id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:62186,Deployability,integrat,integrating,62186,"curve in the frame variable, taken at the present value; 1497/// of other observables defined for this PDF.; 1498///; 1499/// \param[in] frame pointer to RooPlot; 1500/// \param[in] arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10 Ordered arguments; 1501///; 1502/// If a PDF is plotted in a frame in which a dataset has already been plotted, it will; 1503/// show a projected curve integrated over all variables that were present in the shown; 1504/// dataset except for the one on the x-axis. The normalization of the curve will also; 1505/// be adjusted to the event count of the plotted dataset. An informational message; 1506/// will be printed for each projection step that is performed.; 1507///; 1508/// This function takes the following named arguments; 1509/// <table>; 1510/// <tr><th><th> Projection control; 1511/// <tr><td> `Slice(const RooArgSet& set)` <td> Override default projection behaviour by omitting observables listed; 1512/// in set from the projection, i.e. by not integrating over these.; 1513/// Slicing is usually only sensible in discrete observables, by e.g. creating a slice; 1514/// of the PDF at the current value of the category observable.; 1515///; 1516/// <tr><td> `Slice(RooCategory& cat, const char* label)` <td> Override default projection behaviour by omitting the specified category; 1517/// observable from the projection, i.e., by not integrating over all states of this category.; 1518/// The slice is positioned at the given label value. To pass multiple Slice() commands, please use the; 1519/// Slice(std::map<RooCategory*, std::string> const&) argument explained below.; 1520///; 1521/// <tr><td> `Slice(std::map<RooCategory*, std::string> const&)` <td> Omits multiple categories from the projection, as explianed above.; 1522/// Can be used with initializer lists for convenience, e.g.; 1523/// ```{.cpp}; 1524/// pdf.plotOn(frame, Slice({{&tagCategory, ""2tag""}, {&jetCategory, ""3jet""}});; 1525/// ```; 1526///; 1527/// <tr><td> `Project(const RooA",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:62575,Deployability,integrat,integrating,62575," all variables that were present in the shown; 1504/// dataset except for the one on the x-axis. The normalization of the curve will also; 1505/// be adjusted to the event count of the plotted dataset. An informational message; 1506/// will be printed for each projection step that is performed.; 1507///; 1508/// This function takes the following named arguments; 1509/// <table>; 1510/// <tr><th><th> Projection control; 1511/// <tr><td> `Slice(const RooArgSet& set)` <td> Override default projection behaviour by omitting observables listed; 1512/// in set from the projection, i.e. by not integrating over these.; 1513/// Slicing is usually only sensible in discrete observables, by e.g. creating a slice; 1514/// of the PDF at the current value of the category observable.; 1515///; 1516/// <tr><td> `Slice(RooCategory& cat, const char* label)` <td> Override default projection behaviour by omitting the specified category; 1517/// observable from the projection, i.e., by not integrating over all states of this category.; 1518/// The slice is positioned at the given label value. To pass multiple Slice() commands, please use the; 1519/// Slice(std::map<RooCategory*, std::string> const&) argument explained below.; 1520///; 1521/// <tr><td> `Slice(std::map<RooCategory*, std::string> const&)` <td> Omits multiple categories from the projection, as explianed above.; 1522/// Can be used with initializer lists for convenience, e.g.; 1523/// ```{.cpp}; 1524/// pdf.plotOn(frame, Slice({{&tagCategory, ""2tag""}, {&jetCategory, ""3jet""}});; 1525/// ```; 1526///; 1527/// <tr><td> `Project(const RooArgSet& set)` <td> Override default projection behaviour by projecting over observables; 1528/// given in the set, ignoring the default projection behavior. Advanced use only.; 1529///; 1530/// <tr><td> `ProjWData(const RooAbsData& d)` <td> Override default projection _technique_ (integration). For observables present in given dataset; 1531/// projection of PDF is achieved by constructing an avera",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:63475,Deployability,integrat,integration,63475," char* label)` <td> Override default projection behaviour by omitting the specified category; 1517/// observable from the projection, i.e., by not integrating over all states of this category.; 1518/// The slice is positioned at the given label value. To pass multiple Slice() commands, please use the; 1519/// Slice(std::map<RooCategory*, std::string> const&) argument explained below.; 1520///; 1521/// <tr><td> `Slice(std::map<RooCategory*, std::string> const&)` <td> Omits multiple categories from the projection, as explianed above.; 1522/// Can be used with initializer lists for convenience, e.g.; 1523/// ```{.cpp}; 1524/// pdf.plotOn(frame, Slice({{&tagCategory, ""2tag""}, {&jetCategory, ""3jet""}});; 1525/// ```; 1526///; 1527/// <tr><td> `Project(const RooArgSet& set)` <td> Override default projection behaviour by projecting over observables; 1528/// given in the set, ignoring the default projection behavior. Advanced use only.; 1529///; 1530/// <tr><td> `ProjWData(const RooAbsData& d)` <td> Override default projection _technique_ (integration). For observables present in given dataset; 1531/// projection of PDF is achieved by constructing an average over all observable values in given set.; 1532/// Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; 1533///; 1534/// <tr><td> `ProjWData(const RooArgSet& s, const RooAbsData& d)` <td> As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; 1535///; 1536/// <tr><td> `ProjectionRange(const char* rn)` <td> Override default range of projection integrals to a different range specified by given range name.; 1537/// This technique allows you to project a finite width slice in a real-valued observable; 1538///; 1539/// <tr><td> `NumCPU(Int_t ncpu)` <td> Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData); 1540///; 1541///; 1542/// <tr><th><th> Misc content control; 1543/// <tr",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:71241,Deployability,configurat,configuration,71241,"//////////////////; 1629/// Internal back-end function of plotOn() with named arguments; 1630 ; 1631RooPlot* RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& argList) const; 1632{; 1633 // Special handling here if argList contains RangeWithName argument with multiple; 1634 // range names -- Need to translate this call into multiple calls; 1635 ; 1636 RooCmdArg* rcmd = static_cast<RooCmdArg*>(argList.FindObject(""RangeWithName"")) ;; 1637 if (rcmd && TString(rcmd->getString(0)).Contains("","")) {; 1638 ; 1639 // List joint ranges as choice of normalization for all later processing; 1640 RooCmdArg rnorm = RooFit::NormRange(rcmd->getString(0)) ;; 1641 argList.Add(&rnorm) ;; 1642 ; 1643 for (const auto& rangeString : ROOT::Split(rcmd->getString(0), "","")) {; 1644 // Process each range with a separate command with a single range to be plotted; 1645 rcmd->setString(0, rangeString.c_str());; 1646 RooAbsReal::plotOn(frame,argList);; 1647 }; 1648 return frame ;; 1649 ; 1650 }; 1651 ; 1652 // Define configuration for this method; 1653 RooCmdConfig pc(""RooAbsReal::plotOn("" + std::string(GetName()) + "")"");; 1654 pc.defineString(""drawOption"",""DrawOption"",0,""L"") ;; 1655 pc.defineString(""projectionRangeName"",""ProjectionRange"",0,"""",true) ;; 1656 pc.defineString(""curveNameSuffix"",""CurveNameSuffix"",0,"""") ;; 1657 pc.defineString(""sliceCatState"",""SliceCat"",0,"""",true) ;; 1658 pc.defineDouble(""scaleFactor"",""Normalization"",0,1.0) ;; 1659 pc.defineInt(""scaleType"",""Normalization"",0,Relative) ;; 1660 pc.defineSet(""sliceSet"",""SliceVars"",0) ;; 1661 pc.defineObject(""sliceCatList"",""SliceCat"",0,nullptr,true) ;; 1662 // This dummy is needed for plotOn to recognize the ""SliceCatMany"" command.; 1663 // It is not used directly, but the ""SliceCat"" commands are nested in it.; 1664 // Removing this dummy definition results in ""ERROR: unrecognized command: SliceCatMany"".; 1665 pc.defineObject(""dummy1"",""SliceCatMany"",0) ;; 1666 pc.defineSet(""projSet"",""Project"",0) ;; 1667 pc.defineObject(""asymCat"",""Asymmetry"",",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:82062,Deployability,integrat,integration,82062,"ret->getAttMarker()->SetMarkerColor(markerColor) ;; 1849 if (markerStyle!=-999) ret->getAttMarker()->SetMarkerStyle(markerStyle) ;; 1850 if (markerSize!=-999) ret->getAttMarker()->SetMarkerSize(markerSize) ;; 1851 ; 1852 if ((fillColor != -999 || fillStyle != -999) && !drawOpt.Contains(""F"")) {; 1853 coutW(Plotting) << ""Fill color or style was set for plotting \"""" << GetName(); 1854 << ""\"", but these only have an effect when 'DrawOption(\""F\"")' for fill is used at the same time."" << std::endl;; 1855 }; 1856 ; 1857 // Move last inserted object to back to drawing stack if requested; 1858 if (pc.getInt(""moveToBack"") && frame->numItems()>1) {; 1859 frame->drawBefore(frame->getObject(0)->GetName(), frame->getCurve()->GetName());; 1860 }; 1861 ; 1862 return ret ;; 1863}; 1864 ; 1865 ; 1866 ; 1867/// Plotting engine function for internal use; 1868///; 1869/// Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; 1870/// function that occur in the previously plotted dataset are projected via partial integration,; 1871/// otherwise no projections are performed. Optionally, certain projections can be performed; 1872/// by summing over the values present in a provided dataset ('projData'), to correctly; 1873/// project out data dependents that are not properly described by the PDF (e.g. per-event errors).; 1874///; 1875/// The functions value can be multiplied with an optional scale factor. The interpretation; 1876/// of the scale factor is unique for generic real functions, for PDFs there are various interpretations; 1877/// possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details).; 1878///; 1879/// The default projection behaviour can be overridden by supplying an optional set of dependents; 1880/// to project via RooFit command arguments.; 1881//_____________________________________________________________________________; 1882// coverity[PASS_BY_VALUE]; 1883RooPlot* RooAbsReal::plotOn(RooPlot *frame, PlotOpt ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:86256,Deployability,integrat,integrates,86256," << "" represents a slice in "" << sliceSetTmp << std::endl ;; 1929 }; 1930 sliceSet.add(sliceSetTmp) ;; 1931 }; 1932 } else {; 1933 makeProjectionSet(frame->getPlotVar(),frame->getNormVars(),projectedVars,true) ;; 1934 }; 1935 ; 1936 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") projectedVars = "" << projectedVars << "" sliceSet = "" << sliceSet << std::endl ;; 1937 ; 1938 ; 1939 RooArgSet* projDataNeededVars = nullptr ;; 1940 // Take out data-projected dependents from projectedVars; 1941 if (o.projData) {; 1942 projDataNeededVars = projectedVars.selectCommon(projDataVars);; 1943 projectedVars.remove(projDataVars,true,true) ;; 1944 }; 1945 ; 1946 // Get the plot variable and remember its original value; 1947 auto* plotVar = static_cast<RooRealVar*>(frame->getPlotVar());; 1948 double oldPlotVarVal = plotVar->getVal();; 1949 ; 1950 // Inform user about projections; 1951 if (!projectedVars.empty()) {; 1952 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot on "" << plotVar->GetName(); 1953 << "" integrates over variables "" << projectedVars; 1954 << (o.projectionRangeName?Form("" in range %s"",o.projectionRangeName):"""") << std::endl;; 1955 }; 1956 if (projDataNeededVars && !projDataNeededVars->empty()) {; 1957 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot on "" << plotVar->GetName(); 1958 << "" averages using data variables "" << *projDataNeededVars << std::endl ;; 1959 }; 1960 ; 1961 // Create projection integral; 1962 RooArgSet* projectionCompList = nullptr ;; 1963 ; 1964 RooArgSet deps;; 1965 getObservables(frame->getNormVars(), deps) ;; 1966 deps.remove(projectedVars,true,true) ;; 1967 if (projDataNeededVars) {; 1968 deps.remove(*projDataNeededVars,true,true) ;; 1969 }; 1970 deps.remove(*plotVar,true,true) ;; 1971 deps.add(*plotVar) ;; 1972 ; 1973 // Now that we have the final set of dependents, call checkObservables(); 1974 ; 1975 // WVE take out conditional observables; 1976 if (checkObservables(&deps)) {; 1977 coutE(Plotting) ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:97284,Deployability,integrat,integration,97284,"183 }; 2184 ; 2185 // add this new curve to the specified plot frame; 2186 frame->addPlotable(curve, o.drawOptions, o.curveInvisible);; 2187 }; 2188 }; 2189 ; 2190 if (projDataNeededVars) delete projDataNeededVars ;; 2191 delete projectionCompList ;; 2192 plotVar->setVal(oldPlotVarVal); // reset the plot variable value to not disturb the original state; 2193 return frame;; 2194}; 2195 ; 2196 ; 2197//_____________________________________________________________________________; 2198// coverity[PASS_BY_VALUE]; 2199RooPlot* RooAbsReal::plotAsymOn(RooPlot *frame, const RooAbsCategoryLValue& asymCat, PlotOpt o) const; 2200 ; 2201{; 2202 // Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))); 2203 //; 2204 // Plot asymmetry of ourselves, defined as; 2205 //; 2206 // asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ); 2207 //; 2208 // on frame. If frame contains a histogram, all dimensions of the plotted; 2209 // asymmetry function that occur in the previously plotted dataset are projected via partial integration.; 2210 // Otherwise no projections are performed,; 2211 //; 2212 // The asymmetry function can be multiplied with an optional scale factor. The default projection; 2213 // behaviour can be overridden by supplying an optional set of dependents to project.; 2214 ; 2215 // Sanity checks; 2216 if (plotSanityChecks(frame)) return frame ;; 2217 ; 2218 // ProjDataVars is either all projData observables, or the user indicated subset of it; 2219 RooArgSet projDataVars ;; 2220 if (o.projData) {; 2221 if (o.projDataSet) {; 2222 std::unique_ptr<RooArgSet> tmp{o.projData->get()->selectCommon(*o.projDataSet)};; 2223 projDataVars.add(*tmp) ;; 2224 } else {; 2225 projDataVars.add(*o.projData->get()) ;; 2226 }; 2227 }; 2228 ; 2229 // Must depend on asymCat; 2230 if (!dependsOn(asymCat)) {; 2231 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2232 << "") function doesn't depend on asymmetry category "" << asym",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:121705,Deployability,configurat,configuration,121705,"tVal(cenVal-Z*errVal) ;; 2758 plotFunc(*cloneFunc);; 2759 minusVar.push_back(frame->getCurve()) ;; 2760 frame->remove(nullptr,false) ;; 2761 ; 2762 (static_cast<RooRealVar*>(paramList.at(ivar)))->setVal(cenVal) ;; 2763 }; 2764 ; 2765 TMatrixDSym C(paramList.size()) ;; 2766 std::vector<double> errVec(paramList.size()) ;; 2767 for (std::size_t i=0 ; i<paramList.size() ; i++) {; 2768 errVec[i] = sqrt(V(i,i)) ;; 2769 for (std::size_t j=i ; j<paramList.size() ; j++) {; 2770 C(i,j) = V(i,j)/sqrt(V(i,i)*V(j,j)) ;; 2771 C(j,i) = C(i,j) ;; 2772 }; 2773 }; 2774 ; 2775 band = cenCurve->makeErrorBand(plusVar,minusVar,C,Z) ;; 2776 ; 2777 ; 2778 // Cleanup; 2779 delete cloneFunc ;; 2780 for (std::vector<RooCurve*>::iterator i=plusVar.begin() ; i!=plusVar.end() ; ++i) {; 2781 delete (*i) ;; 2782 }; 2783 for (std::vector<RooCurve*>::iterator i=minusVar.begin() ; i!=minusVar.end() ; ++i) {; 2784 delete (*i) ;; 2785 }; 2786 ; 2787 }; 2788 ; 2789 delete cenCurve ;; 2790 if (!band) return frame ;; 2791 ; 2792 // Define configuration for this method; 2793 RooCmdConfig pc(""RooAbsPdf::plotOn("" + std::string(GetName()) + "")"");; 2794 pc.defineString(""drawOption"",""DrawOption"",0,""F"") ;; 2795 pc.defineString(""curveNameSuffix"",""CurveNameSuffix"",0,"""") ;; 2796 pc.defineInt(""lineColor"",""LineColor"",0,-999) ;; 2797 pc.defineInt(""lineStyle"",""LineStyle"",0,-999) ;; 2798 pc.defineInt(""lineWidth"",""LineWidth"",0,-999) ;; 2799 pc.defineInt(""markerColor"",""MarkerColor"",0,-999) ;; 2800 pc.defineInt(""markerStyle"",""MarkerStyle"",0,-999) ;; 2801 pc.defineDouble(""markerSize"",""MarkerSize"",0,-999) ;; 2802 pc.defineInt(""fillColor"",""FillColor"",0,-999) ;; 2803 pc.defineInt(""fillStyle"",""FillStyle"",0,-999) ;; 2804 pc.defineString(""curveName"",""Name"",0,"""") ;; 2805 pc.defineInt(""curveInvisible"",""Invisible"",0,0) ;; 2806 pc.defineInt(""moveToBack"",""MoveToBack"",0,0) ;; 2807 pc.allowUndefined() ;; 2808 ; 2809 // Process & check varargs; 2810 pc.process(argList) ;; 2811 if (!pc.ok(true)) {; 2812 return frame ;; 2813 }; 2814 ; 2815 ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:134039,Deployability,release,release,134039,"urn createTreeReadBuffer<UInt_t >(cleanName, t); }}},; 3060 {""Long64_t"", {""LONG_TREE_BRANCH"", [&](){ return createTreeReadBuffer<Long64_t >(cleanName, t); }}},; 3061 {""ULong64_t"", {""UNSIGNED_LONG_TREE_BRANCH"", [&](){ return createTreeReadBuffer<ULong64_t>(cleanName, t); }}},; 3062 {""Short_t"", {""SHORT_TREE_BRANCH"", [&](){ return createTreeReadBuffer<Short_t >(cleanName, t); }}},; 3063 {""UShort_t"", {""UNSIGNED_SHORT_TREE_BRANCH"", [&](){ return createTreeReadBuffer<UShort_t >(cleanName, t); }}},; 3064 };; 3065 ; 3066 auto typeDetails = typeMap.find(typeName.Data());; 3067 if (typeDetails != typeMap.end()) {; 3068 coutI(DataHandling) << ""RooAbsReal::attachToTree("" << GetName() << "") TTree "" << typeDetails->first << "" branch "" << GetName(); 3069 << "" will be converted to double precision."" << std::endl ;; 3070 setAttribute(typeDetails->second.first.c_str(), true);; 3071 _treeReadBuffer = typeDetails->second.second().release();; 3072 } else {; 3073 if (_treeReadBuffer) {; 3074 delete _treeReadBuffer;; 3075 }; 3076 _treeReadBuffer = nullptr;; 3077 ; 3078 if (!typeName.CompareTo(""Double_t"")) {; 3079 t.SetBranchAddress(cleanName, &_value);; 3080 }; 3081 else {; 3082 coutE(InputArguments) << ""RooAbsReal::attachToTree("" << GetName() << "") data type "" << typeName << "" is not supported."" << std::endl ;; 3083 }; 3084 }; 3085 } else {; 3086 ; 3087 TString format(cleanName);; 3088 format.Append(""/D"");; 3089 branch = t.Branch(cleanName, &_value, (const Text_t*)format, bufSize);; 3090 }; 3091 ; 3092}; 3093 ; 3094 ; 3095 ; 3096////////////////////////////////////////////////////////////////////////////////; 3097/// Fill the tree branch that associated with this object with its current value; 3098 ; 3099void RooAbsReal::fillTreeBranch(TTree& t); 3100{; 3101 // First determine if branch is taken; 3102 TBranch* branch = t.GetBranch(cleanBranchName()) ;; 3103 if (!branch) {; 3104 coutE(Eval) << ""RooAbsReal::fillTreeBranch("" << GetName() << "") ERROR: not attached to tree: "" << cleanBranchNam",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:141192,Deployability,integrat,integration,141192," and do not change matchedArgs.; 3240 ; 3241bool RooAbsReal::matchArgsByName(const RooArgSet &allArgs, RooArgSet &matchedArgs,; 3242 const TList &nameList) const; 3243{; 3244 RooArgSet matched(""matched"");; 3245 bool isMatched(true);; 3246 for(auto * name : static_range_cast<TObjString*>(nameList)) {; 3247 RooAbsArg *found= allArgs.find(name->String().Data());; 3248 if(found) {; 3249 matched.add(*found);; 3250 }; 3251 else {; 3252 isMatched= false;; 3253 break;; 3254 }; 3255 }; 3256 ; 3257 // nameList may not contain multiple entries with the same name; 3258 // that are both matched; 3259 if (isMatched && int(matched.size())!=nameList.GetSize()) {; 3260 isMatched = false ;; 3261 }; 3262 ; 3263 if(isMatched) matchedArgs.add(matched);; 3264 return isMatched;; 3265}; 3266 ; 3267 ; 3268 ; 3269////////////////////////////////////////////////////////////////////////////////; 3270/// Returns the default numeric integration configuration for all RooAbsReals; 3271 ; 3272RooNumIntConfig* RooAbsReal::defaultIntegratorConfig(); 3273{; 3274 return &RooNumIntConfig::defaultConfig() ;; 3275}; 3276 ; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3280/// If this object has no specialized configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:141204,Deployability,configurat,configuration,141204," and do not change matchedArgs.; 3240 ; 3241bool RooAbsReal::matchArgsByName(const RooArgSet &allArgs, RooArgSet &matchedArgs,; 3242 const TList &nameList) const; 3243{; 3244 RooArgSet matched(""matched"");; 3245 bool isMatched(true);; 3246 for(auto * name : static_range_cast<TObjString*>(nameList)) {; 3247 RooAbsArg *found= allArgs.find(name->String().Data());; 3248 if(found) {; 3249 matched.add(*found);; 3250 }; 3251 else {; 3252 isMatched= false;; 3253 break;; 3254 }; 3255 }; 3256 ; 3257 // nameList may not contain multiple entries with the same name; 3258 // that are both matched; 3259 if (isMatched && int(matched.size())!=nameList.GetSize()) {; 3260 isMatched = false ;; 3261 }; 3262 ; 3263 if(isMatched) matchedArgs.add(matched);; 3264 return isMatched;; 3265}; 3266 ; 3267 ; 3268 ; 3269////////////////////////////////////////////////////////////////////////////////; 3270/// Returns the default numeric integration configuration for all RooAbsReals; 3271 ; 3272RooNumIntConfig* RooAbsReal::defaultIntegratorConfig(); 3273{; 3274 return &RooNumIntConfig::defaultConfig() ;; 3275}; 3276 ; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3280/// If this object has no specialized configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:141501,Deployability,integrat,integrator,141501," and do not change matchedArgs.; 3240 ; 3241bool RooAbsReal::matchArgsByName(const RooArgSet &allArgs, RooArgSet &matchedArgs,; 3242 const TList &nameList) const; 3243{; 3244 RooArgSet matched(""matched"");; 3245 bool isMatched(true);; 3246 for(auto * name : static_range_cast<TObjString*>(nameList)) {; 3247 RooAbsArg *found= allArgs.find(name->String().Data());; 3248 if(found) {; 3249 matched.add(*found);; 3250 }; 3251 else {; 3252 isMatched= false;; 3253 break;; 3254 }; 3255 }; 3256 ; 3257 // nameList may not contain multiple entries with the same name; 3258 // that are both matched; 3259 if (isMatched && int(matched.size())!=nameList.GetSize()) {; 3260 isMatched = false ;; 3261 }; 3262 ; 3263 if(isMatched) matchedArgs.add(matched);; 3264 return isMatched;; 3265}; 3266 ; 3267 ; 3268 ; 3269////////////////////////////////////////////////////////////////////////////////; 3270/// Returns the default numeric integration configuration for all RooAbsReals; 3271 ; 3272RooNumIntConfig* RooAbsReal::defaultIntegratorConfig(); 3273{; 3274 return &RooNumIntConfig::defaultConfig() ;; 3275}; 3276 ; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3280/// If this object has no specialized configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:141512,Deployability,configurat,configuration,141512," and do not change matchedArgs.; 3240 ; 3241bool RooAbsReal::matchArgsByName(const RooArgSet &allArgs, RooArgSet &matchedArgs,; 3242 const TList &nameList) const; 3243{; 3244 RooArgSet matched(""matched"");; 3245 bool isMatched(true);; 3246 for(auto * name : static_range_cast<TObjString*>(nameList)) {; 3247 RooAbsArg *found= allArgs.find(name->String().Data());; 3248 if(found) {; 3249 matched.add(*found);; 3250 }; 3251 else {; 3252 isMatched= false;; 3253 break;; 3254 }; 3255 }; 3256 ; 3257 // nameList may not contain multiple entries with the same name; 3258 // that are both matched; 3259 if (isMatched && int(matched.size())!=nameList.GetSize()) {; 3260 isMatched = false ;; 3261 }; 3262 ; 3263 if(isMatched) matchedArgs.add(matched);; 3264 return isMatched;; 3265}; 3266 ; 3267 ; 3268 ; 3269////////////////////////////////////////////////////////////////////////////////; 3270/// Returns the default numeric integration configuration for all RooAbsReals; 3271 ; 3272RooNumIntConfig* RooAbsReal::defaultIntegratorConfig(); 3273{; 3274 return &RooNumIntConfig::defaultConfig() ;; 3275}; 3276 ; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3280/// If this object has no specialized configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:141592,Deployability,configurat,configuration,141592," *found= allArgs.find(name->String().Data());; 3248 if(found) {; 3249 matched.add(*found);; 3250 }; 3251 else {; 3252 isMatched= false;; 3253 break;; 3254 }; 3255 }; 3256 ; 3257 // nameList may not contain multiple entries with the same name; 3258 // that are both matched; 3259 if (isMatched && int(matched.size())!=nameList.GetSize()) {; 3260 isMatched = false ;; 3261 }; 3262 ; 3263 if(isMatched) matchedArgs.add(matched);; 3264 return isMatched;; 3265}; 3266 ; 3267 ; 3268 ; 3269////////////////////////////////////////////////////////////////////////////////; 3270/// Returns the default numeric integration configuration for all RooAbsReals; 3271 ; 3272RooNumIntConfig* RooAbsReal::defaultIntegratorConfig(); 3273{; 3274 return &RooNumIntConfig::defaultConfig() ;; 3275}; 3276 ; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3280/// If this object has no specialized configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304/////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:141897,Deployability,integrat,integrator,141897,"are both matched; 3259 if (isMatched && int(matched.size())!=nameList.GetSize()) {; 3260 isMatched = false ;; 3261 }; 3262 ; 3263 if(isMatched) matchedArgs.add(matched);; 3264 return isMatched;; 3265}; 3266 ; 3267 ; 3268 ; 3269////////////////////////////////////////////////////////////////////////////////; 3270/// Returns the default numeric integration configuration for all RooAbsReals; 3271 ; 3272RooNumIntConfig* RooAbsReal::defaultIntegratorConfig(); 3273{; 3274 return &RooNumIntConfig::defaultConfig() ;; 3275}; 3276 ; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3280/// If this object has no specialized configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all Ro",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:141908,Deployability,configurat,configuration,141908,"are both matched; 3259 if (isMatched && int(matched.size())!=nameList.GetSize()) {; 3260 isMatched = false ;; 3261 }; 3262 ; 3263 if(isMatched) matchedArgs.add(matched);; 3264 return isMatched;; 3265}; 3266 ; 3267 ; 3268 ; 3269////////////////////////////////////////////////////////////////////////////////; 3270/// Returns the default numeric integration configuration for all RooAbsReals; 3271 ; 3272RooNumIntConfig* RooAbsReal::defaultIntegratorConfig(); 3273{; 3274 return &RooNumIntConfig::defaultConfig() ;; 3275}; 3276 ; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3280/// If this object has no specialized configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all Ro",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:141988,Deployability,configurat,configuration,141988," for all RooAbsReals; 3271 ; 3272RooNumIntConfig* RooAbsReal::defaultIntegratorConfig(); 3273{; 3274 return &RooNumIntConfig::defaultConfig() ;; 3275}; 3276 ; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3280/// If this object has no specialized configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return th",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:142107,Deployability,integrat,integrator,142107," for all RooAbsReals; 3271 ; 3272RooNumIntConfig* RooAbsReal::defaultIntegratorConfig(); 3273{; 3274 return &RooNumIntConfig::defaultConfig() ;; 3275}; 3276 ; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3280/// If this object has no specialized configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return th",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:142127,Deployability,configurat,configuration,142127," for all RooAbsReals; 3271 ; 3272RooNumIntConfig* RooAbsReal::defaultIntegratorConfig(); 3273{; 3274 return &RooNumIntConfig::defaultConfig() ;; 3275}; 3276 ; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3280/// If this object has no specialized configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return th",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:142153,Deployability,install,installed,142153," for all RooAbsReals; 3271 ; 3272RooNumIntConfig* RooAbsReal::defaultIntegratorConfig(); 3273{; 3274 return &RooNumIntConfig::defaultConfig() ;; 3275}; 3276 ; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3280/// If this object has no specialized configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return th",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:142178,Deployability,configurat,configuration,142178," for all RooAbsReals; 3271 ; 3272RooNumIntConfig* RooAbsReal::defaultIntegratorConfig(); 3273{; 3274 return &RooNumIntConfig::defaultConfig() ;; 3275}; 3276 ; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3280/// If this object has no specialized configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return th",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:142639,Deployability,integrat,integration,142639,"zed configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:142651,Deployability,configurat,configuration,142651,"zed configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:142713,Deployability,configurat,configuration,142713,"ialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:142765,Deployability,configurat,configuration,142765,"ialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:142823,Deployability,configurat,configuration,142823,"ialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:143227,Deployability,integrat,integration,143227,"ialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:143239,Deployability,configurat,configuration,143239,"ialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:143301,Deployability,configurat,configuration,143301,"default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{; 3337 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(config);; 3338}; 3339 ; 3340 ; 3341 ; 3342////////////////////////////////////////////////////////////////////////////////; 3343/// Remove the specialized numeric integration configuration associated; 3344/// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:143353,Deployability,configurat,configuration,143353,"default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{; 3337 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(config);; 3338}; 3339 ; 3340 ; 3341 ; 3342////////////////////////////////////////////////////////////////////////////////; 3343/// Remove the specialized numeric integration configuration associated; 3344/// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:143411,Deployability,configurat,configuration,143411,"default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{; 3337 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(config);; 3338}; 3339 ; 3340 ; 3341 ; 3342////////////////////////////////////////////////////////////////////////////////; 3343/// Remove the specialized numeric integration configuration associated; 3344/// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:143799,Deployability,integrat,integrator,143799,"default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{; 3337 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(config);; 3338}; 3339 ; 3340 ; 3341 ; 3342////////////////////////////////////////////////////////////////////////////////; 3343/// Remove the specialized numeric integration configuration associated; 3344/// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:143810,Deployability,configurat,configuration,143810,"default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{; 3337 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(config);; 3338}; 3339 ; 3340 ; 3341 ; 3342////////////////////////////////////////////////////////////////////////////////; 3343/// Remove the specialized numeric integration configuration associated; 3344/// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:143843,Deployability,integrat,integration,143843,"default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{; 3337 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(config);; 3338}; 3339 ; 3340 ; 3341 ; 3342////////////////////////////////////////////////////////////////////////////////; 3343/// Remove the specialized numeric integration configuration associated; 3344/// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:143864,Deployability,configurat,configuration,143864,"default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{; 3337 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(config);; 3338}; 3339 ; 3340 ; 3341 ; 3342////////////////////////////////////////////////////////////////////////////////; 3343/// Remove the specialized numeric integration configuration associated; 3344/// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:144208,Deployability,integrat,integration,144208,"default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{; 3337 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(config);; 3338}; 3339 ; 3340 ; 3341 ; 3342////////////////////////////////////////////////////////////////////////////////; 3343/// Remove the specialized numeric integration configuration associated; 3344/// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:144220,Deployability,configurat,configuration,144220,"default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{; 3337 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(config);; 3338}; 3339 ; 3340 ; 3341 ; 3342////////////////////////////////////////////////////////////////////////////////; 3343/// Remove the specialized numeric integration configuration associated; 3344/// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:158650,Deployability,integrat,integration,158650," RooArgSet& obs, RooArgSet& orderedObs) const; 3695{; 3696 // Dummy implementation, do nothing; 3697 orderedObs.removeAll() ;; 3698 orderedObs.add(obs) ;; 3699}; 3700 ; 3701 ; 3702 ; 3703////////////////////////////////////////////////////////////////////////////////; 3704/// Calls createRunningIntegral(const RooArgSet&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&); 3705 ; 3706RooFit::OwningPtr<RooAbsReal> RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset); 3707{; 3708 return createRunningIntegral(iset,RooFit::SupNormSet(nset)) ;; 3709}; 3710 ; 3711 ; 3712 ; 3713////////////////////////////////////////////////////////////////////////////////; 3714/// Create an object that represents the running integral of the function over one or more observables listed in iset, i.e.; 3715/// \f[; 3716/// \int_{x_\mathrm{lo}}^x f(x') \, \mathrm{d}x'; 3717/// \f]; 3718///; 3719/// The actual integration calculation is only performed when the return object is evaluated. The name; 3720/// of the integral object is automatically constructed from the name of the input function, the variables; 3721/// it integrates and the range integrates over. The default strategy to calculate the running integrals is; 3722///; 3723/// - If the integrand (this object) supports analytical integration, construct an integral object; 3724/// that calculate the running integrals value by calculating the analytical integral each; 3725/// time the running integral object is evaluated; 3726///; 3727/// - If the integrand (this object) requires numeric integration to construct the running integral; 3728/// create an object of class RooNumRunningInt which first samples the entire function and integrates; 3729/// the sampled function numerically. This method has superior performance as there is no need to; 3730/// perform a full (numeric) integration for each evaluation of the running in",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:158862,Deployability,integrat,integrates,158862,"; 3703////////////////////////////////////////////////////////////////////////////////; 3704/// Calls createRunningIntegral(const RooArgSet&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&); 3705 ; 3706RooFit::OwningPtr<RooAbsReal> RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset); 3707{; 3708 return createRunningIntegral(iset,RooFit::SupNormSet(nset)) ;; 3709}; 3710 ; 3711 ; 3712 ; 3713////////////////////////////////////////////////////////////////////////////////; 3714/// Create an object that represents the running integral of the function over one or more observables listed in iset, i.e.; 3715/// \f[; 3716/// \int_{x_\mathrm{lo}}^x f(x') \, \mathrm{d}x'; 3717/// \f]; 3718///; 3719/// The actual integration calculation is only performed when the return object is evaluated. The name; 3720/// of the integral object is automatically constructed from the name of the input function, the variables; 3721/// it integrates and the range integrates over. The default strategy to calculate the running integrals is; 3722///; 3723/// - If the integrand (this object) supports analytical integration, construct an integral object; 3724/// that calculate the running integrals value by calculating the analytical integral each; 3725/// time the running integral object is evaluated; 3726///; 3727/// - If the integrand (this object) requires numeric integration to construct the running integral; 3728/// create an object of class RooNumRunningInt which first samples the entire function and integrates; 3729/// the sampled function numerically. This method has superior performance as there is no need to; 3730/// perform a full (numeric) integration for each evaluation of the running integral object, but; 3731/// only when one of its parameters has changed.; 3732///; 3733/// The choice of strategy can be changed with the ScanAll() argument, which forces the use of ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:158887,Deployability,integrat,integrates,158887,"; 3703////////////////////////////////////////////////////////////////////////////////; 3704/// Calls createRunningIntegral(const RooArgSet&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&); 3705 ; 3706RooFit::OwningPtr<RooAbsReal> RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset); 3707{; 3708 return createRunningIntegral(iset,RooFit::SupNormSet(nset)) ;; 3709}; 3710 ; 3711 ; 3712 ; 3713////////////////////////////////////////////////////////////////////////////////; 3714/// Create an object that represents the running integral of the function over one or more observables listed in iset, i.e.; 3715/// \f[; 3716/// \int_{x_\mathrm{lo}}^x f(x') \, \mathrm{d}x'; 3717/// \f]; 3718///; 3719/// The actual integration calculation is only performed when the return object is evaluated. The name; 3720/// of the integral object is automatically constructed from the name of the input function, the variables; 3721/// it integrates and the range integrates over. The default strategy to calculate the running integrals is; 3722///; 3723/// - If the integrand (this object) supports analytical integration, construct an integral object; 3724/// that calculate the running integrals value by calculating the analytical integral each; 3725/// time the running integral object is evaluated; 3726///; 3727/// - If the integrand (this object) requires numeric integration to construct the running integral; 3728/// create an object of class RooNumRunningInt which first samples the entire function and integrates; 3729/// the sampled function numerically. This method has superior performance as there is no need to; 3730/// perform a full (numeric) integration for each evaluation of the running integral object, but; 3731/// only when one of its parameters has changed.; 3732///; 3733/// The choice of strategy can be changed with the ScanAll() argument, which forces the use of ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:159034,Deployability,integrat,integration,159034,"et, const RooArgSet& nset); 3707{; 3708 return createRunningIntegral(iset,RooFit::SupNormSet(nset)) ;; 3709}; 3710 ; 3711 ; 3712 ; 3713////////////////////////////////////////////////////////////////////////////////; 3714/// Create an object that represents the running integral of the function over one or more observables listed in iset, i.e.; 3715/// \f[; 3716/// \int_{x_\mathrm{lo}}^x f(x') \, \mathrm{d}x'; 3717/// \f]; 3718///; 3719/// The actual integration calculation is only performed when the return object is evaluated. The name; 3720/// of the integral object is automatically constructed from the name of the input function, the variables; 3721/// it integrates and the range integrates over. The default strategy to calculate the running integrals is; 3722///; 3723/// - If the integrand (this object) supports analytical integration, construct an integral object; 3724/// that calculate the running integrals value by calculating the analytical integral each; 3725/// time the running integral object is evaluated; 3726///; 3727/// - If the integrand (this object) requires numeric integration to construct the running integral; 3728/// create an object of class RooNumRunningInt which first samples the entire function and integrates; 3729/// the sampled function numerically. This method has superior performance as there is no need to; 3730/// perform a full (numeric) integration for each evaluation of the running integral object, but; 3731/// only when one of its parameters has changed.; 3732///; 3733/// The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; 3734/// scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); 3735/// argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; 3736/// granularity for the scanning technique can be controlled with the ScanParameters technique; 3737/// which allows to specify the number of samples to be taken, a",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:159295,Deployability,integrat,integration,159295,"et, const RooArgSet& nset); 3707{; 3708 return createRunningIntegral(iset,RooFit::SupNormSet(nset)) ;; 3709}; 3710 ; 3711 ; 3712 ; 3713////////////////////////////////////////////////////////////////////////////////; 3714/// Create an object that represents the running integral of the function over one or more observables listed in iset, i.e.; 3715/// \f[; 3716/// \int_{x_\mathrm{lo}}^x f(x') \, \mathrm{d}x'; 3717/// \f]; 3718///; 3719/// The actual integration calculation is only performed when the return object is evaluated. The name; 3720/// of the integral object is automatically constructed from the name of the input function, the variables; 3721/// it integrates and the range integrates over. The default strategy to calculate the running integrals is; 3722///; 3723/// - If the integrand (this object) supports analytical integration, construct an integral object; 3724/// that calculate the running integrals value by calculating the analytical integral each; 3725/// time the running integral object is evaluated; 3726///; 3727/// - If the integrand (this object) requires numeric integration to construct the running integral; 3728/// create an object of class RooNumRunningInt which first samples the entire function and integrates; 3729/// the sampled function numerically. This method has superior performance as there is no need to; 3730/// perform a full (numeric) integration for each evaluation of the running integral object, but; 3731/// only when one of its parameters has changed.; 3732///; 3733/// The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; 3734/// scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); 3735/// argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; 3736/// granularity for the scanning technique can be controlled with the ScanParameters technique; 3737/// which allows to specify the number of samples to be taken, a",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:159437,Deployability,integrat,integrates,159437,"et, const RooArgSet& nset); 3707{; 3708 return createRunningIntegral(iset,RooFit::SupNormSet(nset)) ;; 3709}; 3710 ; 3711 ; 3712 ; 3713////////////////////////////////////////////////////////////////////////////////; 3714/// Create an object that represents the running integral of the function over one or more observables listed in iset, i.e.; 3715/// \f[; 3716/// \int_{x_\mathrm{lo}}^x f(x') \, \mathrm{d}x'; 3717/// \f]; 3718///; 3719/// The actual integration calculation is only performed when the return object is evaluated. The name; 3720/// of the integral object is automatically constructed from the name of the input function, the variables; 3721/// it integrates and the range integrates over. The default strategy to calculate the running integrals is; 3722///; 3723/// - If the integrand (this object) supports analytical integration, construct an integral object; 3724/// that calculate the running integrals value by calculating the analytical integral each; 3725/// time the running integral object is evaluated; 3726///; 3727/// - If the integrand (this object) requires numeric integration to construct the running integral; 3728/// create an object of class RooNumRunningInt which first samples the entire function and integrates; 3729/// the sampled function numerically. This method has superior performance as there is no need to; 3730/// perform a full (numeric) integration for each evaluation of the running integral object, but; 3731/// only when one of its parameters has changed.; 3732///; 3733/// The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; 3734/// scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); 3735/// argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; 3736/// granularity for the scanning technique can be controlled with the ScanParameters technique; 3737/// which allows to specify the number of samples to be taken, a",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:159585,Deployability,integrat,integration,159585,"thrm{d}x'; 3717/// \f]; 3718///; 3719/// The actual integration calculation is only performed when the return object is evaluated. The name; 3720/// of the integral object is automatically constructed from the name of the input function, the variables; 3721/// it integrates and the range integrates over. The default strategy to calculate the running integrals is; 3722///; 3723/// - If the integrand (this object) supports analytical integration, construct an integral object; 3724/// that calculate the running integrals value by calculating the analytical integral each; 3725/// time the running integral object is evaluated; 3726///; 3727/// - If the integrand (this object) requires numeric integration to construct the running integral; 3728/// create an object of class RooNumRunningInt which first samples the entire function and integrates; 3729/// the sampled function numerically. This method has superior performance as there is no need to; 3730/// perform a full (numeric) integration for each evaluation of the running integral object, but; 3731/// only when one of its parameters has changed.; 3732///; 3733/// The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; 3734/// scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); 3735/// argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; 3736/// granularity for the scanning technique can be controlled with the ScanParameters technique; 3737/// which allows to specify the number of samples to be taken, and to which order the resulting; 3738/// running integral should be interpolated. The default values are 1000 samples and 2nd order; 3739/// interpolation.; 3740///; 3741/// The following named arguments are accepted; 3742/// | | Effect on integral creation; 3743/// |-|-------------------------------; 3744/// | `SupNormSet(const RooArgSet&)` | Observables over which should be normalized _in additio",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:159959,Deployability,integrat,integrate,159959,"t integrates and the range integrates over. The default strategy to calculate the running integrals is; 3722///; 3723/// - If the integrand (this object) supports analytical integration, construct an integral object; 3724/// that calculate the running integrals value by calculating the analytical integral each; 3725/// time the running integral object is evaluated; 3726///; 3727/// - If the integrand (this object) requires numeric integration to construct the running integral; 3728/// create an object of class RooNumRunningInt which first samples the entire function and integrates; 3729/// the sampled function numerically. This method has superior performance as there is no need to; 3730/// perform a full (numeric) integration for each evaluation of the running integral object, but; 3731/// only when one of its parameters has changed.; 3732///; 3733/// The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; 3734/// scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); 3735/// argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; 3736/// granularity for the scanning technique can be controlled with the ScanParameters technique; 3737/// which allows to specify the number of samples to be taken, and to which order the resulting; 3738/// running integral should be interpolated. The default values are 1000 samples and 2nd order; 3739/// interpolation.; 3740///; 3741/// The following named arguments are accepted; 3742/// | | Effect on integral creation; 3743/// |-|-------------------------------; 3744/// | `SupNormSet(const RooArgSet&)` | Observables over which should be normalized _in addition_ to the integration observables; 3745/// | `ScanParameters(Int_t nbins, Int_t intOrder)` | Parameters for scanning technique of making CDF: number of sampled bins and order of interpolation applied on numeric cdf; 3746/// | `ScanNum()` | Apply scanning techniq",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:160608,Deployability,integrat,integration,160608," ScanNone(); 3735/// argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; 3736/// granularity for the scanning technique can be controlled with the ScanParameters technique; 3737/// which allows to specify the number of samples to be taken, and to which order the resulting; 3738/// running integral should be interpolated. The default values are 1000 samples and 2nd order; 3739/// interpolation.; 3740///; 3741/// The following named arguments are accepted; 3742/// | | Effect on integral creation; 3743/// |-|-------------------------------; 3744/// | `SupNormSet(const RooArgSet&)` | Observables over which should be normalized _in addition_ to the integration observables; 3745/// | `ScanParameters(Int_t nbins, Int_t intOrder)` | Parameters for scanning technique of making CDF: number of sampled bins and order of interpolation applied on numeric cdf; 3746/// | `ScanNum()` | Apply scanning technique if cdf integral involves numeric integration; 3747/// | `ScanAll()` | Always apply scanning technique; 3748/// | `ScanNone()` | Never apply scanning technique; 3749 ; 3750RooFit::OwningPtr<RooAbsReal> RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2,; 3751 const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5,; 3752 const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 3753{; 3754 // Define configuration for this method; 3755 RooCmdConfig pc(""RooAbsReal::createRunningIntegral("" + std::string(GetName()) + "")"");; 3756 pc.defineSet(""supNormSet"",""SupNormSet"",0,nullptr) ;; 3757 pc.defineInt(""numScanBins"",""ScanParameters"",0,1000) ;; 3758 pc.defineInt(""intOrder"",""ScanParameters"",1,2) ;; 3759 pc.defineInt(""doScanNum"",""ScanNum"",0,1) ;; 3760 pc.defineInt(""doScanAll"",""ScanAll"",0,0) ;; 3761 pc.defineInt(""doScanNon"",""ScanNone"",0,0) ;; 3762 pc.defineMutex(""ScanNum"",""ScanAll"",""ScanNone"") ;; 3763 ; 3764 // Process & check varargs; 3765 pc.process(arg1,arg2,arg3,arg4,a",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:160896,Deployability,integrat,integration,160896," ScanNone(); 3735/// argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; 3736/// granularity for the scanning technique can be controlled with the ScanParameters technique; 3737/// which allows to specify the number of samples to be taken, and to which order the resulting; 3738/// running integral should be interpolated. The default values are 1000 samples and 2nd order; 3739/// interpolation.; 3740///; 3741/// The following named arguments are accepted; 3742/// | | Effect on integral creation; 3743/// |-|-------------------------------; 3744/// | `SupNormSet(const RooArgSet&)` | Observables over which should be normalized _in addition_ to the integration observables; 3745/// | `ScanParameters(Int_t nbins, Int_t intOrder)` | Parameters for scanning technique of making CDF: number of sampled bins and order of interpolation applied on numeric cdf; 3746/// | `ScanNum()` | Apply scanning technique if cdf integral involves numeric integration; 3747/// | `ScanAll()` | Always apply scanning technique; 3748/// | `ScanNone()` | Never apply scanning technique; 3749 ; 3750RooFit::OwningPtr<RooAbsReal> RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2,; 3751 const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5,; 3752 const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 3753{; 3754 // Define configuration for this method; 3755 RooCmdConfig pc(""RooAbsReal::createRunningIntegral("" + std::string(GetName()) + "")"");; 3756 pc.defineSet(""supNormSet"",""SupNormSet"",0,nullptr) ;; 3757 pc.defineInt(""numScanBins"",""ScanParameters"",0,1000) ;; 3758 pc.defineInt(""intOrder"",""ScanParameters"",1,2) ;; 3759 pc.defineInt(""doScanNum"",""ScanNum"",0,1) ;; 3760 pc.defineInt(""doScanAll"",""ScanAll"",0,0) ;; 3761 pc.defineInt(""doScanNon"",""ScanNone"",0,0) ;; 3762 pc.defineMutex(""ScanNum"",""ScanAll"",""ScanNone"") ;; 3763 ; 3764 // Process & check varargs; 3765 pc.process(arg1,arg2,arg3,arg4,a",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:161340,Deployability,configurat,configuration,161340," ScanNone(); 3735/// argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; 3736/// granularity for the scanning technique can be controlled with the ScanParameters technique; 3737/// which allows to specify the number of samples to be taken, and to which order the resulting; 3738/// running integral should be interpolated. The default values are 1000 samples and 2nd order; 3739/// interpolation.; 3740///; 3741/// The following named arguments are accepted; 3742/// | | Effect on integral creation; 3743/// |-|-------------------------------; 3744/// | `SupNormSet(const RooArgSet&)` | Observables over which should be normalized _in addition_ to the integration observables; 3745/// | `ScanParameters(Int_t nbins, Int_t intOrder)` | Parameters for scanning technique of making CDF: number of sampled bins and order of interpolation applied on numeric cdf; 3746/// | `ScanNum()` | Apply scanning technique if cdf integral involves numeric integration; 3747/// | `ScanAll()` | Always apply scanning technique; 3748/// | `ScanNone()` | Never apply scanning technique; 3749 ; 3750RooFit::OwningPtr<RooAbsReal> RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2,; 3751 const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5,; 3752 const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 3753{; 3754 // Define configuration for this method; 3755 RooCmdConfig pc(""RooAbsReal::createRunningIntegral("" + std::string(GetName()) + "")"");; 3756 pc.defineSet(""supNormSet"",""SupNormSet"",0,nullptr) ;; 3757 pc.defineInt(""numScanBins"",""ScanParameters"",0,1000) ;; 3758 pc.defineInt(""intOrder"",""ScanParameters"",1,2) ;; 3759 pc.defineInt(""doScanNum"",""ScanNum"",0,1) ;; 3760 pc.defineInt(""doScanAll"",""ScanAll"",0,0) ;; 3761 pc.defineInt(""doScanNon"",""ScanNone"",0,0) ;; 3762 pc.defineMutex(""ScanNum"",""ScanAll"",""ScanNone"") ;; 3763 ; 3764 // Process & check varargs; 3765 pc.process(arg1,arg2,arg3,arg4,a",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:162945,Deployability,integrat,integration,162945,"s from named arguments; 3771 RooArgSet nset ;; 3772 if (const RooArgSet* snset = pc.getSet(""supNormSet"",nullptr)) {; 3773 nset.add(*snset) ;; 3774 }; 3775 Int_t numScanBins = pc.getInt(""numScanBins"") ;; 3776 Int_t intOrder = pc.getInt(""intOrder"") ;; 3777 Int_t doScanNum = pc.getInt(""doScanNum"") ;; 3778 Int_t doScanAll = pc.getInt(""doScanAll"") ;; 3779 Int_t doScanNon = pc.getInt(""doScanNon"") ;; 3780 ; 3781 // If scanning technique is not requested make integral-based cdf and return; 3782 if (doScanNon) {; 3783 return createIntRI(iset,nset) ;; 3784 }; 3785 if (doScanAll) {; 3786 return createScanRI(iset,nset,numScanBins,intOrder) ;; 3787 }; 3788 if (doScanNum) {; 3789 std::unique_ptr<RooAbsReal> tmp{createIntegral(iset)} ;; 3790 Int_t isNum= !static_cast<RooRealIntegral&>(*tmp).numIntRealVars().empty();; 3791 ; 3792 if (isNum) {; 3793 coutI(NumIntegration) << ""RooAbsPdf::createRunningIntegral("" << GetName() << "") integration over observable(s) "" << iset << "" involves numeric integration,"" << std::endl; 3794 << "" constructing cdf though numeric integration of sampled pdf in "" << numScanBins << "" bins and applying order ""; 3795 << intOrder << "" interpolation on integrated histogram."" << std::endl; 3796 << "" To override this choice of technique use argument ScanNone(), to change scan parameters use ScanParameters(nbins,order) argument"" << std::endl ;; 3797 }; 3798 ; 3799 return isNum ? createScanRI(iset,nset,numScanBins,intOrder) : createIntRI(iset,nset) ;; 3800 }; 3801 return nullptr;; 3802}; 3803 ; 3804 ; 3805 ; 3806////////////////////////////////////////////////////////////////////////////////; 3807/// Utility function for createRunningIntegral that construct an object; 3808/// implementing the numeric scanning technique for calculating the running integral; 3809 ; 3810RooFit::OwningPtr<RooAbsReal> RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); 3811{; 3812 std::string name = std::string(GetName()) + ""_NUMRUNI",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:163008,Deployability,integrat,integration,163008,"s from named arguments; 3771 RooArgSet nset ;; 3772 if (const RooArgSet* snset = pc.getSet(""supNormSet"",nullptr)) {; 3773 nset.add(*snset) ;; 3774 }; 3775 Int_t numScanBins = pc.getInt(""numScanBins"") ;; 3776 Int_t intOrder = pc.getInt(""intOrder"") ;; 3777 Int_t doScanNum = pc.getInt(""doScanNum"") ;; 3778 Int_t doScanAll = pc.getInt(""doScanAll"") ;; 3779 Int_t doScanNon = pc.getInt(""doScanNon"") ;; 3780 ; 3781 // If scanning technique is not requested make integral-based cdf and return; 3782 if (doScanNon) {; 3783 return createIntRI(iset,nset) ;; 3784 }; 3785 if (doScanAll) {; 3786 return createScanRI(iset,nset,numScanBins,intOrder) ;; 3787 }; 3788 if (doScanNum) {; 3789 std::unique_ptr<RooAbsReal> tmp{createIntegral(iset)} ;; 3790 Int_t isNum= !static_cast<RooRealIntegral&>(*tmp).numIntRealVars().empty();; 3791 ; 3792 if (isNum) {; 3793 coutI(NumIntegration) << ""RooAbsPdf::createRunningIntegral("" << GetName() << "") integration over observable(s) "" << iset << "" involves numeric integration,"" << std::endl; 3794 << "" constructing cdf though numeric integration of sampled pdf in "" << numScanBins << "" bins and applying order ""; 3795 << intOrder << "" interpolation on integrated histogram."" << std::endl; 3796 << "" To override this choice of technique use argument ScanNone(), to change scan parameters use ScanParameters(nbins,order) argument"" << std::endl ;; 3797 }; 3798 ; 3799 return isNum ? createScanRI(iset,nset,numScanBins,intOrder) : createIntRI(iset,nset) ;; 3800 }; 3801 return nullptr;; 3802}; 3803 ; 3804 ; 3805 ; 3806////////////////////////////////////////////////////////////////////////////////; 3807/// Utility function for createRunningIntegral that construct an object; 3808/// implementing the numeric scanning technique for calculating the running integral; 3809 ; 3810RooFit::OwningPtr<RooAbsReal> RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); 3811{; 3812 std::string name = std::string(GetName()) + ""_NUMRUNI",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:163078,Deployability,integrat,integration,163078,"s from named arguments; 3771 RooArgSet nset ;; 3772 if (const RooArgSet* snset = pc.getSet(""supNormSet"",nullptr)) {; 3773 nset.add(*snset) ;; 3774 }; 3775 Int_t numScanBins = pc.getInt(""numScanBins"") ;; 3776 Int_t intOrder = pc.getInt(""intOrder"") ;; 3777 Int_t doScanNum = pc.getInt(""doScanNum"") ;; 3778 Int_t doScanAll = pc.getInt(""doScanAll"") ;; 3779 Int_t doScanNon = pc.getInt(""doScanNon"") ;; 3780 ; 3781 // If scanning technique is not requested make integral-based cdf and return; 3782 if (doScanNon) {; 3783 return createIntRI(iset,nset) ;; 3784 }; 3785 if (doScanAll) {; 3786 return createScanRI(iset,nset,numScanBins,intOrder) ;; 3787 }; 3788 if (doScanNum) {; 3789 std::unique_ptr<RooAbsReal> tmp{createIntegral(iset)} ;; 3790 Int_t isNum= !static_cast<RooRealIntegral&>(*tmp).numIntRealVars().empty();; 3791 ; 3792 if (isNum) {; 3793 coutI(NumIntegration) << ""RooAbsPdf::createRunningIntegral("" << GetName() << "") integration over observable(s) "" << iset << "" involves numeric integration,"" << std::endl; 3794 << "" constructing cdf though numeric integration of sampled pdf in "" << numScanBins << "" bins and applying order ""; 3795 << intOrder << "" interpolation on integrated histogram."" << std::endl; 3796 << "" To override this choice of technique use argument ScanNone(), to change scan parameters use ScanParameters(nbins,order) argument"" << std::endl ;; 3797 }; 3798 ; 3799 return isNum ? createScanRI(iset,nset,numScanBins,intOrder) : createIntRI(iset,nset) ;; 3800 }; 3801 return nullptr;; 3802}; 3803 ; 3804 ; 3805 ; 3806////////////////////////////////////////////////////////////////////////////////; 3807/// Utility function for createRunningIntegral that construct an object; 3808/// implementing the numeric scanning technique for calculating the running integral; 3809 ; 3810RooFit::OwningPtr<RooAbsReal> RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); 3811{; 3812 std::string name = std::string(GetName()) + ""_NUMRUNI",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:163196,Deployability,integrat,integrated,163196,"s from named arguments; 3771 RooArgSet nset ;; 3772 if (const RooArgSet* snset = pc.getSet(""supNormSet"",nullptr)) {; 3773 nset.add(*snset) ;; 3774 }; 3775 Int_t numScanBins = pc.getInt(""numScanBins"") ;; 3776 Int_t intOrder = pc.getInt(""intOrder"") ;; 3777 Int_t doScanNum = pc.getInt(""doScanNum"") ;; 3778 Int_t doScanAll = pc.getInt(""doScanAll"") ;; 3779 Int_t doScanNon = pc.getInt(""doScanNon"") ;; 3780 ; 3781 // If scanning technique is not requested make integral-based cdf and return; 3782 if (doScanNon) {; 3783 return createIntRI(iset,nset) ;; 3784 }; 3785 if (doScanAll) {; 3786 return createScanRI(iset,nset,numScanBins,intOrder) ;; 3787 }; 3788 if (doScanNum) {; 3789 std::unique_ptr<RooAbsReal> tmp{createIntegral(iset)} ;; 3790 Int_t isNum= !static_cast<RooRealIntegral&>(*tmp).numIntRealVars().empty();; 3791 ; 3792 if (isNum) {; 3793 coutI(NumIntegration) << ""RooAbsPdf::createRunningIntegral("" << GetName() << "") integration over observable(s) "" << iset << "" involves numeric integration,"" << std::endl; 3794 << "" constructing cdf though numeric integration of sampled pdf in "" << numScanBins << "" bins and applying order ""; 3795 << intOrder << "" interpolation on integrated histogram."" << std::endl; 3796 << "" To override this choice of technique use argument ScanNone(), to change scan parameters use ScanParameters(nbins,order) argument"" << std::endl ;; 3797 }; 3798 ; 3799 return isNum ? createScanRI(iset,nset,numScanBins,intOrder) : createIntRI(iset,nset) ;; 3800 }; 3801 return nullptr;; 3802}; 3803 ; 3804 ; 3805 ; 3806////////////////////////////////////////////////////////////////////////////////; 3807/// Utility function for createRunningIntegral that construct an object; 3808/// implementing the numeric scanning technique for calculating the running integral; 3809 ; 3810RooFit::OwningPtr<RooAbsReal> RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); 3811{; 3812 std::string name = std::string(GetName()) + ""_NUMRUNI",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:164628,Deployability,integrat,integration,164628,"////////////; 3807/// Utility function for createRunningIntegral that construct an object; 3808/// implementing the numeric scanning technique for calculating the running integral; 3809 ; 3810RooFit::OwningPtr<RooAbsReal> RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); 3811{; 3812 std::string name = std::string(GetName()) + ""_NUMRUNINT_"" + integralNameSuffix(iset,&nset).Data() ;; 3813 RooRealVar* ivar = static_cast<RooRealVar*>(iset.first()) ;; 3814 ivar->setBins(numScanBins,""numcdf"") ;; 3815 auto ret = std::make_unique<RooNumRunningInt>(name.c_str(),name.c_str(),*this,*ivar,""numrunint"") ;; 3816 ret->setInterpolationOrder(intOrder) ;; 3817 return RooFit::makeOwningPtr<RooAbsReal>(std::move(ret));; 3818}; 3819 ; 3820 ; 3821 ; 3822////////////////////////////////////////////////////////////////////////////////; 3823/// Utility function for createRunningIntegral. It creates an; 3824/// object implementing the standard (analytical) integration; 3825/// technique for calculating the running integral.; 3826 ; 3827RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset); 3828{; 3829 // Make list of input arguments keeping only RooRealVars; 3830 RooArgList ilist ;; 3831 for(RooAbsArg * arg : iset) {; 3832 if (dynamic_cast<RooRealVar*>(arg)) {; 3833 ilist.add(*arg) ;; 3834 } else {; 3835 coutW(InputArguments) << ""RooAbsPdf::createRunningIntegral("" << GetName() << "") WARNING ignoring non-RooRealVar input argument "" << arg->GetName() << std::endl ;; 3836 }; 3837 }; 3838 ; 3839 RooArgList cloneList ;; 3840 RooArgList loList ;; 3841 RooArgSet clonedBranchNodes ;; 3842 ; 3843 // Setup customizer that stores all cloned branches in our non-owning list; 3844 RooCustomizer cust(*this,""cdf"") ;; 3845 cust.setCloneBranchSet(clonedBranchNodes) ;; 3846 cust.setOwning(false) ;; 3847 ; 3848 // Make integration observable x_prime for each observable x as well as an x_lowbound; 3849 for(auto ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:165534,Deployability,integrat,integration,165534,"tandard (analytical) integration; 3825/// technique for calculating the running integral.; 3826 ; 3827RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset); 3828{; 3829 // Make list of input arguments keeping only RooRealVars; 3830 RooArgList ilist ;; 3831 for(RooAbsArg * arg : iset) {; 3832 if (dynamic_cast<RooRealVar*>(arg)) {; 3833 ilist.add(*arg) ;; 3834 } else {; 3835 coutW(InputArguments) << ""RooAbsPdf::createRunningIntegral("" << GetName() << "") WARNING ignoring non-RooRealVar input argument "" << arg->GetName() << std::endl ;; 3836 }; 3837 }; 3838 ; 3839 RooArgList cloneList ;; 3840 RooArgList loList ;; 3841 RooArgSet clonedBranchNodes ;; 3842 ; 3843 // Setup customizer that stores all cloned branches in our non-owning list; 3844 RooCustomizer cust(*this,""cdf"") ;; 3845 cust.setCloneBranchSet(clonedBranchNodes) ;; 3846 cust.setOwning(false) ;; 3847 ; 3848 // Make integration observable x_prime for each observable x as well as an x_lowbound; 3849 for(auto * rrv : static_range_cast<RooRealVar*>(ilist)) {; 3850 ; 3851 // Make clone x_prime of each c.d.f observable x represening running integral; 3852 RooRealVar* cloneArg = static_cast<RooRealVar*>(rrv->clone(Form(""%s_prime"",rrv->GetName()))) ;; 3853 cloneList.add(*cloneArg) ;; 3854 cust.replaceArg(*rrv,*cloneArg) ;; 3855 ; 3856 // Make clone x_lowbound of each c.d.f observable representing low bound of x; 3857 RooRealVar* cloneLo = static_cast<RooRealVar*>(rrv->clone(Form(""%s_lowbound"",rrv->GetName()))) ;; 3858 cloneLo->setVal(rrv->getMin()) ;; 3859 loList.add(*cloneLo) ;; 3860 ; 3861 // Make parameterized binning from [x_lowbound,x] for each x_prime; 3862 RooParamBinning pb(*cloneLo,*rrv,100) ;; 3863 cloneArg->setBinning(pb,""CDF"") ;; 3864 ; 3865 }; 3866 ; 3867 RooAbsReal* tmp = static_cast<RooAbsReal*>(cust.build()) ;; 3868 ; 3869 // Construct final normalization set for c.d.f = integrated observables + any extra specified by user; 3870 RooArgSet finalNset(nset) ;; 387",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:166517,Deployability,integrat,integrated,166517,"or each observable x as well as an x_lowbound; 3849 for(auto * rrv : static_range_cast<RooRealVar*>(ilist)) {; 3850 ; 3851 // Make clone x_prime of each c.d.f observable x represening running integral; 3852 RooRealVar* cloneArg = static_cast<RooRealVar*>(rrv->clone(Form(""%s_prime"",rrv->GetName()))) ;; 3853 cloneList.add(*cloneArg) ;; 3854 cust.replaceArg(*rrv,*cloneArg) ;; 3855 ; 3856 // Make clone x_lowbound of each c.d.f observable representing low bound of x; 3857 RooRealVar* cloneLo = static_cast<RooRealVar*>(rrv->clone(Form(""%s_lowbound"",rrv->GetName()))) ;; 3858 cloneLo->setVal(rrv->getMin()) ;; 3859 loList.add(*cloneLo) ;; 3860 ; 3861 // Make parameterized binning from [x_lowbound,x] for each x_prime; 3862 RooParamBinning pb(*cloneLo,*rrv,100) ;; 3863 cloneArg->setBinning(pb,""CDF"") ;; 3864 ; 3865 }; 3866 ; 3867 RooAbsReal* tmp = static_cast<RooAbsReal*>(cust.build()) ;; 3868 ; 3869 // Construct final normalization set for c.d.f = integrated observables + any extra specified by user; 3870 RooArgSet finalNset(nset) ;; 3871 finalNset.add(cloneList,true) ;; 3872 std::unique_ptr<RooAbsReal> cdf{tmp->createIntegral(cloneList,finalNset,""CDF"")};; 3873 ; 3874 // Transfer ownership of cloned items to top-level c.d.f object; 3875 cdf->addOwnedComponents(*tmp) ;; 3876 cdf->addOwnedComponents(cloneList) ;; 3877 cdf->addOwnedComponents(loList) ;; 3878 ; 3879 return RooFit::makeOwningPtr(std::move(cdf));; 3880}; 3881 ; 3882 ; 3883////////////////////////////////////////////////////////////////////////////////; 3884/// Return a RooFunctor object bound to this RooAbsReal with given definition of observables; 3885/// and parameters; 3886 ; 3887RooFunctor* RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars, const RooArgSet& nset) const; 3888{; 3889 RooArgSet realObs;; 3890 getObservables(&obs, realObs);; 3891 if (realObs.size() != obs.size()) {; 3892 coutE(InputArguments) << ""RooAbsReal::functor("" << GetName() << "") ERROR: one or more specified observables are not",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:174144,Deployability,integrat,integrated,174144,"std::string name=Form(""%s_MOMENT_%d%s_%s"",GetName(),order,(central?""C"":""""),obs.GetName()) ;; 4018 std::string title=Form(""%sMoment of order %d of %s w.r.t %s "",(central?""Central "":""""),order,GetName(),obs.GetName()) ;; 4019 if (order==1) return new RooFirstMoment(name.c_str(),title.c_str(),*this,obs) ;; 4020 if (order==2) return new RooSecondMoment(name.c_str(),title.c_str(),*this,obs,central,takeRoot) ;; 4021 return new RooMoment(name.c_str(),title.c_str(),*this,obs,order,central,takeRoot) ;; 4022}; 4023 ; 4024 ; 4025////////////////////////////////////////////////////////////////////////////////; 4026/// Return function representing moment of p.d.f (normalized w.r.t given observables) of given order.; 4027/// \param[in] obs Observable to calculate the moments for; 4028/// \param[in] normObs Normalise w.r.t. these observables; 4029/// \param[in] order Order of the moment; 4030/// \param[in] central If true, the central moment is given by \f$ \langle (x- \langle x \rangle )^2 \rangle \f$; 4031/// \param[in] takeRoot Calculate the square root; 4032/// \param[in] intNormObs If true, the moment of the function integrated over all normalization observables is returned.; 4033 ; 4034RooAbsMoment* RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, bool central, bool takeRoot, bool intNormObs); 4035{; 4036 std::string name=Form(""%s_MOMENT_%d%s_%s"",GetName(),order,(central?""C"":""""),obs.GetName()) ;; 4037 std::string title=Form(""%sMoment of order %d of %s w.r.t %s "",(central?""Central "":""""),order,GetName(),obs.GetName()) ;; 4038 ; 4039 if (order==1) return new RooFirstMoment(name.c_str(),title.c_str(),*this,obs,normObs,intNormObs) ;; 4040 if (order==2) return new RooSecondMoment(name.c_str(),title.c_str(),*this,obs,normObs,central,takeRoot,intNormObs) ;; 4041 return new RooMoment(name.c_str(),title.c_str(),*this,obs,normObs,order,central,takeRoot,intNormObs) ;; 4042}; 4043 ; 4044 ; 4045 ; 4046////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:218819,Deployability,integrat,integration,218819,"tValV(const RooArgSet *normalisationSet=nullptr) constReturn value of object.Definition RooAbsReal.cxx:300; RooAbsReal::numEvalErrorItemsstatic Int_t numEvalErrorItems()Definition RooAbsReal.cxx:176; RooAbsReal::RooAbsRealRooAbsReal()coverity[UNINIT_CTOR] Default constructorDefinition RooAbsReal.cxx:199; RooAbsReal::RooRealBindingfriend class RooRealBindingDefinition RooAbsReal.h:401; RooAbsReal::fixAddCoefNormalizationvirtual void fixAddCoefNormalization(const RooArgSet &addNormSet=RooArgSet(), bool force=true)Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by...Definition RooAbsReal.cxx:3650; RooAbsReal::getAnalyticalIntegralWNvirtual Int_t getAnalyticalIntegralWN(RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) constVariant of getAnalyticalIntegral that is also passed the normalization set that should be applied to ...Definition RooAbsReal.cxx:351; RooAbsReal::_forceNumIntbool _forceNumIntForce numerical integration if flag set.Definition RooAbsReal.h:539; RooAbsReal::~RooAbsReal~RooAbsReal() overrideDestructor.Definition RooAbsReal.cxx:238; RooAbsReal::setParameterizeIntegralvoid setParameterizeIntegral(const RooArgSet &paramVars)Definition RooAbsReal.cxx:4324; RooAbsReal::matchArgsByNamebool matchArgsByName(const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) constCheck if allArgs contains matching elements for each name in nameList.Definition RooAbsReal.cxx:3241; RooAbsReal::hideOffsetstatic bool hideOffset()Definition RooAbsReal.cxx:192; RooAbsReal::setTreeBranchStatusvoid setTreeBranchStatus(TTree &t, bool active) override(De)Activate associated tree branchDefinition RooAbsReal.cxx:3116; RooAbsReal::fillHistogramTH1 * fillHistogram(TH1 *hist, const RooArgList &plotVars, double scaleFactor=1, const RooArgSet *projectedVars=nullptr, bool scaling=true, const RooArgSet *condObs=nullptr, bool setError=true) constFill the ROOT histogram 'hist' wi",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:222320,Deployability,integrat,integration,222320,"ooAbsReal::derivativeRooDerivative * derivative(RooRealVar &obs, Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Perform a fit to given histogram.Definition RooAbsReal.cxx:4105; RooAbsReal::asTFTF1 * asTF(const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) constReturn a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parame...Definition RooAbsReal.cxx:3911; RooAbsReal::_unitTString _unitUnit for objects value.Definition RooAbsReal.h:537; RooAbsReal::defaultIntegratorConfigstatic RooNumIntConfig * defaultIntegratorConfig()Returns the default numeric integration configuration for all RooAbsReals.Definition RooAbsReal.cxx:3272; RooAbsReal::readFromStreambool readFromStream(std::istream &is, bool compact, bool verbose=false) overrideRead object contents from stream (dummy for now)Definition RooAbsReal.cxx:426; RooAbsReal::matchArgsbool matchArgs(const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a) constUtility function for use in getAnalyticalIntegral().Definition RooAbsReal.cxx:3146; RooAbsReal::fillTreeBranchvoid fillTreeBranch(TTree &t) overrideFill the tree branch that associated with this object with its current value.Definition RooAbsReal.cxx:3099; RooAbsReal::printMultilinevoid printMultiline(std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const overrideStructure printing.Definition RooAbsReal.cxx:455; RooAbsReal::plotAsymOnvirtual RooPlot * plotAsymOn(RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) constDefinition RooAbsReal.cxx:2199;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:222332,Deployability,configurat,configuration,222332,"ooAbsReal::derivativeRooDerivative * derivative(RooRealVar &obs, Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Perform a fit to given histogram.Definition RooAbsReal.cxx:4105; RooAbsReal::asTFTF1 * asTF(const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) constReturn a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parame...Definition RooAbsReal.cxx:3911; RooAbsReal::_unitTString _unitUnit for objects value.Definition RooAbsReal.h:537; RooAbsReal::defaultIntegratorConfigstatic RooNumIntConfig * defaultIntegratorConfig()Returns the default numeric integration configuration for all RooAbsReals.Definition RooAbsReal.cxx:3272; RooAbsReal::readFromStreambool readFromStream(std::istream &is, bool compact, bool verbose=false) overrideRead object contents from stream (dummy for now)Definition RooAbsReal.cxx:426; RooAbsReal::matchArgsbool matchArgs(const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a) constUtility function for use in getAnalyticalIntegral().Definition RooAbsReal.cxx:3146; RooAbsReal::fillTreeBranchvoid fillTreeBranch(TTree &t) overrideFill the tree branch that associated with this object with its current value.Definition RooAbsReal.cxx:3099; RooAbsReal::printMultilinevoid printMultiline(std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const overrideStructure printing.Definition RooAbsReal.cxx:455; RooAbsReal::plotAsymOnvirtual RooPlot * plotAsymOn(RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) constDefinition RooAbsReal.cxx:2199;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:224123,Deployability,integrat,integration,224123,"efinition RooAbsReal.cxx:455; RooAbsReal::plotAsymOnvirtual RooPlot * plotAsymOn(RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) constDefinition RooAbsReal.cxx:2199; RooAbsReal::operator==bool operator==(double value) constEquality operator comparing to a double.Definition RooAbsReal.cxx:250; RooAbsReal::evalErrorLoggingModestatic ErrorLoggingMode evalErrorLoggingMode()Return current evaluation error logging mode.Definition RooAbsReal.cxx:4302; RooAbsReal::redirectServersHookbool redirectServersHook(const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) overrideFunction that is called at the end of redirectServers().Definition RooAbsReal.cxx:4474; RooAbsReal::isValidRealvirtual bool isValidReal(double, bool printError=false) constInterface function to check if given value is a valid value for this object. Returns true unless over...Definition RooAbsReal.h:447; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::printValuevoid printValue(std::ostream &os) const overridePrint object value.Definition RooAbsReal.cxx:445; RooAbsReal::isIdenticalbool isIdentical(const RooAbsArg &other, bool assumeSameType=false) const overrideDefinition RooAbsReal.cxx:270; RooAbsReal::createProfilevirtual RooFit::OwningPtr< RooAbsReal > createProfile(const RooArgSet &paramsOfInterest)Create a RooProfileLL object that eliminates all nuisance parameters in the present function.Definition RooAbsReal.cxx:471; RooAbsReal::_hideOffsetstatic bool _hideOffsetOffset hiding flag.Definition RooAbsReal.h:546; RooAbsReal::attachToVStorevoid attachToVStore(RooVectorDataStore &vstore) overrideDefinition RooAbsReal.cxx:3012; RooAbsReal::copyCachevoid copyCache(const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) overrideCopy the cached value of another RooAbsArg to our cache.Definition RooAbsReal.c",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:224135,Deployability,configurat,configuration,224135,"efinition RooAbsReal.cxx:455; RooAbsReal::plotAsymOnvirtual RooPlot * plotAsymOn(RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) constDefinition RooAbsReal.cxx:2199; RooAbsReal::operator==bool operator==(double value) constEquality operator comparing to a double.Definition RooAbsReal.cxx:250; RooAbsReal::evalErrorLoggingModestatic ErrorLoggingMode evalErrorLoggingMode()Return current evaluation error logging mode.Definition RooAbsReal.cxx:4302; RooAbsReal::redirectServersHookbool redirectServersHook(const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) overrideFunction that is called at the end of redirectServers().Definition RooAbsReal.cxx:4474; RooAbsReal::isValidRealvirtual bool isValidReal(double, bool printError=false) constInterface function to check if given value is a valid value for this object. Returns true unless over...Definition RooAbsReal.h:447; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::printValuevoid printValue(std::ostream &os) const overridePrint object value.Definition RooAbsReal.cxx:445; RooAbsReal::isIdenticalbool isIdentical(const RooAbsArg &other, bool assumeSameType=false) const overrideDefinition RooAbsReal.cxx:270; RooAbsReal::createProfilevirtual RooFit::OwningPtr< RooAbsReal > createProfile(const RooArgSet &paramsOfInterest)Create a RooProfileLL object that eliminates all nuisance parameters in the present function.Definition RooAbsReal.cxx:471; RooAbsReal::_hideOffsetstatic bool _hideOffsetOffset hiding flag.Definition RooAbsReal.h:546; RooAbsReal::attachToVStorevoid attachToVStore(RooVectorDataStore &vstore) overrideDefinition RooAbsReal.cxx:3012; RooAbsReal::copyCachevoid copyCache(const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) overrideCopy the cached value of another RooAbsArg to our cache.Definition RooAbsReal.c",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:226193,Deployability,integrat,integrator,226193,"gram(RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) constCreate and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables w...Definition RooAbsReal.cxx:1183; RooAbsReal::fixAddCoefRangevirtual void fixAddCoefRange(const char *rangeName=nullptr, bool force=true)Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by...Definition RooAbsReal.cxx:3675; RooAbsReal::_valuedouble _valueCache for current value of object.Definition RooAbsReal.h:536; RooAbsReal::analyticalIntegralvirtual double analyticalIntegral(Int_t code, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:394; RooAbsReal::attachToTreevoid attachToTree(TTree &t, Int_t bufSize=32000) overrideAttach object to a branch of given TTree.Definition RooAbsReal.cxx:3028; RooAbsReal::specialIntegratorConfigRooNumIntConfig * specialIntegratorConfig() constReturns the specialized integrator configuration for this RooAbsReal.Definition RooAbsReal.cxx:3282; RooAbsReal::writeToStreamvoid writeToStream(std::ostream &os, bool compact) const overrideWrite object contents to stream (dummy for now)Definition RooAbsReal.cxx:436; RooAbsReal::traceEvaldouble traceEval(const RooArgSet *set) constCalculate current value of object, with error tracing wrapper.Definition RooAbsReal.cxx:319; RooAbsReal::getPropagatedErrordouble getPropagatedError(const RooFitResult &fr, const RooArgSet &nset={}) constPropagates parameter uncertainties to an uncertainty estimate for this RooAbsReal.Definition RooAbsReal.cxx:2472; RooAbsReal::setHideOffsetstatic void setHideOffset(bool flag)Definition RooAbsReal.cxx:191; RooAbsReal::ErrorLoggingModeErrorLoggingModeDefinition RooAbsReal.h:317; RooAbsReal::CountErrors@ CountErrorsDefinition RooAbsReal.h:317; RooAbsReal::CollectErrors@ CollectErrorsDefinition RooAbsReal.h:317; RooAbsReal::PrintErrors@ PrintErrorsD",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:226204,Deployability,configurat,configuration,226204,"gram(RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) constCreate and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables w...Definition RooAbsReal.cxx:1183; RooAbsReal::fixAddCoefRangevirtual void fixAddCoefRange(const char *rangeName=nullptr, bool force=true)Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by...Definition RooAbsReal.cxx:3675; RooAbsReal::_valuedouble _valueCache for current value of object.Definition RooAbsReal.h:536; RooAbsReal::analyticalIntegralvirtual double analyticalIntegral(Int_t code, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:394; RooAbsReal::attachToTreevoid attachToTree(TTree &t, Int_t bufSize=32000) overrideAttach object to a branch of given TTree.Definition RooAbsReal.cxx:3028; RooAbsReal::specialIntegratorConfigRooNumIntConfig * specialIntegratorConfig() constReturns the specialized integrator configuration for this RooAbsReal.Definition RooAbsReal.cxx:3282; RooAbsReal::writeToStreamvoid writeToStream(std::ostream &os, bool compact) const overrideWrite object contents to stream (dummy for now)Definition RooAbsReal.cxx:436; RooAbsReal::traceEvaldouble traceEval(const RooArgSet *set) constCalculate current value of object, with error tracing wrapper.Definition RooAbsReal.cxx:319; RooAbsReal::getPropagatedErrordouble getPropagatedError(const RooFitResult &fr, const RooArgSet &nset={}) constPropagates parameter uncertainties to an uncertainty estimate for this RooAbsReal.Definition RooAbsReal.cxx:2472; RooAbsReal::setHideOffsetstatic void setHideOffset(bool flag)Definition RooAbsReal.cxx:191; RooAbsReal::ErrorLoggingModeErrorLoggingModeDefinition RooAbsReal.h:317; RooAbsReal::CountErrors@ CountErrorsDefinition RooAbsReal.h:317; RooAbsReal::CollectErrors@ CollectErrorsDefinition RooAbsReal.h:317; RooAbsReal::PrintErrors@ PrintErrorsD",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:230607,Deployability,integrat,integrated,230607,"bsReal::setEvalErrorLoggingModestatic void setEvalErrorLoggingMode(ErrorLoggingMode m)Set evaluation error logging mode.Definition RooAbsReal.cxx:4316; RooAbsReal::preferredObservableScanOrdervirtual void preferredObservableScanOrder(const RooArgSet &obs, RooArgSet &orderedObs) constInterface method for function objects to indicate their preferred order of observables for scanning t...Definition RooAbsReal.cxx:3694; RooAbsReal::maxValvirtual double maxVal(Int_t code) constReturn maximum value for set of observables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive integrals over functions ...Definition RooAbsReal.cxx:701; RooAbsReal::integralNameSuffixTString integralNameSuffix(const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:231537,Deployability,integrat,integration,231537,"itEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsReal.cxx:3827; RooAbsReal::enableOffsettingvirtual void enableOffsetting(bool)Definition RooAbsReal.cxx:4484; RooAbsReal::clearEvalErrorLogstatic void clearEvalErrorLog()Clear the stack of evaluation error messages.Definition RooAbsReal.cxx:3542; RooAbsReal::createIntObjRooFit::OwningPtr< RooAbsReal > createIntObj(const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) constInternal utility function for createIntegral() that creates the actual integral object.Def",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:231549,Deployability,configurat,configuration,231549,"itEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsReal.cxx:3827; RooAbsReal::enableOffsettingvirtual void enableOffsetting(bool)Definition RooAbsReal.cxx:4484; RooAbsReal::clearEvalErrorLogstatic void clearEvalErrorLog()Clear the stack of evaluation error messages.Definition RooAbsReal.cxx:3542; RooAbsReal::createIntObjRooFit::OwningPtr< RooAbsReal > createIntObj(const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) constInternal utility function for createIntegral() that creates the actual integral object.Def",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:244962,Deployability,configurat,configuration,244962,"pointers in a doubly linked list...Definition RooLinkedList.h:44; RooLinkedList::Deletevoid Delete(Option_t *o=nullptr) overrideRemove all elements in collection and delete all elements NB: Collection does not own elements,...Definition RooLinkedList.cxx:578; RooLinkedList::Addvirtual void Add(TObject *arg)Definition RooLinkedList.h:73; RooLinkedList::beginRooLinkedListIterImpl begin() constDefinition RooLinkedList.cxx:761; RooLinkedList::FindObjectTObject * FindObject(const char *name) const overrideReturn pointer to object with given name.Definition RooLinkedList.cxx:534; RooMomentDefinition RooMoment.h:26; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::isActivebool isActive(T self, RooFit::MsgTopic topic, RooFit::MsgLevel level)Check if logging is active for given object/topic/RooFit::MsgLevel combination.Definition RooMsgService.h:186; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooNumIntConfig::defaultConfigstatic RooNumIntConfig & defaultConfig()Return reference to instance of default numeric integrator configuration object.Definition RooNumIntConfig.cxx:44; RooParamBinningImplementation of RooAbsBinning that constructs a binning with a range definition that depends on ext...Definition RooParamBinning.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::removevoid remove(const char *name=nullptr, bool deleteToo=true)Remove object with given name, or last object added if no name is given.Definition RooPlot.cxx:868; RooPlot::drawBeforebool drawBefore(const char *before, const char *target)Change the order in which our contained objects are drawn so that the target object is drawn just bef...Definition RooPlot.cxx:906; RooPlot::findObjectTObject * findObject(const char *name, const TClass *tClass=nullptr) constFi",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:245010,Deployability,integrat,integrators,245010,"pointers in a doubly linked list...Definition RooLinkedList.h:44; RooLinkedList::Deletevoid Delete(Option_t *o=nullptr) overrideRemove all elements in collection and delete all elements NB: Collection does not own elements,...Definition RooLinkedList.cxx:578; RooLinkedList::Addvirtual void Add(TObject *arg)Definition RooLinkedList.h:73; RooLinkedList::beginRooLinkedListIterImpl begin() constDefinition RooLinkedList.cxx:761; RooLinkedList::FindObjectTObject * FindObject(const char *name) const overrideReturn pointer to object with given name.Definition RooLinkedList.cxx:534; RooMomentDefinition RooMoment.h:26; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::isActivebool isActive(T self, RooFit::MsgTopic topic, RooFit::MsgLevel level)Check if logging is active for given object/topic/RooFit::MsgLevel combination.Definition RooMsgService.h:186; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooNumIntConfig::defaultConfigstatic RooNumIntConfig & defaultConfig()Return reference to instance of default numeric integrator configuration object.Definition RooNumIntConfig.cxx:44; RooParamBinningImplementation of RooAbsBinning that constructs a binning with a range definition that depends on ext...Definition RooParamBinning.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::removevoid remove(const char *name=nullptr, bool deleteToo=true)Remove object with given name, or last object added if no name is given.Definition RooPlot.cxx:868; RooPlot::drawBeforebool drawBefore(const char *before, const char *target)Change the order in which our contained objects are drawn so that the target object is drawn just bef...Definition RooPlot.cxx:906; RooPlot::findObjectTObject * findObject(const char *name, const TClass *tClass=nullptr) constFi",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:245197,Deployability,integrat,integrator,245197,"nd delete all elements NB: Collection does not own elements,...Definition RooLinkedList.cxx:578; RooLinkedList::Addvirtual void Add(TObject *arg)Definition RooLinkedList.h:73; RooLinkedList::beginRooLinkedListIterImpl begin() constDefinition RooLinkedList.cxx:761; RooLinkedList::FindObjectTObject * FindObject(const char *name) const overrideReturn pointer to object with given name.Definition RooLinkedList.cxx:534; RooMomentDefinition RooMoment.h:26; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::isActivebool isActive(T self, RooFit::MsgTopic topic, RooFit::MsgLevel level)Check if logging is active for given object/topic/RooFit::MsgLevel combination.Definition RooMsgService.h:186; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooNumIntConfig::defaultConfigstatic RooNumIntConfig & defaultConfig()Return reference to instance of default numeric integrator configuration object.Definition RooNumIntConfig.cxx:44; RooParamBinningImplementation of RooAbsBinning that constructs a binning with a range definition that depends on ext...Definition RooParamBinning.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::removevoid remove(const char *name=nullptr, bool deleteToo=true)Remove object with given name, or last object added if no name is given.Definition RooPlot.cxx:868; RooPlot::drawBeforebool drawBefore(const char *before, const char *target)Change the order in which our contained objects are drawn so that the target object is drawn just bef...Definition RooPlot.cxx:906; RooPlot::findObjectTObject * findObject(const char *name, const TClass *tClass=nullptr) constFind the named object in our list of items and return a pointer to it.Definition RooPlot.cxx:942; RooPlot::getNormVarsconst RooArgSet * getNormVars() constDefinition",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:245208,Deployability,configurat,configuration,245208,"nd delete all elements NB: Collection does not own elements,...Definition RooLinkedList.cxx:578; RooLinkedList::Addvirtual void Add(TObject *arg)Definition RooLinkedList.h:73; RooLinkedList::beginRooLinkedListIterImpl begin() constDefinition RooLinkedList.cxx:761; RooLinkedList::FindObjectTObject * FindObject(const char *name) const overrideReturn pointer to object with given name.Definition RooLinkedList.cxx:534; RooMomentDefinition RooMoment.h:26; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::isActivebool isActive(T self, RooFit::MsgTopic topic, RooFit::MsgLevel level)Check if logging is active for given object/topic/RooFit::MsgLevel combination.Definition RooMsgService.h:186; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooNumIntConfig::defaultConfigstatic RooNumIntConfig & defaultConfig()Return reference to instance of default numeric integrator configuration object.Definition RooNumIntConfig.cxx:44; RooParamBinningImplementation of RooAbsBinning that constructs a binning with a range definition that depends on ext...Definition RooParamBinning.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::removevoid remove(const char *name=nullptr, bool deleteToo=true)Remove object with given name, or last object added if no name is given.Definition RooPlot.cxx:868; RooPlot::drawBeforebool drawBefore(const char *before, const char *target)Change the order in which our contained objects are drawn so that the target object is drawn just bef...Definition RooPlot.cxx:906; RooPlot::findObjectTObject * findObject(const char *name, const TClass *tClass=nullptr) constFind the named object in our list of items and return a pointer to it.Definition RooPlot.cxx:942; RooPlot::getNormVarsconst RooArgSet * getNormVars() constDefinition",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:11826,Energy Efficiency,efficient,efficient,11826,"alue = evaluate() ;; 322 ; 323 if (TMath::IsNaN(value)) {; 324 logEvalError(""function value is NAN"") ;; 325 }; 326 ; 327 //cxcoutD(Tracing) << ""RooAbsReal::getValF("" << GetName() << "") operMode = "" << _operMode << "" recalculated, new value = "" << value << std::endl ;; 328 ; 329 //Standard tracing code goes here; 330 if (!isValidReal(value)) {; 331 coutW(Tracing) << ""RooAbsReal::traceEval("" << GetName(); 332 << ""): validation failed: "" << value << std::endl ;; 333 }; 334 ; 335 //Call optional subclass tracing code; 336 // traceEvalHook(value) ;; 337 ; 338 return value ;; 339}; 340 ; 341 ; 342 ; 343////////////////////////////////////////////////////////////////////////////////; 344/// Variant of getAnalyticalIntegral that is also passed the normalization set; 345/// that should be applied to the integrand of which the integral is requested.; 346/// For certain operator p.d.f it is useful to overload this function rather; 347/// than analyticalIntegralWN() as the additional normalization information; 348/// may be useful in determining a more efficient decomposition of the; 349/// requested integral.; 350 ; 351Int_t RooAbsReal::getAnalyticalIntegralWN(RooArgSet& allDeps, RooArgSet& analDeps,; 352 const RooArgSet* /*normSet*/, const char* rangeName) const; 353{; 354 return _forceNumInt ? 0 : getAnalyticalIntegral(allDeps,analDeps,rangeName) ;; 355}; 356 ; 357 ; 358 ; 359////////////////////////////////////////////////////////////////////////////////; 360/// Interface function getAnalyticalIntergral advertises the; 361/// analytical integrals that are supported. 'integSet'; 362/// is the set of dependents for which integration is requested. The; 363/// function should copy the subset of dependents it can analytically; 364/// integrate to anaIntSet and return a unique identification code for; 365/// this integration configuration. If no integration can be; 366/// performed, zero should be returned.; 367 ; 368Int_t RooAbsReal::getAnalyticalIntegral(RooArgSet& /*integSet*/",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:88480,Energy Efficiency,reduce,reduced,88480,"<RooAbsReal*>(createPlotProjection(deps, &projectedVars, projectionCompList, o.projectionRangeName));; 1983 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot projection object is "" << projection->GetName() << std::endl ;; 1984 if (dologD(Plotting)) {; 1985 projection->printStream(ccoutD(Plotting),0,kVerbose) ;; 1986 }; 1987 ; 1988 // Always fix RooAddPdf normalizations; 1989 RooArgSet fullNormSet(deps) ;; 1990 fullNormSet.add(projectedVars) ;; 1991 if (projDataNeededVars && !projDataNeededVars->empty()) {; 1992 fullNormSet.add(*projDataNeededVars) ;; 1993 }; 1994 ; 1995 std::unique_ptr<RooArgSet> projectionComponents(projection->getComponents());; 1996 for(auto * pdf : dynamic_range_cast<RooAbsPdf*>(*projectionComponents)) {; 1997 if (pdf) {; 1998 pdf->selectNormalization(&fullNormSet) ;; 1999 }; 2000 }; 2001 ; 2002 // Apply data projection, if requested; 2003 if (o.projData && projDataNeededVars && !projDataNeededVars->empty()) {; 2004 ; 2005 // If data set contains more rows than needed, make reduced copy first; 2006 RooAbsData* projDataSel = const_cast<RooAbsData*>(o.projData);; 2007 std::unique_ptr<RooAbsData> projDataSelOwned;; 2008 ; 2009 if (projDataNeededVars->size() < o.projData->get()->size()) {; 2010 ; 2011 // Determine if there are any slice variables in the projection set; 2012 std::unique_ptr<RooArgSet> sliceDataSet{sliceSet.selectCommon(*o.projData->get())};; 2013 TString cutString ;; 2014 if (!sliceDataSet->empty()) {; 2015 bool first(true) ;; 2016 for(RooAbsArg * sliceVar : *sliceDataSet) {; 2017 if (!first) {; 2018 cutString.Append(""&&"") ;; 2019 } else {; 2020 first=false ;; 2021 }; 2022 ; 2023 RooAbsRealLValue* real ;; 2024 RooAbsCategoryLValue* cat ;; 2025 if ((real = dynamic_cast<RooAbsRealLValue*>(sliceVar))) {; 2026 cutString.Append(Form(""%s==%f"",real->GetName(),real->getVal())) ;; 2027 } else if ((cat = dynamic_cast<RooAbsCategoryLValue*>(sliceVar))) {; 2028 cutString.Append(Form(""%s==%d"",cat->GetName(),cat->getCurrentIndex()",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:89766,Energy Efficiency,reduce,reduce,89766,"12 std::unique_ptr<RooArgSet> sliceDataSet{sliceSet.selectCommon(*o.projData->get())};; 2013 TString cutString ;; 2014 if (!sliceDataSet->empty()) {; 2015 bool first(true) ;; 2016 for(RooAbsArg * sliceVar : *sliceDataSet) {; 2017 if (!first) {; 2018 cutString.Append(""&&"") ;; 2019 } else {; 2020 first=false ;; 2021 }; 2022 ; 2023 RooAbsRealLValue* real ;; 2024 RooAbsCategoryLValue* cat ;; 2025 if ((real = dynamic_cast<RooAbsRealLValue*>(sliceVar))) {; 2026 cutString.Append(Form(""%s==%f"",real->GetName(),real->getVal())) ;; 2027 } else if ((cat = dynamic_cast<RooAbsCategoryLValue*>(sliceVar))) {; 2028 cutString.Append(Form(""%s==%d"",cat->GetName(),cat->getCurrentIndex())) ;; 2029 }; 2030 }; 2031 }; 2032 ; 2033 if (!cutString.IsNull()) {; 2034 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") reducing given projection dataset to entries with "" << cutString << std::endl ;; 2035 }; 2036 projDataSelOwned = std::unique_ptr<RooAbsData>{const_cast<RooAbsData*>(o.projData)->reduce(*projDataNeededVars, cutString.IsNull() ? nullptr : cutString)};; 2037 projDataSel = projDataSelOwned.get();; 2038 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2039 << "") only the following components of the projection data will be used: "" << *projDataNeededVars << std::endl ;; 2040 }; 2041 ; 2042 // Request binning of unbinned projection dataset that consists exclusively of category observables; 2043 if (!o.binProjData && dynamic_cast<RooDataSet*>(projDataSel)!=nullptr) {; 2044 ; 2045 // Determine if dataset contains only categories; 2046 bool allCat(true) ;; 2047 for(RooAbsArg * arg2 : *projDataSel->get()) {; 2048 if (!dynamic_cast<RooCategory*>(arg2)) allCat = false ;; 2049 }; 2050 if (allCat) {; 2051 o.binProjData = true ;; 2052 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") unbinned projection dataset consist only of discrete variables,""; 2053 << "" performing projection with binned copy for optimization."" << std::endl ;; 2054 ; 2055 }; 2056 }; 2057 ; 2058 // Bin pr",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:102908,Energy Efficiency,reduce,reduced,102908,"g.add(projDataVars) ;; 2323 ; 2324 const RooAbsReal *posProj = funcPos->createPlotProjection(depPos, &projectedVars, posProjCompList, o.projectionRangeName) ;; 2325 const RooAbsReal *negProj = funcNeg->createPlotProjection(depNeg, &projectedVars, negProjCompList, o.projectionRangeName) ;; 2326 if (!posProj || !negProj) {; 2327 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName() << "") Unable to create projections, abort"" << std::endl ;; 2328 return frame ;; 2329 }; 2330 ; 2331 // Create a RooFormulaVar representing the asymmetry; 2332 TString asymName(GetName()) ;; 2333 asymName.Append(""_Asym["") ;; 2334 asymName.Append(asymCat.GetName()) ;; 2335 asymName.Append(""]"") ;; 2336 TString asymTitle(asymCat.GetName()) ;; 2337 asymTitle.Append("" Asymmetry of "") ;; 2338 asymTitle.Append(GetTitle()) ;; 2339 RooFormulaVar funcAsym{asymName,asymTitle,""(@0-@1)/(@0+@1)"",RooArgSet(*posProj,*negProj)};; 2340 ; 2341 if (o.projData) {; 2342 ; 2343 // If data set contains more rows than needed, make reduced copy first; 2344 RooAbsData* projDataSel = const_cast<RooAbsData*>(o.projData);; 2345 std::unique_ptr<RooAbsData> projDataSelOwned;; 2346 if (projDataNeededVars && projDataNeededVars->size() < o.projData->get()->size()) {; 2347 ; 2348 // Determine if there are any slice variables in the projection set; 2349 RooArgSet sliceDataSet;; 2350 sliceSet.selectCommon(*o.projData->get(), sliceDataSet);; 2351 TString cutString ;; 2352 if (!sliceDataSet.empty()) {; 2353 bool first(true) ;; 2354 for(RooAbsArg * sliceVar : sliceDataSet) {; 2355 if (!first) {; 2356 cutString.Append(""&&"") ;; 2357 } else {; 2358 first=false ;; 2359 }; 2360 ; 2361 RooAbsRealLValue* real ;; 2362 RooAbsCategoryLValue* cat ;; 2363 if ((real = dynamic_cast<RooAbsRealLValue*>(sliceVar))) {; 2364 cutString.Append(Form(""%s==%f"",real->GetName(),real->getVal())) ;; 2365 } else if ((cat = dynamic_cast<RooAbsCategoryLValue*>(sliceVar))) {; 2366 cutString.Append(Form(""%s==%d"",cat->GetName(),cat->getCurrentIndex())) ;; 2367 ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:104220,Energy Efficiency,reduce,reduce,104220,"t sliceDataSet;; 2350 sliceSet.selectCommon(*o.projData->get(), sliceDataSet);; 2351 TString cutString ;; 2352 if (!sliceDataSet.empty()) {; 2353 bool first(true) ;; 2354 for(RooAbsArg * sliceVar : sliceDataSet) {; 2355 if (!first) {; 2356 cutString.Append(""&&"") ;; 2357 } else {; 2358 first=false ;; 2359 }; 2360 ; 2361 RooAbsRealLValue* real ;; 2362 RooAbsCategoryLValue* cat ;; 2363 if ((real = dynamic_cast<RooAbsRealLValue*>(sliceVar))) {; 2364 cutString.Append(Form(""%s==%f"",real->GetName(),real->getVal())) ;; 2365 } else if ((cat = dynamic_cast<RooAbsCategoryLValue*>(sliceVar))) {; 2366 cutString.Append(Form(""%s==%d"",cat->GetName(),cat->getCurrentIndex())) ;; 2367 }; 2368 }; 2369 }; 2370 ; 2371 if (!cutString.IsNull()) {; 2372 coutI(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2373 << "") reducing given projection dataset to entries with "" << cutString << std::endl ;; 2374 }; 2375 projDataSelOwned = std::unique_ptr<RooAbsData>{const_cast<RooAbsData*>(o.projData)->reduce(*projDataNeededVars,cutString.IsNull() ? nullptr : cutString)};; 2376 projDataSel = projDataSelOwned.get();; 2377 coutI(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2378 << "") only the following components of the projection data will be used: "" << *projDataNeededVars << std::endl ;; 2379 }; 2380 ; 2381 ; 2382 // Construct scaled data weighted average; 2383 ScaledDataWeightedAverage scaleBind{funcAsym, *projDataSel, o.scaleFactor, *plotVar};; 2384 ; 2385 // Set default range, if not specified; 2386 if (o.rangeLo==0 && o.rangeHi==0) {; 2387 o.rangeLo = frame->GetXaxis()->GetXmin() ;; 2388 o.rangeHi = frame->GetXaxis()->GetXmax() ;; 2389 }; 2390 ; 2391 // Construct name of curve for data weighed average; 2392 TString curveName(funcAsym.GetName()) ;; 2393 curveName.Append(Form(""_DataAvg[%s]"",projDataSel->get()->contentsString().c_str())) ;; 2394 // Append slice set specification if any; 2395 if (!sliceSet.empty()) {; 2396 curveName.Append(Form(""_Slice[%s]"",sliceSet.contentsString().c_str",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:110509,Energy Efficiency,reduce,reducedCovarianceMatrix,110509,"nue;; 2493 ; 2494 // Checking for float equality is a bad. We check if the values are; 2495 // negligibly far away from each other, relative to the uncertainty.; 2496 if(std::abs(rrvInAbsReal->getVal() - rrvFitRes->getVal()) > 0.01 * rrvFitRes->getError()) {; 2497 std::stringstream errMsg;; 2498 errMsg << ""RooAbsReal::getPropagatedError(): the parameters of the RooAbsReal don't have""; 2499 << "" the same values as in the fit result! The logic of getPropagatedError is broken in this case."";; 2500 ; 2501 throw std::runtime_error(errMsg.str());; 2502 }; 2503 ; 2504 paramList.add(*rrvInAbsReal);; 2505 }; 2506 ; 2507 std::vector<double> plusVar;; 2508 std::vector<double> minusVar;; 2509 plusVar.reserve(paramList.size());; 2510 minusVar.reserve(paramList.size());; 2511 ; 2512 // Create std::vector of plus,minus variations for each parameter; 2513 TMatrixDSym V(paramList.size() == fr.floatParsFinal().size() ?; 2514 fr.covarianceMatrix() :; 2515 fr.reducedCovarianceMatrix(paramList)) ;; 2516 ; 2517 for (std::size_t ivar=0 ; ivar<paramList.size() ; ivar++) {; 2518 ; 2519 auto& rrv = static_cast<RooRealVar&>(paramList[ivar]);; 2520 ; 2521 double cenVal = rrv.getVal() ;; 2522 double errVal = sqrt(V(ivar,ivar)) ;; 2523 ; 2524 // Make Plus variation; 2525 rrv.setVal(cenVal+errVal) ;; 2526 plusVar.push_back(getVal(nset)) ;; 2527 ; 2528 // Make Minus variation; 2529 rrv.setVal(cenVal-errVal) ;; 2530 minusVar.push_back(getVal(nset)) ;; 2531 ; 2532 rrv.setVal(cenVal) ;; 2533 }; 2534 ; 2535 // Re-evaluate this RooAbsReal with the central parameters just to be; 2536 // extra-safe that a call to `getPropagatedError()` doesn't change any state.; 2537 // It should not be necessary because thanks to the dirty flag propagation; 2538 // the RooAbsReal is re-evaluated anyway the next time getVal() is called.; 2539 // Still there are imaginable corner cases where it would not be triggered,; 2540 // for example if the user changes the RooFit operation more after the error; 2541 // propagation.;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:120067,Energy Efficiency,reduce,reducedCovarianceMatrix,120067,"->getObservables(&fpf_stripped, cloneParams) ;; 2711 RooArgSet errorParams{cloneParams};; 2712 if(params) {; 2713 // clear and fill errorParams only with parameters that both in params and cloneParams; 2714 cloneParams.selectCommon(*params, errorParams);; 2715 }; 2716 ; 2717 ; 2718 // Make list of parameter instances of cloneFunc in order of error matrix; 2719 RooArgList paramList ;; 2720 const RooArgList& fpf = fr.floatParsFinal() ;; 2721 std::vector<int> fpf_idx ;; 2722 for (std::size_t i=0 ; i<fpf.size() ; i++) {; 2723 RooAbsArg* par = errorParams.find(fpf[i].GetName()) ;; 2724 if (par) {; 2725 paramList.add(*par) ;; 2726 fpf_idx.push_back(i) ;; 2727 }; 2728 }; 2729 ; 2730 std::vector<RooCurve *> plusVar;; 2731 std::vector<RooCurve *> minusVar;; 2732 ; 2733 // Create std::vector of plus,minus variations for each parameter; 2734 ; 2735 TMatrixDSym V(paramList.size() == fr.floatParsFinal().size() ?; 2736 fr.covarianceMatrix():; 2737 fr.reducedCovarianceMatrix(paramList)) ;; 2738 ; 2739 ; 2740 for (std::size_t ivar=0 ; ivar<paramList.size() ; ivar++) {; 2741 ; 2742 RooRealVar& rrv = static_cast<RooRealVar&>(fpf[fpf_idx[ivar]]) ;; 2743 ; 2744 double cenVal = rrv.getVal() ;; 2745 double errVal = sqrt(V(ivar,ivar)) ;; 2746 ; 2747 // Make Plus variation; 2748 (static_cast<RooRealVar*>(paramList.at(ivar)))->setVal(cenVal+Z*errVal) ;; 2749 ; 2750 ; 2751 plotFunc(*cloneFunc);; 2752 plusVar.push_back(frame->getCurve()) ;; 2753 frame->remove(nullptr,false) ;; 2754 ; 2755 ; 2756 // Make Minus variation; 2757 (static_cast<RooRealVar*>(paramList.at(ivar)))->setVal(cenVal-Z*errVal) ;; 2758 plotFunc(*cloneFunc);; 2759 minusVar.push_back(frame->getCurve()) ;; 2760 frame->remove(nullptr,false) ;; 2761 ; 2762 (static_cast<RooRealVar*>(paramList.at(ivar)))->setVal(cenVal) ;; 2763 }; 2764 ; 2765 TMatrixDSym C(paramList.size()) ;; 2766 std::vector<double> errVec(paramList.size()) ;; 2767 for (std::size_t i=0 ; i<paramList.size() ; i++) {; 2768 errVec[i] = sqrt(V(i,i)) ;; 2769 for (std::",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:128964,Energy Efficiency,adapt,adaptor,128964,"erver of "" << plotVar->GetName() << std::endl ;; 2927 projectedVars.remove(*tmp) ;; 2928 }; 2929 }; 2930 ; 2931 if (!silent) {; 2932 coutW(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2933 << "") WARNING: cannot project out frame variable (""; 2934 << found->GetName() << ""), ignoring"" << std::endl ;; 2935 }; 2936 }; 2937 ; 2938 // Take out all non-dependents of function; 2939 for(RooAbsArg * arg : *allVars) {; 2940 if (!dependsOnValue(*arg)) {; 2941 projectedVars.remove(*arg,true) ;; 2942 ; 2943 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2944 << "") function doesn't depend on projection variable ""; 2945 << arg->GetName() << "", ignoring"" << std::endl ;; 2946 }; 2947 }; 2948}; 2949 ; 2950 ; 2951 ; 2952 ; 2953////////////////////////////////////////////////////////////////////////////////; 2954/// If true, the current pdf is a selected component (for use in plotting); 2955 ; 2956bool RooAbsReal::isSelectedComp() const; 2957{; 2958 return _selectComp || _globalSelectComp ;; 2959}; 2960 ; 2961 ; 2962 ; 2963////////////////////////////////////////////////////////////////////////////////; 2964/// Global switch controlling the activation of the selectComp() functionality; 2965 ; 2966void RooAbsReal::globalSelectComp(bool flag); 2967{; 2968 _globalSelectComp = flag ;; 2969}; 2970 ; 2971 ; 2972 ; 2973 ; 2974////////////////////////////////////////////////////////////////////////////////; 2975/// Create an interface adaptor f(vars) that binds us to the specified variables; 2976/// (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; 2977/// F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; 2978/// current values of x2 and x4. The caller takes ownership of the returned adaptor.; 2979 ; 2980RooFit::OwningPtr<RooAbsFunc> RooAbsReal::bindVars(const RooArgSet &vars, const RooArgSet* nset, bool clipInvalid) const; 2981{; 2982 auto binding = std::make_unique<RooRealBinding>(*this,vars,nset,clipInvalid);; 2983 if(!binding->isVal",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:129264,Energy Efficiency,adapt,adaptor,129264," 2953////////////////////////////////////////////////////////////////////////////////; 2954/// If true, the current pdf is a selected component (for use in plotting); 2955 ; 2956bool RooAbsReal::isSelectedComp() const; 2957{; 2958 return _selectComp || _globalSelectComp ;; 2959}; 2960 ; 2961 ; 2962 ; 2963////////////////////////////////////////////////////////////////////////////////; 2964/// Global switch controlling the activation of the selectComp() functionality; 2965 ; 2966void RooAbsReal::globalSelectComp(bool flag); 2967{; 2968 _globalSelectComp = flag ;; 2969}; 2970 ; 2971 ; 2972 ; 2973 ; 2974////////////////////////////////////////////////////////////////////////////////; 2975/// Create an interface adaptor f(vars) that binds us to the specified variables; 2976/// (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; 2977/// F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; 2978/// current values of x2 and x4. The caller takes ownership of the returned adaptor.; 2979 ; 2980RooFit::OwningPtr<RooAbsFunc> RooAbsReal::bindVars(const RooArgSet &vars, const RooArgSet* nset, bool clipInvalid) const; 2981{; 2982 auto binding = std::make_unique<RooRealBinding>(*this,vars,nset,clipInvalid);; 2983 if(!binding->isValid()) {; 2984 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":bindVars: cannot bind to "" << vars << std::endl ;; 2985 return nullptr;; 2986 }; 2987 return RooFit::makeOwningPtr(std::unique_ptr<RooAbsFunc>{std::move(binding)});; 2988}; 2989 ; 2990 ; 2991 ; 2992////////////////////////////////////////////////////////////////////////////////; 2993/// Copy the cached value of another RooAbsArg to our cache.; 2994/// Warning: This function just copies the cached values of source,; 2995/// it is the callers responsibility to make sure the cache is clean.; 2996 ; 2997void RooAbsReal::copyCache(const RooAbsArg* source, bool /*valueOnly*/, bool setValDirty); 2998{; 2999 auto other = static_cast<const RooAbsRea",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:145572,Energy Efficiency,efficient,efficiently,145572,"///////////////////////; 3368/// Interface function to force use of a given normalization range; 3369/// to interpret function value. Needed for functions or p.d.f.s; 3370/// whose shape depends on the choice of normalization such as; 3371/// RooAddPdf; 3372 ; 3373void RooAbsReal::selectNormalizationRange(const char*, bool); 3374{; 3375}; 3376 ; 3377 ; 3378 ; 3379////////////////////////////////////////////////////////////////////////////////; 3380/// Advertise capability to determine maximum value of function for given set of; 3381/// observables. If no direct generator method is provided, this information; 3382/// will assist the accept/reject generator to operate more efficiently as; 3383/// it can skip the initial trial sampling phase to empirically find the function; 3384/// maximum; 3385 ; 3386Int_t RooAbsReal::getMaxVal(const RooArgSet& /*vars*/) const; 3387{; 3388 return 0 ;; 3389}; 3390 ; 3391 ; 3392 ; 3393////////////////////////////////////////////////////////////////////////////////; 3394/// Return maximum value for set of observables identified by code assigned; 3395/// in getMaxVal; 3396 ; 3397double RooAbsReal::maxVal(Int_t /*code*/) const; 3398{; 3399 assert(1) ;; 3400 return 0 ;; 3401}; 3402 ; 3403 ; 3404 ; 3405////////////////////////////////////////////////////////////////////////////////; 3406/// Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream.; 3407 ; 3408void RooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString); 3409{; 3410 if (evalErrorData().mode == Ignore) {; 3411 return ;; 3412 }; 3413 ; 3414 if (evalErrorData().mode == CountErrors) {; 3415 evalErrorData().count++ ;; 3416 return ;; 3417 }; 3418 ; 3419 static bool inLogEvalError = false ;; 3420 ; 3421 if (inLogEvalError) {; 3422 return ;; 3423 }; 3424 inLogEvalError = true ;; 3425 ; 3426 EvalError ee ;; 3427 ee.setMessage(message) ;; 3428 ; 3429 if (serverVa",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:178576,Energy Efficiency,consumption,consumption,178576," hi)` <td> Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; 4080/// Multiple comma separated range names can be specified.; 4081/// <tr><td> `NumCPU(int num)` <td> Parallelize NLL calculation on num CPUs; 4082/// <tr><td> `Optimize(bool flag)` <td> Activate constant term optimization (on by default); 4083/// <tr><td> `IntegrateBins()` <td> Integrate PDF within each bin. This sets the desired precision.; 4084///; 4085/// <tr><th> <th> Options to control flow of fit procedure; 4086/// <tr><td> `InitialHesse(bool flag)` <td> Flag controls if HESSE before MIGRAD as well, off by default; 4087/// <tr><td> `Hesse(bool flag)` <td> Flag controls if HESSE is run after MIGRAD, on by default; 4088/// <tr><td> `Minos(bool flag)` <td> Flag controls if MINOS is run after HESSE, on by default; 4089/// <tr><td> `Minos(const RooArgSet& set)` <td> Only run MINOS on given subset of arguments; 4090/// <tr><td> `Save(bool flag)` <td> Flag controls if RooFitResult object is produced and returned, off by default; 4091/// <tr><td> `Strategy(Int_t flag)` <td> Set Minuit strategy (0 through 2, default is 1); 4092///; 4093/// <tr><th> <th> Options to control informational output; 4094/// <tr><td> `Verbose(bool flag)` <td> Flag controls if verbose output is printed (NLL, parameter changes during fit; 4095/// <tr><td> `Timer(bool flag)` <td> Time CPU and wall clock consumption of fit steps, off by default; 4096/// <tr><td> `PrintLevel(Int_t level)` <td> Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; 4097/// messages are suppressed as well; 4098/// <tr><td> `Warnings(bool flag)` <td> Enable or disable MINUIT warnings (enabled by default); 4099/// <tr><td> `PrintEvalErrors(Int_t numErr)` <td> Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; 4100/// value suppress output completely, a zero value will only print the error count per p.d.f component,; 4101/// a positive value is",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:186251,Energy Efficiency,consumption,consumption,186251,"08/// by the YVar() argument. The y value must have errors defined for the \f$ \chi^2 \f$ to; 4209/// be well defined.; 4210///; 4211/// <table>; 4212/// <tr><th><th> Options to control construction of the chi-square; 4213/// <tr><td> `YVar(RooRealVar& yvar)` <td> Designate given column in dataset as Y value; 4214/// <tr><td> `Integrate(bool flag)` <td> Integrate function over range specified by X errors; 4215/// rather than take value at bin center.; 4216///; 4217/// <tr><th><th> Options to control flow of fit procedure; 4218/// <tr><td> `InitialHesse(bool flag)` <td> Flag controls if HESSE before MIGRAD as well, off by default; 4219/// <tr><td> `Hesse(bool flag)` <td> Flag controls if HESSE is run after MIGRAD, on by default; 4220/// <tr><td> `Minos(bool flag)` <td> Flag controls if MINOS is run after HESSE, on by default; 4221/// <tr><td> `Minos(const RooArgSet& set)` <td> Only run MINOS on given subset of arguments; 4222/// <tr><td> `Save(bool flag)` <td> Flag controls if RooFitResult object is produced and returned, off by default; 4223/// <tr><td> `Strategy(Int_t flag)` <td> Set Minuit strategy (0 through 2, default is 1); 4224///; 4225/// <tr><th><th> Options to control informational output; 4226/// <tr><td> `Verbose(bool flag)` <td> Flag controls if verbose output is printed (NLL, parameter changes during fit; 4227/// <tr><td> `Timer(bool flag)` <td> Time CPU and wall clock consumption of fit steps, off by default; 4228/// <tr><td> `PrintLevel(Int_t level)` <td> Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; 4229/// messages are suppressed as well; 4230/// <tr><td> `Warnings(bool flag)` <td> Enable or disable MINUIT warnings (enabled by default); 4231/// <tr><td> `PrintEvalErrors(Int_t numErr)` <td> Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; 4232/// value suppress output completely, a zero value will only print the error count per p.d.f component,; 4233/// a positive value is ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:220936,Energy Efficiency,adapt,adaptor,220936,"AbsReal::createScanRIRooFit::OwningPtr< RooAbsReal > createScanRI(const RooArgSet &iset, const RooArgSet &nset, Int_t numScanBins, Int_t intOrder)Utility function for createRunningIntegral that construct an object implementing the numeric scanning...Definition RooAbsReal.cxx:3810; RooAbsReal::_DEBUG_getValdouble _DEBUG_getVal(const RooArgSet *normalisationSet) constDebug version of getVal(), which is slow and does error checking.Definition RooAbsReal.cxx:4434; RooAbsReal::createFundamentalRooFit::OwningPtr< RooAbsArg > createFundamental(const char *newname=nullptr) const overrideCreate a RooRealVar fundamental object with our properties.Definition RooAbsReal.cxx:3130; RooAbsReal::plotSanityChecksbool plotSanityChecks(RooPlot *frame) constUtility function for plotOn(), perform general sanity check on frame to ensure safe plotting operatio...Definition RooAbsReal.cxx:2860; RooAbsReal::bindVarsRooFit::OwningPtr< RooAbsFunc > bindVars(const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) constCreate an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order).Definition RooAbsReal.cxx:2980; RooAbsReal::selectNormalizationvirtual void selectNormalization(const RooArgSet *depSet=nullptr, bool force=false)Interface function to force use of a given set of observables to interpret function value.Definition RooAbsReal.cxx:3360; RooAbsReal::derivativeRooDerivative * derivative(RooRealVar &obs, Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Perform a fit to given histogram.Definition RooAbsReal.cxx:4105; RooAbsReal::asTFTF1 * asTF",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:242536,Energy Efficiency,reduce,reducedCovarianceMatrixTMatrixDSym,242536,"Number, double weight, double wgtErr)Set bin content of bin that was last loaded with get(std::size_t).Definition RooDataHist.cxx:1754; RooDataHist::binVolumedouble binVolume(std::size_t i) constReturn bin volume of i-th bin.Definition RooDataHist.h:118; RooDataHist::getconst RooArgSet * get() const overrideGet bin centre of current bin.Definition RooDataHist.h:82; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDerivativeRepresents the first, second, or third order derivative of any RooAbsReal as calculated (numerically)...Definition RooDerivative.h:30; RooFirstMomentDefinition RooFirstMoment.h:26; RooFitResultRooFitResult is a container class to hold the input and output of a PDF fit to a dataset.Definition RooFitResult.h:40; RooFitResult::covarianceMatrixconst TMatrixDSym & covarianceMatrix() constReturn covariance matrix.Definition RooFitResult.cxx:1112; RooFitResult::reducedCovarianceMatrixTMatrixDSym reducedCovarianceMatrix(const RooArgList &params) constReturn a reduced covariance matrix (Note that Vred is a simple sub-matrix of V, row/columns are order...Definition RooFitResult.cxx:1124; RooFitResult::floatParsFinalconst RooArgList & floatParsFinal() constReturn list of floating parameters after fit.Definition RooFitResult.h:111; RooFitResult::createHessePdfRooAbsPdf * createHessePdf(const RooArgSet &params) constReturn a p.d.f that represents the fit result as a multi-variate probability densisty function on the...Definition RooFitResult.cxx:1260; RooFit::Detail::CodeSquashContextA class to maintain the context for squashing of RooFit models into code.Definition CodeSquashContext.h:42; RooFit::EvalContextDefinition EvalContext.h:84; RooFit::EvalContext::atstd::span< const double > at(RooAbsArg const *arg, RooAbsArg const *caller=nullptr)Definition EvalContext.cxx:35; RooFit::EvalContext::outputstd::span< double > output()Definition EvalContext.h:112; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued obj",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:242571,Energy Efficiency,reduce,reducedCovarianceMatrix,242571,"Number, double weight, double wgtErr)Set bin content of bin that was last loaded with get(std::size_t).Definition RooDataHist.cxx:1754; RooDataHist::binVolumedouble binVolume(std::size_t i) constReturn bin volume of i-th bin.Definition RooDataHist.h:118; RooDataHist::getconst RooArgSet * get() const overrideGet bin centre of current bin.Definition RooDataHist.h:82; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDerivativeRepresents the first, second, or third order derivative of any RooAbsReal as calculated (numerically)...Definition RooDerivative.h:30; RooFirstMomentDefinition RooFirstMoment.h:26; RooFitResultRooFitResult is a container class to hold the input and output of a PDF fit to a dataset.Definition RooFitResult.h:40; RooFitResult::covarianceMatrixconst TMatrixDSym & covarianceMatrix() constReturn covariance matrix.Definition RooFitResult.cxx:1112; RooFitResult::reducedCovarianceMatrixTMatrixDSym reducedCovarianceMatrix(const RooArgList &params) constReturn a reduced covariance matrix (Note that Vred is a simple sub-matrix of V, row/columns are order...Definition RooFitResult.cxx:1124; RooFitResult::floatParsFinalconst RooArgList & floatParsFinal() constReturn list of floating parameters after fit.Definition RooFitResult.h:111; RooFitResult::createHessePdfRooAbsPdf * createHessePdf(const RooArgSet &params) constReturn a p.d.f that represents the fit result as a multi-variate probability densisty function on the...Definition RooFitResult.cxx:1260; RooFit::Detail::CodeSquashContextA class to maintain the context for squashing of RooFit models into code.Definition CodeSquashContext.h:42; RooFit::EvalContextDefinition EvalContext.h:84; RooFit::EvalContext::atstd::span< const double > at(RooAbsArg const *arg, RooAbsArg const *caller=nullptr)Definition EvalContext.cxx:35; RooFit::EvalContext::outputstd::span< double > output()Definition EvalContext.h:112; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued obj",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:242635,Energy Efficiency,reduce,reduced,242635,"Number, double weight, double wgtErr)Set bin content of bin that was last loaded with get(std::size_t).Definition RooDataHist.cxx:1754; RooDataHist::binVolumedouble binVolume(std::size_t i) constReturn bin volume of i-th bin.Definition RooDataHist.h:118; RooDataHist::getconst RooArgSet * get() const overrideGet bin centre of current bin.Definition RooDataHist.h:82; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDerivativeRepresents the first, second, or third order derivative of any RooAbsReal as calculated (numerically)...Definition RooDerivative.h:30; RooFirstMomentDefinition RooFirstMoment.h:26; RooFitResultRooFitResult is a container class to hold the input and output of a PDF fit to a dataset.Definition RooFitResult.h:40; RooFitResult::covarianceMatrixconst TMatrixDSym & covarianceMatrix() constReturn covariance matrix.Definition RooFitResult.cxx:1112; RooFitResult::reducedCovarianceMatrixTMatrixDSym reducedCovarianceMatrix(const RooArgList &params) constReturn a reduced covariance matrix (Note that Vred is a simple sub-matrix of V, row/columns are order...Definition RooFitResult.cxx:1124; RooFitResult::floatParsFinalconst RooArgList & floatParsFinal() constReturn list of floating parameters after fit.Definition RooFitResult.h:111; RooFitResult::createHessePdfRooAbsPdf * createHessePdf(const RooArgSet &params) constReturn a p.d.f that represents the fit result as a multi-variate probability densisty function on the...Definition RooFitResult.cxx:1260; RooFit::Detail::CodeSquashContextA class to maintain the context for squashing of RooFit models into code.Definition CodeSquashContext.h:42; RooFit::EvalContextDefinition EvalContext.h:84; RooFit::EvalContext::atstd::span< const double > at(RooAbsArg const *arg, RooAbsArg const *caller=nullptr)Definition EvalContext.cxx:35; RooFit::EvalContext::outputstd::span< double > output()Definition EvalContext.h:112; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued obj",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:243723,Energy Efficiency,adapt,adaptor,243723,"...Definition RooFitResult.cxx:1124; RooFitResult::floatParsFinalconst RooArgList & floatParsFinal() constReturn list of floating parameters after fit.Definition RooFitResult.h:111; RooFitResult::createHessePdfRooAbsPdf * createHessePdf(const RooArgSet &params) constReturn a p.d.f that represents the fit result as a multi-variate probability densisty function on the...Definition RooFitResult.cxx:1260; RooFit::Detail::CodeSquashContextA class to maintain the context for squashing of RooFit models into code.Definition CodeSquashContext.h:42; RooFit::EvalContextDefinition EvalContext.h:84; RooFit::EvalContext::atstd::span< const double > at(RooAbsArg const *arg, RooAbsArg const *caller=nullptr)Definition EvalContext.cxx:35; RooFit::EvalContext::outputstd::span< double > output()Definition EvalContext.h:112; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooFunctorLightweight interface adaptor that exports a RooAbsPdf as a functor.Definition RooFunctor.h:25; RooHistGraphical representation of binned data based on the TGraphAsymmErrors class.Definition RooHist.h:29; RooLinkedListCollection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list...Definition RooLinkedList.h:44; RooLinkedList::Deletevoid Delete(Option_t *o=nullptr) overrideRemove all elements in collection and delete all elements NB: Collection does not own elements,...Definition RooLinkedList.cxx:578; RooLinkedList::Addvirtual void Add(TObject *arg)Definition RooLinkedList.h:73; RooLinkedList::beginRooLinkedListIterImpl begin() constDefinition RooLinkedList.cxx:761; RooLinkedList::FindObjectTObject * FindObject(const char *name) const overrideReturn pointer to object with given name.Definition RooLinkedList.cxx:534; RooMomentDefinition RooMoment.h:26; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cx",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:1372,Integrability,interface,interface,1372,": *; 6 * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; 7 * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; 8 * *; 9 * Copyright (c) 2000-2005, Regents of the University of California *; 10 * and Stanford University. All rights reserved. *; 11 * *; 12 * Redistribution and use in source and binary forms, *; 13 * with or without modification, are permitted according to the terms *; 14 * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; 15 *****************************************************************************/; 16 ; 17//////////////////////////////////////////////////////////////////////////////; 18 ; 19/** \class RooAbsReal; 20 ; 21 Abstract base class for objects that represent a; 22 real value and implements functionality common to all real-valued objects; 23 such as the ability to plot them, to construct integrals of them, the; 24 ability to advertise (partial) analytical integrals etc.; 25 ; 26 Implementation of RooAbsReal may be derived, thus no interface; 27 is provided to modify the contents.; 28 ; 29 \ingroup Roofitcore; 30*/; 31 ; 32#include ""RooAbsReal.h""; 33 ; 34#include ""FitHelpers.h""; 35#include ""RooAbsCategoryLValue.h""; 36#include ""RooAbsData.h""; 37#include ""RooAddPdf.h""; 38#include ""RooAddition.h""; 39#include ""RooArgList.h""; 40#include ""RooArgProxy.h""; 41#include ""RooArgSet.h""; 42#include ""RooBinning.h""; 43#include ""RooBrentRootFinder.h""; 44#include ""RooCachedReal.h""; 45#include ""RooCategory.h""; 46#include ""RooCmdConfig.h""; 47#include ""RooConstVar.h""; 48#include ""RooCurve.h""; 49#include ""RooCustomizer.h""; 50#include ""RooDataHist.h""; 51#include ""RooDataSet.h""; 52#include ""RooDerivative.h""; 53#include ""RooFirstMoment.h""; 54#include ""RooFit/BatchModeDataHelpers.h""; 55#include ""RooFit/Evaluator.h""; 56#include ""RooFitResult.h""; 57#include ""RooFormulaVar.h""; 58#include ""RooFunctor.h""; 59#include ""RooGlobalFunc.h""; 60#include ""RooFitImplHelpers.h""; 61#include ""RooHist.h""; 62#include ""RooMoment.h""; 63#include ""RooMsgS",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:10670,Integrability,wrap,wrapper,10670," the cache is clean, return the; 297/// cached value, otherwise recalculate on the fly and refill; 298/// the cache; 299 ; 300double RooAbsReal::getValV(const RooArgSet* nset) const; 301{; 302 if (nset && nset->uniqueId().value() != _lastNormSetId) {; 303 const_cast<RooAbsReal*>(this)->setProxyNormSet(nset);; 304 _lastNormSetId = nset->uniqueId().value();; 305 }; 306 ; 307 if (isValueDirtyAndClear()) {; 308 _value = traceEval(nullptr) ;; 309 // clearValueDirty() ;; 310 }; 311 ; 312 return hideOffset() ? _value + offset() : _value;; 313}; 314 ; 315 ; 316////////////////////////////////////////////////////////////////////////////////; 317/// Calculate current value of object, with error tracing wrapper; 318 ; 319double RooAbsReal::traceEval(const RooArgSet* /*nset*/) const; 320{; 321 double value = evaluate() ;; 322 ; 323 if (TMath::IsNaN(value)) {; 324 logEvalError(""function value is NAN"") ;; 325 }; 326 ; 327 //cxcoutD(Tracing) << ""RooAbsReal::getValF("" << GetName() << "") operMode = "" << _operMode << "" recalculated, new value = "" << value << std::endl ;; 328 ; 329 //Standard tracing code goes here; 330 if (!isValidReal(value)) {; 331 coutW(Tracing) << ""RooAbsReal::traceEval("" << GetName(); 332 << ""): validation failed: "" << value << std::endl ;; 333 }; 334 ; 335 //Call optional subclass tracing code; 336 // traceEvalHook(value) ;; 337 ; 338 return value ;; 339}; 340 ; 341 ; 342 ; 343////////////////////////////////////////////////////////////////////////////////; 344/// Variant of getAnalyticalIntegral that is also passed the normalization set; 345/// that should be applied to the integrand of which the integral is requested.; 346/// For certain operator p.d.f it is useful to overload this function rather; 347/// than analyticalIntegralWN() as the additional normalization information; 348/// may be useful in determining a more efficient decomposition of the; 349/// requested integral.; 350 ; 351Int_t RooAbsReal::getAnalyticalIntegralWN(RooArgSet& allDeps, RooArgSet& a",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:12387,Integrability,depend,dependents,12387,"////////////////////////////////////////////////////////////; 344/// Variant of getAnalyticalIntegral that is also passed the normalization set; 345/// that should be applied to the integrand of which the integral is requested.; 346/// For certain operator p.d.f it is useful to overload this function rather; 347/// than analyticalIntegralWN() as the additional normalization information; 348/// may be useful in determining a more efficient decomposition of the; 349/// requested integral.; 350 ; 351Int_t RooAbsReal::getAnalyticalIntegralWN(RooArgSet& allDeps, RooArgSet& analDeps,; 352 const RooArgSet* /*normSet*/, const char* rangeName) const; 353{; 354 return _forceNumInt ? 0 : getAnalyticalIntegral(allDeps,analDeps,rangeName) ;; 355}; 356 ; 357 ; 358 ; 359////////////////////////////////////////////////////////////////////////////////; 360/// Interface function getAnalyticalIntergral advertises the; 361/// analytical integrals that are supported. 'integSet'; 362/// is the set of dependents for which integration is requested. The; 363/// function should copy the subset of dependents it can analytically; 364/// integrate to anaIntSet and return a unique identification code for; 365/// this integration configuration. If no integration can be; 366/// performed, zero should be returned.; 367 ; 368Int_t RooAbsReal::getAnalyticalIntegral(RooArgSet& /*integSet*/, RooArgSet& /*anaIntSet*/, const char* /*rangeName*/) const; 369{; 370 return 0 ;; 371}; 372 ; 373 ; 374 ; 375////////////////////////////////////////////////////////////////////////////////; 376/// Implements the actual analytical integral(s) advertised by; 377/// getAnalyticalIntegral. This functions will only be called with; 378/// codes returned by getAnalyticalIntegral, except code zero.; 379 ; 380double RooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName) const; 381{; 382// cout << ""RooAbsReal::analyticalIntegralWN("" << GetName() << "") code = "" << code << "" normSet = "" ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:12408,Integrability,integrat,integration,12408,"////////////////////////////////////////////////////////////; 344/// Variant of getAnalyticalIntegral that is also passed the normalization set; 345/// that should be applied to the integrand of which the integral is requested.; 346/// For certain operator p.d.f it is useful to overload this function rather; 347/// than analyticalIntegralWN() as the additional normalization information; 348/// may be useful in determining a more efficient decomposition of the; 349/// requested integral.; 350 ; 351Int_t RooAbsReal::getAnalyticalIntegralWN(RooArgSet& allDeps, RooArgSet& analDeps,; 352 const RooArgSet* /*normSet*/, const char* rangeName) const; 353{; 354 return _forceNumInt ? 0 : getAnalyticalIntegral(allDeps,analDeps,rangeName) ;; 355}; 356 ; 357 ; 358 ; 359////////////////////////////////////////////////////////////////////////////////; 360/// Interface function getAnalyticalIntergral advertises the; 361/// analytical integrals that are supported. 'integSet'; 362/// is the set of dependents for which integration is requested. The; 363/// function should copy the subset of dependents it can analytically; 364/// integrate to anaIntSet and return a unique identification code for; 365/// this integration configuration. If no integration can be; 366/// performed, zero should be returned.; 367 ; 368Int_t RooAbsReal::getAnalyticalIntegral(RooArgSet& /*integSet*/, RooArgSet& /*anaIntSet*/, const char* /*rangeName*/) const; 369{; 370 return 0 ;; 371}; 372 ; 373 ; 374 ; 375////////////////////////////////////////////////////////////////////////////////; 376/// Implements the actual analytical integral(s) advertised by; 377/// getAnalyticalIntegral. This functions will only be called with; 378/// codes returned by getAnalyticalIntegral, except code zero.; 379 ; 380double RooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName) const; 381{; 382// cout << ""RooAbsReal::analyticalIntegralWN("" << GetName() << "") code = "" << code << "" normSet = "" ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:12481,Integrability,depend,dependents,12481,"ion set; 345/// that should be applied to the integrand of which the integral is requested.; 346/// For certain operator p.d.f it is useful to overload this function rather; 347/// than analyticalIntegralWN() as the additional normalization information; 348/// may be useful in determining a more efficient decomposition of the; 349/// requested integral.; 350 ; 351Int_t RooAbsReal::getAnalyticalIntegralWN(RooArgSet& allDeps, RooArgSet& analDeps,; 352 const RooArgSet* /*normSet*/, const char* rangeName) const; 353{; 354 return _forceNumInt ? 0 : getAnalyticalIntegral(allDeps,analDeps,rangeName) ;; 355}; 356 ; 357 ; 358 ; 359////////////////////////////////////////////////////////////////////////////////; 360/// Interface function getAnalyticalIntergral advertises the; 361/// analytical integrals that are supported. 'integSet'; 362/// is the set of dependents for which integration is requested. The; 363/// function should copy the subset of dependents it can analytically; 364/// integrate to anaIntSet and return a unique identification code for; 365/// this integration configuration. If no integration can be; 366/// performed, zero should be returned.; 367 ; 368Int_t RooAbsReal::getAnalyticalIntegral(RooArgSet& /*integSet*/, RooArgSet& /*anaIntSet*/, const char* /*rangeName*/) const; 369{; 370 return 0 ;; 371}; 372 ; 373 ; 374 ; 375////////////////////////////////////////////////////////////////////////////////; 376/// Implements the actual analytical integral(s) advertised by; 377/// getAnalyticalIntegral. This functions will only be called with; 378/// codes returned by getAnalyticalIntegral, except code zero.; 379 ; 380double RooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName) const; 381{; 382// cout << ""RooAbsReal::analyticalIntegralWN("" << GetName() << "") code = "" << code << "" normSet = "" << (normSet?*normSet:RooArgSet()) << std::endl ;; 383 if (code==0) return getVal(normSet) ;; 384 return analyticalIntegral(code,rangeName",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:12520,Integrability,integrat,integrate,12520,"ion set; 345/// that should be applied to the integrand of which the integral is requested.; 346/// For certain operator p.d.f it is useful to overload this function rather; 347/// than analyticalIntegralWN() as the additional normalization information; 348/// may be useful in determining a more efficient decomposition of the; 349/// requested integral.; 350 ; 351Int_t RooAbsReal::getAnalyticalIntegralWN(RooArgSet& allDeps, RooArgSet& analDeps,; 352 const RooArgSet* /*normSet*/, const char* rangeName) const; 353{; 354 return _forceNumInt ? 0 : getAnalyticalIntegral(allDeps,analDeps,rangeName) ;; 355}; 356 ; 357 ; 358 ; 359////////////////////////////////////////////////////////////////////////////////; 360/// Interface function getAnalyticalIntergral advertises the; 361/// analytical integrals that are supported. 'integSet'; 362/// is the set of dependents for which integration is requested. The; 363/// function should copy the subset of dependents it can analytically; 364/// integrate to anaIntSet and return a unique identification code for; 365/// this integration configuration. If no integration can be; 366/// performed, zero should be returned.; 367 ; 368Int_t RooAbsReal::getAnalyticalIntegral(RooArgSet& /*integSet*/, RooArgSet& /*anaIntSet*/, const char* /*rangeName*/) const; 369{; 370 return 0 ;; 371}; 372 ; 373 ; 374 ; 375////////////////////////////////////////////////////////////////////////////////; 376/// Implements the actual analytical integral(s) advertised by; 377/// getAnalyticalIntegral. This functions will only be called with; 378/// codes returned by getAnalyticalIntegral, except code zero.; 379 ; 380double RooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName) const; 381{; 382// cout << ""RooAbsReal::analyticalIntegralWN("" << GetName() << "") code = "" << code << "" normSet = "" << (normSet?*normSet:RooArgSet()) << std::endl ;; 383 if (code==0) return getVal(normSet) ;; 384 return analyticalIntegral(code,rangeName",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:12600,Integrability,integrat,integration,12600,"ion set; 345/// that should be applied to the integrand of which the integral is requested.; 346/// For certain operator p.d.f it is useful to overload this function rather; 347/// than analyticalIntegralWN() as the additional normalization information; 348/// may be useful in determining a more efficient decomposition of the; 349/// requested integral.; 350 ; 351Int_t RooAbsReal::getAnalyticalIntegralWN(RooArgSet& allDeps, RooArgSet& analDeps,; 352 const RooArgSet* /*normSet*/, const char* rangeName) const; 353{; 354 return _forceNumInt ? 0 : getAnalyticalIntegral(allDeps,analDeps,rangeName) ;; 355}; 356 ; 357 ; 358 ; 359////////////////////////////////////////////////////////////////////////////////; 360/// Interface function getAnalyticalIntergral advertises the; 361/// analytical integrals that are supported. 'integSet'; 362/// is the set of dependents for which integration is requested. The; 363/// function should copy the subset of dependents it can analytically; 364/// integrate to anaIntSet and return a unique identification code for; 365/// this integration configuration. If no integration can be; 366/// performed, zero should be returned.; 367 ; 368Int_t RooAbsReal::getAnalyticalIntegral(RooArgSet& /*integSet*/, RooArgSet& /*anaIntSet*/, const char* /*rangeName*/) const; 369{; 370 return 0 ;; 371}; 372 ; 373 ; 374 ; 375////////////////////////////////////////////////////////////////////////////////; 376/// Implements the actual analytical integral(s) advertised by; 377/// getAnalyticalIntegral. This functions will only be called with; 378/// codes returned by getAnalyticalIntegral, except code zero.; 379 ; 380double RooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName) const; 381{; 382// cout << ""RooAbsReal::analyticalIntegralWN("" << GetName() << "") code = "" << code << "" normSet = "" << (normSet?*normSet:RooArgSet()) << std::endl ;; 383 if (code==0) return getVal(normSet) ;; 384 return analyticalIntegral(code,rangeName",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:12633,Integrability,integrat,integration,12633,"s useful to overload this function rather; 347/// than analyticalIntegralWN() as the additional normalization information; 348/// may be useful in determining a more efficient decomposition of the; 349/// requested integral.; 350 ; 351Int_t RooAbsReal::getAnalyticalIntegralWN(RooArgSet& allDeps, RooArgSet& analDeps,; 352 const RooArgSet* /*normSet*/, const char* rangeName) const; 353{; 354 return _forceNumInt ? 0 : getAnalyticalIntegral(allDeps,analDeps,rangeName) ;; 355}; 356 ; 357 ; 358 ; 359////////////////////////////////////////////////////////////////////////////////; 360/// Interface function getAnalyticalIntergral advertises the; 361/// analytical integrals that are supported. 'integSet'; 362/// is the set of dependents for which integration is requested. The; 363/// function should copy the subset of dependents it can analytically; 364/// integrate to anaIntSet and return a unique identification code for; 365/// this integration configuration. If no integration can be; 366/// performed, zero should be returned.; 367 ; 368Int_t RooAbsReal::getAnalyticalIntegral(RooArgSet& /*integSet*/, RooArgSet& /*anaIntSet*/, const char* /*rangeName*/) const; 369{; 370 return 0 ;; 371}; 372 ; 373 ; 374 ; 375////////////////////////////////////////////////////////////////////////////////; 376/// Implements the actual analytical integral(s) advertised by; 377/// getAnalyticalIntegral. This functions will only be called with; 378/// codes returned by getAnalyticalIntegral, except code zero.; 379 ; 380double RooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName) const; 381{; 382// cout << ""RooAbsReal::analyticalIntegralWN("" << GetName() << "") code = "" << code << "" normSet = "" << (normSet?*normSet:RooArgSet()) << std::endl ;; 383 if (code==0) return getVal(normSet) ;; 384 return analyticalIntegral(code,rangeName) ;; 385}; 386 ; 387 ; 388 ; 389////////////////////////////////////////////////////////////////////////////////; 390/// Implements",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:17305,Integrability,integrat,integration,17305,"n except the stated paramsOfInterest; 470 ; 471RooFit::OwningPtr<RooAbsReal> RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); 472{; 473 // Construct name of profile object; 474 auto name = std::string(GetName()) + ""_Profile["";; 475 bool first = true;; 476 for (auto const& arg : paramsOfInterest) {; 477 if (first) {; 478 first = false ;; 479 } else {; 480 name.append("","") ;; 481 }; 482 name.append(arg->GetName()) ;; 483 }; 484 name.append(""]"") ;; 485 ; 486 // Create and return profile object; 487 auto out = std::make_unique<RooProfileLL>(name.c_str(),(std::string(""Profile of "") + GetTitle()).c_str(),*this,paramsOfInterest);; 488 return RooFit::makeOwningPtr<RooAbsReal>(std::move(out));; 489}; 490 ; 491 ; 492 ; 493 ; 494 ; 495 ; 496////////////////////////////////////////////////////////////////////////////////; 497/// Create an object that represents the integral of the function over one or more observables listed in `iset`.; 498/// The actual integration calculation is only performed when the returned object is evaluated. The name; 499/// of the integral object is automatically constructed from the name of the input function, the variables; 500/// it integrates and the range integrates over.; 501///; 502/// \note The integral over a PDF is usually not normalised (*i.e.*, it is usually not; 503/// 1 when integrating the PDF over the full range). In fact, this integral is used *to compute*; 504/// the normalisation of each PDF. See the [rf110 tutorial](group__tutorial__roofit.html); 505/// for details on PDF normalisation.; 506///; 507/// The following named arguments are accepted; 508/// | | Effect on integral creation; 509/// |--|-------------------------------; 510/// | `NormSet(const RooArgSet&)` | Specify normalization set, mostly useful when working with PDFs; 511/// | `NumIntConfig(const RooNumIntConfig&)` | Use given configuration for any numeric integration, if necessary; 512/// | `Range(const char* name)` | Integrate only over given range. Multi",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:17517,Integrability,integrat,integrates,17517,"); 472{; 473 // Construct name of profile object; 474 auto name = std::string(GetName()) + ""_Profile["";; 475 bool first = true;; 476 for (auto const& arg : paramsOfInterest) {; 477 if (first) {; 478 first = false ;; 479 } else {; 480 name.append("","") ;; 481 }; 482 name.append(arg->GetName()) ;; 483 }; 484 name.append(""]"") ;; 485 ; 486 // Create and return profile object; 487 auto out = std::make_unique<RooProfileLL>(name.c_str(),(std::string(""Profile of "") + GetTitle()).c_str(),*this,paramsOfInterest);; 488 return RooFit::makeOwningPtr<RooAbsReal>(std::move(out));; 489}; 490 ; 491 ; 492 ; 493 ; 494 ; 495 ; 496////////////////////////////////////////////////////////////////////////////////; 497/// Create an object that represents the integral of the function over one or more observables listed in `iset`.; 498/// The actual integration calculation is only performed when the returned object is evaluated. The name; 499/// of the integral object is automatically constructed from the name of the input function, the variables; 500/// it integrates and the range integrates over.; 501///; 502/// \note The integral over a PDF is usually not normalised (*i.e.*, it is usually not; 503/// 1 when integrating the PDF over the full range). In fact, this integral is used *to compute*; 504/// the normalisation of each PDF. See the [rf110 tutorial](group__tutorial__roofit.html); 505/// for details on PDF normalisation.; 506///; 507/// The following named arguments are accepted; 508/// | | Effect on integral creation; 509/// |--|-------------------------------; 510/// | `NormSet(const RooArgSet&)` | Specify normalization set, mostly useful when working with PDFs; 511/// | `NumIntConfig(const RooNumIntConfig&)` | Use given configuration for any numeric integration, if necessary; 512/// | `Range(const char* name)` | Integrate only over given range. Multiple ranges may be specified by passing multiple Range() arguments; 513 ; 514RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(cons",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:17542,Integrability,integrat,integrates,17542,"); 472{; 473 // Construct name of profile object; 474 auto name = std::string(GetName()) + ""_Profile["";; 475 bool first = true;; 476 for (auto const& arg : paramsOfInterest) {; 477 if (first) {; 478 first = false ;; 479 } else {; 480 name.append("","") ;; 481 }; 482 name.append(arg->GetName()) ;; 483 }; 484 name.append(""]"") ;; 485 ; 486 // Create and return profile object; 487 auto out = std::make_unique<RooProfileLL>(name.c_str(),(std::string(""Profile of "") + GetTitle()).c_str(),*this,paramsOfInterest);; 488 return RooFit::makeOwningPtr<RooAbsReal>(std::move(out));; 489}; 490 ; 491 ; 492 ; 493 ; 494 ; 495 ; 496////////////////////////////////////////////////////////////////////////////////; 497/// Create an object that represents the integral of the function over one or more observables listed in `iset`.; 498/// The actual integration calculation is only performed when the returned object is evaluated. The name; 499/// of the integral object is automatically constructed from the name of the input function, the variables; 500/// it integrates and the range integrates over.; 501///; 502/// \note The integral over a PDF is usually not normalised (*i.e.*, it is usually not; 503/// 1 when integrating the PDF over the full range). In fact, this integral is used *to compute*; 504/// the normalisation of each PDF. See the [rf110 tutorial](group__tutorial__roofit.html); 505/// for details on PDF normalisation.; 506///; 507/// The following named arguments are accepted; 508/// | | Effect on integral creation; 509/// |--|-------------------------------; 510/// | `NormSet(const RooArgSet&)` | Specify normalization set, mostly useful when working with PDFs; 511/// | `NumIntConfig(const RooNumIntConfig&)` | Use given configuration for any numeric integration, if necessary; 512/// | `Range(const char* name)` | Integrate only over given range. Multiple ranges may be specified by passing multiple Range() arguments; 513 ; 514RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(cons",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:17673,Integrability,integrat,integrating,17673," = false ;; 479 } else {; 480 name.append("","") ;; 481 }; 482 name.append(arg->GetName()) ;; 483 }; 484 name.append(""]"") ;; 485 ; 486 // Create and return profile object; 487 auto out = std::make_unique<RooProfileLL>(name.c_str(),(std::string(""Profile of "") + GetTitle()).c_str(),*this,paramsOfInterest);; 488 return RooFit::makeOwningPtr<RooAbsReal>(std::move(out));; 489}; 490 ; 491 ; 492 ; 493 ; 494 ; 495 ; 496////////////////////////////////////////////////////////////////////////////////; 497/// Create an object that represents the integral of the function over one or more observables listed in `iset`.; 498/// The actual integration calculation is only performed when the returned object is evaluated. The name; 499/// of the integral object is automatically constructed from the name of the input function, the variables; 500/// it integrates and the range integrates over.; 501///; 502/// \note The integral over a PDF is usually not normalised (*i.e.*, it is usually not; 503/// 1 when integrating the PDF over the full range). In fact, this integral is used *to compute*; 504/// the normalisation of each PDF. See the [rf110 tutorial](group__tutorial__roofit.html); 505/// for details on PDF normalisation.; 506///; 507/// The following named arguments are accepted; 508/// | | Effect on integral creation; 509/// |--|-------------------------------; 510/// | `NormSet(const RooArgSet&)` | Specify normalization set, mostly useful when working with PDFs; 511/// | `NumIntConfig(const RooNumIntConfig&)` | Use given configuration for any numeric integration, if necessary; 512/// | `Range(const char* name)` | Integrate only over given range. Multiple ranges may be specified by passing multiple Range() arguments; 513 ; 514RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2,; 515 const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5,; 516 const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdAr",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:18233,Integrability,integrat,integration,18233,"/////////////////////////////////////////////////////////; 497/// Create an object that represents the integral of the function over one or more observables listed in `iset`.; 498/// The actual integration calculation is only performed when the returned object is evaluated. The name; 499/// of the integral object is automatically constructed from the name of the input function, the variables; 500/// it integrates and the range integrates over.; 501///; 502/// \note The integral over a PDF is usually not normalised (*i.e.*, it is usually not; 503/// 1 when integrating the PDF over the full range). In fact, this integral is used *to compute*; 504/// the normalisation of each PDF. See the [rf110 tutorial](group__tutorial__roofit.html); 505/// for details on PDF normalisation.; 506///; 507/// The following named arguments are accepted; 508/// | | Effect on integral creation; 509/// |--|-------------------------------; 510/// | `NormSet(const RooArgSet&)` | Specify normalization set, mostly useful when working with PDFs; 511/// | `NumIntConfig(const RooNumIntConfig&)` | Use given configuration for any numeric integration, if necessary; 512/// | `Range(const char* name)` | Integrate only over given range. Multiple ranges may be specified by passing multiple Range() arguments; 513 ; 514RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2,; 515 const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5,; 516 const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 517{; 518 // Define configuration for this method; 519 RooCmdConfig pc(""RooAbsReal::createIntegral("" + std::string(GetName()) + "")"");; 520 pc.defineString(""rangeName"",""RangeWithName"",0,"""",true) ;; 521 pc.defineSet(""normSet"",""NormSet"",0,nullptr) ;; 522 pc.defineObject(""numIntConfig"",""NumIntConfig"",0,nullptr) ;; 523 ; 524 // Process & check varargs; 525 pc.process(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8) ;; 526 if (!pc",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:19757,Integrability,integrat,integration,19757,"gral("" + std::string(GetName()) + "")"");; 520 pc.defineString(""rangeName"",""RangeWithName"",0,"""",true) ;; 521 pc.defineSet(""normSet"",""NormSet"",0,nullptr) ;; 522 pc.defineObject(""numIntConfig"",""NumIntConfig"",0,nullptr) ;; 523 ; 524 // Process & check varargs; 525 pc.process(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8) ;; 526 if (!pc.ok(true)) {; 527 return nullptr;; 528 }; 529 ; 530 // Extract values from named arguments; 531 const char* rangeName = pc.getString(""rangeName"",nullptr,true) ;; 532 const RooArgSet* nset = pc.getSet(""normSet"",nullptr);; 533 const RooNumIntConfig* cfg = static_cast<const RooNumIntConfig*>(pc.getObject(""numIntConfig"",nullptr)) ;; 534 ; 535 return createIntegral(iset,nset,cfg,rangeName) ;; 536}; 537 ; 538 ; 539 ; 540 ; 541 ; 542////////////////////////////////////////////////////////////////////////////////; 543/// Create an object that represents the integral of the function over one or more observables listed in iset.; 544/// The actual integration calculation is only performed when the return object is evaluated. The name; 545/// of the integral object is automatically constructed from the name of the input function, the variables; 546/// it integrates and the range integrates over. If nset is specified the integrand is request; 547/// to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; 548/// the integral is performed over the named range, otherwise it is performed over the domain of each; 549/// integrated observable. If cfg is specified it will be used to configure any numeric integration; 550/// aspect of the integral. It will not force the integral to be performed numerically, which is; 551/// decided automatically by RooRealIntegral.; 552 ; 553RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset,; 554 const RooNumIntConfig* cfg, const char* rangeName) const; 555{; 556 if (!rangeName || strchr(rangeName,',')==nullptr) {; 557 // Simple case: int",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:19967,Integrability,integrat,integrates,19967,"Set"",0,nullptr) ;; 522 pc.defineObject(""numIntConfig"",""NumIntConfig"",0,nullptr) ;; 523 ; 524 // Process & check varargs; 525 pc.process(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8) ;; 526 if (!pc.ok(true)) {; 527 return nullptr;; 528 }; 529 ; 530 // Extract values from named arguments; 531 const char* rangeName = pc.getString(""rangeName"",nullptr,true) ;; 532 const RooArgSet* nset = pc.getSet(""normSet"",nullptr);; 533 const RooNumIntConfig* cfg = static_cast<const RooNumIntConfig*>(pc.getObject(""numIntConfig"",nullptr)) ;; 534 ; 535 return createIntegral(iset,nset,cfg,rangeName) ;; 536}; 537 ; 538 ; 539 ; 540 ; 541 ; 542////////////////////////////////////////////////////////////////////////////////; 543/// Create an object that represents the integral of the function over one or more observables listed in iset.; 544/// The actual integration calculation is only performed when the return object is evaluated. The name; 545/// of the integral object is automatically constructed from the name of the input function, the variables; 546/// it integrates and the range integrates over. If nset is specified the integrand is request; 547/// to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; 548/// the integral is performed over the named range, otherwise it is performed over the domain of each; 549/// integrated observable. If cfg is specified it will be used to configure any numeric integration; 550/// aspect of the integral. It will not force the integral to be performed numerically, which is; 551/// decided automatically by RooRealIntegral.; 552 ; 553RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset,; 554 const RooNumIntConfig* cfg, const char* rangeName) const; 555{; 556 if (!rangeName || strchr(rangeName,',')==nullptr) {; 557 // Simple case: integral over full range or single limited range; 558 return createIntObj(iset,nset,cfg,rangeName);; 559 }; 560 ; 561 // Integral over mult",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:19992,Integrability,integrat,integrates,19992,"Set"",0,nullptr) ;; 522 pc.defineObject(""numIntConfig"",""NumIntConfig"",0,nullptr) ;; 523 ; 524 // Process & check varargs; 525 pc.process(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8) ;; 526 if (!pc.ok(true)) {; 527 return nullptr;; 528 }; 529 ; 530 // Extract values from named arguments; 531 const char* rangeName = pc.getString(""rangeName"",nullptr,true) ;; 532 const RooArgSet* nset = pc.getSet(""normSet"",nullptr);; 533 const RooNumIntConfig* cfg = static_cast<const RooNumIntConfig*>(pc.getObject(""numIntConfig"",nullptr)) ;; 534 ; 535 return createIntegral(iset,nset,cfg,rangeName) ;; 536}; 537 ; 538 ; 539 ; 540 ; 541 ; 542////////////////////////////////////////////////////////////////////////////////; 543/// Create an object that represents the integral of the function over one or more observables listed in iset.; 544/// The actual integration calculation is only performed when the return object is evaluated. The name; 545/// of the integral object is automatically constructed from the name of the input function, the variables; 546/// it integrates and the range integrates over. If nset is specified the integrand is request; 547/// to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; 548/// the integral is performed over the named range, otherwise it is performed over the domain of each; 549/// integrated observable. If cfg is specified it will be used to configure any numeric integration; 550/// aspect of the integral. It will not force the integral to be performed numerically, which is; 551/// decided automatically by RooRealIntegral.; 552 ; 553RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset,; 554 const RooNumIntConfig* cfg, const char* rangeName) const; 555{; 556 if (!rangeName || strchr(rangeName,',')==nullptr) {; 557 // Simple case: integral over full range or single limited range; 558 return createIntObj(iset,nset,cfg,rangeName);; 559 }; 560 ; 561 // Integral over mult",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:20277,Integrability,integrat,integrated,20277,"r* rangeName = pc.getString(""rangeName"",nullptr,true) ;; 532 const RooArgSet* nset = pc.getSet(""normSet"",nullptr);; 533 const RooNumIntConfig* cfg = static_cast<const RooNumIntConfig*>(pc.getObject(""numIntConfig"",nullptr)) ;; 534 ; 535 return createIntegral(iset,nset,cfg,rangeName) ;; 536}; 537 ; 538 ; 539 ; 540 ; 541 ; 542////////////////////////////////////////////////////////////////////////////////; 543/// Create an object that represents the integral of the function over one or more observables listed in iset.; 544/// The actual integration calculation is only performed when the return object is evaluated. The name; 545/// of the integral object is automatically constructed from the name of the input function, the variables; 546/// it integrates and the range integrates over. If nset is specified the integrand is request; 547/// to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; 548/// the integral is performed over the named range, otherwise it is performed over the domain of each; 549/// integrated observable. If cfg is specified it will be used to configure any numeric integration; 550/// aspect of the integral. It will not force the integral to be performed numerically, which is; 551/// decided automatically by RooRealIntegral.; 552 ; 553RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset,; 554 const RooNumIntConfig* cfg, const char* rangeName) const; 555{; 556 if (!rangeName || strchr(rangeName,',')==nullptr) {; 557 // Simple case: integral over full range or single limited range; 558 return createIntObj(iset,nset,cfg,rangeName);; 559 }; 560 ; 561 // Integral over multiple ranges; 562 std::vector<std::string> tokens = ROOT::Split(rangeName, "","");; 563 ; 564 if(RooHelpers::checkIfRangesOverlap(iset, tokens)) {; 565 std::stringstream errMsg;; 566 errMsg << GetName() << "" : integrating with respect to the variables "" << iset << "" on the ranges \"""" << rangeName; ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:20361,Integrability,integrat,integration,20361,"tConfig* cfg = static_cast<const RooNumIntConfig*>(pc.getObject(""numIntConfig"",nullptr)) ;; 534 ; 535 return createIntegral(iset,nset,cfg,rangeName) ;; 536}; 537 ; 538 ; 539 ; 540 ; 541 ; 542////////////////////////////////////////////////////////////////////////////////; 543/// Create an object that represents the integral of the function over one or more observables listed in iset.; 544/// The actual integration calculation is only performed when the return object is evaluated. The name; 545/// of the integral object is automatically constructed from the name of the input function, the variables; 546/// it integrates and the range integrates over. If nset is specified the integrand is request; 547/// to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; 548/// the integral is performed over the named range, otherwise it is performed over the domain of each; 549/// integrated observable. If cfg is specified it will be used to configure any numeric integration; 550/// aspect of the integral. It will not force the integral to be performed numerically, which is; 551/// decided automatically by RooRealIntegral.; 552 ; 553RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset,; 554 const RooNumIntConfig* cfg, const char* rangeName) const; 555{; 556 if (!rangeName || strchr(rangeName,',')==nullptr) {; 557 // Simple case: integral over full range or single limited range; 558 return createIntObj(iset,nset,cfg,rangeName);; 559 }; 560 ; 561 // Integral over multiple ranges; 562 std::vector<std::string> tokens = ROOT::Split(rangeName, "","");; 563 ; 564 if(RooHelpers::checkIfRangesOverlap(iset, tokens)) {; 565 std::stringstream errMsg;; 566 errMsg << GetName() << "" : integrating with respect to the variables "" << iset << "" on the ranges \"""" << rangeName; 567 << ""\"" is not possible because the ranges are overlapping"";; 568 const std::string errMsgString = errMsg.str();; 569 coutE(Integra",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:21129,Integrability,integrat,integrating,21129," input function, the variables; 546/// it integrates and the range integrates over. If nset is specified the integrand is request; 547/// to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; 548/// the integral is performed over the named range, otherwise it is performed over the domain of each; 549/// integrated observable. If cfg is specified it will be used to configure any numeric integration; 550/// aspect of the integral. It will not force the integral to be performed numerically, which is; 551/// decided automatically by RooRealIntegral.; 552 ; 553RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset,; 554 const RooNumIntConfig* cfg, const char* rangeName) const; 555{; 556 if (!rangeName || strchr(rangeName,',')==nullptr) {; 557 // Simple case: integral over full range or single limited range; 558 return createIntObj(iset,nset,cfg,rangeName);; 559 }; 560 ; 561 // Integral over multiple ranges; 562 std::vector<std::string> tokens = ROOT::Split(rangeName, "","");; 563 ; 564 if(RooHelpers::checkIfRangesOverlap(iset, tokens)) {; 565 std::stringstream errMsg;; 566 errMsg << GetName() << "" : integrating with respect to the variables "" << iset << "" on the ranges \"""" << rangeName; 567 << ""\"" is not possible because the ranges are overlapping"";; 568 const std::string errMsgString = errMsg.str();; 569 coutE(Integration) << errMsgString << std::endl;; 570 throw std::invalid_argument(errMsgString);; 571 }; 572 ; 573 RooArgSet components ;; 574 for (const std::string& token : tokens) {; 575 components.addOwned(std::unique_ptr<RooAbsReal>{createIntObj(iset,nset,cfg, token.c_str())});; 576 }; 577 ; 578 const std::string title = std::string(""Integral of "") + GetTitle();; 579 const std::string fullName = std::string(GetName()) + integralNameSuffix(iset,nset,rangeName).Data();; 580 ; 581 auto out = std::make_unique<RooAddition>(fullName.c_str(), title.c_str(), components);; 582 out->a",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:22753,Integrability,integrat,integration,22753,"tokens) {; 575 components.addOwned(std::unique_ptr<RooAbsReal>{createIntObj(iset,nset,cfg, token.c_str())});; 576 }; 577 ; 578 const std::string title = std::string(""Integral of "") + GetTitle();; 579 const std::string fullName = std::string(GetName()) + integralNameSuffix(iset,nset,rangeName).Data();; 580 ; 581 auto out = std::make_unique<RooAddition>(fullName.c_str(), title.c_str(), components);; 582 out->addOwnedComponents(std::move(components));; 583 return RooFit::makeOwningPtr<RooAbsReal>(std::move(out));; 584}; 585 ; 586 ; 587 ; 588////////////////////////////////////////////////////////////////////////////////; 589/// Internal utility function for createIntegral() that creates the actual integral object.; 590RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntObj(const RooArgSet& iset2, const RooArgSet* nset2,; 591 const RooNumIntConfig* cfg, const char* rangeName) const; 592{; 593 // Make internal use copies of iset and nset; 594 RooArgSet iset(iset2) ;; 595 const RooArgSet* nset = nset2 ;; 596 ; 597 ; 598 // Initialize local variables perparing for recursive loop; 599 bool error = false ;; 600 const RooAbsReal* integrand = this ;; 601 std::unique_ptr<RooAbsReal> integral;; 602 ; 603 // Handle trivial case of no integration here explicitly; 604 if (iset.empty()) {; 605 ; 606 const std::string title = std::string(""Integral of "") + GetTitle();; 607 const std::string name = std::string(GetName()) + integralNameSuffix(iset,nset,rangeName).Data();; 608 ; 609 auto out = std::make_unique<RooRealIntegral>(name.c_str(), title.c_str(), *this, iset, nset, cfg, rangeName);; 610 return RooFit::makeOwningPtr<RooAbsReal>(std::move(out));; 611 }; 612 ; 613 // Process integration over remaining integration variables; 614 while(!iset.empty()) {; 615 ; 616 ; 617 // Find largest set of observables that can be integrated in one go; 618 RooArgSet innerSet ;; 619 findInnerMostIntegration(iset,innerSet,rangeName) ;; 620 ; 621 // If largest set of observables that can be integrated is",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:23201,Integrability,integrat,integration,23201,"unction for createIntegral() that creates the actual integral object.; 590RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntObj(const RooArgSet& iset2, const RooArgSet* nset2,; 591 const RooNumIntConfig* cfg, const char* rangeName) const; 592{; 593 // Make internal use copies of iset and nset; 594 RooArgSet iset(iset2) ;; 595 const RooArgSet* nset = nset2 ;; 596 ; 597 ; 598 // Initialize local variables perparing for recursive loop; 599 bool error = false ;; 600 const RooAbsReal* integrand = this ;; 601 std::unique_ptr<RooAbsReal> integral;; 602 ; 603 // Handle trivial case of no integration here explicitly; 604 if (iset.empty()) {; 605 ; 606 const std::string title = std::string(""Integral of "") + GetTitle();; 607 const std::string name = std::string(GetName()) + integralNameSuffix(iset,nset,rangeName).Data();; 608 ; 609 auto out = std::make_unique<RooRealIntegral>(name.c_str(), title.c_str(), *this, iset, nset, cfg, rangeName);; 610 return RooFit::makeOwningPtr<RooAbsReal>(std::move(out));; 611 }; 612 ; 613 // Process integration over remaining integration variables; 614 while(!iset.empty()) {; 615 ; 616 ; 617 // Find largest set of observables that can be integrated in one go; 618 RooArgSet innerSet ;; 619 findInnerMostIntegration(iset,innerSet,rangeName) ;; 620 ; 621 // If largest set of observables that can be integrated is empty set, problem was ill defined; 622 // Postpone error messaging and handling to end of function, exit loop here; 623 if (innerSet.empty()) {; 624 error = true ;; 625 break ;; 626 }; 627 ; 628 // Prepare name and title of integral to be created; 629 const std::string title = std::string(""Integral of "") + integrand->GetTitle();; 630 const std::string name = std::string(integrand->GetName()) + integrand->integralNameSuffix(innerSet,nset,rangeName).Data();; 631 ; 632 std::unique_ptr<RooAbsReal> innerIntegral = std::move(integral);; 633 ; 634 // Construct innermost integral; 635 integral = std::make_unique<RooRealIntegral>(name.c_str(),title.c",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:23228,Integrability,integrat,integration,23228,"unction for createIntegral() that creates the actual integral object.; 590RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntObj(const RooArgSet& iset2, const RooArgSet* nset2,; 591 const RooNumIntConfig* cfg, const char* rangeName) const; 592{; 593 // Make internal use copies of iset and nset; 594 RooArgSet iset(iset2) ;; 595 const RooArgSet* nset = nset2 ;; 596 ; 597 ; 598 // Initialize local variables perparing for recursive loop; 599 bool error = false ;; 600 const RooAbsReal* integrand = this ;; 601 std::unique_ptr<RooAbsReal> integral;; 602 ; 603 // Handle trivial case of no integration here explicitly; 604 if (iset.empty()) {; 605 ; 606 const std::string title = std::string(""Integral of "") + GetTitle();; 607 const std::string name = std::string(GetName()) + integralNameSuffix(iset,nset,rangeName).Data();; 608 ; 609 auto out = std::make_unique<RooRealIntegral>(name.c_str(), title.c_str(), *this, iset, nset, cfg, rangeName);; 610 return RooFit::makeOwningPtr<RooAbsReal>(std::move(out));; 611 }; 612 ; 613 // Process integration over remaining integration variables; 614 while(!iset.empty()) {; 615 ; 616 ; 617 // Find largest set of observables that can be integrated in one go; 618 RooArgSet innerSet ;; 619 findInnerMostIntegration(iset,innerSet,rangeName) ;; 620 ; 621 // If largest set of observables that can be integrated is empty set, problem was ill defined; 622 // Postpone error messaging and handling to end of function, exit loop here; 623 if (innerSet.empty()) {; 624 error = true ;; 625 break ;; 626 }; 627 ; 628 // Prepare name and title of integral to be created; 629 const std::string title = std::string(""Integral of "") + integrand->GetTitle();; 630 const std::string name = std::string(integrand->GetName()) + integrand->integralNameSuffix(innerSet,nset,rangeName).Data();; 631 ; 632 std::unique_ptr<RooAbsReal> innerIntegral = std::move(integral);; 633 ; 634 // Construct innermost integral; 635 integral = std::make_unique<RooRealIntegral>(name.c_str(),title.c",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:23342,Integrability,integrat,integrated,23342,"t; 594 RooArgSet iset(iset2) ;; 595 const RooArgSet* nset = nset2 ;; 596 ; 597 ; 598 // Initialize local variables perparing for recursive loop; 599 bool error = false ;; 600 const RooAbsReal* integrand = this ;; 601 std::unique_ptr<RooAbsReal> integral;; 602 ; 603 // Handle trivial case of no integration here explicitly; 604 if (iset.empty()) {; 605 ; 606 const std::string title = std::string(""Integral of "") + GetTitle();; 607 const std::string name = std::string(GetName()) + integralNameSuffix(iset,nset,rangeName).Data();; 608 ; 609 auto out = std::make_unique<RooRealIntegral>(name.c_str(), title.c_str(), *this, iset, nset, cfg, rangeName);; 610 return RooFit::makeOwningPtr<RooAbsReal>(std::move(out));; 611 }; 612 ; 613 // Process integration over remaining integration variables; 614 while(!iset.empty()) {; 615 ; 616 ; 617 // Find largest set of observables that can be integrated in one go; 618 RooArgSet innerSet ;; 619 findInnerMostIntegration(iset,innerSet,rangeName) ;; 620 ; 621 // If largest set of observables that can be integrated is empty set, problem was ill defined; 622 // Postpone error messaging and handling to end of function, exit loop here; 623 if (innerSet.empty()) {; 624 error = true ;; 625 break ;; 626 }; 627 ; 628 // Prepare name and title of integral to be created; 629 const std::string title = std::string(""Integral of "") + integrand->GetTitle();; 630 const std::string name = std::string(integrand->GetName()) + integrand->integralNameSuffix(innerSet,nset,rangeName).Data();; 631 ; 632 std::unique_ptr<RooAbsReal> innerIntegral = std::move(integral);; 633 ; 634 // Construct innermost integral; 635 integral = std::make_unique<RooRealIntegral>(name.c_str(),title.c_str(),*integrand,innerSet,nset,cfg,rangeName);; 636 ; 637 // Integral of integral takes ownership of innermost integral; 638 if (innerIntegral) {; 639 integral->addOwnedComponents(std::move(innerIntegral));; 640 }; 641 ; 642 // Remove already integrated observables from to-do list; 643 iset.",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:23502,Integrability,integrat,integrated,23502,"t; 594 RooArgSet iset(iset2) ;; 595 const RooArgSet* nset = nset2 ;; 596 ; 597 ; 598 // Initialize local variables perparing for recursive loop; 599 bool error = false ;; 600 const RooAbsReal* integrand = this ;; 601 std::unique_ptr<RooAbsReal> integral;; 602 ; 603 // Handle trivial case of no integration here explicitly; 604 if (iset.empty()) {; 605 ; 606 const std::string title = std::string(""Integral of "") + GetTitle();; 607 const std::string name = std::string(GetName()) + integralNameSuffix(iset,nset,rangeName).Data();; 608 ; 609 auto out = std::make_unique<RooRealIntegral>(name.c_str(), title.c_str(), *this, iset, nset, cfg, rangeName);; 610 return RooFit::makeOwningPtr<RooAbsReal>(std::move(out));; 611 }; 612 ; 613 // Process integration over remaining integration variables; 614 while(!iset.empty()) {; 615 ; 616 ; 617 // Find largest set of observables that can be integrated in one go; 618 RooArgSet innerSet ;; 619 findInnerMostIntegration(iset,innerSet,rangeName) ;; 620 ; 621 // If largest set of observables that can be integrated is empty set, problem was ill defined; 622 // Postpone error messaging and handling to end of function, exit loop here; 623 if (innerSet.empty()) {; 624 error = true ;; 625 break ;; 626 }; 627 ; 628 // Prepare name and title of integral to be created; 629 const std::string title = std::string(""Integral of "") + integrand->GetTitle();; 630 const std::string name = std::string(integrand->GetName()) + integrand->integralNameSuffix(innerSet,nset,rangeName).Data();; 631 ; 632 std::unique_ptr<RooAbsReal> innerIntegral = std::move(integral);; 633 ; 634 // Construct innermost integral; 635 integral = std::make_unique<RooRealIntegral>(name.c_str(),title.c_str(),*integrand,innerSet,nset,cfg,rangeName);; 636 ; 637 // Integral of integral takes ownership of innermost integral; 638 if (innerIntegral) {; 639 integral->addOwnedComponents(std::move(innerIntegral));; 640 }; 641 ; 642 // Remove already integrated observables from to-do list; 643 iset.",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:24410,Integrability,integrat,integrated,24410,"et of observables that can be integrated in one go; 618 RooArgSet innerSet ;; 619 findInnerMostIntegration(iset,innerSet,rangeName) ;; 620 ; 621 // If largest set of observables that can be integrated is empty set, problem was ill defined; 622 // Postpone error messaging and handling to end of function, exit loop here; 623 if (innerSet.empty()) {; 624 error = true ;; 625 break ;; 626 }; 627 ; 628 // Prepare name and title of integral to be created; 629 const std::string title = std::string(""Integral of "") + integrand->GetTitle();; 630 const std::string name = std::string(integrand->GetName()) + integrand->integralNameSuffix(innerSet,nset,rangeName).Data();; 631 ; 632 std::unique_ptr<RooAbsReal> innerIntegral = std::move(integral);; 633 ; 634 // Construct innermost integral; 635 integral = std::make_unique<RooRealIntegral>(name.c_str(),title.c_str(),*integrand,innerSet,nset,cfg,rangeName);; 636 ; 637 // Integral of integral takes ownership of innermost integral; 638 if (innerIntegral) {; 639 integral->addOwnedComponents(std::move(innerIntegral));; 640 }; 641 ; 642 // Remove already integrated observables from to-do list; 643 iset.remove(innerSet) ;; 644 ; 645 // Send info message on recursion if needed; 646 if (integrand == this && !iset.empty()) {; 647 coutI(Integration) << GetName() << "" : multidimensional integration over observables with parameterized ranges in terms of other integrated observables detected, using recursive integration strategy to construct final integral"" << std::endl ;; 648 }; 649 ; 650 // Prepare for recursion, next integral should integrate last integrand; 651 integrand = integral.get();; 652 ; 653 ; 654 // Only need normalization set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 retur",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:24502,Integrability,message,message,24502,"s empty set, problem was ill defined; 622 // Postpone error messaging and handling to end of function, exit loop here; 623 if (innerSet.empty()) {; 624 error = true ;; 625 break ;; 626 }; 627 ; 628 // Prepare name and title of integral to be created; 629 const std::string title = std::string(""Integral of "") + integrand->GetTitle();; 630 const std::string name = std::string(integrand->GetName()) + integrand->integralNameSuffix(innerSet,nset,rangeName).Data();; 631 ; 632 std::unique_ptr<RooAbsReal> innerIntegral = std::move(integral);; 633 ; 634 // Construct innermost integral; 635 integral = std::make_unique<RooRealIntegral>(name.c_str(),title.c_str(),*integrand,innerSet,nset,cfg,rangeName);; 636 ; 637 // Integral of integral takes ownership of innermost integral; 638 if (innerIntegral) {; 639 integral->addOwnedComponents(std::move(innerIntegral));; 640 }; 641 ; 642 // Remove already integrated observables from to-do list; 643 iset.remove(innerSet) ;; 644 ; 645 // Send info message on recursion if needed; 646 if (integrand == this && !iset.empty()) {; 647 coutI(Integration) << GetName() << "" : multidimensional integration over observables with parameterized ranges in terms of other integrated observables detected, using recursive integration strategy to construct final integral"" << std::endl ;; 648 }; 649 ; 650 // Prepare for recursion, next integral should integrate last integrand; 651 integrand = integral.get();; 652 ; 653 ; 654 // Only need normalization set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:24641,Integrability,integrat,integration,24641,"created; 629 const std::string title = std::string(""Integral of "") + integrand->GetTitle();; 630 const std::string name = std::string(integrand->GetName()) + integrand->integralNameSuffix(innerSet,nset,rangeName).Data();; 631 ; 632 std::unique_ptr<RooAbsReal> innerIntegral = std::move(integral);; 633 ; 634 // Construct innermost integral; 635 integral = std::make_unique<RooRealIntegral>(name.c_str(),title.c_str(),*integrand,innerSet,nset,cfg,rangeName);; 636 ; 637 // Integral of integral takes ownership of innermost integral; 638 if (innerIntegral) {; 639 integral->addOwnedComponents(std::move(innerIntegral));; 640 }; 641 ; 642 // Remove already integrated observables from to-do list; 643 iset.remove(innerSet) ;; 644 ; 645 // Send info message on recursion if needed; 646 if (integrand == this && !iset.empty()) {; 647 coutI(Integration) << GetName() << "" : multidimensional integration over observables with parameterized ranges in terms of other integrated observables detected, using recursive integration strategy to construct final integral"" << std::endl ;; 648 }; 649 ; 650 // Prepare for recursion, next integral should integrate last integrand; 651 integrand = integral.get();; 652 ; 653 ; 654 // Only need normalization set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.emp",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:24714,Integrability,integrat,integrated,24714,"created; 629 const std::string title = std::string(""Integral of "") + integrand->GetTitle();; 630 const std::string name = std::string(integrand->GetName()) + integrand->integralNameSuffix(innerSet,nset,rangeName).Data();; 631 ; 632 std::unique_ptr<RooAbsReal> innerIntegral = std::move(integral);; 633 ; 634 // Construct innermost integral; 635 integral = std::make_unique<RooRealIntegral>(name.c_str(),title.c_str(),*integrand,innerSet,nset,cfg,rangeName);; 636 ; 637 // Integral of integral takes ownership of innermost integral; 638 if (innerIntegral) {; 639 integral->addOwnedComponents(std::move(innerIntegral));; 640 }; 641 ; 642 // Remove already integrated observables from to-do list; 643 iset.remove(innerSet) ;; 644 ; 645 // Send info message on recursion if needed; 646 if (integrand == this && !iset.empty()) {; 647 coutI(Integration) << GetName() << "" : multidimensional integration over observables with parameterized ranges in terms of other integrated observables detected, using recursive integration strategy to construct final integral"" << std::endl ;; 648 }; 649 ; 650 // Prepare for recursion, next integral should integrate last integrand; 651 integrand = integral.get();; 652 ; 653 ; 654 // Only need normalization set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.emp",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:24763,Integrability,integrat,integration,24763,"created; 629 const std::string title = std::string(""Integral of "") + integrand->GetTitle();; 630 const std::string name = std::string(integrand->GetName()) + integrand->integralNameSuffix(innerSet,nset,rangeName).Data();; 631 ; 632 std::unique_ptr<RooAbsReal> innerIntegral = std::move(integral);; 633 ; 634 // Construct innermost integral; 635 integral = std::make_unique<RooRealIntegral>(name.c_str(),title.c_str(),*integrand,innerSet,nset,cfg,rangeName);; 636 ; 637 // Integral of integral takes ownership of innermost integral; 638 if (innerIntegral) {; 639 integral->addOwnedComponents(std::move(innerIntegral));; 640 }; 641 ; 642 // Remove already integrated observables from to-do list; 643 iset.remove(innerSet) ;; 644 ; 645 // Send info message on recursion if needed; 646 if (integrand == this && !iset.empty()) {; 647 coutI(Integration) << GetName() << "" : multidimensional integration over observables with parameterized ranges in terms of other integrated observables detected, using recursive integration strategy to construct final integral"" << std::endl ;; 648 }; 649 ; 650 // Prepare for recursion, next integral should integrate last integrand; 651 integrand = integral.get();; 652 ; 653 ; 654 // Only need normalization set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.emp",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:24893,Integrability,integrat,integrate,24893,"created; 629 const std::string title = std::string(""Integral of "") + integrand->GetTitle();; 630 const std::string name = std::string(integrand->GetName()) + integrand->integralNameSuffix(innerSet,nset,rangeName).Data();; 631 ; 632 std::unique_ptr<RooAbsReal> innerIntegral = std::move(integral);; 633 ; 634 // Construct innermost integral; 635 integral = std::make_unique<RooRealIntegral>(name.c_str(),title.c_str(),*integrand,innerSet,nset,cfg,rangeName);; 636 ; 637 // Integral of integral takes ownership of innermost integral; 638 if (innerIntegral) {; 639 integral->addOwnedComponents(std::move(innerIntegral));; 640 }; 641 ; 642 // Remove already integrated observables from to-do list; 643 iset.remove(innerSet) ;; 644 ; 645 // Send info message on recursion if needed; 646 if (integrand == this && !iset.empty()) {; 647 coutI(Integration) << GetName() << "" : multidimensional integration over observables with parameterized ranges in terms of other integrated observables detected, using recursive integration strategy to construct final integral"" << std::endl ;; 648 }; 649 ; 650 // Prepare for recursion, next integral should integrate last integrand; 651 integrand = integral.get();; 652 ; 653 ; 654 // Only need normalization set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.emp",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:25012,Integrability,integrat,integration,25012,"d::move(innerIntegral));; 640 }; 641 ; 642 // Remove already integrated observables from to-do list; 643 iset.remove(innerSet) ;; 644 ; 645 // Send info message on recursion if needed; 646 if (integrand == this && !iset.empty()) {; 647 coutI(Integration) << GetName() << "" : multidimensional integration over observables with parameterized ranges in terms of other integrated observables detected, using recursive integration strategy to construct final integral"" << std::endl ;; 648 }; 649 ; 650 // Prepare for recursion, next integral should integrate last integrand; 651 integrand = integral.get();; 652 ; 653 ; 654 // Only need normalization set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::mov",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:25196,Integrability,integrat,integration,25196,"d::move(innerIntegral));; 640 }; 641 ; 642 // Remove already integrated observables from to-do list; 643 iset.remove(innerSet) ;; 644 ; 645 // Send info message on recursion if needed; 646 if (integrand == this && !iset.empty()) {; 647 coutI(Integration) << GetName() << "" : multidimensional integration over observables with parameterized ranges in terms of other integrated observables detected, using recursive integration strategy to construct final integral"" << std::endl ;; 648 }; 649 ; 650 // Prepare for recursion, next integral should integrate last integrand; 651 integrand = integral.get();; 652 ; 653 ; 654 // Only need normalization set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::mov",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:25234,Integrability,integrat,integration,25234,"d::move(innerIntegral));; 640 }; 641 ; 642 // Remove already integrated observables from to-do list; 643 iset.remove(innerSet) ;; 644 ; 645 // Send info message on recursion if needed; 646 if (integrand == this && !iset.empty()) {; 647 coutI(Integration) << GetName() << "" : multidimensional integration over observables with parameterized ranges in terms of other integrated observables detected, using recursive integration strategy to construct final integral"" << std::endl ;; 648 }; 649 ; 650 // Prepare for recursion, next integral should integrate last integrand; 651 integrand = integral.get();; 652 ; 653 ; 654 // Only need normalization set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::mov",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:27032,Integrability,integrat,integration,27032,"g name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::move(integral));; 679 cachedIntegral->setCacheSource(true) ;; 680 if (integral->operMode()==ADirty) {; 681 cachedIntegral->setOperMode(ADirty) ;; 682 }; 683 //cachedIntegral->disableCache(true) ;; 684 return RooFit::makeOwningPtr<RooAbsReal>(std::move(cachedIntegral));; 685 }; 686 }; 687 ; 688 return RooFit::makeOwningPtr(std::move(integral));; 689}; 690 ; 691 ; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ranges depending on other integrated observables; 706 // c) integrated observables used in definition of any parameterized ranges of integrated observables; 707 RooArgSet obsWithFixedRange(allObs) ;; 708 RooArgSet obsWithParamRange ;; 709 RooArgSet obsServingAsRangeParams ;; 710 ; 711 // Loop over all integrated observables; 712 for (const auto aarg : allObs) {; 713 // Check if observable is real-valued lvalue; 714 if (auto arglv = dynamic_cast<RooAbsRealL",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:27112,Integrability,integrat,integrated,27112,"g name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::move(integral));; 679 cachedIntegral->setCacheSource(true) ;; 680 if (integral->operMode()==ADirty) {; 681 cachedIntegral->setOperMode(ADirty) ;; 682 }; 683 //cachedIntegral->disableCache(true) ;; 684 return RooFit::makeOwningPtr<RooAbsReal>(std::move(cachedIntegral));; 685 }; 686 }; 687 ; 688 return RooFit::makeOwningPtr(std::move(integral));; 689}; 690 ; 691 ; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ranges depending on other integrated observables; 706 // c) integrated observables used in definition of any parameterized ranges of integrated observables; 707 RooArgSet obsWithFixedRange(allObs) ;; 708 RooArgSet obsWithParamRange ;; 709 RooArgSet obsServingAsRangeParams ;; 710 ; 711 // Loop over all integrated observables; 712 for (const auto aarg : allObs) {; 713 // Check if observable is real-valued lvalue; 714 if (auto arglv = dynamic_cast<RooAbsRealL",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:27283,Integrability,depend,depend,27283,"ral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::move(integral));; 679 cachedIntegral->setCacheSource(true) ;; 680 if (integral->operMode()==ADirty) {; 681 cachedIntegral->setOperMode(ADirty) ;; 682 }; 683 //cachedIntegral->disableCache(true) ;; 684 return RooFit::makeOwningPtr<RooAbsReal>(std::move(cachedIntegral));; 685 }; 686 }; 687 ; 688 return RooFit::makeOwningPtr(std::move(integral));; 689}; 690 ; 691 ; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ranges depending on other integrated observables; 706 // c) integrated observables used in definition of any parameterized ranges of integrated observables; 707 RooArgSet obsWithFixedRange(allObs) ;; 708 RooArgSet obsWithParamRange ;; 709 RooArgSet obsServingAsRangeParams ;; 710 ; 711 // Loop over all integrated observables; 712 for (const auto aarg : allObs) {; 713 // Check if observable is real-valued lvalue; 714 if (auto arglv = dynamic_cast<RooAbsRealLValue*>(aarg)) {; 715 ; 716 // Check if range is parameterized; 717 RooAbsBinning& binning = arglv->getBinning(rangeName,false,true) ;; 718 if (binning.isParameterized()) {; 719 Roo",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:27321,Integrability,integrat,integrated,27321,"ral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::move(integral));; 679 cachedIntegral->setCacheSource(true) ;; 680 if (integral->operMode()==ADirty) {; 681 cachedIntegral->setOperMode(ADirty) ;; 682 }; 683 //cachedIntegral->disableCache(true) ;; 684 return RooFit::makeOwningPtr<RooAbsReal>(std::move(cachedIntegral));; 685 }; 686 }; 687 ; 688 return RooFit::makeOwningPtr(std::move(integral));; 689}; 690 ; 691 ; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ranges depending on other integrated observables; 706 // c) integrated observables used in definition of any parameterized ranges of integrated observables; 707 RooArgSet obsWithFixedRange(allObs) ;; 708 RooArgSet obsWithParamRange ;; 709 RooArgSet obsServingAsRangeParams ;; 710 ; 711 // Loop over all integrated observables; 712 for (const auto aarg : allObs) {; 713 // Check if observable is real-valued lvalue; 714 if (auto arglv = dynamic_cast<RooAbsRealLValue*>(aarg)) {; 715 ; 716 // Check if range is parameterized; 717 RooAbsBinning& binning = arglv->getBinning(rangeName,false,true) ;; 718 if (binning.isParameterized()) {; 719 Roo",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:27499,Integrability,integrat,integrated,27499,"///////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ranges depending on other integrated observables; 706 // c) integrated observables used in definition of any parameterized ranges of integrated observables; 707 RooArgSet obsWithFixedRange(allObs) ;; 708 RooArgSet obsWithParamRange ;; 709 RooArgSet obsServingAsRangeParams ;; 710 ; 711 // Loop over all integrated observables; 712 for (const auto aarg : allObs) {; 713 // Check if observable is real-valued lvalue; 714 if (auto arglv = dynamic_cast<RooAbsRealLValue*>(aarg)) {; 715 ; 716 // Check if range is parameterized; 717 RooAbsBinning& binning = arglv->getBinning(rangeName,false,true) ;; 718 if (binning.isParameterized()) {; 719 RooArgSet loBoundObs;; 720 RooArgSet hiBoundObs;; 721 binning.lowBoundFunc()->getObservables(&allObs, loBoundObs) ;; 722 binning.highBoundFunc()->getObservables(&allObs, hiBoundObs) ;; 723 ; 724 // Check if range parameterization depends on other integrated observables; 725 if (loBoundObs.overlaps(allObs) || hiBoundObs.overlaps(allObs)) {; 726 obsWithParamRange.add(*aarg) ;; 727 obsWithFixedRange.remove(*aarg) ;; 728 obsServingAsRangeParams.add(loBoundObs,false) ;; 729 obsServingAsRangeParams.add(hiBoundObs,false) ;; 730 }; 731 }; ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:27552,Integrability,integrat,integrated,27552,"///////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ranges depending on other integrated observables; 706 // c) integrated observables used in definition of any parameterized ranges of integrated observables; 707 RooArgSet obsWithFixedRange(allObs) ;; 708 RooArgSet obsWithParamRange ;; 709 RooArgSet obsServingAsRangeParams ;; 710 ; 711 // Loop over all integrated observables; 712 for (const auto aarg : allObs) {; 713 // Check if observable is real-valued lvalue; 714 if (auto arglv = dynamic_cast<RooAbsRealLValue*>(aarg)) {; 715 ; 716 // Check if range is parameterized; 717 RooAbsBinning& binning = arglv->getBinning(rangeName,false,true) ;; 718 if (binning.isParameterized()) {; 719 RooArgSet loBoundObs;; 720 RooArgSet hiBoundObs;; 721 binning.lowBoundFunc()->getObservables(&allObs, loBoundObs) ;; 722 binning.highBoundFunc()->getObservables(&allObs, hiBoundObs) ;; 723 ; 724 // Check if range parameterization depends on other integrated observables; 725 if (loBoundObs.overlaps(allObs) || hiBoundObs.overlaps(allObs)) {; 726 obsWithParamRange.add(*aarg) ;; 727 obsWithFixedRange.remove(*aarg) ;; 728 obsServingAsRangeParams.add(loBoundObs,false) ;; 729 obsServingAsRangeParams.add(hiBoundObs,false) ;; 730 }; 731 }; ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:27601,Integrability,depend,depending,27601,"///////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ranges depending on other integrated observables; 706 // c) integrated observables used in definition of any parameterized ranges of integrated observables; 707 RooArgSet obsWithFixedRange(allObs) ;; 708 RooArgSet obsWithParamRange ;; 709 RooArgSet obsServingAsRangeParams ;; 710 ; 711 // Loop over all integrated observables; 712 for (const auto aarg : allObs) {; 713 // Check if observable is real-valued lvalue; 714 if (auto arglv = dynamic_cast<RooAbsRealLValue*>(aarg)) {; 715 ; 716 // Check if range is parameterized; 717 RooAbsBinning& binning = arglv->getBinning(rangeName,false,true) ;; 718 if (binning.isParameterized()) {; 719 RooArgSet loBoundObs;; 720 RooArgSet hiBoundObs;; 721 binning.lowBoundFunc()->getObservables(&allObs, loBoundObs) ;; 722 binning.highBoundFunc()->getObservables(&allObs, hiBoundObs) ;; 723 ; 724 // Check if range parameterization depends on other integrated observables; 725 if (loBoundObs.overlaps(allObs) || hiBoundObs.overlaps(allObs)) {; 726 obsWithParamRange.add(*aarg) ;; 727 obsWithFixedRange.remove(*aarg) ;; 728 obsServingAsRangeParams.add(loBoundObs,false) ;; 729 obsServingAsRangeParams.add(hiBoundObs,false) ;; 730 }; 731 }; ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:27620,Integrability,integrat,integrated,27620,"///////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ranges depending on other integrated observables; 706 // c) integrated observables used in definition of any parameterized ranges of integrated observables; 707 RooArgSet obsWithFixedRange(allObs) ;; 708 RooArgSet obsWithParamRange ;; 709 RooArgSet obsServingAsRangeParams ;; 710 ; 711 // Loop over all integrated observables; 712 for (const auto aarg : allObs) {; 713 // Check if observable is real-valued lvalue; 714 if (auto arglv = dynamic_cast<RooAbsRealLValue*>(aarg)) {; 715 ; 716 // Check if range is parameterized; 717 RooAbsBinning& binning = arglv->getBinning(rangeName,false,true) ;; 718 if (binning.isParameterized()) {; 719 RooArgSet loBoundObs;; 720 RooArgSet hiBoundObs;; 721 binning.lowBoundFunc()->getObservables(&allObs, loBoundObs) ;; 722 binning.highBoundFunc()->getObservables(&allObs, hiBoundObs) ;; 723 ; 724 // Check if range parameterization depends on other integrated observables; 725 if (loBoundObs.overlaps(allObs) || hiBoundObs.overlaps(allObs)) {; 726 obsWithParamRange.add(*aarg) ;; 727 obsWithFixedRange.remove(*aarg) ;; 728 obsServingAsRangeParams.add(loBoundObs,false) ;; 729 obsServingAsRangeParams.add(hiBoundObs,false) ;; 730 }; 731 }; ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:27654,Integrability,integrat,integrated,27654,"///////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ranges depending on other integrated observables; 706 // c) integrated observables used in definition of any parameterized ranges of integrated observables; 707 RooArgSet obsWithFixedRange(allObs) ;; 708 RooArgSet obsWithParamRange ;; 709 RooArgSet obsServingAsRangeParams ;; 710 ; 711 // Loop over all integrated observables; 712 for (const auto aarg : allObs) {; 713 // Check if observable is real-valued lvalue; 714 if (auto arglv = dynamic_cast<RooAbsRealLValue*>(aarg)) {; 715 ; 716 // Check if range is parameterized; 717 RooAbsBinning& binning = arglv->getBinning(rangeName,false,true) ;; 718 if (binning.isParameterized()) {; 719 RooArgSet loBoundObs;; 720 RooArgSet hiBoundObs;; 721 binning.lowBoundFunc()->getObservables(&allObs, loBoundObs) ;; 722 binning.highBoundFunc()->getObservables(&allObs, hiBoundObs) ;; 723 ; 724 // Check if range parameterization depends on other integrated observables; 725 if (loBoundObs.overlaps(allObs) || hiBoundObs.overlaps(allObs)) {; 726 obsWithParamRange.add(*aarg) ;; 727 obsWithFixedRange.remove(*aarg) ;; 728 obsServingAsRangeParams.add(loBoundObs,false) ;; 729 obsServingAsRangeParams.add(hiBoundObs,false) ;; 730 }; 731 }; ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:27727,Integrability,integrat,integrated,27727,"///////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ranges depending on other integrated observables; 706 // c) integrated observables used in definition of any parameterized ranges of integrated observables; 707 RooArgSet obsWithFixedRange(allObs) ;; 708 RooArgSet obsWithParamRange ;; 709 RooArgSet obsServingAsRangeParams ;; 710 ; 711 // Loop over all integrated observables; 712 for (const auto aarg : allObs) {; 713 // Check if observable is real-valued lvalue; 714 if (auto arglv = dynamic_cast<RooAbsRealLValue*>(aarg)) {; 715 ; 716 // Check if range is parameterized; 717 RooAbsBinning& binning = arglv->getBinning(rangeName,false,true) ;; 718 if (binning.isParameterized()) {; 719 RooArgSet loBoundObs;; 720 RooArgSet hiBoundObs;; 721 binning.lowBoundFunc()->getObservables(&allObs, loBoundObs) ;; 722 binning.highBoundFunc()->getObservables(&allObs, hiBoundObs) ;; 723 ; 724 // Check if range parameterization depends on other integrated observables; 725 if (loBoundObs.overlaps(allObs) || hiBoundObs.overlaps(allObs)) {; 726 obsWithParamRange.add(*aarg) ;; 727 obsWithFixedRange.remove(*aarg) ;; 728 obsServingAsRangeParams.add(loBoundObs,false) ;; 729 obsServingAsRangeParams.add(hiBoundObs,false) ;; 730 }; 731 }; ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:27897,Integrability,integrat,integrated,27897,"///////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ranges depending on other integrated observables; 706 // c) integrated observables used in definition of any parameterized ranges of integrated observables; 707 RooArgSet obsWithFixedRange(allObs) ;; 708 RooArgSet obsWithParamRange ;; 709 RooArgSet obsServingAsRangeParams ;; 710 ; 711 // Loop over all integrated observables; 712 for (const auto aarg : allObs) {; 713 // Check if observable is real-valued lvalue; 714 if (auto arglv = dynamic_cast<RooAbsRealLValue*>(aarg)) {; 715 ; 716 // Check if range is parameterized; 717 RooAbsBinning& binning = arglv->getBinning(rangeName,false,true) ;; 718 if (binning.isParameterized()) {; 719 RooArgSet loBoundObs;; 720 RooArgSet hiBoundObs;; 721 binning.lowBoundFunc()->getObservables(&allObs, loBoundObs) ;; 722 binning.highBoundFunc()->getObservables(&allObs, hiBoundObs) ;; 723 ; 724 // Check if range parameterization depends on other integrated observables; 725 if (loBoundObs.overlaps(allObs) || hiBoundObs.overlaps(allObs)) {; 726 obsWithParamRange.add(*aarg) ;; 727 obsWithFixedRange.remove(*aarg) ;; 728 obsServingAsRangeParams.add(loBoundObs,false) ;; 729 obsServingAsRangeParams.add(hiBoundObs,false) ;; 730 }; 731 }; ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:28462,Integrability,depend,depends,28462,"* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ranges depending on other integrated observables; 706 // c) integrated observables used in definition of any parameterized ranges of integrated observables; 707 RooArgSet obsWithFixedRange(allObs) ;; 708 RooArgSet obsWithParamRange ;; 709 RooArgSet obsServingAsRangeParams ;; 710 ; 711 // Loop over all integrated observables; 712 for (const auto aarg : allObs) {; 713 // Check if observable is real-valued lvalue; 714 if (auto arglv = dynamic_cast<RooAbsRealLValue*>(aarg)) {; 715 ; 716 // Check if range is parameterized; 717 RooAbsBinning& binning = arglv->getBinning(rangeName,false,true) ;; 718 if (binning.isParameterized()) {; 719 RooArgSet loBoundObs;; 720 RooArgSet hiBoundObs;; 721 binning.lowBoundFunc()->getObservables(&allObs, loBoundObs) ;; 722 binning.highBoundFunc()->getObservables(&allObs, hiBoundObs) ;; 723 ; 724 // Check if range parameterization depends on other integrated observables; 725 if (loBoundObs.overlaps(allObs) || hiBoundObs.overlaps(allObs)) {; 726 obsWithParamRange.add(*aarg) ;; 727 obsWithFixedRange.remove(*aarg) ;; 728 obsServingAsRangeParams.add(loBoundObs,false) ;; 729 obsServingAsRangeParams.add(hiBoundObs,false) ;; 730 }; 731 }; 732 }; 733 }; 734 ; 735 // Make list of fixed-range observables that are _not_ involved in the parameterization of ranges of other observables; 736 RooArgSet obsWithFixedRangeNP(obsWithFixedRange) ;; 737 obsWithFixedRangeNP.remove(obsServingAsRangeParams) ;; 738 ; 739 // Make list of param-range observables that are _not_ involved in the parameterization of ranges of other observables; 740 RooArgSet obsWithParamRangeNP(obsWithParamRange) ;; 741 obsWithParamRangeNP.remove(obsServingAsRangeParams) ;; 742 ; 743 // Construct inner-most integration: over observables (with fixed or param range) not used in any other param range definitions; 744 innerObs.removeAll() ;; 74",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:28479,Integrability,integrat,integrated,28479,"* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ranges depending on other integrated observables; 706 // c) integrated observables used in definition of any parameterized ranges of integrated observables; 707 RooArgSet obsWithFixedRange(allObs) ;; 708 RooArgSet obsWithParamRange ;; 709 RooArgSet obsServingAsRangeParams ;; 710 ; 711 // Loop over all integrated observables; 712 for (const auto aarg : allObs) {; 713 // Check if observable is real-valued lvalue; 714 if (auto arglv = dynamic_cast<RooAbsRealLValue*>(aarg)) {; 715 ; 716 // Check if range is parameterized; 717 RooAbsBinning& binning = arglv->getBinning(rangeName,false,true) ;; 718 if (binning.isParameterized()) {; 719 RooArgSet loBoundObs;; 720 RooArgSet hiBoundObs;; 721 binning.lowBoundFunc()->getObservables(&allObs, loBoundObs) ;; 722 binning.highBoundFunc()->getObservables(&allObs, hiBoundObs) ;; 723 ; 724 // Check if range parameterization depends on other integrated observables; 725 if (loBoundObs.overlaps(allObs) || hiBoundObs.overlaps(allObs)) {; 726 obsWithParamRange.add(*aarg) ;; 727 obsWithFixedRange.remove(*aarg) ;; 728 obsServingAsRangeParams.add(loBoundObs,false) ;; 729 obsServingAsRangeParams.add(hiBoundObs,false) ;; 730 }; 731 }; 732 }; 733 }; 734 ; 735 // Make list of fixed-range observables that are _not_ involved in the parameterization of ranges of other observables; 736 RooArgSet obsWithFixedRangeNP(obsWithFixedRange) ;; 737 obsWithFixedRangeNP.remove(obsServingAsRangeParams) ;; 738 ; 739 // Make list of param-range observables that are _not_ involved in the parameterization of ranges of other observables; 740 RooArgSet obsWithParamRangeNP(obsWithParamRange) ;; 741 obsWithParamRangeNP.remove(obsServingAsRangeParams) ;; 742 ; 743 // Construct inner-most integration: over observables (with fixed or param range) not used in any other param range definitions; 744 innerObs.removeAll() ;; 74",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:29307,Integrability,integrat,integration,29307,"s, loBoundObs) ;; 722 binning.highBoundFunc()->getObservables(&allObs, hiBoundObs) ;; 723 ; 724 // Check if range parameterization depends on other integrated observables; 725 if (loBoundObs.overlaps(allObs) || hiBoundObs.overlaps(allObs)) {; 726 obsWithParamRange.add(*aarg) ;; 727 obsWithFixedRange.remove(*aarg) ;; 728 obsServingAsRangeParams.add(loBoundObs,false) ;; 729 obsServingAsRangeParams.add(hiBoundObs,false) ;; 730 }; 731 }; 732 }; 733 }; 734 ; 735 // Make list of fixed-range observables that are _not_ involved in the parameterization of ranges of other observables; 736 RooArgSet obsWithFixedRangeNP(obsWithFixedRange) ;; 737 obsWithFixedRangeNP.remove(obsServingAsRangeParams) ;; 738 ; 739 // Make list of param-range observables that are _not_ involved in the parameterization of ranges of other observables; 740 RooArgSet obsWithParamRangeNP(obsWithParamRange) ;; 741 obsWithParamRangeNP.remove(obsServingAsRangeParams) ;; 742 ; 743 // Construct inner-most integration: over observables (with fixed or param range) not used in any other param range definitions; 744 innerObs.removeAll() ;; 745 innerObs.add(obsWithFixedRangeNP) ;; 746 innerObs.add(obsWithParamRangeNP) ;; 747 ; 748}; 749 ; 750 ; 751////////////////////////////////////////////////////////////////////////////////; 752/// Construct string with unique suffix name to give to integral object that encodes; 753/// integrated observables, normalization observables and the integration range name; 754 ; 755TString RooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset, const char* rangeName, bool omitEmpty) const; 756{; 757 TString name ;; 758 if (!iset.empty()) {; 759 name.Append(""_Int["" + RooHelpers::getColonSeparatedNameString(iset, ','));; 760 if (rangeName) {; 761 name.Append(""|"" + std::string{rangeName});; 762 }; 763 name.Append(""]"");; 764 } else if (!omitEmpty) {; 765 name.Append(""_Int[]"") ;; 766 }; 767 ; 768 if (nset && !nset->empty()) {; 769 name.Append(""_Norm["" + RooHelpers::getCo",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:29727,Integrability,integrat,integrated,29727,"Obs,false) ;; 730 }; 731 }; 732 }; 733 }; 734 ; 735 // Make list of fixed-range observables that are _not_ involved in the parameterization of ranges of other observables; 736 RooArgSet obsWithFixedRangeNP(obsWithFixedRange) ;; 737 obsWithFixedRangeNP.remove(obsServingAsRangeParams) ;; 738 ; 739 // Make list of param-range observables that are _not_ involved in the parameterization of ranges of other observables; 740 RooArgSet obsWithParamRangeNP(obsWithParamRange) ;; 741 obsWithParamRangeNP.remove(obsServingAsRangeParams) ;; 742 ; 743 // Construct inner-most integration: over observables (with fixed or param range) not used in any other param range definitions; 744 innerObs.removeAll() ;; 745 innerObs.add(obsWithFixedRangeNP) ;; 746 innerObs.add(obsWithParamRangeNP) ;; 747 ; 748}; 749 ; 750 ; 751////////////////////////////////////////////////////////////////////////////////; 752/// Construct string with unique suffix name to give to integral object that encodes; 753/// integrated observables, normalization observables and the integration range name; 754 ; 755TString RooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset, const char* rangeName, bool omitEmpty) const; 756{; 757 TString name ;; 758 if (!iset.empty()) {; 759 name.Append(""_Int["" + RooHelpers::getColonSeparatedNameString(iset, ','));; 760 if (rangeName) {; 761 name.Append(""|"" + std::string{rangeName});; 762 }; 763 name.Append(""]"");; 764 } else if (!omitEmpty) {; 765 name.Append(""_Int[]"") ;; 766 }; 767 ; 768 if (nset && !nset->empty()) {; 769 name.Append(""_Norm["" + RooHelpers::getColonSeparatedNameString(*nset, ','));; 770 const RooAbsPdf* thisPdf = dynamic_cast<const RooAbsPdf*>(this) ;; 771 if (thisPdf && thisPdf->normRange()) {; 772 name.Append(""|"" + std::string{thisPdf->normRange()}) ;; 773 }; 774 name.Append(""]"") ;; 775 }; 776 ; 777 return name ;; 778}; 779 ; 780 ; 781 ; 782////////////////////////////////////////////////////////////////////////////////; 783/// Utility function f",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:29785,Integrability,integrat,integration,29785,"Obs,false) ;; 730 }; 731 }; 732 }; 733 }; 734 ; 735 // Make list of fixed-range observables that are _not_ involved in the parameterization of ranges of other observables; 736 RooArgSet obsWithFixedRangeNP(obsWithFixedRange) ;; 737 obsWithFixedRangeNP.remove(obsServingAsRangeParams) ;; 738 ; 739 // Make list of param-range observables that are _not_ involved in the parameterization of ranges of other observables; 740 RooArgSet obsWithParamRangeNP(obsWithParamRange) ;; 741 obsWithParamRangeNP.remove(obsServingAsRangeParams) ;; 742 ; 743 // Construct inner-most integration: over observables (with fixed or param range) not used in any other param range definitions; 744 innerObs.removeAll() ;; 745 innerObs.add(obsWithFixedRangeNP) ;; 746 innerObs.add(obsWithParamRangeNP) ;; 747 ; 748}; 749 ; 750 ; 751////////////////////////////////////////////////////////////////////////////////; 752/// Construct string with unique suffix name to give to integral object that encodes; 753/// integrated observables, normalization observables and the integration range name; 754 ; 755TString RooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset, const char* rangeName, bool omitEmpty) const; 756{; 757 TString name ;; 758 if (!iset.empty()) {; 759 name.Append(""_Int["" + RooHelpers::getColonSeparatedNameString(iset, ','));; 760 if (rangeName) {; 761 name.Append(""|"" + std::string{rangeName});; 762 }; 763 name.Append(""]"");; 764 } else if (!omitEmpty) {; 765 name.Append(""_Int[]"") ;; 766 }; 767 ; 768 if (nset && !nset->empty()) {; 769 name.Append(""_Norm["" + RooHelpers::getColonSeparatedNameString(*nset, ','));; 770 const RooAbsPdf* thisPdf = dynamic_cast<const RooAbsPdf*>(this) ;; 771 if (thisPdf && thisPdf->normRange()) {; 772 name.Append(""|"" + std::string{thisPdf->normRange()}) ;; 773 }; 774 name.Append(""]"") ;; 775 }; 776 ; 777 return name ;; 778}; 779 ; 780 ; 781 ; 782////////////////////////////////////////////////////////////////////////////////; 783/// Utility function f",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:31769,Integrability,depend,dependentVars,31769,"on or p.d.f; 784/// to be plotted on a RooPlot.; 785/// \ref createPlotProjAnchor ""createPlotProjection()""; 786 ; 787const RooAbsReal* RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars,; 788 RooArgSet*& cloneSet) const; 789{; 790 return createPlotProjection(depVars,&projVars,cloneSet) ;; 791}; 792 ; 793 ; 794////////////////////////////////////////////////////////////////////////////////; 795/// Utility function for plotOn() that creates a projection of a function or p.d.f; 796/// to be plotted on a RooPlot.; 797/// \anchor createPlotProjAnchor; 798///; 799/// Create a new object \f$ G \f$ that represents the normalized projection:; 800/// \f[; 801/// G[x,p] = \frac{\int F[x,y,p] \; \mathrm{d}\{y\}}; 802/// {\int F[x,y,p] \; \mathrm{d}\{x\} \, \mathrm{d}\{y\}}; 803/// \f]; 804/// where \f$ F[x,y,p] \f$ is the function we represent, and; 805/// \f$ \{ p \} \f$ are the remaining variables (""parameters"").; 806///; 807/// \param[in] dependentVars Dependent variables over which to normalise, \f$ \{x\} \f$.; 808/// \param[in] projectedVars Variables to project out, \f$ \{ y \} \f$.; 809/// \param[out] cloneSet Will be set to a RooArgSet*, which will contain a clone of *this plus its projection integral object.; 810/// The latter will also be returned. The caller takes ownership of this set.; 811/// \param[in] rangeName Optional range for projection integrals; 812/// \param[in] condObs Conditional observables, which are not integrated for normalisation, even if they; 813/// are in `dependentVars` or `projectedVars`.; 814/// \return A pointer to the newly created object, or zero in case of an; 815/// error. The caller is responsible for deleting the `cloneSet` (which includes the returned projection object).; 816const RooAbsReal *RooAbsReal::createPlotProjection(const RooArgSet &dependentVars, const RooArgSet *projectedVars,; 817 RooArgSet *&cloneSet, const char* rangeName, const RooArgSet* condObs) const; 818{; 819 // Get the set of our le",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:32267,Integrability,integrat,integrated,32267," plotOn() that creates a projection of a function or p.d.f; 796/// to be plotted on a RooPlot.; 797/// \anchor createPlotProjAnchor; 798///; 799/// Create a new object \f$ G \f$ that represents the normalized projection:; 800/// \f[; 801/// G[x,p] = \frac{\int F[x,y,p] \; \mathrm{d}\{y\}}; 802/// {\int F[x,y,p] \; \mathrm{d}\{x\} \, \mathrm{d}\{y\}}; 803/// \f]; 804/// where \f$ F[x,y,p] \f$ is the function we represent, and; 805/// \f$ \{ p \} \f$ are the remaining variables (""parameters"").; 806///; 807/// \param[in] dependentVars Dependent variables over which to normalise, \f$ \{x\} \f$.; 808/// \param[in] projectedVars Variables to project out, \f$ \{ y \} \f$.; 809/// \param[out] cloneSet Will be set to a RooArgSet*, which will contain a clone of *this plus its projection integral object.; 810/// The latter will also be returned. The caller takes ownership of this set.; 811/// \param[in] rangeName Optional range for projection integrals; 812/// \param[in] condObs Conditional observables, which are not integrated for normalisation, even if they; 813/// are in `dependentVars` or `projectedVars`.; 814/// \return A pointer to the newly created object, or zero in case of an; 815/// error. The caller is responsible for deleting the `cloneSet` (which includes the returned projection object).; 816const RooAbsReal *RooAbsReal::createPlotProjection(const RooArgSet &dependentVars, const RooArgSet *projectedVars,; 817 RooArgSet *&cloneSet, const char* rangeName, const RooArgSet* condObs) const; 818{; 819 // Get the set of our leaf nodes; 820 RooArgSet leafNodes;; 821 RooArgSet treeNodes;; 822 leafNodeServerList(&leafNodes,this);; 823 treeNodeServerList(&treeNodes,this) ;; 824 ; 825 ; 826 // Check that the dependents are all fundamental. Filter out any that we; 827 // do not depend on, and make substitutions by name in our leaf list.; 828 // Check for overlaps with the projection variables.; 829 for (const auto arg : dependentVars) {; 830 if(!arg->isFundamental() && !dynamic",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:32326,Integrability,depend,dependentVars,32326," plotOn() that creates a projection of a function or p.d.f; 796/// to be plotted on a RooPlot.; 797/// \anchor createPlotProjAnchor; 798///; 799/// Create a new object \f$ G \f$ that represents the normalized projection:; 800/// \f[; 801/// G[x,p] = \frac{\int F[x,y,p] \; \mathrm{d}\{y\}}; 802/// {\int F[x,y,p] \; \mathrm{d}\{x\} \, \mathrm{d}\{y\}}; 803/// \f]; 804/// where \f$ F[x,y,p] \f$ is the function we represent, and; 805/// \f$ \{ p \} \f$ are the remaining variables (""parameters"").; 806///; 807/// \param[in] dependentVars Dependent variables over which to normalise, \f$ \{x\} \f$.; 808/// \param[in] projectedVars Variables to project out, \f$ \{ y \} \f$.; 809/// \param[out] cloneSet Will be set to a RooArgSet*, which will contain a clone of *this plus its projection integral object.; 810/// The latter will also be returned. The caller takes ownership of this set.; 811/// \param[in] rangeName Optional range for projection integrals; 812/// \param[in] condObs Conditional observables, which are not integrated for normalisation, even if they; 813/// are in `dependentVars` or `projectedVars`.; 814/// \return A pointer to the newly created object, or zero in case of an; 815/// error. The caller is responsible for deleting the `cloneSet` (which includes the returned projection object).; 816const RooAbsReal *RooAbsReal::createPlotProjection(const RooArgSet &dependentVars, const RooArgSet *projectedVars,; 817 RooArgSet *&cloneSet, const char* rangeName, const RooArgSet* condObs) const; 818{; 819 // Get the set of our leaf nodes; 820 RooArgSet leafNodes;; 821 RooArgSet treeNodes;; 822 leafNodeServerList(&leafNodes,this);; 823 treeNodeServerList(&treeNodes,this) ;; 824 ; 825 ; 826 // Check that the dependents are all fundamental. Filter out any that we; 827 // do not depend on, and make substitutions by name in our leaf list.; 828 // Check for overlaps with the projection variables.; 829 for (const auto arg : dependentVars) {; 830 if(!arg->isFundamental() && !dynamic",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:32628,Integrability,depend,dependentVars,32628,"ars Dependent variables over which to normalise, \f$ \{x\} \f$.; 808/// \param[in] projectedVars Variables to project out, \f$ \{ y \} \f$.; 809/// \param[out] cloneSet Will be set to a RooArgSet*, which will contain a clone of *this plus its projection integral object.; 810/// The latter will also be returned. The caller takes ownership of this set.; 811/// \param[in] rangeName Optional range for projection integrals; 812/// \param[in] condObs Conditional observables, which are not integrated for normalisation, even if they; 813/// are in `dependentVars` or `projectedVars`.; 814/// \return A pointer to the newly created object, or zero in case of an; 815/// error. The caller is responsible for deleting the `cloneSet` (which includes the returned projection object).; 816const RooAbsReal *RooAbsReal::createPlotProjection(const RooArgSet &dependentVars, const RooArgSet *projectedVars,; 817 RooArgSet *&cloneSet, const char* rangeName, const RooArgSet* condObs) const; 818{; 819 // Get the set of our leaf nodes; 820 RooArgSet leafNodes;; 821 RooArgSet treeNodes;; 822 leafNodeServerList(&leafNodes,this);; 823 treeNodeServerList(&treeNodes,this) ;; 824 ; 825 ; 826 // Check that the dependents are all fundamental. Filter out any that we; 827 // do not depend on, and make substitutions by name in our leaf list.; 828 // Check for overlaps with the projection variables.; 829 for (const auto arg : dependentVars) {; 830 if(!arg->isFundamental() && !dynamic_cast<const RooAbsLValue*>(arg)) {; 831 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: variable \"""" << arg->GetName(); 832 << ""\"" of wrong type: "" << arg->ClassName() << std::endl;; 833 return nullptr;; 834 }; 835 ; 836 RooAbsArg *found= treeNodes.find(arg->GetName());; 837 if(!found) {; 838 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: \"""" << arg->GetName(); 839 << ""\"" is not a dependent and will be ignored."" << std::endl;; 840 continue;; 841 }; 842 if(found != ar",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:32973,Integrability,depend,dependents,32973,"ars Dependent variables over which to normalise, \f$ \{x\} \f$.; 808/// \param[in] projectedVars Variables to project out, \f$ \{ y \} \f$.; 809/// \param[out] cloneSet Will be set to a RooArgSet*, which will contain a clone of *this plus its projection integral object.; 810/// The latter will also be returned. The caller takes ownership of this set.; 811/// \param[in] rangeName Optional range for projection integrals; 812/// \param[in] condObs Conditional observables, which are not integrated for normalisation, even if they; 813/// are in `dependentVars` or `projectedVars`.; 814/// \return A pointer to the newly created object, or zero in case of an; 815/// error. The caller is responsible for deleting the `cloneSet` (which includes the returned projection object).; 816const RooAbsReal *RooAbsReal::createPlotProjection(const RooArgSet &dependentVars, const RooArgSet *projectedVars,; 817 RooArgSet *&cloneSet, const char* rangeName, const RooArgSet* condObs) const; 818{; 819 // Get the set of our leaf nodes; 820 RooArgSet leafNodes;; 821 RooArgSet treeNodes;; 822 leafNodeServerList(&leafNodes,this);; 823 treeNodeServerList(&treeNodes,this) ;; 824 ; 825 ; 826 // Check that the dependents are all fundamental. Filter out any that we; 827 // do not depend on, and make substitutions by name in our leaf list.; 828 // Check for overlaps with the projection variables.; 829 for (const auto arg : dependentVars) {; 830 if(!arg->isFundamental() && !dynamic_cast<const RooAbsLValue*>(arg)) {; 831 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: variable \"""" << arg->GetName(); 832 << ""\"" of wrong type: "" << arg->ClassName() << std::endl;; 833 return nullptr;; 834 }; 835 ; 836 RooAbsArg *found= treeNodes.find(arg->GetName());; 837 if(!found) {; 838 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: \"""" << arg->GetName(); 839 << ""\"" is not a dependent and will be ignored."" << std::endl;; 840 continue;; 841 }; 842 if(found != ar",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:33043,Integrability,depend,depend,33043,"0/// The latter will also be returned. The caller takes ownership of this set.; 811/// \param[in] rangeName Optional range for projection integrals; 812/// \param[in] condObs Conditional observables, which are not integrated for normalisation, even if they; 813/// are in `dependentVars` or `projectedVars`.; 814/// \return A pointer to the newly created object, or zero in case of an; 815/// error. The caller is responsible for deleting the `cloneSet` (which includes the returned projection object).; 816const RooAbsReal *RooAbsReal::createPlotProjection(const RooArgSet &dependentVars, const RooArgSet *projectedVars,; 817 RooArgSet *&cloneSet, const char* rangeName, const RooArgSet* condObs) const; 818{; 819 // Get the set of our leaf nodes; 820 RooArgSet leafNodes;; 821 RooArgSet treeNodes;; 822 leafNodeServerList(&leafNodes,this);; 823 treeNodeServerList(&treeNodes,this) ;; 824 ; 825 ; 826 // Check that the dependents are all fundamental. Filter out any that we; 827 // do not depend on, and make substitutions by name in our leaf list.; 828 // Check for overlaps with the projection variables.; 829 for (const auto arg : dependentVars) {; 830 if(!arg->isFundamental() && !dynamic_cast<const RooAbsLValue*>(arg)) {; 831 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: variable \"""" << arg->GetName(); 832 << ""\"" of wrong type: "" << arg->ClassName() << std::endl;; 833 return nullptr;; 834 }; 835 ; 836 RooAbsArg *found= treeNodes.find(arg->GetName());; 837 if(!found) {; 838 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: \"""" << arg->GetName(); 839 << ""\"" is not a dependent and will be ignored."" << std::endl;; 840 continue;; 841 }; 842 if(found != arg) {; 843 if (leafNodes.find(found->GetName())) {; 844 leafNodes.replace(*found,*arg);; 845 } else {; 846 leafNodes.add(*arg) ;; 847 ; 848 // Remove any dependents of found, replace by dependents of LV node; 849 RooArgSet lvDep;; 850 arg->getObservables(&leafNodes, lvDep);",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:33188,Integrability,depend,dependentVars,33188," `projectedVars`.; 814/// \return A pointer to the newly created object, or zero in case of an; 815/// error. The caller is responsible for deleting the `cloneSet` (which includes the returned projection object).; 816const RooAbsReal *RooAbsReal::createPlotProjection(const RooArgSet &dependentVars, const RooArgSet *projectedVars,; 817 RooArgSet *&cloneSet, const char* rangeName, const RooArgSet* condObs) const; 818{; 819 // Get the set of our leaf nodes; 820 RooArgSet leafNodes;; 821 RooArgSet treeNodes;; 822 leafNodeServerList(&leafNodes,this);; 823 treeNodeServerList(&treeNodes,this) ;; 824 ; 825 ; 826 // Check that the dependents are all fundamental. Filter out any that we; 827 // do not depend on, and make substitutions by name in our leaf list.; 828 // Check for overlaps with the projection variables.; 829 for (const auto arg : dependentVars) {; 830 if(!arg->isFundamental() && !dynamic_cast<const RooAbsLValue*>(arg)) {; 831 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: variable \"""" << arg->GetName(); 832 << ""\"" of wrong type: "" << arg->ClassName() << std::endl;; 833 return nullptr;; 834 }; 835 ; 836 RooAbsArg *found= treeNodes.find(arg->GetName());; 837 if(!found) {; 838 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: \"""" << arg->GetName(); 839 << ""\"" is not a dependent and will be ignored."" << std::endl;; 840 continue;; 841 }; 842 if(found != arg) {; 843 if (leafNodes.find(found->GetName())) {; 844 leafNodes.replace(*found,*arg);; 845 } else {; 846 leafNodes.add(*arg) ;; 847 ; 848 // Remove any dependents of found, replace by dependents of LV node; 849 RooArgSet lvDep;; 850 arg->getObservables(&leafNodes, lvDep);; 851 for (const auto lvs : lvDep) {; 852 RooAbsArg* tmp = leafNodes.find(lvs->GetName()) ;; 853 if (tmp) {; 854 leafNodes.remove(*tmp) ;; 855 leafNodes.add(*lvs) ;; 856 }; 857 }; 858 }; 859 }; 860 ; 861 // check if this arg is also in the projection set; 862 if(nullptr != projectedVars &&",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:33693,Integrability,depend,dependent,33693,"et &dependentVars, const RooArgSet *projectedVars,; 817 RooArgSet *&cloneSet, const char* rangeName, const RooArgSet* condObs) const; 818{; 819 // Get the set of our leaf nodes; 820 RooArgSet leafNodes;; 821 RooArgSet treeNodes;; 822 leafNodeServerList(&leafNodes,this);; 823 treeNodeServerList(&treeNodes,this) ;; 824 ; 825 ; 826 // Check that the dependents are all fundamental. Filter out any that we; 827 // do not depend on, and make substitutions by name in our leaf list.; 828 // Check for overlaps with the projection variables.; 829 for (const auto arg : dependentVars) {; 830 if(!arg->isFundamental() && !dynamic_cast<const RooAbsLValue*>(arg)) {; 831 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: variable \"""" << arg->GetName(); 832 << ""\"" of wrong type: "" << arg->ClassName() << std::endl;; 833 return nullptr;; 834 }; 835 ; 836 RooAbsArg *found= treeNodes.find(arg->GetName());; 837 if(!found) {; 838 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: \"""" << arg->GetName(); 839 << ""\"" is not a dependent and will be ignored."" << std::endl;; 840 continue;; 841 }; 842 if(found != arg) {; 843 if (leafNodes.find(found->GetName())) {; 844 leafNodes.replace(*found,*arg);; 845 } else {; 846 leafNodes.add(*arg) ;; 847 ; 848 // Remove any dependents of found, replace by dependents of LV node; 849 RooArgSet lvDep;; 850 arg->getObservables(&leafNodes, lvDep);; 851 for (const auto lvs : lvDep) {; 852 RooAbsArg* tmp = leafNodes.find(lvs->GetName()) ;; 853 if (tmp) {; 854 leafNodes.remove(*tmp) ;; 855 leafNodes.add(*lvs) ;; 856 }; 857 }; 858 }; 859 }; 860 ; 861 // check if this arg is also in the projection set; 862 if(nullptr != projectedVars && projectedVars->find(arg->GetName())) {; 863 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: \"""" << arg->GetName(); 864 << ""\"" cannot be both a dependent and a projected variable."" << std::endl;; 865 return nullptr;; 866 }; 867 }; 868 ; 869 // Remove ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:33933,Integrability,depend,dependents,33933,"er out any that we; 827 // do not depend on, and make substitutions by name in our leaf list.; 828 // Check for overlaps with the projection variables.; 829 for (const auto arg : dependentVars) {; 830 if(!arg->isFundamental() && !dynamic_cast<const RooAbsLValue*>(arg)) {; 831 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: variable \"""" << arg->GetName(); 832 << ""\"" of wrong type: "" << arg->ClassName() << std::endl;; 833 return nullptr;; 834 }; 835 ; 836 RooAbsArg *found= treeNodes.find(arg->GetName());; 837 if(!found) {; 838 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: \"""" << arg->GetName(); 839 << ""\"" is not a dependent and will be ignored."" << std::endl;; 840 continue;; 841 }; 842 if(found != arg) {; 843 if (leafNodes.find(found->GetName())) {; 844 leafNodes.replace(*found,*arg);; 845 } else {; 846 leafNodes.add(*arg) ;; 847 ; 848 // Remove any dependents of found, replace by dependents of LV node; 849 RooArgSet lvDep;; 850 arg->getObservables(&leafNodes, lvDep);; 851 for (const auto lvs : lvDep) {; 852 RooAbsArg* tmp = leafNodes.find(lvs->GetName()) ;; 853 if (tmp) {; 854 leafNodes.remove(*tmp) ;; 855 leafNodes.add(*lvs) ;; 856 }; 857 }; 858 }; 859 }; 860 ; 861 // check if this arg is also in the projection set; 862 if(nullptr != projectedVars && projectedVars->find(arg->GetName())) {; 863 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: \"""" << arg->GetName(); 864 << ""\"" cannot be both a dependent and a projected variable."" << std::endl;; 865 return nullptr;; 866 }; 867 }; 868 ; 869 // Remove the projected variables from the list of leaf nodes, if necessary.; 870 if(nullptr != projectedVars) leafNodes.remove(*projectedVars,true);; 871 ; 872 // Make a deep-clone of ourself so later operations do not disturb our original state; 873 cloneSet = new RooArgSet;; 874 if (RooArgSet(*this).snapshot(*cloneSet, true)) {; 875 coutE(Plotting) << ""RooAbsPdf::createPlotProjection("" <<",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:33965,Integrability,depend,dependents,33965,"er out any that we; 827 // do not depend on, and make substitutions by name in our leaf list.; 828 // Check for overlaps with the projection variables.; 829 for (const auto arg : dependentVars) {; 830 if(!arg->isFundamental() && !dynamic_cast<const RooAbsLValue*>(arg)) {; 831 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: variable \"""" << arg->GetName(); 832 << ""\"" of wrong type: "" << arg->ClassName() << std::endl;; 833 return nullptr;; 834 }; 835 ; 836 RooAbsArg *found= treeNodes.find(arg->GetName());; 837 if(!found) {; 838 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: \"""" << arg->GetName(); 839 << ""\"" is not a dependent and will be ignored."" << std::endl;; 840 continue;; 841 }; 842 if(found != arg) {; 843 if (leafNodes.find(found->GetName())) {; 844 leafNodes.replace(*found,*arg);; 845 } else {; 846 leafNodes.add(*arg) ;; 847 ; 848 // Remove any dependents of found, replace by dependents of LV node; 849 RooArgSet lvDep;; 850 arg->getObservables(&leafNodes, lvDep);; 851 for (const auto lvs : lvDep) {; 852 RooAbsArg* tmp = leafNodes.find(lvs->GetName()) ;; 853 if (tmp) {; 854 leafNodes.remove(*tmp) ;; 855 leafNodes.add(*lvs) ;; 856 }; 857 }; 858 }; 859 }; 860 ; 861 // check if this arg is also in the projection set; 862 if(nullptr != projectedVars && projectedVars->find(arg->GetName())) {; 863 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: \"""" << arg->GetName(); 864 << ""\"" cannot be both a dependent and a projected variable."" << std::endl;; 865 return nullptr;; 866 }; 867 }; 868 ; 869 // Remove the projected variables from the list of leaf nodes, if necessary.; 870 if(nullptr != projectedVars) leafNodes.remove(*projectedVars,true);; 871 ; 872 // Make a deep-clone of ourself so later operations do not disturb our original state; 873 cloneSet = new RooArgSet;; 874 if (RooArgSet(*this).snapshot(*cloneSet, true)) {; 875 coutE(Plotting) << ""RooAbsPdf::createPlotProjection("" <<",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:34518,Integrability,depend,dependent,34518,"< arg->GetName(); 832 << ""\"" of wrong type: "" << arg->ClassName() << std::endl;; 833 return nullptr;; 834 }; 835 ; 836 RooAbsArg *found= treeNodes.find(arg->GetName());; 837 if(!found) {; 838 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: \"""" << arg->GetName(); 839 << ""\"" is not a dependent and will be ignored."" << std::endl;; 840 continue;; 841 }; 842 if(found != arg) {; 843 if (leafNodes.find(found->GetName())) {; 844 leafNodes.replace(*found,*arg);; 845 } else {; 846 leafNodes.add(*arg) ;; 847 ; 848 // Remove any dependents of found, replace by dependents of LV node; 849 RooArgSet lvDep;; 850 arg->getObservables(&leafNodes, lvDep);; 851 for (const auto lvs : lvDep) {; 852 RooAbsArg* tmp = leafNodes.find(lvs->GetName()) ;; 853 if (tmp) {; 854 leafNodes.remove(*tmp) ;; 855 leafNodes.add(*lvs) ;; 856 }; 857 }; 858 }; 859 }; 860 ; 861 // check if this arg is also in the projection set; 862 if(nullptr != projectedVars && projectedVars->find(arg->GetName())) {; 863 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: \"""" << arg->GetName(); 864 << ""\"" cannot be both a dependent and a projected variable."" << std::endl;; 865 return nullptr;; 866 }; 867 }; 868 ; 869 // Remove the projected variables from the list of leaf nodes, if necessary.; 870 if(nullptr != projectedVars) leafNodes.remove(*projectedVars,true);; 871 ; 872 // Make a deep-clone of ourself so later operations do not disturb our original state; 873 cloneSet = new RooArgSet;; 874 if (RooArgSet(*this).snapshot(*cloneSet, true)) {; 875 coutE(Plotting) << ""RooAbsPdf::createPlotProjection("" << GetName() << "") Couldn't deep-clone PDF, abort,"" << std::endl ;; 876 return nullptr ;; 877 }; 878 RooAbsReal *theClone= static_cast<RooAbsReal*>(cloneSet->find(GetName()));; 879 ; 880 // The remaining entries in our list of leaf nodes are the external; 881 // dependents (x) and parameters (p) of the projection. Patch them back; 882 // into the theClone. This orphans t",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:35270,Integrability,depend,dependents,35270,"s.find(lvs->GetName()) ;; 853 if (tmp) {; 854 leafNodes.remove(*tmp) ;; 855 leafNodes.add(*lvs) ;; 856 }; 857 }; 858 }; 859 }; 860 ; 861 // check if this arg is also in the projection set; 862 if(nullptr != projectedVars && projectedVars->find(arg->GetName())) {; 863 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: \"""" << arg->GetName(); 864 << ""\"" cannot be both a dependent and a projected variable."" << std::endl;; 865 return nullptr;; 866 }; 867 }; 868 ; 869 // Remove the projected variables from the list of leaf nodes, if necessary.; 870 if(nullptr != projectedVars) leafNodes.remove(*projectedVars,true);; 871 ; 872 // Make a deep-clone of ourself so later operations do not disturb our original state; 873 cloneSet = new RooArgSet;; 874 if (RooArgSet(*this).snapshot(*cloneSet, true)) {; 875 coutE(Plotting) << ""RooAbsPdf::createPlotProjection("" << GetName() << "") Couldn't deep-clone PDF, abort,"" << std::endl ;; 876 return nullptr ;; 877 }; 878 RooAbsReal *theClone= static_cast<RooAbsReal*>(cloneSet->find(GetName()));; 879 ; 880 // The remaining entries in our list of leaf nodes are the external; 881 // dependents (x) and parameters (p) of the projection. Patch them back; 882 // into the theClone. This orphans the nodes they replace, but the orphans; 883 // are still in the cloneList and so will be cleaned up eventually.; 884 //cout << ""redirection leafNodes : "" ; leafNodes.Print(""1"") ;; 885 ; 886 std::unique_ptr<RooArgSet> plotLeafNodes{leafNodes.selectCommon(dependentVars)};; 887 theClone->recursiveRedirectServers(*plotLeafNodes,false,false,false);; 888 ; 889 // Create the set of normalization variables to use in the projection integrand; 890 RooArgSet normSet(dependentVars);; 891 if(nullptr != projectedVars) normSet.add(*projectedVars);; 892 if(nullptr != condObs) {; 893 normSet.remove(*condObs,true,true) ;; 894 }; 895 ; 896 // Try to create a valid projection integral. If no variables are to be projected,; 897 // create a null project",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:35634,Integrability,depend,dependentVars,35634,"rue);; 871 ; 872 // Make a deep-clone of ourself so later operations do not disturb our original state; 873 cloneSet = new RooArgSet;; 874 if (RooArgSet(*this).snapshot(*cloneSet, true)) {; 875 coutE(Plotting) << ""RooAbsPdf::createPlotProjection("" << GetName() << "") Couldn't deep-clone PDF, abort,"" << std::endl ;; 876 return nullptr ;; 877 }; 878 RooAbsReal *theClone= static_cast<RooAbsReal*>(cloneSet->find(GetName()));; 879 ; 880 // The remaining entries in our list of leaf nodes are the external; 881 // dependents (x) and parameters (p) of the projection. Patch them back; 882 // into the theClone. This orphans the nodes they replace, but the orphans; 883 // are still in the cloneList and so will be cleaned up eventually.; 884 //cout << ""redirection leafNodes : "" ; leafNodes.Print(""1"") ;; 885 ; 886 std::unique_ptr<RooArgSet> plotLeafNodes{leafNodes.selectCommon(dependentVars)};; 887 theClone->recursiveRedirectServers(*plotLeafNodes,false,false,false);; 888 ; 889 // Create the set of normalization variables to use in the projection integrand; 890 RooArgSet normSet(dependentVars);; 891 if(nullptr != projectedVars) normSet.add(*projectedVars);; 892 if(nullptr != condObs) {; 893 normSet.remove(*condObs,true,true) ;; 894 }; 895 ; 896 // Try to create a valid projection integral. If no variables are to be projected,; 897 // create a null projection anyway to bind our normalization over the dependents; 898 // consistently with the way they would be bound with a non-trivial projection.; 899 RooArgSet empty;; 900 if(nullptr == projectedVars) projectedVars= &empty;; 901 ; 902 std::string name = GetName();; 903 name += integralNameSuffix(*projectedVars,&normSet,rangeName,true) ;; 904 ; 905 std::string title = std::string{""Projection of ""} + GetTitle();; 906 ; 907 std::unique_ptr<RooAbsReal> projected{theClone->createIntegral(*projectedVars,normSet,rangeName)};; 908 ; 909 if(nullptr == projected || !projected->isValid()) {; 910 coutE(Plotting) << ClassName() << ""::"" << GetName(",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:35840,Integrability,depend,dependentVars,35840,"rue);; 871 ; 872 // Make a deep-clone of ourself so later operations do not disturb our original state; 873 cloneSet = new RooArgSet;; 874 if (RooArgSet(*this).snapshot(*cloneSet, true)) {; 875 coutE(Plotting) << ""RooAbsPdf::createPlotProjection("" << GetName() << "") Couldn't deep-clone PDF, abort,"" << std::endl ;; 876 return nullptr ;; 877 }; 878 RooAbsReal *theClone= static_cast<RooAbsReal*>(cloneSet->find(GetName()));; 879 ; 880 // The remaining entries in our list of leaf nodes are the external; 881 // dependents (x) and parameters (p) of the projection. Patch them back; 882 // into the theClone. This orphans the nodes they replace, but the orphans; 883 // are still in the cloneList and so will be cleaned up eventually.; 884 //cout << ""redirection leafNodes : "" ; leafNodes.Print(""1"") ;; 885 ; 886 std::unique_ptr<RooArgSet> plotLeafNodes{leafNodes.selectCommon(dependentVars)};; 887 theClone->recursiveRedirectServers(*plotLeafNodes,false,false,false);; 888 ; 889 // Create the set of normalization variables to use in the projection integrand; 890 RooArgSet normSet(dependentVars);; 891 if(nullptr != projectedVars) normSet.add(*projectedVars);; 892 if(nullptr != condObs) {; 893 normSet.remove(*condObs,true,true) ;; 894 }; 895 ; 896 // Try to create a valid projection integral. If no variables are to be projected,; 897 // create a null projection anyway to bind our normalization over the dependents; 898 // consistently with the way they would be bound with a non-trivial projection.; 899 RooArgSet empty;; 900 if(nullptr == projectedVars) projectedVars= &empty;; 901 ; 902 std::string name = GetName();; 903 name += integralNameSuffix(*projectedVars,&normSet,rangeName,true) ;; 904 ; 905 std::string title = std::string{""Projection of ""} + GetTitle();; 906 ; 907 std::unique_ptr<RooAbsReal> projected{theClone->createIntegral(*projectedVars,normSet,rangeName)};; 908 ; 909 if(nullptr == projected || !projected->isValid()) {; 910 coutE(Plotting) << ClassName() << ""::"" << GetName(",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:36167,Integrability,depend,dependents,36167,"neSet->find(GetName()));; 879 ; 880 // The remaining entries in our list of leaf nodes are the external; 881 // dependents (x) and parameters (p) of the projection. Patch them back; 882 // into the theClone. This orphans the nodes they replace, but the orphans; 883 // are still in the cloneList and so will be cleaned up eventually.; 884 //cout << ""redirection leafNodes : "" ; leafNodes.Print(""1"") ;; 885 ; 886 std::unique_ptr<RooArgSet> plotLeafNodes{leafNodes.selectCommon(dependentVars)};; 887 theClone->recursiveRedirectServers(*plotLeafNodes,false,false,false);; 888 ; 889 // Create the set of normalization variables to use in the projection integrand; 890 RooArgSet normSet(dependentVars);; 891 if(nullptr != projectedVars) normSet.add(*projectedVars);; 892 if(nullptr != condObs) {; 893 normSet.remove(*condObs,true,true) ;; 894 }; 895 ; 896 // Try to create a valid projection integral. If no variables are to be projected,; 897 // create a null projection anyway to bind our normalization over the dependents; 898 // consistently with the way they would be bound with a non-trivial projection.; 899 RooArgSet empty;; 900 if(nullptr == projectedVars) projectedVars= &empty;; 901 ; 902 std::string name = GetName();; 903 name += integralNameSuffix(*projectedVars,&normSet,rangeName,true) ;; 904 ; 905 std::string title = std::string{""Projection of ""} + GetTitle();; 906 ; 907 std::unique_ptr<RooAbsReal> projected{theClone->createIntegral(*projectedVars,normSet,rangeName)};; 908 ; 909 if(nullptr == projected || !projected->isValid()) {; 910 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: cannot integrate out "";; 911 projectedVars->printStream(std::cout,kName|kArgs,kSingleLine);; 912 return nullptr;; 913 }; 914 ; 915 if(projected->InheritsFrom(RooRealIntegral::Class())){; 916 static_cast<RooRealIntegral&>(*projected).setAllowComponentSelection(true);; 917 }; 918 ; 919 projected->SetName(name.c_str()) ;; 920 projected->SetTitle(title.c_str()) ;; 921 ; ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:36796,Integrability,integrat,integrate,36796,"tVars)};; 887 theClone->recursiveRedirectServers(*plotLeafNodes,false,false,false);; 888 ; 889 // Create the set of normalization variables to use in the projection integrand; 890 RooArgSet normSet(dependentVars);; 891 if(nullptr != projectedVars) normSet.add(*projectedVars);; 892 if(nullptr != condObs) {; 893 normSet.remove(*condObs,true,true) ;; 894 }; 895 ; 896 // Try to create a valid projection integral. If no variables are to be projected,; 897 // create a null projection anyway to bind our normalization over the dependents; 898 // consistently with the way they would be bound with a non-trivial projection.; 899 RooArgSet empty;; 900 if(nullptr == projectedVars) projectedVars= &empty;; 901 ; 902 std::string name = GetName();; 903 name += integralNameSuffix(*projectedVars,&normSet,rangeName,true) ;; 904 ; 905 std::string title = std::string{""Projection of ""} + GetTitle();; 906 ; 907 std::unique_ptr<RooAbsReal> projected{theClone->createIntegral(*projectedVars,normSet,rangeName)};; 908 ; 909 if(nullptr == projected || !projected->isValid()) {; 910 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: cannot integrate out "";; 911 projectedVars->printStream(std::cout,kName|kArgs,kSingleLine);; 912 return nullptr;; 913 }; 914 ; 915 if(projected->InheritsFrom(RooRealIntegral::Class())){; 916 static_cast<RooRealIntegral&>(*projected).setAllowComponentSelection(true);; 917 }; 918 ; 919 projected->SetName(name.c_str()) ;; 920 projected->SetTitle(title.c_str()) ;; 921 ; 922 // Add the projection integral to the cloneSet so that it eventually gets cleaned up by the caller.; 923 RooAbsReal *projectedPtr = projected.get();; 924 cloneSet->addOwned(std::move(projected));; 925 ; 926 // return a const pointer to remind the caller that they do not delete the returned object; 927 // directly (it is contained in the cloneSet instead).; 928 return projectedPtr;; 929}; 930 ; 931 ; 932 ; 933////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:37802,Integrability,integrat,integrating,37802,"s->printStream(std::cout,kName|kArgs,kSingleLine);; 912 return nullptr;; 913 }; 914 ; 915 if(projected->InheritsFrom(RooRealIntegral::Class())){; 916 static_cast<RooRealIntegral&>(*projected).setAllowComponentSelection(true);; 917 }; 918 ; 919 projected->SetName(name.c_str()) ;; 920 projected->SetTitle(title.c_str()) ;; 921 ; 922 // Add the projection integral to the cloneSet so that it eventually gets cleaned up by the caller.; 923 RooAbsReal *projectedPtr = projected.get();; 924 cloneSet->addOwned(std::move(projected));; 925 ; 926 // return a const pointer to remind the caller that they do not delete the returned object; 927 // directly (it is contained in the cloneSet instead).; 928 return projectedPtr;; 929}; 930 ; 931 ; 932 ; 933////////////////////////////////////////////////////////////////////////////////; 934/// Fill the ROOT histogram 'hist' with values sampled from this; 935/// function at the bin centers. Our value is calculated by first; 936/// integrating out any variables in projectedVars and then scaling; 937/// the result by scaleFactor. Returns a pointer to the input; 938/// histogram, or zero in case of an error. The input histogram can; 939/// be any TH1 subclass, and therefore of arbitrary; 940/// dimension. Variables are matched with the (x,y,...) dimensions of; 941/// the input histogram according to the order in which they appear; 942/// in the input plotVars list. If scaleForDensity is true the; 943/// histogram is filled with a the functions density rather than; 944/// the functions value (i.e. the value at the bin center is multiplied; 945/// with bin volume); 946 ; 947TH1 *RooAbsReal::fillHistogram(TH1 *hist, const RooArgList &plotVars,; 948 double scaleFactor, const RooArgSet *projectedVars, bool scaleForDensity,; 949 const RooArgSet* condObs, bool setError) const; 950{; 951 // Do we have a valid histogram to use?; 952 if(nullptr == hist) {; 953 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillHistogram: no valid histog",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:39342,Integrability,depend,depend,39342,"ear; 942/// in the input plotVars list. If scaleForDensity is true the; 943/// histogram is filled with a the functions density rather than; 944/// the functions value (i.e. the value at the bin center is multiplied; 945/// with bin volume); 946 ; 947TH1 *RooAbsReal::fillHistogram(TH1 *hist, const RooArgList &plotVars,; 948 double scaleFactor, const RooArgSet *projectedVars, bool scaleForDensity,; 949 const RooArgSet* condObs, bool setError) const; 950{; 951 // Do we have a valid histogram to use?; 952 if(nullptr == hist) {; 953 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillHistogram: no valid histogram to fill"" << std::endl;; 954 return nullptr;; 955 }; 956 ; 957 // Check that the number of plotVars matches the input histogram's dimension; 958 Int_t hdim= hist->GetDimension();; 959 if(hdim != int(plotVars.size())) {; 960 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillHistogram: plotVars has the wrong dimension"" << std::endl;; 961 return nullptr;; 962 }; 963 ; 964 ; 965 // Check that the plot variables are all actually RooRealVars and print a warning if we do not; 966 // explicitly depend on one of them. Fill a set (not list!) of cloned plot variables.; 967 RooArgSet plotClones;; 968 for(std::size_t index= 0; index < plotVars.size(); index++) {; 969 const RooAbsArg *var= plotVars.at(index);; 970 const RooRealVar *realVar= dynamic_cast<const RooRealVar*>(var);; 971 if(nullptr == realVar) {; 972 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillHistogram: cannot plot variable \"""" << var->GetName(); 973 << ""\"" of type "" << var->ClassName() << std::endl;; 974 return nullptr;; 975 }; 976 if(!this->dependsOn(*realVar)) {; 977 coutE(InputArguments) << ClassName() << ""::"" << GetName(); 978 << "":fillHistogram: WARNING: variable is not an explicit dependent: "" << realVar->GetName() << std::endl;; 979 }; 980 plotClones.addClone(*realVar,true); // do not complain about duplicates; 981 }; 982 ; 983 // Reconnect all plotClo",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:39880,Integrability,depend,dependsOn,39880,"d histogram to fill"" << std::endl;; 954 return nullptr;; 955 }; 956 ; 957 // Check that the number of plotVars matches the input histogram's dimension; 958 Int_t hdim= hist->GetDimension();; 959 if(hdim != int(plotVars.size())) {; 960 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillHistogram: plotVars has the wrong dimension"" << std::endl;; 961 return nullptr;; 962 }; 963 ; 964 ; 965 // Check that the plot variables are all actually RooRealVars and print a warning if we do not; 966 // explicitly depend on one of them. Fill a set (not list!) of cloned plot variables.; 967 RooArgSet plotClones;; 968 for(std::size_t index= 0; index < plotVars.size(); index++) {; 969 const RooAbsArg *var= plotVars.at(index);; 970 const RooRealVar *realVar= dynamic_cast<const RooRealVar*>(var);; 971 if(nullptr == realVar) {; 972 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillHistogram: cannot plot variable \"""" << var->GetName(); 973 << ""\"" of type "" << var->ClassName() << std::endl;; 974 return nullptr;; 975 }; 976 if(!this->dependsOn(*realVar)) {; 977 coutE(InputArguments) << ClassName() << ""::"" << GetName(); 978 << "":fillHistogram: WARNING: variable is not an explicit dependent: "" << realVar->GetName() << std::endl;; 979 }; 980 plotClones.addClone(*realVar,true); // do not complain about duplicates; 981 }; 982 ; 983 // Reconnect all plotClones to each other, imported when plotting N-dim integrals with entangled parameterized ranges; 984 for(RooAbsArg * pc : plotClones) {; 985 pc->recursiveRedirectServers(plotClones,false,false,true) ;; 986 }; 987 ; 988 // Call checkObservables; 989 RooArgSet allDeps(plotClones) ;; 990 if (projectedVars) {; 991 allDeps.add(*projectedVars) ;; 992 }; 993 if (checkObservables(&allDeps)) {; 994 coutE(InputArguments) << ""RooAbsReal::fillHistogram("" << GetName() << "") error in checkObservables, abort"" << std::endl ;; 995 return hist ;; 996 }; 997 ; 998 // Create a standalone projection object to use for calculating bin c",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:40028,Integrability,depend,dependent,40028,"d histogram to fill"" << std::endl;; 954 return nullptr;; 955 }; 956 ; 957 // Check that the number of plotVars matches the input histogram's dimension; 958 Int_t hdim= hist->GetDimension();; 959 if(hdim != int(plotVars.size())) {; 960 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillHistogram: plotVars has the wrong dimension"" << std::endl;; 961 return nullptr;; 962 }; 963 ; 964 ; 965 // Check that the plot variables are all actually RooRealVars and print a warning if we do not; 966 // explicitly depend on one of them. Fill a set (not list!) of cloned plot variables.; 967 RooArgSet plotClones;; 968 for(std::size_t index= 0; index < plotVars.size(); index++) {; 969 const RooAbsArg *var= plotVars.at(index);; 970 const RooRealVar *realVar= dynamic_cast<const RooRealVar*>(var);; 971 if(nullptr == realVar) {; 972 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillHistogram: cannot plot variable \"""" << var->GetName(); 973 << ""\"" of type "" << var->ClassName() << std::endl;; 974 return nullptr;; 975 }; 976 if(!this->dependsOn(*realVar)) {; 977 coutE(InputArguments) << ClassName() << ""::"" << GetName(); 978 << "":fillHistogram: WARNING: variable is not an explicit dependent: "" << realVar->GetName() << std::endl;; 979 }; 980 plotClones.addClone(*realVar,true); // do not complain about duplicates; 981 }; 982 ; 983 // Reconnect all plotClones to each other, imported when plotting N-dim integrals with entangled parameterized ranges; 984 for(RooAbsArg * pc : plotClones) {; 985 pc->recursiveRedirectServers(plotClones,false,false,true) ;; 986 }; 987 ; 988 // Call checkObservables; 989 RooArgSet allDeps(plotClones) ;; 990 if (projectedVars) {; 991 allDeps.add(*projectedVars) ;; 992 }; 993 if (checkObservables(&allDeps)) {; 994 coutE(InputArguments) << ""RooAbsReal::fillHistogram("" << GetName() << "") error in checkObservables, abort"" << std::endl ;; 995 return hist ;; 996 }; 997 ; 998 // Create a standalone projection object to use for calculating bin c",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:59014,Integrability,depend,depend,59014,"("" << GetName() << "") ERROR: component selection set "" << *compSet << "" does not match any components of p.d.f."" << std::endl ;; 1406 } else {; 1407 coutE(Plotting) << ""RooAbsPdf::createHistogram("" << GetName() << "") ERROR: component selection expression '"" << compSpec << ""' does not select any components of p.d.f."" << std::endl ;; 1408 }; 1409 return nullptr ;; 1410 }; 1411 }; 1412 ; 1413 double scaleFactor(1.0) ;; 1414 if (doExtended) {; 1415 scaleFactor = pdfSelf->expectedEvents(vars) ;; 1416 doScaling=false ;; 1417 }; 1418 ; 1419 fillHistogram(histo,vars,scaleFactor,intObs,doScaling,projObs,false) ;; 1420 ; 1421 // Deactivate component selection; 1422 if (haveCompSel) {; 1423 plotOnCompSelect(nullptr) ;; 1424 }; 1425 ; 1426 ; 1427 return histo ;; 1428}; 1429 ; 1430 ; 1431////////////////////////////////////////////////////////////////////////////////; 1432/// Helper function for plotting of composite p.d.fs. Given; 1433/// a set of selected components that should be plotted,; 1434/// find all nodes that (in)directly depend on these selected; 1435/// nodes. Mark all directly and indirectly selected nodes; 1436/// as 'selected' using the selectComp() method; 1437 ; 1438void RooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; 1439{; 1440 // Get complete set of tree branch nodes; 1441 RooArgSet branchNodeSet;; 1442 branchNodeServerList(&branchNodeSet);; 1443 ; 1444 // Discard any non-PDF nodes; 1445 // Iterate by number because collection is being modified! Iterators may invalidate ...; 1446 for (unsigned int i = 0; i < branchNodeSet.size(); ++i) {; 1447 const auto arg = branchNodeSet[i];; 1448 if (!dynamic_cast<RooAbsReal*>(arg)) {; 1449 branchNodeSet.remove(*arg) ;; 1450 }; 1451 }; 1452 ; 1453 // If no set is specified, restored all selection bits to true; 1454 if (!selNodes) {; 1455 // Reset PDF selection bits to true; 1456 for (const auto arg : branchNodeSet) {; 1457 static_cast<RooAbsReal*>(arg)->selectComp(true);; 1458 }; 1459 return ;; 1460 }; 1461 ; 1462",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:60178,Integrability,depend,dependsOn,60178,"at should be plotted,; 1434/// find all nodes that (in)directly depend on these selected; 1435/// nodes. Mark all directly and indirectly selected nodes; 1436/// as 'selected' using the selectComp() method; 1437 ; 1438void RooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; 1439{; 1440 // Get complete set of tree branch nodes; 1441 RooArgSet branchNodeSet;; 1442 branchNodeServerList(&branchNodeSet);; 1443 ; 1444 // Discard any non-PDF nodes; 1445 // Iterate by number because collection is being modified! Iterators may invalidate ...; 1446 for (unsigned int i = 0; i < branchNodeSet.size(); ++i) {; 1447 const auto arg = branchNodeSet[i];; 1448 if (!dynamic_cast<RooAbsReal*>(arg)) {; 1449 branchNodeSet.remove(*arg) ;; 1450 }; 1451 }; 1452 ; 1453 // If no set is specified, restored all selection bits to true; 1454 if (!selNodes) {; 1455 // Reset PDF selection bits to true; 1456 for (const auto arg : branchNodeSet) {; 1457 static_cast<RooAbsReal*>(arg)->selectComp(true);; 1458 }; 1459 return ;; 1460 }; 1461 ; 1462 ; 1463 // Add all nodes below selected nodes that are value servers; 1464 RooArgSet tmp;; 1465 for (const auto arg : branchNodeSet) {; 1466 for (const auto selNode : *selNodes) {; 1467 if (selNode->dependsOn(*arg, nullptr, /*valueOnly=*/true)) {; 1468 tmp.add(*arg,true);; 1469 }; 1470 }; 1471 }; 1472 ; 1473 // Add all nodes that depend on selected nodes by value; 1474 for (const auto arg : branchNodeSet) {; 1475 if (arg->dependsOn(*selNodes, nullptr, /*valueOnly=*/true)) {; 1476 tmp.add(*arg,true);; 1477 }; 1478 }; 1479 ; 1480 tmp.remove(*selNodes, true);; 1481 tmp.remove(*this);; 1482 selNodes->add(tmp);; 1483 coutI(Plotting) << ""RooAbsPdf::plotOn("" << GetName() << "") indirectly selected PDF components: "" << tmp << std::endl ;; 1484 ; 1485 // Set PDF selection bits according to selNodes; 1486 for (const auto arg : branchNodeSet) {; 1487 bool select = selNodes->find(arg->GetName()) != nullptr;; 1488 static_cast<RooAbsReal*>(arg)->selectComp(select);; 1489 ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:60311,Integrability,depend,depend,60311,"Set);; 1443 ; 1444 // Discard any non-PDF nodes; 1445 // Iterate by number because collection is being modified! Iterators may invalidate ...; 1446 for (unsigned int i = 0; i < branchNodeSet.size(); ++i) {; 1447 const auto arg = branchNodeSet[i];; 1448 if (!dynamic_cast<RooAbsReal*>(arg)) {; 1449 branchNodeSet.remove(*arg) ;; 1450 }; 1451 }; 1452 ; 1453 // If no set is specified, restored all selection bits to true; 1454 if (!selNodes) {; 1455 // Reset PDF selection bits to true; 1456 for (const auto arg : branchNodeSet) {; 1457 static_cast<RooAbsReal*>(arg)->selectComp(true);; 1458 }; 1459 return ;; 1460 }; 1461 ; 1462 ; 1463 // Add all nodes below selected nodes that are value servers; 1464 RooArgSet tmp;; 1465 for (const auto arg : branchNodeSet) {; 1466 for (const auto selNode : *selNodes) {; 1467 if (selNode->dependsOn(*arg, nullptr, /*valueOnly=*/true)) {; 1468 tmp.add(*arg,true);; 1469 }; 1470 }; 1471 }; 1472 ; 1473 // Add all nodes that depend on selected nodes by value; 1474 for (const auto arg : branchNodeSet) {; 1475 if (arg->dependsOn(*selNodes, nullptr, /*valueOnly=*/true)) {; 1476 tmp.add(*arg,true);; 1477 }; 1478 }; 1479 ; 1480 tmp.remove(*selNodes, true);; 1481 tmp.remove(*this);; 1482 selNodes->add(tmp);; 1483 coutI(Plotting) << ""RooAbsPdf::plotOn("" << GetName() << "") indirectly selected PDF components: "" << tmp << std::endl ;; 1484 ; 1485 // Set PDF selection bits according to selNodes; 1486 for (const auto arg : branchNodeSet) {; 1487 bool select = selNodes->find(arg->GetName()) != nullptr;; 1488 static_cast<RooAbsReal*>(arg)->selectComp(select);; 1489 }; 1490}; 1491 ; 1492 ; 1493 ; 1494////////////////////////////////////////////////////////////////////////////////; 1495/// Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; 1496/// will show a unit normalized curve in the frame variable, taken at the present value; 1497/// of other observables defined for this PDF.; 1498///; 1499/// \param[in] frame pointer to RooPl",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:60405,Integrability,depend,dependsOn,60405,"Set);; 1443 ; 1444 // Discard any non-PDF nodes; 1445 // Iterate by number because collection is being modified! Iterators may invalidate ...; 1446 for (unsigned int i = 0; i < branchNodeSet.size(); ++i) {; 1447 const auto arg = branchNodeSet[i];; 1448 if (!dynamic_cast<RooAbsReal*>(arg)) {; 1449 branchNodeSet.remove(*arg) ;; 1450 }; 1451 }; 1452 ; 1453 // If no set is specified, restored all selection bits to true; 1454 if (!selNodes) {; 1455 // Reset PDF selection bits to true; 1456 for (const auto arg : branchNodeSet) {; 1457 static_cast<RooAbsReal*>(arg)->selectComp(true);; 1458 }; 1459 return ;; 1460 }; 1461 ; 1462 ; 1463 // Add all nodes below selected nodes that are value servers; 1464 RooArgSet tmp;; 1465 for (const auto arg : branchNodeSet) {; 1466 for (const auto selNode : *selNodes) {; 1467 if (selNode->dependsOn(*arg, nullptr, /*valueOnly=*/true)) {; 1468 tmp.add(*arg,true);; 1469 }; 1470 }; 1471 }; 1472 ; 1473 // Add all nodes that depend on selected nodes by value; 1474 for (const auto arg : branchNodeSet) {; 1475 if (arg->dependsOn(*selNodes, nullptr, /*valueOnly=*/true)) {; 1476 tmp.add(*arg,true);; 1477 }; 1478 }; 1479 ; 1480 tmp.remove(*selNodes, true);; 1481 tmp.remove(*this);; 1482 selNodes->add(tmp);; 1483 coutI(Plotting) << ""RooAbsPdf::plotOn("" << GetName() << "") indirectly selected PDF components: "" << tmp << std::endl ;; 1484 ; 1485 // Set PDF selection bits according to selNodes; 1486 for (const auto arg : branchNodeSet) {; 1487 bool select = selNodes->find(arg->GetName()) != nullptr;; 1488 static_cast<RooAbsReal*>(arg)->selectComp(select);; 1489 }; 1490}; 1491 ; 1492 ; 1493 ; 1494////////////////////////////////////////////////////////////////////////////////; 1495/// Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; 1496/// will show a unit normalized curve in the frame variable, taken at the present value; 1497/// of other observables defined for this PDF.; 1498///; 1499/// \param[in] frame pointer to RooPl",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:61578,Integrability,integrat,integrated,61578,"478 }; 1479 ; 1480 tmp.remove(*selNodes, true);; 1481 tmp.remove(*this);; 1482 selNodes->add(tmp);; 1483 coutI(Plotting) << ""RooAbsPdf::plotOn("" << GetName() << "") indirectly selected PDF components: "" << tmp << std::endl ;; 1484 ; 1485 // Set PDF selection bits according to selNodes; 1486 for (const auto arg : branchNodeSet) {; 1487 bool select = selNodes->find(arg->GetName()) != nullptr;; 1488 static_cast<RooAbsReal*>(arg)->selectComp(select);; 1489 }; 1490}; 1491 ; 1492 ; 1493 ; 1494////////////////////////////////////////////////////////////////////////////////; 1495/// Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; 1496/// will show a unit normalized curve in the frame variable, taken at the present value; 1497/// of other observables defined for this PDF.; 1498///; 1499/// \param[in] frame pointer to RooPlot; 1500/// \param[in] arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10 Ordered arguments; 1501///; 1502/// If a PDF is plotted in a frame in which a dataset has already been plotted, it will; 1503/// show a projected curve integrated over all variables that were present in the shown; 1504/// dataset except for the one on the x-axis. The normalization of the curve will also; 1505/// be adjusted to the event count of the plotted dataset. An informational message; 1506/// will be printed for each projection step that is performed.; 1507///; 1508/// This function takes the following named arguments; 1509/// <table>; 1510/// <tr><th><th> Projection control; 1511/// <tr><td> `Slice(const RooArgSet& set)` <td> Override default projection behaviour by omitting observables listed; 1512/// in set from the projection, i.e. by not integrating over these.; 1513/// Slicing is usually only sensible in discrete observables, by e.g. creating a slice; 1514/// of the PDF at the current value of the category observable.; 1515///; 1516/// <tr><td> `Slice(RooCategory& cat, const char* label)` <td> Override default projection behaviour by omitti",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:61812,Integrability,message,message,61812," = selNodes->find(arg->GetName()) != nullptr;; 1488 static_cast<RooAbsReal*>(arg)->selectComp(select);; 1489 }; 1490}; 1491 ; 1492 ; 1493 ; 1494////////////////////////////////////////////////////////////////////////////////; 1495/// Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; 1496/// will show a unit normalized curve in the frame variable, taken at the present value; 1497/// of other observables defined for this PDF.; 1498///; 1499/// \param[in] frame pointer to RooPlot; 1500/// \param[in] arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10 Ordered arguments; 1501///; 1502/// If a PDF is plotted in a frame in which a dataset has already been plotted, it will; 1503/// show a projected curve integrated over all variables that were present in the shown; 1504/// dataset except for the one on the x-axis. The normalization of the curve will also; 1505/// be adjusted to the event count of the plotted dataset. An informational message; 1506/// will be printed for each projection step that is performed.; 1507///; 1508/// This function takes the following named arguments; 1509/// <table>; 1510/// <tr><th><th> Projection control; 1511/// <tr><td> `Slice(const RooArgSet& set)` <td> Override default projection behaviour by omitting observables listed; 1512/// in set from the projection, i.e. by not integrating over these.; 1513/// Slicing is usually only sensible in discrete observables, by e.g. creating a slice; 1514/// of the PDF at the current value of the category observable.; 1515///; 1516/// <tr><td> `Slice(RooCategory& cat, const char* label)` <td> Override default projection behaviour by omitting the specified category; 1517/// observable from the projection, i.e., by not integrating over all states of this category.; 1518/// The slice is positioned at the given label value. To pass multiple Slice() commands, please use the; 1519/// Slice(std::map<RooCategory*, std::string> const&) argument explained below.; 1520///; 1521/// <tr><td>",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:62186,Integrability,integrat,integrating,62186,"curve in the frame variable, taken at the present value; 1497/// of other observables defined for this PDF.; 1498///; 1499/// \param[in] frame pointer to RooPlot; 1500/// \param[in] arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10 Ordered arguments; 1501///; 1502/// If a PDF is plotted in a frame in which a dataset has already been plotted, it will; 1503/// show a projected curve integrated over all variables that were present in the shown; 1504/// dataset except for the one on the x-axis. The normalization of the curve will also; 1505/// be adjusted to the event count of the plotted dataset. An informational message; 1506/// will be printed for each projection step that is performed.; 1507///; 1508/// This function takes the following named arguments; 1509/// <table>; 1510/// <tr><th><th> Projection control; 1511/// <tr><td> `Slice(const RooArgSet& set)` <td> Override default projection behaviour by omitting observables listed; 1512/// in set from the projection, i.e. by not integrating over these.; 1513/// Slicing is usually only sensible in discrete observables, by e.g. creating a slice; 1514/// of the PDF at the current value of the category observable.; 1515///; 1516/// <tr><td> `Slice(RooCategory& cat, const char* label)` <td> Override default projection behaviour by omitting the specified category; 1517/// observable from the projection, i.e., by not integrating over all states of this category.; 1518/// The slice is positioned at the given label value. To pass multiple Slice() commands, please use the; 1519/// Slice(std::map<RooCategory*, std::string> const&) argument explained below.; 1520///; 1521/// <tr><td> `Slice(std::map<RooCategory*, std::string> const&)` <td> Omits multiple categories from the projection, as explianed above.; 1522/// Can be used with initializer lists for convenience, e.g.; 1523/// ```{.cpp}; 1524/// pdf.plotOn(frame, Slice({{&tagCategory, ""2tag""}, {&jetCategory, ""3jet""}});; 1525/// ```; 1526///; 1527/// <tr><td> `Project(const RooA",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:62575,Integrability,integrat,integrating,62575," all variables that were present in the shown; 1504/// dataset except for the one on the x-axis. The normalization of the curve will also; 1505/// be adjusted to the event count of the plotted dataset. An informational message; 1506/// will be printed for each projection step that is performed.; 1507///; 1508/// This function takes the following named arguments; 1509/// <table>; 1510/// <tr><th><th> Projection control; 1511/// <tr><td> `Slice(const RooArgSet& set)` <td> Override default projection behaviour by omitting observables listed; 1512/// in set from the projection, i.e. by not integrating over these.; 1513/// Slicing is usually only sensible in discrete observables, by e.g. creating a slice; 1514/// of the PDF at the current value of the category observable.; 1515///; 1516/// <tr><td> `Slice(RooCategory& cat, const char* label)` <td> Override default projection behaviour by omitting the specified category; 1517/// observable from the projection, i.e., by not integrating over all states of this category.; 1518/// The slice is positioned at the given label value. To pass multiple Slice() commands, please use the; 1519/// Slice(std::map<RooCategory*, std::string> const&) argument explained below.; 1520///; 1521/// <tr><td> `Slice(std::map<RooCategory*, std::string> const&)` <td> Omits multiple categories from the projection, as explianed above.; 1522/// Can be used with initializer lists for convenience, e.g.; 1523/// ```{.cpp}; 1524/// pdf.plotOn(frame, Slice({{&tagCategory, ""2tag""}, {&jetCategory, ""3jet""}});; 1525/// ```; 1526///; 1527/// <tr><td> `Project(const RooArgSet& set)` <td> Override default projection behaviour by projecting over observables; 1528/// given in the set, ignoring the default projection behavior. Advanced use only.; 1529///; 1530/// <tr><td> `ProjWData(const RooAbsData& d)` <td> Override default projection _technique_ (integration). For observables present in given dataset; 1531/// projection of PDF is achieved by constructing an avera",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:63475,Integrability,integrat,integration,63475," char* label)` <td> Override default projection behaviour by omitting the specified category; 1517/// observable from the projection, i.e., by not integrating over all states of this category.; 1518/// The slice is positioned at the given label value. To pass multiple Slice() commands, please use the; 1519/// Slice(std::map<RooCategory*, std::string> const&) argument explained below.; 1520///; 1521/// <tr><td> `Slice(std::map<RooCategory*, std::string> const&)` <td> Omits multiple categories from the projection, as explianed above.; 1522/// Can be used with initializer lists for convenience, e.g.; 1523/// ```{.cpp}; 1524/// pdf.plotOn(frame, Slice({{&tagCategory, ""2tag""}, {&jetCategory, ""3jet""}});; 1525/// ```; 1526///; 1527/// <tr><td> `Project(const RooArgSet& set)` <td> Override default projection behaviour by projecting over observables; 1528/// given in the set, ignoring the default projection behavior. Advanced use only.; 1529///; 1530/// <tr><td> `ProjWData(const RooAbsData& d)` <td> Override default projection _technique_ (integration). For observables present in given dataset; 1531/// projection of PDF is achieved by constructing an average over all observable values in given set.; 1532/// Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; 1533///; 1534/// <tr><td> `ProjWData(const RooArgSet& s, const RooAbsData& d)` <td> As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; 1535///; 1536/// <tr><td> `ProjectionRange(const char* rn)` <td> Override default range of projection integrals to a different range specified by given range name.; 1537/// This technique allows you to project a finite width slice in a real-valued observable; 1538///; 1539/// <tr><td> `NumCPU(Int_t ncpu)` <td> Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData); 1540///; 1541///; 1542/// <tr><th><th> Misc content control; 1543/// <tr",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:64727,Integrability,message,messages,64727," explanation of meaning & use of this technique; 1533///; 1534/// <tr><td> `ProjWData(const RooArgSet& s, const RooAbsData& d)` <td> As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; 1535///; 1536/// <tr><td> `ProjectionRange(const char* rn)` <td> Override default range of projection integrals to a different range specified by given range name.; 1537/// This technique allows you to project a finite width slice in a real-valued observable; 1538///; 1539/// <tr><td> `NumCPU(Int_t ncpu)` <td> Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData); 1540///; 1541///; 1542/// <tr><th><th> Misc content control; 1543/// <tr><td> `PrintEvalErrors(Int_t numErr)` <td> Control number of p.d.f evaluation errors printed per curve. A negative; 1544/// value suppress output completely, a zero value will only print the error count per p.d.f component,; 1545/// a positive value is will print details of each error up to numErr messages per p.d.f component.; 1546///; 1547/// <tr><td> `EvalErrorValue(double value)` <td> Set curve points at which (pdf) evaluation errors occur to specified value. By default the; 1548/// function value is plotted.; 1549///; 1550/// <tr><td> `Normalization(double scale, ScaleType code)` <td> Adjust normalization by given scale factor. Interpretation of number depends on code:; 1551/// - Relative: relative adjustment factor for a normalized function,; 1552/// - NumEvent: scale to match given number of events.; 1553/// - Raw: relative adjustment factor for an un-normalized function.; 1554///; 1555/// <tr><td> `Name(const chat* name)` <td> Give curve specified name in frame. Useful if curve is to be referenced later; 1556///; 1557/// <tr><td> `Asymmetry(const RooCategory& c)` <td> Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; 1558/// the PDF projection. Category must have two states with indices -1",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:65094,Integrability,depend,depends,65094,"lice in a real-valued observable; 1538///; 1539/// <tr><td> `NumCPU(Int_t ncpu)` <td> Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData); 1540///; 1541///; 1542/// <tr><th><th> Misc content control; 1543/// <tr><td> `PrintEvalErrors(Int_t numErr)` <td> Control number of p.d.f evaluation errors printed per curve. A negative; 1544/// value suppress output completely, a zero value will only print the error count per p.d.f component,; 1545/// a positive value is will print details of each error up to numErr messages per p.d.f component.; 1546///; 1547/// <tr><td> `EvalErrorValue(double value)` <td> Set curve points at which (pdf) evaluation errors occur to specified value. By default the; 1548/// function value is plotted.; 1549///; 1550/// <tr><td> `Normalization(double scale, ScaleType code)` <td> Adjust normalization by given scale factor. Interpretation of number depends on code:; 1551/// - Relative: relative adjustment factor for a normalized function,; 1552/// - NumEvent: scale to match given number of events.; 1553/// - Raw: relative adjustment factor for an un-normalized function.; 1554///; 1555/// <tr><td> `Name(const chat* name)` <td> Give curve specified name in frame. Useful if curve is to be referenced later; 1556///; 1557/// <tr><td> `Asymmetry(const RooCategory& c)` <td> Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; 1558/// the PDF projection. Category must have two states with indices -1 and +1 or three states with; 1559/// indices -1,0 and +1.; 1560///; 1561/// <tr><td> `ShiftToZero(bool flag)` <td> Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when plotting \f$ -\log(L) \f$ or \f$ \chi^2 \f$ distributions; 1562///; 1563/// <tr><td> `AddTo(const char* name, double_t wgtSelf, double_t wgtOther)` <td> Add constructed projection to already existing curve with given name and relative weight factors; 1564/// <t",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:82062,Integrability,integrat,integration,82062,"ret->getAttMarker()->SetMarkerColor(markerColor) ;; 1849 if (markerStyle!=-999) ret->getAttMarker()->SetMarkerStyle(markerStyle) ;; 1850 if (markerSize!=-999) ret->getAttMarker()->SetMarkerSize(markerSize) ;; 1851 ; 1852 if ((fillColor != -999 || fillStyle != -999) && !drawOpt.Contains(""F"")) {; 1853 coutW(Plotting) << ""Fill color or style was set for plotting \"""" << GetName(); 1854 << ""\"", but these only have an effect when 'DrawOption(\""F\"")' for fill is used at the same time."" << std::endl;; 1855 }; 1856 ; 1857 // Move last inserted object to back to drawing stack if requested; 1858 if (pc.getInt(""moveToBack"") && frame->numItems()>1) {; 1859 frame->drawBefore(frame->getObject(0)->GetName(), frame->getCurve()->GetName());; 1860 }; 1861 ; 1862 return ret ;; 1863}; 1864 ; 1865 ; 1866 ; 1867/// Plotting engine function for internal use; 1868///; 1869/// Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; 1870/// function that occur in the previously plotted dataset are projected via partial integration,; 1871/// otherwise no projections are performed. Optionally, certain projections can be performed; 1872/// by summing over the values present in a provided dataset ('projData'), to correctly; 1873/// project out data dependents that are not properly described by the PDF (e.g. per-event errors).; 1874///; 1875/// The functions value can be multiplied with an optional scale factor. The interpretation; 1876/// of the scale factor is unique for generic real functions, for PDFs there are various interpretations; 1877/// possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details).; 1878///; 1879/// The default projection behaviour can be overridden by supplying an optional set of dependents; 1880/// to project via RooFit command arguments.; 1881//_____________________________________________________________________________; 1882// coverity[PASS_BY_VALUE]; 1883RooPlot* RooAbsReal::plotOn(RooPlot *frame, PlotOpt ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:82292,Integrability,depend,dependents,82292,"2 if ((fillColor != -999 || fillStyle != -999) && !drawOpt.Contains(""F"")) {; 1853 coutW(Plotting) << ""Fill color or style was set for plotting \"""" << GetName(); 1854 << ""\"", but these only have an effect when 'DrawOption(\""F\"")' for fill is used at the same time."" << std::endl;; 1855 }; 1856 ; 1857 // Move last inserted object to back to drawing stack if requested; 1858 if (pc.getInt(""moveToBack"") && frame->numItems()>1) {; 1859 frame->drawBefore(frame->getObject(0)->GetName(), frame->getCurve()->GetName());; 1860 }; 1861 ; 1862 return ret ;; 1863}; 1864 ; 1865 ; 1866 ; 1867/// Plotting engine function for internal use; 1868///; 1869/// Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; 1870/// function that occur in the previously plotted dataset are projected via partial integration,; 1871/// otherwise no projections are performed. Optionally, certain projections can be performed; 1872/// by summing over the values present in a provided dataset ('projData'), to correctly; 1873/// project out data dependents that are not properly described by the PDF (e.g. per-event errors).; 1874///; 1875/// The functions value can be multiplied with an optional scale factor. The interpretation; 1876/// of the scale factor is unique for generic real functions, for PDFs there are various interpretations; 1877/// possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details).; 1878///; 1879/// The default projection behaviour can be overridden by supplying an optional set of dependents; 1880/// to project via RooFit command arguments.; 1881//_____________________________________________________________________________; 1882// coverity[PASS_BY_VALUE]; 1883RooPlot* RooAbsReal::plotOn(RooPlot *frame, PlotOpt o) const; 1884{; 1885 // Sanity checks; 1886 if (plotSanityChecks(frame)) return frame ;; 1887 ; 1888 // ProjDataVars is either all projData observables, or the user indicated subset of it; 1889 RooArgSet projDataVars ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:82782,Integrability,depend,dependents,82782,"61 ; 1862 return ret ;; 1863}; 1864 ; 1865 ; 1866 ; 1867/// Plotting engine function for internal use; 1868///; 1869/// Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; 1870/// function that occur in the previously plotted dataset are projected via partial integration,; 1871/// otherwise no projections are performed. Optionally, certain projections can be performed; 1872/// by summing over the values present in a provided dataset ('projData'), to correctly; 1873/// project out data dependents that are not properly described by the PDF (e.g. per-event errors).; 1874///; 1875/// The functions value can be multiplied with an optional scale factor. The interpretation; 1876/// of the scale factor is unique for generic real functions, for PDFs there are various interpretations; 1877/// possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details).; 1878///; 1879/// The default projection behaviour can be overridden by supplying an optional set of dependents; 1880/// to project via RooFit command arguments.; 1881//_____________________________________________________________________________; 1882// coverity[PASS_BY_VALUE]; 1883RooPlot* RooAbsReal::plotOn(RooPlot *frame, PlotOpt o) const; 1884{; 1885 // Sanity checks; 1886 if (plotSanityChecks(frame)) return frame ;; 1887 ; 1888 // ProjDataVars is either all projData observables, or the user indicated subset of it; 1889 RooArgSet projDataVars ;; 1890 if (o.projData) {; 1891 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") have ProjData with observables = "" << *o.projData->get() << std::endl ;; 1892 if (o.projDataSet) {; 1893 projDataVars.add(*std::unique_ptr<RooArgSet>{o.projData->get()->selectCommon(*o.projDataSet)}) ;; 1894 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") have ProjDataSet = "" << *o.projDataSet << "" will only use this subset of projData"" << std::endl ;; 1895 } else {; 1896 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:85694,Integrability,depend,dependents,85694,"f (frame->getNormVars()) {; 1913 RooArgSet sliceSetTmp;; 1914 getObservables(frame->getNormVars(), sliceSetTmp) ;; 1915 ; 1916 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") frame->getNormVars() that are also observables = "" << sliceSetTmp << std::endl ;; 1917 ; 1918 sliceSetTmp.remove(projectedVars,true,true) ;; 1919 sliceSetTmp.remove(*frame->getPlotVar(),true,true) ;; 1920 ; 1921 if (o.projData) {; 1922 std::unique_ptr<RooArgSet> tmp{projDataVars.selectCommon(*o.projSet)};; 1923 sliceSetTmp.remove(*tmp,true,true) ;; 1924 }; 1925 ; 1926 if (!sliceSetTmp.empty()) {; 1927 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot on ""; 1928 << frame->getPlotVar()->GetName() << "" represents a slice in "" << sliceSetTmp << std::endl ;; 1929 }; 1930 sliceSet.add(sliceSetTmp) ;; 1931 }; 1932 } else {; 1933 makeProjectionSet(frame->getPlotVar(),frame->getNormVars(),projectedVars,true) ;; 1934 }; 1935 ; 1936 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") projectedVars = "" << projectedVars << "" sliceSet = "" << sliceSet << std::endl ;; 1937 ; 1938 ; 1939 RooArgSet* projDataNeededVars = nullptr ;; 1940 // Take out data-projected dependents from projectedVars; 1941 if (o.projData) {; 1942 projDataNeededVars = projectedVars.selectCommon(projDataVars);; 1943 projectedVars.remove(projDataVars,true,true) ;; 1944 }; 1945 ; 1946 // Get the plot variable and remember its original value; 1947 auto* plotVar = static_cast<RooRealVar*>(frame->getPlotVar());; 1948 double oldPlotVarVal = plotVar->getVal();; 1949 ; 1950 // Inform user about projections; 1951 if (!projectedVars.empty()) {; 1952 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot on "" << plotVar->GetName(); 1953 << "" integrates over variables "" << projectedVars; 1954 << (o.projectionRangeName?Form("" in range %s"",o.projectionRangeName):"""") << std::endl;; 1955 }; 1956 if (projDataNeededVars && !projDataNeededVars->empty()) {; 1957 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetNam",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:86256,Integrability,integrat,integrates,86256," << "" represents a slice in "" << sliceSetTmp << std::endl ;; 1929 }; 1930 sliceSet.add(sliceSetTmp) ;; 1931 }; 1932 } else {; 1933 makeProjectionSet(frame->getPlotVar(),frame->getNormVars(),projectedVars,true) ;; 1934 }; 1935 ; 1936 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") projectedVars = "" << projectedVars << "" sliceSet = "" << sliceSet << std::endl ;; 1937 ; 1938 ; 1939 RooArgSet* projDataNeededVars = nullptr ;; 1940 // Take out data-projected dependents from projectedVars; 1941 if (o.projData) {; 1942 projDataNeededVars = projectedVars.selectCommon(projDataVars);; 1943 projectedVars.remove(projDataVars,true,true) ;; 1944 }; 1945 ; 1946 // Get the plot variable and remember its original value; 1947 auto* plotVar = static_cast<RooRealVar*>(frame->getPlotVar());; 1948 double oldPlotVarVal = plotVar->getVal();; 1949 ; 1950 // Inform user about projections; 1951 if (!projectedVars.empty()) {; 1952 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot on "" << plotVar->GetName(); 1953 << "" integrates over variables "" << projectedVars; 1954 << (o.projectionRangeName?Form("" in range %s"",o.projectionRangeName):"""") << std::endl;; 1955 }; 1956 if (projDataNeededVars && !projDataNeededVars->empty()) {; 1957 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot on "" << plotVar->GetName(); 1958 << "" averages using data variables "" << *projDataNeededVars << std::endl ;; 1959 }; 1960 ; 1961 // Create projection integral; 1962 RooArgSet* projectionCompList = nullptr ;; 1963 ; 1964 RooArgSet deps;; 1965 getObservables(frame->getNormVars(), deps) ;; 1966 deps.remove(projectedVars,true,true) ;; 1967 if (projDataNeededVars) {; 1968 deps.remove(*projDataNeededVars,true,true) ;; 1969 }; 1970 deps.remove(*plotVar,true,true) ;; 1971 deps.add(*plotVar) ;; 1972 ; 1973 // Now that we have the final set of dependents, call checkObservables(); 1974 ; 1975 // WVE take out conditional observables; 1976 if (checkObservables(&deps)) {; 1977 coutE(Plotting) ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:87077,Integrability,depend,dependents,87077," variables "" << projectedVars; 1954 << (o.projectionRangeName?Form("" in range %s"",o.projectionRangeName):"""") << std::endl;; 1955 }; 1956 if (projDataNeededVars && !projDataNeededVars->empty()) {; 1957 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot on "" << plotVar->GetName(); 1958 << "" averages using data variables "" << *projDataNeededVars << std::endl ;; 1959 }; 1960 ; 1961 // Create projection integral; 1962 RooArgSet* projectionCompList = nullptr ;; 1963 ; 1964 RooArgSet deps;; 1965 getObservables(frame->getNormVars(), deps) ;; 1966 deps.remove(projectedVars,true,true) ;; 1967 if (projDataNeededVars) {; 1968 deps.remove(*projDataNeededVars,true,true) ;; 1969 }; 1970 deps.remove(*plotVar,true,true) ;; 1971 deps.add(*plotVar) ;; 1972 ; 1973 // Now that we have the final set of dependents, call checkObservables(); 1974 ; 1975 // WVE take out conditional observables; 1976 if (checkObservables(&deps)) {; 1977 coutE(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") error in checkObservables, abort"" << std::endl ;; 1978 if (projDataNeededVars) delete projDataNeededVars ;; 1979 return frame ;; 1980 }; 1981 ; 1982 RooAbsReal *projection = const_cast<RooAbsReal*>(createPlotProjection(deps, &projectedVars, projectionCompList, o.projectionRangeName));; 1983 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot projection object is "" << projection->GetName() << std::endl ;; 1984 if (dologD(Plotting)) {; 1985 projection->printStream(ccoutD(Plotting),0,kVerbose) ;; 1986 }; 1987 ; 1988 // Always fix RooAddPdf normalizations; 1989 RooArgSet fullNormSet(deps) ;; 1990 fullNormSet.add(projectedVars) ;; 1991 if (projDataNeededVars && !projDataNeededVars->empty()) {; 1992 fullNormSet.add(*projDataNeededVars) ;; 1993 }; 1994 ; 1995 std::unique_ptr<RooArgSet> projectionComponents(projection->getComponents());; 1996 for(auto * pdf : dynamic_range_cast<RooAbsPdf*>(*projectionComponents)) {; 1997 if (pdf) {; 1998 pdf->selectNormalization(&fullNormSet) ;; 19",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:97284,Integrability,integrat,integration,97284,"183 }; 2184 ; 2185 // add this new curve to the specified plot frame; 2186 frame->addPlotable(curve, o.drawOptions, o.curveInvisible);; 2187 }; 2188 }; 2189 ; 2190 if (projDataNeededVars) delete projDataNeededVars ;; 2191 delete projectionCompList ;; 2192 plotVar->setVal(oldPlotVarVal); // reset the plot variable value to not disturb the original state; 2193 return frame;; 2194}; 2195 ; 2196 ; 2197//_____________________________________________________________________________; 2198// coverity[PASS_BY_VALUE]; 2199RooPlot* RooAbsReal::plotAsymOn(RooPlot *frame, const RooAbsCategoryLValue& asymCat, PlotOpt o) const; 2200 ; 2201{; 2202 // Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))); 2203 //; 2204 // Plot asymmetry of ourselves, defined as; 2205 //; 2206 // asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ); 2207 //; 2208 // on frame. If frame contains a histogram, all dimensions of the plotted; 2209 // asymmetry function that occur in the previously plotted dataset are projected via partial integration.; 2210 // Otherwise no projections are performed,; 2211 //; 2212 // The asymmetry function can be multiplied with an optional scale factor. The default projection; 2213 // behaviour can be overridden by supplying an optional set of dependents to project.; 2214 ; 2215 // Sanity checks; 2216 if (plotSanityChecks(frame)) return frame ;; 2217 ; 2218 // ProjDataVars is either all projData observables, or the user indicated subset of it; 2219 RooArgSet projDataVars ;; 2220 if (o.projData) {; 2221 if (o.projDataSet) {; 2222 std::unique_ptr<RooArgSet> tmp{o.projData->get()->selectCommon(*o.projDataSet)};; 2223 projDataVars.add(*tmp) ;; 2224 } else {; 2225 projDataVars.add(*o.projData->get()) ;; 2226 }; 2227 }; 2228 ; 2229 // Must depend on asymCat; 2230 if (!dependsOn(asymCat)) {; 2231 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2232 << "") function doesn't depend on asymmetry category "" << asym",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:97528,Integrability,depend,dependents,97528,"al); // reset the plot variable value to not disturb the original state; 2193 return frame;; 2194}; 2195 ; 2196 ; 2197//_____________________________________________________________________________; 2198// coverity[PASS_BY_VALUE]; 2199RooPlot* RooAbsReal::plotAsymOn(RooPlot *frame, const RooAbsCategoryLValue& asymCat, PlotOpt o) const; 2200 ; 2201{; 2202 // Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))); 2203 //; 2204 // Plot asymmetry of ourselves, defined as; 2205 //; 2206 // asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ); 2207 //; 2208 // on frame. If frame contains a histogram, all dimensions of the plotted; 2209 // asymmetry function that occur in the previously plotted dataset are projected via partial integration.; 2210 // Otherwise no projections are performed,; 2211 //; 2212 // The asymmetry function can be multiplied with an optional scale factor. The default projection; 2213 // behaviour can be overridden by supplying an optional set of dependents to project.; 2214 ; 2215 // Sanity checks; 2216 if (plotSanityChecks(frame)) return frame ;; 2217 ; 2218 // ProjDataVars is either all projData observables, or the user indicated subset of it; 2219 RooArgSet projDataVars ;; 2220 if (o.projData) {; 2221 if (o.projDataSet) {; 2222 std::unique_ptr<RooArgSet> tmp{o.projData->get()->selectCommon(*o.projDataSet)};; 2223 projDataVars.add(*tmp) ;; 2224 } else {; 2225 projDataVars.add(*o.projData->get()) ;; 2226 }; 2227 }; 2228 ; 2229 // Must depend on asymCat; 2230 if (!dependsOn(asymCat)) {; 2231 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2232 << "") function doesn't depend on asymmetry category "" << asymCat.GetName() << std::endl ;; 2233 return frame ;; 2234 }; 2235 ; 2236 // asymCat must be a signCat; 2237 if (!asymCat.isSignType()) {; 2238 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2239 << "") asymmetry category must have 2 or 3 states with index values -1,0,1"" << ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:98028,Integrability,depend,depend,98028," ); 2207 //; 2208 // on frame. If frame contains a histogram, all dimensions of the plotted; 2209 // asymmetry function that occur in the previously plotted dataset are projected via partial integration.; 2210 // Otherwise no projections are performed,; 2211 //; 2212 // The asymmetry function can be multiplied with an optional scale factor. The default projection; 2213 // behaviour can be overridden by supplying an optional set of dependents to project.; 2214 ; 2215 // Sanity checks; 2216 if (plotSanityChecks(frame)) return frame ;; 2217 ; 2218 // ProjDataVars is either all projData observables, or the user indicated subset of it; 2219 RooArgSet projDataVars ;; 2220 if (o.projData) {; 2221 if (o.projDataSet) {; 2222 std::unique_ptr<RooArgSet> tmp{o.projData->get()->selectCommon(*o.projDataSet)};; 2223 projDataVars.add(*tmp) ;; 2224 } else {; 2225 projDataVars.add(*o.projData->get()) ;; 2226 }; 2227 }; 2228 ; 2229 // Must depend on asymCat; 2230 if (!dependsOn(asymCat)) {; 2231 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2232 << "") function doesn't depend on asymmetry category "" << asymCat.GetName() << std::endl ;; 2233 return frame ;; 2234 }; 2235 ; 2236 // asymCat must be a signCat; 2237 if (!asymCat.isSignType()) {; 2238 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2239 << "") asymmetry category must have 2 or 3 states with index values -1,0,1"" << std::endl ;; 2240 return frame ;; 2241 }; 2242 ; 2243 // Make list of variables to be projected; 2244 RooArgSet projectedVars ;; 2245 RooArgSet sliceSet ;; 2246 if (o.projSet) {; 2247 makeProjectionSet(frame->getPlotVar(),o.projSet,projectedVars,false) ;; 2248 ; 2249 // Print list of non-projected variables; 2250 if (frame->getNormVars()) {; 2251 RooArgSet sliceSetTmp;; 2252 getObservables(frame->getNormVars(), sliceSetTmp) ;; 2253 sliceSetTmp.remove(projectedVars,true,true) ;; 2254 sliceSetTmp.remove(*frame->getPlotVar(),true,true) ;; 2255 ; 2256 if (o.projData) {; 2257 std::unique_ptr<RooArg",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:98057,Integrability,depend,dependsOn,98057," ); 2207 //; 2208 // on frame. If frame contains a histogram, all dimensions of the plotted; 2209 // asymmetry function that occur in the previously plotted dataset are projected via partial integration.; 2210 // Otherwise no projections are performed,; 2211 //; 2212 // The asymmetry function can be multiplied with an optional scale factor. The default projection; 2213 // behaviour can be overridden by supplying an optional set of dependents to project.; 2214 ; 2215 // Sanity checks; 2216 if (plotSanityChecks(frame)) return frame ;; 2217 ; 2218 // ProjDataVars is either all projData observables, or the user indicated subset of it; 2219 RooArgSet projDataVars ;; 2220 if (o.projData) {; 2221 if (o.projDataSet) {; 2222 std::unique_ptr<RooArgSet> tmp{o.projData->get()->selectCommon(*o.projDataSet)};; 2223 projDataVars.add(*tmp) ;; 2224 } else {; 2225 projDataVars.add(*o.projData->get()) ;; 2226 }; 2227 }; 2228 ; 2229 // Must depend on asymCat; 2230 if (!dependsOn(asymCat)) {; 2231 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2232 << "") function doesn't depend on asymmetry category "" << asymCat.GetName() << std::endl ;; 2233 return frame ;; 2234 }; 2235 ; 2236 // asymCat must be a signCat; 2237 if (!asymCat.isSignType()) {; 2238 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2239 << "") asymmetry category must have 2 or 3 states with index values -1,0,1"" << std::endl ;; 2240 return frame ;; 2241 }; 2242 ; 2243 // Make list of variables to be projected; 2244 RooArgSet projectedVars ;; 2245 RooArgSet sliceSet ;; 2246 if (o.projSet) {; 2247 makeProjectionSet(frame->getPlotVar(),o.projSet,projectedVars,false) ;; 2248 ; 2249 // Print list of non-projected variables; 2250 if (frame->getNormVars()) {; 2251 RooArgSet sliceSetTmp;; 2252 getObservables(frame->getNormVars(), sliceSetTmp) ;; 2253 sliceSetTmp.remove(projectedVars,true,true) ;; 2254 sliceSetTmp.remove(*frame->getPlotVar(),true,true) ;; 2255 ; 2256 if (o.projData) {; 2257 std::unique_ptr<RooArg",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:98172,Integrability,depend,depend,98172," ); 2207 //; 2208 // on frame. If frame contains a histogram, all dimensions of the plotted; 2209 // asymmetry function that occur in the previously plotted dataset are projected via partial integration.; 2210 // Otherwise no projections are performed,; 2211 //; 2212 // The asymmetry function can be multiplied with an optional scale factor. The default projection; 2213 // behaviour can be overridden by supplying an optional set of dependents to project.; 2214 ; 2215 // Sanity checks; 2216 if (plotSanityChecks(frame)) return frame ;; 2217 ; 2218 // ProjDataVars is either all projData observables, or the user indicated subset of it; 2219 RooArgSet projDataVars ;; 2220 if (o.projData) {; 2221 if (o.projDataSet) {; 2222 std::unique_ptr<RooArgSet> tmp{o.projData->get()->selectCommon(*o.projDataSet)};; 2223 projDataVars.add(*tmp) ;; 2224 } else {; 2225 projDataVars.add(*o.projData->get()) ;; 2226 }; 2227 }; 2228 ; 2229 // Must depend on asymCat; 2230 if (!dependsOn(asymCat)) {; 2231 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2232 << "") function doesn't depend on asymmetry category "" << asymCat.GetName() << std::endl ;; 2233 return frame ;; 2234 }; 2235 ; 2236 // asymCat must be a signCat; 2237 if (!asymCat.isSignType()) {; 2238 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2239 << "") asymmetry category must have 2 or 3 states with index values -1,0,1"" << std::endl ;; 2240 return frame ;; 2241 }; 2242 ; 2243 // Make list of variables to be projected; 2244 RooArgSet projectedVars ;; 2245 RooArgSet sliceSet ;; 2246 if (o.projSet) {; 2247 makeProjectionSet(frame->getPlotVar(),o.projSet,projectedVars,false) ;; 2248 ; 2249 // Print list of non-projected variables; 2250 if (frame->getNormVars()) {; 2251 RooArgSet sliceSetTmp;; 2252 getObservables(frame->getNormVars(), sliceSetTmp) ;; 2253 sliceSetTmp.remove(projectedVars,true,true) ;; 2254 sliceSetTmp.remove(*frame->getPlotVar(),true,true) ;; 2255 ; 2256 if (o.projData) {; 2257 std::unique_ptr<RooArg",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:99620,Integrability,depend,dependens,99620," to be projected; 2244 RooArgSet projectedVars ;; 2245 RooArgSet sliceSet ;; 2246 if (o.projSet) {; 2247 makeProjectionSet(frame->getPlotVar(),o.projSet,projectedVars,false) ;; 2248 ; 2249 // Print list of non-projected variables; 2250 if (frame->getNormVars()) {; 2251 RooArgSet sliceSetTmp;; 2252 getObservables(frame->getNormVars(), sliceSetTmp) ;; 2253 sliceSetTmp.remove(projectedVars,true,true) ;; 2254 sliceSetTmp.remove(*frame->getPlotVar(),true,true) ;; 2255 ; 2256 if (o.projData) {; 2257 std::unique_ptr<RooArgSet> tmp{projDataVars.selectCommon(*o.projSet)};; 2258 sliceSetTmp.remove(*tmp,true,true) ;; 2259 }; 2260 ; 2261 if (!sliceSetTmp.empty()) {; 2262 coutI(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName() << "") plot on ""; 2263 << frame->getPlotVar()->GetName() << "" represents a slice in "" << sliceSetTmp << std::endl ;; 2264 }; 2265 sliceSet.add(sliceSetTmp) ;; 2266 }; 2267 } else {; 2268 makeProjectionSet(frame->getPlotVar(),frame->getNormVars(),projectedVars,true) ;; 2269 }; 2270 ; 2271 ; 2272 // Take out data-projected dependens from projectedVars; 2273 RooArgSet* projDataNeededVars = nullptr ;; 2274 if (o.projData) {; 2275 projDataNeededVars = projectedVars.selectCommon(projDataVars);; 2276 projectedVars.remove(projDataVars,true,true) ;; 2277 }; 2278 ; 2279 // Take out plotted asymmetry from projection; 2280 if (projectedVars.find(asymCat.GetName())) {; 2281 projectedVars.remove(*projectedVars.find(asymCat.GetName())) ;; 2282 }; 2283 ; 2284 // Clone the plot variable; 2285 RooAbsReal* realVar = static_cast<RooRealVar*>(frame->getPlotVar()) ;; 2286 RooRealVar* plotVar = static_cast<RooRealVar*>(realVar->Clone()) ;; 2287 ; 2288 // Inform user about projections; 2289 if (!projectedVars.empty()) {; 2290 coutI(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName() << "") plot on "" << plotVar->GetName(); 2291 << "" projects variables "" << projectedVars << std::endl ;; 2292 }; 2293 if (projDataNeededVars && !projDataNeededVars->empty()) {; 2294 coutI(Plotting) << """,MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:101699,Integrability,depend,dependents,101699,"edVars << std::endl ;; 2296 }; 2297 ; 2298 ; 2299 // Customize two copies of projection with fixed negative and positive asymmetry; 2300 std::unique_ptr<RooAbsCategoryLValue> asymPos{static_cast<RooAbsCategoryLValue*>(asymCat.Clone(""asym_pos""))};; 2301 std::unique_ptr<RooAbsCategoryLValue> asymNeg{static_cast<RooAbsCategoryLValue*>(asymCat.Clone(""asym_neg""))};; 2302 asymPos->setIndex(1) ;; 2303 asymNeg->setIndex(-1) ;; 2304 RooCustomizer custPos{*this,""pos""};; 2305 RooCustomizer custNeg{*this,""neg""};; 2306 //custPos->setOwning(true) ;; 2307 //custNeg->setOwning(true) ;; 2308 custPos.replaceArg(asymCat,*asymPos) ;; 2309 custNeg.replaceArg(asymCat,*asymNeg) ;; 2310 std::unique_ptr<RooAbsReal> funcPos{static_cast<RooAbsReal*>(custPos.build())};; 2311 std::unique_ptr<RooAbsReal> funcNeg{static_cast<RooAbsReal*>(custNeg.build())};; 2312 ; 2313 // Create projection integral; 2314 RooArgSet *posProjCompList;; 2315 RooArgSet *negProjCompList;; 2316 ; 2317 // Add projDataVars to normalized dependents of projection; 2318 // This is needed only for asymmetries (why?); 2319 RooArgSet depPos(*plotVar,*asymPos) ;; 2320 RooArgSet depNeg(*plotVar,*asymNeg) ;; 2321 depPos.add(projDataVars) ;; 2322 depNeg.add(projDataVars) ;; 2323 ; 2324 const RooAbsReal *posProj = funcPos->createPlotProjection(depPos, &projectedVars, posProjCompList, o.projectionRangeName) ;; 2325 const RooAbsReal *negProj = funcNeg->createPlotProjection(depNeg, &projectedVars, negProjCompList, o.projectionRangeName) ;; 2326 if (!posProj || !negProj) {; 2327 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName() << "") Unable to create projections, abort"" << std::endl ;; 2328 return frame ;; 2329 }; 2330 ; 2331 // Create a RooFormulaVar representing the asymmetry; 2332 TString asymName(GetName()) ;; 2333 asymName.Append(""_Asym["") ;; 2334 asymName.Append(asymCat.GetName()) ;; 2335 asymName.Append(""]"") ;; 2336 TString asymTitle(asymCat.GetName()) ;; 2337 asymTitle.Append("" Asymmetry of "") ;; 2338 asymTitle.Append(Get",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:109516,Integrability,depend,depend,109516,"rr}_{i,j} = \left(\sigma_{\theta_i} \sigma_{\theta_j}\right)^{-1} \cdot \mathrm{Cov}_{i,j} \f$ is the correlation matrix from the fit result.; 2471 ; 2472double RooAbsReal::getPropagatedError(const RooFitResult &fr, const RooArgSet &nset) const; 2473{; 2474 // Calling getParameters() might be costly, but necessary to get the right; 2475 // parameters in the RooAbsReal. The RooFitResult only stores snapshots.; 2476 RooArgSet allParamsInAbsReal;; 2477 getParameters(&nset, allParamsInAbsReal);; 2478 ; 2479 RooArgList paramList;; 2480 for(auto * rrvFitRes : static_range_cast<RooRealVar*>(fr.floatParsFinal())) {; 2481 ; 2482 auto rrvInAbsReal = static_cast<RooRealVar const*>(allParamsInAbsReal.find(*rrvFitRes));; 2483 ; 2484 // If this RooAbsReal is a RooRealVar in the fit result, we don't need to; 2485 // propagate anything and can just return the error in the fit result; 2486 if(rrvFitRes->namePtr() == namePtr()) return rrvFitRes->getError();; 2487 ; 2488 // Strip out parameters with zero error; 2489 if (rrvFitRes->getError() <= std::abs(rrvFitRes->getVal()) * std::numeric_limits<double>::epsilon()) continue;; 2490 ; 2491 // Ignore parameters in the fit result that this RooAbsReal doesn't depend on; 2492 if(!rrvInAbsReal) continue;; 2493 ; 2494 // Checking for float equality is a bad. We check if the values are; 2495 // negligibly far away from each other, relative to the uncertainty.; 2496 if(std::abs(rrvInAbsReal->getVal() - rrvFitRes->getVal()) > 0.01 * rrvFitRes->getError()) {; 2497 std::stringstream errMsg;; 2498 errMsg << ""RooAbsReal::getPropagatedError(): the parameters of the RooAbsReal don't have""; 2499 << "" the same values as in the fit result! The logic of getPropagatedError is broken in this case."";; 2500 ; 2501 throw std::runtime_error(errMsg.str());; 2502 }; 2503 ; 2504 paramList.add(*rrvInAbsReal);; 2505 }; 2506 ; 2507 std::vector<double> plusVar;; 2508 std::vector<double> minusVar;; 2509 plusVar.reserve(paramList.size());; 2510 minusVar.reserve(paramLis",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:125682,Integrability,depend,depend,125682,"nserted object to back to drawing stack if requested; 2846 if (pc.getInt(""moveToBack"") && frame->numItems()>1) {; 2847 frame->drawBefore(frame->getObject(0)->GetName(), frame->getCurve()->GetName());; 2848 }; 2849 ; 2850 ; 2851 return frame ;; 2852}; 2853 ; 2854 ; 2855 ; 2856 ; 2857////////////////////////////////////////////////////////////////////////////////; 2858/// Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations; 2859 ; 2860bool RooAbsReal::plotSanityChecks(RooPlot* frame) const; 2861{; 2862 // check that we are passed a valid plot frame to use; 2863 if(nullptr == frame) {; 2864 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: frame is null"" << std::endl;; 2865 return true;; 2866 }; 2867 ; 2868 // check that this frame knows what variable to plot; 2869 RooAbsReal* var = frame->getPlotVar() ;; 2870 if(!var) {; 2871 coutE(Plotting) << ClassName() << ""::"" << GetName(); 2872 << "":plotOn: frame does not specify a plot variable"" << std::endl;; 2873 return true;; 2874 }; 2875 ; 2876 // check that the plot variable is not derived; 2877 if(!dynamic_cast<RooAbsRealLValue*>(var)) {; 2878 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: cannot plot variable \""""; 2879 << var->GetName() << ""\"" of type "" << var->ClassName() << std::endl;; 2880 return true;; 2881 }; 2882 ; 2883 // check if we actually depend on the plot variable; 2884 if(!this->dependsOn(*var)) {; 2885 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: WARNING: variable is not an explicit dependent: ""; 2886 << var->GetName() << std::endl;; 2887 }; 2888 ; 2889 return false ;; 2890}; 2891 ; 2892 ; 2893 ; 2894 ; 2895////////////////////////////////////////////////////////////////////////////////; 2896/// Utility function for plotOn() that constructs the set of; 2897/// observables to project when plotting ourselves as function of; 2898/// 'plotVar'. 'allVars' is the list of variables that must be; 2899/// projecte",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:125726,Integrability,depend,dependsOn,125726,"nserted object to back to drawing stack if requested; 2846 if (pc.getInt(""moveToBack"") && frame->numItems()>1) {; 2847 frame->drawBefore(frame->getObject(0)->GetName(), frame->getCurve()->GetName());; 2848 }; 2849 ; 2850 ; 2851 return frame ;; 2852}; 2853 ; 2854 ; 2855 ; 2856 ; 2857////////////////////////////////////////////////////////////////////////////////; 2858/// Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations; 2859 ; 2860bool RooAbsReal::plotSanityChecks(RooPlot* frame) const; 2861{; 2862 // check that we are passed a valid plot frame to use; 2863 if(nullptr == frame) {; 2864 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: frame is null"" << std::endl;; 2865 return true;; 2866 }; 2867 ; 2868 // check that this frame knows what variable to plot; 2869 RooAbsReal* var = frame->getPlotVar() ;; 2870 if(!var) {; 2871 coutE(Plotting) << ClassName() << ""::"" << GetName(); 2872 << "":plotOn: frame does not specify a plot variable"" << std::endl;; 2873 return true;; 2874 }; 2875 ; 2876 // check that the plot variable is not derived; 2877 if(!dynamic_cast<RooAbsRealLValue*>(var)) {; 2878 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: cannot plot variable \""""; 2879 << var->GetName() << ""\"" of type "" << var->ClassName() << std::endl;; 2880 return true;; 2881 }; 2882 ; 2883 // check if we actually depend on the plot variable; 2884 if(!this->dependsOn(*var)) {; 2885 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: WARNING: variable is not an explicit dependent: ""; 2886 << var->GetName() << std::endl;; 2887 }; 2888 ; 2889 return false ;; 2890}; 2891 ; 2892 ; 2893 ; 2894 ; 2895////////////////////////////////////////////////////////////////////////////////; 2896/// Utility function for plotOn() that constructs the set of; 2897/// observables to project when plotting ourselves as function of; 2898/// 'plotVar'. 'allVars' is the list of variables that must be; 2899/// projecte",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:125853,Integrability,depend,dependent,125853,"nserted object to back to drawing stack if requested; 2846 if (pc.getInt(""moveToBack"") && frame->numItems()>1) {; 2847 frame->drawBefore(frame->getObject(0)->GetName(), frame->getCurve()->GetName());; 2848 }; 2849 ; 2850 ; 2851 return frame ;; 2852}; 2853 ; 2854 ; 2855 ; 2856 ; 2857////////////////////////////////////////////////////////////////////////////////; 2858/// Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations; 2859 ; 2860bool RooAbsReal::plotSanityChecks(RooPlot* frame) const; 2861{; 2862 // check that we are passed a valid plot frame to use; 2863 if(nullptr == frame) {; 2864 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: frame is null"" << std::endl;; 2865 return true;; 2866 }; 2867 ; 2868 // check that this frame knows what variable to plot; 2869 RooAbsReal* var = frame->getPlotVar() ;; 2870 if(!var) {; 2871 coutE(Plotting) << ClassName() << ""::"" << GetName(); 2872 << "":plotOn: frame does not specify a plot variable"" << std::endl;; 2873 return true;; 2874 }; 2875 ; 2876 // check that the plot variable is not derived; 2877 if(!dynamic_cast<RooAbsRealLValue*>(var)) {; 2878 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: cannot plot variable \""""; 2879 << var->GetName() << ""\"" of type "" << var->ClassName() << std::endl;; 2880 return true;; 2881 }; 2882 ; 2883 // check if we actually depend on the plot variable; 2884 if(!this->dependsOn(*var)) {; 2885 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: WARNING: variable is not an explicit dependent: ""; 2886 << var->GetName() << std::endl;; 2887 }; 2888 ; 2889 return false ;; 2890}; 2891 ; 2892 ; 2893 ; 2894 ; 2895////////////////////////////////////////////////////////////////////////////////; 2896/// Utility function for plotOn() that constructs the set of; 2897/// observables to project when plotting ourselves as function of; 2898/// 'plotVar'. 'allVars' is the list of variables that must be; 2899/// projecte",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:126327,Integrability,depend,depend,126327,"y a plot variable"" << std::endl;; 2873 return true;; 2874 }; 2875 ; 2876 // check that the plot variable is not derived; 2877 if(!dynamic_cast<RooAbsRealLValue*>(var)) {; 2878 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: cannot plot variable \""""; 2879 << var->GetName() << ""\"" of type "" << var->ClassName() << std::endl;; 2880 return true;; 2881 }; 2882 ; 2883 // check if we actually depend on the plot variable; 2884 if(!this->dependsOn(*var)) {; 2885 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: WARNING: variable is not an explicit dependent: ""; 2886 << var->GetName() << std::endl;; 2887 }; 2888 ; 2889 return false ;; 2890}; 2891 ; 2892 ; 2893 ; 2894 ; 2895////////////////////////////////////////////////////////////////////////////////; 2896/// Utility function for plotOn() that constructs the set of; 2897/// observables to project when plotting ourselves as function of; 2898/// 'plotVar'. 'allVars' is the list of variables that must be; 2899/// projected, but may contain variables that we do not depend on. If; 2900/// 'silent' is cleared, warnings about inconsistent input parameters; 2901/// will be printed.; 2902 ; 2903void RooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars,; 2904 RooArgSet& projectedVars, bool silent) const; 2905{; 2906 cxcoutD(Plotting) << ""RooAbsReal::makeProjectionSet("" << GetName() << "") plotVar = "" << plotVar->GetName(); 2907 << "" allVars = "" << (allVars?(*allVars):RooArgSet()) << std::endl ;; 2908 ; 2909 projectedVars.removeAll() ;; 2910 if (!allVars) return ;; 2911 ; 2912 // Start out with suggested list of variables; 2913 projectedVars.add(*allVars) ;; 2914 ; 2915 // Take out plot variable; 2916 RooAbsArg *found= projectedVars.find(plotVar->GetName());; 2917 if(found) {; 2918 projectedVars.remove(*found);; 2919 ; 2920 // Take out eventual servers of plotVar; 2921 std::unique_ptr<RooArgSet> plotServers{plotVar->getObservables(&projectedVars)};; 2922 for(RooAbsArg * ps : *p",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:127872,Integrability,depend,dependents,127872,"08 ; 2909 projectedVars.removeAll() ;; 2910 if (!allVars) return ;; 2911 ; 2912 // Start out with suggested list of variables; 2913 projectedVars.add(*allVars) ;; 2914 ; 2915 // Take out plot variable; 2916 RooAbsArg *found= projectedVars.find(plotVar->GetName());; 2917 if(found) {; 2918 projectedVars.remove(*found);; 2919 ; 2920 // Take out eventual servers of plotVar; 2921 std::unique_ptr<RooArgSet> plotServers{plotVar->getObservables(&projectedVars)};; 2922 for(RooAbsArg * ps : *plotServers) {; 2923 RooAbsArg* tmp = projectedVars.find(ps->GetName()) ;; 2924 if (tmp) {; 2925 cxcoutD(Plotting) << ""RooAbsReal::makeProjectionSet("" << GetName() << "") removing "" << tmp->GetName(); 2926 << "" from projection set because it a server of "" << plotVar->GetName() << std::endl ;; 2927 projectedVars.remove(*tmp) ;; 2928 }; 2929 }; 2930 ; 2931 if (!silent) {; 2932 coutW(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2933 << "") WARNING: cannot project out frame variable (""; 2934 << found->GetName() << ""), ignoring"" << std::endl ;; 2935 }; 2936 }; 2937 ; 2938 // Take out all non-dependents of function; 2939 for(RooAbsArg * arg : *allVars) {; 2940 if (!dependsOnValue(*arg)) {; 2941 projectedVars.remove(*arg,true) ;; 2942 ; 2943 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2944 << "") function doesn't depend on projection variable ""; 2945 << arg->GetName() << "", ignoring"" << std::endl ;; 2946 }; 2947 }; 2948}; 2949 ; 2950 ; 2951 ; 2952 ; 2953////////////////////////////////////////////////////////////////////////////////; 2954/// If true, the current pdf is a selected component (for use in plotting); 2955 ; 2956bool RooAbsReal::isSelectedComp() const; 2957{; 2958 return _selectComp || _globalSelectComp ;; 2959}; 2960 ; 2961 ; 2962 ; 2963////////////////////////////////////////////////////////////////////////////////; 2964/// Global switch controlling the activation of the selectComp() functionality; 2965 ; 2966void RooAbsReal::globalSelectComp(bool flag); 2967{; 2968 _g",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:127946,Integrability,depend,dependsOnValue,127946,"08 ; 2909 projectedVars.removeAll() ;; 2910 if (!allVars) return ;; 2911 ; 2912 // Start out with suggested list of variables; 2913 projectedVars.add(*allVars) ;; 2914 ; 2915 // Take out plot variable; 2916 RooAbsArg *found= projectedVars.find(plotVar->GetName());; 2917 if(found) {; 2918 projectedVars.remove(*found);; 2919 ; 2920 // Take out eventual servers of plotVar; 2921 std::unique_ptr<RooArgSet> plotServers{plotVar->getObservables(&projectedVars)};; 2922 for(RooAbsArg * ps : *plotServers) {; 2923 RooAbsArg* tmp = projectedVars.find(ps->GetName()) ;; 2924 if (tmp) {; 2925 cxcoutD(Plotting) << ""RooAbsReal::makeProjectionSet("" << GetName() << "") removing "" << tmp->GetName(); 2926 << "" from projection set because it a server of "" << plotVar->GetName() << std::endl ;; 2927 projectedVars.remove(*tmp) ;; 2928 }; 2929 }; 2930 ; 2931 if (!silent) {; 2932 coutW(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2933 << "") WARNING: cannot project out frame variable (""; 2934 << found->GetName() << ""), ignoring"" << std::endl ;; 2935 }; 2936 }; 2937 ; 2938 // Take out all non-dependents of function; 2939 for(RooAbsArg * arg : *allVars) {; 2940 if (!dependsOnValue(*arg)) {; 2941 projectedVars.remove(*arg,true) ;; 2942 ; 2943 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2944 << "") function doesn't depend on projection variable ""; 2945 << arg->GetName() << "", ignoring"" << std::endl ;; 2946 }; 2947 }; 2948}; 2949 ; 2950 ; 2951 ; 2952 ; 2953////////////////////////////////////////////////////////////////////////////////; 2954/// If true, the current pdf is a selected component (for use in plotting); 2955 ; 2956bool RooAbsReal::isSelectedComp() const; 2957{; 2958 return _selectComp || _globalSelectComp ;; 2959}; 2960 ; 2961 ; 2962 ; 2963////////////////////////////////////////////////////////////////////////////////; 2964/// Global switch controlling the activation of the selectComp() functionality; 2965 ; 2966void RooAbsReal::globalSelectComp(bool flag); 2967{; 2968 _g",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:128108,Integrability,depend,depend,128108,"erver of "" << plotVar->GetName() << std::endl ;; 2927 projectedVars.remove(*tmp) ;; 2928 }; 2929 }; 2930 ; 2931 if (!silent) {; 2932 coutW(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2933 << "") WARNING: cannot project out frame variable (""; 2934 << found->GetName() << ""), ignoring"" << std::endl ;; 2935 }; 2936 }; 2937 ; 2938 // Take out all non-dependents of function; 2939 for(RooAbsArg * arg : *allVars) {; 2940 if (!dependsOnValue(*arg)) {; 2941 projectedVars.remove(*arg,true) ;; 2942 ; 2943 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2944 << "") function doesn't depend on projection variable ""; 2945 << arg->GetName() << "", ignoring"" << std::endl ;; 2946 }; 2947 }; 2948}; 2949 ; 2950 ; 2951 ; 2952 ; 2953////////////////////////////////////////////////////////////////////////////////; 2954/// If true, the current pdf is a selected component (for use in plotting); 2955 ; 2956bool RooAbsReal::isSelectedComp() const; 2957{; 2958 return _selectComp || _globalSelectComp ;; 2959}; 2960 ; 2961 ; 2962 ; 2963////////////////////////////////////////////////////////////////////////////////; 2964/// Global switch controlling the activation of the selectComp() functionality; 2965 ; 2966void RooAbsReal::globalSelectComp(bool flag); 2967{; 2968 _globalSelectComp = flag ;; 2969}; 2970 ; 2971 ; 2972 ; 2973 ; 2974////////////////////////////////////////////////////////////////////////////////; 2975/// Create an interface adaptor f(vars) that binds us to the specified variables; 2976/// (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; 2977/// F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; 2978/// current values of x2 and x4. The caller takes ownership of the returned adaptor.; 2979 ; 2980RooFit::OwningPtr<RooAbsFunc> RooAbsReal::bindVars(const RooArgSet &vars, const RooArgSet* nset, bool clipInvalid) const; 2981{; 2982 auto binding = std::make_unique<RooRealBinding>(*this,vars,nset,clipInvalid);; 2983 if(!binding->isVal",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:128954,Integrability,interface,interface,128954,"erver of "" << plotVar->GetName() << std::endl ;; 2927 projectedVars.remove(*tmp) ;; 2928 }; 2929 }; 2930 ; 2931 if (!silent) {; 2932 coutW(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2933 << "") WARNING: cannot project out frame variable (""; 2934 << found->GetName() << ""), ignoring"" << std::endl ;; 2935 }; 2936 }; 2937 ; 2938 // Take out all non-dependents of function; 2939 for(RooAbsArg * arg : *allVars) {; 2940 if (!dependsOnValue(*arg)) {; 2941 projectedVars.remove(*arg,true) ;; 2942 ; 2943 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2944 << "") function doesn't depend on projection variable ""; 2945 << arg->GetName() << "", ignoring"" << std::endl ;; 2946 }; 2947 }; 2948}; 2949 ; 2950 ; 2951 ; 2952 ; 2953////////////////////////////////////////////////////////////////////////////////; 2954/// If true, the current pdf is a selected component (for use in plotting); 2955 ; 2956bool RooAbsReal::isSelectedComp() const; 2957{; 2958 return _selectComp || _globalSelectComp ;; 2959}; 2960 ; 2961 ; 2962 ; 2963////////////////////////////////////////////////////////////////////////////////; 2964/// Global switch controlling the activation of the selectComp() functionality; 2965 ; 2966void RooAbsReal::globalSelectComp(bool flag); 2967{; 2968 _globalSelectComp = flag ;; 2969}; 2970 ; 2971 ; 2972 ; 2973 ; 2974////////////////////////////////////////////////////////////////////////////////; 2975/// Create an interface adaptor f(vars) that binds us to the specified variables; 2976/// (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; 2977/// F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; 2978/// current values of x2 and x4. The caller takes ownership of the returned adaptor.; 2979 ; 2980RooFit::OwningPtr<RooAbsFunc> RooAbsReal::bindVars(const RooArgSet &vars, const RooArgSet* nset, bool clipInvalid) const; 2981{; 2982 auto binding = std::make_unique<RooRealBinding>(*this,vars,nset,clipInvalid);; 2983 if(!binding->isVal",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:141192,Integrability,integrat,integration,141192," and do not change matchedArgs.; 3240 ; 3241bool RooAbsReal::matchArgsByName(const RooArgSet &allArgs, RooArgSet &matchedArgs,; 3242 const TList &nameList) const; 3243{; 3244 RooArgSet matched(""matched"");; 3245 bool isMatched(true);; 3246 for(auto * name : static_range_cast<TObjString*>(nameList)) {; 3247 RooAbsArg *found= allArgs.find(name->String().Data());; 3248 if(found) {; 3249 matched.add(*found);; 3250 }; 3251 else {; 3252 isMatched= false;; 3253 break;; 3254 }; 3255 }; 3256 ; 3257 // nameList may not contain multiple entries with the same name; 3258 // that are both matched; 3259 if (isMatched && int(matched.size())!=nameList.GetSize()) {; 3260 isMatched = false ;; 3261 }; 3262 ; 3263 if(isMatched) matchedArgs.add(matched);; 3264 return isMatched;; 3265}; 3266 ; 3267 ; 3268 ; 3269////////////////////////////////////////////////////////////////////////////////; 3270/// Returns the default numeric integration configuration for all RooAbsReals; 3271 ; 3272RooNumIntConfig* RooAbsReal::defaultIntegratorConfig(); 3273{; 3274 return &RooNumIntConfig::defaultConfig() ;; 3275}; 3276 ; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3280/// If this object has no specialized configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:141501,Integrability,integrat,integrator,141501," and do not change matchedArgs.; 3240 ; 3241bool RooAbsReal::matchArgsByName(const RooArgSet &allArgs, RooArgSet &matchedArgs,; 3242 const TList &nameList) const; 3243{; 3244 RooArgSet matched(""matched"");; 3245 bool isMatched(true);; 3246 for(auto * name : static_range_cast<TObjString*>(nameList)) {; 3247 RooAbsArg *found= allArgs.find(name->String().Data());; 3248 if(found) {; 3249 matched.add(*found);; 3250 }; 3251 else {; 3252 isMatched= false;; 3253 break;; 3254 }; 3255 }; 3256 ; 3257 // nameList may not contain multiple entries with the same name; 3258 // that are both matched; 3259 if (isMatched && int(matched.size())!=nameList.GetSize()) {; 3260 isMatched = false ;; 3261 }; 3262 ; 3263 if(isMatched) matchedArgs.add(matched);; 3264 return isMatched;; 3265}; 3266 ; 3267 ; 3268 ; 3269////////////////////////////////////////////////////////////////////////////////; 3270/// Returns the default numeric integration configuration for all RooAbsReals; 3271 ; 3272RooNumIntConfig* RooAbsReal::defaultIntegratorConfig(); 3273{; 3274 return &RooNumIntConfig::defaultConfig() ;; 3275}; 3276 ; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3280/// If this object has no specialized configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:141897,Integrability,integrat,integrator,141897,"are both matched; 3259 if (isMatched && int(matched.size())!=nameList.GetSize()) {; 3260 isMatched = false ;; 3261 }; 3262 ; 3263 if(isMatched) matchedArgs.add(matched);; 3264 return isMatched;; 3265}; 3266 ; 3267 ; 3268 ; 3269////////////////////////////////////////////////////////////////////////////////; 3270/// Returns the default numeric integration configuration for all RooAbsReals; 3271 ; 3272RooNumIntConfig* RooAbsReal::defaultIntegratorConfig(); 3273{; 3274 return &RooNumIntConfig::defaultConfig() ;; 3275}; 3276 ; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3280/// If this object has no specialized configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all Ro",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:142107,Integrability,integrat,integrator,142107," for all RooAbsReals; 3271 ; 3272RooNumIntConfig* RooAbsReal::defaultIntegratorConfig(); 3273{; 3274 return &RooNumIntConfig::defaultConfig() ;; 3275}; 3276 ; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3280/// If this object has no specialized configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return th",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:142639,Integrability,integrat,integration,142639,"zed configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:143227,Integrability,integrat,integration,143227,"ialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:143799,Integrability,integrat,integrator,143799,"default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{; 3337 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(config);; 3338}; 3339 ; 3340 ; 3341 ; 3342////////////////////////////////////////////////////////////////////////////////; 3343/// Remove the specialized numeric integration configuration associated; 3344/// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:143843,Integrability,integrat,integration,143843,"default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{; 3337 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(config);; 3338}; 3339 ; 3340 ; 3341 ; 3342////////////////////////////////////////////////////////////////////////////////; 3343/// Remove the specialized numeric integration configuration associated; 3344/// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:144208,Integrability,integrat,integration,144208,"default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{; 3337 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(config);; 3338}; 3339 ; 3340 ; 3341 ; 3342////////////////////////////////////////////////////////////////////////////////; 3343/// Remove the specialized numeric integration configuration associated; 3344/// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:144649,Integrability,depend,depends,144649,"s default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{; 3337 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(config);; 3338}; 3339 ; 3340 ; 3341 ; 3342////////////////////////////////////////////////////////////////////////////////; 3343/// Remove the specialized numeric integration configuration associated; 3344/// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ; 3365 ; 3366 ; 3367////////////////////////////////////////////////////////////////////////////////; 3368/// Interface function to force use of a given normalization range; 3369/// to interpret function value. Needed for functions or p.d.f.s; 3370/// whose shape depends on the choice of normalization such as; 3371/// RooAddPdf; 3372 ; 3373void RooAbsReal::selectNormalizationRange(const char*, bool); 3374{; 3375}; 3376 ; 3377 ; 3378 ; 3379////////////////////////////////////////////////////////////////////////////////; 3380/// Advertise capability to determine maximum value of function for given set of; 3381/// observables. If no direct generator method is provided, this information; 3382/// will assist the accept/reject generator to operate more efficiently as; 3383/// it can skip the initial trial sampling phase to empirically find the function; 3384/// maximum; 3385 ; 3386Int_t RooAbsReal::getMaxVal(const RooArgSet& /*vars*/) const; 3387{; 3388 return 0 ;; 3389}; 3390 ; 3391 ; 3392 ; 3393/////",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:145079,Integrability,depend,depends,145079,"// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ; 3365 ; 3366 ; 3367////////////////////////////////////////////////////////////////////////////////; 3368/// Interface function to force use of a given normalization range; 3369/// to interpret function value. Needed for functions or p.d.f.s; 3370/// whose shape depends on the choice of normalization such as; 3371/// RooAddPdf; 3372 ; 3373void RooAbsReal::selectNormalizationRange(const char*, bool); 3374{; 3375}; 3376 ; 3377 ; 3378 ; 3379////////////////////////////////////////////////////////////////////////////////; 3380/// Advertise capability to determine maximum value of function for given set of; 3381/// observables. If no direct generator method is provided, this information; 3382/// will assist the accept/reject generator to operate more efficiently as; 3383/// it can skip the initial trial sampling phase to empirically find the function; 3384/// maximum; 3385 ; 3386Int_t RooAbsReal::getMaxVal(const RooArgSet& /*vars*/) const; 3387{; 3388 return 0 ;; 3389}; 3390 ; 3391 ; 3392 ; 3393////////////////////////////////////////////////////////////////////////////////; 3394/// Return maximum value for set of observables identified by code assigned; 3395/// in getMaxVal; 3396 ; 3397double RooAbsReal::maxVal(Int_t /*code*/) const; 3398{; 3399 assert(1) ;; 3400 return 0 ;; 3401}; 3402 ; 3403 ; 3404 ; 3405////////////////////////////////////////////////////////////////////////////////; 3406/// Interface to insert r",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:146271,Integrability,message,messages,146271,"///////////////////////; 3368/// Interface function to force use of a given normalization range; 3369/// to interpret function value. Needed for functions or p.d.f.s; 3370/// whose shape depends on the choice of normalization such as; 3371/// RooAddPdf; 3372 ; 3373void RooAbsReal::selectNormalizationRange(const char*, bool); 3374{; 3375}; 3376 ; 3377 ; 3378 ; 3379////////////////////////////////////////////////////////////////////////////////; 3380/// Advertise capability to determine maximum value of function for given set of; 3381/// observables. If no direct generator method is provided, this information; 3382/// will assist the accept/reject generator to operate more efficiently as; 3383/// it can skip the initial trial sampling phase to empirically find the function; 3384/// maximum; 3385 ; 3386Int_t RooAbsReal::getMaxVal(const RooArgSet& /*vars*/) const; 3387{; 3388 return 0 ;; 3389}; 3390 ; 3391 ; 3392 ; 3393////////////////////////////////////////////////////////////////////////////////; 3394/// Return maximum value for set of observables identified by code assigned; 3395/// in getMaxVal; 3396 ; 3397double RooAbsReal::maxVal(Int_t /*code*/) const; 3398{; 3399 assert(1) ;; 3400 return 0 ;; 3401}; 3402 ; 3403 ; 3404 ; 3405////////////////////////////////////////////////////////////////////////////////; 3406/// Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream.; 3407 ; 3408void RooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString); 3409{; 3410 if (evalErrorData().mode == Ignore) {; 3411 return ;; 3412 }; 3413 ; 3414 if (evalErrorData().mode == CountErrors) {; 3415 evalErrorData().count++ ;; 3416 return ;; 3417 }; 3418 ; 3419 static bool inLogEvalError = false ;; 3420 ; 3421 if (inLogEvalError) {; 3422 return ;; 3423 }; 3424 inLogEvalError = true ;; 3425 ; 3426 EvalError ee ;; 3427 ee.setMessage(message) ;; 3428 ; 3429 if (serverVa",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:146445,Integrability,message,message,146445,"81/// observables. If no direct generator method is provided, this information; 3382/// will assist the accept/reject generator to operate more efficiently as; 3383/// it can skip the initial trial sampling phase to empirically find the function; 3384/// maximum; 3385 ; 3386Int_t RooAbsReal::getMaxVal(const RooArgSet& /*vars*/) const; 3387{; 3388 return 0 ;; 3389}; 3390 ; 3391 ; 3392 ; 3393////////////////////////////////////////////////////////////////////////////////; 3394/// Return maximum value for set of observables identified by code assigned; 3395/// in getMaxVal; 3396 ; 3397double RooAbsReal::maxVal(Int_t /*code*/) const; 3398{; 3399 assert(1) ;; 3400 return 0 ;; 3401}; 3402 ; 3403 ; 3404 ; 3405////////////////////////////////////////////////////////////////////////////////; 3406/// Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream.; 3407 ; 3408void RooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString); 3409{; 3410 if (evalErrorData().mode == Ignore) {; 3411 return ;; 3412 }; 3413 ; 3414 if (evalErrorData().mode == CountErrors) {; 3415 evalErrorData().count++ ;; 3416 return ;; 3417 }; 3418 ; 3419 static bool inLogEvalError = false ;; 3420 ; 3421 if (inLogEvalError) {; 3422 return ;; 3423 }; 3424 inLogEvalError = true ;; 3425 ; 3426 EvalError ee ;; 3427 ee.setMessage(message) ;; 3428 ; 3429 if (serverValueString) {; 3430 ee.setServerValues(serverValueString) ;; 3431 }; 3432 ; 3433 if (evalErrorData().mode == PrintErrors) {; 3434 oocoutE(nullptr,Eval) << ""RooAbsReal::logEvalError("" << ""<STATIC>"" << "") evaluation error, "" << std::endl; 3435 << "" origin : "" << origName << std::endl; 3436 << "" message : "" << ee._msg << std::endl; 3437 << "" server values: "" << ee._srvval << std::endl ;; 3438 } else if (evalErrorData().mode == CollectErrors) {; 3439 auto &evalErrorList = evalErrorData().errorList[originator];; 3440 evalErrorList.first",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:146856,Integrability,message,message,146856,"//////////////////////; 3394/// Return maximum value for set of observables identified by code assigned; 3395/// in getMaxVal; 3396 ; 3397double RooAbsReal::maxVal(Int_t /*code*/) const; 3398{; 3399 assert(1) ;; 3400 return 0 ;; 3401}; 3402 ; 3403 ; 3404 ; 3405////////////////////////////////////////////////////////////////////////////////; 3406/// Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream.; 3407 ; 3408void RooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString); 3409{; 3410 if (evalErrorData().mode == Ignore) {; 3411 return ;; 3412 }; 3413 ; 3414 if (evalErrorData().mode == CountErrors) {; 3415 evalErrorData().count++ ;; 3416 return ;; 3417 }; 3418 ; 3419 static bool inLogEvalError = false ;; 3420 ; 3421 if (inLogEvalError) {; 3422 return ;; 3423 }; 3424 inLogEvalError = true ;; 3425 ; 3426 EvalError ee ;; 3427 ee.setMessage(message) ;; 3428 ; 3429 if (serverValueString) {; 3430 ee.setServerValues(serverValueString) ;; 3431 }; 3432 ; 3433 if (evalErrorData().mode == PrintErrors) {; 3434 oocoutE(nullptr,Eval) << ""RooAbsReal::logEvalError("" << ""<STATIC>"" << "") evaluation error, "" << std::endl; 3435 << "" origin : "" << origName << std::endl; 3436 << "" message : "" << ee._msg << std::endl; 3437 << "" server values: "" << ee._srvval << std::endl ;; 3438 } else if (evalErrorData().mode == CollectErrors) {; 3439 auto &evalErrorList = evalErrorData().errorList[originator];; 3440 evalErrorList.first = origName ;; 3441 evalErrorList.second.push_back(ee) ;; 3442 }; 3443 ; 3444 ; 3445 inLogEvalError = false ;; 3446}; 3447 ; 3448 ; 3449 ; 3450////////////////////////////////////////////////////////////////////////////////; 3451/// Log evaluation error message. Evaluation errors may be routed through a different; 3452/// protocol than generic RooFit warning message (which go straight through RooMsgService); 3453/// because evaluation errors can oc",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:147185,Integrability,message,message,147185,"eturn 0 ;; 3401}; 3402 ; 3403 ; 3404 ; 3405////////////////////////////////////////////////////////////////////////////////; 3406/// Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream.; 3407 ; 3408void RooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString); 3409{; 3410 if (evalErrorData().mode == Ignore) {; 3411 return ;; 3412 }; 3413 ; 3414 if (evalErrorData().mode == CountErrors) {; 3415 evalErrorData().count++ ;; 3416 return ;; 3417 }; 3418 ; 3419 static bool inLogEvalError = false ;; 3420 ; 3421 if (inLogEvalError) {; 3422 return ;; 3423 }; 3424 inLogEvalError = true ;; 3425 ; 3426 EvalError ee ;; 3427 ee.setMessage(message) ;; 3428 ; 3429 if (serverValueString) {; 3430 ee.setServerValues(serverValueString) ;; 3431 }; 3432 ; 3433 if (evalErrorData().mode == PrintErrors) {; 3434 oocoutE(nullptr,Eval) << ""RooAbsReal::logEvalError("" << ""<STATIC>"" << "") evaluation error, "" << std::endl; 3435 << "" origin : "" << origName << std::endl; 3436 << "" message : "" << ee._msg << std::endl; 3437 << "" server values: "" << ee._srvval << std::endl ;; 3438 } else if (evalErrorData().mode == CollectErrors) {; 3439 auto &evalErrorList = evalErrorData().errorList[originator];; 3440 evalErrorList.first = origName ;; 3441 evalErrorList.second.push_back(ee) ;; 3442 }; 3443 ; 3444 ; 3445 inLogEvalError = false ;; 3446}; 3447 ; 3448 ; 3449 ; 3450////////////////////////////////////////////////////////////////////////////////; 3451/// Log evaluation error message. Evaluation errors may be routed through a different; 3452/// protocol than generic RooFit warning message (which go straight through RooMsgService); 3453/// because evaluation errors can occur in very large numbers in the use of likelihood; 3454/// evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); 3455/// messages reported through this function are not printed but a",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:147682,Integrability,message,message,147682,"lErrorData().mode == CountErrors) {; 3415 evalErrorData().count++ ;; 3416 return ;; 3417 }; 3418 ; 3419 static bool inLogEvalError = false ;; 3420 ; 3421 if (inLogEvalError) {; 3422 return ;; 3423 }; 3424 inLogEvalError = true ;; 3425 ; 3426 EvalError ee ;; 3427 ee.setMessage(message) ;; 3428 ; 3429 if (serverValueString) {; 3430 ee.setServerValues(serverValueString) ;; 3431 }; 3432 ; 3433 if (evalErrorData().mode == PrintErrors) {; 3434 oocoutE(nullptr,Eval) << ""RooAbsReal::logEvalError("" << ""<STATIC>"" << "") evaluation error, "" << std::endl; 3435 << "" origin : "" << origName << std::endl; 3436 << "" message : "" << ee._msg << std::endl; 3437 << "" server values: "" << ee._srvval << std::endl ;; 3438 } else if (evalErrorData().mode == CollectErrors) {; 3439 auto &evalErrorList = evalErrorData().errorList[originator];; 3440 evalErrorList.first = origName ;; 3441 evalErrorList.second.push_back(ee) ;; 3442 }; 3443 ; 3444 ; 3445 inLogEvalError = false ;; 3446}; 3447 ; 3448 ; 3449 ; 3450////////////////////////////////////////////////////////////////////////////////; 3451/// Log evaluation error message. Evaluation errors may be routed through a different; 3452/// protocol than generic RooFit warning message (which go straight through RooMsgService); 3453/// because evaluation errors can occur in very large numbers in the use of likelihood; 3454/// evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); 3455/// messages reported through this function are not printed but all stored in a list,; 3456/// along with server values at the time of reporting. Error messages logged in this; 3457/// way can be printed in a structured way, eliminating duplicates and with the ability; 3458/// to truncate the list by printEvalErrors. This is the standard mode of error logging; 3459/// during MINUIT operations. If enableEvalErrorLogging() is false, all errors; 3460/// reported through this method are passed for immediate printing through RooMsgService.; 3461/",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:147716,Integrability,rout,routed,147716,"EvalError ee ;; 3427 ee.setMessage(message) ;; 3428 ; 3429 if (serverValueString) {; 3430 ee.setServerValues(serverValueString) ;; 3431 }; 3432 ; 3433 if (evalErrorData().mode == PrintErrors) {; 3434 oocoutE(nullptr,Eval) << ""RooAbsReal::logEvalError("" << ""<STATIC>"" << "") evaluation error, "" << std::endl; 3435 << "" origin : "" << origName << std::endl; 3436 << "" message : "" << ee._msg << std::endl; 3437 << "" server values: "" << ee._srvval << std::endl ;; 3438 } else if (evalErrorData().mode == CollectErrors) {; 3439 auto &evalErrorList = evalErrorData().errorList[originator];; 3440 evalErrorList.first = origName ;; 3441 evalErrorList.second.push_back(ee) ;; 3442 }; 3443 ; 3444 ; 3445 inLogEvalError = false ;; 3446}; 3447 ; 3448 ; 3449 ; 3450////////////////////////////////////////////////////////////////////////////////; 3451/// Log evaluation error message. Evaluation errors may be routed through a different; 3452/// protocol than generic RooFit warning message (which go straight through RooMsgService); 3453/// because evaluation errors can occur in very large numbers in the use of likelihood; 3454/// evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); 3455/// messages reported through this function are not printed but all stored in a list,; 3456/// along with server values at the time of reporting. Error messages logged in this; 3457/// way can be printed in a structured way, eliminating duplicates and with the ability; 3458/// to truncate the list by printEvalErrors. This is the standard mode of error logging; 3459/// during MINUIT operations. If enableEvalErrorLogging() is false, all errors; 3460/// reported through this method are passed for immediate printing through RooMsgService.; 3461/// A string with server names and values is constructed automatically for error logging; 3462/// purposes, unless a custom string with similar information is passed as argument.; 3463 ; 3464void RooAbsReal::logEvalError(const char* message, ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:147752,Integrability,protocol,protocol,147752,"EvalError ee ;; 3427 ee.setMessage(message) ;; 3428 ; 3429 if (serverValueString) {; 3430 ee.setServerValues(serverValueString) ;; 3431 }; 3432 ; 3433 if (evalErrorData().mode == PrintErrors) {; 3434 oocoutE(nullptr,Eval) << ""RooAbsReal::logEvalError("" << ""<STATIC>"" << "") evaluation error, "" << std::endl; 3435 << "" origin : "" << origName << std::endl; 3436 << "" message : "" << ee._msg << std::endl; 3437 << "" server values: "" << ee._srvval << std::endl ;; 3438 } else if (evalErrorData().mode == CollectErrors) {; 3439 auto &evalErrorList = evalErrorData().errorList[originator];; 3440 evalErrorList.first = origName ;; 3441 evalErrorList.second.push_back(ee) ;; 3442 }; 3443 ; 3444 ; 3445 inLogEvalError = false ;; 3446}; 3447 ; 3448 ; 3449 ; 3450////////////////////////////////////////////////////////////////////////////////; 3451/// Log evaluation error message. Evaluation errors may be routed through a different; 3452/// protocol than generic RooFit warning message (which go straight through RooMsgService); 3453/// because evaluation errors can occur in very large numbers in the use of likelihood; 3454/// evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); 3455/// messages reported through this function are not printed but all stored in a list,; 3456/// along with server values at the time of reporting. Error messages logged in this; 3457/// way can be printed in a structured way, eliminating duplicates and with the ability; 3458/// to truncate the list by printEvalErrors. This is the standard mode of error logging; 3459/// during MINUIT operations. If enableEvalErrorLogging() is false, all errors; 3460/// reported through this method are passed for immediate printing through RooMsgService.; 3461/// A string with server names and values is constructed automatically for error logging; 3462/// purposes, unless a custom string with similar information is passed as argument.; 3463 ; 3464void RooAbsReal::logEvalError(const char* message, ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:147789,Integrability,message,message,147789,"EvalError ee ;; 3427 ee.setMessage(message) ;; 3428 ; 3429 if (serverValueString) {; 3430 ee.setServerValues(serverValueString) ;; 3431 }; 3432 ; 3433 if (evalErrorData().mode == PrintErrors) {; 3434 oocoutE(nullptr,Eval) << ""RooAbsReal::logEvalError("" << ""<STATIC>"" << "") evaluation error, "" << std::endl; 3435 << "" origin : "" << origName << std::endl; 3436 << "" message : "" << ee._msg << std::endl; 3437 << "" server values: "" << ee._srvval << std::endl ;; 3438 } else if (evalErrorData().mode == CollectErrors) {; 3439 auto &evalErrorList = evalErrorData().errorList[originator];; 3440 evalErrorList.first = origName ;; 3441 evalErrorList.second.push_back(ee) ;; 3442 }; 3443 ; 3444 ; 3445 inLogEvalError = false ;; 3446}; 3447 ; 3448 ; 3449 ; 3450////////////////////////////////////////////////////////////////////////////////; 3451/// Log evaluation error message. Evaluation errors may be routed through a different; 3452/// protocol than generic RooFit warning message (which go straight through RooMsgService); 3453/// because evaluation errors can occur in very large numbers in the use of likelihood; 3454/// evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); 3455/// messages reported through this function are not printed but all stored in a list,; 3456/// along with server values at the time of reporting. Error messages logged in this; 3457/// way can be printed in a structured way, eliminating duplicates and with the ability; 3458/// to truncate the list by printEvalErrors. This is the standard mode of error logging; 3459/// during MINUIT operations. If enableEvalErrorLogging() is false, all errors; 3460/// reported through this method are passed for immediate printing through RooMsgService.; 3461/// A string with server names and values is constructed automatically for error logging; 3462/// purposes, unless a custom string with similar information is passed as argument.; 3463 ; 3464void RooAbsReal::logEvalError(const char* message, ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:148037,Integrability,message,messages,148037,"lError("" << ""<STATIC>"" << "") evaluation error, "" << std::endl; 3435 << "" origin : "" << origName << std::endl; 3436 << "" message : "" << ee._msg << std::endl; 3437 << "" server values: "" << ee._srvval << std::endl ;; 3438 } else if (evalErrorData().mode == CollectErrors) {; 3439 auto &evalErrorList = evalErrorData().errorList[originator];; 3440 evalErrorList.first = origName ;; 3441 evalErrorList.second.push_back(ee) ;; 3442 }; 3443 ; 3444 ; 3445 inLogEvalError = false ;; 3446}; 3447 ; 3448 ; 3449 ; 3450////////////////////////////////////////////////////////////////////////////////; 3451/// Log evaluation error message. Evaluation errors may be routed through a different; 3452/// protocol than generic RooFit warning message (which go straight through RooMsgService); 3453/// because evaluation errors can occur in very large numbers in the use of likelihood; 3454/// evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); 3455/// messages reported through this function are not printed but all stored in a list,; 3456/// along with server values at the time of reporting. Error messages logged in this; 3457/// way can be printed in a structured way, eliminating duplicates and with the ability; 3458/// to truncate the list by printEvalErrors. This is the standard mode of error logging; 3459/// during MINUIT operations. If enableEvalErrorLogging() is false, all errors; 3460/// reported through this method are passed for immediate printing through RooMsgService.; 3461/// A string with server names and values is constructed automatically for error logging; 3462/// purposes, unless a custom string with similar information is passed as argument.; 3463 ; 3464void RooAbsReal::logEvalError(const char* message, const char* serverValueString) const; 3465{; 3466 if (evalErrorData().mode == Ignore) {; 3467 return ;; 3468 }; 3469 ; 3470 if (evalErrorData().mode == CountErrors) {; 3471 evalErrorData().count++ ;; 3472 return ;; 3473 }; 3474 ; 3475 static bo",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:148185,Integrability,message,messages,148185,"< std::endl ;; 3438 } else if (evalErrorData().mode == CollectErrors) {; 3439 auto &evalErrorList = evalErrorData().errorList[originator];; 3440 evalErrorList.first = origName ;; 3441 evalErrorList.second.push_back(ee) ;; 3442 }; 3443 ; 3444 ; 3445 inLogEvalError = false ;; 3446}; 3447 ; 3448 ; 3449 ; 3450////////////////////////////////////////////////////////////////////////////////; 3451/// Log evaluation error message. Evaluation errors may be routed through a different; 3452/// protocol than generic RooFit warning message (which go straight through RooMsgService); 3453/// because evaluation errors can occur in very large numbers in the use of likelihood; 3454/// evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); 3455/// messages reported through this function are not printed but all stored in a list,; 3456/// along with server values at the time of reporting. Error messages logged in this; 3457/// way can be printed in a structured way, eliminating duplicates and with the ability; 3458/// to truncate the list by printEvalErrors. This is the standard mode of error logging; 3459/// during MINUIT operations. If enableEvalErrorLogging() is false, all errors; 3460/// reported through this method are passed for immediate printing through RooMsgService.; 3461/// A string with server names and values is constructed automatically for error logging; 3462/// purposes, unless a custom string with similar information is passed as argument.; 3463 ; 3464void RooAbsReal::logEvalError(const char* message, const char* serverValueString) const; 3465{; 3466 if (evalErrorData().mode == Ignore) {; 3467 return ;; 3468 }; 3469 ; 3470 if (evalErrorData().mode == CountErrors) {; 3471 evalErrorData().count++ ;; 3472 return ;; 3473 }; 3474 ; 3475 static bool inLogEvalError = false ;; 3476 ; 3477 if (inLogEvalError) {; 3478 return ;; 3479 }; 3480 inLogEvalError = true ;; 3481 ; 3482 EvalError ee ;; 3483 ee.setMessage(message) ;; 3484 ; 3485 if (serverVa",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:148812,Integrability,message,message,148812,"RooMsgService); 3453/// because evaluation errors can occur in very large numbers in the use of likelihood; 3454/// evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); 3455/// messages reported through this function are not printed but all stored in a list,; 3456/// along with server values at the time of reporting. Error messages logged in this; 3457/// way can be printed in a structured way, eliminating duplicates and with the ability; 3458/// to truncate the list by printEvalErrors. This is the standard mode of error logging; 3459/// during MINUIT operations. If enableEvalErrorLogging() is false, all errors; 3460/// reported through this method are passed for immediate printing through RooMsgService.; 3461/// A string with server names and values is constructed automatically for error logging; 3462/// purposes, unless a custom string with similar information is passed as argument.; 3463 ; 3464void RooAbsReal::logEvalError(const char* message, const char* serverValueString) const; 3465{; 3466 if (evalErrorData().mode == Ignore) {; 3467 return ;; 3468 }; 3469 ; 3470 if (evalErrorData().mode == CountErrors) {; 3471 evalErrorData().count++ ;; 3472 return ;; 3473 }; 3474 ; 3475 static bool inLogEvalError = false ;; 3476 ; 3477 if (inLogEvalError) {; 3478 return ;; 3479 }; 3480 inLogEvalError = true ;; 3481 ; 3482 EvalError ee ;; 3483 ee.setMessage(message) ;; 3484 ; 3485 if (serverValueString) {; 3486 ee.setServerValues(serverValueString) ;; 3487 } else {; 3488 std::string srvval ;; 3489 std::ostringstream oss ;; 3490 bool first(true) ;; 3491 for (Int_t i=0 ; i<numProxies() ; i++) {; 3492 RooAbsProxy* p = getProxy(i) ;; 3493 if (!p) continue ;; 3494 //if (p->name()[0]=='!') continue ;; 3495 if (first) {; 3496 first=false ;; 3497 } else {; 3498 oss << "", "" ;; 3499 }; 3500 p->print(oss,true) ;; 3501 }; 3502 ee.setServerValues(oss.str().c_str()) ;; 3503 }; 3504 ; 3505 std::ostringstream oss2 ;; 3506 printStream(oss2,kName|kClassName|k",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:149229,Integrability,message,message,149229," way, eliminating duplicates and with the ability; 3458/// to truncate the list by printEvalErrors. This is the standard mode of error logging; 3459/// during MINUIT operations. If enableEvalErrorLogging() is false, all errors; 3460/// reported through this method are passed for immediate printing through RooMsgService.; 3461/// A string with server names and values is constructed automatically for error logging; 3462/// purposes, unless a custom string with similar information is passed as argument.; 3463 ; 3464void RooAbsReal::logEvalError(const char* message, const char* serverValueString) const; 3465{; 3466 if (evalErrorData().mode == Ignore) {; 3467 return ;; 3468 }; 3469 ; 3470 if (evalErrorData().mode == CountErrors) {; 3471 evalErrorData().count++ ;; 3472 return ;; 3473 }; 3474 ; 3475 static bool inLogEvalError = false ;; 3476 ; 3477 if (inLogEvalError) {; 3478 return ;; 3479 }; 3480 inLogEvalError = true ;; 3481 ; 3482 EvalError ee ;; 3483 ee.setMessage(message) ;; 3484 ; 3485 if (serverValueString) {; 3486 ee.setServerValues(serverValueString) ;; 3487 } else {; 3488 std::string srvval ;; 3489 std::ostringstream oss ;; 3490 bool first(true) ;; 3491 for (Int_t i=0 ; i<numProxies() ; i++) {; 3492 RooAbsProxy* p = getProxy(i) ;; 3493 if (!p) continue ;; 3494 //if (p->name()[0]=='!') continue ;; 3495 if (first) {; 3496 first=false ;; 3497 } else {; 3498 oss << "", "" ;; 3499 }; 3500 p->print(oss,true) ;; 3501 }; 3502 ee.setServerValues(oss.str().c_str()) ;; 3503 }; 3504 ; 3505 std::ostringstream oss2 ;; 3506 printStream(oss2,kName|kClassName|kArgs,kInline) ;; 3507 ; 3508 if (evalErrorData().mode == PrintErrors) {; 3509 coutE(Eval) << ""RooAbsReal::logEvalError("" << GetName() << "") evaluation error, "" << std::endl; 3510 << "" origin : "" << oss2.str() << std::endl; 3511 << "" message : "" << ee._msg << std::endl; 3512 << "" server values: "" << ee._srvval << std::endl ;; 3513 } else if (evalErrorData().mode == CollectErrors) {; 3514 auto &evalErrorList = evalErrorData().e",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:150057,Integrability,message,message,150057,"3475 static bool inLogEvalError = false ;; 3476 ; 3477 if (inLogEvalError) {; 3478 return ;; 3479 }; 3480 inLogEvalError = true ;; 3481 ; 3482 EvalError ee ;; 3483 ee.setMessage(message) ;; 3484 ; 3485 if (serverValueString) {; 3486 ee.setServerValues(serverValueString) ;; 3487 } else {; 3488 std::string srvval ;; 3489 std::ostringstream oss ;; 3490 bool first(true) ;; 3491 for (Int_t i=0 ; i<numProxies() ; i++) {; 3492 RooAbsProxy* p = getProxy(i) ;; 3493 if (!p) continue ;; 3494 //if (p->name()[0]=='!') continue ;; 3495 if (first) {; 3496 first=false ;; 3497 } else {; 3498 oss << "", "" ;; 3499 }; 3500 p->print(oss,true) ;; 3501 }; 3502 ee.setServerValues(oss.str().c_str()) ;; 3503 }; 3504 ; 3505 std::ostringstream oss2 ;; 3506 printStream(oss2,kName|kClassName|kArgs,kInline) ;; 3507 ; 3508 if (evalErrorData().mode == PrintErrors) {; 3509 coutE(Eval) << ""RooAbsReal::logEvalError("" << GetName() << "") evaluation error, "" << std::endl; 3510 << "" origin : "" << oss2.str() << std::endl; 3511 << "" message : "" << ee._msg << std::endl; 3512 << "" server values: "" << ee._srvval << std::endl ;; 3513 } else if (evalErrorData().mode == CollectErrors) {; 3514 auto &evalErrorList = evalErrorData().errorList[this];; 3515 if (evalErrorList.second.size() >= 2048) {; 3516 // avoid overflowing the error list, so if there are very many, print; 3517 // the oldest one first, and pop it off the list; 3518 const EvalError& oee = evalErrorList.second.front();; 3519 // print to debug stream, since these would normally be suppressed, and; 3520 // we do not want to increase the error count in the message service...; 3521 ccoutD(Eval) << ""RooAbsReal::logEvalError("" << GetName(); 3522 << "") delayed evaluation error, "" << std::endl; 3523 << "" origin : "" << oss2.str() << std::endl; 3524 << "" message : "" << oee._msg << std::endl; 3525 << "" server values: "" << oee._srvval << std::endl ;; 3526 evalErrorList.second.pop_front();; 3527 }; 3528 evalErrorList.first = oss2.str() ;; 3529 evalErrorList.second.",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:150645,Integrability,message,message,150645,"f (first) {; 3496 first=false ;; 3497 } else {; 3498 oss << "", "" ;; 3499 }; 3500 p->print(oss,true) ;; 3501 }; 3502 ee.setServerValues(oss.str().c_str()) ;; 3503 }; 3504 ; 3505 std::ostringstream oss2 ;; 3506 printStream(oss2,kName|kClassName|kArgs,kInline) ;; 3507 ; 3508 if (evalErrorData().mode == PrintErrors) {; 3509 coutE(Eval) << ""RooAbsReal::logEvalError("" << GetName() << "") evaluation error, "" << std::endl; 3510 << "" origin : "" << oss2.str() << std::endl; 3511 << "" message : "" << ee._msg << std::endl; 3512 << "" server values: "" << ee._srvval << std::endl ;; 3513 } else if (evalErrorData().mode == CollectErrors) {; 3514 auto &evalErrorList = evalErrorData().errorList[this];; 3515 if (evalErrorList.second.size() >= 2048) {; 3516 // avoid overflowing the error list, so if there are very many, print; 3517 // the oldest one first, and pop it off the list; 3518 const EvalError& oee = evalErrorList.second.front();; 3519 // print to debug stream, since these would normally be suppressed, and; 3520 // we do not want to increase the error count in the message service...; 3521 ccoutD(Eval) << ""RooAbsReal::logEvalError("" << GetName(); 3522 << "") delayed evaluation error, "" << std::endl; 3523 << "" origin : "" << oss2.str() << std::endl; 3524 << "" message : "" << oee._msg << std::endl; 3525 << "" server values: "" << oee._srvval << std::endl ;; 3526 evalErrorList.second.pop_front();; 3527 }; 3528 evalErrorList.first = oss2.str() ;; 3529 evalErrorList.second.push_back(ee) ;; 3530 }; 3531 ; 3532 inLogEvalError = false ;; 3533 //coutE(Tracing) << ""RooAbsReal::logEvalError("" << GetName() << "") message = "" << message << std::endl ;; 3534}; 3535 ; 3536 ; 3537 ; 3538 ; 3539////////////////////////////////////////////////////////////////////////////////; 3540/// Clear the stack of evaluation error messages; 3541 ; 3542void RooAbsReal::clearEvalErrorLog(); 3543{; 3544 if (evalErrorData().mode == PrintErrors) {; 3545 return ;; 3546 } else if (evalErrorData().mode == CollectErrors) {; 35",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:150840,Integrability,message,message,150840,"ne) ;; 3507 ; 3508 if (evalErrorData().mode == PrintErrors) {; 3509 coutE(Eval) << ""RooAbsReal::logEvalError("" << GetName() << "") evaluation error, "" << std::endl; 3510 << "" origin : "" << oss2.str() << std::endl; 3511 << "" message : "" << ee._msg << std::endl; 3512 << "" server values: "" << ee._srvval << std::endl ;; 3513 } else if (evalErrorData().mode == CollectErrors) {; 3514 auto &evalErrorList = evalErrorData().errorList[this];; 3515 if (evalErrorList.second.size() >= 2048) {; 3516 // avoid overflowing the error list, so if there are very many, print; 3517 // the oldest one first, and pop it off the list; 3518 const EvalError& oee = evalErrorList.second.front();; 3519 // print to debug stream, since these would normally be suppressed, and; 3520 // we do not want to increase the error count in the message service...; 3521 ccoutD(Eval) << ""RooAbsReal::logEvalError("" << GetName(); 3522 << "") delayed evaluation error, "" << std::endl; 3523 << "" origin : "" << oss2.str() << std::endl; 3524 << "" message : "" << oee._msg << std::endl; 3525 << "" server values: "" << oee._srvval << std::endl ;; 3526 evalErrorList.second.pop_front();; 3527 }; 3528 evalErrorList.first = oss2.str() ;; 3529 evalErrorList.second.push_back(ee) ;; 3530 }; 3531 ; 3532 inLogEvalError = false ;; 3533 //coutE(Tracing) << ""RooAbsReal::logEvalError("" << GetName() << "") message = "" << message << std::endl ;; 3534}; 3535 ; 3536 ; 3537 ; 3538 ; 3539////////////////////////////////////////////////////////////////////////////////; 3540/// Clear the stack of evaluation error messages; 3541 ; 3542void RooAbsReal::clearEvalErrorLog(); 3543{; 3544 if (evalErrorData().mode == PrintErrors) {; 3545 return ;; 3546 } else if (evalErrorData().mode == CollectErrors) {; 3547 evalErrorData().errorList.clear() ;; 3548 } else {; 3549 evalErrorData().count = 0 ;; 3550 }; 3551}; 3552 ; 3553 ; 3554////////////////////////////////////////////////////////////////////////////////; 3555/// Retrieve bin boundaries if this distributio",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:151186,Integrability,message,message,151186,"];; 3515 if (evalErrorList.second.size() >= 2048) {; 3516 // avoid overflowing the error list, so if there are very many, print; 3517 // the oldest one first, and pop it off the list; 3518 const EvalError& oee = evalErrorList.second.front();; 3519 // print to debug stream, since these would normally be suppressed, and; 3520 // we do not want to increase the error count in the message service...; 3521 ccoutD(Eval) << ""RooAbsReal::logEvalError("" << GetName(); 3522 << "") delayed evaluation error, "" << std::endl; 3523 << "" origin : "" << oss2.str() << std::endl; 3524 << "" message : "" << oee._msg << std::endl; 3525 << "" server values: "" << oee._srvval << std::endl ;; 3526 evalErrorList.second.pop_front();; 3527 }; 3528 evalErrorList.first = oss2.str() ;; 3529 evalErrorList.second.push_back(ee) ;; 3530 }; 3531 ; 3532 inLogEvalError = false ;; 3533 //coutE(Tracing) << ""RooAbsReal::logEvalError("" << GetName() << "") message = "" << message << std::endl ;; 3534}; 3535 ; 3536 ; 3537 ; 3538 ; 3539////////////////////////////////////////////////////////////////////////////////; 3540/// Clear the stack of evaluation error messages; 3541 ; 3542void RooAbsReal::clearEvalErrorLog(); 3543{; 3544 if (evalErrorData().mode == PrintErrors) {; 3545 return ;; 3546 } else if (evalErrorData().mode == CollectErrors) {; 3547 evalErrorData().errorList.clear() ;; 3548 } else {; 3549 evalErrorData().count = 0 ;; 3550 }; 3551}; 3552 ; 3553 ; 3554////////////////////////////////////////////////////////////////////////////////; 3555/// Retrieve bin boundaries if this distribution is binned in `obs`.; 3556/// \param[in] obs Observable to retrieve boundaries for.; 3557/// \param[in] xlo Beginning of range.; 3558/// \param[in] xhi End of range.; 3559/// \return The caller owns the returned std::list.; 3560std::list<double>* RooAbsReal::binBoundaries(RooAbsRealLValue& /*obs*/, double /*xlo*/, double /*xhi*/) const {; 3561 return nullptr;; 3562}; 3563 ; 3564 ; 3565//////////////////////////////////////////",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:151201,Integrability,message,message,151201,"];; 3515 if (evalErrorList.second.size() >= 2048) {; 3516 // avoid overflowing the error list, so if there are very many, print; 3517 // the oldest one first, and pop it off the list; 3518 const EvalError& oee = evalErrorList.second.front();; 3519 // print to debug stream, since these would normally be suppressed, and; 3520 // we do not want to increase the error count in the message service...; 3521 ccoutD(Eval) << ""RooAbsReal::logEvalError("" << GetName(); 3522 << "") delayed evaluation error, "" << std::endl; 3523 << "" origin : "" << oss2.str() << std::endl; 3524 << "" message : "" << oee._msg << std::endl; 3525 << "" server values: "" << oee._srvval << std::endl ;; 3526 evalErrorList.second.pop_front();; 3527 }; 3528 evalErrorList.first = oss2.str() ;; 3529 evalErrorList.second.push_back(ee) ;; 3530 }; 3531 ; 3532 inLogEvalError = false ;; 3533 //coutE(Tracing) << ""RooAbsReal::logEvalError("" << GetName() << "") message = "" << message << std::endl ;; 3534}; 3535 ; 3536 ; 3537 ; 3538 ; 3539////////////////////////////////////////////////////////////////////////////////; 3540/// Clear the stack of evaluation error messages; 3541 ; 3542void RooAbsReal::clearEvalErrorLog(); 3543{; 3544 if (evalErrorData().mode == PrintErrors) {; 3545 return ;; 3546 } else if (evalErrorData().mode == CollectErrors) {; 3547 evalErrorData().errorList.clear() ;; 3548 } else {; 3549 evalErrorData().count = 0 ;; 3550 }; 3551}; 3552 ; 3553 ; 3554////////////////////////////////////////////////////////////////////////////////; 3555/// Retrieve bin boundaries if this distribution is binned in `obs`.; 3556/// \param[in] obs Observable to retrieve boundaries for.; 3557/// \param[in] xlo Beginning of range.; 3558/// \param[in] xhi End of range.; 3559/// \return The caller owns the returned std::list.; 3560std::list<double>* RooAbsReal::binBoundaries(RooAbsRealLValue& /*obs*/, double /*xlo*/, double /*xhi*/) const {; 3561 return nullptr;; 3562}; 3563 ; 3564 ; 3565//////////////////////////////////////////",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:151390,Integrability,message,messages,151390,"];; 3515 if (evalErrorList.second.size() >= 2048) {; 3516 // avoid overflowing the error list, so if there are very many, print; 3517 // the oldest one first, and pop it off the list; 3518 const EvalError& oee = evalErrorList.second.front();; 3519 // print to debug stream, since these would normally be suppressed, and; 3520 // we do not want to increase the error count in the message service...; 3521 ccoutD(Eval) << ""RooAbsReal::logEvalError("" << GetName(); 3522 << "") delayed evaluation error, "" << std::endl; 3523 << "" origin : "" << oss2.str() << std::endl; 3524 << "" message : "" << oee._msg << std::endl; 3525 << "" server values: "" << oee._srvval << std::endl ;; 3526 evalErrorList.second.pop_front();; 3527 }; 3528 evalErrorList.first = oss2.str() ;; 3529 evalErrorList.second.push_back(ee) ;; 3530 }; 3531 ; 3532 inLogEvalError = false ;; 3533 //coutE(Tracing) << ""RooAbsReal::logEvalError("" << GetName() << "") message = "" << message << std::endl ;; 3534}; 3535 ; 3536 ; 3537 ; 3538 ; 3539////////////////////////////////////////////////////////////////////////////////; 3540/// Clear the stack of evaluation error messages; 3541 ; 3542void RooAbsReal::clearEvalErrorLog(); 3543{; 3544 if (evalErrorData().mode == PrintErrors) {; 3545 return ;; 3546 } else if (evalErrorData().mode == CollectErrors) {; 3547 evalErrorData().errorList.clear() ;; 3548 } else {; 3549 evalErrorData().count = 0 ;; 3550 }; 3551}; 3552 ; 3553 ; 3554////////////////////////////////////////////////////////////////////////////////; 3555/// Retrieve bin boundaries if this distribution is binned in `obs`.; 3556/// \param[in] obs Observable to retrieve boundaries for.; 3557/// \param[in] xlo Beginning of range.; 3558/// \param[in] xhi End of range.; 3559/// \return The caller owns the returned std::list.; 3560std::list<double>* RooAbsReal::binBoundaries(RooAbsRealLValue& /*obs*/, double /*xlo*/, double /*xhi*/) const {; 3561 return nullptr;; 3562}; 3563 ; 3564 ; 3565//////////////////////////////////////////",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:153152,Integrability,message,messages,153152,"ouble /*xlo*/, double /*xhi*/) const {; 3561 return nullptr;; 3562}; 3563 ; 3564 ; 3565////////////////////////////////////////////////////////////////////////////////; 3566/// Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable `obs`.; 3567/// \param[in] obs Observable to retrieve sampling hint for.; 3568/// \param[in] xlo Beginning of range.; 3569/// \param[in] xhi End of range.; 3570/// \return The caller owns the returned std::list.; 3571std::list<double>* RooAbsReal::plotSamplingHint(RooAbsRealLValue& /*obs*/, double /*xlo*/, double /*xhi*/) const {; 3572 return nullptr;; 3573}; 3574 ; 3575////////////////////////////////////////////////////////////////////////////////; 3576/// Print all outstanding logged evaluation error on the given ostream. If maxPerNode; 3577/// is zero, only the number of errors for each source (object with unique name) is listed.; 3578/// If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; 3579/// per source of errors. A truncation message is shown if there were more errors logged; 3580/// than shown.; 3581 ; 3582void RooAbsReal::printEvalErrors(std::ostream &os, Int_t maxPerNode); 3583{; 3584 if (evalErrorData().mode == CountErrors) {; 3585 os << evalErrorData().count << "" errors counted"" << std::endl;; 3586 }; 3587 ; 3588 if (maxPerNode < 0); 3589 return;; 3590 ; 3591 for (auto const &item : evalErrorData().errorList) {; 3592 if (maxPerNode == 0) {; 3593 ; 3594 // Only print node name with total number of errors; 3595 os << item.second.first;; 3596 // item.first->printStream(os,kName|kClassName|kArgs,kInline) ;; 3597 os << "" has "" << item.second.second.size() << "" errors"" << std::endl;; 3598 ; 3599 } else {; 3600 ; 3601 // Print node name and details of 'maxPerNode' errors; 3602 os << item.second.first << std::endl;; 3603 // item.first->printStream(os,kName|kClassName|kArgs,kSingleLine) ;; 3604 ; 3605 Int_t i(0);; 3606 for (auto const ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:153215,Integrability,message,message,153215,"/////////////////////////////////////////////////////////////; 3566/// Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable `obs`.; 3567/// \param[in] obs Observable to retrieve sampling hint for.; 3568/// \param[in] xlo Beginning of range.; 3569/// \param[in] xhi End of range.; 3570/// \return The caller owns the returned std::list.; 3571std::list<double>* RooAbsReal::plotSamplingHint(RooAbsRealLValue& /*obs*/, double /*xlo*/, double /*xhi*/) const {; 3572 return nullptr;; 3573}; 3574 ; 3575////////////////////////////////////////////////////////////////////////////////; 3576/// Print all outstanding logged evaluation error on the given ostream. If maxPerNode; 3577/// is zero, only the number of errors for each source (object with unique name) is listed.; 3578/// If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; 3579/// per source of errors. A truncation message is shown if there were more errors logged; 3580/// than shown.; 3581 ; 3582void RooAbsReal::printEvalErrors(std::ostream &os, Int_t maxPerNode); 3583{; 3584 if (evalErrorData().mode == CountErrors) {; 3585 os << evalErrorData().count << "" errors counted"" << std::endl;; 3586 }; 3587 ; 3588 if (maxPerNode < 0); 3589 return;; 3590 ; 3591 for (auto const &item : evalErrorData().errorList) {; 3592 if (maxPerNode == 0) {; 3593 ; 3594 // Only print node name with total number of errors; 3595 os << item.second.first;; 3596 // item.first->printStream(os,kName|kClassName|kArgs,kInline) ;; 3597 os << "" has "" << item.second.second.size() << "" errors"" << std::endl;; 3598 ; 3599 } else {; 3600 ; 3601 // Print node name and details of 'maxPerNode' errors; 3602 os << item.second.first << std::endl;; 3603 // item.first->printStream(os,kName|kClassName|kArgs,kSingleLine) ;; 3604 ; 3605 Int_t i(0);; 3606 for (auto const &item2 : item.second.second) {; 3607 os << "" "" << item2._msg << "" @ "" << item2._srvval << std::endl;; 360",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:154345,Integrability,message,messages,154345,"<< std::endl;; 3586 }; 3587 ; 3588 if (maxPerNode < 0); 3589 return;; 3590 ; 3591 for (auto const &item : evalErrorData().errorList) {; 3592 if (maxPerNode == 0) {; 3593 ; 3594 // Only print node name with total number of errors; 3595 os << item.second.first;; 3596 // item.first->printStream(os,kName|kClassName|kArgs,kInline) ;; 3597 os << "" has "" << item.second.second.size() << "" errors"" << std::endl;; 3598 ; 3599 } else {; 3600 ; 3601 // Print node name and details of 'maxPerNode' errors; 3602 os << item.second.first << std::endl;; 3603 // item.first->printStream(os,kName|kClassName|kArgs,kSingleLine) ;; 3604 ; 3605 Int_t i(0);; 3606 for (auto const &item2 : item.second.second) {; 3607 os << "" "" << item2._msg << "" @ "" << item2._srvval << std::endl;; 3608 if (i > maxPerNode) {; 3609 os << "" ... (remaining "" << item.second.second.size() - maxPerNode << "" messages suppressed)""; 3610 << std::endl;; 3611 break;; 3612 }; 3613 i++;; 3614 }; 3615 }; 3616 }; 3617}; 3618 ; 3619 ; 3620 ; 3621////////////////////////////////////////////////////////////////////////////////; 3622/// Return the number of logged evaluation errors since the last clearing.; 3623 ; 3624Int_t RooAbsReal::numEvalErrors(); 3625{; 3626 auto &evalErrors = evalErrorData();; 3627 if (evalErrors.mode == CountErrors) {; 3628 return evalErrors.count;; 3629 }; 3630 ; 3631 Int_t ntot(0);; 3632 for (auto const &elem : evalErrors.errorList) {; 3633 ntot += elem.second.second.size();; 3634 }; 3635 return ntot;; 3636}; 3637 ; 3638 ; 3639 ; 3640////////////////////////////////////////////////////////////////////////////////; 3641/// Fix the interpretation of the coefficient of any RooAddPdf component in; 3642/// the expression tree headed by this object to the given set of observables.; 3643///; 3644/// If the force flag is false, the normalization choice is only fixed for those; 3645/// RooAddPdf components that have the default 'automatic' interpretation of; 3646/// coefficients (i.e. the interpretation is defined",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:158650,Integrability,integrat,integration,158650," RooArgSet& obs, RooArgSet& orderedObs) const; 3695{; 3696 // Dummy implementation, do nothing; 3697 orderedObs.removeAll() ;; 3698 orderedObs.add(obs) ;; 3699}; 3700 ; 3701 ; 3702 ; 3703////////////////////////////////////////////////////////////////////////////////; 3704/// Calls createRunningIntegral(const RooArgSet&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&); 3705 ; 3706RooFit::OwningPtr<RooAbsReal> RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset); 3707{; 3708 return createRunningIntegral(iset,RooFit::SupNormSet(nset)) ;; 3709}; 3710 ; 3711 ; 3712 ; 3713////////////////////////////////////////////////////////////////////////////////; 3714/// Create an object that represents the running integral of the function over one or more observables listed in iset, i.e.; 3715/// \f[; 3716/// \int_{x_\mathrm{lo}}^x f(x') \, \mathrm{d}x'; 3717/// \f]; 3718///; 3719/// The actual integration calculation is only performed when the return object is evaluated. The name; 3720/// of the integral object is automatically constructed from the name of the input function, the variables; 3721/// it integrates and the range integrates over. The default strategy to calculate the running integrals is; 3722///; 3723/// - If the integrand (this object) supports analytical integration, construct an integral object; 3724/// that calculate the running integrals value by calculating the analytical integral each; 3725/// time the running integral object is evaluated; 3726///; 3727/// - If the integrand (this object) requires numeric integration to construct the running integral; 3728/// create an object of class RooNumRunningInt which first samples the entire function and integrates; 3729/// the sampled function numerically. This method has superior performance as there is no need to; 3730/// perform a full (numeric) integration for each evaluation of the running in",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:158862,Integrability,integrat,integrates,158862,"; 3703////////////////////////////////////////////////////////////////////////////////; 3704/// Calls createRunningIntegral(const RooArgSet&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&); 3705 ; 3706RooFit::OwningPtr<RooAbsReal> RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset); 3707{; 3708 return createRunningIntegral(iset,RooFit::SupNormSet(nset)) ;; 3709}; 3710 ; 3711 ; 3712 ; 3713////////////////////////////////////////////////////////////////////////////////; 3714/// Create an object that represents the running integral of the function over one or more observables listed in iset, i.e.; 3715/// \f[; 3716/// \int_{x_\mathrm{lo}}^x f(x') \, \mathrm{d}x'; 3717/// \f]; 3718///; 3719/// The actual integration calculation is only performed when the return object is evaluated. The name; 3720/// of the integral object is automatically constructed from the name of the input function, the variables; 3721/// it integrates and the range integrates over. The default strategy to calculate the running integrals is; 3722///; 3723/// - If the integrand (this object) supports analytical integration, construct an integral object; 3724/// that calculate the running integrals value by calculating the analytical integral each; 3725/// time the running integral object is evaluated; 3726///; 3727/// - If the integrand (this object) requires numeric integration to construct the running integral; 3728/// create an object of class RooNumRunningInt which first samples the entire function and integrates; 3729/// the sampled function numerically. This method has superior performance as there is no need to; 3730/// perform a full (numeric) integration for each evaluation of the running integral object, but; 3731/// only when one of its parameters has changed.; 3732///; 3733/// The choice of strategy can be changed with the ScanAll() argument, which forces the use of ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:158887,Integrability,integrat,integrates,158887,"; 3703////////////////////////////////////////////////////////////////////////////////; 3704/// Calls createRunningIntegral(const RooArgSet&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&); 3705 ; 3706RooFit::OwningPtr<RooAbsReal> RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset); 3707{; 3708 return createRunningIntegral(iset,RooFit::SupNormSet(nset)) ;; 3709}; 3710 ; 3711 ; 3712 ; 3713////////////////////////////////////////////////////////////////////////////////; 3714/// Create an object that represents the running integral of the function over one or more observables listed in iset, i.e.; 3715/// \f[; 3716/// \int_{x_\mathrm{lo}}^x f(x') \, \mathrm{d}x'; 3717/// \f]; 3718///; 3719/// The actual integration calculation is only performed when the return object is evaluated. The name; 3720/// of the integral object is automatically constructed from the name of the input function, the variables; 3721/// it integrates and the range integrates over. The default strategy to calculate the running integrals is; 3722///; 3723/// - If the integrand (this object) supports analytical integration, construct an integral object; 3724/// that calculate the running integrals value by calculating the analytical integral each; 3725/// time the running integral object is evaluated; 3726///; 3727/// - If the integrand (this object) requires numeric integration to construct the running integral; 3728/// create an object of class RooNumRunningInt which first samples the entire function and integrates; 3729/// the sampled function numerically. This method has superior performance as there is no need to; 3730/// perform a full (numeric) integration for each evaluation of the running integral object, but; 3731/// only when one of its parameters has changed.; 3732///; 3733/// The choice of strategy can be changed with the ScanAll() argument, which forces the use of ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:159034,Integrability,integrat,integration,159034,"et, const RooArgSet& nset); 3707{; 3708 return createRunningIntegral(iset,RooFit::SupNormSet(nset)) ;; 3709}; 3710 ; 3711 ; 3712 ; 3713////////////////////////////////////////////////////////////////////////////////; 3714/// Create an object that represents the running integral of the function over one or more observables listed in iset, i.e.; 3715/// \f[; 3716/// \int_{x_\mathrm{lo}}^x f(x') \, \mathrm{d}x'; 3717/// \f]; 3718///; 3719/// The actual integration calculation is only performed when the return object is evaluated. The name; 3720/// of the integral object is automatically constructed from the name of the input function, the variables; 3721/// it integrates and the range integrates over. The default strategy to calculate the running integrals is; 3722///; 3723/// - If the integrand (this object) supports analytical integration, construct an integral object; 3724/// that calculate the running integrals value by calculating the analytical integral each; 3725/// time the running integral object is evaluated; 3726///; 3727/// - If the integrand (this object) requires numeric integration to construct the running integral; 3728/// create an object of class RooNumRunningInt which first samples the entire function and integrates; 3729/// the sampled function numerically. This method has superior performance as there is no need to; 3730/// perform a full (numeric) integration for each evaluation of the running integral object, but; 3731/// only when one of its parameters has changed.; 3732///; 3733/// The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; 3734/// scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); 3735/// argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; 3736/// granularity for the scanning technique can be controlled with the ScanParameters technique; 3737/// which allows to specify the number of samples to be taken, a",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:159295,Integrability,integrat,integration,159295,"et, const RooArgSet& nset); 3707{; 3708 return createRunningIntegral(iset,RooFit::SupNormSet(nset)) ;; 3709}; 3710 ; 3711 ; 3712 ; 3713////////////////////////////////////////////////////////////////////////////////; 3714/// Create an object that represents the running integral of the function over one or more observables listed in iset, i.e.; 3715/// \f[; 3716/// \int_{x_\mathrm{lo}}^x f(x') \, \mathrm{d}x'; 3717/// \f]; 3718///; 3719/// The actual integration calculation is only performed when the return object is evaluated. The name; 3720/// of the integral object is automatically constructed from the name of the input function, the variables; 3721/// it integrates and the range integrates over. The default strategy to calculate the running integrals is; 3722///; 3723/// - If the integrand (this object) supports analytical integration, construct an integral object; 3724/// that calculate the running integrals value by calculating the analytical integral each; 3725/// time the running integral object is evaluated; 3726///; 3727/// - If the integrand (this object) requires numeric integration to construct the running integral; 3728/// create an object of class RooNumRunningInt which first samples the entire function and integrates; 3729/// the sampled function numerically. This method has superior performance as there is no need to; 3730/// perform a full (numeric) integration for each evaluation of the running integral object, but; 3731/// only when one of its parameters has changed.; 3732///; 3733/// The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; 3734/// scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); 3735/// argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; 3736/// granularity for the scanning technique can be controlled with the ScanParameters technique; 3737/// which allows to specify the number of samples to be taken, a",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:159437,Integrability,integrat,integrates,159437,"et, const RooArgSet& nset); 3707{; 3708 return createRunningIntegral(iset,RooFit::SupNormSet(nset)) ;; 3709}; 3710 ; 3711 ; 3712 ; 3713////////////////////////////////////////////////////////////////////////////////; 3714/// Create an object that represents the running integral of the function over one or more observables listed in iset, i.e.; 3715/// \f[; 3716/// \int_{x_\mathrm{lo}}^x f(x') \, \mathrm{d}x'; 3717/// \f]; 3718///; 3719/// The actual integration calculation is only performed when the return object is evaluated. The name; 3720/// of the integral object is automatically constructed from the name of the input function, the variables; 3721/// it integrates and the range integrates over. The default strategy to calculate the running integrals is; 3722///; 3723/// - If the integrand (this object) supports analytical integration, construct an integral object; 3724/// that calculate the running integrals value by calculating the analytical integral each; 3725/// time the running integral object is evaluated; 3726///; 3727/// - If the integrand (this object) requires numeric integration to construct the running integral; 3728/// create an object of class RooNumRunningInt which first samples the entire function and integrates; 3729/// the sampled function numerically. This method has superior performance as there is no need to; 3730/// perform a full (numeric) integration for each evaluation of the running integral object, but; 3731/// only when one of its parameters has changed.; 3732///; 3733/// The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; 3734/// scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); 3735/// argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; 3736/// granularity for the scanning technique can be controlled with the ScanParameters technique; 3737/// which allows to specify the number of samples to be taken, a",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:159585,Integrability,integrat,integration,159585,"thrm{d}x'; 3717/// \f]; 3718///; 3719/// The actual integration calculation is only performed when the return object is evaluated. The name; 3720/// of the integral object is automatically constructed from the name of the input function, the variables; 3721/// it integrates and the range integrates over. The default strategy to calculate the running integrals is; 3722///; 3723/// - If the integrand (this object) supports analytical integration, construct an integral object; 3724/// that calculate the running integrals value by calculating the analytical integral each; 3725/// time the running integral object is evaluated; 3726///; 3727/// - If the integrand (this object) requires numeric integration to construct the running integral; 3728/// create an object of class RooNumRunningInt which first samples the entire function and integrates; 3729/// the sampled function numerically. This method has superior performance as there is no need to; 3730/// perform a full (numeric) integration for each evaluation of the running integral object, but; 3731/// only when one of its parameters has changed.; 3732///; 3733/// The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; 3734/// scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); 3735/// argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; 3736/// granularity for the scanning technique can be controlled with the ScanParameters technique; 3737/// which allows to specify the number of samples to be taken, and to which order the resulting; 3738/// running integral should be interpolated. The default values are 1000 samples and 2nd order; 3739/// interpolation.; 3740///; 3741/// The following named arguments are accepted; 3742/// | | Effect on integral creation; 3743/// |-|-------------------------------; 3744/// | `SupNormSet(const RooArgSet&)` | Observables over which should be normalized _in additio",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:159959,Integrability,integrat,integrate,159959,"t integrates and the range integrates over. The default strategy to calculate the running integrals is; 3722///; 3723/// - If the integrand (this object) supports analytical integration, construct an integral object; 3724/// that calculate the running integrals value by calculating the analytical integral each; 3725/// time the running integral object is evaluated; 3726///; 3727/// - If the integrand (this object) requires numeric integration to construct the running integral; 3728/// create an object of class RooNumRunningInt which first samples the entire function and integrates; 3729/// the sampled function numerically. This method has superior performance as there is no need to; 3730/// perform a full (numeric) integration for each evaluation of the running integral object, but; 3731/// only when one of its parameters has changed.; 3732///; 3733/// The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; 3734/// scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); 3735/// argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; 3736/// granularity for the scanning technique can be controlled with the ScanParameters technique; 3737/// which allows to specify the number of samples to be taken, and to which order the resulting; 3738/// running integral should be interpolated. The default values are 1000 samples and 2nd order; 3739/// interpolation.; 3740///; 3741/// The following named arguments are accepted; 3742/// | | Effect on integral creation; 3743/// |-|-------------------------------; 3744/// | `SupNormSet(const RooArgSet&)` | Observables over which should be normalized _in addition_ to the integration observables; 3745/// | `ScanParameters(Int_t nbins, Int_t intOrder)` | Parameters for scanning technique of making CDF: number of sampled bins and order of interpolation applied on numeric cdf; 3746/// | `ScanNum()` | Apply scanning techniq",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:160608,Integrability,integrat,integration,160608," ScanNone(); 3735/// argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; 3736/// granularity for the scanning technique can be controlled with the ScanParameters technique; 3737/// which allows to specify the number of samples to be taken, and to which order the resulting; 3738/// running integral should be interpolated. The default values are 1000 samples and 2nd order; 3739/// interpolation.; 3740///; 3741/// The following named arguments are accepted; 3742/// | | Effect on integral creation; 3743/// |-|-------------------------------; 3744/// | `SupNormSet(const RooArgSet&)` | Observables over which should be normalized _in addition_ to the integration observables; 3745/// | `ScanParameters(Int_t nbins, Int_t intOrder)` | Parameters for scanning technique of making CDF: number of sampled bins and order of interpolation applied on numeric cdf; 3746/// | `ScanNum()` | Apply scanning technique if cdf integral involves numeric integration; 3747/// | `ScanAll()` | Always apply scanning technique; 3748/// | `ScanNone()` | Never apply scanning technique; 3749 ; 3750RooFit::OwningPtr<RooAbsReal> RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2,; 3751 const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5,; 3752 const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 3753{; 3754 // Define configuration for this method; 3755 RooCmdConfig pc(""RooAbsReal::createRunningIntegral("" + std::string(GetName()) + "")"");; 3756 pc.defineSet(""supNormSet"",""SupNormSet"",0,nullptr) ;; 3757 pc.defineInt(""numScanBins"",""ScanParameters"",0,1000) ;; 3758 pc.defineInt(""intOrder"",""ScanParameters"",1,2) ;; 3759 pc.defineInt(""doScanNum"",""ScanNum"",0,1) ;; 3760 pc.defineInt(""doScanAll"",""ScanAll"",0,0) ;; 3761 pc.defineInt(""doScanNon"",""ScanNone"",0,0) ;; 3762 pc.defineMutex(""ScanNum"",""ScanAll"",""ScanNone"") ;; 3763 ; 3764 // Process & check varargs; 3765 pc.process(arg1,arg2,arg3,arg4,a",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:160896,Integrability,integrat,integration,160896," ScanNone(); 3735/// argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; 3736/// granularity for the scanning technique can be controlled with the ScanParameters technique; 3737/// which allows to specify the number of samples to be taken, and to which order the resulting; 3738/// running integral should be interpolated. The default values are 1000 samples and 2nd order; 3739/// interpolation.; 3740///; 3741/// The following named arguments are accepted; 3742/// | | Effect on integral creation; 3743/// |-|-------------------------------; 3744/// | `SupNormSet(const RooArgSet&)` | Observables over which should be normalized _in addition_ to the integration observables; 3745/// | `ScanParameters(Int_t nbins, Int_t intOrder)` | Parameters for scanning technique of making CDF: number of sampled bins and order of interpolation applied on numeric cdf; 3746/// | `ScanNum()` | Apply scanning technique if cdf integral involves numeric integration; 3747/// | `ScanAll()` | Always apply scanning technique; 3748/// | `ScanNone()` | Never apply scanning technique; 3749 ; 3750RooFit::OwningPtr<RooAbsReal> RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2,; 3751 const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5,; 3752 const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 3753{; 3754 // Define configuration for this method; 3755 RooCmdConfig pc(""RooAbsReal::createRunningIntegral("" + std::string(GetName()) + "")"");; 3756 pc.defineSet(""supNormSet"",""SupNormSet"",0,nullptr) ;; 3757 pc.defineInt(""numScanBins"",""ScanParameters"",0,1000) ;; 3758 pc.defineInt(""intOrder"",""ScanParameters"",1,2) ;; 3759 pc.defineInt(""doScanNum"",""ScanNum"",0,1) ;; 3760 pc.defineInt(""doScanAll"",""ScanAll"",0,0) ;; 3761 pc.defineInt(""doScanNon"",""ScanNone"",0,0) ;; 3762 pc.defineMutex(""ScanNum"",""ScanAll"",""ScanNone"") ;; 3763 ; 3764 // Process & check varargs; 3765 pc.process(arg1,arg2,arg3,arg4,a",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:162945,Integrability,integrat,integration,162945,"s from named arguments; 3771 RooArgSet nset ;; 3772 if (const RooArgSet* snset = pc.getSet(""supNormSet"",nullptr)) {; 3773 nset.add(*snset) ;; 3774 }; 3775 Int_t numScanBins = pc.getInt(""numScanBins"") ;; 3776 Int_t intOrder = pc.getInt(""intOrder"") ;; 3777 Int_t doScanNum = pc.getInt(""doScanNum"") ;; 3778 Int_t doScanAll = pc.getInt(""doScanAll"") ;; 3779 Int_t doScanNon = pc.getInt(""doScanNon"") ;; 3780 ; 3781 // If scanning technique is not requested make integral-based cdf and return; 3782 if (doScanNon) {; 3783 return createIntRI(iset,nset) ;; 3784 }; 3785 if (doScanAll) {; 3786 return createScanRI(iset,nset,numScanBins,intOrder) ;; 3787 }; 3788 if (doScanNum) {; 3789 std::unique_ptr<RooAbsReal> tmp{createIntegral(iset)} ;; 3790 Int_t isNum= !static_cast<RooRealIntegral&>(*tmp).numIntRealVars().empty();; 3791 ; 3792 if (isNum) {; 3793 coutI(NumIntegration) << ""RooAbsPdf::createRunningIntegral("" << GetName() << "") integration over observable(s) "" << iset << "" involves numeric integration,"" << std::endl; 3794 << "" constructing cdf though numeric integration of sampled pdf in "" << numScanBins << "" bins and applying order ""; 3795 << intOrder << "" interpolation on integrated histogram."" << std::endl; 3796 << "" To override this choice of technique use argument ScanNone(), to change scan parameters use ScanParameters(nbins,order) argument"" << std::endl ;; 3797 }; 3798 ; 3799 return isNum ? createScanRI(iset,nset,numScanBins,intOrder) : createIntRI(iset,nset) ;; 3800 }; 3801 return nullptr;; 3802}; 3803 ; 3804 ; 3805 ; 3806////////////////////////////////////////////////////////////////////////////////; 3807/// Utility function for createRunningIntegral that construct an object; 3808/// implementing the numeric scanning technique for calculating the running integral; 3809 ; 3810RooFit::OwningPtr<RooAbsReal> RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); 3811{; 3812 std::string name = std::string(GetName()) + ""_NUMRUNI",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:163008,Integrability,integrat,integration,163008,"s from named arguments; 3771 RooArgSet nset ;; 3772 if (const RooArgSet* snset = pc.getSet(""supNormSet"",nullptr)) {; 3773 nset.add(*snset) ;; 3774 }; 3775 Int_t numScanBins = pc.getInt(""numScanBins"") ;; 3776 Int_t intOrder = pc.getInt(""intOrder"") ;; 3777 Int_t doScanNum = pc.getInt(""doScanNum"") ;; 3778 Int_t doScanAll = pc.getInt(""doScanAll"") ;; 3779 Int_t doScanNon = pc.getInt(""doScanNon"") ;; 3780 ; 3781 // If scanning technique is not requested make integral-based cdf and return; 3782 if (doScanNon) {; 3783 return createIntRI(iset,nset) ;; 3784 }; 3785 if (doScanAll) {; 3786 return createScanRI(iset,nset,numScanBins,intOrder) ;; 3787 }; 3788 if (doScanNum) {; 3789 std::unique_ptr<RooAbsReal> tmp{createIntegral(iset)} ;; 3790 Int_t isNum= !static_cast<RooRealIntegral&>(*tmp).numIntRealVars().empty();; 3791 ; 3792 if (isNum) {; 3793 coutI(NumIntegration) << ""RooAbsPdf::createRunningIntegral("" << GetName() << "") integration over observable(s) "" << iset << "" involves numeric integration,"" << std::endl; 3794 << "" constructing cdf though numeric integration of sampled pdf in "" << numScanBins << "" bins and applying order ""; 3795 << intOrder << "" interpolation on integrated histogram."" << std::endl; 3796 << "" To override this choice of technique use argument ScanNone(), to change scan parameters use ScanParameters(nbins,order) argument"" << std::endl ;; 3797 }; 3798 ; 3799 return isNum ? createScanRI(iset,nset,numScanBins,intOrder) : createIntRI(iset,nset) ;; 3800 }; 3801 return nullptr;; 3802}; 3803 ; 3804 ; 3805 ; 3806////////////////////////////////////////////////////////////////////////////////; 3807/// Utility function for createRunningIntegral that construct an object; 3808/// implementing the numeric scanning technique for calculating the running integral; 3809 ; 3810RooFit::OwningPtr<RooAbsReal> RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); 3811{; 3812 std::string name = std::string(GetName()) + ""_NUMRUNI",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:163078,Integrability,integrat,integration,163078,"s from named arguments; 3771 RooArgSet nset ;; 3772 if (const RooArgSet* snset = pc.getSet(""supNormSet"",nullptr)) {; 3773 nset.add(*snset) ;; 3774 }; 3775 Int_t numScanBins = pc.getInt(""numScanBins"") ;; 3776 Int_t intOrder = pc.getInt(""intOrder"") ;; 3777 Int_t doScanNum = pc.getInt(""doScanNum"") ;; 3778 Int_t doScanAll = pc.getInt(""doScanAll"") ;; 3779 Int_t doScanNon = pc.getInt(""doScanNon"") ;; 3780 ; 3781 // If scanning technique is not requested make integral-based cdf and return; 3782 if (doScanNon) {; 3783 return createIntRI(iset,nset) ;; 3784 }; 3785 if (doScanAll) {; 3786 return createScanRI(iset,nset,numScanBins,intOrder) ;; 3787 }; 3788 if (doScanNum) {; 3789 std::unique_ptr<RooAbsReal> tmp{createIntegral(iset)} ;; 3790 Int_t isNum= !static_cast<RooRealIntegral&>(*tmp).numIntRealVars().empty();; 3791 ; 3792 if (isNum) {; 3793 coutI(NumIntegration) << ""RooAbsPdf::createRunningIntegral("" << GetName() << "") integration over observable(s) "" << iset << "" involves numeric integration,"" << std::endl; 3794 << "" constructing cdf though numeric integration of sampled pdf in "" << numScanBins << "" bins and applying order ""; 3795 << intOrder << "" interpolation on integrated histogram."" << std::endl; 3796 << "" To override this choice of technique use argument ScanNone(), to change scan parameters use ScanParameters(nbins,order) argument"" << std::endl ;; 3797 }; 3798 ; 3799 return isNum ? createScanRI(iset,nset,numScanBins,intOrder) : createIntRI(iset,nset) ;; 3800 }; 3801 return nullptr;; 3802}; 3803 ; 3804 ; 3805 ; 3806////////////////////////////////////////////////////////////////////////////////; 3807/// Utility function for createRunningIntegral that construct an object; 3808/// implementing the numeric scanning technique for calculating the running integral; 3809 ; 3810RooFit::OwningPtr<RooAbsReal> RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); 3811{; 3812 std::string name = std::string(GetName()) + ""_NUMRUNI",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:163196,Integrability,integrat,integrated,163196,"s from named arguments; 3771 RooArgSet nset ;; 3772 if (const RooArgSet* snset = pc.getSet(""supNormSet"",nullptr)) {; 3773 nset.add(*snset) ;; 3774 }; 3775 Int_t numScanBins = pc.getInt(""numScanBins"") ;; 3776 Int_t intOrder = pc.getInt(""intOrder"") ;; 3777 Int_t doScanNum = pc.getInt(""doScanNum"") ;; 3778 Int_t doScanAll = pc.getInt(""doScanAll"") ;; 3779 Int_t doScanNon = pc.getInt(""doScanNon"") ;; 3780 ; 3781 // If scanning technique is not requested make integral-based cdf and return; 3782 if (doScanNon) {; 3783 return createIntRI(iset,nset) ;; 3784 }; 3785 if (doScanAll) {; 3786 return createScanRI(iset,nset,numScanBins,intOrder) ;; 3787 }; 3788 if (doScanNum) {; 3789 std::unique_ptr<RooAbsReal> tmp{createIntegral(iset)} ;; 3790 Int_t isNum= !static_cast<RooRealIntegral&>(*tmp).numIntRealVars().empty();; 3791 ; 3792 if (isNum) {; 3793 coutI(NumIntegration) << ""RooAbsPdf::createRunningIntegral("" << GetName() << "") integration over observable(s) "" << iset << "" involves numeric integration,"" << std::endl; 3794 << "" constructing cdf though numeric integration of sampled pdf in "" << numScanBins << "" bins and applying order ""; 3795 << intOrder << "" interpolation on integrated histogram."" << std::endl; 3796 << "" To override this choice of technique use argument ScanNone(), to change scan parameters use ScanParameters(nbins,order) argument"" << std::endl ;; 3797 }; 3798 ; 3799 return isNum ? createScanRI(iset,nset,numScanBins,intOrder) : createIntRI(iset,nset) ;; 3800 }; 3801 return nullptr;; 3802}; 3803 ; 3804 ; 3805 ; 3806////////////////////////////////////////////////////////////////////////////////; 3807/// Utility function for createRunningIntegral that construct an object; 3808/// implementing the numeric scanning technique for calculating the running integral; 3809 ; 3810RooFit::OwningPtr<RooAbsReal> RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); 3811{; 3812 std::string name = std::string(GetName()) + ""_NUMRUNI",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:164628,Integrability,integrat,integration,164628,"////////////; 3807/// Utility function for createRunningIntegral that construct an object; 3808/// implementing the numeric scanning technique for calculating the running integral; 3809 ; 3810RooFit::OwningPtr<RooAbsReal> RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); 3811{; 3812 std::string name = std::string(GetName()) + ""_NUMRUNINT_"" + integralNameSuffix(iset,&nset).Data() ;; 3813 RooRealVar* ivar = static_cast<RooRealVar*>(iset.first()) ;; 3814 ivar->setBins(numScanBins,""numcdf"") ;; 3815 auto ret = std::make_unique<RooNumRunningInt>(name.c_str(),name.c_str(),*this,*ivar,""numrunint"") ;; 3816 ret->setInterpolationOrder(intOrder) ;; 3817 return RooFit::makeOwningPtr<RooAbsReal>(std::move(ret));; 3818}; 3819 ; 3820 ; 3821 ; 3822////////////////////////////////////////////////////////////////////////////////; 3823/// Utility function for createRunningIntegral. It creates an; 3824/// object implementing the standard (analytical) integration; 3825/// technique for calculating the running integral.; 3826 ; 3827RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset); 3828{; 3829 // Make list of input arguments keeping only RooRealVars; 3830 RooArgList ilist ;; 3831 for(RooAbsArg * arg : iset) {; 3832 if (dynamic_cast<RooRealVar*>(arg)) {; 3833 ilist.add(*arg) ;; 3834 } else {; 3835 coutW(InputArguments) << ""RooAbsPdf::createRunningIntegral("" << GetName() << "") WARNING ignoring non-RooRealVar input argument "" << arg->GetName() << std::endl ;; 3836 }; 3837 }; 3838 ; 3839 RooArgList cloneList ;; 3840 RooArgList loList ;; 3841 RooArgSet clonedBranchNodes ;; 3842 ; 3843 // Setup customizer that stores all cloned branches in our non-owning list; 3844 RooCustomizer cust(*this,""cdf"") ;; 3845 cust.setCloneBranchSet(clonedBranchNodes) ;; 3846 cust.setOwning(false) ;; 3847 ; 3848 // Make integration observable x_prime for each observable x as well as an x_lowbound; 3849 for(auto ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:165534,Integrability,integrat,integration,165534,"tandard (analytical) integration; 3825/// technique for calculating the running integral.; 3826 ; 3827RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset); 3828{; 3829 // Make list of input arguments keeping only RooRealVars; 3830 RooArgList ilist ;; 3831 for(RooAbsArg * arg : iset) {; 3832 if (dynamic_cast<RooRealVar*>(arg)) {; 3833 ilist.add(*arg) ;; 3834 } else {; 3835 coutW(InputArguments) << ""RooAbsPdf::createRunningIntegral("" << GetName() << "") WARNING ignoring non-RooRealVar input argument "" << arg->GetName() << std::endl ;; 3836 }; 3837 }; 3838 ; 3839 RooArgList cloneList ;; 3840 RooArgList loList ;; 3841 RooArgSet clonedBranchNodes ;; 3842 ; 3843 // Setup customizer that stores all cloned branches in our non-owning list; 3844 RooCustomizer cust(*this,""cdf"") ;; 3845 cust.setCloneBranchSet(clonedBranchNodes) ;; 3846 cust.setOwning(false) ;; 3847 ; 3848 // Make integration observable x_prime for each observable x as well as an x_lowbound; 3849 for(auto * rrv : static_range_cast<RooRealVar*>(ilist)) {; 3850 ; 3851 // Make clone x_prime of each c.d.f observable x represening running integral; 3852 RooRealVar* cloneArg = static_cast<RooRealVar*>(rrv->clone(Form(""%s_prime"",rrv->GetName()))) ;; 3853 cloneList.add(*cloneArg) ;; 3854 cust.replaceArg(*rrv,*cloneArg) ;; 3855 ; 3856 // Make clone x_lowbound of each c.d.f observable representing low bound of x; 3857 RooRealVar* cloneLo = static_cast<RooRealVar*>(rrv->clone(Form(""%s_lowbound"",rrv->GetName()))) ;; 3858 cloneLo->setVal(rrv->getMin()) ;; 3859 loList.add(*cloneLo) ;; 3860 ; 3861 // Make parameterized binning from [x_lowbound,x] for each x_prime; 3862 RooParamBinning pb(*cloneLo,*rrv,100) ;; 3863 cloneArg->setBinning(pb,""CDF"") ;; 3864 ; 3865 }; 3866 ; 3867 RooAbsReal* tmp = static_cast<RooAbsReal*>(cust.build()) ;; 3868 ; 3869 // Construct final normalization set for c.d.f = integrated observables + any extra specified by user; 3870 RooArgSet finalNset(nset) ;; 387",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:166517,Integrability,integrat,integrated,166517,"or each observable x as well as an x_lowbound; 3849 for(auto * rrv : static_range_cast<RooRealVar*>(ilist)) {; 3850 ; 3851 // Make clone x_prime of each c.d.f observable x represening running integral; 3852 RooRealVar* cloneArg = static_cast<RooRealVar*>(rrv->clone(Form(""%s_prime"",rrv->GetName()))) ;; 3853 cloneList.add(*cloneArg) ;; 3854 cust.replaceArg(*rrv,*cloneArg) ;; 3855 ; 3856 // Make clone x_lowbound of each c.d.f observable representing low bound of x; 3857 RooRealVar* cloneLo = static_cast<RooRealVar*>(rrv->clone(Form(""%s_lowbound"",rrv->GetName()))) ;; 3858 cloneLo->setVal(rrv->getMin()) ;; 3859 loList.add(*cloneLo) ;; 3860 ; 3861 // Make parameterized binning from [x_lowbound,x] for each x_prime; 3862 RooParamBinning pb(*cloneLo,*rrv,100) ;; 3863 cloneArg->setBinning(pb,""CDF"") ;; 3864 ; 3865 }; 3866 ; 3867 RooAbsReal* tmp = static_cast<RooAbsReal*>(cust.build()) ;; 3868 ; 3869 // Construct final normalization set for c.d.f = integrated observables + any extra specified by user; 3870 RooArgSet finalNset(nset) ;; 3871 finalNset.add(cloneList,true) ;; 3872 std::unique_ptr<RooAbsReal> cdf{tmp->createIntegral(cloneList,finalNset,""CDF"")};; 3873 ; 3874 // Transfer ownership of cloned items to top-level c.d.f object; 3875 cdf->addOwnedComponents(*tmp) ;; 3876 cdf->addOwnedComponents(cloneList) ;; 3877 cdf->addOwnedComponents(loList) ;; 3878 ; 3879 return RooFit::makeOwningPtr(std::move(cdf));; 3880}; 3881 ; 3882 ; 3883////////////////////////////////////////////////////////////////////////////////; 3884/// Return a RooFunctor object bound to this RooAbsReal with given definition of observables; 3885/// and parameters; 3886 ; 3887RooFunctor* RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars, const RooArgSet& nset) const; 3888{; 3889 RooArgSet realObs;; 3890 getObservables(&obs, realObs);; 3891 if (realObs.size() != obs.size()) {; 3892 coutE(InputArguments) << ""RooAbsReal::functor("" << GetName() << "") ERROR: one or more specified observables are not",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:174144,Integrability,integrat,integrated,174144,"std::string name=Form(""%s_MOMENT_%d%s_%s"",GetName(),order,(central?""C"":""""),obs.GetName()) ;; 4018 std::string title=Form(""%sMoment of order %d of %s w.r.t %s "",(central?""Central "":""""),order,GetName(),obs.GetName()) ;; 4019 if (order==1) return new RooFirstMoment(name.c_str(),title.c_str(),*this,obs) ;; 4020 if (order==2) return new RooSecondMoment(name.c_str(),title.c_str(),*this,obs,central,takeRoot) ;; 4021 return new RooMoment(name.c_str(),title.c_str(),*this,obs,order,central,takeRoot) ;; 4022}; 4023 ; 4024 ; 4025////////////////////////////////////////////////////////////////////////////////; 4026/// Return function representing moment of p.d.f (normalized w.r.t given observables) of given order.; 4027/// \param[in] obs Observable to calculate the moments for; 4028/// \param[in] normObs Normalise w.r.t. these observables; 4029/// \param[in] order Order of the moment; 4030/// \param[in] central If true, the central moment is given by \f$ \langle (x- \langle x \rangle )^2 \rangle \f$; 4031/// \param[in] takeRoot Calculate the square root; 4032/// \param[in] intNormObs If true, the moment of the function integrated over all normalization observables is returned.; 4033 ; 4034RooAbsMoment* RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, bool central, bool takeRoot, bool intNormObs); 4035{; 4036 std::string name=Form(""%s_MOMENT_%d%s_%s"",GetName(),order,(central?""C"":""""),obs.GetName()) ;; 4037 std::string title=Form(""%sMoment of order %d of %s w.r.t %s "",(central?""Central "":""""),order,GetName(),obs.GetName()) ;; 4038 ; 4039 if (order==1) return new RooFirstMoment(name.c_str(),title.c_str(),*this,obs,normObs,intNormObs) ;; 4040 if (order==2) return new RooSecondMoment(name.c_str(),title.c_str(),*this,obs,normObs,central,takeRoot,intNormObs) ;; 4041 return new RooMoment(name.c_str(),title.c_str(),*this,obs,normObs,order,central,takeRoot,intNormObs) ;; 4042}; 4043 ; 4044 ; 4045 ; 4046////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:176499,Integrability,message,messages,176499,"////////////////////////////////////////////////////////; 4061/// Perform a \f$ \chi^2 \f$ fit to given histogram. By default the fit is executed through the MINUIT; 4062/// commands MIGRAD, HESSE in succession; 4063///; 4064/// The following named arguments are supported; 4065///; 4066/// <table>; 4067/// <tr><th> <th> Options to control construction of chi2; 4068/// <tr><td> `Extended(bool flag)` <td> **Only applicable when fitting a RooAbsPdf**. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight.; 4069/// This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; 4070/// - If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events; 4071/// (in RooFit jargon, ""if the pdf can be extended"").; 4072/// - Passing `Extended(true)` when the the pdf makes no prediction on the expected number of events will result in error messages,; 4073/// and the chi2 will fall back to the total data weight to scale the normalized pdf.; 4074/// - There are cases where the fit **must** be done in extended mode. This happens for example when you have a RooAddPdf; 4075/// where the coefficients represent component yields. If the fit is not extended, these coefficients will not be; 4076/// well-defined, as the RooAddPdf always normalizes itself. If you pass `Extended(false)` in such a case, an error will be; 4077/// printed and you'll most likely get garbage results.; 4078/// <tr><td> `Range(const char* name)` <td> Fit only data inside range with given name; 4079/// <tr><td> `Range(double lo, double hi)` <td> Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; 4080/// Multiple comma separated range names can be specified.; 4081/// <tr><td> `NumCPU(int num)` <td> Parallelize NLL calculation on num CPUs; 4082/// <tr><td> `Optimize(bool flag)` <td> Activate constant ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:178759,Integrability,message,messages,178759,"` <td> Flag controls if HESSE is run after MIGRAD, on by default; 4088/// <tr><td> `Minos(bool flag)` <td> Flag controls if MINOS is run after HESSE, on by default; 4089/// <tr><td> `Minos(const RooArgSet& set)` <td> Only run MINOS on given subset of arguments; 4090/// <tr><td> `Save(bool flag)` <td> Flag controls if RooFitResult object is produced and returned, off by default; 4091/// <tr><td> `Strategy(Int_t flag)` <td> Set Minuit strategy (0 through 2, default is 1); 4092///; 4093/// <tr><th> <th> Options to control informational output; 4094/// <tr><td> `Verbose(bool flag)` <td> Flag controls if verbose output is printed (NLL, parameter changes during fit; 4095/// <tr><td> `Timer(bool flag)` <td> Time CPU and wall clock consumption of fit steps, off by default; 4096/// <tr><td> `PrintLevel(Int_t level)` <td> Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; 4097/// messages are suppressed as well; 4098/// <tr><td> `Warnings(bool flag)` <td> Enable or disable MINUIT warnings (enabled by default); 4099/// <tr><td> `PrintEvalErrors(Int_t numErr)` <td> Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; 4100/// value suppress output completely, a zero value will only print the error count per p.d.f component,; 4101/// a positive value is will print details of each error up to numErr messages per p.d.f component.; 4102/// </table>; 4103///; 4104 ; 4105RooFit::OwningPtr<RooFitResult> RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1, const RooCmdArg& arg2,; 4106 const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5,; 4107 const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 4108{; 4109 RooLinkedList l ;; 4110 l.Add((TObject*)&arg1) ; l.Add((TObject*)&arg2) ;; 4111 l.Add((TObject*)&arg3) ; l.Add((TObject*)&arg4) ;; 4112 l.Add((TObject*)&arg5) ; l.Add((TObject*)&arg6) ;; 4113 l.Add((TObject*)&arg7) ; l.Add((TObject*)&arg8) ;; 4114 return chi2FitTo(data,l) ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:179218,Integrability,message,messages,179218,"is produced and returned, off by default; 4091/// <tr><td> `Strategy(Int_t flag)` <td> Set Minuit strategy (0 through 2, default is 1); 4092///; 4093/// <tr><th> <th> Options to control informational output; 4094/// <tr><td> `Verbose(bool flag)` <td> Flag controls if verbose output is printed (NLL, parameter changes during fit; 4095/// <tr><td> `Timer(bool flag)` <td> Time CPU and wall clock consumption of fit steps, off by default; 4096/// <tr><td> `PrintLevel(Int_t level)` <td> Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; 4097/// messages are suppressed as well; 4098/// <tr><td> `Warnings(bool flag)` <td> Enable or disable MINUIT warnings (enabled by default); 4099/// <tr><td> `PrintEvalErrors(Int_t numErr)` <td> Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; 4100/// value suppress output completely, a zero value will only print the error count per p.d.f component,; 4101/// a positive value is will print details of each error up to numErr messages per p.d.f component.; 4102/// </table>; 4103///; 4104 ; 4105RooFit::OwningPtr<RooFitResult> RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1, const RooCmdArg& arg2,; 4106 const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5,; 4107 const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 4108{; 4109 RooLinkedList l ;; 4110 l.Add((TObject*)&arg1) ; l.Add((TObject*)&arg2) ;; 4111 l.Add((TObject*)&arg3) ; l.Add((TObject*)&arg4) ;; 4112 l.Add((TObject*)&arg5) ; l.Add((TObject*)&arg6) ;; 4113 l.Add((TObject*)&arg7) ; l.Add((TObject*)&arg8) ;; 4114 return chi2FitTo(data,l) ;; 4115}; 4116 ; 4117 ; 4118 ; 4119////////////////////////////////////////////////////////////////////////////////; 4120/// Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result.; 4121///; 4122/// List of possible commands in the `cmdList`:; 4123///; 4124/// <table>; 4125/// <tr><th> Type of ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:186434,Integrability,message,messages,186434,")` <td> Flag controls if HESSE is run after MIGRAD, on by default; 4220/// <tr><td> `Minos(bool flag)` <td> Flag controls if MINOS is run after HESSE, on by default; 4221/// <tr><td> `Minos(const RooArgSet& set)` <td> Only run MINOS on given subset of arguments; 4222/// <tr><td> `Save(bool flag)` <td> Flag controls if RooFitResult object is produced and returned, off by default; 4223/// <tr><td> `Strategy(Int_t flag)` <td> Set Minuit strategy (0 through 2, default is 1); 4224///; 4225/// <tr><th><th> Options to control informational output; 4226/// <tr><td> `Verbose(bool flag)` <td> Flag controls if verbose output is printed (NLL, parameter changes during fit; 4227/// <tr><td> `Timer(bool flag)` <td> Time CPU and wall clock consumption of fit steps, off by default; 4228/// <tr><td> `PrintLevel(Int_t level)` <td> Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; 4229/// messages are suppressed as well; 4230/// <tr><td> `Warnings(bool flag)` <td> Enable or disable MINUIT warnings (enabled by default); 4231/// <tr><td> `PrintEvalErrors(Int_t numErr)` <td> Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; 4232/// value suppress output completely, a zero value will only print the error count per p.d.f component,; 4233/// a positive value is will print details of each error up to numErr messages per p.d.f component.; 4234/// </table>; 4235 ; 4236RooFit::OwningPtr<RooFitResult> RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1, const RooCmdArg& arg2,; 4237 const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5,; 4238 const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 4239{; 4240 RooLinkedList l ;; 4241 l.Add((TObject*)&arg1) ; l.Add((TObject*)&arg2) ;; 4242 l.Add((TObject*)&arg3) ; l.Add((TObject*)&arg4) ;; 4243 l.Add((TObject*)&arg5) ; l.Add((TObject*)&arg6) ;; 4244 l.Add((TObject*)&arg7) ; l.Add((TObject*)&arg8) ;; 4245 return chi2FitTo(xydata,l) ;; 424",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:186893,Integrability,message,messages,186893," is produced and returned, off by default; 4223/// <tr><td> `Strategy(Int_t flag)` <td> Set Minuit strategy (0 through 2, default is 1); 4224///; 4225/// <tr><th><th> Options to control informational output; 4226/// <tr><td> `Verbose(bool flag)` <td> Flag controls if verbose output is printed (NLL, parameter changes during fit; 4227/// <tr><td> `Timer(bool flag)` <td> Time CPU and wall clock consumption of fit steps, off by default; 4228/// <tr><td> `PrintLevel(Int_t level)` <td> Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; 4229/// messages are suppressed as well; 4230/// <tr><td> `Warnings(bool flag)` <td> Enable or disable MINUIT warnings (enabled by default); 4231/// <tr><td> `PrintEvalErrors(Int_t numErr)` <td> Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; 4232/// value suppress output completely, a zero value will only print the error count per p.d.f component,; 4233/// a positive value is will print details of each error up to numErr messages per p.d.f component.; 4234/// </table>; 4235 ; 4236RooFit::OwningPtr<RooFitResult> RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1, const RooCmdArg& arg2,; 4237 const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5,; 4238 const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 4239{; 4240 RooLinkedList l ;; 4241 l.Add((TObject*)&arg1) ; l.Add((TObject*)&arg2) ;; 4242 l.Add((TObject*)&arg3) ; l.Add((TObject*)&arg4) ;; 4243 l.Add((TObject*)&arg5) ; l.Add((TObject*)&arg6) ;; 4244 l.Add((TObject*)&arg7) ; l.Add((TObject*)&arg8) ;; 4245 return chi2FitTo(xydata,l) ;; 4246}; 4247 ; 4248 ; 4249 ; 4250 ; 4251////////////////////////////////////////////////////////////////////////////////; 4252/// \copydoc RooAbsReal::chi2FitTo(RooDataSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&); 4253 ; 4254RooFit::OwningPtr<RooF",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:191092,Integrability,depend,dependsOnValue,191092," current evaluation error logging mode.; 4301 ; 4302RooAbsReal::ErrorLoggingMode RooAbsReal::evalErrorLoggingMode(); 4303{; 4304 return evalErrorData().mode ;; 4305}; 4306 ; 4307////////////////////////////////////////////////////////////////////////////////; 4308/// Set evaluation error logging mode. Options are; 4309///; 4310/// PrintErrors - Print each error through RooMsgService() as it occurs; 4311/// CollectErrors - Accumulate errors, but do not print them. A subsequent call; 4312/// to printEvalErrors() will print a summary; 4313/// CountErrors - Accumulate error count, but do not print them.; 4314///; 4315 ; 4316void RooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); 4317{; 4318 evalErrorData().mode = m;; 4319}; 4320 ; 4321 ; 4322////////////////////////////////////////////////////////////////////////////////; 4323 ; 4324void RooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); 4325{; 4326 std::string plist ;; 4327 for (auto const* arg : paramVars) {; 4328 if (!dependsOnValue(*arg)) {; 4329 coutW(InputArguments) << ""RooAbsReal::setParameterizeIntegral("" << GetName(); 4330 << "") function does not depend on listed parameter "" << arg->GetName() << "", ignoring"" << std::endl ;; 4331 continue ;; 4332 }; 4333 if (!plist.empty()) plist += "":"" ;; 4334 plist += arg->GetName() ;; 4335 }; 4336 setStringAttribute(""CACHEPARAMINT"",plist.c_str()) ;; 4337}; 4338 ; 4339 ; 4340/** Base function for computing multiple values of a RooAbsReal.; 4341\param ctx An evaluation context object; 4342**/; 4343void RooAbsReal::doEval(RooFit::EvalContext & ctx) const; 4344{; 4345 std::span<double> output = ctx.output();; 4346 ; 4347 // Find all servers that are serving real numbers to us, retrieve their batch data,; 4348 // and switch them into ""always clean"" operating mode, so they return always the last-set value.; 4349 struct ServerData {; 4350 RooAbsArg* server;; 4351 std::span<const double> batch;; 4352 double oldValue;; 4353 RooAbsArg::OperMode oldOperMod",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:191229,Integrability,depend,depend,191229," current evaluation error logging mode.; 4301 ; 4302RooAbsReal::ErrorLoggingMode RooAbsReal::evalErrorLoggingMode(); 4303{; 4304 return evalErrorData().mode ;; 4305}; 4306 ; 4307////////////////////////////////////////////////////////////////////////////////; 4308/// Set evaluation error logging mode. Options are; 4309///; 4310/// PrintErrors - Print each error through RooMsgService() as it occurs; 4311/// CollectErrors - Accumulate errors, but do not print them. A subsequent call; 4312/// to printEvalErrors() will print a summary; 4313/// CountErrors - Accumulate error count, but do not print them.; 4314///; 4315 ; 4316void RooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); 4317{; 4318 evalErrorData().mode = m;; 4319}; 4320 ; 4321 ; 4322////////////////////////////////////////////////////////////////////////////////; 4323 ; 4324void RooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); 4325{; 4326 std::string plist ;; 4327 for (auto const* arg : paramVars) {; 4328 if (!dependsOnValue(*arg)) {; 4329 coutW(InputArguments) << ""RooAbsReal::setParameterizeIntegral("" << GetName(); 4330 << "") function does not depend on listed parameter "" << arg->GetName() << "", ignoring"" << std::endl ;; 4331 continue ;; 4332 }; 4333 if (!plist.empty()) plist += "":"" ;; 4334 plist += arg->GetName() ;; 4335 }; 4336 setStringAttribute(""CACHEPARAMINT"",plist.c_str()) ;; 4337}; 4338 ; 4339 ; 4340/** Base function for computing multiple values of a RooAbsReal.; 4341\param ctx An evaluation context object; 4342**/; 4343void RooAbsReal::doEval(RooFit::EvalContext & ctx) const; 4344{; 4345 std::span<double> output = ctx.output();; 4346 ; 4347 // Find all servers that are serving real numbers to us, retrieve their batch data,; 4348 // and switch them into ""always clean"" operating mode, so they return always the last-set value.; 4349 struct ServerData {; 4350 RooAbsArg* server;; 4351 std::span<const double> batch;; 4352 double oldValue;; 4353 RooAbsArg::OperMode oldOperMod",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:193741,Integrability,interface,interface,193741," ourServers.push_back({server,; 4371 serverValues,; 4372 server->isCategory() ? static_cast<RooAbsCategory const*>(server)->getCurrentIndex() : static_cast<RooAbsReal const*>(server)->_value,; 4373 oldOperMode,; 4374 server->_valueDirty,; 4375 server->_shapeDirty});; 4376 // Prevent the server from evaluating; just return cached result, which we will side load:; 4377 }; 4378 ; 4379 ; 4380 // Make sure that we restore all state when we finish:; 4381 struct RestoreStateRAII {; 4382 RestoreStateRAII(std::vector<ServerData>& servers) :; 4383 _servers{servers} { }; 4384 ; 4385 ~RestoreStateRAII() {; 4386 for (auto& serverData : _servers) {; 4387 serverData.server->setCachedValue(serverData.oldValue, true);; 4388 serverData.server->setOperMode(serverData.oldOperMode);; 4389 serverData.server->_valueDirty = serverData.oldValueDirty;; 4390 serverData.server->_shapeDirty = serverData.oldShapeDirty;; 4391 }; 4392 }; 4393 ; 4394 std::vector<ServerData>& _servers;; 4395 } restoreState{ourServers};; 4396 ; 4397 ; 4398 // Advising to implement the batch interface makes only sense if the batch was not a scalar.; 4399 // Otherwise, there would be no speedup benefit.; 4400 if(output.size() > 1 && RooMsgService::instance().isActive(this, RooFit::FastEvaluations, RooFit::INFO)) {; 4401 coutI(FastEvaluations) << ""The class "" << ClassName() << "" does not implement the faster batch evaluation interface.""; 4402 << "" Consider requesting or implementing it to benefit from a speed up."" << std::endl;; 4403 }; 4404 ; 4405 ; 4406 // For each event, write temporary values into our servers' caches, and run a single-value computation.; 4407 ; 4408 for (std::size_t i=0; i < output.size(); ++i) {; 4409 for (auto& serv : ourServers) {; 4410 serv.server->setCachedValue(serv.batch[std::min(i, serv.batch.size()-1)], false);; 4411 }; 4412 ; 4413 output[i] = evaluate();; 4414 }; 4415}; 4416 ; 4417////////////////////////////////////////////////////////////////////////////////; 4418/// This function defines",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:194079,Integrability,interface,interface,194079,"st return cached result, which we will side load:; 4377 }; 4378 ; 4379 ; 4380 // Make sure that we restore all state when we finish:; 4381 struct RestoreStateRAII {; 4382 RestoreStateRAII(std::vector<ServerData>& servers) :; 4383 _servers{servers} { }; 4384 ; 4385 ~RestoreStateRAII() {; 4386 for (auto& serverData : _servers) {; 4387 serverData.server->setCachedValue(serverData.oldValue, true);; 4388 serverData.server->setOperMode(serverData.oldOperMode);; 4389 serverData.server->_valueDirty = serverData.oldValueDirty;; 4390 serverData.server->_shapeDirty = serverData.oldShapeDirty;; 4391 }; 4392 }; 4393 ; 4394 std::vector<ServerData>& _servers;; 4395 } restoreState{ourServers};; 4396 ; 4397 ; 4398 // Advising to implement the batch interface makes only sense if the batch was not a scalar.; 4399 // Otherwise, there would be no speedup benefit.; 4400 if(output.size() > 1 && RooMsgService::instance().isActive(this, RooFit::FastEvaluations, RooFit::INFO)) {; 4401 coutI(FastEvaluations) << ""The class "" << ClassName() << "" does not implement the faster batch evaluation interface.""; 4402 << "" Consider requesting or implementing it to benefit from a speed up."" << std::endl;; 4403 }; 4404 ; 4405 ; 4406 // For each event, write temporary values into our servers' caches, and run a single-value computation.; 4407 ; 4408 for (std::size_t i=0; i < output.size(); ++i) {; 4409 for (auto& serv : ourServers) {; 4410 serv.server->setCachedValue(serv.batch[std::min(i, serv.batch.size()-1)], false);; 4411 }; 4412 ; 4413 output[i] = evaluate();; 4414 }; 4415}; 4416 ; 4417////////////////////////////////////////////////////////////////////////////////; 4418/// This function defines the analytical integral translation for the class.; 4419///; 4420/// \param[in] code The code that decides the integrands.; 4421/// \param[in] rangeName Name of the normalization range.; 4422/// \param[in] ctx An object to manage auxiliary information for code-squashing.; 4423///; 4424/// \returns The representa",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:202328,Integrability,depend,dependsOnbool,202328," prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; TH1.h; TH2.h; TH3.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TLeaf.h; TMath.h; TMatrixD.h; TObjString.h; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TTree.h; TVector.h; TreeReadBuffer.h; ValueChecking.h; CachingErrorDefinition ValueChecking.h:18; FormatPdfTreeDefinition ValueChecking.h:61; FormatPdfTree::streamstd::ostream & stream()Definition ValueChecking.h:82; RooAbsArgCommon abstract base class for objects that represent a value and a ""shape"" in RooFit.Definition RooAbsArg.h:79; RooAbsArg::dependsOnbool dependsOn(const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) constTest whether we depend on (ie, are served by) any object in the specified collection.Definition RooAbsArg.cxx:850; RooAbsArg::recursiveRedirectServersbool recursiveRedirectServers(const RooAbsCollection &newServerList, bool mustReplaceAll=false, bool nameChange=false, bool recurseInNewSet=true)Recursively replace all servers with the new servers in newSet.Definition RooAbsArg.cxx:1289; RooAbsArg::namePtrconst TNamed * namePtr() constDe-duplicated pointer to this object's name.Definition RooAbsArg.h:535; RooAbsArg::constR__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg constDefinition RooAbsArg.h:145; RooAbsArg::setShapeDirtyvoid setShapeDirty()Notify that a shape-like property (e.g. binning) has changed.Definition RooAbsArg.h:467; RooAbsArg::setStringAttributevoid setStringAttribute(const Text_t *key, const Text_t *value)Associ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:202342,Integrability,depend,dependsOn,202342," prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; TH1.h; TH2.h; TH3.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TLeaf.h; TMath.h; TMatrixD.h; TObjString.h; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TTree.h; TVector.h; TreeReadBuffer.h; ValueChecking.h; CachingErrorDefinition ValueChecking.h:18; FormatPdfTreeDefinition ValueChecking.h:61; FormatPdfTree::streamstd::ostream & stream()Definition ValueChecking.h:82; RooAbsArgCommon abstract base class for objects that represent a value and a ""shape"" in RooFit.Definition RooAbsArg.h:79; RooAbsArg::dependsOnbool dependsOn(const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) constTest whether we depend on (ie, are served by) any object in the specified collection.Definition RooAbsArg.cxx:850; RooAbsArg::recursiveRedirectServersbool recursiveRedirectServers(const RooAbsCollection &newServerList, bool mustReplaceAll=false, bool nameChange=false, bool recurseInNewSet=true)Recursively replace all servers with the new servers in newSet.Definition RooAbsArg.cxx:1289; RooAbsArg::namePtrconst TNamed * namePtr() constDe-duplicated pointer to this object's name.Definition RooAbsArg.h:535; RooAbsArg::constR__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg constDefinition RooAbsArg.h:145; RooAbsArg::setShapeDirtyvoid setShapeDirty()Notify that a shape-like property (e.g. binning) has changed.Definition RooAbsArg.h:467; RooAbsArg::setStringAttributevoid setStringAttribute(const Text_t *key, const Text_t *value)Associ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:202467,Integrability,depend,depend,202467," prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; TH1.h; TH2.h; TH3.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TLeaf.h; TMath.h; TMatrixD.h; TObjString.h; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TTree.h; TVector.h; TreeReadBuffer.h; ValueChecking.h; CachingErrorDefinition ValueChecking.h:18; FormatPdfTreeDefinition ValueChecking.h:61; FormatPdfTree::streamstd::ostream & stream()Definition ValueChecking.h:82; RooAbsArgCommon abstract base class for objects that represent a value and a ""shape"" in RooFit.Definition RooAbsArg.h:79; RooAbsArg::dependsOnbool dependsOn(const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) constTest whether we depend on (ie, are served by) any object in the specified collection.Definition RooAbsArg.cxx:850; RooAbsArg::recursiveRedirectServersbool recursiveRedirectServers(const RooAbsCollection &newServerList, bool mustReplaceAll=false, bool nameChange=false, bool recurseInNewSet=true)Recursively replace all servers with the new servers in newSet.Definition RooAbsArg.cxx:1289; RooAbsArg::namePtrconst TNamed * namePtr() constDe-duplicated pointer to this object's name.Definition RooAbsArg.h:535; RooAbsArg::constR__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg constDefinition RooAbsArg.h:145; RooAbsArg::setShapeDirtyvoid setShapeDirty()Notify that a shape-like property (e.g. binning) has changed.Definition RooAbsArg.h:467; RooAbsArg::setStringAttributevoid setStringAttribute(const Text_t *key, const Text_t *value)Associ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:204104,Integrability,depend,depends,204104,"ervables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg constDefinition RooAbsArg.h:145; RooAbsArg::setShapeDirtyvoid setShapeDirty()Notify that a shape-like property (e.g. binning) has changed.Definition RooAbsArg.h:467; RooAbsArg::setStringAttributevoid setStringAttribute(const Text_t *key, const Text_t *value)Associate string 'value' to this object under key 'key'.Definition RooAbsArg.cxx:254; RooAbsArg::isValueDirtyAndClearbool isValueDirtyAndClear() constDefinition RooAbsArg.h:408; RooAbsArg::_fastbool _fastDefinition RooAbsArg.h:689; RooAbsArg::getParametersRooFit::OwningPtr< RooArgSet > getParameters(const RooAbsData *data, bool stripDisconnected=true) constCreate a list of leaf nodes in the arg tree starting with ourself as top node that don't match any of...Definition RooAbsArg.cxx:541; RooAbsArg::getObservablesRooFit::OwningPtr< RooArgSet > getObservables(const RooArgSet &set, bool valueOnly=true) constGiven a set of possible observables, return the observables that this PDF depends on.Definition RooAbsArg.cxx:698; RooAbsArg::OperModeOperModeDefinition RooAbsArg.h:362; RooAbsArg::ADirty@ ADirtyDefinition RooAbsArg.h:362; RooAbsArg::AClean@ ACleanDefinition RooAbsArg.h:362; RooAbsArg::getStringAttributeconst Text_t * getStringAttribute(const Text_t *key) constGet string attribute mapped under key 'key'.Definition RooAbsArg.cxx:275; RooAbsArg::getComponentsRooFit::OwningPtr< RooArgSet > getComponents() constCreate a RooArgSet with all components (branch nodes) of the expression tree headed by this object.Definition RooAbsArg.cxx:802; RooAbsArg::serversconst RefCountList_t & servers() constList of all servers of this object.Definition RooAbsArg.h:180; RooAbsArg::dependsOnValuebool dependsOnValue(const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr) constCheck whether this object depends on values from an element in the serverList.Definition RooAbsA",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:204802,Integrability,depend,dependsOnValuebool,204802,"tion RooAbsArg.cxx:541; RooAbsArg::getObservablesRooFit::OwningPtr< RooArgSet > getObservables(const RooArgSet &set, bool valueOnly=true) constGiven a set of possible observables, return the observables that this PDF depends on.Definition RooAbsArg.cxx:698; RooAbsArg::OperModeOperModeDefinition RooAbsArg.h:362; RooAbsArg::ADirty@ ADirtyDefinition RooAbsArg.h:362; RooAbsArg::AClean@ ACleanDefinition RooAbsArg.h:362; RooAbsArg::getStringAttributeconst Text_t * getStringAttribute(const Text_t *key) constGet string attribute mapped under key 'key'.Definition RooAbsArg.cxx:275; RooAbsArg::getComponentsRooFit::OwningPtr< RooArgSet > getComponents() constCreate a RooArgSet with all components (branch nodes) of the expression tree headed by this object.Definition RooAbsArg.cxx:802; RooAbsArg::serversconst RefCountList_t & servers() constList of all servers of this object.Definition RooAbsArg.h:180; RooAbsArg::dependsOnValuebool dependsOnValue(const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr) constCheck whether this object depends on values from an element in the serverList.Definition RooAbsArg.h:108; RooAbsArg::setValueDirtyvoid setValueDirty()Mark the element dirty. This forces a re-evaluation when a value is requested.Definition RooAbsArg.h:462; RooAbsArg::getVariablesRooFit::OwningPtr< RooArgSet > getVariables(bool stripDisconnected=true) constReturn RooArgSet with all variables (tree leaf nodes of expression tree)Definition RooAbsArg.cxx:2154; RooAbsArg::printMultilinevoid printMultiline(std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const overrideImplement multi-line detailed printing.Definition RooAbsArg.cxx:1589; RooAbsArg::cloneTreevirtual RooAbsArg * cloneTree(const char *newname=nullptr) constClone tree expression of objects.Definition RooAbsArg.cxx:2293; RooAbsArg::cleanBranchNameTString cleanBranchName() constConstruct a mangled name from the actual name that is free of any math symbols that might be interpre...Defi",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:204821,Integrability,depend,dependsOnValue,204821,"tion RooAbsArg.cxx:541; RooAbsArg::getObservablesRooFit::OwningPtr< RooArgSet > getObservables(const RooArgSet &set, bool valueOnly=true) constGiven a set of possible observables, return the observables that this PDF depends on.Definition RooAbsArg.cxx:698; RooAbsArg::OperModeOperModeDefinition RooAbsArg.h:362; RooAbsArg::ADirty@ ADirtyDefinition RooAbsArg.h:362; RooAbsArg::AClean@ ACleanDefinition RooAbsArg.h:362; RooAbsArg::getStringAttributeconst Text_t * getStringAttribute(const Text_t *key) constGet string attribute mapped under key 'key'.Definition RooAbsArg.cxx:275; RooAbsArg::getComponentsRooFit::OwningPtr< RooArgSet > getComponents() constCreate a RooArgSet with all components (branch nodes) of the expression tree headed by this object.Definition RooAbsArg.cxx:802; RooAbsArg::serversconst RefCountList_t & servers() constList of all servers of this object.Definition RooAbsArg.h:180; RooAbsArg::dependsOnValuebool dependsOnValue(const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr) constCheck whether this object depends on values from an element in the serverList.Definition RooAbsArg.h:108; RooAbsArg::setValueDirtyvoid setValueDirty()Mark the element dirty. This forces a re-evaluation when a value is requested.Definition RooAbsArg.h:462; RooAbsArg::getVariablesRooFit::OwningPtr< RooArgSet > getVariables(bool stripDisconnected=true) constReturn RooArgSet with all variables (tree leaf nodes of expression tree)Definition RooAbsArg.cxx:2154; RooAbsArg::printMultilinevoid printMultiline(std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const overrideImplement multi-line detailed printing.Definition RooAbsArg.cxx:1589; RooAbsArg::cloneTreevirtual RooAbsArg * cloneTree(const char *newname=nullptr) constClone tree expression of objects.Definition RooAbsArg.cxx:2293; RooAbsArg::cleanBranchNameTString cleanBranchName() constConstruct a mangled name from the actual name that is free of any math symbols that might be interpre...Defi",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:204939,Integrability,depend,depends,204939,"tion RooAbsArg.cxx:541; RooAbsArg::getObservablesRooFit::OwningPtr< RooArgSet > getObservables(const RooArgSet &set, bool valueOnly=true) constGiven a set of possible observables, return the observables that this PDF depends on.Definition RooAbsArg.cxx:698; RooAbsArg::OperModeOperModeDefinition RooAbsArg.h:362; RooAbsArg::ADirty@ ADirtyDefinition RooAbsArg.h:362; RooAbsArg::AClean@ ACleanDefinition RooAbsArg.h:362; RooAbsArg::getStringAttributeconst Text_t * getStringAttribute(const Text_t *key) constGet string attribute mapped under key 'key'.Definition RooAbsArg.cxx:275; RooAbsArg::getComponentsRooFit::OwningPtr< RooArgSet > getComponents() constCreate a RooArgSet with all components (branch nodes) of the expression tree headed by this object.Definition RooAbsArg.cxx:802; RooAbsArg::serversconst RefCountList_t & servers() constList of all servers of this object.Definition RooAbsArg.h:180; RooAbsArg::dependsOnValuebool dependsOnValue(const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr) constCheck whether this object depends on values from an element in the serverList.Definition RooAbsArg.h:108; RooAbsArg::setValueDirtyvoid setValueDirty()Mark the element dirty. This forces a re-evaluation when a value is requested.Definition RooAbsArg.h:462; RooAbsArg::getVariablesRooFit::OwningPtr< RooArgSet > getVariables(bool stripDisconnected=true) constReturn RooArgSet with all variables (tree leaf nodes of expression tree)Definition RooAbsArg.cxx:2154; RooAbsArg::printMultilinevoid printMultiline(std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const overrideImplement multi-line detailed printing.Definition RooAbsArg.cxx:1589; RooAbsArg::cloneTreevirtual RooAbsArg * cloneTree(const char *newname=nullptr) constClone tree expression of objects.Definition RooAbsArg.cxx:2293; RooAbsArg::cleanBranchNameTString cleanBranchName() constConstruct a mangled name from the actual name that is free of any math symbols that might be interpre...Defi",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:212483,Integrability,interface,interface,212483,"dOwned(RooAbsArg &var, bool silent=false)Add an argument and transfer the ownership to the collection.Definition RooAbsCollection.cxx:367; RooAbsCollection::addClonevirtual RooAbsArg * addClone(const RooAbsArg &var, bool silent=false)Add a clone of the specified argument to list.Definition RooAbsCollection.cxx:416; RooAbsCollection::contentsStringstd::string contentsString() constReturn comma separated list of contained object names as STL string.Definition RooAbsCollection.cxx:1148; RooAbsCollection::findRooAbsArg * find(const char *name) constFind object with given name in list.Definition RooAbsCollection.cxx:922; RooAbsDataAbstract base class for binned and unbinned datasets.Definition RooAbsData.h:57; RooAbsData::getvirtual const RooArgSet * get() constDefinition RooAbsData.h:101; RooAbsData::numEntriesvirtual Int_t numEntries() constReturn number of entries in dataset, i.e., count unweighted entries.Definition RooAbsData.cxx:323; RooAbsFuncAbstract interface for evaluating a real-valued function of one real variable and performing numerica...Definition RooAbsFunc.h:27; RooAbsFunc::getMaxLimitvirtual double getMaxLimit(UInt_t dimension) const =0; RooAbsFunc::operator()virtual double operator()(const double xvector[]) const =0; RooAbsFunc::getMinLimitvirtual double getMinLimit(UInt_t dimension) const =0; RooAbsLValueAbstract base class for objects that are lvalues, i.e.Definition RooAbsLValue.h:26; RooAbsMomentDefinition RooAbsMoment.h:27; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::expectedEventsvirtual double expectedEvents(const RooArgSet *nset) constReturn expected number of events to be used in calculation of extended likelihood.Definition RooAbsPdf.cxx:2398; RooAbsPdf::Classstatic TClass * Class(); RooAbsPdf::CanNotBeExtended@ CanNotBeExtendedDefinition RooAbsPdf.h:212; RooAbsPdf::normRangeconst char * normRange() constDefinition RooAbsPdf.h:250; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > ge",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:213000,Integrability,interface,interface,213000,"llection::findRooAbsArg * find(const char *name) constFind object with given name in list.Definition RooAbsCollection.cxx:922; RooAbsDataAbstract base class for binned and unbinned datasets.Definition RooAbsData.h:57; RooAbsData::getvirtual const RooArgSet * get() constDefinition RooAbsData.h:101; RooAbsData::numEntriesvirtual Int_t numEntries() constReturn number of entries in dataset, i.e., count unweighted entries.Definition RooAbsData.cxx:323; RooAbsFuncAbstract interface for evaluating a real-valued function of one real variable and performing numerica...Definition RooAbsFunc.h:27; RooAbsFunc::getMaxLimitvirtual double getMaxLimit(UInt_t dimension) const =0; RooAbsFunc::operator()virtual double operator()(const double xvector[]) const =0; RooAbsFunc::getMinLimitvirtual double getMinLimit(UInt_t dimension) const =0; RooAbsLValueAbstract base class for objects that are lvalues, i.e.Definition RooAbsLValue.h:26; RooAbsMomentDefinition RooAbsMoment.h:27; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::expectedEventsvirtual double expectedEvents(const RooArgSet *nset) constReturn expected number of events to be used in calculation of extended likelihood.Definition RooAbsPdf.cxx:2398; RooAbsPdf::Classstatic TClass * Class(); RooAbsPdf::CanNotBeExtended@ CanNotBeExtendedDefinition RooAbsPdf.h:212; RooAbsPdf::normRangeconst char * normRange() constDefinition RooAbsPdf.h:250; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={})See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,...Definition RooAbsPdf.h:57; RooAbsPdf::extendModevirtual ExtendMode extendMode() constReturns ability of PDF to provide extended likelihood terms.Definition RooAbsPdf.h:216; RooAbsProxyAbstract interface for proxy classes.Defin",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:213979,Integrability,interface,interface,213979,"7; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::expectedEventsvirtual double expectedEvents(const RooArgSet *nset) constReturn expected number of events to be used in calculation of extended likelihood.Definition RooAbsPdf.cxx:2398; RooAbsPdf::Classstatic TClass * Class(); RooAbsPdf::CanNotBeExtended@ CanNotBeExtendedDefinition RooAbsPdf.h:212; RooAbsPdf::normRangeconst char * normRange() constDefinition RooAbsPdf.h:250; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={})See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,...Definition RooAbsPdf.h:57; RooAbsPdf::extendModevirtual ExtendMode extendMode() constReturns ability of PDF to provide extended likelihood terms.Definition RooAbsPdf.h:216; RooAbsProxyAbstract interface for proxy classes.Definition RooAbsProxy.h:37; RooAbsRealLValueAbstract base class for objects that represent a real value that may appear on the left hand side of ...Definition RooAbsRealLValue.h:31; RooAbsRealLValue::getMaxvirtual double getMax(const char *name=nullptr) constGet maximum of currently defined range.Definition RooAbsRealLValue.h:84; RooAbsRealLValue::createHistogramTH1 * createHistogram(const char *name, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) constDefinition RooAbsRealLValue.cxx:534; RooAbsRealLValue::getMinvirtual double getMin(const char *name=nullptr) constGet minimum of currently defined range.Definition RooAbsRealLValue.h:81; RooAbsReal::EvalErrorDefinition RooAbsReal.h:307; RooAbsReal::EvalError::setServerValuesvoid setServerValues(const char *tmp)Definition RooAbsReal.h:312; RooAbsReal::E",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:218819,Integrability,integrat,integration,218819,"tValV(const RooArgSet *normalisationSet=nullptr) constReturn value of object.Definition RooAbsReal.cxx:300; RooAbsReal::numEvalErrorItemsstatic Int_t numEvalErrorItems()Definition RooAbsReal.cxx:176; RooAbsReal::RooAbsRealRooAbsReal()coverity[UNINIT_CTOR] Default constructorDefinition RooAbsReal.cxx:199; RooAbsReal::RooRealBindingfriend class RooRealBindingDefinition RooAbsReal.h:401; RooAbsReal::fixAddCoefNormalizationvirtual void fixAddCoefNormalization(const RooArgSet &addNormSet=RooArgSet(), bool force=true)Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by...Definition RooAbsReal.cxx:3650; RooAbsReal::getAnalyticalIntegralWNvirtual Int_t getAnalyticalIntegralWN(RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) constVariant of getAnalyticalIntegral that is also passed the normalization set that should be applied to ...Definition RooAbsReal.cxx:351; RooAbsReal::_forceNumIntbool _forceNumIntForce numerical integration if flag set.Definition RooAbsReal.h:539; RooAbsReal::~RooAbsReal~RooAbsReal() overrideDestructor.Definition RooAbsReal.cxx:238; RooAbsReal::setParameterizeIntegralvoid setParameterizeIntegral(const RooArgSet &paramVars)Definition RooAbsReal.cxx:4324; RooAbsReal::matchArgsByNamebool matchArgsByName(const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) constCheck if allArgs contains matching elements for each name in nameList.Definition RooAbsReal.cxx:3241; RooAbsReal::hideOffsetstatic bool hideOffset()Definition RooAbsReal.cxx:192; RooAbsReal::setTreeBranchStatusvoid setTreeBranchStatus(TTree &t, bool active) override(De)Activate associated tree branchDefinition RooAbsReal.cxx:3116; RooAbsReal::fillHistogramTH1 * fillHistogram(TH1 *hist, const RooArgList &plotVars, double scaleFactor=1, const RooArgSet *projectedVars=nullptr, bool scaling=true, const RooArgSet *condObs=nullptr, bool setError=true) constFill the ROOT histogram 'hist' wi",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:220926,Integrability,interface,interface,220926,"AbsReal::createScanRIRooFit::OwningPtr< RooAbsReal > createScanRI(const RooArgSet &iset, const RooArgSet &nset, Int_t numScanBins, Int_t intOrder)Utility function for createRunningIntegral that construct an object implementing the numeric scanning...Definition RooAbsReal.cxx:3810; RooAbsReal::_DEBUG_getValdouble _DEBUG_getVal(const RooArgSet *normalisationSet) constDebug version of getVal(), which is slow and does error checking.Definition RooAbsReal.cxx:4434; RooAbsReal::createFundamentalRooFit::OwningPtr< RooAbsArg > createFundamental(const char *newname=nullptr) const overrideCreate a RooRealVar fundamental object with our properties.Definition RooAbsReal.cxx:3130; RooAbsReal::plotSanityChecksbool plotSanityChecks(RooPlot *frame) constUtility function for plotOn(), perform general sanity check on frame to ensure safe plotting operatio...Definition RooAbsReal.cxx:2860; RooAbsReal::bindVarsRooFit::OwningPtr< RooAbsFunc > bindVars(const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) constCreate an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order).Definition RooAbsReal.cxx:2980; RooAbsReal::selectNormalizationvirtual void selectNormalization(const RooArgSet *depSet=nullptr, bool force=false)Interface function to force use of a given set of observables to interpret function value.Definition RooAbsReal.cxx:3360; RooAbsReal::derivativeRooDerivative * derivative(RooRealVar &obs, Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Perform a fit to given histogram.Definition RooAbsReal.cxx:4105; RooAbsReal::asTFTF1 * asTF",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:222320,Integrability,integrat,integration,222320,"ooAbsReal::derivativeRooDerivative * derivative(RooRealVar &obs, Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Perform a fit to given histogram.Definition RooAbsReal.cxx:4105; RooAbsReal::asTFTF1 * asTF(const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) constReturn a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parame...Definition RooAbsReal.cxx:3911; RooAbsReal::_unitTString _unitUnit for objects value.Definition RooAbsReal.h:537; RooAbsReal::defaultIntegratorConfigstatic RooNumIntConfig * defaultIntegratorConfig()Returns the default numeric integration configuration for all RooAbsReals.Definition RooAbsReal.cxx:3272; RooAbsReal::readFromStreambool readFromStream(std::istream &is, bool compact, bool verbose=false) overrideRead object contents from stream (dummy for now)Definition RooAbsReal.cxx:426; RooAbsReal::matchArgsbool matchArgs(const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a) constUtility function for use in getAnalyticalIntegral().Definition RooAbsReal.cxx:3146; RooAbsReal::fillTreeBranchvoid fillTreeBranch(TTree &t) overrideFill the tree branch that associated with this object with its current value.Definition RooAbsReal.cxx:3099; RooAbsReal::printMultilinevoid printMultiline(std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const overrideStructure printing.Definition RooAbsReal.cxx:455; RooAbsReal::plotAsymOnvirtual RooPlot * plotAsymOn(RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) constDefinition RooAbsReal.cxx:2199;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:224123,Integrability,integrat,integration,224123,"efinition RooAbsReal.cxx:455; RooAbsReal::plotAsymOnvirtual RooPlot * plotAsymOn(RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) constDefinition RooAbsReal.cxx:2199; RooAbsReal::operator==bool operator==(double value) constEquality operator comparing to a double.Definition RooAbsReal.cxx:250; RooAbsReal::evalErrorLoggingModestatic ErrorLoggingMode evalErrorLoggingMode()Return current evaluation error logging mode.Definition RooAbsReal.cxx:4302; RooAbsReal::redirectServersHookbool redirectServersHook(const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) overrideFunction that is called at the end of redirectServers().Definition RooAbsReal.cxx:4474; RooAbsReal::isValidRealvirtual bool isValidReal(double, bool printError=false) constInterface function to check if given value is a valid value for this object. Returns true unless over...Definition RooAbsReal.h:447; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::printValuevoid printValue(std::ostream &os) const overridePrint object value.Definition RooAbsReal.cxx:445; RooAbsReal::isIdenticalbool isIdentical(const RooAbsArg &other, bool assumeSameType=false) const overrideDefinition RooAbsReal.cxx:270; RooAbsReal::createProfilevirtual RooFit::OwningPtr< RooAbsReal > createProfile(const RooArgSet &paramsOfInterest)Create a RooProfileLL object that eliminates all nuisance parameters in the present function.Definition RooAbsReal.cxx:471; RooAbsReal::_hideOffsetstatic bool _hideOffsetOffset hiding flag.Definition RooAbsReal.h:546; RooAbsReal::attachToVStorevoid attachToVStore(RooVectorDataStore &vstore) overrideDefinition RooAbsReal.cxx:3012; RooAbsReal::copyCachevoid copyCache(const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) overrideCopy the cached value of another RooAbsArg to our cache.Definition RooAbsReal.c",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:226193,Integrability,integrat,integrator,226193,"gram(RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) constCreate and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables w...Definition RooAbsReal.cxx:1183; RooAbsReal::fixAddCoefRangevirtual void fixAddCoefRange(const char *rangeName=nullptr, bool force=true)Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by...Definition RooAbsReal.cxx:3675; RooAbsReal::_valuedouble _valueCache for current value of object.Definition RooAbsReal.h:536; RooAbsReal::analyticalIntegralvirtual double analyticalIntegral(Int_t code, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:394; RooAbsReal::attachToTreevoid attachToTree(TTree &t, Int_t bufSize=32000) overrideAttach object to a branch of given TTree.Definition RooAbsReal.cxx:3028; RooAbsReal::specialIntegratorConfigRooNumIntConfig * specialIntegratorConfig() constReturns the specialized integrator configuration for this RooAbsReal.Definition RooAbsReal.cxx:3282; RooAbsReal::writeToStreamvoid writeToStream(std::ostream &os, bool compact) const overrideWrite object contents to stream (dummy for now)Definition RooAbsReal.cxx:436; RooAbsReal::traceEvaldouble traceEval(const RooArgSet *set) constCalculate current value of object, with error tracing wrapper.Definition RooAbsReal.cxx:319; RooAbsReal::getPropagatedErrordouble getPropagatedError(const RooFitResult &fr, const RooArgSet &nset={}) constPropagates parameter uncertainties to an uncertainty estimate for this RooAbsReal.Definition RooAbsReal.cxx:2472; RooAbsReal::setHideOffsetstatic void setHideOffset(bool flag)Definition RooAbsReal.cxx:191; RooAbsReal::ErrorLoggingModeErrorLoggingModeDefinition RooAbsReal.h:317; RooAbsReal::CountErrors@ CountErrorsDefinition RooAbsReal.h:317; RooAbsReal::CollectErrors@ CollectErrorsDefinition RooAbsReal.h:317; RooAbsReal::PrintErrors@ PrintErrorsD",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:226557,Integrability,wrap,wrapper,226557,"on of the coefficient of any RooAddPdf component in the expression tree headed by...Definition RooAbsReal.cxx:3675; RooAbsReal::_valuedouble _valueCache for current value of object.Definition RooAbsReal.h:536; RooAbsReal::analyticalIntegralvirtual double analyticalIntegral(Int_t code, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:394; RooAbsReal::attachToTreevoid attachToTree(TTree &t, Int_t bufSize=32000) overrideAttach object to a branch of given TTree.Definition RooAbsReal.cxx:3028; RooAbsReal::specialIntegratorConfigRooNumIntConfig * specialIntegratorConfig() constReturns the specialized integrator configuration for this RooAbsReal.Definition RooAbsReal.cxx:3282; RooAbsReal::writeToStreamvoid writeToStream(std::ostream &os, bool compact) const overrideWrite object contents to stream (dummy for now)Definition RooAbsReal.cxx:436; RooAbsReal::traceEvaldouble traceEval(const RooArgSet *set) constCalculate current value of object, with error tracing wrapper.Definition RooAbsReal.cxx:319; RooAbsReal::getPropagatedErrordouble getPropagatedError(const RooFitResult &fr, const RooArgSet &nset={}) constPropagates parameter uncertainties to an uncertainty estimate for this RooAbsReal.Definition RooAbsReal.cxx:2472; RooAbsReal::setHideOffsetstatic void setHideOffset(bool flag)Definition RooAbsReal.cxx:191; RooAbsReal::ErrorLoggingModeErrorLoggingModeDefinition RooAbsReal.h:317; RooAbsReal::CountErrors@ CountErrorsDefinition RooAbsReal.h:317; RooAbsReal::CollectErrors@ CollectErrorsDefinition RooAbsReal.h:317; RooAbsReal::PrintErrors@ PrintErrorsDefinition RooAbsReal.h:317; RooAbsReal::Ignore@ IgnoreDefinition RooAbsReal.h:317; RooAbsReal::globalSelectCompstatic void globalSelectComp(bool flag)Global switch controlling the activation of the selectComp() functionality.Definition RooAbsReal.cxx:2966; RooAbsReal::momentRooAbsMoment * moment(RooRealVar &obs, Int_t order, bool central,",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:230607,Integrability,integrat,integrated,230607,"bsReal::setEvalErrorLoggingModestatic void setEvalErrorLoggingMode(ErrorLoggingMode m)Set evaluation error logging mode.Definition RooAbsReal.cxx:4316; RooAbsReal::preferredObservableScanOrdervirtual void preferredObservableScanOrder(const RooArgSet &obs, RooArgSet &orderedObs) constInterface method for function objects to indicate their preferred order of observables for scanning t...Definition RooAbsReal.cxx:3694; RooAbsReal::maxValvirtual double maxVal(Int_t code) constReturn maximum value for set of observables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive integrals over functions ...Definition RooAbsReal.cxx:701; RooAbsReal::integralNameSuffixTString integralNameSuffix(const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:230990,Integrability,message,message,230990,"servables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive integrals over functions ...Definition RooAbsReal.cxx:701; RooAbsReal::integralNameSuffixTString integralNameSuffix(const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsR",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:231064,Integrability,message,message,231064,"servables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive integrals over functions ...Definition RooAbsReal.cxx:701; RooAbsReal::integralNameSuffixTString integralNameSuffix(const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsR",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:231537,Integrability,integrat,integration,231537,"itEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsReal.cxx:3827; RooAbsReal::enableOffsettingvirtual void enableOffsetting(bool)Definition RooAbsReal.cxx:4484; RooAbsReal::clearEvalErrorLogstatic void clearEvalErrorLog()Clear the stack of evaluation error messages.Definition RooAbsReal.cxx:3542; RooAbsReal::createIntObjRooFit::OwningPtr< RooAbsReal > createIntObj(const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) constInternal utility function for createIntegral() that creates the actual integral object.Def",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:232205,Integrability,message,messages,232205,"ticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsReal.cxx:3827; RooAbsReal::enableOffsettingvirtual void enableOffsetting(bool)Definition RooAbsReal.cxx:4484; RooAbsReal::clearEvalErrorLogstatic void clearEvalErrorLog()Clear the stack of evaluation error messages.Definition RooAbsReal.cxx:3542; RooAbsReal::createIntObjRooFit::OwningPtr< RooAbsReal > createIntObj(const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) constInternal utility function for createIntegral() that creates the actual integral object.Definition RooAbsReal.cxx:590; RooAbsReal::functorRooFunctor * functor(const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) constReturn a RooFunctor object bound to this RooAbsReal with given definition of observables and paramete...Definition RooAbsReal.cxx:3887; RooAbsReal::createPlotProjectionconst RooAbsReal * createPlotProjection(const RooArgSet &depVars, const RooArgSet &projVars, RooArgSet *&cloneSet) constUtility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a Roo...Definition RooAbsReal.cxx:787; RooAbsReal::plotSamplingHintvirtual std::list< double > * p",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:235115,Integrability,interface,interface,235115,"otVar, const RooArgSet *allVars, RooArgSet &projectedVars, bool silent) constUtility function for plotOn() that constructs the set of observables to project when plotting ourselv...Definition RooAbsReal.cxx:2903; RooAbsReal::getMaxValvirtual Int_t getMaxVal(const RooArgSet &vars) constAdvertise capability to determine maximum value of function for given set of observables.Definition RooAbsReal.cxx:3386; RooAbsReal::createChi2virtual RooFit::OwningPtr< RooAbsReal > createChi2(RooDataHist &data, const RooLinkedList &cmdList)Definition RooAbsReal.cxx:4200; RooAbsReal::offsetvirtual double offset() constDefinition RooAbsReal.h:371; RooAbsReal::_globalSelectCompstatic bool _globalSelectCompDefinition RooAbsReal.h:545; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgList::atRooAbsArg * at(Int_t idx) constReturn object at given index, or nullptr if index is out of range.Definition RooArgList.h:110; RooArgProxyAbstract interface for RooAbsArg proxy classes.Definition RooArgProxy.h:24; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooArgSet::snapshotRooArgSet * snapshot(bool deepCopy=true) constUse RooAbsCollection::snapshot(), but return as RooArgSet.Definition RooArgSet.h:154; RooArgSet::selectByNameRooArgSet * selectByName(const char *nameList, bool verbose=false) constUse RooAbsCollection::selectByName(), but return as RooArgSet.Definition RooArgSet.h:144; RooArgSet::selectCommonRooArgSet * selectCommon(const RooAbsCollection &refColl) constUse RooAbsCollection::selecCommon(), but return as RooArgSet.Definition RooArgSet.h:149; RooBrentRootFinderImplement the abstract 1-dimensional root finding interface using the Brent-Decker method.Definition RooBrentRootFinder.h:23; RooBrentRootFinder::findRootbool findRoot(double &result, double xlo, double xhi, double value=0) constDo the root finding using the Brent-Decker method.Definition RooBrentRoo",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:235870,Integrability,interface,interface,235870,"tRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgList::atRooAbsArg * at(Int_t idx) constReturn object at given index, or nullptr if index is out of range.Definition RooArgList.h:110; RooArgProxyAbstract interface for RooAbsArg proxy classes.Definition RooArgProxy.h:24; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooArgSet::snapshotRooArgSet * snapshot(bool deepCopy=true) constUse RooAbsCollection::snapshot(), but return as RooArgSet.Definition RooArgSet.h:154; RooArgSet::selectByNameRooArgSet * selectByName(const char *nameList, bool verbose=false) constUse RooAbsCollection::selectByName(), but return as RooArgSet.Definition RooArgSet.h:144; RooArgSet::selectCommonRooArgSet * selectCommon(const RooAbsCollection &refColl) constUse RooAbsCollection::selecCommon(), but return as RooArgSet.Definition RooArgSet.h:149; RooBrentRootFinderImplement the abstract 1-dimensional root finding interface using the Brent-Decker method.Definition RooBrentRootFinder.h:23; RooBrentRootFinder::findRootbool findRoot(double &result, double xlo, double xhi, double value=0) constDo the root finding using the Brent-Decker method.Definition RooBrentRootFinder.cxx:60; RooCategoryObject to represent discrete states.Definition RooCategory.h:28; RooCmdArgNamed container for two doubles, two integers two object points and three string pointers that can be...Definition RooCmdArg.h:26; RooCmdArg::nonestatic const RooCmdArg & none()Return reference to null argument.Definition RooCmdArg.cxx:48; RooCmdArg::getStringconst char * getString(Int_t idx) constReturn string stored in slot idx.Definition RooCmdArg.h:95; RooCmdArg::setStringvoid setString(Int_t idx, const char *value)Definition RooCmdArg.h:78; RooCmdConfigConfigurable parser for RooCmdArg named arguments.Definition RooCmdConfig.h:32; RooCmdConfig::defineMutexvoid defineMutex(const char *head, Args_t &&... tail)Define argu",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:243713,Integrability,interface,interface,243713,"...Definition RooFitResult.cxx:1124; RooFitResult::floatParsFinalconst RooArgList & floatParsFinal() constReturn list of floating parameters after fit.Definition RooFitResult.h:111; RooFitResult::createHessePdfRooAbsPdf * createHessePdf(const RooArgSet &params) constReturn a p.d.f that represents the fit result as a multi-variate probability densisty function on the...Definition RooFitResult.cxx:1260; RooFit::Detail::CodeSquashContextA class to maintain the context for squashing of RooFit models into code.Definition CodeSquashContext.h:42; RooFit::EvalContextDefinition EvalContext.h:84; RooFit::EvalContext::atstd::span< const double > at(RooAbsArg const *arg, RooAbsArg const *caller=nullptr)Definition EvalContext.cxx:35; RooFit::EvalContext::outputstd::span< double > output()Definition EvalContext.h:112; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooFunctorLightweight interface adaptor that exports a RooAbsPdf as a functor.Definition RooFunctor.h:25; RooHistGraphical representation of binned data based on the TGraphAsymmErrors class.Definition RooHist.h:29; RooLinkedListCollection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list...Definition RooLinkedList.h:44; RooLinkedList::Deletevoid Delete(Option_t *o=nullptr) overrideRemove all elements in collection and delete all elements NB: Collection does not own elements,...Definition RooLinkedList.cxx:578; RooLinkedList::Addvirtual void Add(TObject *arg)Definition RooLinkedList.h:73; RooLinkedList::beginRooLinkedListIterImpl begin() constDefinition RooLinkedList.cxx:761; RooLinkedList::FindObjectTObject * FindObject(const char *name) const overrideReturn pointer to object with given name.Definition RooLinkedList.cxx:534; RooMomentDefinition RooMoment.h:26; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cx",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:245010,Integrability,integrat,integrators,245010,"pointers in a doubly linked list...Definition RooLinkedList.h:44; RooLinkedList::Deletevoid Delete(Option_t *o=nullptr) overrideRemove all elements in collection and delete all elements NB: Collection does not own elements,...Definition RooLinkedList.cxx:578; RooLinkedList::Addvirtual void Add(TObject *arg)Definition RooLinkedList.h:73; RooLinkedList::beginRooLinkedListIterImpl begin() constDefinition RooLinkedList.cxx:761; RooLinkedList::FindObjectTObject * FindObject(const char *name) const overrideReturn pointer to object with given name.Definition RooLinkedList.cxx:534; RooMomentDefinition RooMoment.h:26; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::isActivebool isActive(T self, RooFit::MsgTopic topic, RooFit::MsgLevel level)Check if logging is active for given object/topic/RooFit::MsgLevel combination.Definition RooMsgService.h:186; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooNumIntConfig::defaultConfigstatic RooNumIntConfig & defaultConfig()Return reference to instance of default numeric integrator configuration object.Definition RooNumIntConfig.cxx:44; RooParamBinningImplementation of RooAbsBinning that constructs a binning with a range definition that depends on ext...Definition RooParamBinning.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::removevoid remove(const char *name=nullptr, bool deleteToo=true)Remove object with given name, or last object added if no name is given.Definition RooPlot.cxx:868; RooPlot::drawBeforebool drawBefore(const char *before, const char *target)Change the order in which our contained objects are drawn so that the target object is drawn just bef...Definition RooPlot.cxx:906; RooPlot::findObjectTObject * findObject(const char *name, const TClass *tClass=nullptr) constFi",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:245197,Integrability,integrat,integrator,245197,"nd delete all elements NB: Collection does not own elements,...Definition RooLinkedList.cxx:578; RooLinkedList::Addvirtual void Add(TObject *arg)Definition RooLinkedList.h:73; RooLinkedList::beginRooLinkedListIterImpl begin() constDefinition RooLinkedList.cxx:761; RooLinkedList::FindObjectTObject * FindObject(const char *name) const overrideReturn pointer to object with given name.Definition RooLinkedList.cxx:534; RooMomentDefinition RooMoment.h:26; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::isActivebool isActive(T self, RooFit::MsgTopic topic, RooFit::MsgLevel level)Check if logging is active for given object/topic/RooFit::MsgLevel combination.Definition RooMsgService.h:186; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooNumIntConfig::defaultConfigstatic RooNumIntConfig & defaultConfig()Return reference to instance of default numeric integrator configuration object.Definition RooNumIntConfig.cxx:44; RooParamBinningImplementation of RooAbsBinning that constructs a binning with a range definition that depends on ext...Definition RooParamBinning.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::removevoid remove(const char *name=nullptr, bool deleteToo=true)Remove object with given name, or last object added if no name is given.Definition RooPlot.cxx:868; RooPlot::drawBeforebool drawBefore(const char *before, const char *target)Change the order in which our contained objects are drawn so that the target object is drawn just bef...Definition RooPlot.cxx:906; RooPlot::findObjectTObject * findObject(const char *name, const TClass *tClass=nullptr) constFind the named object in our list of items and return a pointer to it.Definition RooPlot.cxx:942; RooPlot::getNormVarsconst RooArgSet * getNormVars() constDefinition",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:245366,Integrability,depend,depends,245366,"st.h:73; RooLinkedList::beginRooLinkedListIterImpl begin() constDefinition RooLinkedList.cxx:761; RooLinkedList::FindObjectTObject * FindObject(const char *name) const overrideReturn pointer to object with given name.Definition RooLinkedList.cxx:534; RooMomentDefinition RooMoment.h:26; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::isActivebool isActive(T self, RooFit::MsgTopic topic, RooFit::MsgLevel level)Check if logging is active for given object/topic/RooFit::MsgLevel combination.Definition RooMsgService.h:186; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooNumIntConfig::defaultConfigstatic RooNumIntConfig & defaultConfig()Return reference to instance of default numeric integrator configuration object.Definition RooNumIntConfig.cxx:44; RooParamBinningImplementation of RooAbsBinning that constructs a binning with a range definition that depends on ext...Definition RooParamBinning.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::removevoid remove(const char *name=nullptr, bool deleteToo=true)Remove object with given name, or last object added if no name is given.Definition RooPlot.cxx:868; RooPlot::drawBeforebool drawBefore(const char *before, const char *target)Change the order in which our contained objects are drawn so that the target object is drawn just bef...Definition RooPlot.cxx:906; RooPlot::findObjectTObject * findObject(const char *name, const TClass *tClass=nullptr) constFind the named object in our list of items and return a pointer to it.Definition RooPlot.cxx:942; RooPlot::getNormVarsconst RooArgSet * getNormVars() constDefinition RooPlot.h:152; RooPlot::GetMaximumdouble GetMaximum(double maxval=FLT_MAX) constDefinition RooPlot.cxx:1272; RooPlot::getAttLineTAttLine * getAttLine(const char *name=",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:249739,Integrability,wrap,wrapper,249739,"s.Definition RooRealIntegral.h:29; RooRealIntegral::numIntRealVarsconst RooArgSet & numIntRealVars() constDefinition RooRealIntegral.h:48; RooRealIntegral::setAllowComponentSelectionvoid setAllowComponentSelection(bool allow)Set component selection to be allowed/forbidden.Definition RooRealIntegral.cxx:1031; RooRealIntegral::Classstatic TClass * Class(); RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::setValvoid setVal(double value) overrideSet value of variable to 'value'.Definition RooRealVar.cxx:242; RooRealVar::setBinningvoid setBinning(const RooAbsBinning &binning, const char *name=nullptr)Add given binning under name 'name' with this variable.Definition RooRealVar.cxx:403; RooRealVar::setBinsvoid setBins(Int_t nBins, const char *name=nullptr)Create a uniform binning under name 'name' for this variable.Definition RooRealVar.cxx:396; RooSecondMomentDefinition RooSecondMoment.h:27; RooStringViewThe RooStringView is a wrapper around a C-style string that can also be constructed from a std::strin...Definition RooStringView.h:27; RooVectorDataStore::RealVector::setBuffervoid setBuffer(RooAbsReal *real, double *newBuf)Definition RooVectorDataStore.h:248; RooVectorDataStoreUses std::vector to store data columns.Definition RooVectorDataStore.h:41; RooVectorDataStore::addRealRealVector * addReal(RooAbsReal *real)Definition RooVectorDataStore.cxx:1244; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLineLine Attributes class.Definition TAttLine.h:18; TAttLine::SetLineStylevirtual void SetLineStyle(Style_t lstyle)Set the line style.Definition TAttLine.h:42; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Def",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:3601,Modifiability,variab,variable,3601,"RooProfileLL.h""; 70#include ""RooRealBinding.h""; 71#include ""RooRealIntegral.h""; 72#include ""RooRealVar.h""; 73#include ""RooSecondMoment.h""; 74#include ""RooVectorDataStore.h""; 75#include ""TreeReadBuffer.h""; 76#include ""ValueChecking.h""; 77 ; 78#include ""ROOT/StringUtils.hxx""; 79#include ""Compression.h""; 80#include ""Math/IFunction.h""; 81#include ""TMath.h""; 82#include ""TObjString.h""; 83#include ""TTree.h""; 84#include ""TH1.h""; 85#include ""TH2.h""; 86#include ""TH3.h""; 87#include ""TBranch.h""; 88#include ""TLeaf.h""; 89#include ""TAttLine.h""; 90#include ""TF1.h""; 91#include ""TF2.h""; 92#include ""TF3.h""; 93#include ""TMatrixD.h""; 94#include ""TVector.h""; 95#include ""strlcpy.h""; 96#ifndef NDEBUG; 97#include <TSystem.h> // To print stack traces when caching errors are detected; 98#endif; 99 ; 100#include <iomanip>; 101#include <iostream>; 102#include <limits>; 103#include <sstream>; 104#include <sys/types.h>; 105 ; 106namespace {; 107 ; 108// Internal helper RooAbsFunc that evaluates the scaled data-weighted average of; 109// given RooAbsReal as a function of a single variable using the RooFit::Evaluator.; 110class ScaledDataWeightedAverage : public RooAbsFunc {; 111public:; 112 ScaledDataWeightedAverage(RooAbsReal const &arg, RooAbsData const &data, double scaleFactor, RooAbsRealLValue &var); 113 : RooAbsFunc{1}, _var{var}, _dataWeights{data.getWeightBatch(0, data.numEntries())}, _scaleFactor{scaleFactor}; 114 {; 115 _arg = RooFit::Detail::compileForNormSet(arg, *data.get());; 116 _arg->recursiveRedirectServers(RooArgList{var});; 117 _evaluator = std::make_unique<RooFit::Evaluator>(*_arg);; 118 std::stack<std::vector<double>>{}.swap(_vectorBuffers);; 119 auto dataSpans = RooFit::BatchModeDataHelpers::getDataSpans(data, """", nullptr, /*skipZeroWeights=*/false,; 120 /*takeGlobalObservablesFromData=*/true,; 121 _vectorBuffers);; 122 for (auto const& item : dataSpans) {; 123 _evaluator->setInput(item.first->GetName(), item.second, false);; 124 }; 125 }; 126 ; 127 double operator()(const dou",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:9498,Modifiability,variab,variable,9498,"urn (getVal()==value) ;; 253}; 254 ; 255 ; 256 ; 257////////////////////////////////////////////////////////////////////////////////; 258/// Equality operator when comparing to another RooAbsArg.; 259/// Only functional when the other arg is a RooAbsReal; 260 ; 261bool RooAbsReal::operator==(const RooAbsArg& other) const; 262{; 263 const RooAbsReal* otherReal = dynamic_cast<const RooAbsReal*>(&other) ;; 264 return otherReal ? operator==(otherReal->getVal()) : false ;; 265}; 266 ; 267 ; 268////////////////////////////////////////////////////////////////////////////////; 269 ; 270bool RooAbsReal::isIdentical(const RooAbsArg& other, bool assumeSameType) const; 271{; 272 if (!assumeSameType) {; 273 const RooAbsReal* otherReal = dynamic_cast<const RooAbsReal*>(&other) ;; 274 return otherReal ? operator==(otherReal->getVal()) : false ;; 275 } else {; 276 return getVal() == static_cast<const RooAbsReal&>(other).getVal();; 277 }; 278}; 279 ; 280 ; 281////////////////////////////////////////////////////////////////////////////////; 282/// Return this variable's title string. If appendUnit is true and; 283/// this variable has units, also append a string "" (<unit>)"".; 284 ; 285TString RooAbsReal::getTitle(bool appendUnit) const; 286{; 287 if(appendUnit && 0 != strlen(getUnit())) {; 288 return std::string{GetTitle()} + "" ("" + getUnit() + "")"";; 289 }; 290 return GetTitle();; 291}; 292 ; 293 ; 294 ; 295////////////////////////////////////////////////////////////////////////////////; 296/// Return value of object. If the cache is clean, return the; 297/// cached value, otherwise recalculate on the fly and refill; 298/// the cache; 299 ; 300double RooAbsReal::getValV(const RooArgSet* nset) const; 301{; 302 if (nset && nset->uniqueId().value() != _lastNormSetId) {; 303 const_cast<RooAbsReal*>(this)->setProxyNormSet(nset);; 304 _lastNormSetId = nset->uniqueId().value();; 305 }; 306 ; 307 if (isValueDirtyAndClear()) {; 308 _value = traceEval(nullptr) ;; 309 // clearValueDirty() ;; 31",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:9562,Modifiability,variab,variable,9562,"////; 258/// Equality operator when comparing to another RooAbsArg.; 259/// Only functional when the other arg is a RooAbsReal; 260 ; 261bool RooAbsReal::operator==(const RooAbsArg& other) const; 262{; 263 const RooAbsReal* otherReal = dynamic_cast<const RooAbsReal*>(&other) ;; 264 return otherReal ? operator==(otherReal->getVal()) : false ;; 265}; 266 ; 267 ; 268////////////////////////////////////////////////////////////////////////////////; 269 ; 270bool RooAbsReal::isIdentical(const RooAbsArg& other, bool assumeSameType) const; 271{; 272 if (!assumeSameType) {; 273 const RooAbsReal* otherReal = dynamic_cast<const RooAbsReal*>(&other) ;; 274 return otherReal ? operator==(otherReal->getVal()) : false ;; 275 } else {; 276 return getVal() == static_cast<const RooAbsReal&>(other).getVal();; 277 }; 278}; 279 ; 280 ; 281////////////////////////////////////////////////////////////////////////////////; 282/// Return this variable's title string. If appendUnit is true and; 283/// this variable has units, also append a string "" (<unit>)"".; 284 ; 285TString RooAbsReal::getTitle(bool appendUnit) const; 286{; 287 if(appendUnit && 0 != strlen(getUnit())) {; 288 return std::string{GetTitle()} + "" ("" + getUnit() + "")"";; 289 }; 290 return GetTitle();; 291}; 292 ; 293 ; 294 ; 295////////////////////////////////////////////////////////////////////////////////; 296/// Return value of object. If the cache is clean, return the; 297/// cached value, otherwise recalculate on the fly and refill; 298/// the cache; 299 ; 300double RooAbsReal::getValV(const RooArgSet* nset) const; 301{; 302 if (nset && nset->uniqueId().value() != _lastNormSetId) {; 303 const_cast<RooAbsReal*>(this)->setProxyNormSet(nset);; 304 _lastNormSetId = nset->uniqueId().value();; 305 }; 306 ; 307 if (isValueDirtyAndClear()) {; 308 _value = traceEval(nullptr) ;; 309 // clearValueDirty() ;; 310 }; 311 ; 312 return hideOffset() ? _value + offset() : _value;; 313}; 314 ; 315 ; 316//////////////////////////////////////////",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:12612,Modifiability,config,configuration,12612,"ion set; 345/// that should be applied to the integrand of which the integral is requested.; 346/// For certain operator p.d.f it is useful to overload this function rather; 347/// than analyticalIntegralWN() as the additional normalization information; 348/// may be useful in determining a more efficient decomposition of the; 349/// requested integral.; 350 ; 351Int_t RooAbsReal::getAnalyticalIntegralWN(RooArgSet& allDeps, RooArgSet& analDeps,; 352 const RooArgSet* /*normSet*/, const char* rangeName) const; 353{; 354 return _forceNumInt ? 0 : getAnalyticalIntegral(allDeps,analDeps,rangeName) ;; 355}; 356 ; 357 ; 358 ; 359////////////////////////////////////////////////////////////////////////////////; 360/// Interface function getAnalyticalIntergral advertises the; 361/// analytical integrals that are supported. 'integSet'; 362/// is the set of dependents for which integration is requested. The; 363/// function should copy the subset of dependents it can analytically; 364/// integrate to anaIntSet and return a unique identification code for; 365/// this integration configuration. If no integration can be; 366/// performed, zero should be returned.; 367 ; 368Int_t RooAbsReal::getAnalyticalIntegral(RooArgSet& /*integSet*/, RooArgSet& /*anaIntSet*/, const char* /*rangeName*/) const; 369{; 370 return 0 ;; 371}; 372 ; 373 ; 374 ; 375////////////////////////////////////////////////////////////////////////////////; 376/// Implements the actual analytical integral(s) advertised by; 377/// getAnalyticalIntegral. This functions will only be called with; 378/// codes returned by getAnalyticalIntegral, except code zero.; 379 ; 380double RooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName) const; 381{; 382// cout << ""RooAbsReal::analyticalIntegralWN("" << GetName() << "") code = "" << code << "" normSet = "" << (normSet?*normSet:RooArgSet()) << std::endl ;; 383 if (code==0) return getVal(normSet) ;; 384 return analyticalIntegral(code,rangeName",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:14298,Modifiability,variab,variable,14298,"rned by getAnalyticalIntegral, except code zero.; 379 ; 380double RooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName) const; 381{; 382// cout << ""RooAbsReal::analyticalIntegralWN("" << GetName() << "") code = "" << code << "" normSet = "" << (normSet?*normSet:RooArgSet()) << std::endl ;; 383 if (code==0) return getVal(normSet) ;; 384 return analyticalIntegral(code,rangeName) ;; 385}; 386 ; 387 ; 388 ; 389////////////////////////////////////////////////////////////////////////////////; 390/// Implements the actual analytical integral(s) advertised by; 391/// getAnalyticalIntegral. This functions will only be called with; 392/// codes returned by getAnalyticalIntegral, except code zero.; 393 ; 394double RooAbsReal::analyticalIntegral(Int_t code, const char* /*rangeName*/) const; 395{; 396 // By default no analytical integrals are implemented; 397 coutF(Eval) << ""RooAbsReal::analyticalIntegral("" << GetName() << "") code "" << code << "" not implemented"" << std::endl ;; 398 return 0 ;; 399}; 400 ; 401 ; 402 ; 403////////////////////////////////////////////////////////////////////////////////; 404/// Get the label associated with the variable; 405 ; 406const char *RooAbsReal::getPlotLabel() const; 407{; 408 return _label.IsNull() ? fName.Data() : _label.Data();; 409}; 410 ; 411 ; 412 ; 413////////////////////////////////////////////////////////////////////////////////; 414/// Set the label associated with this variable; 415 ; 416void RooAbsReal::setPlotLabel(const char *label); 417{; 418 _label= label;; 419}; 420 ; 421 ; 422 ; 423////////////////////////////////////////////////////////////////////////////////; 424///Read object contents from stream (dummy for now); 425 ; 426bool RooAbsReal::readFromStream(std::istream& /*is*/, bool /*compact*/, bool /*verbose*/); 427{; 428 return false ;; 429}; 430 ; 431 ; 432 ; 433////////////////////////////////////////////////////////////////////////////////; 434///Write object contents to stream (dum",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:14580,Modifiability,variab,variable,14580,"urn 0 ;; 399}; 400 ; 401 ; 402 ; 403////////////////////////////////////////////////////////////////////////////////; 404/// Get the label associated with the variable; 405 ; 406const char *RooAbsReal::getPlotLabel() const; 407{; 408 return _label.IsNull() ? fName.Data() : _label.Data();; 409}; 410 ; 411 ; 412 ; 413////////////////////////////////////////////////////////////////////////////////; 414/// Set the label associated with this variable; 415 ; 416void RooAbsReal::setPlotLabel(const char *label); 417{; 418 _label= label;; 419}; 420 ; 421 ; 422 ; 423////////////////////////////////////////////////////////////////////////////////; 424///Read object contents from stream (dummy for now); 425 ; 426bool RooAbsReal::readFromStream(std::istream& /*is*/, bool /*compact*/, bool /*verbose*/); 427{; 428 return false ;; 429}; 430 ; 431 ; 432 ; 433////////////////////////////////////////////////////////////////////////////////; 434///Write object contents to stream (dummy for now); 435 ; 436void RooAbsReal::writeToStream(std::ostream& /*os*/, bool /*compact*/) const; 437{; 438}; 439 ; 440 ; 441 ; 442////////////////////////////////////////////////////////////////////////////////; 443/// Print object value; 444 ; 445void RooAbsReal::printValue(std::ostream& os) const; 446{; 447 os << getVal() ;; 448}; 449 ; 450 ; 451 ; 452////////////////////////////////////////////////////////////////////////////////; 453/// Structure printing; 454 ; 455void RooAbsReal::printMultiline(std::ostream& os, Int_t contents, bool verbose, TString indent) const; 456{; 457 RooAbsArg::printMultiline(os,contents,verbose,indent) ;; 458 os << indent << ""--- RooAbsReal ---"" << std::endl;; 459 TString unit(_unit);; 460 if(!unit.IsNull()) unit.Prepend(' ');; 461 //os << indent << "" Value = "" << getVal() << unit << std::endl;; 462 os << std::endl << indent << "" Plot label is \"""" << getPlotLabel() << ""\"""" << ""\n"";; 463}; 464 ; 465 ; 466////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:17496,Modifiability,variab,variables,17496,"); 472{; 473 // Construct name of profile object; 474 auto name = std::string(GetName()) + ""_Profile["";; 475 bool first = true;; 476 for (auto const& arg : paramsOfInterest) {; 477 if (first) {; 478 first = false ;; 479 } else {; 480 name.append("","") ;; 481 }; 482 name.append(arg->GetName()) ;; 483 }; 484 name.append(""]"") ;; 485 ; 486 // Create and return profile object; 487 auto out = std::make_unique<RooProfileLL>(name.c_str(),(std::string(""Profile of "") + GetTitle()).c_str(),*this,paramsOfInterest);; 488 return RooFit::makeOwningPtr<RooAbsReal>(std::move(out));; 489}; 490 ; 491 ; 492 ; 493 ; 494 ; 495 ; 496////////////////////////////////////////////////////////////////////////////////; 497/// Create an object that represents the integral of the function over one or more observables listed in `iset`.; 498/// The actual integration calculation is only performed when the returned object is evaluated. The name; 499/// of the integral object is automatically constructed from the name of the input function, the variables; 500/// it integrates and the range integrates over.; 501///; 502/// \note The integral over a PDF is usually not normalised (*i.e.*, it is usually not; 503/// 1 when integrating the PDF over the full range). In fact, this integral is used *to compute*; 504/// the normalisation of each PDF. See the [rf110 tutorial](group__tutorial__roofit.html); 505/// for details on PDF normalisation.; 506///; 507/// The following named arguments are accepted; 508/// | | Effect on integral creation; 509/// |--|-------------------------------; 510/// | `NormSet(const RooArgSet&)` | Specify normalization set, mostly useful when working with PDFs; 511/// | `NumIntConfig(const RooNumIntConfig&)` | Use given configuration for any numeric integration, if necessary; 512/// | `Range(const char* name)` | Integrate only over given range. Multiple ranges may be specified by passing multiple Range() arguments; 513 ; 514RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(cons",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:18203,Modifiability,config,configuration,18203,"/////////////////////////////////////////////////////////; 497/// Create an object that represents the integral of the function over one or more observables listed in `iset`.; 498/// The actual integration calculation is only performed when the returned object is evaluated. The name; 499/// of the integral object is automatically constructed from the name of the input function, the variables; 500/// it integrates and the range integrates over.; 501///; 502/// \note The integral over a PDF is usually not normalised (*i.e.*, it is usually not; 503/// 1 when integrating the PDF over the full range). In fact, this integral is used *to compute*; 504/// the normalisation of each PDF. See the [rf110 tutorial](group__tutorial__roofit.html); 505/// for details on PDF normalisation.; 506///; 507/// The following named arguments are accepted; 508/// | | Effect on integral creation; 509/// |--|-------------------------------; 510/// | `NormSet(const RooArgSet&)` | Specify normalization set, mostly useful when working with PDFs; 511/// | `NumIntConfig(const RooNumIntConfig&)` | Use given configuration for any numeric integration, if necessary; 512/// | `Range(const char* name)` | Integrate only over given range. Multiple ranges may be specified by passing multiple Range() arguments; 513 ; 514RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2,; 515 const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5,; 516 const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 517{; 518 // Define configuration for this method; 519 RooCmdConfig pc(""RooAbsReal::createIntegral("" + std::string(GetName()) + "")"");; 520 pc.defineString(""rangeName"",""RangeWithName"",0,"""",true) ;; 521 pc.defineSet(""normSet"",""NormSet"",0,nullptr) ;; 522 pc.defineObject(""numIntConfig"",""NumIntConfig"",0,nullptr) ;; 523 ; 524 // Process & check varargs; 525 pc.process(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8) ;; 526 if (!pc",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:18712,Modifiability,config,configuration,18712,"The integral over a PDF is usually not normalised (*i.e.*, it is usually not; 503/// 1 when integrating the PDF over the full range). In fact, this integral is used *to compute*; 504/// the normalisation of each PDF. See the [rf110 tutorial](group__tutorial__roofit.html); 505/// for details on PDF normalisation.; 506///; 507/// The following named arguments are accepted; 508/// | | Effect on integral creation; 509/// |--|-------------------------------; 510/// | `NormSet(const RooArgSet&)` | Specify normalization set, mostly useful when working with PDFs; 511/// | `NumIntConfig(const RooNumIntConfig&)` | Use given configuration for any numeric integration, if necessary; 512/// | `Range(const char* name)` | Integrate only over given range. Multiple ranges may be specified by passing multiple Range() arguments; 513 ; 514RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2,; 515 const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5,; 516 const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 517{; 518 // Define configuration for this method; 519 RooCmdConfig pc(""RooAbsReal::createIntegral("" + std::string(GetName()) + "")"");; 520 pc.defineString(""rangeName"",""RangeWithName"",0,"""",true) ;; 521 pc.defineSet(""normSet"",""NormSet"",0,nullptr) ;; 522 pc.defineObject(""numIntConfig"",""NumIntConfig"",0,nullptr) ;; 523 ; 524 // Process & check varargs; 525 pc.process(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8) ;; 526 if (!pc.ok(true)) {; 527 return nullptr;; 528 }; 529 ; 530 // Extract values from named arguments; 531 const char* rangeName = pc.getString(""rangeName"",nullptr,true) ;; 532 const RooArgSet* nset = pc.getSet(""normSet"",nullptr);; 533 const RooNumIntConfig* cfg = static_cast<const RooNumIntConfig*>(pc.getObject(""numIntConfig"",nullptr)) ;; 534 ; 535 return createIntegral(iset,nset,cfg,rangeName) ;; 536}; 537 ; 538 ; 539 ; 540 ; 541 ; 542////////////////////////////////////////",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:19946,Modifiability,variab,variables,19946,"Set"",0,nullptr) ;; 522 pc.defineObject(""numIntConfig"",""NumIntConfig"",0,nullptr) ;; 523 ; 524 // Process & check varargs; 525 pc.process(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8) ;; 526 if (!pc.ok(true)) {; 527 return nullptr;; 528 }; 529 ; 530 // Extract values from named arguments; 531 const char* rangeName = pc.getString(""rangeName"",nullptr,true) ;; 532 const RooArgSet* nset = pc.getSet(""normSet"",nullptr);; 533 const RooNumIntConfig* cfg = static_cast<const RooNumIntConfig*>(pc.getObject(""numIntConfig"",nullptr)) ;; 534 ; 535 return createIntegral(iset,nset,cfg,rangeName) ;; 536}; 537 ; 538 ; 539 ; 540 ; 541 ; 542////////////////////////////////////////////////////////////////////////////////; 543/// Create an object that represents the integral of the function over one or more observables listed in iset.; 544/// The actual integration calculation is only performed when the return object is evaluated. The name; 545/// of the integral object is automatically constructed from the name of the input function, the variables; 546/// it integrates and the range integrates over. If nset is specified the integrand is request; 547/// to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; 548/// the integral is performed over the named range, otherwise it is performed over the domain of each; 549/// integrated observable. If cfg is specified it will be used to configure any numeric integration; 550/// aspect of the integral. It will not force the integral to be performed numerically, which is; 551/// decided automatically by RooRealIntegral.; 552 ; 553RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset,; 554 const RooNumIntConfig* cfg, const char* rangeName) const; 555{; 556 if (!rangeName || strchr(rangeName,',')==nullptr) {; 557 // Simple case: integral over full range or single limited range; 558 return createIntObj(iset,nset,cfg,rangeName);; 559 }; 560 ; 561 // Integral over mult",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:20339,Modifiability,config,configure,20339,"tConfig* cfg = static_cast<const RooNumIntConfig*>(pc.getObject(""numIntConfig"",nullptr)) ;; 534 ; 535 return createIntegral(iset,nset,cfg,rangeName) ;; 536}; 537 ; 538 ; 539 ; 540 ; 541 ; 542////////////////////////////////////////////////////////////////////////////////; 543/// Create an object that represents the integral of the function over one or more observables listed in iset.; 544/// The actual integration calculation is only performed when the return object is evaluated. The name; 545/// of the integral object is automatically constructed from the name of the input function, the variables; 546/// it integrates and the range integrates over. If nset is specified the integrand is request; 547/// to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; 548/// the integral is performed over the named range, otherwise it is performed over the domain of each; 549/// integrated observable. If cfg is specified it will be used to configure any numeric integration; 550/// aspect of the integral. It will not force the integral to be performed numerically, which is; 551/// decided automatically by RooRealIntegral.; 552 ; 553RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset,; 554 const RooNumIntConfig* cfg, const char* rangeName) const; 555{; 556 if (!rangeName || strchr(rangeName,',')==nullptr) {; 557 // Simple case: integral over full range or single limited range; 558 return createIntObj(iset,nset,cfg,rangeName);; 559 }; 560 ; 561 // Integral over multiple ranges; 562 std::vector<std::string> tokens = ROOT::Split(rangeName, "","");; 563 ; 564 if(RooHelpers::checkIfRangesOverlap(iset, tokens)) {; 565 std::stringstream errMsg;; 566 errMsg << GetName() << "" : integrating with respect to the variables "" << iset << "" on the ranges \"""" << rangeName; 567 << ""\"" is not possible because the ranges are overlapping"";; 568 const std::string errMsgString = errMsg.str();; 569 coutE(Integra",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:21161,Modifiability,variab,variables,21161," input function, the variables; 546/// it integrates and the range integrates over. If nset is specified the integrand is request; 547/// to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; 548/// the integral is performed over the named range, otherwise it is performed over the domain of each; 549/// integrated observable. If cfg is specified it will be used to configure any numeric integration; 550/// aspect of the integral. It will not force the integral to be performed numerically, which is; 551/// decided automatically by RooRealIntegral.; 552 ; 553RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset,; 554 const RooNumIntConfig* cfg, const char* rangeName) const; 555{; 556 if (!rangeName || strchr(rangeName,',')==nullptr) {; 557 // Simple case: integral over full range or single limited range; 558 return createIntObj(iset,nset,cfg,rangeName);; 559 }; 560 ; 561 // Integral over multiple ranges; 562 std::vector<std::string> tokens = ROOT::Split(rangeName, "","");; 563 ; 564 if(RooHelpers::checkIfRangesOverlap(iset, tokens)) {; 565 std::stringstream errMsg;; 566 errMsg << GetName() << "" : integrating with respect to the variables "" << iset << "" on the ranges \"""" << rangeName; 567 << ""\"" is not possible because the ranges are overlapping"";; 568 const std::string errMsgString = errMsg.str();; 569 coutE(Integration) << errMsgString << std::endl;; 570 throw std::invalid_argument(errMsgString);; 571 }; 572 ; 573 RooArgSet components ;; 574 for (const std::string& token : tokens) {; 575 components.addOwned(std::unique_ptr<RooAbsReal>{createIntObj(iset,nset,cfg, token.c_str())});; 576 }; 577 ; 578 const std::string title = std::string(""Integral of "") + GetTitle();; 579 const std::string fullName = std::string(GetName()) + integralNameSuffix(iset,nset,rangeName).Data();; 580 ; 581 auto out = std::make_unique<RooAddition>(fullName.c_str(), title.c_str(), components);; 582 out->a",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:22563,Modifiability,variab,variables,22563,"tokens) {; 575 components.addOwned(std::unique_ptr<RooAbsReal>{createIntObj(iset,nset,cfg, token.c_str())});; 576 }; 577 ; 578 const std::string title = std::string(""Integral of "") + GetTitle();; 579 const std::string fullName = std::string(GetName()) + integralNameSuffix(iset,nset,rangeName).Data();; 580 ; 581 auto out = std::make_unique<RooAddition>(fullName.c_str(), title.c_str(), components);; 582 out->addOwnedComponents(std::move(components));; 583 return RooFit::makeOwningPtr<RooAbsReal>(std::move(out));; 584}; 585 ; 586 ; 587 ; 588////////////////////////////////////////////////////////////////////////////////; 589/// Internal utility function for createIntegral() that creates the actual integral object.; 590RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntObj(const RooArgSet& iset2, const RooArgSet* nset2,; 591 const RooNumIntConfig* cfg, const char* rangeName) const; 592{; 593 // Make internal use copies of iset and nset; 594 RooArgSet iset(iset2) ;; 595 const RooArgSet* nset = nset2 ;; 596 ; 597 ; 598 // Initialize local variables perparing for recursive loop; 599 bool error = false ;; 600 const RooAbsReal* integrand = this ;; 601 std::unique_ptr<RooAbsReal> integral;; 602 ; 603 // Handle trivial case of no integration here explicitly; 604 if (iset.empty()) {; 605 ; 606 const std::string title = std::string(""Integral of "") + GetTitle();; 607 const std::string name = std::string(GetName()) + integralNameSuffix(iset,nset,rangeName).Data();; 608 ; 609 auto out = std::make_unique<RooRealIntegral>(name.c_str(), title.c_str(), *this, iset, nset, cfg, rangeName);; 610 return RooFit::makeOwningPtr<RooAbsReal>(std::move(out));; 611 }; 612 ; 613 // Process integration over remaining integration variables; 614 while(!iset.empty()) {; 615 ; 616 ; 617 // Find largest set of observables that can be integrated in one go; 618 RooArgSet innerSet ;; 619 findInnerMostIntegration(iset,innerSet,rangeName) ;; 620 ; 621 // If largest set of observables that can be integrated is",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:23240,Modifiability,variab,variables,23240,"unction for createIntegral() that creates the actual integral object.; 590RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntObj(const RooArgSet& iset2, const RooArgSet* nset2,; 591 const RooNumIntConfig* cfg, const char* rangeName) const; 592{; 593 // Make internal use copies of iset and nset; 594 RooArgSet iset(iset2) ;; 595 const RooArgSet* nset = nset2 ;; 596 ; 597 ; 598 // Initialize local variables perparing for recursive loop; 599 bool error = false ;; 600 const RooAbsReal* integrand = this ;; 601 std::unique_ptr<RooAbsReal> integral;; 602 ; 603 // Handle trivial case of no integration here explicitly; 604 if (iset.empty()) {; 605 ; 606 const std::string title = std::string(""Integral of "") + GetTitle();; 607 const std::string name = std::string(GetName()) + integralNameSuffix(iset,nset,rangeName).Data();; 608 ; 609 auto out = std::make_unique<RooRealIntegral>(name.c_str(), title.c_str(), *this, iset, nset, cfg, rangeName);; 610 return RooFit::makeOwningPtr<RooAbsReal>(std::move(out));; 611 }; 612 ; 613 // Process integration over remaining integration variables; 614 while(!iset.empty()) {; 615 ; 616 ; 617 // Find largest set of observables that can be integrated in one go; 618 RooArgSet innerSet ;; 619 findInnerMostIntegration(iset,innerSet,rangeName) ;; 620 ; 621 // If largest set of observables that can be integrated is empty set, problem was ill defined; 622 // Postpone error messaging and handling to end of function, exit loop here; 623 if (innerSet.empty()) {; 624 error = true ;; 625 break ;; 626 }; 627 ; 628 // Prepare name and title of integral to be created; 629 const std::string title = std::string(""Integral of "") + integrand->GetTitle();; 630 const std::string name = std::string(integrand->GetName()) + integrand->integralNameSuffix(innerSet,nset,rangeName).Data();; 631 ; 632 std::unique_ptr<RooAbsReal> innerIntegral = std::move(integral);; 633 ; 634 // Construct innermost integral; 635 integral = std::make_unique<RooRealIntegral>(name.c_str(),title.c",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:24675,Modifiability,parameteriz,parameterized,24675,"created; 629 const std::string title = std::string(""Integral of "") + integrand->GetTitle();; 630 const std::string name = std::string(integrand->GetName()) + integrand->integralNameSuffix(innerSet,nset,rangeName).Data();; 631 ; 632 std::unique_ptr<RooAbsReal> innerIntegral = std::move(integral);; 633 ; 634 // Construct innermost integral; 635 integral = std::make_unique<RooRealIntegral>(name.c_str(),title.c_str(),*integrand,innerSet,nset,cfg,rangeName);; 636 ; 637 // Integral of integral takes ownership of innermost integral; 638 if (innerIntegral) {; 639 integral->addOwnedComponents(std::move(innerIntegral));; 640 }; 641 ; 642 // Remove already integrated observables from to-do list; 643 iset.remove(innerSet) ;; 644 ; 645 // Send info message on recursion if needed; 646 if (integrand == this && !iset.empty()) {; 647 coutI(Integration) << GetName() << "" : multidimensional integration over observables with parameterized ranges in terms of other integrated observables detected, using recursive integration strategy to construct final integral"" << std::endl ;; 648 }; 649 ; 650 // Prepare for recursion, next integral should integrate last integrand; 651 integrand = integral.get();; 652 ; 653 ; 654 // Only need normalization set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.emp",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:25182,Modifiability,parameteriz,parameterized,25182,"d::move(innerIntegral));; 640 }; 641 ; 642 // Remove already integrated observables from to-do list; 643 iset.remove(innerSet) ;; 644 ; 645 // Send info message on recursion if needed; 646 if (integrand == this && !iset.empty()) {; 647 coutI(Integration) << GetName() << "" : multidimensional integration over observables with parameterized ranges in terms of other integrated observables detected, using recursive integration strategy to construct final integral"" << std::endl ;; 648 }; 649 ; 650 // Prepare for recursion, next integral should integrate last integrand; 651 integrand = integral.get();; 652 ; 653 ; 654 // Only need normalization set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::mov",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:26949,Modifiability,parameteriz,parameterized,26949," intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::move(integral));; 679 cachedIntegral->setCacheSource(true) ;; 680 if (integral->operMode()==ADirty) {; 681 cachedIntegral->setOperMode(ADirty) ;; 682 }; 683 //cachedIntegral->disableCache(true) ;; 684 return RooFit::makeOwningPtr<RooAbsReal>(std::move(cachedIntegral));; 685 }; 686 }; 687 ; 688 return RooFit::makeOwningPtr(std::move(integral));; 689}; 690 ; 691 ; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ra",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:27222,Modifiability,parameteriz,parameterized,27222,"ral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::move(integral));; 679 cachedIntegral->setCacheSource(true) ;; 680 if (integral->operMode()==ADirty) {; 681 cachedIntegral->setOperMode(ADirty) ;; 682 }; 683 //cachedIntegral->disableCache(true) ;; 684 return RooFit::makeOwningPtr<RooAbsReal>(std::move(cachedIntegral));; 685 }; 686 }; 687 ; 688 return RooFit::makeOwningPtr(std::move(integral));; 689}; 690 ; 691 ; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ranges depending on other integrated observables; 706 // c) integrated observables used in definition of any parameterized ranges of integrated observables; 707 RooArgSet obsWithFixedRange(allObs) ;; 708 RooArgSet obsWithParamRange ;; 709 RooArgSet obsServingAsRangeParams ;; 710 ; 711 // Loop over all integrated observables; 712 for (const auto aarg : allObs) {; 713 // Check if observable is real-valued lvalue; 714 if (auto arglv = dynamic_cast<RooAbsRealLValue*>(aarg)) {; 715 ; 716 // Check if range is parameterized; 717 RooAbsBinning& binning = arglv->getBinning(rangeName,false,true) ;; 718 if (binning.isParameterized()) {; 719 Roo",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:27257,Modifiability,parameteriz,parameterization,27257,"ral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::move(integral));; 679 cachedIntegral->setCacheSource(true) ;; 680 if (integral->operMode()==ADirty) {; 681 cachedIntegral->setOperMode(ADirty) ;; 682 }; 683 //cachedIntegral->disableCache(true) ;; 684 return RooFit::makeOwningPtr<RooAbsReal>(std::move(cachedIntegral));; 685 }; 686 }; 687 ; 688 return RooFit::makeOwningPtr(std::move(integral));; 689}; 690 ; 691 ; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ranges depending on other integrated observables; 706 // c) integrated observables used in definition of any parameterized ranges of integrated observables; 707 RooArgSet obsWithFixedRange(allObs) ;; 708 RooArgSet obsWithParamRange ;; 709 RooArgSet obsServingAsRangeParams ;; 710 ; 711 // Loop over all integrated observables; 712 for (const auto aarg : allObs) {; 713 // Check if observable is real-valued lvalue; 714 if (auto arglv = dynamic_cast<RooAbsRealLValue*>(aarg)) {; 715 ; 716 // Check if range is parameterized; 717 RooAbsBinning& binning = arglv->getBinning(rangeName,false,true) ;; 718 if (binning.isParameterized()) {; 719 Roo",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:27580,Modifiability,parameteriz,parameterized,27580,"///////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ranges depending on other integrated observables; 706 // c) integrated observables used in definition of any parameterized ranges of integrated observables; 707 RooArgSet obsWithFixedRange(allObs) ;; 708 RooArgSet obsWithParamRange ;; 709 RooArgSet obsServingAsRangeParams ;; 710 ; 711 // Loop over all integrated observables; 712 for (const auto aarg : allObs) {; 713 // Check if observable is real-valued lvalue; 714 if (auto arglv = dynamic_cast<RooAbsRealLValue*>(aarg)) {; 715 ; 716 // Check if range is parameterized; 717 RooAbsBinning& binning = arglv->getBinning(rangeName,false,true) ;; 718 if (binning.isParameterized()) {; 719 RooArgSet loBoundObs;; 720 RooArgSet hiBoundObs;; 721 binning.lowBoundFunc()->getObservables(&allObs, loBoundObs) ;; 722 binning.highBoundFunc()->getObservables(&allObs, hiBoundObs) ;; 723 ; 724 // Check if range parameterization depends on other integrated observables; 725 if (loBoundObs.overlaps(allObs) || hiBoundObs.overlaps(allObs)) {; 726 obsWithParamRange.add(*aarg) ;; 727 obsWithFixedRange.remove(*aarg) ;; 728 obsServingAsRangeParams.add(loBoundObs,false) ;; 729 obsServingAsRangeParams.add(hiBoundObs,false) ;; 730 }; 731 }; ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:27703,Modifiability,parameteriz,parameterized,27703,"///////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ranges depending on other integrated observables; 706 // c) integrated observables used in definition of any parameterized ranges of integrated observables; 707 RooArgSet obsWithFixedRange(allObs) ;; 708 RooArgSet obsWithParamRange ;; 709 RooArgSet obsServingAsRangeParams ;; 710 ; 711 // Loop over all integrated observables; 712 for (const auto aarg : allObs) {; 713 // Check if observable is real-valued lvalue; 714 if (auto arglv = dynamic_cast<RooAbsRealLValue*>(aarg)) {; 715 ; 716 // Check if range is parameterized; 717 RooAbsBinning& binning = arglv->getBinning(rangeName,false,true) ;; 718 if (binning.isParameterized()) {; 719 RooArgSet loBoundObs;; 720 RooArgSet hiBoundObs;; 721 binning.lowBoundFunc()->getObservables(&allObs, loBoundObs) ;; 722 binning.highBoundFunc()->getObservables(&allObs, hiBoundObs) ;; 723 ; 724 // Check if range parameterization depends on other integrated observables; 725 if (loBoundObs.overlaps(allObs) || hiBoundObs.overlaps(allObs)) {; 726 obsWithParamRange.add(*aarg) ;; 727 obsWithFixedRange.remove(*aarg) ;; 728 obsServingAsRangeParams.add(loBoundObs,false) ;; 729 obsServingAsRangeParams.add(hiBoundObs,false) ;; 730 }; 731 }; ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:28103,Modifiability,parameteriz,parameterized,28103,"///////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ranges depending on other integrated observables; 706 // c) integrated observables used in definition of any parameterized ranges of integrated observables; 707 RooArgSet obsWithFixedRange(allObs) ;; 708 RooArgSet obsWithParamRange ;; 709 RooArgSet obsServingAsRangeParams ;; 710 ; 711 // Loop over all integrated observables; 712 for (const auto aarg : allObs) {; 713 // Check if observable is real-valued lvalue; 714 if (auto arglv = dynamic_cast<RooAbsRealLValue*>(aarg)) {; 715 ; 716 // Check if range is parameterized; 717 RooAbsBinning& binning = arglv->getBinning(rangeName,false,true) ;; 718 if (binning.isParameterized()) {; 719 RooArgSet loBoundObs;; 720 RooArgSet hiBoundObs;; 721 binning.lowBoundFunc()->getObservables(&allObs, loBoundObs) ;; 722 binning.highBoundFunc()->getObservables(&allObs, hiBoundObs) ;; 723 ; 724 // Check if range parameterization depends on other integrated observables; 725 if (loBoundObs.overlaps(allObs) || hiBoundObs.overlaps(allObs)) {; 726 obsWithParamRange.add(*aarg) ;; 727 obsWithFixedRange.remove(*aarg) ;; 728 obsServingAsRangeParams.add(loBoundObs,false) ;; 729 obsServingAsRangeParams.add(hiBoundObs,false) ;; 730 }; 731 }; ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:28445,Modifiability,parameteriz,parameterization,28445,"* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ranges depending on other integrated observables; 706 // c) integrated observables used in definition of any parameterized ranges of integrated observables; 707 RooArgSet obsWithFixedRange(allObs) ;; 708 RooArgSet obsWithParamRange ;; 709 RooArgSet obsServingAsRangeParams ;; 710 ; 711 // Loop over all integrated observables; 712 for (const auto aarg : allObs) {; 713 // Check if observable is real-valued lvalue; 714 if (auto arglv = dynamic_cast<RooAbsRealLValue*>(aarg)) {; 715 ; 716 // Check if range is parameterized; 717 RooAbsBinning& binning = arglv->getBinning(rangeName,false,true) ;; 718 if (binning.isParameterized()) {; 719 RooArgSet loBoundObs;; 720 RooArgSet hiBoundObs;; 721 binning.lowBoundFunc()->getObservables(&allObs, loBoundObs) ;; 722 binning.highBoundFunc()->getObservables(&allObs, hiBoundObs) ;; 723 ; 724 // Check if range parameterization depends on other integrated observables; 725 if (loBoundObs.overlaps(allObs) || hiBoundObs.overlaps(allObs)) {; 726 obsWithParamRange.add(*aarg) ;; 727 obsWithFixedRange.remove(*aarg) ;; 728 obsServingAsRangeParams.add(loBoundObs,false) ;; 729 obsServingAsRangeParams.add(hiBoundObs,false) ;; 730 }; 731 }; 732 }; 733 }; 734 ; 735 // Make list of fixed-range observables that are _not_ involved in the parameterization of ranges of other observables; 736 RooArgSet obsWithFixedRangeNP(obsWithFixedRange) ;; 737 obsWithFixedRangeNP.remove(obsServingAsRangeParams) ;; 738 ; 739 // Make list of param-range observables that are _not_ involved in the parameterization of ranges of other observables; 740 RooArgSet obsWithParamRangeNP(obsWithParamRange) ;; 741 obsWithParamRangeNP.remove(obsServingAsRangeParams) ;; 742 ; 743 // Construct inner-most integration: over observables (with fixed or param range) not used in any other param range definitions; 744 innerObs.removeAll() ;; 74",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:28864,Modifiability,parameteriz,parameterization,28864,"arams ;; 710 ; 711 // Loop over all integrated observables; 712 for (const auto aarg : allObs) {; 713 // Check if observable is real-valued lvalue; 714 if (auto arglv = dynamic_cast<RooAbsRealLValue*>(aarg)) {; 715 ; 716 // Check if range is parameterized; 717 RooAbsBinning& binning = arglv->getBinning(rangeName,false,true) ;; 718 if (binning.isParameterized()) {; 719 RooArgSet loBoundObs;; 720 RooArgSet hiBoundObs;; 721 binning.lowBoundFunc()->getObservables(&allObs, loBoundObs) ;; 722 binning.highBoundFunc()->getObservables(&allObs, hiBoundObs) ;; 723 ; 724 // Check if range parameterization depends on other integrated observables; 725 if (loBoundObs.overlaps(allObs) || hiBoundObs.overlaps(allObs)) {; 726 obsWithParamRange.add(*aarg) ;; 727 obsWithFixedRange.remove(*aarg) ;; 728 obsServingAsRangeParams.add(loBoundObs,false) ;; 729 obsServingAsRangeParams.add(hiBoundObs,false) ;; 730 }; 731 }; 732 }; 733 }; 734 ; 735 // Make list of fixed-range observables that are _not_ involved in the parameterization of ranges of other observables; 736 RooArgSet obsWithFixedRangeNP(obsWithFixedRange) ;; 737 obsWithFixedRangeNP.remove(obsServingAsRangeParams) ;; 738 ; 739 // Make list of param-range observables that are _not_ involved in the parameterization of ranges of other observables; 740 RooArgSet obsWithParamRangeNP(obsWithParamRange) ;; 741 obsWithParamRangeNP.remove(obsServingAsRangeParams) ;; 742 ; 743 // Construct inner-most integration: over observables (with fixed or param range) not used in any other param range definitions; 744 innerObs.removeAll() ;; 745 innerObs.add(obsWithFixedRangeNP) ;; 746 innerObs.add(obsWithParamRangeNP) ;; 747 ; 748}; 749 ; 750 ; 751////////////////////////////////////////////////////////////////////////////////; 752/// Construct string with unique suffix name to give to integral object that encodes; 753/// integrated observables, normalization observables and the integration range name; 754 ; 755TString RooAbsReal::integralNameSuffix(const",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:29109,Modifiability,parameteriz,parameterization,29109,"d; 717 RooAbsBinning& binning = arglv->getBinning(rangeName,false,true) ;; 718 if (binning.isParameterized()) {; 719 RooArgSet loBoundObs;; 720 RooArgSet hiBoundObs;; 721 binning.lowBoundFunc()->getObservables(&allObs, loBoundObs) ;; 722 binning.highBoundFunc()->getObservables(&allObs, hiBoundObs) ;; 723 ; 724 // Check if range parameterization depends on other integrated observables; 725 if (loBoundObs.overlaps(allObs) || hiBoundObs.overlaps(allObs)) {; 726 obsWithParamRange.add(*aarg) ;; 727 obsWithFixedRange.remove(*aarg) ;; 728 obsServingAsRangeParams.add(loBoundObs,false) ;; 729 obsServingAsRangeParams.add(hiBoundObs,false) ;; 730 }; 731 }; 732 }; 733 }; 734 ; 735 // Make list of fixed-range observables that are _not_ involved in the parameterization of ranges of other observables; 736 RooArgSet obsWithFixedRangeNP(obsWithFixedRange) ;; 737 obsWithFixedRangeNP.remove(obsServingAsRangeParams) ;; 738 ; 739 // Make list of param-range observables that are _not_ involved in the parameterization of ranges of other observables; 740 RooArgSet obsWithParamRangeNP(obsWithParamRange) ;; 741 obsWithParamRangeNP.remove(obsServingAsRangeParams) ;; 742 ; 743 // Construct inner-most integration: over observables (with fixed or param range) not used in any other param range definitions; 744 innerObs.removeAll() ;; 745 innerObs.add(obsWithFixedRangeNP) ;; 746 innerObs.add(obsWithParamRangeNP) ;; 747 ; 748}; 749 ; 750 ; 751////////////////////////////////////////////////////////////////////////////////; 752/// Construct string with unique suffix name to give to integral object that encodes; 753/// integrated observables, normalization observables and the integration range name; 754 ; 755TString RooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset, const char* rangeName, bool omitEmpty) const; 756{; 757 TString name ;; 758 if (!iset.empty()) {; 759 name.Append(""_Int["" + RooHelpers::getColonSeparatedNameString(iset, ','));; 760 if (rangeName) {; 761 name.Appe",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:31716,Modifiability,variab,variables,31716,") ;; 773 }; 774 name.Append(""]"") ;; 775 }; 776 ; 777 return name ;; 778}; 779 ; 780 ; 781 ; 782////////////////////////////////////////////////////////////////////////////////; 783/// Utility function for plotOn() that creates a projection of a function or p.d.f; 784/// to be plotted on a RooPlot.; 785/// \ref createPlotProjAnchor ""createPlotProjection()""; 786 ; 787const RooAbsReal* RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars,; 788 RooArgSet*& cloneSet) const; 789{; 790 return createPlotProjection(depVars,&projVars,cloneSet) ;; 791}; 792 ; 793 ; 794////////////////////////////////////////////////////////////////////////////////; 795/// Utility function for plotOn() that creates a projection of a function or p.d.f; 796/// to be plotted on a RooPlot.; 797/// \anchor createPlotProjAnchor; 798///; 799/// Create a new object \f$ G \f$ that represents the normalized projection:; 800/// \f[; 801/// G[x,p] = \frac{\int F[x,y,p] \; \mathrm{d}\{y\}}; 802/// {\int F[x,y,p] \; \mathrm{d}\{x\} \, \mathrm{d}\{y\}}; 803/// \f]; 804/// where \f$ F[x,y,p] \f$ is the function we represent, and; 805/// \f$ \{ p \} \f$ are the remaining variables (""parameters"").; 806///; 807/// \param[in] dependentVars Dependent variables over which to normalise, \f$ \{x\} \f$.; 808/// \param[in] projectedVars Variables to project out, \f$ \{ y \} \f$.; 809/// \param[out] cloneSet Will be set to a RooArgSet*, which will contain a clone of *this plus its projection integral object.; 810/// The latter will also be returned. The caller takes ownership of this set.; 811/// \param[in] rangeName Optional range for projection integrals; 812/// \param[in] condObs Conditional observables, which are not integrated for normalisation, even if they; 813/// are in `dependentVars` or `projectedVars`.; 814/// \return A pointer to the newly created object, or zero in case of an; 815/// error. The caller is responsible for deleting the `cloneSet` (which includes the returned proj",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:31793,Modifiability,variab,variables,31793,"on or p.d.f; 784/// to be plotted on a RooPlot.; 785/// \ref createPlotProjAnchor ""createPlotProjection()""; 786 ; 787const RooAbsReal* RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars,; 788 RooArgSet*& cloneSet) const; 789{; 790 return createPlotProjection(depVars,&projVars,cloneSet) ;; 791}; 792 ; 793 ; 794////////////////////////////////////////////////////////////////////////////////; 795/// Utility function for plotOn() that creates a projection of a function or p.d.f; 796/// to be plotted on a RooPlot.; 797/// \anchor createPlotProjAnchor; 798///; 799/// Create a new object \f$ G \f$ that represents the normalized projection:; 800/// \f[; 801/// G[x,p] = \frac{\int F[x,y,p] \; \mathrm{d}\{y\}}; 802/// {\int F[x,y,p] \; \mathrm{d}\{x\} \, \mathrm{d}\{y\}}; 803/// \f]; 804/// where \f$ F[x,y,p] \f$ is the function we represent, and; 805/// \f$ \{ p \} \f$ are the remaining variables (""parameters"").; 806///; 807/// \param[in] dependentVars Dependent variables over which to normalise, \f$ \{x\} \f$.; 808/// \param[in] projectedVars Variables to project out, \f$ \{ y \} \f$.; 809/// \param[out] cloneSet Will be set to a RooArgSet*, which will contain a clone of *this plus its projection integral object.; 810/// The latter will also be returned. The caller takes ownership of this set.; 811/// \param[in] rangeName Optional range for projection integrals; 812/// \param[in] condObs Conditional observables, which are not integrated for normalisation, even if they; 813/// are in `dependentVars` or `projectedVars`.; 814/// \return A pointer to the newly created object, or zero in case of an; 815/// error. The caller is responsible for deleting the `cloneSet` (which includes the returned projection object).; 816const RooAbsReal *RooAbsReal::createPlotProjection(const RooArgSet &dependentVars, const RooArgSet *projectedVars,; 817 RooArgSet *&cloneSet, const char* rangeName, const RooArgSet* condObs) const; 818{; 819 // Get the set of our le",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:33150,Modifiability,variab,variables,33150,"; 811/// \param[in] rangeName Optional range for projection integrals; 812/// \param[in] condObs Conditional observables, which are not integrated for normalisation, even if they; 813/// are in `dependentVars` or `projectedVars`.; 814/// \return A pointer to the newly created object, or zero in case of an; 815/// error. The caller is responsible for deleting the `cloneSet` (which includes the returned projection object).; 816const RooAbsReal *RooAbsReal::createPlotProjection(const RooArgSet &dependentVars, const RooArgSet *projectedVars,; 817 RooArgSet *&cloneSet, const char* rangeName, const RooArgSet* condObs) const; 818{; 819 // Get the set of our leaf nodes; 820 RooArgSet leafNodes;; 821 RooArgSet treeNodes;; 822 leafNodeServerList(&leafNodes,this);; 823 treeNodeServerList(&treeNodes,this) ;; 824 ; 825 ; 826 // Check that the dependents are all fundamental. Filter out any that we; 827 // do not depend on, and make substitutions by name in our leaf list.; 828 // Check for overlaps with the projection variables.; 829 for (const auto arg : dependentVars) {; 830 if(!arg->isFundamental() && !dynamic_cast<const RooAbsLValue*>(arg)) {; 831 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: variable \"""" << arg->GetName(); 832 << ""\"" of wrong type: "" << arg->ClassName() << std::endl;; 833 return nullptr;; 834 }; 835 ; 836 RooAbsArg *found= treeNodes.find(arg->GetName());; 837 if(!found) {; 838 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: \"""" << arg->GetName(); 839 << ""\"" is not a dependent and will be ignored."" << std::endl;; 840 continue;; 841 }; 842 if(found != arg) {; 843 if (leafNodes.find(found->GetName())) {; 844 leafNodes.replace(*found,*arg);; 845 } else {; 846 leafNodes.add(*arg) ;; 847 ; 848 // Remove any dependents of found, replace by dependents of LV node; 849 RooArgSet lvDep;; 850 arg->getObservables(&leafNodes, lvDep);; 851 for (const auto lvs : lvDep) {; 852 RooAbsArg* tmp = leafNodes.find(lvs-",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:33365,Modifiability,variab,variable,33365," `projectedVars`.; 814/// \return A pointer to the newly created object, or zero in case of an; 815/// error. The caller is responsible for deleting the `cloneSet` (which includes the returned projection object).; 816const RooAbsReal *RooAbsReal::createPlotProjection(const RooArgSet &dependentVars, const RooArgSet *projectedVars,; 817 RooArgSet *&cloneSet, const char* rangeName, const RooArgSet* condObs) const; 818{; 819 // Get the set of our leaf nodes; 820 RooArgSet leafNodes;; 821 RooArgSet treeNodes;; 822 leafNodeServerList(&leafNodes,this);; 823 treeNodeServerList(&treeNodes,this) ;; 824 ; 825 ; 826 // Check that the dependents are all fundamental. Filter out any that we; 827 // do not depend on, and make substitutions by name in our leaf list.; 828 // Check for overlaps with the projection variables.; 829 for (const auto arg : dependentVars) {; 830 if(!arg->isFundamental() && !dynamic_cast<const RooAbsLValue*>(arg)) {; 831 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: variable \"""" << arg->GetName(); 832 << ""\"" of wrong type: "" << arg->ClassName() << std::endl;; 833 return nullptr;; 834 }; 835 ; 836 RooAbsArg *found= treeNodes.find(arg->GetName());; 837 if(!found) {; 838 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: \"""" << arg->GetName(); 839 << ""\"" is not a dependent and will be ignored."" << std::endl;; 840 continue;; 841 }; 842 if(found != arg) {; 843 if (leafNodes.find(found->GetName())) {; 844 leafNodes.replace(*found,*arg);; 845 } else {; 846 leafNodes.add(*arg) ;; 847 ; 848 // Remove any dependents of found, replace by dependents of LV node; 849 RooArgSet lvDep;; 850 arg->getObservables(&leafNodes, lvDep);; 851 for (const auto lvs : lvDep) {; 852 RooAbsArg* tmp = leafNodes.find(lvs->GetName()) ;; 853 if (tmp) {; 854 leafNodes.remove(*tmp) ;; 855 leafNodes.add(*lvs) ;; 856 }; 857 }; 858 }; 859 }; 860 ; 861 // check if this arg is also in the projection set; 862 if(nullptr != projectedVars &&",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:34544,Modifiability,variab,variable,34544,"< arg->GetName(); 832 << ""\"" of wrong type: "" << arg->ClassName() << std::endl;; 833 return nullptr;; 834 }; 835 ; 836 RooAbsArg *found= treeNodes.find(arg->GetName());; 837 if(!found) {; 838 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: \"""" << arg->GetName(); 839 << ""\"" is not a dependent and will be ignored."" << std::endl;; 840 continue;; 841 }; 842 if(found != arg) {; 843 if (leafNodes.find(found->GetName())) {; 844 leafNodes.replace(*found,*arg);; 845 } else {; 846 leafNodes.add(*arg) ;; 847 ; 848 // Remove any dependents of found, replace by dependents of LV node; 849 RooArgSet lvDep;; 850 arg->getObservables(&leafNodes, lvDep);; 851 for (const auto lvs : lvDep) {; 852 RooAbsArg* tmp = leafNodes.find(lvs->GetName()) ;; 853 if (tmp) {; 854 leafNodes.remove(*tmp) ;; 855 leafNodes.add(*lvs) ;; 856 }; 857 }; 858 }; 859 }; 860 ; 861 // check if this arg is also in the projection set; 862 if(nullptr != projectedVars && projectedVars->find(arg->GetName())) {; 863 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: \"""" << arg->GetName(); 864 << ""\"" cannot be both a dependent and a projected variable."" << std::endl;; 865 return nullptr;; 866 }; 867 }; 868 ; 869 // Remove the projected variables from the list of leaf nodes, if necessary.; 870 if(nullptr != projectedVars) leafNodes.remove(*projectedVars,true);; 871 ; 872 // Make a deep-clone of ourself so later operations do not disturb our original state; 873 cloneSet = new RooArgSet;; 874 if (RooArgSet(*this).snapshot(*cloneSet, true)) {; 875 coutE(Plotting) << ""RooAbsPdf::createPlotProjection("" << GetName() << "") Couldn't deep-clone PDF, abort,"" << std::endl ;; 876 return nullptr ;; 877 }; 878 RooAbsReal *theClone= static_cast<RooAbsReal*>(cloneSet->find(GetName()));; 879 ; 880 // The remaining entries in our list of leaf nodes are the external; 881 // dependents (x) and parameters (p) of the projection. Patch them back; 882 // into the theClone. This orphans t",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:34639,Modifiability,variab,variables,34639," << "":createPlotProjection: \"""" << arg->GetName(); 839 << ""\"" is not a dependent and will be ignored."" << std::endl;; 840 continue;; 841 }; 842 if(found != arg) {; 843 if (leafNodes.find(found->GetName())) {; 844 leafNodes.replace(*found,*arg);; 845 } else {; 846 leafNodes.add(*arg) ;; 847 ; 848 // Remove any dependents of found, replace by dependents of LV node; 849 RooArgSet lvDep;; 850 arg->getObservables(&leafNodes, lvDep);; 851 for (const auto lvs : lvDep) {; 852 RooAbsArg* tmp = leafNodes.find(lvs->GetName()) ;; 853 if (tmp) {; 854 leafNodes.remove(*tmp) ;; 855 leafNodes.add(*lvs) ;; 856 }; 857 }; 858 }; 859 }; 860 ; 861 // check if this arg is also in the projection set; 862 if(nullptr != projectedVars && projectedVars->find(arg->GetName())) {; 863 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: \"""" << arg->GetName(); 864 << ""\"" cannot be both a dependent and a projected variable."" << std::endl;; 865 return nullptr;; 866 }; 867 }; 868 ; 869 // Remove the projected variables from the list of leaf nodes, if necessary.; 870 if(nullptr != projectedVars) leafNodes.remove(*projectedVars,true);; 871 ; 872 // Make a deep-clone of ourself so later operations do not disturb our original state; 873 cloneSet = new RooArgSet;; 874 if (RooArgSet(*this).snapshot(*cloneSet, true)) {; 875 coutE(Plotting) << ""RooAbsPdf::createPlotProjection("" << GetName() << "") Couldn't deep-clone PDF, abort,"" << std::endl ;; 876 return nullptr ;; 877 }; 878 RooAbsReal *theClone= static_cast<RooAbsReal*>(cloneSet->find(GetName()));; 879 ; 880 // The remaining entries in our list of leaf nodes are the external; 881 // dependents (x) and parameters (p) of the projection. Patch them back; 882 // into the theClone. This orphans the nodes they replace, but the orphans; 883 // are still in the cloneList and so will be cleaned up eventually.; 884 //cout << ""redirection leafNodes : "" ; leafNodes.Print(""1"") ;; 885 ; 886 std::unique_ptr<RooArgSet> plotLeafNodes{leafNodes.s",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:35772,Modifiability,variab,variables,35772,"rue);; 871 ; 872 // Make a deep-clone of ourself so later operations do not disturb our original state; 873 cloneSet = new RooArgSet;; 874 if (RooArgSet(*this).snapshot(*cloneSet, true)) {; 875 coutE(Plotting) << ""RooAbsPdf::createPlotProjection("" << GetName() << "") Couldn't deep-clone PDF, abort,"" << std::endl ;; 876 return nullptr ;; 877 }; 878 RooAbsReal *theClone= static_cast<RooAbsReal*>(cloneSet->find(GetName()));; 879 ; 880 // The remaining entries in our list of leaf nodes are the external; 881 // dependents (x) and parameters (p) of the projection. Patch them back; 882 // into the theClone. This orphans the nodes they replace, but the orphans; 883 // are still in the cloneList and so will be cleaned up eventually.; 884 //cout << ""redirection leafNodes : "" ; leafNodes.Print(""1"") ;; 885 ; 886 std::unique_ptr<RooArgSet> plotLeafNodes{leafNodes.selectCommon(dependentVars)};; 887 theClone->recursiveRedirectServers(*plotLeafNodes,false,false,false);; 888 ; 889 // Create the set of normalization variables to use in the projection integrand; 890 RooArgSet normSet(dependentVars);; 891 if(nullptr != projectedVars) normSet.add(*projectedVars);; 892 if(nullptr != condObs) {; 893 normSet.remove(*condObs,true,true) ;; 894 }; 895 ; 896 // Try to create a valid projection integral. If no variables are to be projected,; 897 // create a null projection anyway to bind our normalization over the dependents; 898 // consistently with the way they would be bound with a non-trivial projection.; 899 RooArgSet empty;; 900 if(nullptr == projectedVars) projectedVars= &empty;; 901 ; 902 std::string name = GetName();; 903 name += integralNameSuffix(*projectedVars,&normSet,rangeName,true) ;; 904 ; 905 std::string title = std::string{""Projection of ""} + GetTitle();; 906 ; 907 std::unique_ptr<RooAbsReal> projected{theClone->createIntegral(*projectedVars,normSet,rangeName)};; 908 ; 909 if(nullptr == projected || !projected->isValid()) {; 910 coutE(Plotting) << ClassName() << ""::"" << GetName(",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:36061,Modifiability,variab,variables,36061,"neSet->find(GetName()));; 879 ; 880 // The remaining entries in our list of leaf nodes are the external; 881 // dependents (x) and parameters (p) of the projection. Patch them back; 882 // into the theClone. This orphans the nodes they replace, but the orphans; 883 // are still in the cloneList and so will be cleaned up eventually.; 884 //cout << ""redirection leafNodes : "" ; leafNodes.Print(""1"") ;; 885 ; 886 std::unique_ptr<RooArgSet> plotLeafNodes{leafNodes.selectCommon(dependentVars)};; 887 theClone->recursiveRedirectServers(*plotLeafNodes,false,false,false);; 888 ; 889 // Create the set of normalization variables to use in the projection integrand; 890 RooArgSet normSet(dependentVars);; 891 if(nullptr != projectedVars) normSet.add(*projectedVars);; 892 if(nullptr != condObs) {; 893 normSet.remove(*condObs,true,true) ;; 894 }; 895 ; 896 // Try to create a valid projection integral. If no variables are to be projected,; 897 // create a null projection anyway to bind our normalization over the dependents; 898 // consistently with the way they would be bound with a non-trivial projection.; 899 RooArgSet empty;; 900 if(nullptr == projectedVars) projectedVars= &empty;; 901 ; 902 std::string name = GetName();; 903 name += integralNameSuffix(*projectedVars,&normSet,rangeName,true) ;; 904 ; 905 std::string title = std::string{""Projection of ""} + GetTitle();; 906 ; 907 std::unique_ptr<RooAbsReal> projected{theClone->createIntegral(*projectedVars,normSet,rangeName)};; 908 ; 909 if(nullptr == projected || !projected->isValid()) {; 910 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: cannot integrate out "";; 911 projectedVars->printStream(std::cout,kName|kArgs,kSingleLine);; 912 return nullptr;; 913 }; 914 ; 915 if(projected->InheritsFrom(RooRealIntegral::Class())){; 916 static_cast<RooRealIntegral&>(*projected).setAllowComponentSelection(true);; 917 }; 918 ; 919 projected->SetName(name.c_str()) ;; 920 projected->SetTitle(title.c_str()) ;; 921 ; ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:37822,Modifiability,variab,variables,37822,"s->printStream(std::cout,kName|kArgs,kSingleLine);; 912 return nullptr;; 913 }; 914 ; 915 if(projected->InheritsFrom(RooRealIntegral::Class())){; 916 static_cast<RooRealIntegral&>(*projected).setAllowComponentSelection(true);; 917 }; 918 ; 919 projected->SetName(name.c_str()) ;; 920 projected->SetTitle(title.c_str()) ;; 921 ; 922 // Add the projection integral to the cloneSet so that it eventually gets cleaned up by the caller.; 923 RooAbsReal *projectedPtr = projected.get();; 924 cloneSet->addOwned(std::move(projected));; 925 ; 926 // return a const pointer to remind the caller that they do not delete the returned object; 927 // directly (it is contained in the cloneSet instead).; 928 return projectedPtr;; 929}; 930 ; 931 ; 932 ; 933////////////////////////////////////////////////////////////////////////////////; 934/// Fill the ROOT histogram 'hist' with values sampled from this; 935/// function at the bin centers. Our value is calculated by first; 936/// integrating out any variables in projectedVars and then scaling; 937/// the result by scaleFactor. Returns a pointer to the input; 938/// histogram, or zero in case of an error. The input histogram can; 939/// be any TH1 subclass, and therefore of arbitrary; 940/// dimension. Variables are matched with the (x,y,...) dimensions of; 941/// the input histogram according to the order in which they appear; 942/// in the input plotVars list. If scaleForDensity is true the; 943/// histogram is filled with a the functions density rather than; 944/// the functions value (i.e. the value at the bin center is multiplied; 945/// with bin volume); 946 ; 947TH1 *RooAbsReal::fillHistogram(TH1 *hist, const RooArgList &plotVars,; 948 double scaleFactor, const RooArgSet *projectedVars, bool scaleForDensity,; 949 const RooArgSet* condObs, bool setError) const; 950{; 951 // Do we have a valid histogram to use?; 952 if(nullptr == hist) {; 953 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillHistogram: no valid histog",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:39251,Modifiability,variab,variables,39251,"ear; 942/// in the input plotVars list. If scaleForDensity is true the; 943/// histogram is filled with a the functions density rather than; 944/// the functions value (i.e. the value at the bin center is multiplied; 945/// with bin volume); 946 ; 947TH1 *RooAbsReal::fillHistogram(TH1 *hist, const RooArgList &plotVars,; 948 double scaleFactor, const RooArgSet *projectedVars, bool scaleForDensity,; 949 const RooArgSet* condObs, bool setError) const; 950{; 951 // Do we have a valid histogram to use?; 952 if(nullptr == hist) {; 953 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillHistogram: no valid histogram to fill"" << std::endl;; 954 return nullptr;; 955 }; 956 ; 957 // Check that the number of plotVars matches the input histogram's dimension; 958 Int_t hdim= hist->GetDimension();; 959 if(hdim != int(plotVars.size())) {; 960 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillHistogram: plotVars has the wrong dimension"" << std::endl;; 961 return nullptr;; 962 }; 963 ; 964 ; 965 // Check that the plot variables are all actually RooRealVars and print a warning if we do not; 966 // explicitly depend on one of them. Fill a set (not list!) of cloned plot variables.; 967 RooArgSet plotClones;; 968 for(std::size_t index= 0; index < plotVars.size(); index++) {; 969 const RooAbsArg *var= plotVars.at(index);; 970 const RooRealVar *realVar= dynamic_cast<const RooRealVar*>(var);; 971 if(nullptr == realVar) {; 972 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillHistogram: cannot plot variable \"""" << var->GetName(); 973 << ""\"" of type "" << var->ClassName() << std::endl;; 974 return nullptr;; 975 }; 976 if(!this->dependsOn(*realVar)) {; 977 coutE(InputArguments) << ClassName() << ""::"" << GetName(); 978 << "":fillHistogram: WARNING: variable is not an explicit dependent: "" << realVar->GetName() << std::endl;; 979 }; 980 plotClones.addClone(*realVar,true); // do not complain about duplicates; 981 }; 982 ; 983 // Reconnect all plotClo",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:39403,Modifiability,variab,variables,39403," the bin center is multiplied; 945/// with bin volume); 946 ; 947TH1 *RooAbsReal::fillHistogram(TH1 *hist, const RooArgList &plotVars,; 948 double scaleFactor, const RooArgSet *projectedVars, bool scaleForDensity,; 949 const RooArgSet* condObs, bool setError) const; 950{; 951 // Do we have a valid histogram to use?; 952 if(nullptr == hist) {; 953 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillHistogram: no valid histogram to fill"" << std::endl;; 954 return nullptr;; 955 }; 956 ; 957 // Check that the number of plotVars matches the input histogram's dimension; 958 Int_t hdim= hist->GetDimension();; 959 if(hdim != int(plotVars.size())) {; 960 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillHistogram: plotVars has the wrong dimension"" << std::endl;; 961 return nullptr;; 962 }; 963 ; 964 ; 965 // Check that the plot variables are all actually RooRealVars and print a warning if we do not; 966 // explicitly depend on one of them. Fill a set (not list!) of cloned plot variables.; 967 RooArgSet plotClones;; 968 for(std::size_t index= 0; index < plotVars.size(); index++) {; 969 const RooAbsArg *var= plotVars.at(index);; 970 const RooRealVar *realVar= dynamic_cast<const RooRealVar*>(var);; 971 if(nullptr == realVar) {; 972 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillHistogram: cannot plot variable \"""" << var->GetName(); 973 << ""\"" of type "" << var->ClassName() << std::endl;; 974 return nullptr;; 975 }; 976 if(!this->dependsOn(*realVar)) {; 977 coutE(InputArguments) << ClassName() << ""::"" << GetName(); 978 << "":fillHistogram: WARNING: variable is not an explicit dependent: "" << realVar->GetName() << std::endl;; 979 }; 980 plotClones.addClone(*realVar,true); // do not complain about duplicates; 981 }; 982 ; 983 // Reconnect all plotClones to each other, imported when plotting N-dim integrals with entangled parameterized ranges; 984 for(RooAbsArg * pc : plotClones) {; 985 pc->recursiveRedirectServers(plotClones,false,f",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:39750,Modifiability,variab,variable,39750,"d histogram to fill"" << std::endl;; 954 return nullptr;; 955 }; 956 ; 957 // Check that the number of plotVars matches the input histogram's dimension; 958 Int_t hdim= hist->GetDimension();; 959 if(hdim != int(plotVars.size())) {; 960 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillHistogram: plotVars has the wrong dimension"" << std::endl;; 961 return nullptr;; 962 }; 963 ; 964 ; 965 // Check that the plot variables are all actually RooRealVars and print a warning if we do not; 966 // explicitly depend on one of them. Fill a set (not list!) of cloned plot variables.; 967 RooArgSet plotClones;; 968 for(std::size_t index= 0; index < plotVars.size(); index++) {; 969 const RooAbsArg *var= plotVars.at(index);; 970 const RooRealVar *realVar= dynamic_cast<const RooRealVar*>(var);; 971 if(nullptr == realVar) {; 972 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillHistogram: cannot plot variable \"""" << var->GetName(); 973 << ""\"" of type "" << var->ClassName() << std::endl;; 974 return nullptr;; 975 }; 976 if(!this->dependsOn(*realVar)) {; 977 coutE(InputArguments) << ClassName() << ""::"" << GetName(); 978 << "":fillHistogram: WARNING: variable is not an explicit dependent: "" << realVar->GetName() << std::endl;; 979 }; 980 plotClones.addClone(*realVar,true); // do not complain about duplicates; 981 }; 982 ; 983 // Reconnect all plotClones to each other, imported when plotting N-dim integrals with entangled parameterized ranges; 984 for(RooAbsArg * pc : plotClones) {; 985 pc->recursiveRedirectServers(plotClones,false,false,true) ;; 986 }; 987 ; 988 // Call checkObservables; 989 RooArgSet allDeps(plotClones) ;; 990 if (projectedVars) {; 991 allDeps.add(*projectedVars) ;; 992 }; 993 if (checkObservables(&allDeps)) {; 994 coutE(InputArguments) << ""RooAbsReal::fillHistogram("" << GetName() << "") error in checkObservables, abort"" << std::endl ;; 995 return hist ;; 996 }; 997 ; 998 // Create a standalone projection object to use for calculating bin c",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:40000,Modifiability,variab,variable,40000,"d histogram to fill"" << std::endl;; 954 return nullptr;; 955 }; 956 ; 957 // Check that the number of plotVars matches the input histogram's dimension; 958 Int_t hdim= hist->GetDimension();; 959 if(hdim != int(plotVars.size())) {; 960 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillHistogram: plotVars has the wrong dimension"" << std::endl;; 961 return nullptr;; 962 }; 963 ; 964 ; 965 // Check that the plot variables are all actually RooRealVars and print a warning if we do not; 966 // explicitly depend on one of them. Fill a set (not list!) of cloned plot variables.; 967 RooArgSet plotClones;; 968 for(std::size_t index= 0; index < plotVars.size(); index++) {; 969 const RooAbsArg *var= plotVars.at(index);; 970 const RooRealVar *realVar= dynamic_cast<const RooRealVar*>(var);; 971 if(nullptr == realVar) {; 972 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillHistogram: cannot plot variable \"""" << var->GetName(); 973 << ""\"" of type "" << var->ClassName() << std::endl;; 974 return nullptr;; 975 }; 976 if(!this->dependsOn(*realVar)) {; 977 coutE(InputArguments) << ClassName() << ""::"" << GetName(); 978 << "":fillHistogram: WARNING: variable is not an explicit dependent: "" << realVar->GetName() << std::endl;; 979 }; 980 plotClones.addClone(*realVar,true); // do not complain about duplicates; 981 }; 982 ; 983 // Reconnect all plotClones to each other, imported when plotting N-dim integrals with entangled parameterized ranges; 984 for(RooAbsArg * pc : plotClones) {; 985 pc->recursiveRedirectServers(plotClones,false,false,true) ;; 986 }; 987 ; 988 // Call checkObservables; 989 RooArgSet allDeps(plotClones) ;; 990 if (projectedVars) {; 991 allDeps.add(*projectedVars) ;; 992 }; 993 if (checkObservables(&allDeps)) {; 994 coutE(InputArguments) << ""RooAbsReal::fillHistogram("" << GetName() << "") error in checkObservables, abort"" << std::endl ;; 995 return hist ;; 996 }; 997 ; 998 // Create a standalone projection object to use for calculating bin c",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:40276,Modifiability,parameteriz,parameterized,40276,"if we do not; 966 // explicitly depend on one of them. Fill a set (not list!) of cloned plot variables.; 967 RooArgSet plotClones;; 968 for(std::size_t index= 0; index < plotVars.size(); index++) {; 969 const RooAbsArg *var= plotVars.at(index);; 970 const RooRealVar *realVar= dynamic_cast<const RooRealVar*>(var);; 971 if(nullptr == realVar) {; 972 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillHistogram: cannot plot variable \"""" << var->GetName(); 973 << ""\"" of type "" << var->ClassName() << std::endl;; 974 return nullptr;; 975 }; 976 if(!this->dependsOn(*realVar)) {; 977 coutE(InputArguments) << ClassName() << ""::"" << GetName(); 978 << "":fillHistogram: WARNING: variable is not an explicit dependent: "" << realVar->GetName() << std::endl;; 979 }; 980 plotClones.addClone(*realVar,true); // do not complain about duplicates; 981 }; 982 ; 983 // Reconnect all plotClones to each other, imported when plotting N-dim integrals with entangled parameterized ranges; 984 for(RooAbsArg * pc : plotClones) {; 985 pc->recursiveRedirectServers(plotClones,false,false,true) ;; 986 }; 987 ; 988 // Call checkObservables; 989 RooArgSet allDeps(plotClones) ;; 990 if (projectedVars) {; 991 allDeps.add(*projectedVars) ;; 992 }; 993 if (checkObservables(&allDeps)) {; 994 coutE(InputArguments) << ""RooAbsReal::fillHistogram("" << GetName() << "") error in checkObservables, abort"" << std::endl ;; 995 return hist ;; 996 }; 997 ; 998 // Create a standalone projection object to use for calculating bin contents; 999 RooArgSet *cloneSet = nullptr;; 1000 const RooAbsReal *projected= createPlotProjection(plotClones,projectedVars,cloneSet,nullptr,condObs);; 1001 ; 1002 cxcoutD(Plotting) << ""RooAbsReal::fillHistogram("" << GetName() << "") plot projection object is "" << projected->GetName() << std::endl ;; 1003 ; 1004 // Prepare to loop over the histogram bins; 1005 Int_t xbins(0);; 1006 Int_t ybins(1);; 1007 Int_t zbins(1);; 1008 RooRealVar *xvar = nullptr;; 1009 RooRealVar *yvar = nullptr",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:44767,Modifiability,extend,extendedMode,44767,"ordinates [x]="" << xvar->getVal() ;; 1081 if (hdim==2) ccoutW(Plotting) << "" [y]="" << yvar->getVal() ;; 1082 if (hdim==3) ccoutW(Plotting) << "" [z]="" << zvar->getVal() ;; 1083 ccoutW(Plotting) << std::endl ;; 1084 // RooAbsReal::printEvalErrors(ccoutW(Plotting),10) ;; 1085 result = 0 ;; 1086 }; 1087 RooAbsReal::clearEvalErrorLog() ;; 1088 ; 1089 hist->SetBinContent(hist->GetBin(xbin,ybin,zbin),result);; 1090 if (setError) {; 1091 hist->SetBinError(hist->GetBin(xbin,ybin,zbin),sqrt(result)) ;; 1092 }; 1093 ; 1094 //cout << ""bin "" << bin << "" -> ("" << xbin << "","" << ybin << "","" << zbin << "") = "" << result << std::endl;; 1095 }; 1096 RooAbsReal::setEvalErrorLoggingMode(RooAbsReal::PrintErrors) ;; 1097 ; 1098 // cleanup; 1099 delete cloneSet;; 1100 ; 1101 return hist;; 1102}; 1103 ; 1104 ; 1105 ; 1106////////////////////////////////////////////////////////////////////////////////; 1107/// Fill a RooDataHist with values sampled from this function at the; 1108/// bin centers. If extendedMode is true, the p.d.f. values is multiplied; 1109/// by the number of expected events in each bin; 1110///; 1111/// An optional scaling by a given scaleFactor can be performed.; 1112/// Returns a pointer to the input RooDataHist, or zero; 1113/// in case of an error.; 1114///; 1115/// If correctForBinSize is true the RooDataHist; 1116/// is filled with the functions density (function value times the; 1117/// bin volume) rather than function value.; 1118///; 1119/// If showProgress is true; 1120/// a process indicator is printed on stdout in steps of one percent,; 1121/// which is mostly useful for the sampling of expensive functions; 1122/// such as likelihoods; 1123 ; 1124RooDataHist* RooAbsReal::fillDataHist(RooDataHist *hist, const RooArgSet* normSet, double scaleFactor,; 1125 bool correctForBinSize, bool showProgress) const; 1126{; 1127 // Do we have a valid histogram to use?; 1128 if(nullptr == hist) {; 1129 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillDataHist",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:47336,Modifiability,variab,variables,47336,"origObs = getObservables(hist) ;; 1142 RooArgSet cloneSet;; 1143 RooArgSet(*this).snapshot(cloneSet, true);; 1144 RooAbsReal* theClone = static_cast<RooAbsReal*>(cloneSet.find(GetName()));; 1145 theClone->recursiveRedirectServers(*hist->get()) ;; 1146 //const_cast<RooAbsReal*>(this)->recursiveRedirectServers(*hist->get()) ;; 1147 ; 1148 // Iterator over all bins of RooDataHist and fill weights; 1149 Int_t onePct = hist->numEntries()/100 ;; 1150 if (onePct==0) {; 1151 onePct++ ;; 1152 }; 1153 for (Int_t i=0 ; i<hist->numEntries() ; i++) {; 1154 if (showProgress && (i%onePct==0)) {; 1155 ccoutP(Eval) << ""."" << std::flush ;; 1156 }; 1157 const RooArgSet* obs = hist->get(i) ;; 1158 double binVal = theClone->getVal(normSet?normSet:obs)*scaleFactor ;; 1159 if (correctForBinSize) {; 1160 binVal*= hist->binVolume() ;; 1161 }; 1162 hist->set(i, binVal, 0.);; 1163 }; 1164 ; 1165 return hist;; 1166}; 1167 ; 1168 ; 1169 ; 1170 ; 1171////////////////////////////////////////////////////////////////////////////////; 1172/// Create and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables with given names.; 1173/// \param[in] varNameList List of variables to use for x, y, z axis, separated by ':'; 1174/// \param[in] xbins Number of bins for first variable; 1175/// \param[in] ybins Number of bins for second variable; 1176/// \param[in] zbins Number of bins for third variable; 1177/// \return TH1*, which is one of TH[1-3]. The histogram is owned by the caller.; 1178///; 1179/// For a greater degree of control use; 1180/// RooAbsReal::createHistogram(const char *, const RooAbsRealLValue&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&) const; 1181///; 1182 ; 1183TH1* RooAbsReal::createHistogram(RooStringView varNameList, Int_t xbins, Int_t ybins, Int_t zbins) const; 1184{; 1185 std::unique_ptr<RooArgSet> vars{getVariables()};; 1186 ; 1187 auto varNames = R",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:47404,Modifiability,variab,variables,47404,"Servers(*hist->get()) ;; 1147 ; 1148 // Iterator over all bins of RooDataHist and fill weights; 1149 Int_t onePct = hist->numEntries()/100 ;; 1150 if (onePct==0) {; 1151 onePct++ ;; 1152 }; 1153 for (Int_t i=0 ; i<hist->numEntries() ; i++) {; 1154 if (showProgress && (i%onePct==0)) {; 1155 ccoutP(Eval) << ""."" << std::flush ;; 1156 }; 1157 const RooArgSet* obs = hist->get(i) ;; 1158 double binVal = theClone->getVal(normSet?normSet:obs)*scaleFactor ;; 1159 if (correctForBinSize) {; 1160 binVal*= hist->binVolume() ;; 1161 }; 1162 hist->set(i, binVal, 0.);; 1163 }; 1164 ; 1165 return hist;; 1166}; 1167 ; 1168 ; 1169 ; 1170 ; 1171////////////////////////////////////////////////////////////////////////////////; 1172/// Create and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables with given names.; 1173/// \param[in] varNameList List of variables to use for x, y, z axis, separated by ':'; 1174/// \param[in] xbins Number of bins for first variable; 1175/// \param[in] ybins Number of bins for second variable; 1176/// \param[in] zbins Number of bins for third variable; 1177/// \return TH1*, which is one of TH[1-3]. The histogram is owned by the caller.; 1178///; 1179/// For a greater degree of control use; 1180/// RooAbsReal::createHistogram(const char *, const RooAbsRealLValue&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&) const; 1181///; 1182 ; 1183TH1* RooAbsReal::createHistogram(RooStringView varNameList, Int_t xbins, Int_t ybins, Int_t zbins) const; 1184{; 1185 std::unique_ptr<RooArgSet> vars{getVariables()};; 1186 ; 1187 auto varNames = ROOT::Split(varNameList, "",:"");; 1188 std::vector<RooRealVar*> histVars(3, nullptr);; 1189 ; 1190 for(std::size_t iVar = 0; iVar < varNames.size(); ++iVar) {; 1191 if(varNames[iVar].empty()) continue;; 1192 if(iVar >= 3) {; 1193 std::stringstream errMsg;; 1194 errMsg << ""RooAbsPdf::createHistogram("" << ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:47507,Modifiability,variab,variable,47507,"Servers(*hist->get()) ;; 1147 ; 1148 // Iterator over all bins of RooDataHist and fill weights; 1149 Int_t onePct = hist->numEntries()/100 ;; 1150 if (onePct==0) {; 1151 onePct++ ;; 1152 }; 1153 for (Int_t i=0 ; i<hist->numEntries() ; i++) {; 1154 if (showProgress && (i%onePct==0)) {; 1155 ccoutP(Eval) << ""."" << std::flush ;; 1156 }; 1157 const RooArgSet* obs = hist->get(i) ;; 1158 double binVal = theClone->getVal(normSet?normSet:obs)*scaleFactor ;; 1159 if (correctForBinSize) {; 1160 binVal*= hist->binVolume() ;; 1161 }; 1162 hist->set(i, binVal, 0.);; 1163 }; 1164 ; 1165 return hist;; 1166}; 1167 ; 1168 ; 1169 ; 1170 ; 1171////////////////////////////////////////////////////////////////////////////////; 1172/// Create and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables with given names.; 1173/// \param[in] varNameList List of variables to use for x, y, z axis, separated by ':'; 1174/// \param[in] xbins Number of bins for first variable; 1175/// \param[in] ybins Number of bins for second variable; 1176/// \param[in] zbins Number of bins for third variable; 1177/// \return TH1*, which is one of TH[1-3]. The histogram is owned by the caller.; 1178///; 1179/// For a greater degree of control use; 1180/// RooAbsReal::createHistogram(const char *, const RooAbsRealLValue&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&) const; 1181///; 1182 ; 1183TH1* RooAbsReal::createHistogram(RooStringView varNameList, Int_t xbins, Int_t ybins, Int_t zbins) const; 1184{; 1185 std::unique_ptr<RooArgSet> vars{getVariables()};; 1186 ; 1187 auto varNames = ROOT::Split(varNameList, "",:"");; 1188 std::vector<RooRealVar*> histVars(3, nullptr);; 1189 ; 1190 for(std::size_t iVar = 0; iVar < varNames.size(); ++iVar) {; 1191 if(varNames[iVar].empty()) continue;; 1192 if(iVar >= 3) {; 1193 std::stringstream errMsg;; 1194 errMsg << ""RooAbsPdf::createHistogram("" << ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:47568,Modifiability,variab,variable,47568,"Servers(*hist->get()) ;; 1147 ; 1148 // Iterator over all bins of RooDataHist and fill weights; 1149 Int_t onePct = hist->numEntries()/100 ;; 1150 if (onePct==0) {; 1151 onePct++ ;; 1152 }; 1153 for (Int_t i=0 ; i<hist->numEntries() ; i++) {; 1154 if (showProgress && (i%onePct==0)) {; 1155 ccoutP(Eval) << ""."" << std::flush ;; 1156 }; 1157 const RooArgSet* obs = hist->get(i) ;; 1158 double binVal = theClone->getVal(normSet?normSet:obs)*scaleFactor ;; 1159 if (correctForBinSize) {; 1160 binVal*= hist->binVolume() ;; 1161 }; 1162 hist->set(i, binVal, 0.);; 1163 }; 1164 ; 1165 return hist;; 1166}; 1167 ; 1168 ; 1169 ; 1170 ; 1171////////////////////////////////////////////////////////////////////////////////; 1172/// Create and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables with given names.; 1173/// \param[in] varNameList List of variables to use for x, y, z axis, separated by ':'; 1174/// \param[in] xbins Number of bins for first variable; 1175/// \param[in] ybins Number of bins for second variable; 1176/// \param[in] zbins Number of bins for third variable; 1177/// \return TH1*, which is one of TH[1-3]. The histogram is owned by the caller.; 1178///; 1179/// For a greater degree of control use; 1180/// RooAbsReal::createHistogram(const char *, const RooAbsRealLValue&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&) const; 1181///; 1182 ; 1183TH1* RooAbsReal::createHistogram(RooStringView varNameList, Int_t xbins, Int_t ybins, Int_t zbins) const; 1184{; 1185 std::unique_ptr<RooArgSet> vars{getVariables()};; 1186 ; 1187 auto varNames = ROOT::Split(varNameList, "",:"");; 1188 std::vector<RooRealVar*> histVars(3, nullptr);; 1189 ; 1190 for(std::size_t iVar = 0; iVar < varNames.size(); ++iVar) {; 1191 if(varNames[iVar].empty()) continue;; 1192 if(iVar >= 3) {; 1193 std::stringstream errMsg;; 1194 errMsg << ""RooAbsPdf::createHistogram("" << ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:47628,Modifiability,variab,variable,47628,"Servers(*hist->get()) ;; 1147 ; 1148 // Iterator over all bins of RooDataHist and fill weights; 1149 Int_t onePct = hist->numEntries()/100 ;; 1150 if (onePct==0) {; 1151 onePct++ ;; 1152 }; 1153 for (Int_t i=0 ; i<hist->numEntries() ; i++) {; 1154 if (showProgress && (i%onePct==0)) {; 1155 ccoutP(Eval) << ""."" << std::flush ;; 1156 }; 1157 const RooArgSet* obs = hist->get(i) ;; 1158 double binVal = theClone->getVal(normSet?normSet:obs)*scaleFactor ;; 1159 if (correctForBinSize) {; 1160 binVal*= hist->binVolume() ;; 1161 }; 1162 hist->set(i, binVal, 0.);; 1163 }; 1164 ; 1165 return hist;; 1166}; 1167 ; 1168 ; 1169 ; 1170 ; 1171////////////////////////////////////////////////////////////////////////////////; 1172/// Create and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables with given names.; 1173/// \param[in] varNameList List of variables to use for x, y, z axis, separated by ':'; 1174/// \param[in] xbins Number of bins for first variable; 1175/// \param[in] ybins Number of bins for second variable; 1176/// \param[in] zbins Number of bins for third variable; 1177/// \return TH1*, which is one of TH[1-3]. The histogram is owned by the caller.; 1178///; 1179/// For a greater degree of control use; 1180/// RooAbsReal::createHistogram(const char *, const RooAbsRealLValue&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&) const; 1181///; 1182 ; 1183TH1* RooAbsReal::createHistogram(RooStringView varNameList, Int_t xbins, Int_t ybins, Int_t zbins) const; 1184{; 1185 std::unique_ptr<RooArgSet> vars{getVariables()};; 1186 ; 1187 auto varNames = ROOT::Split(varNameList, "",:"");; 1188 std::vector<RooRealVar*> histVars(3, nullptr);; 1189 ; 1190 for(std::size_t iVar = 0; iVar < varNames.size(); ++iVar) {; 1191 if(varNames[iVar].empty()) continue;; 1192 if(iVar >= 3) {; 1193 std::stringstream errMsg;; 1194 errMsg << ""RooAbsPdf::createHistogram("" << ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:48562,Modifiability,variab,variable,48562,"ybins Number of bins for second variable; 1176/// \param[in] zbins Number of bins for third variable; 1177/// \return TH1*, which is one of TH[1-3]. The histogram is owned by the caller.; 1178///; 1179/// For a greater degree of control use; 1180/// RooAbsReal::createHistogram(const char *, const RooAbsRealLValue&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&) const; 1181///; 1182 ; 1183TH1* RooAbsReal::createHistogram(RooStringView varNameList, Int_t xbins, Int_t ybins, Int_t zbins) const; 1184{; 1185 std::unique_ptr<RooArgSet> vars{getVariables()};; 1186 ; 1187 auto varNames = ROOT::Split(varNameList, "",:"");; 1188 std::vector<RooRealVar*> histVars(3, nullptr);; 1189 ; 1190 for(std::size_t iVar = 0; iVar < varNames.size(); ++iVar) {; 1191 if(varNames[iVar].empty()) continue;; 1192 if(iVar >= 3) {; 1193 std::stringstream errMsg;; 1194 errMsg << ""RooAbsPdf::createHistogram("" << GetName() << "") ERROR more than three variable names passed, but maximum number of supported variables is three"";; 1195 coutE(Plotting) << errMsg.str() << std::endl;; 1196 throw std::invalid_argument(errMsg.str());; 1197 }; 1198 auto var = static_cast<RooRealVar*>(vars->find(varNames[iVar].c_str()));; 1199 if(!var) {; 1200 std::stringstream errMsg;; 1201 errMsg << ""RooAbsPdf::createHistogram("" << GetName() << "") ERROR variable "" << varNames[iVar] << "" does not exist in argset: "" << *vars;; 1202 coutE(Plotting) << errMsg.str() << std::endl;; 1203 throw std::runtime_error(errMsg.str());; 1204 }; 1205 histVars[iVar] = var;; 1206 }; 1207 ; 1208 // Construct list of named arguments to pass to the implementation version of createHistogram(); 1209 ; 1210 RooLinkedList argList ;; 1211 if (xbins>0) {; 1212 argList.Add(RooFit::Binning(xbins).Clone()) ;; 1213 }; 1214 ; 1215 if (histVars[1]) {; 1216 argList.Add(RooFit::YVar(*histVars[1], ybins > 0 ? RooFit::Binning(ybins) : RooCmdArg::none()).Clone()) ;; 1217",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:48617,Modifiability,variab,variables,48617,"ybins Number of bins for second variable; 1176/// \param[in] zbins Number of bins for third variable; 1177/// \return TH1*, which is one of TH[1-3]. The histogram is owned by the caller.; 1178///; 1179/// For a greater degree of control use; 1180/// RooAbsReal::createHistogram(const char *, const RooAbsRealLValue&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&) const; 1181///; 1182 ; 1183TH1* RooAbsReal::createHistogram(RooStringView varNameList, Int_t xbins, Int_t ybins, Int_t zbins) const; 1184{; 1185 std::unique_ptr<RooArgSet> vars{getVariables()};; 1186 ; 1187 auto varNames = ROOT::Split(varNameList, "",:"");; 1188 std::vector<RooRealVar*> histVars(3, nullptr);; 1189 ; 1190 for(std::size_t iVar = 0; iVar < varNames.size(); ++iVar) {; 1191 if(varNames[iVar].empty()) continue;; 1192 if(iVar >= 3) {; 1193 std::stringstream errMsg;; 1194 errMsg << ""RooAbsPdf::createHistogram("" << GetName() << "") ERROR more than three variable names passed, but maximum number of supported variables is three"";; 1195 coutE(Plotting) << errMsg.str() << std::endl;; 1196 throw std::invalid_argument(errMsg.str());; 1197 }; 1198 auto var = static_cast<RooRealVar*>(vars->find(varNames[iVar].c_str()));; 1199 if(!var) {; 1200 std::stringstream errMsg;; 1201 errMsg << ""RooAbsPdf::createHistogram("" << GetName() << "") ERROR variable "" << varNames[iVar] << "" does not exist in argset: "" << *vars;; 1202 coutE(Plotting) << errMsg.str() << std::endl;; 1203 throw std::runtime_error(errMsg.str());; 1204 }; 1205 histVars[iVar] = var;; 1206 }; 1207 ; 1208 // Construct list of named arguments to pass to the implementation version of createHistogram(); 1209 ; 1210 RooLinkedList argList ;; 1211 if (xbins>0) {; 1212 argList.Add(RooFit::Binning(xbins).Clone()) ;; 1213 }; 1214 ; 1215 if (histVars[1]) {; 1216 argList.Add(RooFit::YVar(*histVars[1], ybins > 0 ? RooFit::Binning(ybins) : RooCmdArg::none()).Clone()) ;; 1217",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:48946,Modifiability,variab,variable,48946,"ooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&) const; 1181///; 1182 ; 1183TH1* RooAbsReal::createHistogram(RooStringView varNameList, Int_t xbins, Int_t ybins, Int_t zbins) const; 1184{; 1185 std::unique_ptr<RooArgSet> vars{getVariables()};; 1186 ; 1187 auto varNames = ROOT::Split(varNameList, "",:"");; 1188 std::vector<RooRealVar*> histVars(3, nullptr);; 1189 ; 1190 for(std::size_t iVar = 0; iVar < varNames.size(); ++iVar) {; 1191 if(varNames[iVar].empty()) continue;; 1192 if(iVar >= 3) {; 1193 std::stringstream errMsg;; 1194 errMsg << ""RooAbsPdf::createHistogram("" << GetName() << "") ERROR more than three variable names passed, but maximum number of supported variables is three"";; 1195 coutE(Plotting) << errMsg.str() << std::endl;; 1196 throw std::invalid_argument(errMsg.str());; 1197 }; 1198 auto var = static_cast<RooRealVar*>(vars->find(varNames[iVar].c_str()));; 1199 if(!var) {; 1200 std::stringstream errMsg;; 1201 errMsg << ""RooAbsPdf::createHistogram("" << GetName() << "") ERROR variable "" << varNames[iVar] << "" does not exist in argset: "" << *vars;; 1202 coutE(Plotting) << errMsg.str() << std::endl;; 1203 throw std::runtime_error(errMsg.str());; 1204 }; 1205 histVars[iVar] = var;; 1206 }; 1207 ; 1208 // Construct list of named arguments to pass to the implementation version of createHistogram(); 1209 ; 1210 RooLinkedList argList ;; 1211 if (xbins>0) {; 1212 argList.Add(RooFit::Binning(xbins).Clone()) ;; 1213 }; 1214 ; 1215 if (histVars[1]) {; 1216 argList.Add(RooFit::YVar(*histVars[1], ybins > 0 ? RooFit::Binning(ybins) : RooCmdArg::none()).Clone()) ;; 1217 }; 1218 ; 1219 if (histVars[2]) {; 1220 argList.Add(RooFit::ZVar(*histVars[2], zbins > 0 ? RooFit::Binning(zbins) : RooCmdArg::none()).Clone()) ;; 1221 }; 1222 ; 1223 // Call implementation function; 1224 TH1* result = createHistogram(GetName(), *histVars[0], argList) ;; 1225 ; 1226 // Delete temporary list of RooCmdArgs; 1227 argList.Delete() ;; 1228 ; 1229 return result ;; 1230}; 1231 ; 1232",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:51412,Modifiability,extend,extended,51412,"t below; 1240/// \return TH1 *, one of TH{1,2,3}. The caller takes ownership.; 1241///; 1242/// <table>; 1243/// <tr><th><th> Effect on histogram creation; 1244/// <tr><td> `IntrinsicBinning()` <td> Apply binning defined by function or pdf (as advertised via binBoundaries() method); 1245/// <tr><td> `Binning(const char* name)` <td> Apply binning with given name to x axis of histogram; 1246/// <tr><td> `Binning(RooAbsBinning& binning)` <td> Apply specified binning to x axis of histogram; 1247/// <tr><td> `Binning(int nbins, [double lo, double hi])` <td> Apply specified binning to x axis of histogram; 1248/// <tr><td> `ConditionalObservables(Args_t &&... argsOrArgSet)` <td> Do not normalise PDF over following observables when projecting PDF into histogram.; 1249// Arguments can either be multiple RooRealVar or a single RooArgSet containing them.; 1250/// <tr><td> `Scaling(bool)` <td> Apply density-correction scaling (multiply by bin volume), default is true; 1251/// <tr><td> `Extended(bool)` <td> Plot event yield instead of probability density (for extended pdfs only); 1252///; 1253/// <tr><td> `YVar(const RooAbsRealLValue& var,...)` <td> Observable to be std::mapped on y axis of ROOT histogram.; 1254/// The YVar() and ZVar() arguments can be supplied with optional Binning() arguments to control the binning of the Y and Z axes, e.g.; 1255/// ```; 1256/// createHistogram(""histo"",x,Binning(-1,1,20), YVar(y,Binning(-1,1,30)), ZVar(z,Binning(""zbinning""))); 1257/// ```; 1258/// <tr><td> `ZVar(const RooAbsRealLValue& var,...)` <td> Observable to be std::mapped on z axis of ROOT histogram; 1259/// </table>; 1260///; 1261///; 1262 ; 1263TH1 *RooAbsReal::createHistogram(const char *name, const RooAbsRealLValue& xvar,; 1264 const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4,; 1265 const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 1266{; 1267 ; 1268 RooLinkedList l ;; 1269 l.Add((TObject*)&a",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:52914,Modifiability,config,configuration,52914,"(-1,1,30)), ZVar(z,Binning(""zbinning""))); 1257/// ```; 1258/// <tr><td> `ZVar(const RooAbsRealLValue& var,...)` <td> Observable to be std::mapped on z axis of ROOT histogram; 1259/// </table>; 1260///; 1261///; 1262 ; 1263TH1 *RooAbsReal::createHistogram(const char *name, const RooAbsRealLValue& xvar,; 1264 const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4,; 1265 const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 1266{; 1267 ; 1268 RooLinkedList l ;; 1269 l.Add((TObject*)&arg1) ; l.Add((TObject*)&arg2) ;; 1270 l.Add((TObject*)&arg3) ; l.Add((TObject*)&arg4) ;; 1271 l.Add((TObject*)&arg5) ; l.Add((TObject*)&arg6) ;; 1272 l.Add((TObject*)&arg7) ; l.Add((TObject*)&arg8) ;; 1273 ; 1274 return createHistogram(name,xvar,l) ;; 1275}; 1276 ; 1277 ; 1278////////////////////////////////////////////////////////////////////////////////; 1279/// Internal method implementing createHistogram; 1280 ; 1281TH1* RooAbsReal::createHistogram(const char *name, const RooAbsRealLValue& xvar, RooLinkedList& argList) const; 1282{; 1283 ; 1284 // Define configuration for this method; 1285 RooCmdConfig pc(""RooAbsReal::createHistogram("" + std::string(GetName()) + "")"");; 1286 pc.defineInt(""scaling"",""Scaling"",0,1) ;; 1287 pc.defineInt(""intBinning"",""IntrinsicBinning"",0,2) ;; 1288 pc.defineInt(""extended"",""Extended"",0,2) ;; 1289 ; 1290 pc.defineSet(""compSet"",""SelectCompSet"",0);; 1291 pc.defineString(""compSpec"",""SelectCompSpec"",0) ;; 1292 pc.defineSet(""projObs"",""ProjectedObservables"",0,nullptr) ;; 1293 pc.defineObject(""yvar"",""YVar"",0,nullptr) ;; 1294 pc.defineObject(""zvar"",""ZVar"",0,nullptr) ;; 1295 pc.defineMutex(""SelectCompSet"",""SelectCompSpec"") ;; 1296 pc.defineMutex(""IntrinsicBinning"",""Binning"") ;; 1297 pc.defineMutex(""IntrinsicBinning"",""BinningName"") ;; 1298 pc.defineMutex(""IntrinsicBinning"",""BinningSpec"") ;; 1299 pc.allowUndefined() ;; 1300 ; 1301 // Process & check varargs; 1302 pc.process(argList) ;; 1303 i",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:53154,Modifiability,extend,extended,53154,"mdArg& arg4,; 1265 const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 1266{; 1267 ; 1268 RooLinkedList l ;; 1269 l.Add((TObject*)&arg1) ; l.Add((TObject*)&arg2) ;; 1270 l.Add((TObject*)&arg3) ; l.Add((TObject*)&arg4) ;; 1271 l.Add((TObject*)&arg5) ; l.Add((TObject*)&arg6) ;; 1272 l.Add((TObject*)&arg7) ; l.Add((TObject*)&arg8) ;; 1273 ; 1274 return createHistogram(name,xvar,l) ;; 1275}; 1276 ; 1277 ; 1278////////////////////////////////////////////////////////////////////////////////; 1279/// Internal method implementing createHistogram; 1280 ; 1281TH1* RooAbsReal::createHistogram(const char *name, const RooAbsRealLValue& xvar, RooLinkedList& argList) const; 1282{; 1283 ; 1284 // Define configuration for this method; 1285 RooCmdConfig pc(""RooAbsReal::createHistogram("" + std::string(GetName()) + "")"");; 1286 pc.defineInt(""scaling"",""Scaling"",0,1) ;; 1287 pc.defineInt(""intBinning"",""IntrinsicBinning"",0,2) ;; 1288 pc.defineInt(""extended"",""Extended"",0,2) ;; 1289 ; 1290 pc.defineSet(""compSet"",""SelectCompSet"",0);; 1291 pc.defineString(""compSpec"",""SelectCompSpec"",0) ;; 1292 pc.defineSet(""projObs"",""ProjectedObservables"",0,nullptr) ;; 1293 pc.defineObject(""yvar"",""YVar"",0,nullptr) ;; 1294 pc.defineObject(""zvar"",""ZVar"",0,nullptr) ;; 1295 pc.defineMutex(""SelectCompSet"",""SelectCompSpec"") ;; 1296 pc.defineMutex(""IntrinsicBinning"",""Binning"") ;; 1297 pc.defineMutex(""IntrinsicBinning"",""BinningName"") ;; 1298 pc.defineMutex(""IntrinsicBinning"",""BinningSpec"") ;; 1299 pc.allowUndefined() ;; 1300 ; 1301 // Process & check varargs; 1302 pc.process(argList) ;; 1303 if (!pc.ok(true)) {; 1304 return nullptr ;; 1305 }; 1306 ; 1307 RooArgList vars(xvar) ;; 1308 RooAbsArg* yvar = static_cast<RooAbsArg*>(pc.getObject(""yvar"")) ;; 1309 if (yvar) {; 1310 vars.add(*yvar) ;; 1311 }; 1312 RooAbsArg* zvar = static_cast<RooAbsArg*>(pc.getObject(""zvar"")) ;; 1313 if (zvar) {; 1314 vars.add(*zvar) ;; 1315 }; 1316 ; 1317 auto projObs = pc.getSet(""projObs"");; 1318 R",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:54342,Modifiability,extend,extended,54342," {; 1304 return nullptr ;; 1305 }; 1306 ; 1307 RooArgList vars(xvar) ;; 1308 RooAbsArg* yvar = static_cast<RooAbsArg*>(pc.getObject(""yvar"")) ;; 1309 if (yvar) {; 1310 vars.add(*yvar) ;; 1311 }; 1312 RooAbsArg* zvar = static_cast<RooAbsArg*>(pc.getObject(""zvar"")) ;; 1313 if (zvar) {; 1314 vars.add(*zvar) ;; 1315 }; 1316 ; 1317 auto projObs = pc.getSet(""projObs"");; 1318 RooArgSet* intObs = nullptr ;; 1319 ; 1320 bool doScaling = pc.getInt(""scaling"") ;; 1321 Int_t doIntBinning = pc.getInt(""intBinning"") ;; 1322 Int_t doExtended = pc.getInt(""extended"") ;; 1323 ; 1324 // If doExtended is two, selection is automatic, set to 1 of pdf is extended, to zero otherwise; 1325 const RooAbsPdf* pdfSelf = dynamic_cast<const RooAbsPdf*>(this) ;; 1326 if (!pdfSelf && doExtended == 1) {; 1327 coutW(InputArguments) << ""RooAbsReal::createHistogram("" << GetName() << "") WARNING extended mode requested for a non-pdf object, ignored"" << std::endl ;; 1328 doExtended=0 ;; 1329 }; 1330 if (pdfSelf && doExtended==1 && pdfSelf->extendMode()==RooAbsPdf::CanNotBeExtended) {; 1331 coutW(InputArguments) << ""RooAbsReal::createHistogram("" << GetName() << "") WARNING extended mode requested for a non-extendable pdf, ignored"" << std::endl ;; 1332 doExtended=0 ;; 1333 }; 1334 if (pdfSelf && doExtended==2) {; 1335 doExtended = pdfSelf->extendMode()==RooAbsPdf::CanNotBeExtended ? 0 : 1 ;; 1336 } else if(!pdfSelf) {; 1337 doExtended = 0;; 1338 }; 1339 ; 1340 const char* compSpec = pc.getString(""compSpec"") ;; 1341 const RooArgSet* compSet = pc.getSet(""compSet"");; 1342 bool haveCompSel = ( (compSpec && strlen(compSpec)>0) || compSet) ;; 1343 ; 1344 std::unique_ptr<RooBinning> intBinning;; 1345 if (doIntBinning>0) {; 1346 // Given RooAbsPdf* pdf and RooRealVar* obs; 1347 std::unique_ptr<std::list<double>> bl{binBoundaries(const_cast<RooAbsRealLValue&>(xvar),xvar.getMin(),xvar.getMax())};; 1348 if (!bl) {; 1349 // Only emit warning when intrinsic binning is explicitly requested; 1350 if (doIntBinning==1) {; 1351 ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:54436,Modifiability,extend,extended,54436," {; 1304 return nullptr ;; 1305 }; 1306 ; 1307 RooArgList vars(xvar) ;; 1308 RooAbsArg* yvar = static_cast<RooAbsArg*>(pc.getObject(""yvar"")) ;; 1309 if (yvar) {; 1310 vars.add(*yvar) ;; 1311 }; 1312 RooAbsArg* zvar = static_cast<RooAbsArg*>(pc.getObject(""zvar"")) ;; 1313 if (zvar) {; 1314 vars.add(*zvar) ;; 1315 }; 1316 ; 1317 auto projObs = pc.getSet(""projObs"");; 1318 RooArgSet* intObs = nullptr ;; 1319 ; 1320 bool doScaling = pc.getInt(""scaling"") ;; 1321 Int_t doIntBinning = pc.getInt(""intBinning"") ;; 1322 Int_t doExtended = pc.getInt(""extended"") ;; 1323 ; 1324 // If doExtended is two, selection is automatic, set to 1 of pdf is extended, to zero otherwise; 1325 const RooAbsPdf* pdfSelf = dynamic_cast<const RooAbsPdf*>(this) ;; 1326 if (!pdfSelf && doExtended == 1) {; 1327 coutW(InputArguments) << ""RooAbsReal::createHistogram("" << GetName() << "") WARNING extended mode requested for a non-pdf object, ignored"" << std::endl ;; 1328 doExtended=0 ;; 1329 }; 1330 if (pdfSelf && doExtended==1 && pdfSelf->extendMode()==RooAbsPdf::CanNotBeExtended) {; 1331 coutW(InputArguments) << ""RooAbsReal::createHistogram("" << GetName() << "") WARNING extended mode requested for a non-extendable pdf, ignored"" << std::endl ;; 1332 doExtended=0 ;; 1333 }; 1334 if (pdfSelf && doExtended==2) {; 1335 doExtended = pdfSelf->extendMode()==RooAbsPdf::CanNotBeExtended ? 0 : 1 ;; 1336 } else if(!pdfSelf) {; 1337 doExtended = 0;; 1338 }; 1339 ; 1340 const char* compSpec = pc.getString(""compSpec"") ;; 1341 const RooArgSet* compSet = pc.getSet(""compSet"");; 1342 bool haveCompSel = ( (compSpec && strlen(compSpec)>0) || compSet) ;; 1343 ; 1344 std::unique_ptr<RooBinning> intBinning;; 1345 if (doIntBinning>0) {; 1346 // Given RooAbsPdf* pdf and RooRealVar* obs; 1347 std::unique_ptr<std::list<double>> bl{binBoundaries(const_cast<RooAbsRealLValue&>(xvar),xvar.getMin(),xvar.getMax())};; 1348 if (!bl) {; 1349 // Only emit warning when intrinsic binning is explicitly requested; 1350 if (doIntBinning==1) {; 1351 ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:54666,Modifiability,extend,extended,54666," {; 1304 return nullptr ;; 1305 }; 1306 ; 1307 RooArgList vars(xvar) ;; 1308 RooAbsArg* yvar = static_cast<RooAbsArg*>(pc.getObject(""yvar"")) ;; 1309 if (yvar) {; 1310 vars.add(*yvar) ;; 1311 }; 1312 RooAbsArg* zvar = static_cast<RooAbsArg*>(pc.getObject(""zvar"")) ;; 1313 if (zvar) {; 1314 vars.add(*zvar) ;; 1315 }; 1316 ; 1317 auto projObs = pc.getSet(""projObs"");; 1318 RooArgSet* intObs = nullptr ;; 1319 ; 1320 bool doScaling = pc.getInt(""scaling"") ;; 1321 Int_t doIntBinning = pc.getInt(""intBinning"") ;; 1322 Int_t doExtended = pc.getInt(""extended"") ;; 1323 ; 1324 // If doExtended is two, selection is automatic, set to 1 of pdf is extended, to zero otherwise; 1325 const RooAbsPdf* pdfSelf = dynamic_cast<const RooAbsPdf*>(this) ;; 1326 if (!pdfSelf && doExtended == 1) {; 1327 coutW(InputArguments) << ""RooAbsReal::createHistogram("" << GetName() << "") WARNING extended mode requested for a non-pdf object, ignored"" << std::endl ;; 1328 doExtended=0 ;; 1329 }; 1330 if (pdfSelf && doExtended==1 && pdfSelf->extendMode()==RooAbsPdf::CanNotBeExtended) {; 1331 coutW(InputArguments) << ""RooAbsReal::createHistogram("" << GetName() << "") WARNING extended mode requested for a non-extendable pdf, ignored"" << std::endl ;; 1332 doExtended=0 ;; 1333 }; 1334 if (pdfSelf && doExtended==2) {; 1335 doExtended = pdfSelf->extendMode()==RooAbsPdf::CanNotBeExtended ? 0 : 1 ;; 1336 } else if(!pdfSelf) {; 1337 doExtended = 0;; 1338 }; 1339 ; 1340 const char* compSpec = pc.getString(""compSpec"") ;; 1341 const RooArgSet* compSet = pc.getSet(""compSet"");; 1342 bool haveCompSel = ( (compSpec && strlen(compSpec)>0) || compSet) ;; 1343 ; 1344 std::unique_ptr<RooBinning> intBinning;; 1345 if (doIntBinning>0) {; 1346 // Given RooAbsPdf* pdf and RooRealVar* obs; 1347 std::unique_ptr<std::list<double>> bl{binBoundaries(const_cast<RooAbsRealLValue&>(xvar),xvar.getMin(),xvar.getMax())};; 1348 if (!bl) {; 1349 // Only emit warning when intrinsic binning is explicitly requested; 1350 if (doIntBinning==1) {; 1351 ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:54812,Modifiability,extend,extendMode,54812," {; 1304 return nullptr ;; 1305 }; 1306 ; 1307 RooArgList vars(xvar) ;; 1308 RooAbsArg* yvar = static_cast<RooAbsArg*>(pc.getObject(""yvar"")) ;; 1309 if (yvar) {; 1310 vars.add(*yvar) ;; 1311 }; 1312 RooAbsArg* zvar = static_cast<RooAbsArg*>(pc.getObject(""zvar"")) ;; 1313 if (zvar) {; 1314 vars.add(*zvar) ;; 1315 }; 1316 ; 1317 auto projObs = pc.getSet(""projObs"");; 1318 RooArgSet* intObs = nullptr ;; 1319 ; 1320 bool doScaling = pc.getInt(""scaling"") ;; 1321 Int_t doIntBinning = pc.getInt(""intBinning"") ;; 1322 Int_t doExtended = pc.getInt(""extended"") ;; 1323 ; 1324 // If doExtended is two, selection is automatic, set to 1 of pdf is extended, to zero otherwise; 1325 const RooAbsPdf* pdfSelf = dynamic_cast<const RooAbsPdf*>(this) ;; 1326 if (!pdfSelf && doExtended == 1) {; 1327 coutW(InputArguments) << ""RooAbsReal::createHistogram("" << GetName() << "") WARNING extended mode requested for a non-pdf object, ignored"" << std::endl ;; 1328 doExtended=0 ;; 1329 }; 1330 if (pdfSelf && doExtended==1 && pdfSelf->extendMode()==RooAbsPdf::CanNotBeExtended) {; 1331 coutW(InputArguments) << ""RooAbsReal::createHistogram("" << GetName() << "") WARNING extended mode requested for a non-extendable pdf, ignored"" << std::endl ;; 1332 doExtended=0 ;; 1333 }; 1334 if (pdfSelf && doExtended==2) {; 1335 doExtended = pdfSelf->extendMode()==RooAbsPdf::CanNotBeExtended ? 0 : 1 ;; 1336 } else if(!pdfSelf) {; 1337 doExtended = 0;; 1338 }; 1339 ; 1340 const char* compSpec = pc.getString(""compSpec"") ;; 1341 const RooArgSet* compSet = pc.getSet(""compSet"");; 1342 bool haveCompSel = ( (compSpec && strlen(compSpec)>0) || compSet) ;; 1343 ; 1344 std::unique_ptr<RooBinning> intBinning;; 1345 if (doIntBinning>0) {; 1346 // Given RooAbsPdf* pdf and RooRealVar* obs; 1347 std::unique_ptr<std::list<double>> bl{binBoundaries(const_cast<RooAbsRealLValue&>(xvar),xvar.getMin(),xvar.getMax())};; 1348 if (!bl) {; 1349 // Only emit warning when intrinsic binning is explicitly requested; 1350 if (doIntBinning==1) {; 1351 ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:54946,Modifiability,extend,extended,54946," {; 1304 return nullptr ;; 1305 }; 1306 ; 1307 RooArgList vars(xvar) ;; 1308 RooAbsArg* yvar = static_cast<RooAbsArg*>(pc.getObject(""yvar"")) ;; 1309 if (yvar) {; 1310 vars.add(*yvar) ;; 1311 }; 1312 RooAbsArg* zvar = static_cast<RooAbsArg*>(pc.getObject(""zvar"")) ;; 1313 if (zvar) {; 1314 vars.add(*zvar) ;; 1315 }; 1316 ; 1317 auto projObs = pc.getSet(""projObs"");; 1318 RooArgSet* intObs = nullptr ;; 1319 ; 1320 bool doScaling = pc.getInt(""scaling"") ;; 1321 Int_t doIntBinning = pc.getInt(""intBinning"") ;; 1322 Int_t doExtended = pc.getInt(""extended"") ;; 1323 ; 1324 // If doExtended is two, selection is automatic, set to 1 of pdf is extended, to zero otherwise; 1325 const RooAbsPdf* pdfSelf = dynamic_cast<const RooAbsPdf*>(this) ;; 1326 if (!pdfSelf && doExtended == 1) {; 1327 coutW(InputArguments) << ""RooAbsReal::createHistogram("" << GetName() << "") WARNING extended mode requested for a non-pdf object, ignored"" << std::endl ;; 1328 doExtended=0 ;; 1329 }; 1330 if (pdfSelf && doExtended==1 && pdfSelf->extendMode()==RooAbsPdf::CanNotBeExtended) {; 1331 coutW(InputArguments) << ""RooAbsReal::createHistogram("" << GetName() << "") WARNING extended mode requested for a non-extendable pdf, ignored"" << std::endl ;; 1332 doExtended=0 ;; 1333 }; 1334 if (pdfSelf && doExtended==2) {; 1335 doExtended = pdfSelf->extendMode()==RooAbsPdf::CanNotBeExtended ? 0 : 1 ;; 1336 } else if(!pdfSelf) {; 1337 doExtended = 0;; 1338 }; 1339 ; 1340 const char* compSpec = pc.getString(""compSpec"") ;; 1341 const RooArgSet* compSet = pc.getSet(""compSet"");; 1342 bool haveCompSel = ( (compSpec && strlen(compSpec)>0) || compSet) ;; 1343 ; 1344 std::unique_ptr<RooBinning> intBinning;; 1345 if (doIntBinning>0) {; 1346 // Given RooAbsPdf* pdf and RooRealVar* obs; 1347 std::unique_ptr<std::list<double>> bl{binBoundaries(const_cast<RooAbsRealLValue&>(xvar),xvar.getMin(),xvar.getMax())};; 1348 if (!bl) {; 1349 // Only emit warning when intrinsic binning is explicitly requested; 1350 if (doIntBinning==1) {; 1351 ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:54980,Modifiability,extend,extendable,54980," {; 1304 return nullptr ;; 1305 }; 1306 ; 1307 RooArgList vars(xvar) ;; 1308 RooAbsArg* yvar = static_cast<RooAbsArg*>(pc.getObject(""yvar"")) ;; 1309 if (yvar) {; 1310 vars.add(*yvar) ;; 1311 }; 1312 RooAbsArg* zvar = static_cast<RooAbsArg*>(pc.getObject(""zvar"")) ;; 1313 if (zvar) {; 1314 vars.add(*zvar) ;; 1315 }; 1316 ; 1317 auto projObs = pc.getSet(""projObs"");; 1318 RooArgSet* intObs = nullptr ;; 1319 ; 1320 bool doScaling = pc.getInt(""scaling"") ;; 1321 Int_t doIntBinning = pc.getInt(""intBinning"") ;; 1322 Int_t doExtended = pc.getInt(""extended"") ;; 1323 ; 1324 // If doExtended is two, selection is automatic, set to 1 of pdf is extended, to zero otherwise; 1325 const RooAbsPdf* pdfSelf = dynamic_cast<const RooAbsPdf*>(this) ;; 1326 if (!pdfSelf && doExtended == 1) {; 1327 coutW(InputArguments) << ""RooAbsReal::createHistogram("" << GetName() << "") WARNING extended mode requested for a non-pdf object, ignored"" << std::endl ;; 1328 doExtended=0 ;; 1329 }; 1330 if (pdfSelf && doExtended==1 && pdfSelf->extendMode()==RooAbsPdf::CanNotBeExtended) {; 1331 coutW(InputArguments) << ""RooAbsReal::createHistogram("" << GetName() << "") WARNING extended mode requested for a non-extendable pdf, ignored"" << std::endl ;; 1332 doExtended=0 ;; 1333 }; 1334 if (pdfSelf && doExtended==2) {; 1335 doExtended = pdfSelf->extendMode()==RooAbsPdf::CanNotBeExtended ? 0 : 1 ;; 1336 } else if(!pdfSelf) {; 1337 doExtended = 0;; 1338 }; 1339 ; 1340 const char* compSpec = pc.getString(""compSpec"") ;; 1341 const RooArgSet* compSet = pc.getSet(""compSet"");; 1342 bool haveCompSel = ( (compSpec && strlen(compSpec)>0) || compSet) ;; 1343 ; 1344 std::unique_ptr<RooBinning> intBinning;; 1345 if (doIntBinning>0) {; 1346 // Given RooAbsPdf* pdf and RooRealVar* obs; 1347 std::unique_ptr<std::list<double>> bl{binBoundaries(const_cast<RooAbsRealLValue&>(xvar),xvar.getMin(),xvar.getMax())};; 1348 if (!bl) {; 1349 // Only emit warning when intrinsic binning is explicitly requested; 1350 if (doIntBinning==1) {; 1351 ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:55115,Modifiability,extend,extendMode,55115," {; 1304 return nullptr ;; 1305 }; 1306 ; 1307 RooArgList vars(xvar) ;; 1308 RooAbsArg* yvar = static_cast<RooAbsArg*>(pc.getObject(""yvar"")) ;; 1309 if (yvar) {; 1310 vars.add(*yvar) ;; 1311 }; 1312 RooAbsArg* zvar = static_cast<RooAbsArg*>(pc.getObject(""zvar"")) ;; 1313 if (zvar) {; 1314 vars.add(*zvar) ;; 1315 }; 1316 ; 1317 auto projObs = pc.getSet(""projObs"");; 1318 RooArgSet* intObs = nullptr ;; 1319 ; 1320 bool doScaling = pc.getInt(""scaling"") ;; 1321 Int_t doIntBinning = pc.getInt(""intBinning"") ;; 1322 Int_t doExtended = pc.getInt(""extended"") ;; 1323 ; 1324 // If doExtended is two, selection is automatic, set to 1 of pdf is extended, to zero otherwise; 1325 const RooAbsPdf* pdfSelf = dynamic_cast<const RooAbsPdf*>(this) ;; 1326 if (!pdfSelf && doExtended == 1) {; 1327 coutW(InputArguments) << ""RooAbsReal::createHistogram("" << GetName() << "") WARNING extended mode requested for a non-pdf object, ignored"" << std::endl ;; 1328 doExtended=0 ;; 1329 }; 1330 if (pdfSelf && doExtended==1 && pdfSelf->extendMode()==RooAbsPdf::CanNotBeExtended) {; 1331 coutW(InputArguments) << ""RooAbsReal::createHistogram("" << GetName() << "") WARNING extended mode requested for a non-extendable pdf, ignored"" << std::endl ;; 1332 doExtended=0 ;; 1333 }; 1334 if (pdfSelf && doExtended==2) {; 1335 doExtended = pdfSelf->extendMode()==RooAbsPdf::CanNotBeExtended ? 0 : 1 ;; 1336 } else if(!pdfSelf) {; 1337 doExtended = 0;; 1338 }; 1339 ; 1340 const char* compSpec = pc.getString(""compSpec"") ;; 1341 const RooArgSet* compSet = pc.getSet(""compSet"");; 1342 bool haveCompSel = ( (compSpec && strlen(compSpec)>0) || compSet) ;; 1343 ; 1344 std::unique_ptr<RooBinning> intBinning;; 1345 if (doIntBinning>0) {; 1346 // Given RooAbsPdf* pdf and RooRealVar* obs; 1347 std::unique_ptr<std::list<double>> bl{binBoundaries(const_cast<RooAbsRealLValue&>(xvar),xvar.getMin(),xvar.getMax())};; 1348 if (!bl) {; 1349 // Only emit warning when intrinsic binning is explicitly requested; 1350 if (doIntBinning==1) {; 1351 ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:61212,Modifiability,variab,variable,61212,"alueOnly=*/true)) {; 1468 tmp.add(*arg,true);; 1469 }; 1470 }; 1471 }; 1472 ; 1473 // Add all nodes that depend on selected nodes by value; 1474 for (const auto arg : branchNodeSet) {; 1475 if (arg->dependsOn(*selNodes, nullptr, /*valueOnly=*/true)) {; 1476 tmp.add(*arg,true);; 1477 }; 1478 }; 1479 ; 1480 tmp.remove(*selNodes, true);; 1481 tmp.remove(*this);; 1482 selNodes->add(tmp);; 1483 coutI(Plotting) << ""RooAbsPdf::plotOn("" << GetName() << "") indirectly selected PDF components: "" << tmp << std::endl ;; 1484 ; 1485 // Set PDF selection bits according to selNodes; 1486 for (const auto arg : branchNodeSet) {; 1487 bool select = selNodes->find(arg->GetName()) != nullptr;; 1488 static_cast<RooAbsReal*>(arg)->selectComp(select);; 1489 }; 1490}; 1491 ; 1492 ; 1493 ; 1494////////////////////////////////////////////////////////////////////////////////; 1495/// Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; 1496/// will show a unit normalized curve in the frame variable, taken at the present value; 1497/// of other observables defined for this PDF.; 1498///; 1499/// \param[in] frame pointer to RooPlot; 1500/// \param[in] arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10 Ordered arguments; 1501///; 1502/// If a PDF is plotted in a frame in which a dataset has already been plotted, it will; 1503/// show a projected curve integrated over all variables that were present in the shown; 1504/// dataset except for the one on the x-axis. The normalization of the curve will also; 1505/// be adjusted to the event count of the plotted dataset. An informational message; 1506/// will be printed for each projection step that is performed.; 1507///; 1508/// This function takes the following named arguments; 1509/// <table>; 1510/// <tr><th><th> Projection control; 1511/// <tr><td> `Slice(const RooArgSet& set)` <td> Override default projection behaviour by omitting observables listed; 1512/// in set from the projection, i.e. by not integrating over thes",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:61598,Modifiability,variab,variables,61598,"478 }; 1479 ; 1480 tmp.remove(*selNodes, true);; 1481 tmp.remove(*this);; 1482 selNodes->add(tmp);; 1483 coutI(Plotting) << ""RooAbsPdf::plotOn("" << GetName() << "") indirectly selected PDF components: "" << tmp << std::endl ;; 1484 ; 1485 // Set PDF selection bits according to selNodes; 1486 for (const auto arg : branchNodeSet) {; 1487 bool select = selNodes->find(arg->GetName()) != nullptr;; 1488 static_cast<RooAbsReal*>(arg)->selectComp(select);; 1489 }; 1490}; 1491 ; 1492 ; 1493 ; 1494////////////////////////////////////////////////////////////////////////////////; 1495/// Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; 1496/// will show a unit normalized curve in the frame variable, taken at the present value; 1497/// of other observables defined for this PDF.; 1498///; 1499/// \param[in] frame pointer to RooPlot; 1500/// \param[in] arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10 Ordered arguments; 1501///; 1502/// If a PDF is plotted in a frame in which a dataset has already been plotted, it will; 1503/// show a projected curve integrated over all variables that were present in the shown; 1504/// dataset except for the one on the x-axis. The normalization of the curve will also; 1505/// be adjusted to the event count of the plotted dataset. An informational message; 1506/// will be printed for each projection step that is performed.; 1507///; 1508/// This function takes the following named arguments; 1509/// <table>; 1510/// <tr><th><th> Projection control; 1511/// <tr><td> `Slice(const RooArgSet& set)` <td> Override default projection behaviour by omitting observables listed; 1512/// in set from the projection, i.e. by not integrating over these.; 1513/// Slicing is usually only sensible in discrete observables, by e.g. creating a slice; 1514/// of the PDF at the current value of the category observable.; 1515///; 1516/// <tr><td> `Slice(RooCategory& cat, const char* label)` <td> Override default projection behaviour by omitti",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:71241,Modifiability,config,configuration,71241,"//////////////////; 1629/// Internal back-end function of plotOn() with named arguments; 1630 ; 1631RooPlot* RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& argList) const; 1632{; 1633 // Special handling here if argList contains RangeWithName argument with multiple; 1634 // range names -- Need to translate this call into multiple calls; 1635 ; 1636 RooCmdArg* rcmd = static_cast<RooCmdArg*>(argList.FindObject(""RangeWithName"")) ;; 1637 if (rcmd && TString(rcmd->getString(0)).Contains("","")) {; 1638 ; 1639 // List joint ranges as choice of normalization for all later processing; 1640 RooCmdArg rnorm = RooFit::NormRange(rcmd->getString(0)) ;; 1641 argList.Add(&rnorm) ;; 1642 ; 1643 for (const auto& rangeString : ROOT::Split(rcmd->getString(0), "","")) {; 1644 // Process each range with a separate command with a single range to be plotted; 1645 rcmd->setString(0, rangeString.c_str());; 1646 RooAbsReal::plotOn(frame,argList);; 1647 }; 1648 return frame ;; 1649 ; 1650 }; 1651 ; 1652 // Define configuration for this method; 1653 RooCmdConfig pc(""RooAbsReal::plotOn("" + std::string(GetName()) + "")"");; 1654 pc.defineString(""drawOption"",""DrawOption"",0,""L"") ;; 1655 pc.defineString(""projectionRangeName"",""ProjectionRange"",0,"""",true) ;; 1656 pc.defineString(""curveNameSuffix"",""CurveNameSuffix"",0,"""") ;; 1657 pc.defineString(""sliceCatState"",""SliceCat"",0,"""",true) ;; 1658 pc.defineDouble(""scaleFactor"",""Normalization"",0,1.0) ;; 1659 pc.defineInt(""scaleType"",""Normalization"",0,Relative) ;; 1660 pc.defineSet(""sliceSet"",""SliceVars"",0) ;; 1661 pc.defineObject(""sliceCatList"",""SliceCat"",0,nullptr,true) ;; 1662 // This dummy is needed for plotOn to recognize the ""SliceCatMany"" command.; 1663 // It is not used directly, but the ""SliceCat"" commands are nested in it.; 1664 // Removing this dummy definition results in ""ERROR: unrecognized command: SliceCatMany"".; 1665 pc.defineObject(""dummy1"",""SliceCatMany"",0) ;; 1666 pc.defineSet(""projSet"",""Project"",0) ;; 1667 pc.defineObject(""asymCat"",""Asymmetry"",",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:79014,Modifiability,variab,variables,79014,"cScale = true ;; 1788 }; 1789 ; 1790 o.wmode = (vlines==2)?RooCurve::Extended:(vlines==1?RooCurve::Straight:RooCurve::NoWings) ;; 1791 o.projectionRangeName = pc.getString(""projectionRangeName"",nullptr,true) ;; 1792 o.curveName = pc.getString(""curveName"",nullptr,true) ;; 1793 o.curveInvisible = pc.getInt(""curveInvisible"") ;; 1794 o.progress = pc.getInt(""showProg"") ;; 1795 o.addToCurveName = pc.getString(""addToCurveName"",nullptr,true) ;; 1796 o.addToWgtSelf = pc.getDouble(""addToWgtSelf"") ;; 1797 o.addToWgtOther = pc.getDouble(""addToWgtOther"") ;; 1798 ; 1799 if (o.addToCurveName && !frame->findObject(o.addToCurveName,RooCurve::Class())) {; 1800 coutE(InputArguments) << ""RooAbsReal::plotOn("" << GetName() << "") cannot find existing curve "" << o.addToCurveName << "" to add to in RooPlot"" << std::endl ;; 1801 return frame ;; 1802 }; 1803 ; 1804 RooArgSet projectedVars ;; 1805 if (sliceSet) {; 1806 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") Preprocessing: have slice "" << *sliceSet << std::endl ;; 1807 ; 1808 makeProjectionSet(frame->getPlotVar(),frame->getNormVars(),projectedVars,true) ;; 1809 ; 1810 // Take out the sliced variables; 1811 for (const auto sliceArg : *sliceSet) {; 1812 if (RooAbsArg* arg = projectedVars.find(sliceArg->GetName())) {; 1813 projectedVars.remove(*arg) ;; 1814 } else {; 1815 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") slice variable ""; 1816 << sliceArg->GetName() << "" was not projected anyway"" << std::endl ;; 1817 }; 1818 }; 1819 } else if (projSet) {; 1820 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") Preprocessing: have projSet "" << *projSet << std::endl ;; 1821 makeProjectionSet(frame->getPlotVar(),projSet,projectedVars,false) ;; 1822 } else {; 1823 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") Preprocessing: have neither sliceSet nor projSet "" << std::endl ;; 1824 makeProjectionSet(frame->getPlotVar(),frame->getNormVars(),projectedVars,true) ;; 1825 }; 1826 o.projSet = &project",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:79262,Modifiability,variab,variable,79262,")) {; 1800 coutE(InputArguments) << ""RooAbsReal::plotOn("" << GetName() << "") cannot find existing curve "" << o.addToCurveName << "" to add to in RooPlot"" << std::endl ;; 1801 return frame ;; 1802 }; 1803 ; 1804 RooArgSet projectedVars ;; 1805 if (sliceSet) {; 1806 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") Preprocessing: have slice "" << *sliceSet << std::endl ;; 1807 ; 1808 makeProjectionSet(frame->getPlotVar(),frame->getNormVars(),projectedVars,true) ;; 1809 ; 1810 // Take out the sliced variables; 1811 for (const auto sliceArg : *sliceSet) {; 1812 if (RooAbsArg* arg = projectedVars.find(sliceArg->GetName())) {; 1813 projectedVars.remove(*arg) ;; 1814 } else {; 1815 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") slice variable ""; 1816 << sliceArg->GetName() << "" was not projected anyway"" << std::endl ;; 1817 }; 1818 }; 1819 } else if (projSet) {; 1820 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") Preprocessing: have projSet "" << *projSet << std::endl ;; 1821 makeProjectionSet(frame->getPlotVar(),projSet,projectedVars,false) ;; 1822 } else {; 1823 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") Preprocessing: have neither sliceSet nor projSet "" << std::endl ;; 1824 makeProjectionSet(frame->getPlotVar(),frame->getNormVars(),projectedVars,true) ;; 1825 }; 1826 o.projSet = &projectedVars ;; 1827 ; 1828 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") Preprocessing: projectedVars = "" << projectedVars << std::endl ;; 1829 ; 1830 ; 1831 // Forward to actual calculation; 1832 RooPlot* ret = asymCat ? RooAbsReal::plotAsymOn(frame,*asymCat,o) : RooAbsReal::plotOn(frame,o);; 1833 ; 1834 // Optionally adjust line/fill attributes; 1835 Int_t lineColor = pc.getInt(""lineColor"") ;; 1836 Int_t lineStyle = pc.getInt(""lineStyle"") ;; 1837 Int_t lineWidth = pc.getInt(""lineWidth"") ;; 1838 Int_t markerColor = pc.getInt(""markerColor"") ;; 1839 Int_t markerStyle = pc.getInt(""markerStyle"") ;; 1840 Size_t markerSize = p",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:84029,Modifiability,variab,variables,84029,"::plotOn(RooPlot *frame, PlotOpt o) const; 1884{; 1885 // Sanity checks; 1886 if (plotSanityChecks(frame)) return frame ;; 1887 ; 1888 // ProjDataVars is either all projData observables, or the user indicated subset of it; 1889 RooArgSet projDataVars ;; 1890 if (o.projData) {; 1891 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") have ProjData with observables = "" << *o.projData->get() << std::endl ;; 1892 if (o.projDataSet) {; 1893 projDataVars.add(*std::unique_ptr<RooArgSet>{o.projData->get()->selectCommon(*o.projDataSet)}) ;; 1894 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") have ProjDataSet = "" << *o.projDataSet << "" will only use this subset of projData"" << std::endl ;; 1895 } else {; 1896 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") using full ProjData"" << std::endl ;; 1897 projDataVars.add(*o.projData->get()) ;; 1898 }; 1899 }; 1900 ; 1901 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") ProjDataVars = "" << projDataVars << std::endl ;; 1902 ; 1903 // Make list of variables to be projected; 1904 RooArgSet projectedVars ;; 1905 RooArgSet sliceSet ;; 1906 if (o.projSet) {; 1907 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") have input projSet = "" << *o.projSet << std::endl ;; 1908 makeProjectionSet(frame->getPlotVar(),o.projSet,projectedVars,false) ;; 1909 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") calculated projectedVars = "" << *o.projSet << std::endl ;; 1910 ; 1911 // Print list of non-projected variables; 1912 if (frame->getNormVars()) {; 1913 RooArgSet sliceSetTmp;; 1914 getObservables(frame->getNormVars(), sliceSetTmp) ;; 1915 ; 1916 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") frame->getNormVars() that are also observables = "" << sliceSetTmp << std::endl ;; 1917 ; 1918 sliceSetTmp.remove(projectedVars,true,true) ;; 1919 sliceSetTmp.remove(*frame->getPlotVar(),true,true) ;; 1920 ; 1921 if (o.projData) {; 1922 std::unique_ptr<RooArgSet> tmp{projDat",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:84504,Modifiability,variab,variables,84504,"projDataSet << "" will only use this subset of projData"" << std::endl ;; 1895 } else {; 1896 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") using full ProjData"" << std::endl ;; 1897 projDataVars.add(*o.projData->get()) ;; 1898 }; 1899 }; 1900 ; 1901 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") ProjDataVars = "" << projDataVars << std::endl ;; 1902 ; 1903 // Make list of variables to be projected; 1904 RooArgSet projectedVars ;; 1905 RooArgSet sliceSet ;; 1906 if (o.projSet) {; 1907 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") have input projSet = "" << *o.projSet << std::endl ;; 1908 makeProjectionSet(frame->getPlotVar(),o.projSet,projectedVars,false) ;; 1909 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") calculated projectedVars = "" << *o.projSet << std::endl ;; 1910 ; 1911 // Print list of non-projected variables; 1912 if (frame->getNormVars()) {; 1913 RooArgSet sliceSetTmp;; 1914 getObservables(frame->getNormVars(), sliceSetTmp) ;; 1915 ; 1916 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") frame->getNormVars() that are also observables = "" << sliceSetTmp << std::endl ;; 1917 ; 1918 sliceSetTmp.remove(projectedVars,true,true) ;; 1919 sliceSetTmp.remove(*frame->getPlotVar(),true,true) ;; 1920 ; 1921 if (o.projData) {; 1922 std::unique_ptr<RooArgSet> tmp{projDataVars.selectCommon(*o.projSet)};; 1923 sliceSetTmp.remove(*tmp,true,true) ;; 1924 }; 1925 ; 1926 if (!sliceSetTmp.empty()) {; 1927 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot on ""; 1928 << frame->getPlotVar()->GetName() << "" represents a slice in "" << sliceSetTmp << std::endl ;; 1929 }; 1930 sliceSet.add(sliceSetTmp) ;; 1931 }; 1932 } else {; 1933 makeProjectionSet(frame->getPlotVar(),frame->getNormVars(),projectedVars,true) ;; 1934 }; 1935 ; 1936 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") projectedVars = "" << projectedVars << "" sliceSet = "" << sliceSet << std::endl ;; 1937 ; 1938 ; 1939 RooArgSe",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:85907,Modifiability,variab,variable,85907,"ars.selectCommon(*o.projSet)};; 1923 sliceSetTmp.remove(*tmp,true,true) ;; 1924 }; 1925 ; 1926 if (!sliceSetTmp.empty()) {; 1927 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot on ""; 1928 << frame->getPlotVar()->GetName() << "" represents a slice in "" << sliceSetTmp << std::endl ;; 1929 }; 1930 sliceSet.add(sliceSetTmp) ;; 1931 }; 1932 } else {; 1933 makeProjectionSet(frame->getPlotVar(),frame->getNormVars(),projectedVars,true) ;; 1934 }; 1935 ; 1936 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") projectedVars = "" << projectedVars << "" sliceSet = "" << sliceSet << std::endl ;; 1937 ; 1938 ; 1939 RooArgSet* projDataNeededVars = nullptr ;; 1940 // Take out data-projected dependents from projectedVars; 1941 if (o.projData) {; 1942 projDataNeededVars = projectedVars.selectCommon(projDataVars);; 1943 projectedVars.remove(projDataVars,true,true) ;; 1944 }; 1945 ; 1946 // Get the plot variable and remember its original value; 1947 auto* plotVar = static_cast<RooRealVar*>(frame->getPlotVar());; 1948 double oldPlotVarVal = plotVar->getVal();; 1949 ; 1950 // Inform user about projections; 1951 if (!projectedVars.empty()) {; 1952 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot on "" << plotVar->GetName(); 1953 << "" integrates over variables "" << projectedVars; 1954 << (o.projectionRangeName?Form("" in range %s"",o.projectionRangeName):"""") << std::endl;; 1955 }; 1956 if (projDataNeededVars && !projDataNeededVars->empty()) {; 1957 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot on "" << plotVar->GetName(); 1958 << "" averages using data variables "" << *projDataNeededVars << std::endl ;; 1959 }; 1960 ; 1961 // Create projection integral; 1962 RooArgSet* projectionCompList = nullptr ;; 1963 ; 1964 RooArgSet deps;; 1965 getObservables(frame->getNormVars(), deps) ;; 1966 deps.remove(projectedVars,true,true) ;; 1967 if (projDataNeededVars) {; 1968 deps.remove(*projDataNeededVars,true,true) ;; 1969 }; 1970 deps.remove(*plotVar,",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:86272,Modifiability,variab,variables,86272," << "" represents a slice in "" << sliceSetTmp << std::endl ;; 1929 }; 1930 sliceSet.add(sliceSetTmp) ;; 1931 }; 1932 } else {; 1933 makeProjectionSet(frame->getPlotVar(),frame->getNormVars(),projectedVars,true) ;; 1934 }; 1935 ; 1936 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") projectedVars = "" << projectedVars << "" sliceSet = "" << sliceSet << std::endl ;; 1937 ; 1938 ; 1939 RooArgSet* projDataNeededVars = nullptr ;; 1940 // Take out data-projected dependents from projectedVars; 1941 if (o.projData) {; 1942 projDataNeededVars = projectedVars.selectCommon(projDataVars);; 1943 projectedVars.remove(projDataVars,true,true) ;; 1944 }; 1945 ; 1946 // Get the plot variable and remember its original value; 1947 auto* plotVar = static_cast<RooRealVar*>(frame->getPlotVar());; 1948 double oldPlotVarVal = plotVar->getVal();; 1949 ; 1950 // Inform user about projections; 1951 if (!projectedVars.empty()) {; 1952 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot on "" << plotVar->GetName(); 1953 << "" integrates over variables "" << projectedVars; 1954 << (o.projectionRangeName?Form("" in range %s"",o.projectionRangeName):"""") << std::endl;; 1955 }; 1956 if (projDataNeededVars && !projDataNeededVars->empty()) {; 1957 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot on "" << plotVar->GetName(); 1958 << "" averages using data variables "" << *projDataNeededVars << std::endl ;; 1959 }; 1960 ; 1961 // Create projection integral; 1962 RooArgSet* projectionCompList = nullptr ;; 1963 ; 1964 RooArgSet deps;; 1965 getObservables(frame->getNormVars(), deps) ;; 1966 deps.remove(projectedVars,true,true) ;; 1967 if (projDataNeededVars) {; 1968 deps.remove(*projDataNeededVars,true,true) ;; 1969 }; 1970 deps.remove(*plotVar,true,true) ;; 1971 deps.add(*plotVar) ;; 1972 ; 1973 // Now that we have the final set of dependents, call checkObservables(); 1974 ; 1975 // WVE take out conditional observables; 1976 if (checkObservables(&deps)) {; 1977 coutE(Plotting) ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:86595,Modifiability,variab,variables,86595,"l ;; 1937 ; 1938 ; 1939 RooArgSet* projDataNeededVars = nullptr ;; 1940 // Take out data-projected dependents from projectedVars; 1941 if (o.projData) {; 1942 projDataNeededVars = projectedVars.selectCommon(projDataVars);; 1943 projectedVars.remove(projDataVars,true,true) ;; 1944 }; 1945 ; 1946 // Get the plot variable and remember its original value; 1947 auto* plotVar = static_cast<RooRealVar*>(frame->getPlotVar());; 1948 double oldPlotVarVal = plotVar->getVal();; 1949 ; 1950 // Inform user about projections; 1951 if (!projectedVars.empty()) {; 1952 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot on "" << plotVar->GetName(); 1953 << "" integrates over variables "" << projectedVars; 1954 << (o.projectionRangeName?Form("" in range %s"",o.projectionRangeName):"""") << std::endl;; 1955 }; 1956 if (projDataNeededVars && !projDataNeededVars->empty()) {; 1957 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot on "" << plotVar->GetName(); 1958 << "" averages using data variables "" << *projDataNeededVars << std::endl ;; 1959 }; 1960 ; 1961 // Create projection integral; 1962 RooArgSet* projectionCompList = nullptr ;; 1963 ; 1964 RooArgSet deps;; 1965 getObservables(frame->getNormVars(), deps) ;; 1966 deps.remove(projectedVars,true,true) ;; 1967 if (projDataNeededVars) {; 1968 deps.remove(*projDataNeededVars,true,true) ;; 1969 }; 1970 deps.remove(*plotVar,true,true) ;; 1971 deps.add(*plotVar) ;; 1972 ; 1973 // Now that we have the final set of dependents, call checkObservables(); 1974 ; 1975 // WVE take out conditional observables; 1976 if (checkObservables(&deps)) {; 1977 coutE(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") error in checkObservables, abort"" << std::endl ;; 1978 if (projDataNeededVars) delete projDataNeededVars ;; 1979 return frame ;; 1980 }; 1981 ; 1982 RooAbsReal *projection = const_cast<RooAbsReal*>(createPlotProjection(deps, &projectedVars, projectionCompList, o.projectionRangeName));; 1983 cxcoutD(Plotting) << ""RooAbsReal::",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:88744,Modifiability,variab,variables,88744,"m(ccoutD(Plotting),0,kVerbose) ;; 1986 }; 1987 ; 1988 // Always fix RooAddPdf normalizations; 1989 RooArgSet fullNormSet(deps) ;; 1990 fullNormSet.add(projectedVars) ;; 1991 if (projDataNeededVars && !projDataNeededVars->empty()) {; 1992 fullNormSet.add(*projDataNeededVars) ;; 1993 }; 1994 ; 1995 std::unique_ptr<RooArgSet> projectionComponents(projection->getComponents());; 1996 for(auto * pdf : dynamic_range_cast<RooAbsPdf*>(*projectionComponents)) {; 1997 if (pdf) {; 1998 pdf->selectNormalization(&fullNormSet) ;; 1999 }; 2000 }; 2001 ; 2002 // Apply data projection, if requested; 2003 if (o.projData && projDataNeededVars && !projDataNeededVars->empty()) {; 2004 ; 2005 // If data set contains more rows than needed, make reduced copy first; 2006 RooAbsData* projDataSel = const_cast<RooAbsData*>(o.projData);; 2007 std::unique_ptr<RooAbsData> projDataSelOwned;; 2008 ; 2009 if (projDataNeededVars->size() < o.projData->get()->size()) {; 2010 ; 2011 // Determine if there are any slice variables in the projection set; 2012 std::unique_ptr<RooArgSet> sliceDataSet{sliceSet.selectCommon(*o.projData->get())};; 2013 TString cutString ;; 2014 if (!sliceDataSet->empty()) {; 2015 bool first(true) ;; 2016 for(RooAbsArg * sliceVar : *sliceDataSet) {; 2017 if (!first) {; 2018 cutString.Append(""&&"") ;; 2019 } else {; 2020 first=false ;; 2021 }; 2022 ; 2023 RooAbsRealLValue* real ;; 2024 RooAbsCategoryLValue* cat ;; 2025 if ((real = dynamic_cast<RooAbsRealLValue*>(sliceVar))) {; 2026 cutString.Append(Form(""%s==%f"",real->GetName(),real->getVal())) ;; 2027 } else if ((cat = dynamic_cast<RooAbsCategoryLValue*>(sliceVar))) {; 2028 cutString.Append(Form(""%s==%d"",cat->GetName(),cat->getCurrentIndex())) ;; 2029 }; 2030 }; 2031 }; 2032 ; 2033 if (!cutString.IsNull()) {; 2034 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") reducing given projection dataset to entries with "" << cutString << std::endl ;; 2035 }; 2036 projDataSelOwned = std::unique_ptr<RooAbsData>{const_cast<RooAbsData",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:90639,Modifiability,variab,variables,90639,"ction dataset to entries with "" << cutString << std::endl ;; 2035 }; 2036 projDataSelOwned = std::unique_ptr<RooAbsData>{const_cast<RooAbsData*>(o.projData)->reduce(*projDataNeededVars, cutString.IsNull() ? nullptr : cutString)};; 2037 projDataSel = projDataSelOwned.get();; 2038 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2039 << "") only the following components of the projection data will be used: "" << *projDataNeededVars << std::endl ;; 2040 }; 2041 ; 2042 // Request binning of unbinned projection dataset that consists exclusively of category observables; 2043 if (!o.binProjData && dynamic_cast<RooDataSet*>(projDataSel)!=nullptr) {; 2044 ; 2045 // Determine if dataset contains only categories; 2046 bool allCat(true) ;; 2047 for(RooAbsArg * arg2 : *projDataSel->get()) {; 2048 if (!dynamic_cast<RooCategory*>(arg2)) allCat = false ;; 2049 }; 2050 if (allCat) {; 2051 o.binProjData = true ;; 2052 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") unbinned projection dataset consist only of discrete variables,""; 2053 << "" performing projection with binned copy for optimization."" << std::endl ;; 2054 ; 2055 }; 2056 }; 2057 ; 2058 // Bin projection dataset if requested; 2059 if (o.binProjData) {; 2060 projDataSelOwned = std::make_unique<RooDataHist>(std::string(projDataSel->GetName()) + ""_binned"",""Binned projection data"",*projDataSel->get(),*projDataSel);; 2061 projDataSel = projDataSelOwned.get();; 2062 }; 2063 ; 2064 // Construct scaled data weighted average; 2065 ScaledDataWeightedAverage scaleBind{*projection, *projDataSel, o.scaleFactor, *plotVar};; 2066 ; 2067 // Set default range, if not specified; 2068 if (o.rangeLo==0 && o.rangeHi==0) {; 2069 o.rangeLo = frame->GetXaxis()->GetXmin() ;; 2070 o.rangeHi = frame->GetXaxis()->GetXmax() ;; 2071 }; 2072 ; 2073 // Construct name of curve for data weighed average; 2074 std::string curveName(projection->GetName()) ;; 2075 curveName.append(""_DataAvg["" + projDataSel->get()->contentsString() + ""]"");; 2076 /",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:96515,Modifiability,variab,variable,96515,"()) ;; 2170 ; 2171 // Add self to other curve if requested; 2172 if (o.addToCurveName) {; 2173 RooCurve* otherCurve = static_cast<RooCurve*>(frame->findObject(o.addToCurveName,RooCurve::Class())) ;; 2174 RooCurve* sumCurve = new RooCurve(projection->GetName(),projection->GetTitle(),*curve,*otherCurve,o.addToWgtSelf,o.addToWgtOther) ;; 2175 sumCurve->SetName(Form(""%s_PLUS_%s"",curve->GetName(),otherCurve->GetName())) ;; 2176 delete curve ;; 2177 curve = sumCurve ;; 2178 }; 2179 ; 2180 // Override name of curve by user name, if specified; 2181 if (o.curveName) {; 2182 curve->SetName(o.curveName) ;; 2183 }; 2184 ; 2185 // add this new curve to the specified plot frame; 2186 frame->addPlotable(curve, o.drawOptions, o.curveInvisible);; 2187 }; 2188 }; 2189 ; 2190 if (projDataNeededVars) delete projDataNeededVars ;; 2191 delete projectionCompList ;; 2192 plotVar->setVal(oldPlotVarVal); // reset the plot variable value to not disturb the original state; 2193 return frame;; 2194}; 2195 ; 2196 ; 2197//_____________________________________________________________________________; 2198// coverity[PASS_BY_VALUE]; 2199RooPlot* RooAbsReal::plotAsymOn(RooPlot *frame, const RooAbsCategoryLValue& asymCat, PlotOpt o) const; 2200 ; 2201{; 2202 // Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))); 2203 //; 2204 // Plot asymmetry of ourselves, defined as; 2205 //; 2206 // asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ); 2207 //; 2208 // on frame. If frame contains a histogram, all dimensions of the plotted; 2209 // asymmetry function that occur in the previously plotted dataset are projected via partial integration.; 2210 // Otherwise no projections are performed,; 2211 //; 2212 // The asymmetry function can be multiplied with an optional scale factor. The default projection; 2213 // behaviour can be overridden by supplying an optional set of dependents to project.; 2214 ; 2215 // Sanity checks; 2216 if (plotSanityCheck",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:98563,Modifiability,variab,variables,98563,"n by supplying an optional set of dependents to project.; 2214 ; 2215 // Sanity checks; 2216 if (plotSanityChecks(frame)) return frame ;; 2217 ; 2218 // ProjDataVars is either all projData observables, or the user indicated subset of it; 2219 RooArgSet projDataVars ;; 2220 if (o.projData) {; 2221 if (o.projDataSet) {; 2222 std::unique_ptr<RooArgSet> tmp{o.projData->get()->selectCommon(*o.projDataSet)};; 2223 projDataVars.add(*tmp) ;; 2224 } else {; 2225 projDataVars.add(*o.projData->get()) ;; 2226 }; 2227 }; 2228 ; 2229 // Must depend on asymCat; 2230 if (!dependsOn(asymCat)) {; 2231 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2232 << "") function doesn't depend on asymmetry category "" << asymCat.GetName() << std::endl ;; 2233 return frame ;; 2234 }; 2235 ; 2236 // asymCat must be a signCat; 2237 if (!asymCat.isSignType()) {; 2238 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2239 << "") asymmetry category must have 2 or 3 states with index values -1,0,1"" << std::endl ;; 2240 return frame ;; 2241 }; 2242 ; 2243 // Make list of variables to be projected; 2244 RooArgSet projectedVars ;; 2245 RooArgSet sliceSet ;; 2246 if (o.projSet) {; 2247 makeProjectionSet(frame->getPlotVar(),o.projSet,projectedVars,false) ;; 2248 ; 2249 // Print list of non-projected variables; 2250 if (frame->getNormVars()) {; 2251 RooArgSet sliceSetTmp;; 2252 getObservables(frame->getNormVars(), sliceSetTmp) ;; 2253 sliceSetTmp.remove(projectedVars,true,true) ;; 2254 sliceSetTmp.remove(*frame->getPlotVar(),true,true) ;; 2255 ; 2256 if (o.projData) {; 2257 std::unique_ptr<RooArgSet> tmp{projDataVars.selectCommon(*o.projSet)};; 2258 sliceSetTmp.remove(*tmp,true,true) ;; 2259 }; 2260 ; 2261 if (!sliceSetTmp.empty()) {; 2262 coutI(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName() << "") plot on ""; 2263 << frame->getPlotVar()->GetName() << "" represents a slice in "" << sliceSetTmp << std::endl ;; 2264 }; 2265 sliceSet.add(sliceSetTmp) ;; 2266 }; 2267 } else {; 2268 makeProject",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:98792,Modifiability,variab,variables,98792,"e_ptr<RooArgSet> tmp{o.projData->get()->selectCommon(*o.projDataSet)};; 2223 projDataVars.add(*tmp) ;; 2224 } else {; 2225 projDataVars.add(*o.projData->get()) ;; 2226 }; 2227 }; 2228 ; 2229 // Must depend on asymCat; 2230 if (!dependsOn(asymCat)) {; 2231 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2232 << "") function doesn't depend on asymmetry category "" << asymCat.GetName() << std::endl ;; 2233 return frame ;; 2234 }; 2235 ; 2236 // asymCat must be a signCat; 2237 if (!asymCat.isSignType()) {; 2238 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2239 << "") asymmetry category must have 2 or 3 states with index values -1,0,1"" << std::endl ;; 2240 return frame ;; 2241 }; 2242 ; 2243 // Make list of variables to be projected; 2244 RooArgSet projectedVars ;; 2245 RooArgSet sliceSet ;; 2246 if (o.projSet) {; 2247 makeProjectionSet(frame->getPlotVar(),o.projSet,projectedVars,false) ;; 2248 ; 2249 // Print list of non-projected variables; 2250 if (frame->getNormVars()) {; 2251 RooArgSet sliceSetTmp;; 2252 getObservables(frame->getNormVars(), sliceSetTmp) ;; 2253 sliceSetTmp.remove(projectedVars,true,true) ;; 2254 sliceSetTmp.remove(*frame->getPlotVar(),true,true) ;; 2255 ; 2256 if (o.projData) {; 2257 std::unique_ptr<RooArgSet> tmp{projDataVars.selectCommon(*o.projSet)};; 2258 sliceSetTmp.remove(*tmp,true,true) ;; 2259 }; 2260 ; 2261 if (!sliceSetTmp.empty()) {; 2262 coutI(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName() << "") plot on ""; 2263 << frame->getPlotVar()->GetName() << "" represents a slice in "" << sliceSetTmp << std::endl ;; 2264 }; 2265 sliceSet.add(sliceSetTmp) ;; 2266 }; 2267 } else {; 2268 makeProjectionSet(frame->getPlotVar(),frame->getNormVars(),projectedVars,true) ;; 2269 }; 2270 ; 2271 ; 2272 // Take out data-projected dependens from projectedVars; 2273 RooArgSet* projDataNeededVars = nullptr ;; 2274 if (o.projData) {; 2275 projDataNeededVars = projectedVars.selectCommon(projDataVars);; 2276 projectedVars.remove(projDataVars",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:100069,Modifiability,variab,variable,100069,"mp.remove(*tmp,true,true) ;; 2259 }; 2260 ; 2261 if (!sliceSetTmp.empty()) {; 2262 coutI(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName() << "") plot on ""; 2263 << frame->getPlotVar()->GetName() << "" represents a slice in "" << sliceSetTmp << std::endl ;; 2264 }; 2265 sliceSet.add(sliceSetTmp) ;; 2266 }; 2267 } else {; 2268 makeProjectionSet(frame->getPlotVar(),frame->getNormVars(),projectedVars,true) ;; 2269 }; 2270 ; 2271 ; 2272 // Take out data-projected dependens from projectedVars; 2273 RooArgSet* projDataNeededVars = nullptr ;; 2274 if (o.projData) {; 2275 projDataNeededVars = projectedVars.selectCommon(projDataVars);; 2276 projectedVars.remove(projDataVars,true,true) ;; 2277 }; 2278 ; 2279 // Take out plotted asymmetry from projection; 2280 if (projectedVars.find(asymCat.GetName())) {; 2281 projectedVars.remove(*projectedVars.find(asymCat.GetName())) ;; 2282 }; 2283 ; 2284 // Clone the plot variable; 2285 RooAbsReal* realVar = static_cast<RooRealVar*>(frame->getPlotVar()) ;; 2286 RooRealVar* plotVar = static_cast<RooRealVar*>(realVar->Clone()) ;; 2287 ; 2288 // Inform user about projections; 2289 if (!projectedVars.empty()) {; 2290 coutI(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName() << "") plot on "" << plotVar->GetName(); 2291 << "" projects variables "" << projectedVars << std::endl ;; 2292 }; 2293 if (projDataNeededVars && !projDataNeededVars->empty()) {; 2294 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot on "" << plotVar->GetName(); 2295 << "" averages using data variables ""<< *projDataNeededVars << std::endl ;; 2296 }; 2297 ; 2298 ; 2299 // Customize two copies of projection with fixed negative and positive asymmetry; 2300 std::unique_ptr<RooAbsCategoryLValue> asymPos{static_cast<RooAbsCategoryLValue*>(asymCat.Clone(""asym_pos""))};; 2301 std::unique_ptr<RooAbsCategoryLValue> asymNeg{static_cast<RooAbsCategoryLValue*>(asymCat.Clone(""asym_neg""))};; 2302 asymPos->setIndex(1) ;; 2303 asymNeg->setIndex(-1) ;; 2304 RooCustomizer custPos{*thi",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:100431,Modifiability,variab,variables,100431,"jected dependens from projectedVars; 2273 RooArgSet* projDataNeededVars = nullptr ;; 2274 if (o.projData) {; 2275 projDataNeededVars = projectedVars.selectCommon(projDataVars);; 2276 projectedVars.remove(projDataVars,true,true) ;; 2277 }; 2278 ; 2279 // Take out plotted asymmetry from projection; 2280 if (projectedVars.find(asymCat.GetName())) {; 2281 projectedVars.remove(*projectedVars.find(asymCat.GetName())) ;; 2282 }; 2283 ; 2284 // Clone the plot variable; 2285 RooAbsReal* realVar = static_cast<RooRealVar*>(frame->getPlotVar()) ;; 2286 RooRealVar* plotVar = static_cast<RooRealVar*>(realVar->Clone()) ;; 2287 ; 2288 // Inform user about projections; 2289 if (!projectedVars.empty()) {; 2290 coutI(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName() << "") plot on "" << plotVar->GetName(); 2291 << "" projects variables "" << projectedVars << std::endl ;; 2292 }; 2293 if (projDataNeededVars && !projDataNeededVars->empty()) {; 2294 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot on "" << plotVar->GetName(); 2295 << "" averages using data variables ""<< *projDataNeededVars << std::endl ;; 2296 }; 2297 ; 2298 ; 2299 // Customize two copies of projection with fixed negative and positive asymmetry; 2300 std::unique_ptr<RooAbsCategoryLValue> asymPos{static_cast<RooAbsCategoryLValue*>(asymCat.Clone(""asym_pos""))};; 2301 std::unique_ptr<RooAbsCategoryLValue> asymNeg{static_cast<RooAbsCategoryLValue*>(asymCat.Clone(""asym_neg""))};; 2302 asymPos->setIndex(1) ;; 2303 asymNeg->setIndex(-1) ;; 2304 RooCustomizer custPos{*this,""pos""};; 2305 RooCustomizer custNeg{*this,""neg""};; 2306 //custPos->setOwning(true) ;; 2307 //custNeg->setOwning(true) ;; 2308 custPos.replaceArg(asymCat,*asymPos) ;; 2309 custNeg.replaceArg(asymCat,*asymNeg) ;; 2310 std::unique_ptr<RooAbsReal> funcPos{static_cast<RooAbsReal*>(custPos.build())};; 2311 std::unique_ptr<RooAbsReal> funcNeg{static_cast<RooAbsReal*>(custNeg.build())};; 2312 ; 2313 // Create projection integral; 2314 RooArgSet *posProjCompLi",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:100676,Modifiability,variab,variables,100676,"jected dependens from projectedVars; 2273 RooArgSet* projDataNeededVars = nullptr ;; 2274 if (o.projData) {; 2275 projDataNeededVars = projectedVars.selectCommon(projDataVars);; 2276 projectedVars.remove(projDataVars,true,true) ;; 2277 }; 2278 ; 2279 // Take out plotted asymmetry from projection; 2280 if (projectedVars.find(asymCat.GetName())) {; 2281 projectedVars.remove(*projectedVars.find(asymCat.GetName())) ;; 2282 }; 2283 ; 2284 // Clone the plot variable; 2285 RooAbsReal* realVar = static_cast<RooRealVar*>(frame->getPlotVar()) ;; 2286 RooRealVar* plotVar = static_cast<RooRealVar*>(realVar->Clone()) ;; 2287 ; 2288 // Inform user about projections; 2289 if (!projectedVars.empty()) {; 2290 coutI(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName() << "") plot on "" << plotVar->GetName(); 2291 << "" projects variables "" << projectedVars << std::endl ;; 2292 }; 2293 if (projDataNeededVars && !projDataNeededVars->empty()) {; 2294 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot on "" << plotVar->GetName(); 2295 << "" averages using data variables ""<< *projDataNeededVars << std::endl ;; 2296 }; 2297 ; 2298 ; 2299 // Customize two copies of projection with fixed negative and positive asymmetry; 2300 std::unique_ptr<RooAbsCategoryLValue> asymPos{static_cast<RooAbsCategoryLValue*>(asymCat.Clone(""asym_pos""))};; 2301 std::unique_ptr<RooAbsCategoryLValue> asymNeg{static_cast<RooAbsCategoryLValue*>(asymCat.Clone(""asym_neg""))};; 2302 asymPos->setIndex(1) ;; 2303 asymNeg->setIndex(-1) ;; 2304 RooCustomizer custPos{*this,""pos""};; 2305 RooCustomizer custNeg{*this,""neg""};; 2306 //custPos->setOwning(true) ;; 2307 //custNeg->setOwning(true) ;; 2308 custPos.replaceArg(asymCat,*asymPos) ;; 2309 custNeg.replaceArg(asymCat,*asymNeg) ;; 2310 std::unique_ptr<RooAbsReal> funcPos{static_cast<RooAbsReal*>(custPos.build())};; 2311 std::unique_ptr<RooAbsReal> funcNeg{static_cast<RooAbsReal*>(custNeg.build())};; 2312 ; 2313 // Create projection integral; 2314 RooArgSet *posProjCompLi",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:103187,Modifiability,variab,variables,103187,"geName) ;; 2326 if (!posProj || !negProj) {; 2327 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName() << "") Unable to create projections, abort"" << std::endl ;; 2328 return frame ;; 2329 }; 2330 ; 2331 // Create a RooFormulaVar representing the asymmetry; 2332 TString asymName(GetName()) ;; 2333 asymName.Append(""_Asym["") ;; 2334 asymName.Append(asymCat.GetName()) ;; 2335 asymName.Append(""]"") ;; 2336 TString asymTitle(asymCat.GetName()) ;; 2337 asymTitle.Append("" Asymmetry of "") ;; 2338 asymTitle.Append(GetTitle()) ;; 2339 RooFormulaVar funcAsym{asymName,asymTitle,""(@0-@1)/(@0+@1)"",RooArgSet(*posProj,*negProj)};; 2340 ; 2341 if (o.projData) {; 2342 ; 2343 // If data set contains more rows than needed, make reduced copy first; 2344 RooAbsData* projDataSel = const_cast<RooAbsData*>(o.projData);; 2345 std::unique_ptr<RooAbsData> projDataSelOwned;; 2346 if (projDataNeededVars && projDataNeededVars->size() < o.projData->get()->size()) {; 2347 ; 2348 // Determine if there are any slice variables in the projection set; 2349 RooArgSet sliceDataSet;; 2350 sliceSet.selectCommon(*o.projData->get(), sliceDataSet);; 2351 TString cutString ;; 2352 if (!sliceDataSet.empty()) {; 2353 bool first(true) ;; 2354 for(RooAbsArg * sliceVar : sliceDataSet) {; 2355 if (!first) {; 2356 cutString.Append(""&&"") ;; 2357 } else {; 2358 first=false ;; 2359 }; 2360 ; 2361 RooAbsRealLValue* real ;; 2362 RooAbsCategoryLValue* cat ;; 2363 if ((real = dynamic_cast<RooAbsRealLValue*>(sliceVar))) {; 2364 cutString.Append(Form(""%s==%f"",real->GetName(),real->getVal())) ;; 2365 } else if ((cat = dynamic_cast<RooAbsCategoryLValue*>(sliceVar))) {; 2366 cutString.Append(Form(""%s==%d"",cat->GetName(),cat->getCurrentIndex())) ;; 2367 }; 2368 }; 2369 }; 2370 ; 2371 if (!cutString.IsNull()) {; 2372 coutI(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2373 << "") reducing given projection dataset to entries with "" << cutString << std::endl ;; 2374 }; 2375 projDataSelOwned = std::unique_ptr<RooAbsData>{const",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:121705,Modifiability,config,configuration,121705,"tVal(cenVal-Z*errVal) ;; 2758 plotFunc(*cloneFunc);; 2759 minusVar.push_back(frame->getCurve()) ;; 2760 frame->remove(nullptr,false) ;; 2761 ; 2762 (static_cast<RooRealVar*>(paramList.at(ivar)))->setVal(cenVal) ;; 2763 }; 2764 ; 2765 TMatrixDSym C(paramList.size()) ;; 2766 std::vector<double> errVec(paramList.size()) ;; 2767 for (std::size_t i=0 ; i<paramList.size() ; i++) {; 2768 errVec[i] = sqrt(V(i,i)) ;; 2769 for (std::size_t j=i ; j<paramList.size() ; j++) {; 2770 C(i,j) = V(i,j)/sqrt(V(i,i)*V(j,j)) ;; 2771 C(j,i) = C(i,j) ;; 2772 }; 2773 }; 2774 ; 2775 band = cenCurve->makeErrorBand(plusVar,minusVar,C,Z) ;; 2776 ; 2777 ; 2778 // Cleanup; 2779 delete cloneFunc ;; 2780 for (std::vector<RooCurve*>::iterator i=plusVar.begin() ; i!=plusVar.end() ; ++i) {; 2781 delete (*i) ;; 2782 }; 2783 for (std::vector<RooCurve*>::iterator i=minusVar.begin() ; i!=minusVar.end() ; ++i) {; 2784 delete (*i) ;; 2785 }; 2786 ; 2787 }; 2788 ; 2789 delete cenCurve ;; 2790 if (!band) return frame ;; 2791 ; 2792 // Define configuration for this method; 2793 RooCmdConfig pc(""RooAbsPdf::plotOn("" + std::string(GetName()) + "")"");; 2794 pc.defineString(""drawOption"",""DrawOption"",0,""F"") ;; 2795 pc.defineString(""curveNameSuffix"",""CurveNameSuffix"",0,"""") ;; 2796 pc.defineInt(""lineColor"",""LineColor"",0,-999) ;; 2797 pc.defineInt(""lineStyle"",""LineStyle"",0,-999) ;; 2798 pc.defineInt(""lineWidth"",""LineWidth"",0,-999) ;; 2799 pc.defineInt(""markerColor"",""MarkerColor"",0,-999) ;; 2800 pc.defineInt(""markerStyle"",""MarkerStyle"",0,-999) ;; 2801 pc.defineDouble(""markerSize"",""MarkerSize"",0,-999) ;; 2802 pc.defineInt(""fillColor"",""FillColor"",0,-999) ;; 2803 pc.defineInt(""fillStyle"",""FillStyle"",0,-999) ;; 2804 pc.defineString(""curveName"",""Name"",0,"""") ;; 2805 pc.defineInt(""curveInvisible"",""Invisible"",0,0) ;; 2806 pc.defineInt(""moveToBack"",""MoveToBack"",0,0) ;; 2807 pc.allowUndefined() ;; 2808 ; 2809 // Process & check varargs; 2810 pc.process(argList) ;; 2811 if (!pc.ok(true)) {; 2812 return frame ;; 2813 }; 2814 ; 2815 ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:125099,Modifiability,variab,variable,125099,"nserted object to back to drawing stack if requested; 2846 if (pc.getInt(""moveToBack"") && frame->numItems()>1) {; 2847 frame->drawBefore(frame->getObject(0)->GetName(), frame->getCurve()->GetName());; 2848 }; 2849 ; 2850 ; 2851 return frame ;; 2852}; 2853 ; 2854 ; 2855 ; 2856 ; 2857////////////////////////////////////////////////////////////////////////////////; 2858/// Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations; 2859 ; 2860bool RooAbsReal::plotSanityChecks(RooPlot* frame) const; 2861{; 2862 // check that we are passed a valid plot frame to use; 2863 if(nullptr == frame) {; 2864 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: frame is null"" << std::endl;; 2865 return true;; 2866 }; 2867 ; 2868 // check that this frame knows what variable to plot; 2869 RooAbsReal* var = frame->getPlotVar() ;; 2870 if(!var) {; 2871 coutE(Plotting) << ClassName() << ""::"" << GetName(); 2872 << "":plotOn: frame does not specify a plot variable"" << std::endl;; 2873 return true;; 2874 }; 2875 ; 2876 // check that the plot variable is not derived; 2877 if(!dynamic_cast<RooAbsRealLValue*>(var)) {; 2878 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: cannot plot variable \""""; 2879 << var->GetName() << ""\"" of type "" << var->ClassName() << std::endl;; 2880 return true;; 2881 }; 2882 ; 2883 // check if we actually depend on the plot variable; 2884 if(!this->dependsOn(*var)) {; 2885 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: WARNING: variable is not an explicit dependent: ""; 2886 << var->GetName() << std::endl;; 2887 }; 2888 ; 2889 return false ;; 2890}; 2891 ; 2892 ; 2893 ; 2894 ; 2895////////////////////////////////////////////////////////////////////////////////; 2896/// Utility function for plotOn() that constructs the set of; 2897/// observables to project when plotting ourselves as function of; 2898/// 'plotVar'. 'allVars' is the list of variables that must be; 2899/// projecte",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:125286,Modifiability,variab,variable,125286,"nserted object to back to drawing stack if requested; 2846 if (pc.getInt(""moveToBack"") && frame->numItems()>1) {; 2847 frame->drawBefore(frame->getObject(0)->GetName(), frame->getCurve()->GetName());; 2848 }; 2849 ; 2850 ; 2851 return frame ;; 2852}; 2853 ; 2854 ; 2855 ; 2856 ; 2857////////////////////////////////////////////////////////////////////////////////; 2858/// Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations; 2859 ; 2860bool RooAbsReal::plotSanityChecks(RooPlot* frame) const; 2861{; 2862 // check that we are passed a valid plot frame to use; 2863 if(nullptr == frame) {; 2864 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: frame is null"" << std::endl;; 2865 return true;; 2866 }; 2867 ; 2868 // check that this frame knows what variable to plot; 2869 RooAbsReal* var = frame->getPlotVar() ;; 2870 if(!var) {; 2871 coutE(Plotting) << ClassName() << ""::"" << GetName(); 2872 << "":plotOn: frame does not specify a plot variable"" << std::endl;; 2873 return true;; 2874 }; 2875 ; 2876 // check that the plot variable is not derived; 2877 if(!dynamic_cast<RooAbsRealLValue*>(var)) {; 2878 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: cannot plot variable \""""; 2879 << var->GetName() << ""\"" of type "" << var->ClassName() << std::endl;; 2880 return true;; 2881 }; 2882 ; 2883 // check if we actually depend on the plot variable; 2884 if(!this->dependsOn(*var)) {; 2885 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: WARNING: variable is not an explicit dependent: ""; 2886 << var->GetName() << std::endl;; 2887 }; 2888 ; 2889 return false ;; 2890}; 2891 ; 2892 ; 2893 ; 2894 ; 2895////////////////////////////////////////////////////////////////////////////////; 2896/// Utility function for plotOn() that constructs the set of; 2897/// observables to project when plotting ourselves as function of; 2898/// 'plotVar'. 'allVars' is the list of variables that must be; 2899/// projecte",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:125373,Modifiability,variab,variable,125373,"nserted object to back to drawing stack if requested; 2846 if (pc.getInt(""moveToBack"") && frame->numItems()>1) {; 2847 frame->drawBefore(frame->getObject(0)->GetName(), frame->getCurve()->GetName());; 2848 }; 2849 ; 2850 ; 2851 return frame ;; 2852}; 2853 ; 2854 ; 2855 ; 2856 ; 2857////////////////////////////////////////////////////////////////////////////////; 2858/// Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations; 2859 ; 2860bool RooAbsReal::plotSanityChecks(RooPlot* frame) const; 2861{; 2862 // check that we are passed a valid plot frame to use; 2863 if(nullptr == frame) {; 2864 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: frame is null"" << std::endl;; 2865 return true;; 2866 }; 2867 ; 2868 // check that this frame knows what variable to plot; 2869 RooAbsReal* var = frame->getPlotVar() ;; 2870 if(!var) {; 2871 coutE(Plotting) << ClassName() << ""::"" << GetName(); 2872 << "":plotOn: frame does not specify a plot variable"" << std::endl;; 2873 return true;; 2874 }; 2875 ; 2876 // check that the plot variable is not derived; 2877 if(!dynamic_cast<RooAbsRealLValue*>(var)) {; 2878 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: cannot plot variable \""""; 2879 << var->GetName() << ""\"" of type "" << var->ClassName() << std::endl;; 2880 return true;; 2881 }; 2882 ; 2883 // check if we actually depend on the plot variable; 2884 if(!this->dependsOn(*var)) {; 2885 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: WARNING: variable is not an explicit dependent: ""; 2886 << var->GetName() << std::endl;; 2887 }; 2888 ; 2889 return false ;; 2890}; 2891 ; 2892 ; 2893 ; 2894 ; 2895////////////////////////////////////////////////////////////////////////////////; 2896/// Utility function for plotOn() that constructs the set of; 2897/// observables to project when plotting ourselves as function of; 2898/// 'plotVar'. 'allVars' is the list of variables that must be; 2899/// projecte",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:125530,Modifiability,variab,variable,125530,"nserted object to back to drawing stack if requested; 2846 if (pc.getInt(""moveToBack"") && frame->numItems()>1) {; 2847 frame->drawBefore(frame->getObject(0)->GetName(), frame->getCurve()->GetName());; 2848 }; 2849 ; 2850 ; 2851 return frame ;; 2852}; 2853 ; 2854 ; 2855 ; 2856 ; 2857////////////////////////////////////////////////////////////////////////////////; 2858/// Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations; 2859 ; 2860bool RooAbsReal::plotSanityChecks(RooPlot* frame) const; 2861{; 2862 // check that we are passed a valid plot frame to use; 2863 if(nullptr == frame) {; 2864 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: frame is null"" << std::endl;; 2865 return true;; 2866 }; 2867 ; 2868 // check that this frame knows what variable to plot; 2869 RooAbsReal* var = frame->getPlotVar() ;; 2870 if(!var) {; 2871 coutE(Plotting) << ClassName() << ""::"" << GetName(); 2872 << "":plotOn: frame does not specify a plot variable"" << std::endl;; 2873 return true;; 2874 }; 2875 ; 2876 // check that the plot variable is not derived; 2877 if(!dynamic_cast<RooAbsRealLValue*>(var)) {; 2878 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: cannot plot variable \""""; 2879 << var->GetName() << ""\"" of type "" << var->ClassName() << std::endl;; 2880 return true;; 2881 }; 2882 ; 2883 // check if we actually depend on the plot variable; 2884 if(!this->dependsOn(*var)) {; 2885 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: WARNING: variable is not an explicit dependent: ""; 2886 << var->GetName() << std::endl;; 2887 }; 2888 ; 2889 return false ;; 2890}; 2891 ; 2892 ; 2893 ; 2894 ; 2895////////////////////////////////////////////////////////////////////////////////; 2896/// Utility function for plotOn() that constructs the set of; 2897/// observables to project when plotting ourselves as function of; 2898/// 'plotVar'. 'allVars' is the list of variables that must be; 2899/// projecte",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:125701,Modifiability,variab,variable,125701,"nserted object to back to drawing stack if requested; 2846 if (pc.getInt(""moveToBack"") && frame->numItems()>1) {; 2847 frame->drawBefore(frame->getObject(0)->GetName(), frame->getCurve()->GetName());; 2848 }; 2849 ; 2850 ; 2851 return frame ;; 2852}; 2853 ; 2854 ; 2855 ; 2856 ; 2857////////////////////////////////////////////////////////////////////////////////; 2858/// Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations; 2859 ; 2860bool RooAbsReal::plotSanityChecks(RooPlot* frame) const; 2861{; 2862 // check that we are passed a valid plot frame to use; 2863 if(nullptr == frame) {; 2864 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: frame is null"" << std::endl;; 2865 return true;; 2866 }; 2867 ; 2868 // check that this frame knows what variable to plot; 2869 RooAbsReal* var = frame->getPlotVar() ;; 2870 if(!var) {; 2871 coutE(Plotting) << ClassName() << ""::"" << GetName(); 2872 << "":plotOn: frame does not specify a plot variable"" << std::endl;; 2873 return true;; 2874 }; 2875 ; 2876 // check that the plot variable is not derived; 2877 if(!dynamic_cast<RooAbsRealLValue*>(var)) {; 2878 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: cannot plot variable \""""; 2879 << var->GetName() << ""\"" of type "" << var->ClassName() << std::endl;; 2880 return true;; 2881 }; 2882 ; 2883 // check if we actually depend on the plot variable; 2884 if(!this->dependsOn(*var)) {; 2885 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: WARNING: variable is not an explicit dependent: ""; 2886 << var->GetName() << std::endl;; 2887 }; 2888 ; 2889 return false ;; 2890}; 2891 ; 2892 ; 2893 ; 2894 ; 2895////////////////////////////////////////////////////////////////////////////////; 2896/// Utility function for plotOn() that constructs the set of; 2897/// observables to project when plotting ourselves as function of; 2898/// 'plotVar'. 'allVars' is the list of variables that must be; 2899/// projecte",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:125825,Modifiability,variab,variable,125825,"nserted object to back to drawing stack if requested; 2846 if (pc.getInt(""moveToBack"") && frame->numItems()>1) {; 2847 frame->drawBefore(frame->getObject(0)->GetName(), frame->getCurve()->GetName());; 2848 }; 2849 ; 2850 ; 2851 return frame ;; 2852}; 2853 ; 2854 ; 2855 ; 2856 ; 2857////////////////////////////////////////////////////////////////////////////////; 2858/// Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations; 2859 ; 2860bool RooAbsReal::plotSanityChecks(RooPlot* frame) const; 2861{; 2862 // check that we are passed a valid plot frame to use; 2863 if(nullptr == frame) {; 2864 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: frame is null"" << std::endl;; 2865 return true;; 2866 }; 2867 ; 2868 // check that this frame knows what variable to plot; 2869 RooAbsReal* var = frame->getPlotVar() ;; 2870 if(!var) {; 2871 coutE(Plotting) << ClassName() << ""::"" << GetName(); 2872 << "":plotOn: frame does not specify a plot variable"" << std::endl;; 2873 return true;; 2874 }; 2875 ; 2876 // check that the plot variable is not derived; 2877 if(!dynamic_cast<RooAbsRealLValue*>(var)) {; 2878 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: cannot plot variable \""""; 2879 << var->GetName() << ""\"" of type "" << var->ClassName() << std::endl;; 2880 return true;; 2881 }; 2882 ; 2883 // check if we actually depend on the plot variable; 2884 if(!this->dependsOn(*var)) {; 2885 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: WARNING: variable is not an explicit dependent: ""; 2886 << var->GetName() << std::endl;; 2887 }; 2888 ; 2889 return false ;; 2890}; 2891 ; 2892 ; 2893 ; 2894 ; 2895////////////////////////////////////////////////////////////////////////////////; 2896/// Utility function for plotOn() that constructs the set of; 2897/// observables to project when plotting ourselves as function of; 2898/// 'plotVar'. 'allVars' is the list of variables that must be; 2899/// projecte",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:126243,Modifiability,variab,variables,126243,"y a plot variable"" << std::endl;; 2873 return true;; 2874 }; 2875 ; 2876 // check that the plot variable is not derived; 2877 if(!dynamic_cast<RooAbsRealLValue*>(var)) {; 2878 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: cannot plot variable \""""; 2879 << var->GetName() << ""\"" of type "" << var->ClassName() << std::endl;; 2880 return true;; 2881 }; 2882 ; 2883 // check if we actually depend on the plot variable; 2884 if(!this->dependsOn(*var)) {; 2885 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: WARNING: variable is not an explicit dependent: ""; 2886 << var->GetName() << std::endl;; 2887 }; 2888 ; 2889 return false ;; 2890}; 2891 ; 2892 ; 2893 ; 2894 ; 2895////////////////////////////////////////////////////////////////////////////////; 2896/// Utility function for plotOn() that constructs the set of; 2897/// observables to project when plotting ourselves as function of; 2898/// 'plotVar'. 'allVars' is the list of variables that must be; 2899/// projected, but may contain variables that we do not depend on. If; 2900/// 'silent' is cleared, warnings about inconsistent input parameters; 2901/// will be printed.; 2902 ; 2903void RooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars,; 2904 RooArgSet& projectedVars, bool silent) const; 2905{; 2906 cxcoutD(Plotting) << ""RooAbsReal::makeProjectionSet("" << GetName() << "") plotVar = "" << plotVar->GetName(); 2907 << "" allVars = "" << (allVars?(*allVars):RooArgSet()) << std::endl ;; 2908 ; 2909 projectedVars.removeAll() ;; 2910 if (!allVars) return ;; 2911 ; 2912 // Start out with suggested list of variables; 2913 projectedVars.add(*allVars) ;; 2914 ; 2915 // Take out plot variable; 2916 RooAbsArg *found= projectedVars.find(plotVar->GetName());; 2917 if(found) {; 2918 projectedVars.remove(*found);; 2919 ; 2920 // Take out eventual servers of plotVar; 2921 std::unique_ptr<RooArgSet> plotServers{plotVar->getObservables(&projectedVars)};; 2922 for(RooAbsArg * ps : *p",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:126302,Modifiability,variab,variables,126302,"y a plot variable"" << std::endl;; 2873 return true;; 2874 }; 2875 ; 2876 // check that the plot variable is not derived; 2877 if(!dynamic_cast<RooAbsRealLValue*>(var)) {; 2878 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: cannot plot variable \""""; 2879 << var->GetName() << ""\"" of type "" << var->ClassName() << std::endl;; 2880 return true;; 2881 }; 2882 ; 2883 // check if we actually depend on the plot variable; 2884 if(!this->dependsOn(*var)) {; 2885 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: WARNING: variable is not an explicit dependent: ""; 2886 << var->GetName() << std::endl;; 2887 }; 2888 ; 2889 return false ;; 2890}; 2891 ; 2892 ; 2893 ; 2894 ; 2895////////////////////////////////////////////////////////////////////////////////; 2896/// Utility function for plotOn() that constructs the set of; 2897/// observables to project when plotting ourselves as function of; 2898/// 'plotVar'. 'allVars' is the list of variables that must be; 2899/// projected, but may contain variables that we do not depend on. If; 2900/// 'silent' is cleared, warnings about inconsistent input parameters; 2901/// will be printed.; 2902 ; 2903void RooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars,; 2904 RooArgSet& projectedVars, bool silent) const; 2905{; 2906 cxcoutD(Plotting) << ""RooAbsReal::makeProjectionSet("" << GetName() << "") plotVar = "" << plotVar->GetName(); 2907 << "" allVars = "" << (allVars?(*allVars):RooArgSet()) << std::endl ;; 2908 ; 2909 projectedVars.removeAll() ;; 2910 if (!allVars) return ;; 2911 ; 2912 // Start out with suggested list of variables; 2913 projectedVars.add(*allVars) ;; 2914 ; 2915 // Take out plot variable; 2916 RooAbsArg *found= projectedVars.find(plotVar->GetName());; 2917 if(found) {; 2918 projectedVars.remove(*found);; 2919 ; 2920 // Take out eventual servers of plotVar; 2921 std::unique_ptr<RooArgSet> plotServers{plotVar->getObservables(&projectedVars)};; 2922 for(RooAbsArg * ps : *p",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:126905,Modifiability,variab,variables,126905," var->GetName() << std::endl;; 2887 }; 2888 ; 2889 return false ;; 2890}; 2891 ; 2892 ; 2893 ; 2894 ; 2895////////////////////////////////////////////////////////////////////////////////; 2896/// Utility function for plotOn() that constructs the set of; 2897/// observables to project when plotting ourselves as function of; 2898/// 'plotVar'. 'allVars' is the list of variables that must be; 2899/// projected, but may contain variables that we do not depend on. If; 2900/// 'silent' is cleared, warnings about inconsistent input parameters; 2901/// will be printed.; 2902 ; 2903void RooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars,; 2904 RooArgSet& projectedVars, bool silent) const; 2905{; 2906 cxcoutD(Plotting) << ""RooAbsReal::makeProjectionSet("" << GetName() << "") plotVar = "" << plotVar->GetName(); 2907 << "" allVars = "" << (allVars?(*allVars):RooArgSet()) << std::endl ;; 2908 ; 2909 projectedVars.removeAll() ;; 2910 if (!allVars) return ;; 2911 ; 2912 // Start out with suggested list of variables; 2913 projectedVars.add(*allVars) ;; 2914 ; 2915 // Take out plot variable; 2916 RooAbsArg *found= projectedVars.find(plotVar->GetName());; 2917 if(found) {; 2918 projectedVars.remove(*found);; 2919 ; 2920 // Take out eventual servers of plotVar; 2921 std::unique_ptr<RooArgSet> plotServers{plotVar->getObservables(&projectedVars)};; 2922 for(RooAbsArg * ps : *plotServers) {; 2923 RooAbsArg* tmp = projectedVars.find(ps->GetName()) ;; 2924 if (tmp) {; 2925 cxcoutD(Plotting) << ""RooAbsReal::makeProjectionSet("" << GetName() << "") removing "" << tmp->GetName(); 2926 << "" from projection set because it a server of "" << plotVar->GetName() << std::endl ;; 2927 projectedVars.remove(*tmp) ;; 2928 }; 2929 }; 2930 ; 2931 if (!silent) {; 2932 coutW(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2933 << "") WARNING: cannot project out frame variable (""; 2934 << found->GetName() << ""), ignoring"" << std::endl ;; 2935 }; 2936 }; 2937 ; 2938 // Take out all non-de",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:126981,Modifiability,variab,variable,126981,"///////////////////////////////////////////////////////////////////////////////; 2896/// Utility function for plotOn() that constructs the set of; 2897/// observables to project when plotting ourselves as function of; 2898/// 'plotVar'. 'allVars' is the list of variables that must be; 2899/// projected, but may contain variables that we do not depend on. If; 2900/// 'silent' is cleared, warnings about inconsistent input parameters; 2901/// will be printed.; 2902 ; 2903void RooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars,; 2904 RooArgSet& projectedVars, bool silent) const; 2905{; 2906 cxcoutD(Plotting) << ""RooAbsReal::makeProjectionSet("" << GetName() << "") plotVar = "" << plotVar->GetName(); 2907 << "" allVars = "" << (allVars?(*allVars):RooArgSet()) << std::endl ;; 2908 ; 2909 projectedVars.removeAll() ;; 2910 if (!allVars) return ;; 2911 ; 2912 // Start out with suggested list of variables; 2913 projectedVars.add(*allVars) ;; 2914 ; 2915 // Take out plot variable; 2916 RooAbsArg *found= projectedVars.find(plotVar->GetName());; 2917 if(found) {; 2918 projectedVars.remove(*found);; 2919 ; 2920 // Take out eventual servers of plotVar; 2921 std::unique_ptr<RooArgSet> plotServers{plotVar->getObservables(&projectedVars)};; 2922 for(RooAbsArg * ps : *plotServers) {; 2923 RooAbsArg* tmp = projectedVars.find(ps->GetName()) ;; 2924 if (tmp) {; 2925 cxcoutD(Plotting) << ""RooAbsReal::makeProjectionSet("" << GetName() << "") removing "" << tmp->GetName(); 2926 << "" from projection set because it a server of "" << plotVar->GetName() << std::endl ;; 2927 projectedVars.remove(*tmp) ;; 2928 }; 2929 }; 2930 ; 2931 if (!silent) {; 2932 coutW(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2933 << "") WARNING: cannot project out frame variable (""; 2934 << found->GetName() << ""), ignoring"" << std::endl ;; 2935 }; 2936 }; 2937 ; 2938 // Take out all non-dependents of function; 2939 for(RooAbsArg * arg : *allVars) {; 2940 if (!dependsOnValue(*arg)) {; 2941 projec",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:127753,Modifiability,variab,variable,127753,"08 ; 2909 projectedVars.removeAll() ;; 2910 if (!allVars) return ;; 2911 ; 2912 // Start out with suggested list of variables; 2913 projectedVars.add(*allVars) ;; 2914 ; 2915 // Take out plot variable; 2916 RooAbsArg *found= projectedVars.find(plotVar->GetName());; 2917 if(found) {; 2918 projectedVars.remove(*found);; 2919 ; 2920 // Take out eventual servers of plotVar; 2921 std::unique_ptr<RooArgSet> plotServers{plotVar->getObservables(&projectedVars)};; 2922 for(RooAbsArg * ps : *plotServers) {; 2923 RooAbsArg* tmp = projectedVars.find(ps->GetName()) ;; 2924 if (tmp) {; 2925 cxcoutD(Plotting) << ""RooAbsReal::makeProjectionSet("" << GetName() << "") removing "" << tmp->GetName(); 2926 << "" from projection set because it a server of "" << plotVar->GetName() << std::endl ;; 2927 projectedVars.remove(*tmp) ;; 2928 }; 2929 }; 2930 ; 2931 if (!silent) {; 2932 coutW(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2933 << "") WARNING: cannot project out frame variable (""; 2934 << found->GetName() << ""), ignoring"" << std::endl ;; 2935 }; 2936 }; 2937 ; 2938 // Take out all non-dependents of function; 2939 for(RooAbsArg * arg : *allVars) {; 2940 if (!dependsOnValue(*arg)) {; 2941 projectedVars.remove(*arg,true) ;; 2942 ; 2943 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2944 << "") function doesn't depend on projection variable ""; 2945 << arg->GetName() << "", ignoring"" << std::endl ;; 2946 }; 2947 }; 2948}; 2949 ; 2950 ; 2951 ; 2952 ; 2953////////////////////////////////////////////////////////////////////////////////; 2954/// If true, the current pdf is a selected component (for use in plotting); 2955 ; 2956bool RooAbsReal::isSelectedComp() const; 2957{; 2958 return _selectComp || _globalSelectComp ;; 2959}; 2960 ; 2961 ; 2962 ; 2963////////////////////////////////////////////////////////////////////////////////; 2964/// Global switch controlling the activation of the selectComp() functionality; 2965 ; 2966void RooAbsReal::globalSelectComp(bool flag); 2967{; 2968 _g",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:128129,Modifiability,variab,variable,128129,"erver of "" << plotVar->GetName() << std::endl ;; 2927 projectedVars.remove(*tmp) ;; 2928 }; 2929 }; 2930 ; 2931 if (!silent) {; 2932 coutW(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2933 << "") WARNING: cannot project out frame variable (""; 2934 << found->GetName() << ""), ignoring"" << std::endl ;; 2935 }; 2936 }; 2937 ; 2938 // Take out all non-dependents of function; 2939 for(RooAbsArg * arg : *allVars) {; 2940 if (!dependsOnValue(*arg)) {; 2941 projectedVars.remove(*arg,true) ;; 2942 ; 2943 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2944 << "") function doesn't depend on projection variable ""; 2945 << arg->GetName() << "", ignoring"" << std::endl ;; 2946 }; 2947 }; 2948}; 2949 ; 2950 ; 2951 ; 2952 ; 2953////////////////////////////////////////////////////////////////////////////////; 2954/// If true, the current pdf is a selected component (for use in plotting); 2955 ; 2956bool RooAbsReal::isSelectedComp() const; 2957{; 2958 return _selectComp || _globalSelectComp ;; 2959}; 2960 ; 2961 ; 2962 ; 2963////////////////////////////////////////////////////////////////////////////////; 2964/// Global switch controlling the activation of the selectComp() functionality; 2965 ; 2966void RooAbsReal::globalSelectComp(bool flag); 2967{; 2968 _globalSelectComp = flag ;; 2969}; 2970 ; 2971 ; 2972 ; 2973 ; 2974////////////////////////////////////////////////////////////////////////////////; 2975/// Create an interface adaptor f(vars) that binds us to the specified variables; 2976/// (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; 2977/// F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; 2978/// current values of x2 and x4. The caller takes ownership of the returned adaptor.; 2979 ; 2980RooFit::OwningPtr<RooAbsFunc> RooAbsReal::bindVars(const RooArgSet &vars, const RooArgSet* nset, bool clipInvalid) const; 2981{; 2982 auto binding = std::make_unique<RooRealBinding>(*this,vars,nset,clipInvalid);; 2983 if(!binding->isVal",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:128964,Modifiability,adapt,adaptor,128964,"erver of "" << plotVar->GetName() << std::endl ;; 2927 projectedVars.remove(*tmp) ;; 2928 }; 2929 }; 2930 ; 2931 if (!silent) {; 2932 coutW(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2933 << "") WARNING: cannot project out frame variable (""; 2934 << found->GetName() << ""), ignoring"" << std::endl ;; 2935 }; 2936 }; 2937 ; 2938 // Take out all non-dependents of function; 2939 for(RooAbsArg * arg : *allVars) {; 2940 if (!dependsOnValue(*arg)) {; 2941 projectedVars.remove(*arg,true) ;; 2942 ; 2943 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2944 << "") function doesn't depend on projection variable ""; 2945 << arg->GetName() << "", ignoring"" << std::endl ;; 2946 }; 2947 }; 2948}; 2949 ; 2950 ; 2951 ; 2952 ; 2953////////////////////////////////////////////////////////////////////////////////; 2954/// If true, the current pdf is a selected component (for use in plotting); 2955 ; 2956bool RooAbsReal::isSelectedComp() const; 2957{; 2958 return _selectComp || _globalSelectComp ;; 2959}; 2960 ; 2961 ; 2962 ; 2963////////////////////////////////////////////////////////////////////////////////; 2964/// Global switch controlling the activation of the selectComp() functionality; 2965 ; 2966void RooAbsReal::globalSelectComp(bool flag); 2967{; 2968 _globalSelectComp = flag ;; 2969}; 2970 ; 2971 ; 2972 ; 2973 ; 2974////////////////////////////////////////////////////////////////////////////////; 2975/// Create an interface adaptor f(vars) that binds us to the specified variables; 2976/// (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; 2977/// F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; 2978/// current values of x2 and x4. The caller takes ownership of the returned adaptor.; 2979 ; 2980RooFit::OwningPtr<RooAbsFunc> RooAbsReal::bindVars(const RooArgSet &vars, const RooArgSet* nset, bool clipInvalid) const; 2981{; 2982 auto binding = std::make_unique<RooRealBinding>(*this,vars,nset,clipInvalid);; 2983 if(!binding->isVal",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:129011,Modifiability,variab,variables,129011,"erver of "" << plotVar->GetName() << std::endl ;; 2927 projectedVars.remove(*tmp) ;; 2928 }; 2929 }; 2930 ; 2931 if (!silent) {; 2932 coutW(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2933 << "") WARNING: cannot project out frame variable (""; 2934 << found->GetName() << ""), ignoring"" << std::endl ;; 2935 }; 2936 }; 2937 ; 2938 // Take out all non-dependents of function; 2939 for(RooAbsArg * arg : *allVars) {; 2940 if (!dependsOnValue(*arg)) {; 2941 projectedVars.remove(*arg,true) ;; 2942 ; 2943 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2944 << "") function doesn't depend on projection variable ""; 2945 << arg->GetName() << "", ignoring"" << std::endl ;; 2946 }; 2947 }; 2948}; 2949 ; 2950 ; 2951 ; 2952 ; 2953////////////////////////////////////////////////////////////////////////////////; 2954/// If true, the current pdf is a selected component (for use in plotting); 2955 ; 2956bool RooAbsReal::isSelectedComp() const; 2957{; 2958 return _selectComp || _globalSelectComp ;; 2959}; 2960 ; 2961 ; 2962 ; 2963////////////////////////////////////////////////////////////////////////////////; 2964/// Global switch controlling the activation of the selectComp() functionality; 2965 ; 2966void RooAbsReal::globalSelectComp(bool flag); 2967{; 2968 _globalSelectComp = flag ;; 2969}; 2970 ; 2971 ; 2972 ; 2973 ; 2974////////////////////////////////////////////////////////////////////////////////; 2975/// Create an interface adaptor f(vars) that binds us to the specified variables; 2976/// (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; 2977/// F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; 2978/// current values of x2 and x4. The caller takes ownership of the returned adaptor.; 2979 ; 2980RooFit::OwningPtr<RooAbsFunc> RooAbsReal::bindVars(const RooArgSet &vars, const RooArgSet* nset, bool clipInvalid) const; 2981{; 2982 auto binding = std::make_unique<RooRealBinding>(*this,vars,nset,clipInvalid);; 2983 if(!binding->isVal",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:129264,Modifiability,adapt,adaptor,129264," 2953////////////////////////////////////////////////////////////////////////////////; 2954/// If true, the current pdf is a selected component (for use in plotting); 2955 ; 2956bool RooAbsReal::isSelectedComp() const; 2957{; 2958 return _selectComp || _globalSelectComp ;; 2959}; 2960 ; 2961 ; 2962 ; 2963////////////////////////////////////////////////////////////////////////////////; 2964/// Global switch controlling the activation of the selectComp() functionality; 2965 ; 2966void RooAbsReal::globalSelectComp(bool flag); 2967{; 2968 _globalSelectComp = flag ;; 2969}; 2970 ; 2971 ; 2972 ; 2973 ; 2974////////////////////////////////////////////////////////////////////////////////; 2975/// Create an interface adaptor f(vars) that binds us to the specified variables; 2976/// (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; 2977/// F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; 2978/// current values of x2 and x4. The caller takes ownership of the returned adaptor.; 2979 ; 2980RooFit::OwningPtr<RooAbsFunc> RooAbsReal::bindVars(const RooArgSet &vars, const RooArgSet* nset, bool clipInvalid) const; 2981{; 2982 auto binding = std::make_unique<RooRealBinding>(*this,vars,nset,clipInvalid);; 2983 if(!binding->isValid()) {; 2984 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":bindVars: cannot bind to "" << vars << std::endl ;; 2985 return nullptr;; 2986 }; 2987 return RooFit::makeOwningPtr(std::unique_ptr<RooAbsFunc>{std::move(binding)});; 2988}; 2989 ; 2990 ; 2991 ; 2992////////////////////////////////////////////////////////////////////////////////; 2993/// Copy the cached value of another RooAbsArg to our cache.; 2994/// Warning: This function just copies the cached values of source,; 2995/// it is the callers responsibility to make sure the cache is clean.; 2996 ; 2997void RooAbsReal::copyCache(const RooAbsArg* source, bool /*valueOnly*/, bool setValDirty); 2998{; 2999 auto other = static_cast<const RooAbsRea",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:141204,Modifiability,config,configuration,141204," and do not change matchedArgs.; 3240 ; 3241bool RooAbsReal::matchArgsByName(const RooArgSet &allArgs, RooArgSet &matchedArgs,; 3242 const TList &nameList) const; 3243{; 3244 RooArgSet matched(""matched"");; 3245 bool isMatched(true);; 3246 for(auto * name : static_range_cast<TObjString*>(nameList)) {; 3247 RooAbsArg *found= allArgs.find(name->String().Data());; 3248 if(found) {; 3249 matched.add(*found);; 3250 }; 3251 else {; 3252 isMatched= false;; 3253 break;; 3254 }; 3255 }; 3256 ; 3257 // nameList may not contain multiple entries with the same name; 3258 // that are both matched; 3259 if (isMatched && int(matched.size())!=nameList.GetSize()) {; 3260 isMatched = false ;; 3261 }; 3262 ; 3263 if(isMatched) matchedArgs.add(matched);; 3264 return isMatched;; 3265}; 3266 ; 3267 ; 3268 ; 3269////////////////////////////////////////////////////////////////////////////////; 3270/// Returns the default numeric integration configuration for all RooAbsReals; 3271 ; 3272RooNumIntConfig* RooAbsReal::defaultIntegratorConfig(); 3273{; 3274 return &RooNumIntConfig::defaultConfig() ;; 3275}; 3276 ; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3280/// If this object has no specialized configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:141512,Modifiability,config,configuration,141512," and do not change matchedArgs.; 3240 ; 3241bool RooAbsReal::matchArgsByName(const RooArgSet &allArgs, RooArgSet &matchedArgs,; 3242 const TList &nameList) const; 3243{; 3244 RooArgSet matched(""matched"");; 3245 bool isMatched(true);; 3246 for(auto * name : static_range_cast<TObjString*>(nameList)) {; 3247 RooAbsArg *found= allArgs.find(name->String().Data());; 3248 if(found) {; 3249 matched.add(*found);; 3250 }; 3251 else {; 3252 isMatched= false;; 3253 break;; 3254 }; 3255 }; 3256 ; 3257 // nameList may not contain multiple entries with the same name; 3258 // that are both matched; 3259 if (isMatched && int(matched.size())!=nameList.GetSize()) {; 3260 isMatched = false ;; 3261 }; 3262 ; 3263 if(isMatched) matchedArgs.add(matched);; 3264 return isMatched;; 3265}; 3266 ; 3267 ; 3268 ; 3269////////////////////////////////////////////////////////////////////////////////; 3270/// Returns the default numeric integration configuration for all RooAbsReals; 3271 ; 3272RooNumIntConfig* RooAbsReal::defaultIntegratorConfig(); 3273{; 3274 return &RooNumIntConfig::defaultConfig() ;; 3275}; 3276 ; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3280/// If this object has no specialized configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:141592,Modifiability,config,configuration,141592," *found= allArgs.find(name->String().Data());; 3248 if(found) {; 3249 matched.add(*found);; 3250 }; 3251 else {; 3252 isMatched= false;; 3253 break;; 3254 }; 3255 }; 3256 ; 3257 // nameList may not contain multiple entries with the same name; 3258 // that are both matched; 3259 if (isMatched && int(matched.size())!=nameList.GetSize()) {; 3260 isMatched = false ;; 3261 }; 3262 ; 3263 if(isMatched) matchedArgs.add(matched);; 3264 return isMatched;; 3265}; 3266 ; 3267 ; 3268 ; 3269////////////////////////////////////////////////////////////////////////////////; 3270/// Returns the default numeric integration configuration for all RooAbsReals; 3271 ; 3272RooNumIntConfig* RooAbsReal::defaultIntegratorConfig(); 3273{; 3274 return &RooNumIntConfig::defaultConfig() ;; 3275}; 3276 ; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3280/// If this object has no specialized configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304/////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:141908,Modifiability,config,configuration,141908,"are both matched; 3259 if (isMatched && int(matched.size())!=nameList.GetSize()) {; 3260 isMatched = false ;; 3261 }; 3262 ; 3263 if(isMatched) matchedArgs.add(matched);; 3264 return isMatched;; 3265}; 3266 ; 3267 ; 3268 ; 3269////////////////////////////////////////////////////////////////////////////////; 3270/// Returns the default numeric integration configuration for all RooAbsReals; 3271 ; 3272RooNumIntConfig* RooAbsReal::defaultIntegratorConfig(); 3273{; 3274 return &RooNumIntConfig::defaultConfig() ;; 3275}; 3276 ; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3280/// If this object has no specialized configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all Ro",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:141988,Modifiability,config,configuration,141988," for all RooAbsReals; 3271 ; 3272RooNumIntConfig* RooAbsReal::defaultIntegratorConfig(); 3273{; 3274 return &RooNumIntConfig::defaultConfig() ;; 3275}; 3276 ; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3280/// If this object has no specialized configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return th",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:142127,Modifiability,config,configuration,142127," for all RooAbsReals; 3271 ; 3272RooNumIntConfig* RooAbsReal::defaultIntegratorConfig(); 3273{; 3274 return &RooNumIntConfig::defaultConfig() ;; 3275}; 3276 ; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3280/// If this object has no specialized configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return th",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:142178,Modifiability,config,configuration,142178," for all RooAbsReals; 3271 ; 3272RooNumIntConfig* RooAbsReal::defaultIntegratorConfig(); 3273{; 3274 return &RooNumIntConfig::defaultConfig() ;; 3275}; 3276 ; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3280/// If this object has no specialized configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return th",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:142651,Modifiability,config,configuration,142651,"zed configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:142713,Modifiability,config,configuration,142713,"ialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:142765,Modifiability,config,configuration,142765,"ialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:142823,Modifiability,config,configuration,142823,"ialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:142980,Modifiability,config,config,142980,"ialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:143027,Modifiability,config,config,143027,"ialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:143042,Modifiability,config,config,143042,"ialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:143239,Modifiability,config,configuration,143239,"ialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:143301,Modifiability,config,configuration,143301,"default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{; 3337 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(config);; 3338}; 3339 ; 3340 ; 3341 ; 3342////////////////////////////////////////////////////////////////////////////////; 3343/// Remove the specialized numeric integration configuration associated; 3344/// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:143353,Modifiability,config,configuration,143353,"default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{; 3337 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(config);; 3338}; 3339 ; 3340 ; 3341 ; 3342////////////////////////////////////////////////////////////////////////////////; 3343/// Remove the specialized numeric integration configuration associated; 3344/// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:143411,Modifiability,config,configuration,143411,"default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{; 3337 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(config);; 3338}; 3339 ; 3340 ; 3341 ; 3342////////////////////////////////////////////////////////////////////////////////; 3343/// Remove the specialized numeric integration configuration associated; 3344/// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:143550,Modifiability,config,config,143550,"default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{; 3337 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(config);; 3338}; 3339 ; 3340 ; 3341 ; 3342////////////////////////////////////////////////////////////////////////////////; 3343/// Remove the specialized numeric integration configuration associated; 3344/// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:143597,Modifiability,config,config,143597,"default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{; 3337 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(config);; 3338}; 3339 ; 3340 ; 3341 ; 3342////////////////////////////////////////////////////////////////////////////////; 3343/// Remove the specialized numeric integration configuration associated; 3344/// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:143612,Modifiability,config,config,143612,"default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{; 3337 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(config);; 3338}; 3339 ; 3340 ; 3341 ; 3342////////////////////////////////////////////////////////////////////////////////; 3343/// Remove the specialized numeric integration configuration associated; 3344/// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:143810,Modifiability,config,configuration,143810,"default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{; 3337 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(config);; 3338}; 3339 ; 3340 ; 3341 ; 3342////////////////////////////////////////////////////////////////////////////////; 3343/// Remove the specialized numeric integration configuration associated; 3344/// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:143864,Modifiability,config,configuration,143864,"default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{; 3337 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(config);; 3338}; 3339 ; 3340 ; 3341 ; 3342////////////////////////////////////////////////////////////////////////////////; 3343/// Remove the specialized numeric integration configuration associated; 3344/// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:143966,Modifiability,config,config,143966,"default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{; 3337 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(config);; 3338}; 3339 ; 3340 ; 3341 ; 3342////////////////////////////////////////////////////////////////////////////////; 3343/// Remove the specialized numeric integration configuration associated; 3344/// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:144045,Modifiability,config,config,144045,"default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{; 3337 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(config);; 3338}; 3339 ; 3340 ; 3341 ; 3342////////////////////////////////////////////////////////////////////////////////; 3343/// Remove the specialized numeric integration configuration associated; 3344/// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:144220,Modifiability,config,configuration,144220,"default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; 3325 if (config) return config ;; 3326 return defaultIntegratorConfig() ;; 3327}; 3328 ; 3329 ; 3330 ; 3331////////////////////////////////////////////////////////////////////////////////; 3332/// Set the given integrator configuration as default numeric integration; 3333/// configuration for this object; 3334 ; 3335void RooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); 3336{; 3337 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(config);; 3338}; 3339 ; 3340 ; 3341 ; 3342////////////////////////////////////////////////////////////////////////////////; 3343/// Remove the specialized numeric integration configuration associated; 3344/// with this object; 3345 ; 3346void RooAbsReal::setIntegratorConfig(); 3347{; 3348 _specIntegratorConfig.reset();; 3349}; 3350 ; 3351 ; 3352 ; 3353 ; 3354////////////////////////////////////////////////////////////////////////////////; 3355/// Interface function to force use of a given set of observables; 3356/// to interpret function value. Needed for functions or p.d.f.s; 3357/// whose shape depends on the choice of normalization such as; 3358/// RooAddPdf; 3359 ; 3360void RooAbsReal::selectNormalization(const RooArgSet*, bool); 3361{; 3362}; 3363 ; 3364 ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:158840,Modifiability,variab,variables,158840,"; 3703////////////////////////////////////////////////////////////////////////////////; 3704/// Calls createRunningIntegral(const RooArgSet&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&); 3705 ; 3706RooFit::OwningPtr<RooAbsReal> RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset); 3707{; 3708 return createRunningIntegral(iset,RooFit::SupNormSet(nset)) ;; 3709}; 3710 ; 3711 ; 3712 ; 3713////////////////////////////////////////////////////////////////////////////////; 3714/// Create an object that represents the running integral of the function over one or more observables listed in iset, i.e.; 3715/// \f[; 3716/// \int_{x_\mathrm{lo}}^x f(x') \, \mathrm{d}x'; 3717/// \f]; 3718///; 3719/// The actual integration calculation is only performed when the return object is evaluated. The name; 3720/// of the integral object is automatically constructed from the name of the input function, the variables; 3721/// it integrates and the range integrates over. The default strategy to calculate the running integrals is; 3722///; 3723/// - If the integrand (this object) supports analytical integration, construct an integral object; 3724/// that calculate the running integrals value by calculating the analytical integral each; 3725/// time the running integral object is evaluated; 3726///; 3727/// - If the integrand (this object) requires numeric integration to construct the running integral; 3728/// create an object of class RooNumRunningInt which first samples the entire function and integrates; 3729/// the sampled function numerically. This method has superior performance as there is no need to; 3730/// perform a full (numeric) integration for each evaluation of the running integral object, but; 3731/// only when one of its parameters has changed.; 3732///; 3733/// The choice of strategy can be changed with the ScanAll() argument, which forces the use of ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:161340,Modifiability,config,configuration,161340," ScanNone(); 3735/// argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; 3736/// granularity for the scanning technique can be controlled with the ScanParameters technique; 3737/// which allows to specify the number of samples to be taken, and to which order the resulting; 3738/// running integral should be interpolated. The default values are 1000 samples and 2nd order; 3739/// interpolation.; 3740///; 3741/// The following named arguments are accepted; 3742/// | | Effect on integral creation; 3743/// |-|-------------------------------; 3744/// | `SupNormSet(const RooArgSet&)` | Observables over which should be normalized _in addition_ to the integration observables; 3745/// | `ScanParameters(Int_t nbins, Int_t intOrder)` | Parameters for scanning technique of making CDF: number of sampled bins and order of interpolation applied on numeric cdf; 3746/// | `ScanNum()` | Apply scanning technique if cdf integral involves numeric integration; 3747/// | `ScanAll()` | Always apply scanning technique; 3748/// | `ScanNone()` | Never apply scanning technique; 3749 ; 3750RooFit::OwningPtr<RooAbsReal> RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2,; 3751 const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5,; 3752 const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 3753{; 3754 // Define configuration for this method; 3755 RooCmdConfig pc(""RooAbsReal::createRunningIntegral("" + std::string(GetName()) + "")"");; 3756 pc.defineSet(""supNormSet"",""SupNormSet"",0,nullptr) ;; 3757 pc.defineInt(""numScanBins"",""ScanParameters"",0,1000) ;; 3758 pc.defineInt(""intOrder"",""ScanParameters"",1,2) ;; 3759 pc.defineInt(""doScanNum"",""ScanNum"",0,1) ;; 3760 pc.defineInt(""doScanAll"",""ScanAll"",0,0) ;; 3761 pc.defineInt(""doScanNon"",""ScanNone"",0,0) ;; 3762 pc.defineMutex(""ScanNum"",""ScanAll"",""ScanNone"") ;; 3763 ; 3764 // Process & check varargs; 3765 pc.process(arg1,arg2,arg3,arg4,a",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:166224,Modifiability,parameteriz,parameterized,166224,"43 // Setup customizer that stores all cloned branches in our non-owning list; 3844 RooCustomizer cust(*this,""cdf"") ;; 3845 cust.setCloneBranchSet(clonedBranchNodes) ;; 3846 cust.setOwning(false) ;; 3847 ; 3848 // Make integration observable x_prime for each observable x as well as an x_lowbound; 3849 for(auto * rrv : static_range_cast<RooRealVar*>(ilist)) {; 3850 ; 3851 // Make clone x_prime of each c.d.f observable x represening running integral; 3852 RooRealVar* cloneArg = static_cast<RooRealVar*>(rrv->clone(Form(""%s_prime"",rrv->GetName()))) ;; 3853 cloneList.add(*cloneArg) ;; 3854 cust.replaceArg(*rrv,*cloneArg) ;; 3855 ; 3856 // Make clone x_lowbound of each c.d.f observable representing low bound of x; 3857 RooRealVar* cloneLo = static_cast<RooRealVar*>(rrv->clone(Form(""%s_lowbound"",rrv->GetName()))) ;; 3858 cloneLo->setVal(rrv->getMin()) ;; 3859 loList.add(*cloneLo) ;; 3860 ; 3861 // Make parameterized binning from [x_lowbound,x] for each x_prime; 3862 RooParamBinning pb(*cloneLo,*rrv,100) ;; 3863 cloneArg->setBinning(pb,""CDF"") ;; 3864 ; 3865 }; 3866 ; 3867 RooAbsReal* tmp = static_cast<RooAbsReal*>(cust.build()) ;; 3868 ; 3869 // Construct final normalization set for c.d.f = integrated observables + any extra specified by user; 3870 RooArgSet finalNset(nset) ;; 3871 finalNset.add(cloneList,true) ;; 3872 std::unique_ptr<RooAbsReal> cdf{tmp->createIntegral(cloneList,finalNset,""CDF"")};; 3873 ; 3874 // Transfer ownership of cloned items to top-level c.d.f object; 3875 cdf->addOwnedComponents(*tmp) ;; 3876 cdf->addOwnedComponents(cloneList) ;; 3877 cdf->addOwnedComponents(loList) ;; 3878 ; 3879 return RooFit::makeOwningPtr(std::move(cdf));; 3880}; 3881 ; 3882 ; 3883////////////////////////////////////////////////////////////////////////////////; 3884/// Return a RooFunctor object bound to this RooAbsReal with given definition of observables; 3885/// and parameters; 3886 ; 3887RooFunctor* RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars, const RooA",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:167568,Modifiability,variab,variables,167568,".f = integrated observables + any extra specified by user; 3870 RooArgSet finalNset(nset) ;; 3871 finalNset.add(cloneList,true) ;; 3872 std::unique_ptr<RooAbsReal> cdf{tmp->createIntegral(cloneList,finalNset,""CDF"")};; 3873 ; 3874 // Transfer ownership of cloned items to top-level c.d.f object; 3875 cdf->addOwnedComponents(*tmp) ;; 3876 cdf->addOwnedComponents(cloneList) ;; 3877 cdf->addOwnedComponents(loList) ;; 3878 ; 3879 return RooFit::makeOwningPtr(std::move(cdf));; 3880}; 3881 ; 3882 ; 3883////////////////////////////////////////////////////////////////////////////////; 3884/// Return a RooFunctor object bound to this RooAbsReal with given definition of observables; 3885/// and parameters; 3886 ; 3887RooFunctor* RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars, const RooArgSet& nset) const; 3888{; 3889 RooArgSet realObs;; 3890 getObservables(&obs, realObs);; 3891 if (realObs.size() != obs.size()) {; 3892 coutE(InputArguments) << ""RooAbsReal::functor("" << GetName() << "") ERROR: one or more specified observables are not variables of this p.d.f"" << std::endl ;; 3893 return nullptr;; 3894 }; 3895 RooArgSet realPars;; 3896 getObservables(&pars, realPars);; 3897 if (realPars.size() != pars.size()) {; 3898 coutE(InputArguments) << ""RooAbsReal::functor("" << GetName() << "") ERROR: one or more specified parameters are not variables of this p.d.f"" << std::endl ;; 3899 return nullptr;; 3900 }; 3901 ; 3902 return new RooFunctor(*this,obs,pars,nset) ;; 3903}; 3904 ; 3905 ; 3906 ; 3907////////////////////////////////////////////////////////////////////////////////; 3908/// Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables; 3909/// and parameters; 3910 ; 3911TF1* RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars, const RooArgSet& nset) const; 3912{; 3913 // Check that specified input are indeed variables of this function; 3914 RooArgSet realObs;; 3915 getObservables(&obs, realObs) ;; 3916 if (realObs.size()",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:167868,Modifiability,variab,variables,167868,"cdf->addOwnedComponents(*tmp) ;; 3876 cdf->addOwnedComponents(cloneList) ;; 3877 cdf->addOwnedComponents(loList) ;; 3878 ; 3879 return RooFit::makeOwningPtr(std::move(cdf));; 3880}; 3881 ; 3882 ; 3883////////////////////////////////////////////////////////////////////////////////; 3884/// Return a RooFunctor object bound to this RooAbsReal with given definition of observables; 3885/// and parameters; 3886 ; 3887RooFunctor* RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars, const RooArgSet& nset) const; 3888{; 3889 RooArgSet realObs;; 3890 getObservables(&obs, realObs);; 3891 if (realObs.size() != obs.size()) {; 3892 coutE(InputArguments) << ""RooAbsReal::functor("" << GetName() << "") ERROR: one or more specified observables are not variables of this p.d.f"" << std::endl ;; 3893 return nullptr;; 3894 }; 3895 RooArgSet realPars;; 3896 getObservables(&pars, realPars);; 3897 if (realPars.size() != pars.size()) {; 3898 coutE(InputArguments) << ""RooAbsReal::functor("" << GetName() << "") ERROR: one or more specified parameters are not variables of this p.d.f"" << std::endl ;; 3899 return nullptr;; 3900 }; 3901 ; 3902 return new RooFunctor(*this,obs,pars,nset) ;; 3903}; 3904 ; 3905 ; 3906 ; 3907////////////////////////////////////////////////////////////////////////////////; 3908/// Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables; 3909/// and parameters; 3910 ; 3911TF1* RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars, const RooArgSet& nset) const; 3912{; 3913 // Check that specified input are indeed variables of this function; 3914 RooArgSet realObs;; 3915 getObservables(&obs, realObs) ;; 3916 if (realObs.size() != obs.size()) {; 3917 coutE(InputArguments) << ""RooAbsReal::functor("" << GetName() << "") ERROR: one or more specified observables are not variables of this p.d.f"" << std::endl ;; 3918 return nullptr ;; 3919 }; 3920 RooArgSet realPars;; 3921 getObservables(&pars, realPars) ;; 3922 if (realPars.size(",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:168398,Modifiability,variab,variables,168398,"/ and parameters; 3886 ; 3887RooFunctor* RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars, const RooArgSet& nset) const; 3888{; 3889 RooArgSet realObs;; 3890 getObservables(&obs, realObs);; 3891 if (realObs.size() != obs.size()) {; 3892 coutE(InputArguments) << ""RooAbsReal::functor("" << GetName() << "") ERROR: one or more specified observables are not variables of this p.d.f"" << std::endl ;; 3893 return nullptr;; 3894 }; 3895 RooArgSet realPars;; 3896 getObservables(&pars, realPars);; 3897 if (realPars.size() != pars.size()) {; 3898 coutE(InputArguments) << ""RooAbsReal::functor("" << GetName() << "") ERROR: one or more specified parameters are not variables of this p.d.f"" << std::endl ;; 3899 return nullptr;; 3900 }; 3901 ; 3902 return new RooFunctor(*this,obs,pars,nset) ;; 3903}; 3904 ; 3905 ; 3906 ; 3907////////////////////////////////////////////////////////////////////////////////; 3908/// Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables; 3909/// and parameters; 3910 ; 3911TF1* RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars, const RooArgSet& nset) const; 3912{; 3913 // Check that specified input are indeed variables of this function; 3914 RooArgSet realObs;; 3915 getObservables(&obs, realObs) ;; 3916 if (realObs.size() != obs.size()) {; 3917 coutE(InputArguments) << ""RooAbsReal::functor("" << GetName() << "") ERROR: one or more specified observables are not variables of this p.d.f"" << std::endl ;; 3918 return nullptr ;; 3919 }; 3920 RooArgSet realPars;; 3921 getObservables(&pars, realPars) ;; 3922 if (realPars.size() != pars.size()) {; 3923 coutE(InputArguments) << ""RooAbsReal::functor("" << GetName() << "") ERROR: one or more specified parameters are not variables of this p.d.f"" << std::endl ;; 3924 return nullptr ;; 3925 }; 3926 ; 3927 // Check that all obs and par are of type RooRealVar; 3928 for (std::size_t i=0 ; i<obs.size() ; i++) {; 3929 if (dynamic_cast<RooRealVar*>(obs.at(i))==nullptr)",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:168652,Modifiability,variab,variables,168652,"std::endl ;; 3893 return nullptr;; 3894 }; 3895 RooArgSet realPars;; 3896 getObservables(&pars, realPars);; 3897 if (realPars.size() != pars.size()) {; 3898 coutE(InputArguments) << ""RooAbsReal::functor("" << GetName() << "") ERROR: one or more specified parameters are not variables of this p.d.f"" << std::endl ;; 3899 return nullptr;; 3900 }; 3901 ; 3902 return new RooFunctor(*this,obs,pars,nset) ;; 3903}; 3904 ; 3905 ; 3906 ; 3907////////////////////////////////////////////////////////////////////////////////; 3908/// Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables; 3909/// and parameters; 3910 ; 3911TF1* RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars, const RooArgSet& nset) const; 3912{; 3913 // Check that specified input are indeed variables of this function; 3914 RooArgSet realObs;; 3915 getObservables(&obs, realObs) ;; 3916 if (realObs.size() != obs.size()) {; 3917 coutE(InputArguments) << ""RooAbsReal::functor("" << GetName() << "") ERROR: one or more specified observables are not variables of this p.d.f"" << std::endl ;; 3918 return nullptr ;; 3919 }; 3920 RooArgSet realPars;; 3921 getObservables(&pars, realPars) ;; 3922 if (realPars.size() != pars.size()) {; 3923 coutE(InputArguments) << ""RooAbsReal::functor("" << GetName() << "") ERROR: one or more specified parameters are not variables of this p.d.f"" << std::endl ;; 3924 return nullptr ;; 3925 }; 3926 ; 3927 // Check that all obs and par are of type RooRealVar; 3928 for (std::size_t i=0 ; i<obs.size() ; i++) {; 3929 if (dynamic_cast<RooRealVar*>(obs.at(i))==nullptr) {; 3930 coutE(ObjectHandling) << ""RooAbsReal::asTF("" << GetName() << "") ERROR: proposed observable "" << obs.at(0)->GetName() << "" is not of type RooRealVar"" << std::endl ;; 3931 return nullptr ;; 3932 }; 3933 }; 3934 for (std::size_t i=0 ; i<pars.size() ; i++) {; 3935 if (dynamic_cast<RooRealVar*>(pars.at(i))==nullptr) {; 3936 coutE(ObjectHandling) << ""RooAbsReal::asTF("" << GetName() << "") ERRO",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:168954,Modifiability,variab,variables,168954,"d::endl ;; 3899 return nullptr;; 3900 }; 3901 ; 3902 return new RooFunctor(*this,obs,pars,nset) ;; 3903}; 3904 ; 3905 ; 3906 ; 3907////////////////////////////////////////////////////////////////////////////////; 3908/// Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables; 3909/// and parameters; 3910 ; 3911TF1* RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars, const RooArgSet& nset) const; 3912{; 3913 // Check that specified input are indeed variables of this function; 3914 RooArgSet realObs;; 3915 getObservables(&obs, realObs) ;; 3916 if (realObs.size() != obs.size()) {; 3917 coutE(InputArguments) << ""RooAbsReal::functor("" << GetName() << "") ERROR: one or more specified observables are not variables of this p.d.f"" << std::endl ;; 3918 return nullptr ;; 3919 }; 3920 RooArgSet realPars;; 3921 getObservables(&pars, realPars) ;; 3922 if (realPars.size() != pars.size()) {; 3923 coutE(InputArguments) << ""RooAbsReal::functor("" << GetName() << "") ERROR: one or more specified parameters are not variables of this p.d.f"" << std::endl ;; 3924 return nullptr ;; 3925 }; 3926 ; 3927 // Check that all obs and par are of type RooRealVar; 3928 for (std::size_t i=0 ; i<obs.size() ; i++) {; 3929 if (dynamic_cast<RooRealVar*>(obs.at(i))==nullptr) {; 3930 coutE(ObjectHandling) << ""RooAbsReal::asTF("" << GetName() << "") ERROR: proposed observable "" << obs.at(0)->GetName() << "" is not of type RooRealVar"" << std::endl ;; 3931 return nullptr ;; 3932 }; 3933 }; 3934 for (std::size_t i=0 ; i<pars.size() ; i++) {; 3935 if (dynamic_cast<RooRealVar*>(pars.at(i))==nullptr) {; 3936 coutE(ObjectHandling) << ""RooAbsReal::asTF("" << GetName() << "") ERROR: proposed parameter "" << pars.at(0)->GetName() << "" is not of type RooRealVar"" << std::endl ;; 3937 return nullptr ;; 3938 }; 3939 }; 3940 ; 3941 // Create functor and TFx of matching dimension; 3942 TF1* tf=nullptr ;; 3943 RooFunctor* f ;; 3944 switch(obs.size()) {; 3945 case 1: {; 3946 RooRealVar* ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:176141,Modifiability,extend,extended,176141,"quals yval.; 4049/// (Calculation is performed with Brent root finding algorithm); 4050 ; 4051double RooAbsReal::findRoot(RooRealVar& x, double xmin, double xmax, double yval); 4052{; 4053 double result(0) ;; 4054 RooBrentRootFinder(RooRealBinding(*this,x)).findRoot(result,xmin,xmax,yval) ;; 4055 return result ;; 4056}; 4057 ; 4058 ; 4059 ; 4060////////////////////////////////////////////////////////////////////////////////; 4061/// Perform a \f$ \chi^2 \f$ fit to given histogram. By default the fit is executed through the MINUIT; 4062/// commands MIGRAD, HESSE in succession; 4063///; 4064/// The following named arguments are supported; 4065///; 4066/// <table>; 4067/// <tr><th> <th> Options to control construction of chi2; 4068/// <tr><td> `Extended(bool flag)` <td> **Only applicable when fitting a RooAbsPdf**. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight.; 4069/// This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; 4070/// - If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events; 4071/// (in RooFit jargon, ""if the pdf can be extended"").; 4072/// - Passing `Extended(true)` when the the pdf makes no prediction on the expected number of events will result in error messages,; 4073/// and the chi2 will fall back to the total data weight to scale the normalized pdf.; 4074/// - There are cases where the fit **must** be done in extended mode. This happens for example when you have a RooAddPdf; 4075/// where the coefficients represent component yields. If the fit is not extended, these coefficients will not be; 4076/// well-defined, as the RooAddPdf always normalizes itself. If you pass `Extended(false)` in such a case, an error will be; 4077/// printed and you'll most likely get garbage results.; 4078/// <tr><td> `Range(const char* name)` <td> Fit only data inside range wit",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:176222,Modifiability,extend,extended,176222,"ax, double yval); 4052{; 4053 double result(0) ;; 4054 RooBrentRootFinder(RooRealBinding(*this,x)).findRoot(result,xmin,xmax,yval) ;; 4055 return result ;; 4056}; 4057 ; 4058 ; 4059 ; 4060////////////////////////////////////////////////////////////////////////////////; 4061/// Perform a \f$ \chi^2 \f$ fit to given histogram. By default the fit is executed through the MINUIT; 4062/// commands MIGRAD, HESSE in succession; 4063///; 4064/// The following named arguments are supported; 4065///; 4066/// <table>; 4067/// <tr><th> <th> Options to control construction of chi2; 4068/// <tr><td> `Extended(bool flag)` <td> **Only applicable when fitting a RooAbsPdf**. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight.; 4069/// This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; 4070/// - If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events; 4071/// (in RooFit jargon, ""if the pdf can be extended"").; 4072/// - Passing `Extended(true)` when the the pdf makes no prediction on the expected number of events will result in error messages,; 4073/// and the chi2 will fall back to the total data weight to scale the normalized pdf.; 4074/// - There are cases where the fit **must** be done in extended mode. This happens for example when you have a RooAddPdf; 4075/// where the coefficients represent component yields. If the fit is not extended, these coefficients will not be; 4076/// well-defined, as the RooAddPdf always normalizes itself. If you pass `Extended(false)` in such a case, an error will be; 4077/// printed and you'll most likely get garbage results.; 4078/// <tr><td> `Range(const char* name)` <td> Fit only data inside range with given name; 4079/// <tr><td> `Range(double lo, double hi)` <td> Fit only data inside given range. A range named ""fit"" is created on the fly on all observabl",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:176360,Modifiability,extend,extended,176360,"ax, double yval); 4052{; 4053 double result(0) ;; 4054 RooBrentRootFinder(RooRealBinding(*this,x)).findRoot(result,xmin,xmax,yval) ;; 4055 return result ;; 4056}; 4057 ; 4058 ; 4059 ; 4060////////////////////////////////////////////////////////////////////////////////; 4061/// Perform a \f$ \chi^2 \f$ fit to given histogram. By default the fit is executed through the MINUIT; 4062/// commands MIGRAD, HESSE in succession; 4063///; 4064/// The following named arguments are supported; 4065///; 4066/// <table>; 4067/// <tr><th> <th> Options to control construction of chi2; 4068/// <tr><td> `Extended(bool flag)` <td> **Only applicable when fitting a RooAbsPdf**. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight.; 4069/// This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; 4070/// - If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events; 4071/// (in RooFit jargon, ""if the pdf can be extended"").; 4072/// - Passing `Extended(true)` when the the pdf makes no prediction on the expected number of events will result in error messages,; 4073/// and the chi2 will fall back to the total data weight to scale the normalized pdf.; 4074/// - There are cases where the fit **must** be done in extended mode. This happens for example when you have a RooAddPdf; 4075/// where the coefficients represent component yields. If the fit is not extended, these coefficients will not be; 4076/// well-defined, as the RooAddPdf always normalizes itself. If you pass `Extended(false)` in such a case, an error will be; 4077/// printed and you'll most likely get garbage results.; 4078/// <tr><td> `Range(const char* name)` <td> Fit only data inside range with given name; 4079/// <tr><td> `Range(double lo, double hi)` <td> Fit only data inside given range. A range named ""fit"" is created on the fly on all observabl",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:176661,Modifiability,extend,extended,176661,"h the MINUIT; 4062/// commands MIGRAD, HESSE in succession; 4063///; 4064/// The following named arguments are supported; 4065///; 4066/// <table>; 4067/// <tr><th> <th> Options to control construction of chi2; 4068/// <tr><td> `Extended(bool flag)` <td> **Only applicable when fitting a RooAbsPdf**. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight.; 4069/// This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; 4070/// - If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events; 4071/// (in RooFit jargon, ""if the pdf can be extended"").; 4072/// - Passing `Extended(true)` when the the pdf makes no prediction on the expected number of events will result in error messages,; 4073/// and the chi2 will fall back to the total data weight to scale the normalized pdf.; 4074/// - There are cases where the fit **must** be done in extended mode. This happens for example when you have a RooAddPdf; 4075/// where the coefficients represent component yields. If the fit is not extended, these coefficients will not be; 4076/// well-defined, as the RooAddPdf always normalizes itself. If you pass `Extended(false)` in such a case, an error will be; 4077/// printed and you'll most likely get garbage results.; 4078/// <tr><td> `Range(const char* name)` <td> Fit only data inside range with given name; 4079/// <tr><td> `Range(double lo, double hi)` <td> Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; 4080/// Multiple comma separated range names can be specified.; 4081/// <tr><td> `NumCPU(int num)` <td> Parallelize NLL calculation on num CPUs; 4082/// <tr><td> `Optimize(bool flag)` <td> Activate constant term optimization (on by default); 4083/// <tr><td> `IntegrateBins()` <td> Integrate PDF within each bin. This sets the desired precision.; 4084///; 408",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:176805,Modifiability,extend,extended,176805,"4068/// <tr><td> `Extended(bool flag)` <td> **Only applicable when fitting a RooAbsPdf**. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight.; 4069/// This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; 4070/// - If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events; 4071/// (in RooFit jargon, ""if the pdf can be extended"").; 4072/// - Passing `Extended(true)` when the the pdf makes no prediction on the expected number of events will result in error messages,; 4073/// and the chi2 will fall back to the total data weight to scale the normalized pdf.; 4074/// - There are cases where the fit **must** be done in extended mode. This happens for example when you have a RooAddPdf; 4075/// where the coefficients represent component yields. If the fit is not extended, these coefficients will not be; 4076/// well-defined, as the RooAddPdf always normalizes itself. If you pass `Extended(false)` in such a case, an error will be; 4077/// printed and you'll most likely get garbage results.; 4078/// <tr><td> `Range(const char* name)` <td> Fit only data inside range with given name; 4079/// <tr><td> `Range(double lo, double hi)` <td> Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; 4080/// Multiple comma separated range names can be specified.; 4081/// <tr><td> `NumCPU(int num)` <td> Parallelize NLL calculation on num CPUs; 4082/// <tr><td> `Optimize(bool flag)` <td> Activate constant term optimization (on by default); 4083/// <tr><td> `IntegrateBins()` <td> Integrate PDF within each bin. This sets the desired precision.; 4084///; 4085/// <tr><th> <th> Options to control flow of fit procedure; 4086/// <tr><td> `InitialHesse(bool flag)` <td> Flag controls if HESSE before MIGRAD as well, off by default; 4087/// <tr><td> `Hesse(bool flag)` <td> ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:181319,Modifiability,extend,extended,181319,"tween:; 4128/// - RooAbsData::Expected: Expected Poisson error (\f$ \sqrt{n_\text{expected}} \f$ from the PDF).; 4129/// - RooAbsData::SumW2: The observed error from the square root of the sum of weights,; 4130/// i.e., symmetric errors calculated with the standard deviation of a Poisson distribution.; 4131/// - RooAbsData::Poisson: Asymmetric errors from the central 68 % interval around a Poisson distribution with mean \f$ n_\text{observed} \f$.; 4132/// If for a given bin \f$ n_\text{expected} \f$ is lower than the \f$ n_\text{observed} \f$, the lower uncertainty is taken; 4133/// (e.g., the difference between the mean and the 16 % quantile).; 4134/// If \f$ n_\text{expected} \f$ is higher than \f$ n_\text{observed} \f$, the higher uncertainty is taken; 4135/// (e.g., the difference between the 84 % quantile and the mean).; 4136/// - RooAbsData::Auto (default): RooAbsData::Expected for unweighted data, RooAbsData::SumW2 for weighted data.; 4137/// <tr><td>; 4138/// `Extended()` <td> Use expected number of events of an extended p.d.f as normalization; 4139/// <tr><td>; 4140/// NumCPU() <td> Activate parallel processing feature; 4141/// <tr><td>; 4142/// Range() <td> Calculate \f$ \chi^2 \f$ only in selected region; 4143/// <tr><td>; 4144/// Verbose() <td> Verbose output of GOF framework; 4145/// <tr><td>; 4146/// IntegrateBins() <td> Integrate PDF within each bin. This sets the desired precision. Only useful for binned fits.; 4147/// <tr><td> `SumCoefRange()` <td> Set the range in which to interpret the coefficients of RooAddPdf components; 4148/// <tr><td> `SplitRange()` <td> Fit ranges used in different categories get named after the category.; 4149/// Using `Range(""range""), SplitRange()` as switches, different ranges could be set like this:; 4150/// ```; 4151/// myVariable.setRange(""range_pi0"", 135, 210);; 4152/// myVariable.setRange(""range_gamma"", 50, 210);; 4153/// ```; 4154/// <tr><td> `ConditionalObservables(Args_t &&... argsOrArgSet)` <td> Define projected o",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:182782,Modifiability,variab,variable,182782,"td>; 4146/// IntegrateBins() <td> Integrate PDF within each bin. This sets the desired precision. Only useful for binned fits.; 4147/// <tr><td> `SumCoefRange()` <td> Set the range in which to interpret the coefficients of RooAddPdf components; 4148/// <tr><td> `SplitRange()` <td> Fit ranges used in different categories get named after the category.; 4149/// Using `Range(""range""), SplitRange()` as switches, different ranges could be set like this:; 4150/// ```; 4151/// myVariable.setRange(""range_pi0"", 135, 210);; 4152/// myVariable.setRange(""range_gamma"", 50, 210);; 4153/// ```; 4154/// <tr><td> `ConditionalObservables(Args_t &&... argsOrArgSet)` <td> Define projected observables.; 4155/// Arguments can either be multiple RooRealVar or a single RooArgSet containing them.; 4156///; 4157/// </table>; 4158 ; 4159RooFit::OwningPtr<RooFitResult> RooAbsReal::chi2FitTo(RooDataHist &data, const RooLinkedList &cmdList); 4160{; 4161 return RooFit::makeOwningPtr(RooFit::FitHelpers::fitTo(*this, data, cmdList, true));; 4162}; 4163 ; 4164 ; 4165 ; 4166 ; 4167////////////////////////////////////////////////////////////////////////////////; 4168/// Create a \f$ \chi^2 \f$ variable from a histogram and this function.; 4169///; 4170/// \param arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8 ordered arguments; 4171///; 4172/// The list of supported command arguments is given in the documentation for; 4173/// RooChi2Var::RooChi2Var(const char *name, const char* title, RooAbsReal& func, RooDataHist& hdata, const RooCmdArg&,const RooCmdArg&,const RooCmdArg&, const RooCmdArg&,const RooCmdArg&,const RooCmdArg&, const RooCmdArg&,const RooCmdArg&,const RooCmdArg&).; 4174///; 4175/// \param data Histogram with data; 4176/// \return \f$ \chi^2 \f$ variable; 4177 ; 4178RooFit::OwningPtr<RooAbsReal> RooAbsReal::createChi2(RooDataHist &data, const RooCmdArg &arg1, const RooCmdArg &arg2,; 4179 const RooCmdArg &arg3, const RooCmdArg &arg4,; 4180 const RooCmdArg &arg5, const RooCmdArg &arg6,; 4181 const RooC",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:183348,Modifiability,variab,variable,183348,"i2FitTo(RooDataHist &data, const RooLinkedList &cmdList); 4160{; 4161 return RooFit::makeOwningPtr(RooFit::FitHelpers::fitTo(*this, data, cmdList, true));; 4162}; 4163 ; 4164 ; 4165 ; 4166 ; 4167////////////////////////////////////////////////////////////////////////////////; 4168/// Create a \f$ \chi^2 \f$ variable from a histogram and this function.; 4169///; 4170/// \param arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8 ordered arguments; 4171///; 4172/// The list of supported command arguments is given in the documentation for; 4173/// RooChi2Var::RooChi2Var(const char *name, const char* title, RooAbsReal& func, RooDataHist& hdata, const RooCmdArg&,const RooCmdArg&,const RooCmdArg&, const RooCmdArg&,const RooCmdArg&,const RooCmdArg&, const RooCmdArg&,const RooCmdArg&,const RooCmdArg&).; 4174///; 4175/// \param data Histogram with data; 4176/// \return \f$ \chi^2 \f$ variable; 4177 ; 4178RooFit::OwningPtr<RooAbsReal> RooAbsReal::createChi2(RooDataHist &data, const RooCmdArg &arg1, const RooCmdArg &arg2,; 4179 const RooCmdArg &arg3, const RooCmdArg &arg4,; 4180 const RooCmdArg &arg5, const RooCmdArg &arg6,; 4181 const RooCmdArg &arg7, const RooCmdArg &arg8); 4182{; 4183 RooLinkedList l;; 4184 l.Add((TObject *)&arg1);; 4185 l.Add((TObject *)&arg2);; 4186 l.Add((TObject *)&arg3);; 4187 l.Add((TObject *)&arg4);; 4188 l.Add((TObject *)&arg5);; 4189 l.Add((TObject *)&arg6);; 4190 l.Add((TObject *)&arg7);; 4191 l.Add((TObject *)&arg8);; 4192 return createChi2(data, l);; 4193}; 4194 ; 4195////////////////////////////////////////////////////////////////////////////////; 4196/// \see RooAbsReal::createChi2(RooDataHist&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&); 4197/// \param data hist data; 4198/// \param cmdList List with RooCmdArg() from the table; 4199 ; 4200RooFit::OwningPtr<RooAbsReal> RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); 4201{; 4202 return RooFi",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:205296,Modifiability,variab,variables,205296,"::AClean@ ACleanDefinition RooAbsArg.h:362; RooAbsArg::getStringAttributeconst Text_t * getStringAttribute(const Text_t *key) constGet string attribute mapped under key 'key'.Definition RooAbsArg.cxx:275; RooAbsArg::getComponentsRooFit::OwningPtr< RooArgSet > getComponents() constCreate a RooArgSet with all components (branch nodes) of the expression tree headed by this object.Definition RooAbsArg.cxx:802; RooAbsArg::serversconst RefCountList_t & servers() constList of all servers of this object.Definition RooAbsArg.h:180; RooAbsArg::dependsOnValuebool dependsOnValue(const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr) constCheck whether this object depends on values from an element in the serverList.Definition RooAbsArg.h:108; RooAbsArg::setValueDirtyvoid setValueDirty()Mark the element dirty. This forces a re-evaluation when a value is requested.Definition RooAbsArg.h:462; RooAbsArg::getVariablesRooFit::OwningPtr< RooArgSet > getVariables(bool stripDisconnected=true) constReturn RooArgSet with all variables (tree leaf nodes of expression tree)Definition RooAbsArg.cxx:2154; RooAbsArg::printMultilinevoid printMultiline(std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const overrideImplement multi-line detailed printing.Definition RooAbsArg.cxx:1589; RooAbsArg::cloneTreevirtual RooAbsArg * cloneTree(const char *newname=nullptr) constClone tree expression of objects.Definition RooAbsArg.cxx:2293; RooAbsArg::cleanBranchNameTString cleanBranchName() constConstruct a mangled name from the actual name that is free of any math symbols that might be interpre...Definition RooAbsArg.cxx:2075; RooAbsArg::numProxiesInt_t numProxies() constReturn the number of registered proxies.Definition RooAbsArg.cxx:1457; RooAbsArg::_inhibitDirtystatic bool _inhibitDirtyDefinition RooAbsArg.h:668; RooAbsArg::setAttributevoid setAttribute(const Text_t *name, bool value=true)Set (default) or clear a named boolean attribute of this object.Definition Roo",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:207964,Modifiability,variab,variables,207964,"bject * Clone(const char *newname=nullptr) const overrideMake a clone of an object using the Streamer facility.Definition RooAbsArg.h:91; RooAbsArg::_serverListRefCountList_t _serverListDefinition RooAbsArg.h:606; RooAbsArg::leafNodeServerListvoid leafNodeServerList(RooAbsCollection *list, const RooAbsArg *arg=nullptr, bool recurseNonDerived=false) constFill supplied list with all leaf nodes of the arg tree, starting with ourself as top node.Definition RooAbsArg.cxx:472; RooAbsArg::isFundamentalvirtual bool isFundamental() constIs this object a fundamental type that can be added to a dataset? Fundamental-type subclasses overrid...Definition RooAbsArg.h:223; RooAbsArg::redirectServersHookvirtual bool redirectServersHook(const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep)Function that is called at the end of redirectServers().Definition RooAbsArg.cxx:1313; RooAbsArg::checkObservablesvirtual bool checkObservables(const RooArgSet *nset) constOverloadable function in which derived classes can implement consistency checks of the variables.Definition RooAbsArg.cxx:817; RooAbsArg::treeNodeServerListvoid treeNodeServerList(RooAbsCollection *list, const RooAbsArg *arg=nullptr, bool doBranch=true, bool doLeaf=true, bool valueOnly=false, bool recurseNonDerived=false) constFill supplied list with nodes of the arg tree, following all server links, starting with ourself as t...Definition RooAbsArg.cxx:499; RooAbsBinningAbstract base class for RooRealVar binning definitions.Definition RooAbsBinning.h:25; RooAbsBinning::isParameterizedvirtual bool isParameterized() constInterface function.Definition RooAbsBinning.h:102; RooAbsBinning::highBoundFuncvirtual RooAbsReal * highBoundFunc() constReturn pointer to RooAbsReal parameterized upper bound, if any.Definition RooAbsBinning.h:110; RooAbsBinning::lowBoundFuncvirtual RooAbsReal * lowBoundFunc() constReturn pointer to RooAbsReal parameterized lower bound, if any.Definition RooAbsBinning.h",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:208655,Modifiability,parameteriz,parameterized,208655,"Collection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep)Function that is called at the end of redirectServers().Definition RooAbsArg.cxx:1313; RooAbsArg::checkObservablesvirtual bool checkObservables(const RooArgSet *nset) constOverloadable function in which derived classes can implement consistency checks of the variables.Definition RooAbsArg.cxx:817; RooAbsArg::treeNodeServerListvoid treeNodeServerList(RooAbsCollection *list, const RooAbsArg *arg=nullptr, bool doBranch=true, bool doLeaf=true, bool valueOnly=false, bool recurseNonDerived=false) constFill supplied list with nodes of the arg tree, following all server links, starting with ourself as t...Definition RooAbsArg.cxx:499; RooAbsBinningAbstract base class for RooRealVar binning definitions.Definition RooAbsBinning.h:25; RooAbsBinning::isParameterizedvirtual bool isParameterized() constInterface function.Definition RooAbsBinning.h:102; RooAbsBinning::highBoundFuncvirtual RooAbsReal * highBoundFunc() constReturn pointer to RooAbsReal parameterized upper bound, if any.Definition RooAbsBinning.h:110; RooAbsBinning::lowBoundFuncvirtual RooAbsReal * lowBoundFunc() constReturn pointer to RooAbsReal parameterized lower bound, if any.Definition RooAbsBinning.h:106; RooAbsCategoryLValueAbstract base class for objects that represent a discrete value that can be set from the outside,...Definition RooAbsCategoryLValue.h:26; RooAbsCategoryLValue::setIndexvirtual bool setIndex(value_type index, bool printError=true)=0Change category state by specifying the index code of the desired state.; RooAbsCategoryA space to attach TBranches.Definition RooAbsCategory.h:33; RooAbsCategory::getCurrentIndexvirtual value_type getCurrentIndex() constReturn index number of current state.Definition RooAbsCategory.cxx:121; RooAbsCategory::isSignTypebool isSignType(bool mustHaveZero=false) constDetermine if category has 2 or 3 states with index values -1,0,1.Definition RooAbsCategory.cxx:660; RooAbsCollectionAbs",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:208818,Modifiability,parameteriz,parameterized,208818,"xx:1313; RooAbsArg::checkObservablesvirtual bool checkObservables(const RooArgSet *nset) constOverloadable function in which derived classes can implement consistency checks of the variables.Definition RooAbsArg.cxx:817; RooAbsArg::treeNodeServerListvoid treeNodeServerList(RooAbsCollection *list, const RooAbsArg *arg=nullptr, bool doBranch=true, bool doLeaf=true, bool valueOnly=false, bool recurseNonDerived=false) constFill supplied list with nodes of the arg tree, following all server links, starting with ourself as t...Definition RooAbsArg.cxx:499; RooAbsBinningAbstract base class for RooRealVar binning definitions.Definition RooAbsBinning.h:25; RooAbsBinning::isParameterizedvirtual bool isParameterized() constInterface function.Definition RooAbsBinning.h:102; RooAbsBinning::highBoundFuncvirtual RooAbsReal * highBoundFunc() constReturn pointer to RooAbsReal parameterized upper bound, if any.Definition RooAbsBinning.h:110; RooAbsBinning::lowBoundFuncvirtual RooAbsReal * lowBoundFunc() constReturn pointer to RooAbsReal parameterized lower bound, if any.Definition RooAbsBinning.h:106; RooAbsCategoryLValueAbstract base class for objects that represent a discrete value that can be set from the outside,...Definition RooAbsCategoryLValue.h:26; RooAbsCategoryLValue::setIndexvirtual bool setIndex(value_type index, bool printError=true)=0Change category state by specifying the index code of the desired state.; RooAbsCategoryA space to attach TBranches.Definition RooAbsCategory.h:33; RooAbsCategory::getCurrentIndexvirtual value_type getCurrentIndex() constReturn index number of current state.Definition RooAbsCategory.cxx:121; RooAbsCategory::isSignTypebool isSignType(bool mustHaveZero=false) constDetermine if category has 2 or 3 states with index values -1,0,1.Definition RooAbsCategory.cxx:660; RooAbsCollectionAbstract container object that can hold multiple RooAbsArg objects.Definition RooAbsCollection.h:65; RooAbsCollection::uniqueIdRooFit::UniqueId< RooAbsCollection > con",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:212543,Modifiability,variab,variable,212543,"dOwned(RooAbsArg &var, bool silent=false)Add an argument and transfer the ownership to the collection.Definition RooAbsCollection.cxx:367; RooAbsCollection::addClonevirtual RooAbsArg * addClone(const RooAbsArg &var, bool silent=false)Add a clone of the specified argument to list.Definition RooAbsCollection.cxx:416; RooAbsCollection::contentsStringstd::string contentsString() constReturn comma separated list of contained object names as STL string.Definition RooAbsCollection.cxx:1148; RooAbsCollection::findRooAbsArg * find(const char *name) constFind object with given name in list.Definition RooAbsCollection.cxx:922; RooAbsDataAbstract base class for binned and unbinned datasets.Definition RooAbsData.h:57; RooAbsData::getvirtual const RooArgSet * get() constDefinition RooAbsData.h:101; RooAbsData::numEntriesvirtual Int_t numEntries() constReturn number of entries in dataset, i.e., count unweighted entries.Definition RooAbsData.cxx:323; RooAbsFuncAbstract interface for evaluating a real-valued function of one real variable and performing numerica...Definition RooAbsFunc.h:27; RooAbsFunc::getMaxLimitvirtual double getMaxLimit(UInt_t dimension) const =0; RooAbsFunc::operator()virtual double operator()(const double xvector[]) const =0; RooAbsFunc::getMinLimitvirtual double getMinLimit(UInt_t dimension) const =0; RooAbsLValueAbstract base class for objects that are lvalues, i.e.Definition RooAbsLValue.h:26; RooAbsMomentDefinition RooAbsMoment.h:27; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::expectedEventsvirtual double expectedEvents(const RooArgSet *nset) constReturn expected number of events to be used in calculation of extended likelihood.Definition RooAbsPdf.cxx:2398; RooAbsPdf::Classstatic TClass * Class(); RooAbsPdf::CanNotBeExtended@ CanNotBeExtendedDefinition RooAbsPdf.h:212; RooAbsPdf::normRangeconst char * normRange() constDefinition RooAbsPdf.h:250; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > ge",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:213220,Modifiability,extend,extended,213220,"act base class for binned and unbinned datasets.Definition RooAbsData.h:57; RooAbsData::getvirtual const RooArgSet * get() constDefinition RooAbsData.h:101; RooAbsData::numEntriesvirtual Int_t numEntries() constReturn number of entries in dataset, i.e., count unweighted entries.Definition RooAbsData.cxx:323; RooAbsFuncAbstract interface for evaluating a real-valued function of one real variable and performing numerica...Definition RooAbsFunc.h:27; RooAbsFunc::getMaxLimitvirtual double getMaxLimit(UInt_t dimension) const =0; RooAbsFunc::operator()virtual double operator()(const double xvector[]) const =0; RooAbsFunc::getMinLimitvirtual double getMinLimit(UInt_t dimension) const =0; RooAbsLValueAbstract base class for objects that are lvalues, i.e.Definition RooAbsLValue.h:26; RooAbsMomentDefinition RooAbsMoment.h:27; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::expectedEventsvirtual double expectedEvents(const RooArgSet *nset) constReturn expected number of events to be used in calculation of extended likelihood.Definition RooAbsPdf.cxx:2398; RooAbsPdf::Classstatic TClass * Class(); RooAbsPdf::CanNotBeExtended@ CanNotBeExtendedDefinition RooAbsPdf.h:212; RooAbsPdf::normRangeconst char * normRange() constDefinition RooAbsPdf.h:250; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={})See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,...Definition RooAbsPdf.h:57; RooAbsPdf::extendModevirtual ExtendMode extendMode() constReturns ability of PDF to provide extended likelihood terms.Definition RooAbsPdf.h:216; RooAbsProxyAbstract interface for proxy classes.Definition RooAbsProxy.h:37; RooAbsRealLValueAbstract base class for objects that represent a real value that may appear on the left hand side of ..",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:213824,Modifiability,extend,extendModevirtual,213824," class for objects that are lvalues, i.e.Definition RooAbsLValue.h:26; RooAbsMomentDefinition RooAbsMoment.h:27; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::expectedEventsvirtual double expectedEvents(const RooArgSet *nset) constReturn expected number of events to be used in calculation of extended likelihood.Definition RooAbsPdf.cxx:2398; RooAbsPdf::Classstatic TClass * Class(); RooAbsPdf::CanNotBeExtended@ CanNotBeExtendedDefinition RooAbsPdf.h:212; RooAbsPdf::normRangeconst char * normRange() constDefinition RooAbsPdf.h:250; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={})See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,...Definition RooAbsPdf.h:57; RooAbsPdf::extendModevirtual ExtendMode extendMode() constReturns ability of PDF to provide extended likelihood terms.Definition RooAbsPdf.h:216; RooAbsProxyAbstract interface for proxy classes.Definition RooAbsProxy.h:37; RooAbsRealLValueAbstract base class for objects that represent a real value that may appear on the left hand side of ...Definition RooAbsRealLValue.h:31; RooAbsRealLValue::getMaxvirtual double getMax(const char *name=nullptr) constGet maximum of currently defined range.Definition RooAbsRealLValue.h:84; RooAbsRealLValue::createHistogramTH1 * createHistogram(const char *name, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) constDefinition RooAbsRealLValue.cxx:534; RooAbsRealLValue::getMinvirtual double getMin(const char *name=nullptr) constGet minimum of currently defined range.Definition RooAbsRealLValue.h:81; RooAbsReal::EvalErrorDefinition RooAbsReal.h:307; RooAbs",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:213853,Modifiability,extend,extendMode,213853," class for objects that are lvalues, i.e.Definition RooAbsLValue.h:26; RooAbsMomentDefinition RooAbsMoment.h:27; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::expectedEventsvirtual double expectedEvents(const RooArgSet *nset) constReturn expected number of events to be used in calculation of extended likelihood.Definition RooAbsPdf.cxx:2398; RooAbsPdf::Classstatic TClass * Class(); RooAbsPdf::CanNotBeExtended@ CanNotBeExtendedDefinition RooAbsPdf.h:212; RooAbsPdf::normRangeconst char * normRange() constDefinition RooAbsPdf.h:250; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={})See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,...Definition RooAbsPdf.h:57; RooAbsPdf::extendModevirtual ExtendMode extendMode() constReturns ability of PDF to provide extended likelihood terms.Definition RooAbsPdf.h:216; RooAbsProxyAbstract interface for proxy classes.Definition RooAbsProxy.h:37; RooAbsRealLValueAbstract base class for objects that represent a real value that may appear on the left hand side of ...Definition RooAbsRealLValue.h:31; RooAbsRealLValue::getMaxvirtual double getMax(const char *name=nullptr) constGet maximum of currently defined range.Definition RooAbsRealLValue.h:84; RooAbsRealLValue::createHistogramTH1 * createHistogram(const char *name, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) constDefinition RooAbsRealLValue.cxx:534; RooAbsRealLValue::getMinvirtual double getMin(const char *name=nullptr) constGet minimum of currently defined range.Definition RooAbsRealLValue.h:81; RooAbsReal::EvalErrorDefinition RooAbsReal.h:307; RooAbs",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:213905,Modifiability,extend,extended,213905," class for objects that are lvalues, i.e.Definition RooAbsLValue.h:26; RooAbsMomentDefinition RooAbsMoment.h:27; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::expectedEventsvirtual double expectedEvents(const RooArgSet *nset) constReturn expected number of events to be used in calculation of extended likelihood.Definition RooAbsPdf.cxx:2398; RooAbsPdf::Classstatic TClass * Class(); RooAbsPdf::CanNotBeExtended@ CanNotBeExtendedDefinition RooAbsPdf.h:212; RooAbsPdf::normRangeconst char * normRange() constDefinition RooAbsPdf.h:250; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={})See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,...Definition RooAbsPdf.h:57; RooAbsPdf::extendModevirtual ExtendMode extendMode() constReturns ability of PDF to provide extended likelihood terms.Definition RooAbsPdf.h:216; RooAbsProxyAbstract interface for proxy classes.Definition RooAbsProxy.h:37; RooAbsRealLValueAbstract base class for objects that represent a real value that may appear on the left hand side of ...Definition RooAbsRealLValue.h:31; RooAbsRealLValue::getMaxvirtual double getMax(const char *name=nullptr) constGet maximum of currently defined range.Definition RooAbsRealLValue.h:84; RooAbsRealLValue::createHistogramTH1 * createHistogram(const char *name, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) constDefinition RooAbsRealLValue.cxx:534; RooAbsRealLValue::getMinvirtual double getMin(const char *name=nullptr) constGet minimum of currently defined range.Definition RooAbsRealLValue.h:81; RooAbsReal::EvalErrorDefinition RooAbsReal.h:307; RooAbs",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:220936,Modifiability,adapt,adaptor,220936,"AbsReal::createScanRIRooFit::OwningPtr< RooAbsReal > createScanRI(const RooArgSet &iset, const RooArgSet &nset, Int_t numScanBins, Int_t intOrder)Utility function for createRunningIntegral that construct an object implementing the numeric scanning...Definition RooAbsReal.cxx:3810; RooAbsReal::_DEBUG_getValdouble _DEBUG_getVal(const RooArgSet *normalisationSet) constDebug version of getVal(), which is slow and does error checking.Definition RooAbsReal.cxx:4434; RooAbsReal::createFundamentalRooFit::OwningPtr< RooAbsArg > createFundamental(const char *newname=nullptr) const overrideCreate a RooRealVar fundamental object with our properties.Definition RooAbsReal.cxx:3130; RooAbsReal::plotSanityChecksbool plotSanityChecks(RooPlot *frame) constUtility function for plotOn(), perform general sanity check on frame to ensure safe plotting operatio...Definition RooAbsReal.cxx:2860; RooAbsReal::bindVarsRooFit::OwningPtr< RooAbsFunc > bindVars(const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) constCreate an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order).Definition RooAbsReal.cxx:2980; RooAbsReal::selectNormalizationvirtual void selectNormalization(const RooArgSet *depSet=nullptr, bool force=false)Interface function to force use of a given set of observables to interpret function value.Definition RooAbsReal.cxx:3360; RooAbsReal::derivativeRooDerivative * derivative(RooRealVar &obs, Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Perform a fit to given histogram.Definition RooAbsReal.cxx:4105; RooAbsReal::asTFTF1 * asTF",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:220983,Modifiability,variab,variables,220983,"AbsReal::createScanRIRooFit::OwningPtr< RooAbsReal > createScanRI(const RooArgSet &iset, const RooArgSet &nset, Int_t numScanBins, Int_t intOrder)Utility function for createRunningIntegral that construct an object implementing the numeric scanning...Definition RooAbsReal.cxx:3810; RooAbsReal::_DEBUG_getValdouble _DEBUG_getVal(const RooArgSet *normalisationSet) constDebug version of getVal(), which is slow and does error checking.Definition RooAbsReal.cxx:4434; RooAbsReal::createFundamentalRooFit::OwningPtr< RooAbsArg > createFundamental(const char *newname=nullptr) const overrideCreate a RooRealVar fundamental object with our properties.Definition RooAbsReal.cxx:3130; RooAbsReal::plotSanityChecksbool plotSanityChecks(RooPlot *frame) constUtility function for plotOn(), perform general sanity check on frame to ensure safe plotting operatio...Definition RooAbsReal.cxx:2860; RooAbsReal::bindVarsRooFit::OwningPtr< RooAbsFunc > bindVars(const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) constCreate an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order).Definition RooAbsReal.cxx:2980; RooAbsReal::selectNormalizationvirtual void selectNormalization(const RooArgSet *depSet=nullptr, bool force=false)Interface function to force use of a given set of observables to interpret function value.Definition RooAbsReal.cxx:3360; RooAbsReal::derivativeRooDerivative * derivative(RooRealVar &obs, Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Perform a fit to given histogram.Definition RooAbsReal.cxx:4105; RooAbsReal::asTFTF1 * asTF",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:222332,Modifiability,config,configuration,222332,"ooAbsReal::derivativeRooDerivative * derivative(RooRealVar &obs, Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Perform a fit to given histogram.Definition RooAbsReal.cxx:4105; RooAbsReal::asTFTF1 * asTF(const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) constReturn a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parame...Definition RooAbsReal.cxx:3911; RooAbsReal::_unitTString _unitUnit for objects value.Definition RooAbsReal.h:537; RooAbsReal::defaultIntegratorConfigstatic RooNumIntConfig * defaultIntegratorConfig()Returns the default numeric integration configuration for all RooAbsReals.Definition RooAbsReal.cxx:3272; RooAbsReal::readFromStreambool readFromStream(std::istream &is, bool compact, bool verbose=false) overrideRead object contents from stream (dummy for now)Definition RooAbsReal.cxx:426; RooAbsReal::matchArgsbool matchArgs(const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a) constUtility function for use in getAnalyticalIntegral().Definition RooAbsReal.cxx:3146; RooAbsReal::fillTreeBranchvoid fillTreeBranch(TTree &t) overrideFill the tree branch that associated with this object with its current value.Definition RooAbsReal.cxx:3099; RooAbsReal::printMultilinevoid printMultiline(std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const overrideStructure printing.Definition RooAbsReal.cxx:455; RooAbsReal::plotAsymOnvirtual RooPlot * plotAsymOn(RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) constDefinition RooAbsReal.cxx:2199;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:224135,Modifiability,config,configuration,224135,"efinition RooAbsReal.cxx:455; RooAbsReal::plotAsymOnvirtual RooPlot * plotAsymOn(RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) constDefinition RooAbsReal.cxx:2199; RooAbsReal::operator==bool operator==(double value) constEquality operator comparing to a double.Definition RooAbsReal.cxx:250; RooAbsReal::evalErrorLoggingModestatic ErrorLoggingMode evalErrorLoggingMode()Return current evaluation error logging mode.Definition RooAbsReal.cxx:4302; RooAbsReal::redirectServersHookbool redirectServersHook(const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) overrideFunction that is called at the end of redirectServers().Definition RooAbsReal.cxx:4474; RooAbsReal::isValidRealvirtual bool isValidReal(double, bool printError=false) constInterface function to check if given value is a valid value for this object. Returns true unless over...Definition RooAbsReal.h:447; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::printValuevoid printValue(std::ostream &os) const overridePrint object value.Definition RooAbsReal.cxx:445; RooAbsReal::isIdenticalbool isIdentical(const RooAbsArg &other, bool assumeSameType=false) const overrideDefinition RooAbsReal.cxx:270; RooAbsReal::createProfilevirtual RooFit::OwningPtr< RooAbsReal > createProfile(const RooArgSet &paramsOfInterest)Create a RooProfileLL object that eliminates all nuisance parameters in the present function.Definition RooAbsReal.cxx:471; RooAbsReal::_hideOffsetstatic bool _hideOffsetOffset hiding flag.Definition RooAbsReal.h:546; RooAbsReal::attachToVStorevoid attachToVStore(RooVectorDataStore &vstore) overrideDefinition RooAbsReal.cxx:3012; RooAbsReal::copyCachevoid copyCache(const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) overrideCopy the cached value of another RooAbsArg to our cache.Definition RooAbsReal.c",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:225328,Modifiability,variab,variables,225328,"printValuevoid printValue(std::ostream &os) const overridePrint object value.Definition RooAbsReal.cxx:445; RooAbsReal::isIdenticalbool isIdentical(const RooAbsArg &other, bool assumeSameType=false) const overrideDefinition RooAbsReal.cxx:270; RooAbsReal::createProfilevirtual RooFit::OwningPtr< RooAbsReal > createProfile(const RooArgSet &paramsOfInterest)Create a RooProfileLL object that eliminates all nuisance parameters in the present function.Definition RooAbsReal.cxx:471; RooAbsReal::_hideOffsetstatic bool _hideOffsetOffset hiding flag.Definition RooAbsReal.h:546; RooAbsReal::attachToVStorevoid attachToVStore(RooVectorDataStore &vstore) overrideDefinition RooAbsReal.cxx:3012; RooAbsReal::copyCachevoid copyCache(const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) overrideCopy the cached value of another RooAbsArg to our cache.Definition RooAbsReal.cxx:2997; RooAbsReal::createHistogramTH1 * createHistogram(RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) constCreate and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables w...Definition RooAbsReal.cxx:1183; RooAbsReal::fixAddCoefRangevirtual void fixAddCoefRange(const char *rangeName=nullptr, bool force=true)Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by...Definition RooAbsReal.cxx:3675; RooAbsReal::_valuedouble _valueCache for current value of object.Definition RooAbsReal.h:536; RooAbsReal::analyticalIntegralvirtual double analyticalIntegral(Int_t code, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:394; RooAbsReal::attachToTreevoid attachToTree(TTree &t, Int_t bufSize=32000) overrideAttach object to a branch of given TTree.Definition RooAbsReal.cxx:3028; RooAbsReal::specialIntegratorConfigRooNumIntConfig * specialIntegratorConfig() constReturns the specialized integrator configuration for",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:226204,Modifiability,config,configuration,226204,"gram(RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) constCreate and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables w...Definition RooAbsReal.cxx:1183; RooAbsReal::fixAddCoefRangevirtual void fixAddCoefRange(const char *rangeName=nullptr, bool force=true)Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by...Definition RooAbsReal.cxx:3675; RooAbsReal::_valuedouble _valueCache for current value of object.Definition RooAbsReal.h:536; RooAbsReal::analyticalIntegralvirtual double analyticalIntegral(Int_t code, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:394; RooAbsReal::attachToTreevoid attachToTree(TTree &t, Int_t bufSize=32000) overrideAttach object to a branch of given TTree.Definition RooAbsReal.cxx:3028; RooAbsReal::specialIntegratorConfigRooNumIntConfig * specialIntegratorConfig() constReturns the specialized integrator configuration for this RooAbsReal.Definition RooAbsReal.cxx:3282; RooAbsReal::writeToStreamvoid writeToStream(std::ostream &os, bool compact) const overrideWrite object contents to stream (dummy for now)Definition RooAbsReal.cxx:436; RooAbsReal::traceEvaldouble traceEval(const RooArgSet *set) constCalculate current value of object, with error tracing wrapper.Definition RooAbsReal.cxx:319; RooAbsReal::getPropagatedErrordouble getPropagatedError(const RooFitResult &fr, const RooArgSet &nset={}) constPropagates parameter uncertainties to an uncertainty estimate for this RooAbsReal.Definition RooAbsReal.cxx:2472; RooAbsReal::setHideOffsetstatic void setHideOffset(bool flag)Definition RooAbsReal.cxx:191; RooAbsReal::ErrorLoggingModeErrorLoggingModeDefinition RooAbsReal.h:317; RooAbsReal::CountErrors@ CountErrorsDefinition RooAbsReal.h:317; RooAbsReal::CollectErrors@ CollectErrorsDefinition RooAbsReal.h:317; RooAbsReal::PrintErrors@ PrintErrorsD",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:228449,Modifiability,variab,variable,228449,"cxx:2966; RooAbsReal::momentRooAbsMoment * moment(RooRealVar &obs, Int_t order, bool central, bool takeRoot)Return function representing moment of function of given order.Definition RooAbsReal.cxx:4015; RooAbsReal::buildCallToAnalyticIntegralvirtual std::string buildCallToAnalyticIntegral(Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) constThis function defines the analytical integral translation for the class.Definition RooAbsReal.cxx:4425; RooAbsReal::plotOnWithErrorBandRooPlot * plotOnWithErrorBand(RooPlot *frame, const RooFitResult &fr, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) constPlot function or PDF on frame with support for visualization of the uncertainty encoded in the given ...Definition RooAbsReal.cxx:2601; RooAbsReal::_lastNormSetIdRooFit::UniqueId< RooArgSet >::Value_t _lastNormSetIdComponent selection flag for RooAbsPdf::plotCompOn.Definition RooAbsReal.h:543; RooAbsReal::getPlotLabelconst char * getPlotLabel() constGet the label associated with the variable.Definition RooAbsReal.cxx:406; RooAbsReal::createRunningIntegralRooFit::OwningPtr< RooAbsReal > createRunningIntegral(const RooArgSet &iset, const RooArgSet &nset={})Calls createRunningIntegral(const RooArgSet&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&,...Definition RooAbsReal.cxx:3706; RooAbsReal::_specIntegratorConfigstd::unique_ptr< RooNumIntConfig > _specIntegratorConfigDefinition RooAbsReal.h:540; RooAbsReal::getAnalyticalIntegralvirtual Int_t getAnalyticalIntegral(RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) constInterface function getAnalyticalIntergral advertises the analytical integrals that are supported.Definition RooAbsReal.cxx:368; RooAbsReal::evalErrorIterstatic std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter()Definition RooAbsReal.cxx:181; RooAbsReal::numEvalErrorsstatic Int_t numEvalErrors()Return the number of lo",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:230881,Modifiability,variab,variable,230881,"ables for scanning t...Definition RooAbsReal.cxx:3694; RooAbsReal::maxValvirtual double maxVal(Int_t code) constReturn maximum value for set of observables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive integrals over functions ...Definition RooAbsReal.cxx:701; RooAbsReal::integralNameSuffixTString integralNameSuffix(const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit:",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:231549,Modifiability,config,configuration,231549,"itEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsReal.cxx:3827; RooAbsReal::enableOffsettingvirtual void enableOffsetting(bool)Definition RooAbsReal.cxx:4484; RooAbsReal::clearEvalErrorLogstatic void clearEvalErrorLog()Clear the stack of evaluation error messages.Definition RooAbsReal.cxx:3542; RooAbsReal::createIntObjRooFit::OwningPtr< RooAbsReal > createIntObj(const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) constInternal utility function for createIntegral() that creates the actual integral object.Def",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:233456,Modifiability,variab,variable,233456,"me) constInternal utility function for createIntegral() that creates the actual integral object.Definition RooAbsReal.cxx:590; RooAbsReal::functorRooFunctor * functor(const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) constReturn a RooFunctor object bound to this RooAbsReal with given definition of observables and paramete...Definition RooAbsReal.cxx:3887; RooAbsReal::createPlotProjectionconst RooAbsReal * createPlotProjection(const RooArgSet &depVars, const RooArgSet &projVars, RooArgSet *&cloneSet) constUtility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a Roo...Definition RooAbsReal.cxx:787; RooAbsReal::plotSamplingHintvirtual std::list< double > * plotSamplingHint(RooAbsRealLValue &obs, double xlo, double xhi) constInterface for returning an optional hint for initial sampling points when constructing a curve projec...Definition RooAbsReal.cxx:3571; RooAbsReal::setPlotLabelvoid setPlotLabel(const char *label)Set the label associated with this variable.Definition RooAbsReal.cxx:416; RooAbsReal::plotOnvirtual RooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) constPlot (project) PDF on specified frame.Definition RooAbsReal.cxx:1611; RooAbsReal::doEvalvirtual void doEval(RooFit::EvalContext &) constBase function for computing multiple values of a RooAbsReal.Definition RooAbsReal.cxx:4343; RooAbsReal::makeProjectionSetvoid makeProjectionSet(const RooAbsArg *plotVar, const RooArgSet *allVars, RooArgSet &projectedVars, bool silent) constUtility function for plotOn() that constructs the set of observables to project when plotting ourselv...Definition RooAbsReal.cxx:2903; RooAbsReal::getMaxValvirtual Int_t getMaxVal(const RooArgSet &vars) constAd",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:243723,Modifiability,adapt,adaptor,243723,"...Definition RooFitResult.cxx:1124; RooFitResult::floatParsFinalconst RooArgList & floatParsFinal() constReturn list of floating parameters after fit.Definition RooFitResult.h:111; RooFitResult::createHessePdfRooAbsPdf * createHessePdf(const RooArgSet &params) constReturn a p.d.f that represents the fit result as a multi-variate probability densisty function on the...Definition RooFitResult.cxx:1260; RooFit::Detail::CodeSquashContextA class to maintain the context for squashing of RooFit models into code.Definition CodeSquashContext.h:42; RooFit::EvalContextDefinition EvalContext.h:84; RooFit::EvalContext::atstd::span< const double > at(RooAbsArg const *arg, RooAbsArg const *caller=nullptr)Definition EvalContext.cxx:35; RooFit::EvalContext::outputstd::span< double > output()Definition EvalContext.h:112; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooFunctorLightweight interface adaptor that exports a RooAbsPdf as a functor.Definition RooFunctor.h:25; RooHistGraphical representation of binned data based on the TGraphAsymmErrors class.Definition RooHist.h:29; RooLinkedListCollection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list...Definition RooLinkedList.h:44; RooLinkedList::Deletevoid Delete(Option_t *o=nullptr) overrideRemove all elements in collection and delete all elements NB: Collection does not own elements,...Definition RooLinkedList.cxx:578; RooLinkedList::Addvirtual void Add(TObject *arg)Definition RooLinkedList.h:73; RooLinkedList::beginRooLinkedListIterImpl begin() constDefinition RooLinkedList.cxx:761; RooLinkedList::FindObjectTObject * FindObject(const char *name) const overrideReturn pointer to object with given name.Definition RooLinkedList.cxx:534; RooMomentDefinition RooMoment.h:26; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cx",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:244962,Modifiability,config,configuration,244962,"pointers in a doubly linked list...Definition RooLinkedList.h:44; RooLinkedList::Deletevoid Delete(Option_t *o=nullptr) overrideRemove all elements in collection and delete all elements NB: Collection does not own elements,...Definition RooLinkedList.cxx:578; RooLinkedList::Addvirtual void Add(TObject *arg)Definition RooLinkedList.h:73; RooLinkedList::beginRooLinkedListIterImpl begin() constDefinition RooLinkedList.cxx:761; RooLinkedList::FindObjectTObject * FindObject(const char *name) const overrideReturn pointer to object with given name.Definition RooLinkedList.cxx:534; RooMomentDefinition RooMoment.h:26; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::isActivebool isActive(T self, RooFit::MsgTopic topic, RooFit::MsgLevel level)Check if logging is active for given object/topic/RooFit::MsgLevel combination.Definition RooMsgService.h:186; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooNumIntConfig::defaultConfigstatic RooNumIntConfig & defaultConfig()Return reference to instance of default numeric integrator configuration object.Definition RooNumIntConfig.cxx:44; RooParamBinningImplementation of RooAbsBinning that constructs a binning with a range definition that depends on ext...Definition RooParamBinning.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::removevoid remove(const char *name=nullptr, bool deleteToo=true)Remove object with given name, or last object added if no name is given.Definition RooPlot.cxx:868; RooPlot::drawBeforebool drawBefore(const char *before, const char *target)Change the order in which our contained objects are drawn so that the target object is drawn just bef...Definition RooPlot.cxx:906; RooPlot::findObjectTObject * findObject(const char *name, const TClass *tClass=nullptr) constFi",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:245208,Modifiability,config,configuration,245208,"nd delete all elements NB: Collection does not own elements,...Definition RooLinkedList.cxx:578; RooLinkedList::Addvirtual void Add(TObject *arg)Definition RooLinkedList.h:73; RooLinkedList::beginRooLinkedListIterImpl begin() constDefinition RooLinkedList.cxx:761; RooLinkedList::FindObjectTObject * FindObject(const char *name) const overrideReturn pointer to object with given name.Definition RooLinkedList.cxx:534; RooMomentDefinition RooMoment.h:26; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::isActivebool isActive(T self, RooFit::MsgTopic topic, RooFit::MsgLevel level)Check if logging is active for given object/topic/RooFit::MsgLevel combination.Definition RooMsgService.h:186; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooNumIntConfig::defaultConfigstatic RooNumIntConfig & defaultConfig()Return reference to instance of default numeric integrator configuration object.Definition RooNumIntConfig.cxx:44; RooParamBinningImplementation of RooAbsBinning that constructs a binning with a range definition that depends on ext...Definition RooParamBinning.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::removevoid remove(const char *name=nullptr, bool deleteToo=true)Remove object with given name, or last object added if no name is given.Definition RooPlot.cxx:868; RooPlot::drawBeforebool drawBefore(const char *before, const char *target)Change the order in which our contained objects are drawn so that the target object is drawn just bef...Definition RooPlot.cxx:906; RooPlot::findObjectTObject * findObject(const char *name, const TClass *tClass=nullptr) constFind the named object in our list of items and return a pointer to it.Definition RooPlot.cxx:942; RooPlot::getNormVarsconst RooArgSet * getNormVars() constDefinition",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:249263,Modifiability,variab,variable,249263," RooPrintable.h:33; RooPrintable::kValue@ kValueDefinition RooPrintable.h:33; RooPrintable::kArgs@ kArgsDefinition RooPrintable.h:33; RooPrintable::kExtras@ kExtrasDefinition RooPrintable.h:33; RooPrintable::printStreamvirtual void printStream(std::ostream &os, Int_t contents, StyleOption style, TString indent="""") constPrint description of object on ostream, printing contents set by contents integer,...Definition RooPrintable.cxx:72; RooRealIntegralPerforms hybrid numerical/analytical integrals of RooAbsReal objects.Definition RooRealIntegral.h:29; RooRealIntegral::numIntRealVarsconst RooArgSet & numIntRealVars() constDefinition RooRealIntegral.h:48; RooRealIntegral::setAllowComponentSelectionvoid setAllowComponentSelection(bool allow)Set component selection to be allowed/forbidden.Definition RooRealIntegral.cxx:1031; RooRealIntegral::Classstatic TClass * Class(); RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::setValvoid setVal(double value) overrideSet value of variable to 'value'.Definition RooRealVar.cxx:242; RooRealVar::setBinningvoid setBinning(const RooAbsBinning &binning, const char *name=nullptr)Add given binning under name 'name' with this variable.Definition RooRealVar.cxx:403; RooRealVar::setBinsvoid setBins(Int_t nBins, const char *name=nullptr)Create a uniform binning under name 'name' for this variable.Definition RooRealVar.cxx:396; RooSecondMomentDefinition RooSecondMoment.h:27; RooStringViewThe RooStringView is a wrapper around a C-style string that can also be constructed from a std::strin...Definition RooStringView.h:27; RooVectorDataStore::RealVector::setBuffervoid setBuffer(RooAbsReal *real, double *newBuf)Definition RooVectorDataStore.h:248; RooVectorDataStoreUses std::vector to store data columns.Definition RooVectorDataStore.h:41; RooVectorDataStore::addRealRealVector * addReal(RooAbsReal *real)Definition RooVectorDataStore.cxx:1244; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:249453,Modifiability,variab,variable,249453,"::kExtras@ kExtrasDefinition RooPrintable.h:33; RooPrintable::printStreamvirtual void printStream(std::ostream &os, Int_t contents, StyleOption style, TString indent="""") constPrint description of object on ostream, printing contents set by contents integer,...Definition RooPrintable.cxx:72; RooRealIntegralPerforms hybrid numerical/analytical integrals of RooAbsReal objects.Definition RooRealIntegral.h:29; RooRealIntegral::numIntRealVarsconst RooArgSet & numIntRealVars() constDefinition RooRealIntegral.h:48; RooRealIntegral::setAllowComponentSelectionvoid setAllowComponentSelection(bool allow)Set component selection to be allowed/forbidden.Definition RooRealIntegral.cxx:1031; RooRealIntegral::Classstatic TClass * Class(); RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::setValvoid setVal(double value) overrideSet value of variable to 'value'.Definition RooRealVar.cxx:242; RooRealVar::setBinningvoid setBinning(const RooAbsBinning &binning, const char *name=nullptr)Add given binning under name 'name' with this variable.Definition RooRealVar.cxx:403; RooRealVar::setBinsvoid setBins(Int_t nBins, const char *name=nullptr)Create a uniform binning under name 'name' for this variable.Definition RooRealVar.cxx:396; RooSecondMomentDefinition RooSecondMoment.h:27; RooStringViewThe RooStringView is a wrapper around a C-style string that can also be constructed from a std::strin...Definition RooStringView.h:27; RooVectorDataStore::RealVector::setBuffervoid setBuffer(RooAbsReal *real, double *newBuf)Definition RooVectorDataStore.h:248; RooVectorDataStoreUses std::vector to store data columns.Definition RooVectorDataStore.h:41; RooVectorDataStore::addRealRealVector * addReal(RooAbsReal *real)Definition RooVectorDataStore.cxx:1244; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definitio",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:249615,Modifiability,variab,variable,249615,"onstPrint description of object on ostream, printing contents set by contents integer,...Definition RooPrintable.cxx:72; RooRealIntegralPerforms hybrid numerical/analytical integrals of RooAbsReal objects.Definition RooRealIntegral.h:29; RooRealIntegral::numIntRealVarsconst RooArgSet & numIntRealVars() constDefinition RooRealIntegral.h:48; RooRealIntegral::setAllowComponentSelectionvoid setAllowComponentSelection(bool allow)Set component selection to be allowed/forbidden.Definition RooRealIntegral.cxx:1031; RooRealIntegral::Classstatic TClass * Class(); RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::setValvoid setVal(double value) overrideSet value of variable to 'value'.Definition RooRealVar.cxx:242; RooRealVar::setBinningvoid setBinning(const RooAbsBinning &binning, const char *name=nullptr)Add given binning under name 'name' with this variable.Definition RooRealVar.cxx:403; RooRealVar::setBinsvoid setBins(Int_t nBins, const char *name=nullptr)Create a uniform binning under name 'name' for this variable.Definition RooRealVar.cxx:396; RooSecondMomentDefinition RooSecondMoment.h:27; RooStringViewThe RooStringView is a wrapper around a C-style string that can also be constructed from a std::strin...Definition RooStringView.h:27; RooVectorDataStore::RealVector::setBuffervoid setBuffer(RooAbsReal *real, double *newBuf)Definition RooVectorDataStore.h:248; RooVectorDataStoreUses std::vector to store data columns.Definition RooVectorDataStore.h:41; RooVectorDataStore::addRealRealVector * addReal(RooAbsReal *real)Definition RooVectorDataStore.cxx:1244; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLineLine Attributes class.Definition TAttLine.h:18; TAttLine::SetLineStylevirtual void SetLineStyle(Style_t lstyle)Set the line style.Definition TAtt",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:260818,Modifiability,enhance,enhance,260818,RooAbsReal::PlotOpt::addToWgtSelfdouble addToWgtSelfDefinition RooAbsReal.h:482; RooAbsReal::PlotOpt::shiftToZerobool shiftToZeroDefinition RooAbsReal.h:471; RooAbsReal::PlotOpt::projDataSetconst RooArgSet * projDataSetDefinition RooAbsReal.h:472; RooAbsReal::PlotOpt::binProjDatabool binProjDataDefinition RooAbsReal.h:468; RooAbsReal::PlotOpt::stypeScaleType stypeDefinition RooAbsReal.h:466; RooAbsReal::PlotOpt::curveNameSuffixconst char * curveNameSuffixDefinition RooAbsReal.h:486; RooAbsReal::PlotOpt::addToCurveNameconst char * addToCurveNameDefinition RooAbsReal.h:481; RooAbsReal::PlotOpt::numeeInt_t numeeDefinition RooAbsReal.h:487; RooAbsReal::PlotOpt::errorFRconst RooFitResult * errorFRDefinition RooAbsReal.h:491; RooAbsReal::PlotOpt::rangeHidouble rangeHiDefinition RooAbsReal.h:475; RooAbsReal::PlotOpt::numCPUInt_t numCPUDefinition RooAbsReal.h:484; RooAbsReal::PlotOpt::projSetconst RooArgSet * projSetDefinition RooAbsReal.h:469; RooAbsReal::PlotOpt::postRangeFracScalebool postRangeFracScaleDefinition RooAbsReal.h:476; RooAbsReal::PlotOpt::curveInvisiblebool curveInvisibleDefinition RooAbsReal.h:479; RooAbsReal::PlotOpt::curveNameconst char * curveNameDefinition RooAbsReal.h:480; RooAbsReal::PlotOpt::projDataconst RooAbsData * projDataDefinition RooAbsReal.h:467; RooAbsReal::PlotOpt::drawOptionsOption_t * drawOptionsDefinition RooAbsReal.h:464; RooAbsReal::PlotOpt::rangeLodouble rangeLoDefinition RooAbsReal.h:474; RooFit::UniqueIdA UniqueId can be added as a class member to enhance any class with a unique identifier for each inst...Definition UniqueId.h:39; RooFit::UniqueId::valueconstexpr Value_t value() constReturn numerical value of ID.Definition UniqueId.h:59; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345; outputstatic void output(). roofitroofitcoresrcRooAbsReal.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:52 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:9973,Performance,cache,cache,9973," bool assumeSameType) const; 271{; 272 if (!assumeSameType) {; 273 const RooAbsReal* otherReal = dynamic_cast<const RooAbsReal*>(&other) ;; 274 return otherReal ? operator==(otherReal->getVal()) : false ;; 275 } else {; 276 return getVal() == static_cast<const RooAbsReal&>(other).getVal();; 277 }; 278}; 279 ; 280 ; 281////////////////////////////////////////////////////////////////////////////////; 282/// Return this variable's title string. If appendUnit is true and; 283/// this variable has units, also append a string "" (<unit>)"".; 284 ; 285TString RooAbsReal::getTitle(bool appendUnit) const; 286{; 287 if(appendUnit && 0 != strlen(getUnit())) {; 288 return std::string{GetTitle()} + "" ("" + getUnit() + "")"";; 289 }; 290 return GetTitle();; 291}; 292 ; 293 ; 294 ; 295////////////////////////////////////////////////////////////////////////////////; 296/// Return value of object. If the cache is clean, return the; 297/// cached value, otherwise recalculate on the fly and refill; 298/// the cache; 299 ; 300double RooAbsReal::getValV(const RooArgSet* nset) const; 301{; 302 if (nset && nset->uniqueId().value() != _lastNormSetId) {; 303 const_cast<RooAbsReal*>(this)->setProxyNormSet(nset);; 304 _lastNormSetId = nset->uniqueId().value();; 305 }; 306 ; 307 if (isValueDirtyAndClear()) {; 308 _value = traceEval(nullptr) ;; 309 // clearValueDirty() ;; 310 }; 311 ; 312 return hideOffset() ? _value + offset() : _value;; 313}; 314 ; 315 ; 316////////////////////////////////////////////////////////////////////////////////; 317/// Calculate current value of object, with error tracing wrapper; 318 ; 319double RooAbsReal::traceEval(const RooArgSet* /*nset*/) const; 320{; 321 double value = evaluate() ;; 322 ; 323 if (TMath::IsNaN(value)) {; 324 logEvalError(""function value is NAN"") ;; 325 }; 326 ; 327 //cxcoutD(Tracing) << ""RooAbsReal::getValF("" << GetName() << "") operMode = "" << _operMode << "" recalculated, new value = "" << value << std::endl ;; 328 ; 329 //Standard tracing code goes h",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:10008,Performance,cache,cached,10008," bool assumeSameType) const; 271{; 272 if (!assumeSameType) {; 273 const RooAbsReal* otherReal = dynamic_cast<const RooAbsReal*>(&other) ;; 274 return otherReal ? operator==(otherReal->getVal()) : false ;; 275 } else {; 276 return getVal() == static_cast<const RooAbsReal&>(other).getVal();; 277 }; 278}; 279 ; 280 ; 281////////////////////////////////////////////////////////////////////////////////; 282/// Return this variable's title string. If appendUnit is true and; 283/// this variable has units, also append a string "" (<unit>)"".; 284 ; 285TString RooAbsReal::getTitle(bool appendUnit) const; 286{; 287 if(appendUnit && 0 != strlen(getUnit())) {; 288 return std::string{GetTitle()} + "" ("" + getUnit() + "")"";; 289 }; 290 return GetTitle();; 291}; 292 ; 293 ; 294 ; 295////////////////////////////////////////////////////////////////////////////////; 296/// Return value of object. If the cache is clean, return the; 297/// cached value, otherwise recalculate on the fly and refill; 298/// the cache; 299 ; 300double RooAbsReal::getValV(const RooArgSet* nset) const; 301{; 302 if (nset && nset->uniqueId().value() != _lastNormSetId) {; 303 const_cast<RooAbsReal*>(this)->setProxyNormSet(nset);; 304 _lastNormSetId = nset->uniqueId().value();; 305 }; 306 ; 307 if (isValueDirtyAndClear()) {; 308 _value = traceEval(nullptr) ;; 309 // clearValueDirty() ;; 310 }; 311 ; 312 return hideOffset() ? _value + offset() : _value;; 313}; 314 ; 315 ; 316////////////////////////////////////////////////////////////////////////////////; 317/// Calculate current value of object, with error tracing wrapper; 318 ; 319double RooAbsReal::traceEval(const RooArgSet* /*nset*/) const; 320{; 321 double value = evaluate() ;; 322 ; 323 if (TMath::IsNaN(value)) {; 324 logEvalError(""function value is NAN"") ;; 325 }; 326 ; 327 //cxcoutD(Tracing) << ""RooAbsReal::getValF("" << GetName() << "") operMode = "" << _operMode << "" recalculated, new value = "" << value << std::endl ;; 328 ; 329 //Standard tracing code goes h",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:10078,Performance,cache,cache,10078," bool assumeSameType) const; 271{; 272 if (!assumeSameType) {; 273 const RooAbsReal* otherReal = dynamic_cast<const RooAbsReal*>(&other) ;; 274 return otherReal ? operator==(otherReal->getVal()) : false ;; 275 } else {; 276 return getVal() == static_cast<const RooAbsReal&>(other).getVal();; 277 }; 278}; 279 ; 280 ; 281////////////////////////////////////////////////////////////////////////////////; 282/// Return this variable's title string. If appendUnit is true and; 283/// this variable has units, also append a string "" (<unit>)"".; 284 ; 285TString RooAbsReal::getTitle(bool appendUnit) const; 286{; 287 if(appendUnit && 0 != strlen(getUnit())) {; 288 return std::string{GetTitle()} + "" ("" + getUnit() + "")"";; 289 }; 290 return GetTitle();; 291}; 292 ; 293 ; 294 ; 295////////////////////////////////////////////////////////////////////////////////; 296/// Return value of object. If the cache is clean, return the; 297/// cached value, otherwise recalculate on the fly and refill; 298/// the cache; 299 ; 300double RooAbsReal::getValV(const RooArgSet* nset) const; 301{; 302 if (nset && nset->uniqueId().value() != _lastNormSetId) {; 303 const_cast<RooAbsReal*>(this)->setProxyNormSet(nset);; 304 _lastNormSetId = nset->uniqueId().value();; 305 }; 306 ; 307 if (isValueDirtyAndClear()) {; 308 _value = traceEval(nullptr) ;; 309 // clearValueDirty() ;; 310 }; 311 ; 312 return hideOffset() ? _value + offset() : _value;; 313}; 314 ; 315 ; 316////////////////////////////////////////////////////////////////////////////////; 317/// Calculate current value of object, with error tracing wrapper; 318 ; 319double RooAbsReal::traceEval(const RooArgSet* /*nset*/) const; 320{; 321 double value = evaluate() ;; 322 ; 323 if (TMath::IsNaN(value)) {; 324 logEvalError(""function value is NAN"") ;; 325 }; 326 ; 327 //cxcoutD(Tracing) << ""RooAbsReal::getValF("" << GetName() << "") operMode = "" << _operMode << "" recalculated, new value = "" << value << std::endl ;; 328 ; 329 //Standard tracing code goes h",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:12660,Performance,perform,performed,12660,"s useful to overload this function rather; 347/// than analyticalIntegralWN() as the additional normalization information; 348/// may be useful in determining a more efficient decomposition of the; 349/// requested integral.; 350 ; 351Int_t RooAbsReal::getAnalyticalIntegralWN(RooArgSet& allDeps, RooArgSet& analDeps,; 352 const RooArgSet* /*normSet*/, const char* rangeName) const; 353{; 354 return _forceNumInt ? 0 : getAnalyticalIntegral(allDeps,analDeps,rangeName) ;; 355}; 356 ; 357 ; 358 ; 359////////////////////////////////////////////////////////////////////////////////; 360/// Interface function getAnalyticalIntergral advertises the; 361/// analytical integrals that are supported. 'integSet'; 362/// is the set of dependents for which integration is requested. The; 363/// function should copy the subset of dependents it can analytically; 364/// integrate to anaIntSet and return a unique identification code for; 365/// this integration configuration. If no integration can be; 366/// performed, zero should be returned.; 367 ; 368Int_t RooAbsReal::getAnalyticalIntegral(RooArgSet& /*integSet*/, RooArgSet& /*anaIntSet*/, const char* /*rangeName*/) const; 369{; 370 return 0 ;; 371}; 372 ; 373 ; 374 ; 375////////////////////////////////////////////////////////////////////////////////; 376/// Implements the actual analytical integral(s) advertised by; 377/// getAnalyticalIntegral. This functions will only be called with; 378/// codes returned by getAnalyticalIntegral, except code zero.; 379 ; 380double RooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName) const; 381{; 382// cout << ""RooAbsReal::analyticalIntegralWN("" << GetName() << "") code = "" << code << "" normSet = "" << (normSet?*normSet:RooArgSet()) << std::endl ;; 383 if (code==0) return getVal(normSet) ;; 384 return analyticalIntegral(code,rangeName) ;; 385}; 386 ; 387 ; 388 ; 389////////////////////////////////////////////////////////////////////////////////; 390/// Implements",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:17337,Performance,perform,performed,17337,"n except the stated paramsOfInterest; 470 ; 471RooFit::OwningPtr<RooAbsReal> RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); 472{; 473 // Construct name of profile object; 474 auto name = std::string(GetName()) + ""_Profile["";; 475 bool first = true;; 476 for (auto const& arg : paramsOfInterest) {; 477 if (first) {; 478 first = false ;; 479 } else {; 480 name.append("","") ;; 481 }; 482 name.append(arg->GetName()) ;; 483 }; 484 name.append(""]"") ;; 485 ; 486 // Create and return profile object; 487 auto out = std::make_unique<RooProfileLL>(name.c_str(),(std::string(""Profile of "") + GetTitle()).c_str(),*this,paramsOfInterest);; 488 return RooFit::makeOwningPtr<RooAbsReal>(std::move(out));; 489}; 490 ; 491 ; 492 ; 493 ; 494 ; 495 ; 496////////////////////////////////////////////////////////////////////////////////; 497/// Create an object that represents the integral of the function over one or more observables listed in `iset`.; 498/// The actual integration calculation is only performed when the returned object is evaluated. The name; 499/// of the integral object is automatically constructed from the name of the input function, the variables; 500/// it integrates and the range integrates over.; 501///; 502/// \note The integral over a PDF is usually not normalised (*i.e.*, it is usually not; 503/// 1 when integrating the PDF over the full range). In fact, this integral is used *to compute*; 504/// the normalisation of each PDF. See the [rf110 tutorial](group__tutorial__roofit.html); 505/// for details on PDF normalisation.; 506///; 507/// The following named arguments are accepted; 508/// | | Effect on integral creation; 509/// |--|-------------------------------; 510/// | `NormSet(const RooArgSet&)` | Specify normalization set, mostly useful when working with PDFs; 511/// | `NumIntConfig(const RooNumIntConfig&)` | Use given configuration for any numeric integration, if necessary; 512/// | `Range(const char* name)` | Integrate only over given range. Multi",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:19789,Performance,perform,performed,19789,"gral("" + std::string(GetName()) + "")"");; 520 pc.defineString(""rangeName"",""RangeWithName"",0,"""",true) ;; 521 pc.defineSet(""normSet"",""NormSet"",0,nullptr) ;; 522 pc.defineObject(""numIntConfig"",""NumIntConfig"",0,nullptr) ;; 523 ; 524 // Process & check varargs; 525 pc.process(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8) ;; 526 if (!pc.ok(true)) {; 527 return nullptr;; 528 }; 529 ; 530 // Extract values from named arguments; 531 const char* rangeName = pc.getString(""rangeName"",nullptr,true) ;; 532 const RooArgSet* nset = pc.getSet(""normSet"",nullptr);; 533 const RooNumIntConfig* cfg = static_cast<const RooNumIntConfig*>(pc.getObject(""numIntConfig"",nullptr)) ;; 534 ; 535 return createIntegral(iset,nset,cfg,rangeName) ;; 536}; 537 ; 538 ; 539 ; 540 ; 541 ; 542////////////////////////////////////////////////////////////////////////////////; 543/// Create an object that represents the integral of the function over one or more observables listed in iset.; 544/// The actual integration calculation is only performed when the return object is evaluated. The name; 545/// of the integral object is automatically constructed from the name of the input function, the variables; 546/// it integrates and the range integrates over. If nset is specified the integrand is request; 547/// to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; 548/// the integral is performed over the named range, otherwise it is performed over the domain of each; 549/// integrated observable. If cfg is specified it will be used to configure any numeric integration; 550/// aspect of the integral. It will not force the integral to be performed numerically, which is; 551/// decided automatically by RooRealIntegral.; 552 ; 553RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset,; 554 const RooNumIntConfig* cfg, const char* rangeName) const; 555{; 556 if (!rangeName || strchr(rangeName,',')==nullptr) {; 557 // Simple case: int",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:20187,Performance,perform,performed,20187,"r* rangeName = pc.getString(""rangeName"",nullptr,true) ;; 532 const RooArgSet* nset = pc.getSet(""normSet"",nullptr);; 533 const RooNumIntConfig* cfg = static_cast<const RooNumIntConfig*>(pc.getObject(""numIntConfig"",nullptr)) ;; 534 ; 535 return createIntegral(iset,nset,cfg,rangeName) ;; 536}; 537 ; 538 ; 539 ; 540 ; 541 ; 542////////////////////////////////////////////////////////////////////////////////; 543/// Create an object that represents the integral of the function over one or more observables listed in iset.; 544/// The actual integration calculation is only performed when the return object is evaluated. The name; 545/// of the integral object is automatically constructed from the name of the input function, the variables; 546/// it integrates and the range integrates over. If nset is specified the integrand is request; 547/// to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; 548/// the integral is performed over the named range, otherwise it is performed over the domain of each; 549/// integrated observable. If cfg is specified it will be used to configure any numeric integration; 550/// aspect of the integral. It will not force the integral to be performed numerically, which is; 551/// decided automatically by RooRealIntegral.; 552 ; 553RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset,; 554 const RooNumIntConfig* cfg, const char* rangeName) const; 555{; 556 if (!rangeName || strchr(rangeName,',')==nullptr) {; 557 // Simple case: integral over full range or single limited range; 558 return createIntObj(iset,nset,cfg,rangeName);; 559 }; 560 ; 561 // Integral over multiple ranges; 562 std::vector<std::string> tokens = ROOT::Split(rangeName, "","");; 563 ; 564 if(RooHelpers::checkIfRangesOverlap(iset, tokens)) {; 565 std::stringstream errMsg;; 566 errMsg << GetName() << "" : integrating with respect to the variables "" << iset << "" on the ranges \"""" << rangeName; ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:20235,Performance,perform,performed,20235,"r* rangeName = pc.getString(""rangeName"",nullptr,true) ;; 532 const RooArgSet* nset = pc.getSet(""normSet"",nullptr);; 533 const RooNumIntConfig* cfg = static_cast<const RooNumIntConfig*>(pc.getObject(""numIntConfig"",nullptr)) ;; 534 ; 535 return createIntegral(iset,nset,cfg,rangeName) ;; 536}; 537 ; 538 ; 539 ; 540 ; 541 ; 542////////////////////////////////////////////////////////////////////////////////; 543/// Create an object that represents the integral of the function over one or more observables listed in iset.; 544/// The actual integration calculation is only performed when the return object is evaluated. The name; 545/// of the integral object is automatically constructed from the name of the input function, the variables; 546/// it integrates and the range integrates over. If nset is specified the integrand is request; 547/// to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; 548/// the integral is performed over the named range, otherwise it is performed over the domain of each; 549/// integrated observable. If cfg is specified it will be used to configure any numeric integration; 550/// aspect of the integral. It will not force the integral to be performed numerically, which is; 551/// decided automatically by RooRealIntegral.; 552 ; 553RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset,; 554 const RooNumIntConfig* cfg, const char* rangeName) const; 555{; 556 if (!rangeName || strchr(rangeName,',')==nullptr) {; 557 // Simple case: integral over full range or single limited range; 558 return createIntObj(iset,nset,cfg,rangeName);; 559 }; 560 ; 561 // Integral over multiple ranges; 562 std::vector<std::string> tokens = ROOT::Split(rangeName, "","");; 563 ; 564 if(RooHelpers::checkIfRangesOverlap(iset, tokens)) {; 565 std::stringstream errMsg;; 566 errMsg << GetName() << "" : integrating with respect to the variables "" << iset << "" on the ranges \"""" << rangeName; ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:20442,Performance,perform,performed,20442,"ateIntegral(iset,nset,cfg,rangeName) ;; 536}; 537 ; 538 ; 539 ; 540 ; 541 ; 542////////////////////////////////////////////////////////////////////////////////; 543/// Create an object that represents the integral of the function over one or more observables listed in iset.; 544/// The actual integration calculation is only performed when the return object is evaluated. The name; 545/// of the integral object is automatically constructed from the name of the input function, the variables; 546/// it integrates and the range integrates over. If nset is specified the integrand is request; 547/// to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; 548/// the integral is performed over the named range, otherwise it is performed over the domain of each; 549/// integrated observable. If cfg is specified it will be used to configure any numeric integration; 550/// aspect of the integral. It will not force the integral to be performed numerically, which is; 551/// decided automatically by RooRealIntegral.; 552 ; 553RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset,; 554 const RooNumIntConfig* cfg, const char* rangeName) const; 555{; 556 if (!rangeName || strchr(rangeName,',')==nullptr) {; 557 // Simple case: integral over full range or single limited range; 558 return createIntObj(iset,nset,cfg,rangeName);; 559 }; 560 ; 561 // Integral over multiple ranges; 562 std::vector<std::string> tokens = ROOT::Split(rangeName, "","");; 563 ; 564 if(RooHelpers::checkIfRangesOverlap(iset, tokens)) {; 565 std::stringstream errMsg;; 566 errMsg << GetName() << "" : integrating with respect to the variables "" << iset << "" on the ranges \"""" << rangeName; 567 << ""\"" is not possible because the ranges are overlapping"";; 568 const std::string errMsgString = errMsg.str();; 569 coutE(Integration) << errMsgString << std::endl;; 570 throw std::invalid_argument(errMsgString);; 571 }; 572 ; 573 RooArgSet ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:25384,Performance,cache,cache,25384,"d::move(innerIntegral));; 640 }; 641 ; 642 // Remove already integrated observables from to-do list; 643 iset.remove(innerSet) ;; 644 ; 645 // Send info message on recursion if needed; 646 if (integrand == this && !iset.empty()) {; 647 coutI(Integration) << GetName() << "" : multidimensional integration over observables with parameterized ranges in terms of other integrated observables detected, using recursive integration strategy to construct final integral"" << std::endl ;; 648 }; 649 ; 650 // Prepare for recursion, next integral should integrate last integrand; 651 integrand = integral.get();; 652 ; 653 ; 654 // Only need normalization set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::mov",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:25450,Performance,cache,cacheParamsStr,25450,"d::move(innerIntegral));; 640 }; 641 ; 642 // Remove already integrated observables from to-do list; 643 iset.remove(innerSet) ;; 644 ; 645 // Send info message on recursion if needed; 646 if (integrand == this && !iset.empty()) {; 647 coutI(Integration) << GetName() << "" : multidimensional integration over observables with parameterized ranges in terms of other integrated observables detected, using recursive integration strategy to construct final integral"" << std::endl ;; 648 }; 649 ; 650 // Prepare for recursion, next integral should integrate last integrand; 651 integrand = integral.get();; 652 ; 653 ; 654 // Only need normalization set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::mov",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:25514,Performance,cache,cacheParamsStr,25514,"d::move(innerIntegral));; 640 }; 641 ; 642 // Remove already integrated observables from to-do list; 643 iset.remove(innerSet) ;; 644 ; 645 // Send info message on recursion if needed; 646 if (integrand == this && !iset.empty()) {; 647 coutI(Integration) << GetName() << "" : multidimensional integration over observables with parameterized ranges in terms of other integrated observables detected, using recursive integration strategy to construct final integral"" << std::endl ;; 648 }; 649 ; 650 // Prepare for recursion, next integral should integrate last integrand; 651 integrand = integral.get();; 652 ; 653 ; 654 // Only need normalization set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::mov",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:25539,Performance,cache,cacheParamsStr,25539,"d::move(innerIntegral));; 640 }; 641 ; 642 // Remove already integrated observables from to-do list; 643 iset.remove(innerSet) ;; 644 ; 645 // Send info message on recursion if needed; 646 if (integrand == this && !iset.empty()) {; 647 coutI(Integration) << GetName() << "" : multidimensional integration over observables with parameterized ranges in terms of other integrated observables detected, using recursive integration strategy to construct final integral"" << std::endl ;; 648 }; 649 ; 650 // Prepare for recursion, next integral should integrate last integrand; 651 integrand = integral.get();; 652 ; 653 ; 654 // Only need normalization set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::mov",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:25654,Performance,cache,cacheParams,25654,"d::move(innerIntegral));; 640 }; 641 ; 642 // Remove already integrated observables from to-do list; 643 iset.remove(innerSet) ;; 644 ; 645 // Send info message on recursion if needed; 646 if (integrand == this && !iset.empty()) {; 647 coutI(Integration) << GetName() << "" : multidimensional integration over observables with parameterized ranges in terms of other integrated observables detected, using recursive integration strategy to construct final integral"" << std::endl ;; 648 }; 649 ; 650 // Prepare for recursion, next integral should integrate last integrand; 651 integrand = integral.get();; 652 ; 653 ; 654 // Only need normalization set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::mov",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:25709,Performance,cache,cacheParamsStr,25709,"d::move(innerIntegral));; 640 }; 641 ; 642 // Remove already integrated observables from to-do list; 643 iset.remove(innerSet) ;; 644 ; 645 // Send info message on recursion if needed; 646 if (integrand == this && !iset.empty()) {; 647 coutI(Integration) << GetName() << "" : multidimensional integration over observables with parameterized ranges in terms of other integrated observables detected, using recursive integration strategy to construct final integral"" << std::endl ;; 648 }; 649 ; 650 // Prepare for recursion, next integral should integrate last integrand; 651 integrand = integral.get();; 652 ; 653 ; 654 // Only need normalization set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::mov",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:25742,Performance,cache,cacheParams,25742,"d::move(innerIntegral));; 640 }; 641 ; 642 // Remove already integrated observables from to-do list; 643 iset.remove(innerSet) ;; 644 ; 645 // Send info message on recursion if needed; 646 if (integrand == this && !iset.empty()) {; 647 coutI(Integration) << GetName() << "" : multidimensional integration over observables with parameterized ranges in terms of other integrated observables detected, using recursive integration strategy to construct final integral"" << std::endl ;; 648 }; 649 ; 650 // Prepare for recursion, next integral should integrate last integrand; 651 integrand = integral.get();; 652 ; 653 ; 654 // Only need normalization set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::mov",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:25861,Performance,cache,cacheParams,25861,"<< std::endl ;; 648 }; 649 ; 650 // Prepare for recursion, next integral should integrate last integrand; 651 integrand = integral.get();; 652 ; 653 ; 654 // Only need normalization set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::move(integral));; 679 cachedIntegral->setCacheSource(true) ;; 680 if (integral->operMode()==ADirty) {; 681 cachedIntegral->setOperMode(ADirty) ;; 682 }; 683 //cachedIntegral->disableCache(true) ;; 684 return RooFit::makeOwningPtr<RooAbsReal>(std::move(cachedIntegral));; 685 }; 686 }; 687 ; 688 return RooFit::makeOwningPtr(std::move(integral));; 689}; 690 ; 691 ; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Utili",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:25900,Performance,cache,cache,25900," set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::move(integral));; 679 cachedIntegral->setCacheSource(true) ;; 680 if (integral->operMode()==ADirty) {; 681 cachedIntegral->setOperMode(ADirty) ;; 682 }; 683 //cachedIntegral->disableCache(true) ;; 684 return RooFit::makeOwningPtr<RooAbsReal>(std::move(cachedIntegral));; 685 }; 686 }; 687 ; 688 return RooFit::makeOwningPtr(std::move(integral));; 689}; 690 ; 691 ; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// fi",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:25962,Performance,cache,cacheParams,25962," set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::move(integral));; 679 cachedIntegral->setCacheSource(true) ;; 680 if (integral->operMode()==ADirty) {; 681 cachedIntegral->setOperMode(ADirty) ;; 682 }; 683 //cachedIntegral->disableCache(true) ;; 684 return RooFit::makeOwningPtr<RooAbsReal>(std::move(cachedIntegral));; 685 }; 686 }; 687 ; 688 return RooFit::makeOwningPtr(std::move(integral));; 689}; 690 ; 691 ; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// fi",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:26104,Performance,cache,cacheParams,26104," set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::move(integral));; 679 cachedIntegral->setCacheSource(true) ;; 680 if (integral->operMode()==ADirty) {; 681 cachedIntegral->setOperMode(ADirty) ;; 682 }; 683 //cachedIntegral->disableCache(true) ;; 684 return RooFit::makeOwningPtr<RooAbsReal>(std::move(cachedIntegral));; 685 }; 686 }; 687 ; 688 return RooFit::makeOwningPtr(std::move(integral));; 689}; 690 ; 691 ; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// fi",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:26154,Performance,cache,cachedIntegral,26154,"vables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::move(integral));; 679 cachedIntegral->setCacheSource(true) ;; 680 if (integral->operMode()==ADirty) {; 681 cachedIntegral->setOperMode(ADirty) ;; 682 }; 683 //cachedIntegral->disableCache(true) ;; 684 return RooFit::makeOwningPtr<RooAbsReal>(std::move(cachedIntegral));; 685 }; 686 }; 687 ; 688 return RooFit::makeOwningPtr(std::move(integral));; 689}; 690 ; 691 ; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:26239,Performance,cache,cacheParams,26239," intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::move(integral));; 679 cachedIntegral->setCacheSource(true) ;; 680 if (integral->operMode()==ADirty) {; 681 cachedIntegral->setOperMode(ADirty) ;; 682 }; 683 //cachedIntegral->disableCache(true) ;; 684 return RooFit::makeOwningPtr<RooAbsReal>(std::move(cachedIntegral));; 685 }; 686 }; 687 ; 688 return RooFit::makeOwningPtr(std::move(integral));; 689}; 690 ; 691 ; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ra",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:26258,Performance,cache,cachedIntegral,26258," intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::move(integral));; 679 cachedIntegral->setCacheSource(true) ;; 680 if (integral->operMode()==ADirty) {; 681 cachedIntegral->setOperMode(ADirty) ;; 682 }; 683 //cachedIntegral->disableCache(true) ;; 684 return RooFit::makeOwningPtr<RooAbsReal>(std::move(cachedIntegral));; 685 }; 686 }; 687 ; 688 return RooFit::makeOwningPtr(std::move(integral));; 689}; 690 ; 691 ; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ra",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:26306,Performance,cache,cachedIntegral,26306," intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::move(integral));; 679 cachedIntegral->setCacheSource(true) ;; 680 if (integral->operMode()==ADirty) {; 681 cachedIntegral->setOperMode(ADirty) ;; 682 }; 683 //cachedIntegral->disableCache(true) ;; 684 return RooFit::makeOwningPtr<RooAbsReal>(std::move(cachedIntegral));; 685 }; 686 }; 687 ; 688 return RooFit::makeOwningPtr(std::move(integral));; 689}; 690 ; 691 ; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ra",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:26368,Performance,cache,cachedIntegral,26368," intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::move(integral));; 679 cachedIntegral->setCacheSource(true) ;; 680 if (integral->operMode()==ADirty) {; 681 cachedIntegral->setOperMode(ADirty) ;; 682 }; 683 //cachedIntegral->disableCache(true) ;; 684 return RooFit::makeOwningPtr<RooAbsReal>(std::move(cachedIntegral));; 685 }; 686 }; 687 ; 688 return RooFit::makeOwningPtr(std::move(integral));; 689}; 690 ; 691 ; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ra",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:26453,Performance,cache,cachedIntegral,26453," intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::move(integral));; 679 cachedIntegral->setCacheSource(true) ;; 680 if (integral->operMode()==ADirty) {; 681 cachedIntegral->setOperMode(ADirty) ;; 682 }; 683 //cachedIntegral->disableCache(true) ;; 684 return RooFit::makeOwningPtr<RooAbsReal>(std::move(cachedIntegral));; 685 }; 686 }; 687 ; 688 return RooFit::makeOwningPtr(std::move(integral));; 689}; 690 ; 691 ; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ra",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:26505,Performance,cache,cachedIntegral,26505," intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::move(integral));; 679 cachedIntegral->setCacheSource(true) ;; 680 if (integral->operMode()==ADirty) {; 681 cachedIntegral->setOperMode(ADirty) ;; 682 }; 683 //cachedIntegral->disableCache(true) ;; 684 return RooFit::makeOwningPtr<RooAbsReal>(std::move(cachedIntegral));; 685 }; 686 }; 687 ; 688 return RooFit::makeOwningPtr(std::move(integral));; 689}; 690 ; 691 ; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ra",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:26598,Performance,cache,cachedIntegral,26598," intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::move(integral));; 679 cachedIntegral->setCacheSource(true) ;; 680 if (integral->operMode()==ADirty) {; 681 cachedIntegral->setOperMode(ADirty) ;; 682 }; 683 //cachedIntegral->disableCache(true) ;; 684 return RooFit::makeOwningPtr<RooAbsReal>(std::move(cachedIntegral));; 685 }; 686 }; 687 ; 688 return RooFit::makeOwningPtr(std::move(integral));; 689}; 690 ; 691 ; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Utility function for createIntObj() that aids in the construct of recursive integrals; 695/// over functions with multiple observables with parameterized ranges. This function; 696/// finds in a given set allObs over which integration is requested the largeset subset; 697/// of observables that can be integrated simultaneously. This subset consists of; 698/// observables with fixed ranges and observables with parameterized ranges whose; 699/// parameterization does not depend on any observable that is also integrated.; 700 ; 701void RooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; 702{; 703 // Make lists of; 704 // a) integrated observables with fixed ranges,; 705 // b) integrated observables with parameterized ra",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:44943,Performance,perform,performed,44943,"l() ;; 1082 if (hdim==3) ccoutW(Plotting) << "" [z]="" << zvar->getVal() ;; 1083 ccoutW(Plotting) << std::endl ;; 1084 // RooAbsReal::printEvalErrors(ccoutW(Plotting),10) ;; 1085 result = 0 ;; 1086 }; 1087 RooAbsReal::clearEvalErrorLog() ;; 1088 ; 1089 hist->SetBinContent(hist->GetBin(xbin,ybin,zbin),result);; 1090 if (setError) {; 1091 hist->SetBinError(hist->GetBin(xbin,ybin,zbin),sqrt(result)) ;; 1092 }; 1093 ; 1094 //cout << ""bin "" << bin << "" -> ("" << xbin << "","" << ybin << "","" << zbin << "") = "" << result << std::endl;; 1095 }; 1096 RooAbsReal::setEvalErrorLoggingMode(RooAbsReal::PrintErrors) ;; 1097 ; 1098 // cleanup; 1099 delete cloneSet;; 1100 ; 1101 return hist;; 1102}; 1103 ; 1104 ; 1105 ; 1106////////////////////////////////////////////////////////////////////////////////; 1107/// Fill a RooDataHist with values sampled from this function at the; 1108/// bin centers. If extendedMode is true, the p.d.f. values is multiplied; 1109/// by the number of expected events in each bin; 1110///; 1111/// An optional scaling by a given scaleFactor can be performed.; 1112/// Returns a pointer to the input RooDataHist, or zero; 1113/// in case of an error.; 1114///; 1115/// If correctForBinSize is true the RooDataHist; 1116/// is filled with the functions density (function value times the; 1117/// bin volume) rather than function value.; 1118///; 1119/// If showProgress is true; 1120/// a process indicator is printed on stdout in steps of one percent,; 1121/// which is mostly useful for the sampling of expensive functions; 1122/// such as likelihoods; 1123 ; 1124RooDataHist* RooAbsReal::fillDataHist(RooDataHist *hist, const RooArgSet* normSet, double scaleFactor,; 1125 bool correctForBinSize, bool showProgress) const; 1126{; 1127 // Do we have a valid histogram to use?; 1128 if(nullptr == hist) {; 1129 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillDataHist: no valid RooDataHist to fill"" << std::endl;; 1130 return nullptr;; 1131 }; 1132 ; 1133 // Call ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:61878,Performance,perform,performed,61878," = selNodes->find(arg->GetName()) != nullptr;; 1488 static_cast<RooAbsReal*>(arg)->selectComp(select);; 1489 }; 1490}; 1491 ; 1492 ; 1493 ; 1494////////////////////////////////////////////////////////////////////////////////; 1495/// Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; 1496/// will show a unit normalized curve in the frame variable, taken at the present value; 1497/// of other observables defined for this PDF.; 1498///; 1499/// \param[in] frame pointer to RooPlot; 1500/// \param[in] arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10 Ordered arguments; 1501///; 1502/// If a PDF is plotted in a frame in which a dataset has already been plotted, it will; 1503/// show a projected curve integrated over all variables that were present in the shown; 1504/// dataset except for the one on the x-axis. The normalization of the curve will also; 1505/// be adjusted to the event count of the plotted dataset. An informational message; 1506/// will be printed for each projection step that is performed.; 1507///; 1508/// This function takes the following named arguments; 1509/// <table>; 1510/// <tr><th><th> Projection control; 1511/// <tr><td> `Slice(const RooArgSet& set)` <td> Override default projection behaviour by omitting observables listed; 1512/// in set from the projection, i.e. by not integrating over these.; 1513/// Slicing is usually only sensible in discrete observables, by e.g. creating a slice; 1514/// of the PDF at the current value of the category observable.; 1515///; 1516/// <tr><td> `Slice(RooCategory& cat, const char* label)` <td> Override default projection behaviour by omitting the specified category; 1517/// observable from the projection, i.e., by not integrating over all states of this category.; 1518/// The slice is positioned at the given label value. To pass multiple Slice() commands, please use the; 1519/// Slice(std::map<RooCategory*, std::string> const&) argument explained below.; 1520///; 1521/// <tr><td>",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:68909,Performance,perform,perform,68909,"nd points of curve; 1593///; 1594/// <tr><td> `Precision(double eps)` <td> Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision; 1595/// will result in more and more densely spaced curve points; 1596///; 1597/// <tr><td> `Invisible(bool flag)` <td> Add curve to frame, but do not display. Useful in combination AddTo(); 1598///; 1599/// <tr><td> `VisualizeError(const RooFitResult& fitres, double Z=1, bool linearMethod=true)`; 1600/// <td> Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma'. The linear method is fast but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much) longer to calculate; 1601///; 1602/// <tr><td> `VisualizeError(const RooFitResult& fitres, const RooArgSet& param, double Z=1, bool linearMethod=true)`; 1603/// <td> Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma'; 1604/// </table>; 1605///; 1606/// Details on error band visualization; 1607/// -----------------------------------; 1608/// *VisualizeError() uses plotOnWithErrorBand(). Documentation of the latter:*; 1609/// \see plotOnWithErrorBand(); 1610 ; 1611RooPlot* RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1, const RooCmdArg& arg2,; 1612 const RooCmdArg& arg3, const RooCmdArg& arg4,; 1613 const RooCmdArg& arg5, const RooCmdArg& arg6,; 1614 const RooCmdArg& arg7, const RooCmdArg& arg8,; 1615 const RooCmdArg& arg9, const RooCmdArg& arg10) const; 1616{; 1617 RooLinkedList l ;; 1618 l.Add((TObject*)&arg1) ; l.Add((TObject*)&arg2) ;; 1619 l.Add((TObject*)&arg3) ; l.Add((TObject*)&arg4) ;; 1620 l.Add((TObject*)&arg5) ; l.Add((TObject*)&arg6) ;; 1621 l.Add((TObject*)&arg7) ; l.Add((TObject*)&arg8) ;; 1622 l.Add((TObject*)&arg9) ; l.Add((TObject*)&arg10) ;; 1623 return plotO",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:82113,Performance,perform,performed,82113,"ret->getAttMarker()->SetMarkerColor(markerColor) ;; 1849 if (markerStyle!=-999) ret->getAttMarker()->SetMarkerStyle(markerStyle) ;; 1850 if (markerSize!=-999) ret->getAttMarker()->SetMarkerSize(markerSize) ;; 1851 ; 1852 if ((fillColor != -999 || fillStyle != -999) && !drawOpt.Contains(""F"")) {; 1853 coutW(Plotting) << ""Fill color or style was set for plotting \"""" << GetName(); 1854 << ""\"", but these only have an effect when 'DrawOption(\""F\"")' for fill is used at the same time."" << std::endl;; 1855 }; 1856 ; 1857 // Move last inserted object to back to drawing stack if requested; 1858 if (pc.getInt(""moveToBack"") && frame->numItems()>1) {; 1859 frame->drawBefore(frame->getObject(0)->GetName(), frame->getCurve()->GetName());; 1860 }; 1861 ; 1862 return ret ;; 1863}; 1864 ; 1865 ; 1866 ; 1867/// Plotting engine function for internal use; 1868///; 1869/// Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; 1870/// function that occur in the previously plotted dataset are projected via partial integration,; 1871/// otherwise no projections are performed. Optionally, certain projections can be performed; 1872/// by summing over the values present in a provided dataset ('projData'), to correctly; 1873/// project out data dependents that are not properly described by the PDF (e.g. per-event errors).; 1874///; 1875/// The functions value can be multiplied with an optional scale factor. The interpretation; 1876/// of the scale factor is unique for generic real functions, for PDFs there are various interpretations; 1877/// possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details).; 1878///; 1879/// The default projection behaviour can be overridden by supplying an optional set of dependents; 1880/// to project via RooFit command arguments.; 1881//_____________________________________________________________________________; 1882// coverity[PASS_BY_VALUE]; 1883RooPlot* RooAbsReal::plotOn(RooPlot *frame, PlotOpt ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:82163,Performance,perform,performed,82163,"2 if ((fillColor != -999 || fillStyle != -999) && !drawOpt.Contains(""F"")) {; 1853 coutW(Plotting) << ""Fill color or style was set for plotting \"""" << GetName(); 1854 << ""\"", but these only have an effect when 'DrawOption(\""F\"")' for fill is used at the same time."" << std::endl;; 1855 }; 1856 ; 1857 // Move last inserted object to back to drawing stack if requested; 1858 if (pc.getInt(""moveToBack"") && frame->numItems()>1) {; 1859 frame->drawBefore(frame->getObject(0)->GetName(), frame->getCurve()->GetName());; 1860 }; 1861 ; 1862 return ret ;; 1863}; 1864 ; 1865 ; 1866 ; 1867/// Plotting engine function for internal use; 1868///; 1869/// Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; 1870/// function that occur in the previously plotted dataset are projected via partial integration,; 1871/// otherwise no projections are performed. Optionally, certain projections can be performed; 1872/// by summing over the values present in a provided dataset ('projData'), to correctly; 1873/// project out data dependents that are not properly described by the PDF (e.g. per-event errors).; 1874///; 1875/// The functions value can be multiplied with an optional scale factor. The interpretation; 1876/// of the scale factor is unique for generic real functions, for PDFs there are various interpretations; 1877/// possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details).; 1878///; 1879/// The default projection behaviour can be overridden by supplying an optional set of dependents; 1880/// to project via RooFit command arguments.; 1881//_____________________________________________________________________________; 1882// coverity[PASS_BY_VALUE]; 1883RooPlot* RooAbsReal::plotOn(RooPlot *frame, PlotOpt o) const; 1884{; 1885 // Sanity checks; 1886 if (plotSanityChecks(frame)) return frame ;; 1887 ; 1888 // ProjDataVars is either all projData observables, or the user indicated subset of it; 1889 RooArgSet projDataVars ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:90662,Performance,perform,performing,90662,"ction dataset to entries with "" << cutString << std::endl ;; 2035 }; 2036 projDataSelOwned = std::unique_ptr<RooAbsData>{const_cast<RooAbsData*>(o.projData)->reduce(*projDataNeededVars, cutString.IsNull() ? nullptr : cutString)};; 2037 projDataSel = projDataSelOwned.get();; 2038 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2039 << "") only the following components of the projection data will be used: "" << *projDataNeededVars << std::endl ;; 2040 }; 2041 ; 2042 // Request binning of unbinned projection dataset that consists exclusively of category observables; 2043 if (!o.binProjData && dynamic_cast<RooDataSet*>(projDataSel)!=nullptr) {; 2044 ; 2045 // Determine if dataset contains only categories; 2046 bool allCat(true) ;; 2047 for(RooAbsArg * arg2 : *projDataSel->get()) {; 2048 if (!dynamic_cast<RooCategory*>(arg2)) allCat = false ;; 2049 }; 2050 if (allCat) {; 2051 o.binProjData = true ;; 2052 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") unbinned projection dataset consist only of discrete variables,""; 2053 << "" performing projection with binned copy for optimization."" << std::endl ;; 2054 ; 2055 }; 2056 }; 2057 ; 2058 // Bin projection dataset if requested; 2059 if (o.binProjData) {; 2060 projDataSelOwned = std::make_unique<RooDataHist>(std::string(projDataSel->GetName()) + ""_binned"",""Binned projection data"",*projDataSel->get(),*projDataSel);; 2061 projDataSel = projDataSelOwned.get();; 2062 }; 2063 ; 2064 // Construct scaled data weighted average; 2065 ScaledDataWeightedAverage scaleBind{*projection, *projDataSel, o.scaleFactor, *plotVar};; 2066 ; 2067 // Set default range, if not specified; 2068 if (o.rangeLo==0 && o.rangeHi==0) {; 2069 o.rangeLo = frame->GetXaxis()->GetXmin() ;; 2070 o.rangeHi = frame->GetXaxis()->GetXmax() ;; 2071 }; 2072 ; 2073 // Construct name of curve for data weighed average; 2074 std::string curveName(projection->GetName()) ;; 2075 curveName.append(""_DataAvg["" + projDataSel->get()->contentsString() + ""]"");; 2076 /",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:90705,Performance,optimiz,optimization,90705,"ction dataset to entries with "" << cutString << std::endl ;; 2035 }; 2036 projDataSelOwned = std::unique_ptr<RooAbsData>{const_cast<RooAbsData*>(o.projData)->reduce(*projDataNeededVars, cutString.IsNull() ? nullptr : cutString)};; 2037 projDataSel = projDataSelOwned.get();; 2038 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2039 << "") only the following components of the projection data will be used: "" << *projDataNeededVars << std::endl ;; 2040 }; 2041 ; 2042 // Request binning of unbinned projection dataset that consists exclusively of category observables; 2043 if (!o.binProjData && dynamic_cast<RooDataSet*>(projDataSel)!=nullptr) {; 2044 ; 2045 // Determine if dataset contains only categories; 2046 bool allCat(true) ;; 2047 for(RooAbsArg * arg2 : *projDataSel->get()) {; 2048 if (!dynamic_cast<RooCategory*>(arg2)) allCat = false ;; 2049 }; 2050 if (allCat) {; 2051 o.binProjData = true ;; 2052 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") unbinned projection dataset consist only of discrete variables,""; 2053 << "" performing projection with binned copy for optimization."" << std::endl ;; 2054 ; 2055 }; 2056 }; 2057 ; 2058 // Bin projection dataset if requested; 2059 if (o.binProjData) {; 2060 projDataSelOwned = std::make_unique<RooDataHist>(std::string(projDataSel->GetName()) + ""_binned"",""Binned projection data"",*projDataSel->get(),*projDataSel);; 2061 projDataSel = projDataSelOwned.get();; 2062 }; 2063 ; 2064 // Construct scaled data weighted average; 2065 ScaledDataWeightedAverage scaleBind{*projection, *projDataSel, o.scaleFactor, *plotVar};; 2066 ; 2067 // Set default range, if not specified; 2068 if (o.rangeLo==0 && o.rangeHi==0) {; 2069 o.rangeLo = frame->GetXaxis()->GetXmin() ;; 2070 o.rangeHi = frame->GetXaxis()->GetXmax() ;; 2071 }; 2072 ; 2073 // Construct name of curve for data weighed average; 2074 std::string curveName(projection->GetName()) ;; 2075 curveName.append(""_DataAvg["" + projDataSel->get()->contentsString() + ""]"");; 2076 /",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:97335,Performance,perform,performed,97335," ; 2190 if (projDataNeededVars) delete projDataNeededVars ;; 2191 delete projectionCompList ;; 2192 plotVar->setVal(oldPlotVarVal); // reset the plot variable value to not disturb the original state; 2193 return frame;; 2194}; 2195 ; 2196 ; 2197//_____________________________________________________________________________; 2198// coverity[PASS_BY_VALUE]; 2199RooPlot* RooAbsReal::plotAsymOn(RooPlot *frame, const RooAbsCategoryLValue& asymCat, PlotOpt o) const; 2200 ; 2201{; 2202 // Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))); 2203 //; 2204 // Plot asymmetry of ourselves, defined as; 2205 //; 2206 // asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ); 2207 //; 2208 // on frame. If frame contains a histogram, all dimensions of the plotted; 2209 // asymmetry function that occur in the previously plotted dataset are projected via partial integration.; 2210 // Otherwise no projections are performed,; 2211 //; 2212 // The asymmetry function can be multiplied with an optional scale factor. The default projection; 2213 // behaviour can be overridden by supplying an optional set of dependents to project.; 2214 ; 2215 // Sanity checks; 2216 if (plotSanityChecks(frame)) return frame ;; 2217 ; 2218 // ProjDataVars is either all projData observables, or the user indicated subset of it; 2219 RooArgSet projDataVars ;; 2220 if (o.projData) {; 2221 if (o.projDataSet) {; 2222 std::unique_ptr<RooArgSet> tmp{o.projData->get()->selectCommon(*o.projDataSet)};; 2223 projDataVars.add(*tmp) ;; 2224 } else {; 2225 projDataVars.add(*o.projData->get()) ;; 2226 }; 2227 }; 2228 ; 2229 // Must depend on asymCat; 2230 if (!dependsOn(asymCat)) {; 2231 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2232 << "") function doesn't depend on asymmetry category "" << asymCat.GetName() << std::endl ;; 2233 return frame ;; 2234 }; 2235 ; 2236 // asymCat must be a signCat; 2237 if (!asymCat.isSignType()) {; 2238 coutE(Plotting)",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:114652,Performance,perform,perform,114652,"2590/// The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; 2591/// not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made; 2592///; 2593/// Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves; 2594/// is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; 2595/// from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; 2596/// for each value of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; 2597/// that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); 2598/// Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); 2599/// longer to calculate.; 2600 ; 2601RooPlot* RooAbsReal::plotOnWithErrorBand(RooPlot* frame,const RooFitResult& fr, double Z,const RooArgSet* params, const RooLinkedList& argList, bool linMethod) const; 2602{; 2603 RooLinkedList plotArgListTmp(argList) ;; 2604 RooCmdConfig::stripCmdList(plotArgListTmp,""VisualizeError,MoveToBack"") ;; 2605 ; 2606 // Strip any 'internal normalization' arguments from list; 2607 RooLinkedList plotArgList ;; 2608 for (auto * cmd : static_range_cast<RooCmdArg*>(plotArgListTmp)) {; 2609 if (std::string(""Normalization"")==cmd->GetName()) {; 2610 if (((RooCmdArg*)cmd)->getInt(1)!=0) {; 2611 } else {; 2612 plotArgList.Add(cmd) ;; 2613 }; 2614 } else {; 2615 plotArgList.Add(cmd) ;; 2616 }; 2617 }; 2618 ; 2619 // Function to plot a single curve, creating a copy of the plotArgList to; 2620 // pass as plot command arguments. The ""FillColor"" command is removed because; 2621 // it",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:124686,Performance,perform,perform,124686,"nserted object to back to drawing stack if requested; 2846 if (pc.getInt(""moveToBack"") && frame->numItems()>1) {; 2847 frame->drawBefore(frame->getObject(0)->GetName(), frame->getCurve()->GetName());; 2848 }; 2849 ; 2850 ; 2851 return frame ;; 2852}; 2853 ; 2854 ; 2855 ; 2856 ; 2857////////////////////////////////////////////////////////////////////////////////; 2858/// Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations; 2859 ; 2860bool RooAbsReal::plotSanityChecks(RooPlot* frame) const; 2861{; 2862 // check that we are passed a valid plot frame to use; 2863 if(nullptr == frame) {; 2864 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: frame is null"" << std::endl;; 2865 return true;; 2866 }; 2867 ; 2868 // check that this frame knows what variable to plot; 2869 RooAbsReal* var = frame->getPlotVar() ;; 2870 if(!var) {; 2871 coutE(Plotting) << ClassName() << ""::"" << GetName(); 2872 << "":plotOn: frame does not specify a plot variable"" << std::endl;; 2873 return true;; 2874 }; 2875 ; 2876 // check that the plot variable is not derived; 2877 if(!dynamic_cast<RooAbsRealLValue*>(var)) {; 2878 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: cannot plot variable \""""; 2879 << var->GetName() << ""\"" of type "" << var->ClassName() << std::endl;; 2880 return true;; 2881 }; 2882 ; 2883 // check if we actually depend on the plot variable; 2884 if(!this->dependsOn(*var)) {; 2885 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: WARNING: variable is not an explicit dependent: ""; 2886 << var->GetName() << std::endl;; 2887 }; 2888 ; 2889 return false ;; 2890}; 2891 ; 2892 ; 2893 ; 2894 ; 2895////////////////////////////////////////////////////////////////////////////////; 2896/// Utility function for plotOn() that constructs the set of; 2897/// observables to project when plotting ourselves as function of; 2898/// 'plotVar'. 'allVars' is the list of variables that must be; 2899/// projecte",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:129895,Performance,cache,cached,129895,"/////////////////////////; 2964/// Global switch controlling the activation of the selectComp() functionality; 2965 ; 2966void RooAbsReal::globalSelectComp(bool flag); 2967{; 2968 _globalSelectComp = flag ;; 2969}; 2970 ; 2971 ; 2972 ; 2973 ; 2974////////////////////////////////////////////////////////////////////////////////; 2975/// Create an interface adaptor f(vars) that binds us to the specified variables; 2976/// (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; 2977/// F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; 2978/// current values of x2 and x4. The caller takes ownership of the returned adaptor.; 2979 ; 2980RooFit::OwningPtr<RooAbsFunc> RooAbsReal::bindVars(const RooArgSet &vars, const RooArgSet* nset, bool clipInvalid) const; 2981{; 2982 auto binding = std::make_unique<RooRealBinding>(*this,vars,nset,clipInvalid);; 2983 if(!binding->isValid()) {; 2984 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":bindVars: cannot bind to "" << vars << std::endl ;; 2985 return nullptr;; 2986 }; 2987 return RooFit::makeOwningPtr(std::unique_ptr<RooAbsFunc>{std::move(binding)});; 2988}; 2989 ; 2990 ; 2991 ; 2992////////////////////////////////////////////////////////////////////////////////; 2993/// Copy the cached value of another RooAbsArg to our cache.; 2994/// Warning: This function just copies the cached values of source,; 2995/// it is the callers responsibility to make sure the cache is clean.; 2996 ; 2997void RooAbsReal::copyCache(const RooAbsArg* source, bool /*valueOnly*/, bool setValDirty); 2998{; 2999 auto other = static_cast<const RooAbsReal*>(source);; 3000 assert(dynamic_cast<const RooAbsReal*>(source));; 3001 ; 3002 _value = other->_treeReadBuffer ? other->_treeReadBuffer->operator double() : other->_value;; 3003 ; 3004 if (setValDirty) {; 3005 setValueDirty() ;; 3006 }; 3007}; 3008 ; 3009 ; 3010////////////////////////////////////////////////////////////////////////////////; 3011 ; 3012void",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:129936,Performance,cache,cache,129936,"/////////////////////////; 2964/// Global switch controlling the activation of the selectComp() functionality; 2965 ; 2966void RooAbsReal::globalSelectComp(bool flag); 2967{; 2968 _globalSelectComp = flag ;; 2969}; 2970 ; 2971 ; 2972 ; 2973 ; 2974////////////////////////////////////////////////////////////////////////////////; 2975/// Create an interface adaptor f(vars) that binds us to the specified variables; 2976/// (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; 2977/// F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; 2978/// current values of x2 and x4. The caller takes ownership of the returned adaptor.; 2979 ; 2980RooFit::OwningPtr<RooAbsFunc> RooAbsReal::bindVars(const RooArgSet &vars, const RooArgSet* nset, bool clipInvalid) const; 2981{; 2982 auto binding = std::make_unique<RooRealBinding>(*this,vars,nset,clipInvalid);; 2983 if(!binding->isValid()) {; 2984 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":bindVars: cannot bind to "" << vars << std::endl ;; 2985 return nullptr;; 2986 }; 2987 return RooFit::makeOwningPtr(std::unique_ptr<RooAbsFunc>{std::move(binding)});; 2988}; 2989 ; 2990 ; 2991 ; 2992////////////////////////////////////////////////////////////////////////////////; 2993/// Copy the cached value of another RooAbsArg to our cache.; 2994/// Warning: This function just copies the cached values of source,; 2995/// it is the callers responsibility to make sure the cache is clean.; 2996 ; 2997void RooAbsReal::copyCache(const RooAbsArg* source, bool /*valueOnly*/, bool setValDirty); 2998{; 2999 auto other = static_cast<const RooAbsReal*>(source);; 3000 assert(dynamic_cast<const RooAbsReal*>(source));; 3001 ; 3002 _value = other->_treeReadBuffer ? other->_treeReadBuffer->operator double() : other->_value;; 3003 ; 3004 if (setValDirty) {; 3005 setValueDirty() ;; 3006 }; 3007}; 3008 ; 3009 ; 3010////////////////////////////////////////////////////////////////////////////////; 3011 ; 3012void",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:129991,Performance,cache,cached,129991,"bles; 2976/// (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; 2977/// F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; 2978/// current values of x2 and x4. The caller takes ownership of the returned adaptor.; 2979 ; 2980RooFit::OwningPtr<RooAbsFunc> RooAbsReal::bindVars(const RooArgSet &vars, const RooArgSet* nset, bool clipInvalid) const; 2981{; 2982 auto binding = std::make_unique<RooRealBinding>(*this,vars,nset,clipInvalid);; 2983 if(!binding->isValid()) {; 2984 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":bindVars: cannot bind to "" << vars << std::endl ;; 2985 return nullptr;; 2986 }; 2987 return RooFit::makeOwningPtr(std::unique_ptr<RooAbsFunc>{std::move(binding)});; 2988}; 2989 ; 2990 ; 2991 ; 2992////////////////////////////////////////////////////////////////////////////////; 2993/// Copy the cached value of another RooAbsArg to our cache.; 2994/// Warning: This function just copies the cached values of source,; 2995/// it is the callers responsibility to make sure the cache is clean.; 2996 ; 2997void RooAbsReal::copyCache(const RooAbsArg* source, bool /*valueOnly*/, bool setValDirty); 2998{; 2999 auto other = static_cast<const RooAbsReal*>(source);; 3000 assert(dynamic_cast<const RooAbsReal*>(source));; 3001 ; 3002 _value = other->_treeReadBuffer ? other->_treeReadBuffer->operator double() : other->_value;; 3003 ; 3004 if (setValDirty) {; 3005 setValueDirty() ;; 3006 }; 3007}; 3008 ; 3009 ; 3010////////////////////////////////////////////////////////////////////////////////; 3011 ; 3012void RooAbsReal::attachToVStore(RooVectorDataStore& vstore); 3013{; 3014 vstore.addReal(this)->setBuffer(this,&_value);; 3015}; 3016 ; 3017 ; 3018////////////////////////////////////////////////////////////////////////////////; 3019/// Attach object to a branch of given TTree. By default it will; 3020/// register the internal value cache RooAbsReal::_value as branch; 3021/// buffer for a double tree branch wit",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:130075,Performance,cache,cache,130075,"bles; 2976/// (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; 2977/// F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; 2978/// current values of x2 and x4. The caller takes ownership of the returned adaptor.; 2979 ; 2980RooFit::OwningPtr<RooAbsFunc> RooAbsReal::bindVars(const RooArgSet &vars, const RooArgSet* nset, bool clipInvalid) const; 2981{; 2982 auto binding = std::make_unique<RooRealBinding>(*this,vars,nset,clipInvalid);; 2983 if(!binding->isValid()) {; 2984 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":bindVars: cannot bind to "" << vars << std::endl ;; 2985 return nullptr;; 2986 }; 2987 return RooFit::makeOwningPtr(std::unique_ptr<RooAbsFunc>{std::move(binding)});; 2988}; 2989 ; 2990 ; 2991 ; 2992////////////////////////////////////////////////////////////////////////////////; 2993/// Copy the cached value of another RooAbsArg to our cache.; 2994/// Warning: This function just copies the cached values of source,; 2995/// it is the callers responsibility to make sure the cache is clean.; 2996 ; 2997void RooAbsReal::copyCache(const RooAbsArg* source, bool /*valueOnly*/, bool setValDirty); 2998{; 2999 auto other = static_cast<const RooAbsReal*>(source);; 3000 assert(dynamic_cast<const RooAbsReal*>(source));; 3001 ; 3002 _value = other->_treeReadBuffer ? other->_treeReadBuffer->operator double() : other->_value;; 3003 ; 3004 if (setValDirty) {; 3005 setValueDirty() ;; 3006 }; 3007}; 3008 ; 3009 ; 3010////////////////////////////////////////////////////////////////////////////////; 3011 ; 3012void RooAbsReal::attachToVStore(RooVectorDataStore& vstore); 3013{; 3014 vstore.addReal(this)->setBuffer(this,&_value);; 3015}; 3016 ; 3017 ; 3018////////////////////////////////////////////////////////////////////////////////; 3019/// Attach object to a branch of given TTree. By default it will; 3020/// register the internal value cache RooAbsReal::_value as branch; 3021/// buffer for a double tree branch wit",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:130937,Performance,cache,cache,130937,"nction just copies the cached values of source,; 2995/// it is the callers responsibility to make sure the cache is clean.; 2996 ; 2997void RooAbsReal::copyCache(const RooAbsArg* source, bool /*valueOnly*/, bool setValDirty); 2998{; 2999 auto other = static_cast<const RooAbsReal*>(source);; 3000 assert(dynamic_cast<const RooAbsReal*>(source));; 3001 ; 3002 _value = other->_treeReadBuffer ? other->_treeReadBuffer->operator double() : other->_value;; 3003 ; 3004 if (setValDirty) {; 3005 setValueDirty() ;; 3006 }; 3007}; 3008 ; 3009 ; 3010////////////////////////////////////////////////////////////////////////////////; 3011 ; 3012void RooAbsReal::attachToVStore(RooVectorDataStore& vstore); 3013{; 3014 vstore.addReal(this)->setBuffer(this,&_value);; 3015}; 3016 ; 3017 ; 3018////////////////////////////////////////////////////////////////////////////////; 3019/// Attach object to a branch of given TTree. By default it will; 3020/// register the internal value cache RooAbsReal::_value as branch; 3021/// buffer for a double tree branch with the same name as this; 3022/// object. If no double branch is found with the name of this; 3023/// object, this method looks for a Float_t Int_t, UChar_t and UInt_t, etc; 3024/// branch. If any of these are found, a TreeReadBuffer; 3025/// that branch is created, and saved in _treeReadBuffer.; 3026/// TreeReadBuffer::operator double() can be used to convert the values.; 3027/// This is used by copyCache().; 3028void RooAbsReal::attachToTree(TTree& t, Int_t bufSize); 3029{; 3030 // First determine if branch is taken; 3031 TString cleanName(cleanBranchName()) ;; 3032 TBranch* branch = t.GetBranch(cleanName) ;; 3033 if (branch) {; 3034 ; 3035 // Determine if existing branch is Float_t or double; 3036 TLeaf* leaf = static_cast<TLeaf*>(branch->GetListOfLeaves()->At(0)) ;; 3037 ; 3038 // Check that leaf is _not_ an array; 3039 Int_t dummy ;; 3040 TLeaf* counterLeaf = leaf->GetLeafCounter(dummy) ;; 3041 if (counterLeaf) {; 3042 coutE(Eval) << ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:158682,Performance,perform,performed,158682," RooArgSet& obs, RooArgSet& orderedObs) const; 3695{; 3696 // Dummy implementation, do nothing; 3697 orderedObs.removeAll() ;; 3698 orderedObs.add(obs) ;; 3699}; 3700 ; 3701 ; 3702 ; 3703////////////////////////////////////////////////////////////////////////////////; 3704/// Calls createRunningIntegral(const RooArgSet&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&); 3705 ; 3706RooFit::OwningPtr<RooAbsReal> RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset); 3707{; 3708 return createRunningIntegral(iset,RooFit::SupNormSet(nset)) ;; 3709}; 3710 ; 3711 ; 3712 ; 3713////////////////////////////////////////////////////////////////////////////////; 3714/// Create an object that represents the running integral of the function over one or more observables listed in iset, i.e.; 3715/// \f[; 3716/// \int_{x_\mathrm{lo}}^x f(x') \, \mathrm{d}x'; 3717/// \f]; 3718///; 3719/// The actual integration calculation is only performed when the return object is evaluated. The name; 3720/// of the integral object is automatically constructed from the name of the input function, the variables; 3721/// it integrates and the range integrates over. The default strategy to calculate the running integrals is; 3722///; 3723/// - If the integrand (this object) supports analytical integration, construct an integral object; 3724/// that calculate the running integrals value by calculating the analytical integral each; 3725/// time the running integral object is evaluated; 3726///; 3727/// - If the integrand (this object) requires numeric integration to construct the running integral; 3728/// create an object of class RooNumRunningInt which first samples the entire function and integrates; 3729/// the sampled function numerically. This method has superior performance as there is no need to; 3730/// perform a full (numeric) integration for each evaluation of the running in",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:159516,Performance,perform,performance,159516,"thrm{d}x'; 3717/// \f]; 3718///; 3719/// The actual integration calculation is only performed when the return object is evaluated. The name; 3720/// of the integral object is automatically constructed from the name of the input function, the variables; 3721/// it integrates and the range integrates over. The default strategy to calculate the running integrals is; 3722///; 3723/// - If the integrand (this object) supports analytical integration, construct an integral object; 3724/// that calculate the running integrals value by calculating the analytical integral each; 3725/// time the running integral object is evaluated; 3726///; 3727/// - If the integrand (this object) requires numeric integration to construct the running integral; 3728/// create an object of class RooNumRunningInt which first samples the entire function and integrates; 3729/// the sampled function numerically. This method has superior performance as there is no need to; 3730/// perform a full (numeric) integration for each evaluation of the running integral object, but; 3731/// only when one of its parameters has changed.; 3732///; 3733/// The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; 3734/// scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); 3735/// argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; 3736/// granularity for the scanning technique can be controlled with the ScanParameters technique; 3737/// which allows to specify the number of samples to be taken, and to which order the resulting; 3738/// running integral should be interpolated. The default values are 1000 samples and 2nd order; 3739/// interpolation.; 3740///; 3741/// The following named arguments are accepted; 3742/// | | Effect on integral creation; 3743/// |-|-------------------------------; 3744/// | `SupNormSet(const RooArgSet&)` | Observables over which should be normalized _in additio",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:159560,Performance,perform,perform,159560,"thrm{d}x'; 3717/// \f]; 3718///; 3719/// The actual integration calculation is only performed when the return object is evaluated. The name; 3720/// of the integral object is automatically constructed from the name of the input function, the variables; 3721/// it integrates and the range integrates over. The default strategy to calculate the running integrals is; 3722///; 3723/// - If the integrand (this object) supports analytical integration, construct an integral object; 3724/// that calculate the running integrals value by calculating the analytical integral each; 3725/// time the running integral object is evaluated; 3726///; 3727/// - If the integrand (this object) requires numeric integration to construct the running integral; 3728/// create an object of class RooNumRunningInt which first samples the entire function and integrates; 3729/// the sampled function numerically. This method has superior performance as there is no need to; 3730/// perform a full (numeric) integration for each evaluation of the running integral object, but; 3731/// only when one of its parameters has changed.; 3732///; 3733/// The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; 3734/// scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); 3735/// argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; 3736/// granularity for the scanning technique can be controlled with the ScanParameters technique; 3737/// which allows to specify the number of samples to be taken, and to which order the resulting; 3738/// running integral should be interpolated. The default values are 1000 samples and 2nd order; 3739/// interpolation.; 3740///; 3741/// The following named arguments are accepted; 3742/// | | Effect on integral creation; 3743/// |-|-------------------------------; 3744/// | `SupNormSet(const RooArgSet&)` | Observables over which should be normalized _in additio",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:175151,Performance,perform,performed,175151,"RooRealVar& obs, const RooArgSet& normObs, Int_t order, bool central, bool takeRoot, bool intNormObs); 4035{; 4036 std::string name=Form(""%s_MOMENT_%d%s_%s"",GetName(),order,(central?""C"":""""),obs.GetName()) ;; 4037 std::string title=Form(""%sMoment of order %d of %s w.r.t %s "",(central?""Central "":""""),order,GetName(),obs.GetName()) ;; 4038 ; 4039 if (order==1) return new RooFirstMoment(name.c_str(),title.c_str(),*this,obs,normObs,intNormObs) ;; 4040 if (order==2) return new RooSecondMoment(name.c_str(),title.c_str(),*this,obs,normObs,central,takeRoot,intNormObs) ;; 4041 return new RooMoment(name.c_str(),title.c_str(),*this,obs,normObs,order,central,takeRoot,intNormObs) ;; 4042}; 4043 ; 4044 ; 4045 ; 4046////////////////////////////////////////////////////////////////////////////////; 4047///; 4048/// Return value of x (in range xmin,xmax) at which function equals yval.; 4049/// (Calculation is performed with Brent root finding algorithm); 4050 ; 4051double RooAbsReal::findRoot(RooRealVar& x, double xmin, double xmax, double yval); 4052{; 4053 double result(0) ;; 4054 RooBrentRootFinder(RooRealBinding(*this,x)).findRoot(result,xmin,xmax,yval) ;; 4055 return result ;; 4056}; 4057 ; 4058 ; 4059 ; 4060////////////////////////////////////////////////////////////////////////////////; 4061/// Perform a \f$ \chi^2 \f$ fit to given histogram. By default the fit is executed through the MINUIT; 4062/// commands MIGRAD, HESSE in succession; 4063///; 4064/// The following named arguments are supported; 4065///; 4066/// <table>; 4067/// <tr><th> <th> Options to control construction of chi2; 4068/// <tr><td> `Extended(bool flag)` <td> **Only applicable when fitting a RooAbsPdf**. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight.; 4069/// This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; 4070/// - If you don't pass this command, an extended fit will be done b",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:177490,Performance,optimiz,optimization,177490,"er of events will result in error messages,; 4073/// and the chi2 will fall back to the total data weight to scale the normalized pdf.; 4074/// - There are cases where the fit **must** be done in extended mode. This happens for example when you have a RooAddPdf; 4075/// where the coefficients represent component yields. If the fit is not extended, these coefficients will not be; 4076/// well-defined, as the RooAddPdf always normalizes itself. If you pass `Extended(false)` in such a case, an error will be; 4077/// printed and you'll most likely get garbage results.; 4078/// <tr><td> `Range(const char* name)` <td> Fit only data inside range with given name; 4079/// <tr><td> `Range(double lo, double hi)` <td> Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; 4080/// Multiple comma separated range names can be specified.; 4081/// <tr><td> `NumCPU(int num)` <td> Parallelize NLL calculation on num CPUs; 4082/// <tr><td> `Optimize(bool flag)` <td> Activate constant term optimization (on by default); 4083/// <tr><td> `IntegrateBins()` <td> Integrate PDF within each bin. This sets the desired precision.; 4084///; 4085/// <tr><th> <th> Options to control flow of fit procedure; 4086/// <tr><td> `InitialHesse(bool flag)` <td> Flag controls if HESSE before MIGRAD as well, off by default; 4087/// <tr><td> `Hesse(bool flag)` <td> Flag controls if HESSE is run after MIGRAD, on by default; 4088/// <tr><td> `Minos(bool flag)` <td> Flag controls if MINOS is run after HESSE, on by default; 4089/// <tr><td> `Minos(const RooArgSet& set)` <td> Only run MINOS on given subset of arguments; 4090/// <tr><td> `Save(bool flag)` <td> Flag controls if RooFitResult object is produced and returned, off by default; 4091/// <tr><td> `Strategy(Int_t flag)` <td> Set Minuit strategy (0 through 2, default is 1); 4092///; 4093/// <tr><th> <th> Options to control informational output; 4094/// <tr><td> `Verbose(bool flag)` <td> Flag controls if verbose output i",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:193009,Performance,cache,cached,193009,"4352 double oldValue;; 4353 RooAbsArg::OperMode oldOperMode;; 4354 bool oldValueDirty;; 4355 bool oldShapeDirty;; 4356 };; 4357 std::vector<ServerData> ourServers;; 4358 ourServers.reserve(servers().size());; 4359 ; 4360 for (auto server : servers()) {; 4361 auto serverValues = ctx.at(server);; 4362 if(serverValues.empty()) continue;; 4363 ; 4364 // maybe we are still missing inhibit dirty here; 4365 auto oldOperMode = server->operMode();; 4366 // See note at the bottom of this function to learn why we can only set; 4367 // the operation mode to ""always clean"" if there are no other value; 4368 // clients.; 4369 server->setOperMode(RooAbsArg::AClean);; 4370 ourServers.push_back({server,; 4371 serverValues,; 4372 server->isCategory() ? static_cast<RooAbsCategory const*>(server)->getCurrentIndex() : static_cast<RooAbsReal const*>(server)->_value,; 4373 oldOperMode,; 4374 server->_valueDirty,; 4375 server->_shapeDirty});; 4376 // Prevent the server from evaluating; just return cached result, which we will side load:; 4377 }; 4378 ; 4379 ; 4380 // Make sure that we restore all state when we finish:; 4381 struct RestoreStateRAII {; 4382 RestoreStateRAII(std::vector<ServerData>& servers) :; 4383 _servers{servers} { }; 4384 ; 4385 ~RestoreStateRAII() {; 4386 for (auto& serverData : _servers) {; 4387 serverData.server->setCachedValue(serverData.oldValue, true);; 4388 serverData.server->setOperMode(serverData.oldOperMode);; 4389 serverData.server->_valueDirty = serverData.oldValueDirty;; 4390 serverData.server->_shapeDirty = serverData.oldShapeDirty;; 4391 }; 4392 }; 4393 ; 4394 std::vector<ServerData>& _servers;; 4395 } restoreState{ourServers};; 4396 ; 4397 ; 4398 // Advising to implement the batch interface makes only sense if the batch was not a scalar.; 4399 // Otherwise, there would be no speedup benefit.; 4400 if(output.size() > 1 && RooMsgService::instance().isActive(this, RooFit::FastEvaluations, RooFit::INFO)) {; 4401 coutI(FastEvaluations) << ""The class "" << ClassN",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:193043,Performance,load,load,193043,"4352 double oldValue;; 4353 RooAbsArg::OperMode oldOperMode;; 4354 bool oldValueDirty;; 4355 bool oldShapeDirty;; 4356 };; 4357 std::vector<ServerData> ourServers;; 4358 ourServers.reserve(servers().size());; 4359 ; 4360 for (auto server : servers()) {; 4361 auto serverValues = ctx.at(server);; 4362 if(serverValues.empty()) continue;; 4363 ; 4364 // maybe we are still missing inhibit dirty here; 4365 auto oldOperMode = server->operMode();; 4366 // See note at the bottom of this function to learn why we can only set; 4367 // the operation mode to ""always clean"" if there are no other value; 4368 // clients.; 4369 server->setOperMode(RooAbsArg::AClean);; 4370 ourServers.push_back({server,; 4371 serverValues,; 4372 server->isCategory() ? static_cast<RooAbsCategory const*>(server)->getCurrentIndex() : static_cast<RooAbsReal const*>(server)->_value,; 4373 oldOperMode,; 4374 server->_valueDirty,; 4375 server->_shapeDirty});; 4376 // Prevent the server from evaluating; just return cached result, which we will side load:; 4377 }; 4378 ; 4379 ; 4380 // Make sure that we restore all state when we finish:; 4381 struct RestoreStateRAII {; 4382 RestoreStateRAII(std::vector<ServerData>& servers) :; 4383 _servers{servers} { }; 4384 ; 4385 ~RestoreStateRAII() {; 4386 for (auto& serverData : _servers) {; 4387 serverData.server->setCachedValue(serverData.oldValue, true);; 4388 serverData.server->setOperMode(serverData.oldOperMode);; 4389 serverData.server->_valueDirty = serverData.oldValueDirty;; 4390 serverData.server->_shapeDirty = serverData.oldShapeDirty;; 4391 }; 4392 }; 4393 ; 4394 std::vector<ServerData>& _servers;; 4395 } restoreState{ourServers};; 4396 ; 4397 ; 4398 // Advising to implement the batch interface makes only sense if the batch was not a scalar.; 4399 // Otherwise, there would be no speedup benefit.; 4400 if(output.size() > 1 && RooMsgService::instance().isActive(this, RooFit::FastEvaluations, RooFit::INFO)) {; 4401 coutI(FastEvaluations) << ""The class "" << ClassN",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:194272,Performance,cache,caches,194272,"vers} { }; 4384 ; 4385 ~RestoreStateRAII() {; 4386 for (auto& serverData : _servers) {; 4387 serverData.server->setCachedValue(serverData.oldValue, true);; 4388 serverData.server->setOperMode(serverData.oldOperMode);; 4389 serverData.server->_valueDirty = serverData.oldValueDirty;; 4390 serverData.server->_shapeDirty = serverData.oldShapeDirty;; 4391 }; 4392 }; 4393 ; 4394 std::vector<ServerData>& _servers;; 4395 } restoreState{ourServers};; 4396 ; 4397 ; 4398 // Advising to implement the batch interface makes only sense if the batch was not a scalar.; 4399 // Otherwise, there would be no speedup benefit.; 4400 if(output.size() > 1 && RooMsgService::instance().isActive(this, RooFit::FastEvaluations, RooFit::INFO)) {; 4401 coutI(FastEvaluations) << ""The class "" << ClassName() << "" does not implement the faster batch evaluation interface.""; 4402 << "" Consider requesting or implementing it to benefit from a speed up."" << std::endl;; 4403 }; 4404 ; 4405 ; 4406 // For each event, write temporary values into our servers' caches, and run a single-value computation.; 4407 ; 4408 for (std::size_t i=0; i < output.size(); ++i) {; 4409 for (auto& serv : ourServers) {; 4410 serv.server->setCachedValue(serv.batch[std::min(i, serv.batch.size()-1)], false);; 4411 }; 4412 ; 4413 output[i] = evaluate();; 4414 }; 4415}; 4416 ; 4417////////////////////////////////////////////////////////////////////////////////; 4418/// This function defines the analytical integral translation for the class.; 4419///; 4420/// \param[in] code The code that decides the integrands.; 4421/// \param[in] rangeName Name of the normalization range.; 4422/// \param[in] ctx An object to manage auxiliary information for code-squashing.; 4423///; 4424/// \returns The representative code string of the integral for the given object.; 4425std::string RooAbsReal::buildCallToAnalyticIntegral(Int_t /* code */, const char * /* rangeName */,; 4426 RooFit::Detail::CodeSquashContext & /*ctx*/) const; 4427{; 4428 std::strings",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:206372,Performance,cache,cached,206372,"on RooAbsArg.cxx:2154; RooAbsArg::printMultilinevoid printMultiline(std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const overrideImplement multi-line detailed printing.Definition RooAbsArg.cxx:1589; RooAbsArg::cloneTreevirtual RooAbsArg * cloneTree(const char *newname=nullptr) constClone tree expression of objects.Definition RooAbsArg.cxx:2293; RooAbsArg::cleanBranchNameTString cleanBranchName() constConstruct a mangled name from the actual name that is free of any math symbols that might be interpre...Definition RooAbsArg.cxx:2075; RooAbsArg::numProxiesInt_t numProxies() constReturn the number of registered proxies.Definition RooAbsArg.cxx:1457; RooAbsArg::_inhibitDirtystatic bool _inhibitDirtyDefinition RooAbsArg.h:668; RooAbsArg::setAttributevoid setAttribute(const Text_t *name, bool value=true)Set (default) or clear a named boolean attribute of this object.Definition RooAbsArg.cxx:222; RooAbsArg::setProxyNormSetvoid setProxyNormSet(const RooArgSet *nset)Forward a change in the cached normalization argset to all the registered proxies.Definition RooAbsArg.cxx:1468; RooAbsArg::branchNodeServerListvoid branchNodeServerList(RooAbsCollection *list, const RooAbsArg *arg=nullptr, bool recurseNonDerived=false) constFill supplied list with all branch nodes of the arg tree starting with ourself as top node.Definition RooAbsArg.cxx:483; RooAbsArg::getProxyRooAbsProxy * getProxy(Int_t index) constReturn the nth proxy from the proxy list.Definition RooAbsArg.cxx:1444; RooAbsArg::CloneTObject * Clone(const char *newname=nullptr) const overrideMake a clone of an object using the Streamer facility.Definition RooAbsArg.h:91; RooAbsArg::_serverListRefCountList_t _serverListDefinition RooAbsArg.h:606; RooAbsArg::leafNodeServerListvoid leafNodeServerList(RooAbsCollection *list, const RooAbsArg *arg=nullptr, bool recurseNonDerived=false) constFill supplied list with all leaf nodes of the arg tree, starting with ourself as top node.Definition RooAbsArg.cxx:4",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:210997,Performance,cache,cache,210997," our set, deleting them if we own them.Definition RooAbsCollection.cxx:756; RooAbsCollection::removevirtual bool remove(const RooAbsArg &var, bool silent=false, bool matchByNameOnly=false)Remove the specified argument from our list.Definition RooAbsCollection.cxx:656; RooAbsCollection::emptybool empty() constDefinition RooAbsCollection.h:273; RooAbsCollection::GetNameconst char * GetName() const overrideReturns name of object.Definition RooAbsCollection.h:342; RooAbsCollection::addvirtual bool add(const RooAbsArg &var, bool silent=false)Add the specified argument to list.Definition RooAbsCollection.cxx:443; RooAbsCollection::CloneTObject * Clone(const char *newname=nullptr) const overrideMake a clone of an object using the Streamer facility.Definition RooAbsCollection.h:76; RooAbsCollection::overlapsbool overlaps(Iterator_t otherCollBegin, Iterator_t otherCollEnd) constDefinition RooAbsCollection.h:238; RooAbsCollection::assignvoid assign(const RooAbsCollection &other) constSets the value, cache and constant attribute of any argument in our set that also appears in the othe...Definition RooAbsCollection.cxx:283; RooAbsCollection::sizeStorage_t::size_type size() constDefinition RooAbsCollection.h:269; RooAbsCollection::firstRooAbsArg * first() constDefinition RooAbsCollection.h:291; RooAbsCollection::replacevirtual bool replace(const RooAbsArg &var1, const RooAbsArg &var2)Replace var1 with var2 and return true for success.Definition RooAbsCollection.cxx:610; RooAbsCollection::addOwnedvirtual bool addOwned(RooAbsArg &var, bool silent=false)Add an argument and transfer the ownership to the collection.Definition RooAbsCollection.cxx:367; RooAbsCollection::addClonevirtual RooAbsArg * addClone(const RooAbsArg &var, bool silent=false)Add a clone of the specified argument to list.Definition RooAbsCollection.cxx:416; RooAbsCollection::contentsStringstd::string contentsString() constReturn comma separated list of contained object names as STL string.Definition RooAbsCollection",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:212556,Performance,perform,performing,212556,"dOwned(RooAbsArg &var, bool silent=false)Add an argument and transfer the ownership to the collection.Definition RooAbsCollection.cxx:367; RooAbsCollection::addClonevirtual RooAbsArg * addClone(const RooAbsArg &var, bool silent=false)Add a clone of the specified argument to list.Definition RooAbsCollection.cxx:416; RooAbsCollection::contentsStringstd::string contentsString() constReturn comma separated list of contained object names as STL string.Definition RooAbsCollection.cxx:1148; RooAbsCollection::findRooAbsArg * find(const char *name) constFind object with given name in list.Definition RooAbsCollection.cxx:922; RooAbsDataAbstract base class for binned and unbinned datasets.Definition RooAbsData.h:57; RooAbsData::getvirtual const RooArgSet * get() constDefinition RooAbsData.h:101; RooAbsData::numEntriesvirtual Int_t numEntries() constReturn number of entries in dataset, i.e., count unweighted entries.Definition RooAbsData.cxx:323; RooAbsFuncAbstract interface for evaluating a real-valued function of one real variable and performing numerica...Definition RooAbsFunc.h:27; RooAbsFunc::getMaxLimitvirtual double getMaxLimit(UInt_t dimension) const =0; RooAbsFunc::operator()virtual double operator()(const double xvector[]) const =0; RooAbsFunc::getMinLimitvirtual double getMinLimit(UInt_t dimension) const =0; RooAbsLValueAbstract base class for objects that are lvalues, i.e.Definition RooAbsLValue.h:26; RooAbsMomentDefinition RooAbsMoment.h:27; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::expectedEventsvirtual double expectedEvents(const RooArgSet *nset) constReturn expected number of events to be used in calculation of extended likelihood.Definition RooAbsPdf.cxx:2398; RooAbsPdf::Classstatic TClass * Class(); RooAbsPdf::CanNotBeExtended@ CanNotBeExtendedDefinition RooAbsPdf.h:212; RooAbsPdf::normRangeconst char * normRange() constDefinition RooAbsPdf.h:250; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > ge",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:220667,Performance,perform,perform,220667," const RooArgSet *projectedVars=nullptr, bool scaling=true, const RooArgSet *condObs=nullptr, bool setError=true) constFill the ROOT histogram 'hist' with values sampled from this function at the bin centers.Definition RooAbsReal.cxx:947; RooAbsReal::createScanRIRooFit::OwningPtr< RooAbsReal > createScanRI(const RooArgSet &iset, const RooArgSet &nset, Int_t numScanBins, Int_t intOrder)Utility function for createRunningIntegral that construct an object implementing the numeric scanning...Definition RooAbsReal.cxx:3810; RooAbsReal::_DEBUG_getValdouble _DEBUG_getVal(const RooArgSet *normalisationSet) constDebug version of getVal(), which is slow and does error checking.Definition RooAbsReal.cxx:4434; RooAbsReal::createFundamentalRooFit::OwningPtr< RooAbsArg > createFundamental(const char *newname=nullptr) const overrideCreate a RooRealVar fundamental object with our properties.Definition RooAbsReal.cxx:3130; RooAbsReal::plotSanityChecksbool plotSanityChecks(RooPlot *frame) constUtility function for plotOn(), perform general sanity check on frame to ensure safe plotting operatio...Definition RooAbsReal.cxx:2860; RooAbsReal::bindVarsRooFit::OwningPtr< RooAbsFunc > bindVars(const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) constCreate an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order).Definition RooAbsReal.cxx:2980; RooAbsReal::selectNormalizationvirtual void selectNormalization(const RooArgSet *depSet=nullptr, bool force=false)Interface function to force use of a given set of observables to interpret function value.Definition RooAbsReal.cxx:3360; RooAbsReal::derivativeRooDerivative * derivative(RooRealVar &obs, Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:225033,Performance,cache,cached,225033,"e unless over...Definition RooAbsReal.h:447; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::printValuevoid printValue(std::ostream &os) const overridePrint object value.Definition RooAbsReal.cxx:445; RooAbsReal::isIdenticalbool isIdentical(const RooAbsArg &other, bool assumeSameType=false) const overrideDefinition RooAbsReal.cxx:270; RooAbsReal::createProfilevirtual RooFit::OwningPtr< RooAbsReal > createProfile(const RooArgSet &paramsOfInterest)Create a RooProfileLL object that eliminates all nuisance parameters in the present function.Definition RooAbsReal.cxx:471; RooAbsReal::_hideOffsetstatic bool _hideOffsetOffset hiding flag.Definition RooAbsReal.h:546; RooAbsReal::attachToVStorevoid attachToVStore(RooVectorDataStore &vstore) overrideDefinition RooAbsReal.cxx:3012; RooAbsReal::copyCachevoid copyCache(const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) overrideCopy the cached value of another RooAbsArg to our cache.Definition RooAbsReal.cxx:2997; RooAbsReal::createHistogramTH1 * createHistogram(RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) constCreate and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables w...Definition RooAbsReal.cxx:1183; RooAbsReal::fixAddCoefRangevirtual void fixAddCoefRange(const char *rangeName=nullptr, bool force=true)Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by...Definition RooAbsReal.cxx:3675; RooAbsReal::_valuedouble _valueCache for current value of object.Definition RooAbsReal.h:536; RooAbsReal::analyticalIntegralvirtual double analyticalIntegral(Int_t code, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:394; RooAbsReal::attachToTreevoid attachToTree(TTree &t, Int_t b",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:225074,Performance,cache,cache,225074,"e unless over...Definition RooAbsReal.h:447; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::printValuevoid printValue(std::ostream &os) const overridePrint object value.Definition RooAbsReal.cxx:445; RooAbsReal::isIdenticalbool isIdentical(const RooAbsArg &other, bool assumeSameType=false) const overrideDefinition RooAbsReal.cxx:270; RooAbsReal::createProfilevirtual RooFit::OwningPtr< RooAbsReal > createProfile(const RooArgSet &paramsOfInterest)Create a RooProfileLL object that eliminates all nuisance parameters in the present function.Definition RooAbsReal.cxx:471; RooAbsReal::_hideOffsetstatic bool _hideOffsetOffset hiding flag.Definition RooAbsReal.h:546; RooAbsReal::attachToVStorevoid attachToVStore(RooVectorDataStore &vstore) overrideDefinition RooAbsReal.cxx:3012; RooAbsReal::copyCachevoid copyCache(const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) overrideCopy the cached value of another RooAbsArg to our cache.Definition RooAbsReal.cxx:2997; RooAbsReal::createHistogramTH1 * createHistogram(RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) constCreate and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables w...Definition RooAbsReal.cxx:1183; RooAbsReal::fixAddCoefRangevirtual void fixAddCoefRange(const char *rangeName=nullptr, bool force=true)Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by...Definition RooAbsReal.cxx:3675; RooAbsReal::_valuedouble _valueCache for current value of object.Definition RooAbsReal.h:536; RooAbsReal::analyticalIntegralvirtual double analyticalIntegral(Int_t code, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:394; RooAbsReal::attachToTreevoid attachToTree(TTree &t, Int_t b",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:241694,Performance,load,loaded,241694,"izerRooCustomizer is a factory class to produce clones of a prototype composite PDF object with the same ...Definition RooCustomizer.h:36; RooCustomizer::setCloneBranchSetvoid setCloneBranchSet(RooArgSet &cloneBranchSet)Releases ownership of list of cloned branch nodes.Definition RooCustomizer.cxx:640; RooCustomizer::replaceArgvoid replaceArg(const RooAbsArg &orig, const RooAbsArg &subst)Replace any occurrence of arg 'orig' with arg 'subst'.Definition RooCustomizer.cxx:327; RooCustomizer::buildRooAbsArg * build(const char *masterCatState, bool verbose=false)Build a clone of the prototype executing all registered 'replace' rules and 'split' rules for the mas...Definition RooCustomizer.cxx:383; RooCustomizer::setOwningvoid setOwning(bool flag)If flag is true, make customizer own all created components.Definition RooCustomizer.h:45; RooDataHistContainer class to hold N-dimensional binned data.Definition RooDataHist.h:40; RooDataHist::setvoid set(std::size_t binNumber, double weight, double wgtErr)Set bin content of bin that was last loaded with get(std::size_t).Definition RooDataHist.cxx:1754; RooDataHist::binVolumedouble binVolume(std::size_t i) constReturn bin volume of i-th bin.Definition RooDataHist.h:118; RooDataHist::getconst RooArgSet * get() const overrideGet bin centre of current bin.Definition RooDataHist.h:82; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDerivativeRepresents the first, second, or third order derivative of any RooAbsReal as calculated (numerically)...Definition RooDerivative.h:30; RooFirstMomentDefinition RooFirstMoment.h:26; RooFitResultRooFitResult is a container class to hold the input and output of a PDF fit to a dataset.Definition RooFitResult.h:40; RooFitResult::covarianceMatrixconst TMatrixDSym & covarianceMatrix() constReturn covariance matrix.Definition RooFitResult.cxx:1112; RooFitResult::reducedCovarianceMatrixTMatrixDSym reducedCovarianceMatrix(const RooArgList &params) constReturn a reduced covari",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:3295,Safety,detect,detected,3295,"nt.h""; 63#include ""RooMsgService.h""; 64#include ""RooNumIntConfig.h""; 65#include ""RooNumRunningInt.h""; 66#include ""RooParamBinning.h""; 67#include ""RooPlot.h""; 68#include ""RooProduct.h""; 69#include ""RooProfileLL.h""; 70#include ""RooRealBinding.h""; 71#include ""RooRealIntegral.h""; 72#include ""RooRealVar.h""; 73#include ""RooSecondMoment.h""; 74#include ""RooVectorDataStore.h""; 75#include ""TreeReadBuffer.h""; 76#include ""ValueChecking.h""; 77 ; 78#include ""ROOT/StringUtils.hxx""; 79#include ""Compression.h""; 80#include ""Math/IFunction.h""; 81#include ""TMath.h""; 82#include ""TObjString.h""; 83#include ""TTree.h""; 84#include ""TH1.h""; 85#include ""TH2.h""; 86#include ""TH3.h""; 87#include ""TBranch.h""; 88#include ""TLeaf.h""; 89#include ""TAttLine.h""; 90#include ""TF1.h""; 91#include ""TF2.h""; 92#include ""TF3.h""; 93#include ""TMatrixD.h""; 94#include ""TVector.h""; 95#include ""strlcpy.h""; 96#ifndef NDEBUG; 97#include <TSystem.h> // To print stack traces when caching errors are detected; 98#endif; 99 ; 100#include <iomanip>; 101#include <iostream>; 102#include <limits>; 103#include <sstream>; 104#include <sys/types.h>; 105 ; 106namespace {; 107 ; 108// Internal helper RooAbsFunc that evaluates the scaled data-weighted average of; 109// given RooAbsReal as a function of a single variable using the RooFit::Evaluator.; 110class ScaledDataWeightedAverage : public RooAbsFunc {; 111public:; 112 ScaledDataWeightedAverage(RooAbsReal const &arg, RooAbsData const &data, double scaleFactor, RooAbsRealLValue &var); 113 : RooAbsFunc{1}, _var{var}, _dataWeights{data.getWeightBatch(0, data.numEntries())}, _scaleFactor{scaleFactor}; 114 {; 115 _arg = RooFit::Detail::compileForNormSet(arg, *data.get());; 116 _arg->recursiveRedirectServers(RooArgList{var});; 117 _evaluator = std::make_unique<RooFit::Evaluator>(*_arg);; 118 std::stack<std::vector<double>>{}.swap(_vectorBuffers);; 119 auto dataSpans = RooFit::BatchModeDataHelpers::getDataSpans(data, """", nullptr, /*skipZeroWeights=*/false,; 120 /*takeGlobalObservablesFromD",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:24737,Safety,detect,detected,24737,"created; 629 const std::string title = std::string(""Integral of "") + integrand->GetTitle();; 630 const std::string name = std::string(integrand->GetName()) + integrand->integralNameSuffix(innerSet,nset,rangeName).Data();; 631 ; 632 std::unique_ptr<RooAbsReal> innerIntegral = std::move(integral);; 633 ; 634 // Construct innermost integral; 635 integral = std::make_unique<RooRealIntegral>(name.c_str(),title.c_str(),*integrand,innerSet,nset,cfg,rangeName);; 636 ; 637 // Integral of integral takes ownership of innermost integral; 638 if (innerIntegral) {; 639 integral->addOwnedComponents(std::move(innerIntegral));; 640 }; 641 ; 642 // Remove already integrated observables from to-do list; 643 iset.remove(innerSet) ;; 644 ; 645 // Send info message on recursion if needed; 646 if (integrand == this && !iset.empty()) {; 647 coutI(Integration) << GetName() << "" : multidimensional integration over observables with parameterized ranges in terms of other integrated observables detected, using recursive integration strategy to construct final integral"" << std::endl ;; 648 }; 649 ; 650 // Prepare for recursion, next integral should integrate last integrand; 651 integrand = integral.get();; 652 ; 653 ; 654 // Only need normalization set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.emp",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:35051,Safety,abort,abort,35051,"s.find(lvs->GetName()) ;; 853 if (tmp) {; 854 leafNodes.remove(*tmp) ;; 855 leafNodes.add(*lvs) ;; 856 }; 857 }; 858 }; 859 }; 860 ; 861 // check if this arg is also in the projection set; 862 if(nullptr != projectedVars && projectedVars->find(arg->GetName())) {; 863 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: \"""" << arg->GetName(); 864 << ""\"" cannot be both a dependent and a projected variable."" << std::endl;; 865 return nullptr;; 866 }; 867 }; 868 ; 869 // Remove the projected variables from the list of leaf nodes, if necessary.; 870 if(nullptr != projectedVars) leafNodes.remove(*projectedVars,true);; 871 ; 872 // Make a deep-clone of ourself so later operations do not disturb our original state; 873 cloneSet = new RooArgSet;; 874 if (RooArgSet(*this).snapshot(*cloneSet, true)) {; 875 coutE(Plotting) << ""RooAbsPdf::createPlotProjection("" << GetName() << "") Couldn't deep-clone PDF, abort,"" << std::endl ;; 876 return nullptr ;; 877 }; 878 RooAbsReal *theClone= static_cast<RooAbsReal*>(cloneSet->find(GetName()));; 879 ; 880 // The remaining entries in our list of leaf nodes are the external; 881 // dependents (x) and parameters (p) of the projection. Patch them back; 882 // into the theClone. This orphans the nodes they replace, but the orphans; 883 // are still in the cloneList and so will be cleaned up eventually.; 884 //cout << ""redirection leafNodes : "" ; leafNodes.Print(""1"") ;; 885 ; 886 std::unique_ptr<RooArgSet> plotLeafNodes{leafNodes.selectCommon(dependentVars)};; 887 theClone->recursiveRedirectServers(*plotLeafNodes,false,false,false);; 888 ; 889 // Create the set of normalization variables to use in the projection integrand; 890 RooArgSet normSet(dependentVars);; 891 if(nullptr != projectedVars) normSet.add(*projectedVars);; 892 if(nullptr != condObs) {; 893 normSet.remove(*condObs,true,true) ;; 894 }; 895 ; 896 // Try to create a valid projection integral. If no variables are to be projected,; 897 // create a null project",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:40694,Safety,abort,abort,40694,": "" << realVar->GetName() << std::endl;; 979 }; 980 plotClones.addClone(*realVar,true); // do not complain about duplicates; 981 }; 982 ; 983 // Reconnect all plotClones to each other, imported when plotting N-dim integrals with entangled parameterized ranges; 984 for(RooAbsArg * pc : plotClones) {; 985 pc->recursiveRedirectServers(plotClones,false,false,true) ;; 986 }; 987 ; 988 // Call checkObservables; 989 RooArgSet allDeps(plotClones) ;; 990 if (projectedVars) {; 991 allDeps.add(*projectedVars) ;; 992 }; 993 if (checkObservables(&allDeps)) {; 994 coutE(InputArguments) << ""RooAbsReal::fillHistogram("" << GetName() << "") error in checkObservables, abort"" << std::endl ;; 995 return hist ;; 996 }; 997 ; 998 // Create a standalone projection object to use for calculating bin contents; 999 RooArgSet *cloneSet = nullptr;; 1000 const RooAbsReal *projected= createPlotProjection(plotClones,projectedVars,cloneSet,nullptr,condObs);; 1001 ; 1002 cxcoutD(Plotting) << ""RooAbsReal::fillHistogram("" << GetName() << "") plot projection object is "" << projected->GetName() << std::endl ;; 1003 ; 1004 // Prepare to loop over the histogram bins; 1005 Int_t xbins(0);; 1006 Int_t ybins(1);; 1007 Int_t zbins(1);; 1008 RooRealVar *xvar = nullptr;; 1009 RooRealVar *yvar = nullptr;; 1010 RooRealVar *zvar = nullptr;; 1011 TAxis *xaxis = nullptr;; 1012 TAxis *yaxis = nullptr;; 1013 TAxis *zaxis = nullptr;; 1014 switch(hdim) {; 1015 case 3:; 1016 zbins= hist->GetNbinsZ();; 1017 zvar= dynamic_cast<RooRealVar*>(plotClones.find(plotVars.at(2)->GetName()));; 1018 zaxis= hist->GetZaxis();; 1019 assert(nullptr != zvar && nullptr != zaxis);; 1020 if (scaleForDensity) {; 1021 scaleFactor*= (zaxis->GetXmax() - zaxis->GetXmin())/zbins;; 1022 }; 1023 // fall through to next case...; 1024 case 2:; 1025 ybins= hist->GetNbinsY();; 1026 yvar= dynamic_cast<RooRealVar*>(plotClones.find(plotVars.at(1)->GetName()));; 1027 yaxis= hist->GetYaxis();; 1028 assert(nullptr != yvar && nullptr != yaxis);; 1029 if (scaleFo",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:46078,Safety,abort,abort,46078,"f extendedMode is true, the p.d.f. values is multiplied; 1109/// by the number of expected events in each bin; 1110///; 1111/// An optional scaling by a given scaleFactor can be performed.; 1112/// Returns a pointer to the input RooDataHist, or zero; 1113/// in case of an error.; 1114///; 1115/// If correctForBinSize is true the RooDataHist; 1116/// is filled with the functions density (function value times the; 1117/// bin volume) rather than function value.; 1118///; 1119/// If showProgress is true; 1120/// a process indicator is printed on stdout in steps of one percent,; 1121/// which is mostly useful for the sampling of expensive functions; 1122/// such as likelihoods; 1123 ; 1124RooDataHist* RooAbsReal::fillDataHist(RooDataHist *hist, const RooArgSet* normSet, double scaleFactor,; 1125 bool correctForBinSize, bool showProgress) const; 1126{; 1127 // Do we have a valid histogram to use?; 1128 if(nullptr == hist) {; 1129 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillDataHist: no valid RooDataHist to fill"" << std::endl;; 1130 return nullptr;; 1131 }; 1132 ; 1133 // Call checkObservables; 1134 RooArgSet allDeps(*hist->get()) ;; 1135 if (checkObservables(&allDeps)) {; 1136 coutE(InputArguments) << ""RooAbsReal::fillDataHist("" << GetName() << "") error in checkObservables, abort"" << std::endl ;; 1137 return hist ;; 1138 }; 1139 ; 1140 // Make deep clone of self and attach to dataset observables; 1141 //RooArgSet* origObs = getObservables(hist) ;; 1142 RooArgSet cloneSet;; 1143 RooArgSet(*this).snapshot(cloneSet, true);; 1144 RooAbsReal* theClone = static_cast<RooAbsReal*>(cloneSet.find(GetName()));; 1145 theClone->recursiveRedirectServers(*hist->get()) ;; 1146 //const_cast<RooAbsReal*>(this)->recursiveRedirectServers(*hist->get()) ;; 1147 ; 1148 // Iterator over all bins of RooDataHist and fill weights; 1149 Int_t onePct = hist->numEntries()/100 ;; 1150 if (onePct==0) {; 1151 onePct++ ;; 1152 }; 1153 for (Int_t i=0 ; i<hist->numEntries() ; i++) {; ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:87296,Safety,abort,abort,87296," variables "" << projectedVars; 1954 << (o.projectionRangeName?Form("" in range %s"",o.projectionRangeName):"""") << std::endl;; 1955 }; 1956 if (projDataNeededVars && !projDataNeededVars->empty()) {; 1957 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot on "" << plotVar->GetName(); 1958 << "" averages using data variables "" << *projDataNeededVars << std::endl ;; 1959 }; 1960 ; 1961 // Create projection integral; 1962 RooArgSet* projectionCompList = nullptr ;; 1963 ; 1964 RooArgSet deps;; 1965 getObservables(frame->getNormVars(), deps) ;; 1966 deps.remove(projectedVars,true,true) ;; 1967 if (projDataNeededVars) {; 1968 deps.remove(*projDataNeededVars,true,true) ;; 1969 }; 1970 deps.remove(*plotVar,true,true) ;; 1971 deps.add(*plotVar) ;; 1972 ; 1973 // Now that we have the final set of dependents, call checkObservables(); 1974 ; 1975 // WVE take out conditional observables; 1976 if (checkObservables(&deps)) {; 1977 coutE(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") error in checkObservables, abort"" << std::endl ;; 1978 if (projDataNeededVars) delete projDataNeededVars ;; 1979 return frame ;; 1980 }; 1981 ; 1982 RooAbsReal *projection = const_cast<RooAbsReal*>(createPlotProjection(deps, &projectedVars, projectionCompList, o.projectionRangeName));; 1983 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot projection object is "" << projection->GetName() << std::endl ;; 1984 if (dologD(Plotting)) {; 1985 projection->printStream(ccoutD(Plotting),0,kVerbose) ;; 1986 }; 1987 ; 1988 // Always fix RooAddPdf normalizations; 1989 RooArgSet fullNormSet(deps) ;; 1990 fullNormSet.add(projectedVars) ;; 1991 if (projDataNeededVars && !projDataNeededVars->empty()) {; 1992 fullNormSet.add(*projDataNeededVars) ;; 1993 }; 1994 ; 1995 std::unique_ptr<RooArgSet> projectionComponents(projection->getComponents());; 1996 for(auto * pdf : dynamic_range_cast<RooAbsPdf*>(*projectionComponents)) {; 1997 if (pdf) {; 1998 pdf->selectNormalization(&fullNormSet) ;; 19",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:102331,Safety,abort,abort,102331,"g.replaceArg(asymCat,*asymNeg) ;; 2310 std::unique_ptr<RooAbsReal> funcPos{static_cast<RooAbsReal*>(custPos.build())};; 2311 std::unique_ptr<RooAbsReal> funcNeg{static_cast<RooAbsReal*>(custNeg.build())};; 2312 ; 2313 // Create projection integral; 2314 RooArgSet *posProjCompList;; 2315 RooArgSet *negProjCompList;; 2316 ; 2317 // Add projDataVars to normalized dependents of projection; 2318 // This is needed only for asymmetries (why?); 2319 RooArgSet depPos(*plotVar,*asymPos) ;; 2320 RooArgSet depNeg(*plotVar,*asymNeg) ;; 2321 depPos.add(projDataVars) ;; 2322 depNeg.add(projDataVars) ;; 2323 ; 2324 const RooAbsReal *posProj = funcPos->createPlotProjection(depPos, &projectedVars, posProjCompList, o.projectionRangeName) ;; 2325 const RooAbsReal *negProj = funcNeg->createPlotProjection(depNeg, &projectedVars, negProjCompList, o.projectionRangeName) ;; 2326 if (!posProj || !negProj) {; 2327 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName() << "") Unable to create projections, abort"" << std::endl ;; 2328 return frame ;; 2329 }; 2330 ; 2331 // Create a RooFormulaVar representing the asymmetry; 2332 TString asymName(GetName()) ;; 2333 asymName.Append(""_Asym["") ;; 2334 asymName.Append(asymCat.GetName()) ;; 2335 asymName.Append(""]"") ;; 2336 TString asymTitle(asymCat.GetName()) ;; 2337 asymTitle.Append("" Asymmetry of "") ;; 2338 asymTitle.Append(GetTitle()) ;; 2339 RooFormulaVar funcAsym{asymName,asymTitle,""(@0-@1)/(@0+@1)"",RooArgSet(*posProj,*negProj)};; 2340 ; 2341 if (o.projData) {; 2342 ; 2343 // If data set contains more rows than needed, make reduced copy first; 2344 RooAbsData* projDataSel = const_cast<RooAbsData*>(o.projData);; 2345 std::unique_ptr<RooAbsData> projDataSelOwned;; 2346 if (projDataNeededVars && projDataNeededVars->size() < o.projData->get()->size()) {; 2347 ; 2348 // Determine if there are any slice variables in the projection set; 2349 RooArgSet sliceDataSet;; 2350 sliceSet.selectCommon(*o.projData->get(), sliceDataSet);; 2351 TString cutString ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:111137,Safety,safe,safe,111137,"; 2503 ; 2504 paramList.add(*rrvInAbsReal);; 2505 }; 2506 ; 2507 std::vector<double> plusVar;; 2508 std::vector<double> minusVar;; 2509 plusVar.reserve(paramList.size());; 2510 minusVar.reserve(paramList.size());; 2511 ; 2512 // Create std::vector of plus,minus variations for each parameter; 2513 TMatrixDSym V(paramList.size() == fr.floatParsFinal().size() ?; 2514 fr.covarianceMatrix() :; 2515 fr.reducedCovarianceMatrix(paramList)) ;; 2516 ; 2517 for (std::size_t ivar=0 ; ivar<paramList.size() ; ivar++) {; 2518 ; 2519 auto& rrv = static_cast<RooRealVar&>(paramList[ivar]);; 2520 ; 2521 double cenVal = rrv.getVal() ;; 2522 double errVal = sqrt(V(ivar,ivar)) ;; 2523 ; 2524 // Make Plus variation; 2525 rrv.setVal(cenVal+errVal) ;; 2526 plusVar.push_back(getVal(nset)) ;; 2527 ; 2528 // Make Minus variation; 2529 rrv.setVal(cenVal-errVal) ;; 2530 minusVar.push_back(getVal(nset)) ;; 2531 ; 2532 rrv.setVal(cenVal) ;; 2533 }; 2534 ; 2535 // Re-evaluate this RooAbsReal with the central parameters just to be; 2536 // extra-safe that a call to `getPropagatedError()` doesn't change any state.; 2537 // It should not be necessary because thanks to the dirty flag propagation; 2538 // the RooAbsReal is re-evaluated anyway the next time getVal() is called.; 2539 // Still there are imaginable corner cases where it would not be triggered,; 2540 // for example if the user changes the RooFit operation more after the error; 2541 // propagation.; 2542 getVal(nset);; 2543 ; 2544 TMatrixDSym C(paramList.size()) ;; 2545 std::vector<double> errVec(paramList.size()) ;; 2546 for (std::size_t i=0 ; i<paramList.size() ; i++) {; 2547 errVec[i] = std::sqrt(V(i,i)) ;; 2548 for (std::size_t j=i ; j<paramList.size() ; j++) {; 2549 C(i,j) = V(i,j) / std::sqrt(V(i,i)*V(j,j));; 2550 C(j,i) = C(i,j) ;; 2551 }; 2552 }; 2553 ; 2554 // Make std::vector of variations; 2555 TVectorD F(plusVar.size()) ;; 2556 for (std::size_t j=0 ; j<plusVar.size() ; j++) {; 2557 F[j] = (plusVar[j]-minusVar[j]) * 0.5;; 2558 }; 25",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:124702,Safety,sanity check,sanity check,124702,"nserted object to back to drawing stack if requested; 2846 if (pc.getInt(""moveToBack"") && frame->numItems()>1) {; 2847 frame->drawBefore(frame->getObject(0)->GetName(), frame->getCurve()->GetName());; 2848 }; 2849 ; 2850 ; 2851 return frame ;; 2852}; 2853 ; 2854 ; 2855 ; 2856 ; 2857////////////////////////////////////////////////////////////////////////////////; 2858/// Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations; 2859 ; 2860bool RooAbsReal::plotSanityChecks(RooPlot* frame) const; 2861{; 2862 // check that we are passed a valid plot frame to use; 2863 if(nullptr == frame) {; 2864 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: frame is null"" << std::endl;; 2865 return true;; 2866 }; 2867 ; 2868 // check that this frame knows what variable to plot; 2869 RooAbsReal* var = frame->getPlotVar() ;; 2870 if(!var) {; 2871 coutE(Plotting) << ClassName() << ""::"" << GetName(); 2872 << "":plotOn: frame does not specify a plot variable"" << std::endl;; 2873 return true;; 2874 }; 2875 ; 2876 // check that the plot variable is not derived; 2877 if(!dynamic_cast<RooAbsRealLValue*>(var)) {; 2878 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: cannot plot variable \""""; 2879 << var->GetName() << ""\"" of type "" << var->ClassName() << std::endl;; 2880 return true;; 2881 }; 2882 ; 2883 // check if we actually depend on the plot variable; 2884 if(!this->dependsOn(*var)) {; 2885 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: WARNING: variable is not an explicit dependent: ""; 2886 << var->GetName() << std::endl;; 2887 }; 2888 ; 2889 return false ;; 2890}; 2891 ; 2892 ; 2893 ; 2894 ; 2895////////////////////////////////////////////////////////////////////////////////; 2896/// Utility function for plotOn() that constructs the set of; 2897/// observables to project when plotting ourselves as function of; 2898/// 'plotVar'. 'allVars' is the list of variables that must be; 2899/// projecte",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:124734,Safety,safe,safe,124734,"nserted object to back to drawing stack if requested; 2846 if (pc.getInt(""moveToBack"") && frame->numItems()>1) {; 2847 frame->drawBefore(frame->getObject(0)->GetName(), frame->getCurve()->GetName());; 2848 }; 2849 ; 2850 ; 2851 return frame ;; 2852}; 2853 ; 2854 ; 2855 ; 2856 ; 2857////////////////////////////////////////////////////////////////////////////////; 2858/// Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations; 2859 ; 2860bool RooAbsReal::plotSanityChecks(RooPlot* frame) const; 2861{; 2862 // check that we are passed a valid plot frame to use; 2863 if(nullptr == frame) {; 2864 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: frame is null"" << std::endl;; 2865 return true;; 2866 }; 2867 ; 2868 // check that this frame knows what variable to plot; 2869 RooAbsReal* var = frame->getPlotVar() ;; 2870 if(!var) {; 2871 coutE(Plotting) << ClassName() << ""::"" << GetName(); 2872 << "":plotOn: frame does not specify a plot variable"" << std::endl;; 2873 return true;; 2874 }; 2875 ; 2876 // check that the plot variable is not derived; 2877 if(!dynamic_cast<RooAbsRealLValue*>(var)) {; 2878 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: cannot plot variable \""""; 2879 << var->GetName() << ""\"" of type "" << var->ClassName() << std::endl;; 2880 return true;; 2881 }; 2882 ; 2883 // check if we actually depend on the plot variable; 2884 if(!this->dependsOn(*var)) {; 2885 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: WARNING: variable is not an explicit dependent: ""; 2886 << var->GetName() << std::endl;; 2887 }; 2888 ; 2889 return false ;; 2890}; 2891 ; 2892 ; 2893 ; 2894 ; 2895////////////////////////////////////////////////////////////////////////////////; 2896/// Utility function for plotOn() that constructs the set of; 2897/// observables to project when plotting ourselves as function of; 2898/// 'plotVar'. 'allVars' is the list of variables that must be; 2899/// projecte",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:150327,Safety,avoid,avoid,150327,"; 3490 bool first(true) ;; 3491 for (Int_t i=0 ; i<numProxies() ; i++) {; 3492 RooAbsProxy* p = getProxy(i) ;; 3493 if (!p) continue ;; 3494 //if (p->name()[0]=='!') continue ;; 3495 if (first) {; 3496 first=false ;; 3497 } else {; 3498 oss << "", "" ;; 3499 }; 3500 p->print(oss,true) ;; 3501 }; 3502 ee.setServerValues(oss.str().c_str()) ;; 3503 }; 3504 ; 3505 std::ostringstream oss2 ;; 3506 printStream(oss2,kName|kClassName|kArgs,kInline) ;; 3507 ; 3508 if (evalErrorData().mode == PrintErrors) {; 3509 coutE(Eval) << ""RooAbsReal::logEvalError("" << GetName() << "") evaluation error, "" << std::endl; 3510 << "" origin : "" << oss2.str() << std::endl; 3511 << "" message : "" << ee._msg << std::endl; 3512 << "" server values: "" << ee._srvval << std::endl ;; 3513 } else if (evalErrorData().mode == CollectErrors) {; 3514 auto &evalErrorList = evalErrorData().errorList[this];; 3515 if (evalErrorList.second.size() >= 2048) {; 3516 // avoid overflowing the error list, so if there are very many, print; 3517 // the oldest one first, and pop it off the list; 3518 const EvalError& oee = evalErrorList.second.front();; 3519 // print to debug stream, since these would normally be suppressed, and; 3520 // we do not want to increase the error count in the message service...; 3521 ccoutD(Eval) << ""RooAbsReal::logEvalError("" << GetName(); 3522 << "") delayed evaluation error, "" << std::endl; 3523 << "" origin : "" << oss2.str() << std::endl; 3524 << "" message : "" << oee._msg << std::endl; 3525 << "" server values: "" << oee._srvval << std::endl ;; 3526 evalErrorList.second.pop_front();; 3527 }; 3528 evalErrorList.first = oss2.str() ;; 3529 evalErrorList.second.push_back(ee) ;; 3530 }; 3531 ; 3532 inLogEvalError = false ;; 3533 //coutE(Tracing) << ""RooAbsReal::logEvalError("" << GetName() << "") message = "" << message << std::endl ;; 3534}; 3535 ; 3536 ; 3537 ; 3538 ; 3539////////////////////////////////////////////////////////////////////////////////; 3540/// Clear the stack of evaluation error messag",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:175987,Safety,predict,predicted,175987,"//////////////////////////////////////////; 4047///; 4048/// Return value of x (in range xmin,xmax) at which function equals yval.; 4049/// (Calculation is performed with Brent root finding algorithm); 4050 ; 4051double RooAbsReal::findRoot(RooRealVar& x, double xmin, double xmax, double yval); 4052{; 4053 double result(0) ;; 4054 RooBrentRootFinder(RooRealBinding(*this,x)).findRoot(result,xmin,xmax,yval) ;; 4055 return result ;; 4056}; 4057 ; 4058 ; 4059 ; 4060////////////////////////////////////////////////////////////////////////////////; 4061/// Perform a \f$ \chi^2 \f$ fit to given histogram. By default the fit is executed through the MINUIT; 4062/// commands MIGRAD, HESSE in succession; 4063///; 4064/// The following named arguments are supported; 4065///; 4066/// <table>; 4067/// <tr><th> <th> Options to control construction of chi2; 4068/// <tr><td> `Extended(bool flag)` <td> **Only applicable when fitting a RooAbsPdf**. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight.; 4069/// This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; 4070/// - If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events; 4071/// (in RooFit jargon, ""if the pdf can be extended"").; 4072/// - Passing `Extended(true)` when the the pdf makes no prediction on the expected number of events will result in error messages,; 4073/// and the chi2 will fall back to the total data weight to scale the normalized pdf.; 4074/// - There are cases where the fit **must** be done in extended mode. This happens for example when you have a RooAddPdf; 4075/// where the coefficients represent component yields. If the fit is not extended, these coefficients will not be; 4076/// well-defined, as the RooAddPdf always normalizes itself. If you pass `Extended(false)` in such a case, an error will be; 4077/// printed and ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:176097,Safety,predict,predicted,176097,"quals yval.; 4049/// (Calculation is performed with Brent root finding algorithm); 4050 ; 4051double RooAbsReal::findRoot(RooRealVar& x, double xmin, double xmax, double yval); 4052{; 4053 double result(0) ;; 4054 RooBrentRootFinder(RooRealBinding(*this,x)).findRoot(result,xmin,xmax,yval) ;; 4055 return result ;; 4056}; 4057 ; 4058 ; 4059 ; 4060////////////////////////////////////////////////////////////////////////////////; 4061/// Perform a \f$ \chi^2 \f$ fit to given histogram. By default the fit is executed through the MINUIT; 4062/// commands MIGRAD, HESSE in succession; 4063///; 4064/// The following named arguments are supported; 4065///; 4066/// <table>; 4067/// <tr><th> <th> Options to control construction of chi2; 4068/// <tr><td> `Extended(bool flag)` <td> **Only applicable when fitting a RooAbsPdf**. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight.; 4069/// This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; 4070/// - If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events; 4071/// (in RooFit jargon, ""if the pdf can be extended"").; 4072/// - Passing `Extended(true)` when the the pdf makes no prediction on the expected number of events will result in error messages,; 4073/// and the chi2 will fall back to the total data weight to scale the normalized pdf.; 4074/// - There are cases where the fit **must** be done in extended mode. This happens for example when you have a RooAddPdf; 4075/// where the coefficients represent component yields. If the fit is not extended, these coefficients will not be; 4076/// well-defined, as the RooAddPdf always normalizes itself. If you pass `Extended(false)` in such a case, an error will be; 4077/// printed and you'll most likely get garbage results.; 4078/// <tr><td> `Range(const char* name)` <td> Fit only data inside range wit",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:176278,Safety,predict,prediction,176278,"ax, double yval); 4052{; 4053 double result(0) ;; 4054 RooBrentRootFinder(RooRealBinding(*this,x)).findRoot(result,xmin,xmax,yval) ;; 4055 return result ;; 4056}; 4057 ; 4058 ; 4059 ; 4060////////////////////////////////////////////////////////////////////////////////; 4061/// Perform a \f$ \chi^2 \f$ fit to given histogram. By default the fit is executed through the MINUIT; 4062/// commands MIGRAD, HESSE in succession; 4063///; 4064/// The following named arguments are supported; 4065///; 4066/// <table>; 4067/// <tr><th> <th> Options to control construction of chi2; 4068/// <tr><td> `Extended(bool flag)` <td> **Only applicable when fitting a RooAbsPdf**. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight.; 4069/// This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; 4070/// - If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events; 4071/// (in RooFit jargon, ""if the pdf can be extended"").; 4072/// - Passing `Extended(true)` when the the pdf makes no prediction on the expected number of events will result in error messages,; 4073/// and the chi2 will fall back to the total data weight to scale the normalized pdf.; 4074/// - There are cases where the fit **must** be done in extended mode. This happens for example when you have a RooAddPdf; 4075/// where the coefficients represent component yields. If the fit is not extended, these coefficients will not be; 4076/// well-defined, as the RooAddPdf always normalizes itself. If you pass `Extended(false)` in such a case, an error will be; 4077/// printed and you'll most likely get garbage results.; 4078/// <tr><td> `Range(const char* name)` <td> Fit only data inside range with given name; 4079/// <tr><td> `Range(double lo, double hi)` <td> Fit only data inside given range. A range named ""fit"" is created on the fly on all observabl",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:176434,Safety,predict,prediction,176434,"////////////////////////////////////////////////////////; 4061/// Perform a \f$ \chi^2 \f$ fit to given histogram. By default the fit is executed through the MINUIT; 4062/// commands MIGRAD, HESSE in succession; 4063///; 4064/// The following named arguments are supported; 4065///; 4066/// <table>; 4067/// <tr><th> <th> Options to control construction of chi2; 4068/// <tr><td> `Extended(bool flag)` <td> **Only applicable when fitting a RooAbsPdf**. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight.; 4069/// This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; 4070/// - If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events; 4071/// (in RooFit jargon, ""if the pdf can be extended"").; 4072/// - Passing `Extended(true)` when the the pdf makes no prediction on the expected number of events will result in error messages,; 4073/// and the chi2 will fall back to the total data weight to scale the normalized pdf.; 4074/// - There are cases where the fit **must** be done in extended mode. This happens for example when you have a RooAddPdf; 4075/// where the coefficients represent component yields. If the fit is not extended, these coefficients will not be; 4076/// well-defined, as the RooAddPdf always normalizes itself. If you pass `Extended(false)` in such a case, an error will be; 4077/// printed and you'll most likely get garbage results.; 4078/// <tr><td> `Range(const char* name)` <td> Fit only data inside range with given name; 4079/// <tr><td> `Range(double lo, double hi)` <td> Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; 4080/// Multiple comma separated range names can be specified.; 4081/// <tr><td> `NumCPU(int num)` <td> Parallelize NLL calculation on num CPUs; 4082/// <tr><td> `Optimize(bool flag)` <td> Activate constant ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:220683,Safety,sanity check,sanity check,220683," const RooArgSet *projectedVars=nullptr, bool scaling=true, const RooArgSet *condObs=nullptr, bool setError=true) constFill the ROOT histogram 'hist' with values sampled from this function at the bin centers.Definition RooAbsReal.cxx:947; RooAbsReal::createScanRIRooFit::OwningPtr< RooAbsReal > createScanRI(const RooArgSet &iset, const RooArgSet &nset, Int_t numScanBins, Int_t intOrder)Utility function for createRunningIntegral that construct an object implementing the numeric scanning...Definition RooAbsReal.cxx:3810; RooAbsReal::_DEBUG_getValdouble _DEBUG_getVal(const RooArgSet *normalisationSet) constDebug version of getVal(), which is slow and does error checking.Definition RooAbsReal.cxx:4434; RooAbsReal::createFundamentalRooFit::OwningPtr< RooAbsArg > createFundamental(const char *newname=nullptr) const overrideCreate a RooRealVar fundamental object with our properties.Definition RooAbsReal.cxx:3130; RooAbsReal::plotSanityChecksbool plotSanityChecks(RooPlot *frame) constUtility function for plotOn(), perform general sanity check on frame to ensure safe plotting operatio...Definition RooAbsReal.cxx:2860; RooAbsReal::bindVarsRooFit::OwningPtr< RooAbsFunc > bindVars(const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) constCreate an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order).Definition RooAbsReal.cxx:2980; RooAbsReal::selectNormalizationvirtual void selectNormalization(const RooArgSet *depSet=nullptr, bool force=false)Interface function to force use of a given set of observables to interpret function value.Definition RooAbsReal.cxx:3360; RooAbsReal::derivativeRooDerivative * derivative(RooRealVar &obs, Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:220715,Safety,safe,safe,220715," const RooArgSet *projectedVars=nullptr, bool scaling=true, const RooArgSet *condObs=nullptr, bool setError=true) constFill the ROOT histogram 'hist' with values sampled from this function at the bin centers.Definition RooAbsReal.cxx:947; RooAbsReal::createScanRIRooFit::OwningPtr< RooAbsReal > createScanRI(const RooArgSet &iset, const RooArgSet &nset, Int_t numScanBins, Int_t intOrder)Utility function for createRunningIntegral that construct an object implementing the numeric scanning...Definition RooAbsReal.cxx:3810; RooAbsReal::_DEBUG_getValdouble _DEBUG_getVal(const RooArgSet *normalisationSet) constDebug version of getVal(), which is slow and does error checking.Definition RooAbsReal.cxx:4434; RooAbsReal::createFundamentalRooFit::OwningPtr< RooAbsArg > createFundamental(const char *newname=nullptr) const overrideCreate a RooRealVar fundamental object with our properties.Definition RooAbsReal.cxx:3130; RooAbsReal::plotSanityChecksbool plotSanityChecks(RooPlot *frame) constUtility function for plotOn(), perform general sanity check on frame to ensure safe plotting operatio...Definition RooAbsReal.cxx:2860; RooAbsReal::bindVarsRooFit::OwningPtr< RooAbsFunc > bindVars(const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) constCreate an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order).Definition RooAbsReal.cxx:2980; RooAbsReal::selectNormalizationvirtual void selectNormalization(const RooArgSet *depSet=nullptr, bool force=false)Interface function to force use of a given set of observables to interpret function value.Definition RooAbsReal.cxx:3360; RooAbsReal::derivativeRooDerivative * derivative(RooRealVar &obs, Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:11187,Security,validat,validation,11187," the cache is clean, return the; 297/// cached value, otherwise recalculate on the fly and refill; 298/// the cache; 299 ; 300double RooAbsReal::getValV(const RooArgSet* nset) const; 301{; 302 if (nset && nset->uniqueId().value() != _lastNormSetId) {; 303 const_cast<RooAbsReal*>(this)->setProxyNormSet(nset);; 304 _lastNormSetId = nset->uniqueId().value();; 305 }; 306 ; 307 if (isValueDirtyAndClear()) {; 308 _value = traceEval(nullptr) ;; 309 // clearValueDirty() ;; 310 }; 311 ; 312 return hideOffset() ? _value + offset() : _value;; 313}; 314 ; 315 ; 316////////////////////////////////////////////////////////////////////////////////; 317/// Calculate current value of object, with error tracing wrapper; 318 ; 319double RooAbsReal::traceEval(const RooArgSet* /*nset*/) const; 320{; 321 double value = evaluate() ;; 322 ; 323 if (TMath::IsNaN(value)) {; 324 logEvalError(""function value is NAN"") ;; 325 }; 326 ; 327 //cxcoutD(Tracing) << ""RooAbsReal::getValF("" << GetName() << "") operMode = "" << _operMode << "" recalculated, new value = "" << value << std::endl ;; 328 ; 329 //Standard tracing code goes here; 330 if (!isValidReal(value)) {; 331 coutW(Tracing) << ""RooAbsReal::traceEval("" << GetName(); 332 << ""): validation failed: "" << value << std::endl ;; 333 }; 334 ; 335 //Call optional subclass tracing code; 336 // traceEvalHook(value) ;; 337 ; 338 return value ;; 339}; 340 ; 341 ; 342 ; 343////////////////////////////////////////////////////////////////////////////////; 344/// Variant of getAnalyticalIntegral that is also passed the normalization set; 345/// that should be applied to the integrand of which the integral is requested.; 346/// For certain operator p.d.f it is useful to overload this function rather; 347/// than analyticalIntegralWN() as the additional normalization information; 348/// may be useful in determining a more efficient decomposition of the; 349/// requested integral.; 350 ; 351Int_t RooAbsReal::getAnalyticalIntegralWN(RooArgSet& allDeps, RooArgSet& a",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:10832,Testability,log,logEvalError,10832," the cache is clean, return the; 297/// cached value, otherwise recalculate on the fly and refill; 298/// the cache; 299 ; 300double RooAbsReal::getValV(const RooArgSet* nset) const; 301{; 302 if (nset && nset->uniqueId().value() != _lastNormSetId) {; 303 const_cast<RooAbsReal*>(this)->setProxyNormSet(nset);; 304 _lastNormSetId = nset->uniqueId().value();; 305 }; 306 ; 307 if (isValueDirtyAndClear()) {; 308 _value = traceEval(nullptr) ;; 309 // clearValueDirty() ;; 310 }; 311 ; 312 return hideOffset() ? _value + offset() : _value;; 313}; 314 ; 315 ; 316////////////////////////////////////////////////////////////////////////////////; 317/// Calculate current value of object, with error tracing wrapper; 318 ; 319double RooAbsReal::traceEval(const RooArgSet* /*nset*/) const; 320{; 321 double value = evaluate() ;; 322 ; 323 if (TMath::IsNaN(value)) {; 324 logEvalError(""function value is NAN"") ;; 325 }; 326 ; 327 //cxcoutD(Tracing) << ""RooAbsReal::getValF("" << GetName() << "") operMode = "" << _operMode << "" recalculated, new value = "" << value << std::endl ;; 328 ; 329 //Standard tracing code goes here; 330 if (!isValidReal(value)) {; 331 coutW(Tracing) << ""RooAbsReal::traceEval("" << GetName(); 332 << ""): validation failed: "" << value << std::endl ;; 333 }; 334 ; 335 //Call optional subclass tracing code; 336 // traceEvalHook(value) ;; 337 ; 338 return value ;; 339}; 340 ; 341 ; 342 ; 343////////////////////////////////////////////////////////////////////////////////; 344/// Variant of getAnalyticalIntegral that is also passed the normalization set; 345/// that should be applied to the integrand of which the integral is requested.; 346/// For certain operator p.d.f it is useful to overload this function rather; 347/// than analyticalIntegralWN() as the additional normalization information; 348/// may be useful in determining a more efficient decomposition of the; 349/// requested integral.; 350 ; 351Int_t RooAbsReal::getAnalyticalIntegralWN(RooArgSet& allDeps, RooArgSet& a",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:41624,Testability,assert,assert,41624,"vables, abort"" << std::endl ;; 995 return hist ;; 996 }; 997 ; 998 // Create a standalone projection object to use for calculating bin contents; 999 RooArgSet *cloneSet = nullptr;; 1000 const RooAbsReal *projected= createPlotProjection(plotClones,projectedVars,cloneSet,nullptr,condObs);; 1001 ; 1002 cxcoutD(Plotting) << ""RooAbsReal::fillHistogram("" << GetName() << "") plot projection object is "" << projected->GetName() << std::endl ;; 1003 ; 1004 // Prepare to loop over the histogram bins; 1005 Int_t xbins(0);; 1006 Int_t ybins(1);; 1007 Int_t zbins(1);; 1008 RooRealVar *xvar = nullptr;; 1009 RooRealVar *yvar = nullptr;; 1010 RooRealVar *zvar = nullptr;; 1011 TAxis *xaxis = nullptr;; 1012 TAxis *yaxis = nullptr;; 1013 TAxis *zaxis = nullptr;; 1014 switch(hdim) {; 1015 case 3:; 1016 zbins= hist->GetNbinsZ();; 1017 zvar= dynamic_cast<RooRealVar*>(plotClones.find(plotVars.at(2)->GetName()));; 1018 zaxis= hist->GetZaxis();; 1019 assert(nullptr != zvar && nullptr != zaxis);; 1020 if (scaleForDensity) {; 1021 scaleFactor*= (zaxis->GetXmax() - zaxis->GetXmin())/zbins;; 1022 }; 1023 // fall through to next case...; 1024 case 2:; 1025 ybins= hist->GetNbinsY();; 1026 yvar= dynamic_cast<RooRealVar*>(plotClones.find(plotVars.at(1)->GetName()));; 1027 yaxis= hist->GetYaxis();; 1028 assert(nullptr != yvar && nullptr != yaxis);; 1029 if (scaleForDensity) {; 1030 scaleFactor*= (yaxis->GetXmax() - yaxis->GetXmin())/ybins;; 1031 }; 1032 // fall through to next case...; 1033 case 1:; 1034 xbins= hist->GetNbinsX();; 1035 xvar= dynamic_cast<RooRealVar*>(plotClones.find(plotVars.at(0)->GetName()));; 1036 xaxis= hist->GetXaxis();; 1037 assert(nullptr != xvar && nullptr != xaxis);; 1038 if (scaleForDensity) {; 1039 scaleFactor*= (xaxis->GetXmax() - xaxis->GetXmin())/xbins;; 1040 }; 1041 break;; 1042 default:; 1043 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillHistogram: cannot fill histogram with ""; 1044 << hdim << "" dimensions"" << std::endl;; 1045 break;; 1046 }; 1047 ;",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:41975,Testability,assert,assert,41975,"<< GetName() << "") plot projection object is "" << projected->GetName() << std::endl ;; 1003 ; 1004 // Prepare to loop over the histogram bins; 1005 Int_t xbins(0);; 1006 Int_t ybins(1);; 1007 Int_t zbins(1);; 1008 RooRealVar *xvar = nullptr;; 1009 RooRealVar *yvar = nullptr;; 1010 RooRealVar *zvar = nullptr;; 1011 TAxis *xaxis = nullptr;; 1012 TAxis *yaxis = nullptr;; 1013 TAxis *zaxis = nullptr;; 1014 switch(hdim) {; 1015 case 3:; 1016 zbins= hist->GetNbinsZ();; 1017 zvar= dynamic_cast<RooRealVar*>(plotClones.find(plotVars.at(2)->GetName()));; 1018 zaxis= hist->GetZaxis();; 1019 assert(nullptr != zvar && nullptr != zaxis);; 1020 if (scaleForDensity) {; 1021 scaleFactor*= (zaxis->GetXmax() - zaxis->GetXmin())/zbins;; 1022 }; 1023 // fall through to next case...; 1024 case 2:; 1025 ybins= hist->GetNbinsY();; 1026 yvar= dynamic_cast<RooRealVar*>(plotClones.find(plotVars.at(1)->GetName()));; 1027 yaxis= hist->GetYaxis();; 1028 assert(nullptr != yvar && nullptr != yaxis);; 1029 if (scaleForDensity) {; 1030 scaleFactor*= (yaxis->GetXmax() - yaxis->GetXmin())/ybins;; 1031 }; 1032 // fall through to next case...; 1033 case 1:; 1034 xbins= hist->GetNbinsX();; 1035 xvar= dynamic_cast<RooRealVar*>(plotClones.find(plotVars.at(0)->GetName()));; 1036 xaxis= hist->GetXaxis();; 1037 assert(nullptr != xvar && nullptr != xaxis);; 1038 if (scaleForDensity) {; 1039 scaleFactor*= (xaxis->GetXmax() - xaxis->GetXmin())/xbins;; 1040 }; 1041 break;; 1042 default:; 1043 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillHistogram: cannot fill histogram with ""; 1044 << hdim << "" dimensions"" << std::endl;; 1045 break;; 1046 }; 1047 ; 1048 // Loop over the input histogram's bins and fill each one with our projection's; 1049 // value, calculated at the center.; 1050 RooAbsReal::setEvalErrorLoggingMode(RooAbsReal::CollectErrors) ;; 1051 Int_t xbin(0);; 1052 Int_t ybin(0);; 1053 Int_t zbin(0);; 1054 Int_t bins= xbins*ybins*zbins;; 1055 for(Int_t bin= 0; bin < bins; bin++) {; 1056 s",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:42326,Testability,assert,assert,42326,"(plotClones.find(plotVars.at(2)->GetName()));; 1018 zaxis= hist->GetZaxis();; 1019 assert(nullptr != zvar && nullptr != zaxis);; 1020 if (scaleForDensity) {; 1021 scaleFactor*= (zaxis->GetXmax() - zaxis->GetXmin())/zbins;; 1022 }; 1023 // fall through to next case...; 1024 case 2:; 1025 ybins= hist->GetNbinsY();; 1026 yvar= dynamic_cast<RooRealVar*>(plotClones.find(plotVars.at(1)->GetName()));; 1027 yaxis= hist->GetYaxis();; 1028 assert(nullptr != yvar && nullptr != yaxis);; 1029 if (scaleForDensity) {; 1030 scaleFactor*= (yaxis->GetXmax() - yaxis->GetXmin())/ybins;; 1031 }; 1032 // fall through to next case...; 1033 case 1:; 1034 xbins= hist->GetNbinsX();; 1035 xvar= dynamic_cast<RooRealVar*>(plotClones.find(plotVars.at(0)->GetName()));; 1036 xaxis= hist->GetXaxis();; 1037 assert(nullptr != xvar && nullptr != xaxis);; 1038 if (scaleForDensity) {; 1039 scaleFactor*= (xaxis->GetXmax() - xaxis->GetXmin())/xbins;; 1040 }; 1041 break;; 1042 default:; 1043 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":fillHistogram: cannot fill histogram with ""; 1044 << hdim << "" dimensions"" << std::endl;; 1045 break;; 1046 }; 1047 ; 1048 // Loop over the input histogram's bins and fill each one with our projection's; 1049 // value, calculated at the center.; 1050 RooAbsReal::setEvalErrorLoggingMode(RooAbsReal::CollectErrors) ;; 1051 Int_t xbin(0);; 1052 Int_t ybin(0);; 1053 Int_t zbin(0);; 1054 Int_t bins= xbins*ybins*zbins;; 1055 for(Int_t bin= 0; bin < bins; bin++) {; 1056 switch(hdim) {; 1057 case 3:; 1058 if(bin % (xbins*ybins) == 0) {; 1059 zbin++;; 1060 zvar->setVal(zaxis->GetBinCenter(zbin));; 1061 }; 1062 // fall through to next case...; 1063 case 2:; 1064 if(bin % xbins == 0) {; 1065 ybin= (ybin%ybins) + 1;; 1066 yvar->setVal(yaxis->GetBinCenter(ybin));; 1067 }; 1068 // fall through to next case...; 1069 case 1:; 1070 xbin= (xbin%xbins) + 1;; 1071 xvar->setVal(xaxis->GetBinCenter(xbin));; 1072 break;; 1073 default:; 1074 coutE(InputArguments) << ""RooAbsReal::fil",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:65911,Testability,log,log,65911,"nterpretation of number depends on code:; 1551/// - Relative: relative adjustment factor for a normalized function,; 1552/// - NumEvent: scale to match given number of events.; 1553/// - Raw: relative adjustment factor for an un-normalized function.; 1554///; 1555/// <tr><td> `Name(const chat* name)` <td> Give curve specified name in frame. Useful if curve is to be referenced later; 1556///; 1557/// <tr><td> `Asymmetry(const RooCategory& c)` <td> Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; 1558/// the PDF projection. Category must have two states with indices -1 and +1 or three states with; 1559/// indices -1,0 and +1.; 1560///; 1561/// <tr><td> `ShiftToZero(bool flag)` <td> Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when plotting \f$ -\log(L) \f$ or \f$ \chi^2 \f$ distributions; 1562///; 1563/// <tr><td> `AddTo(const char* name, double_t wgtSelf, double_t wgtOther)` <td> Add constructed projection to already existing curve with given name and relative weight factors; 1564/// <tr><td> `Components(const char* names)` <td> When plotting sums of PDFs, plot only the named components (*e.g.* only; 1565/// the signal of a signal+background model).; 1566/// <tr><td> `Components(const RooArgSet& compSet)` <td> As above, but pass a RooArgSet of the components themselves.; 1567///; 1568/// <tr><th><th> Plotting control; 1569/// <tr><td> `DrawOption(const char* opt)` <td> Select ROOT draw option for resulting TGraph object. Currently supported options are ""F"" (fill), ""L"" (line), and ""P"" (points).; 1570/// \note Option ""P"" will cause RooFit to plot (and treat) this pdf as if it were data! This is intended for plotting ""corrected data""-type pdfs such as ""data-minus-background"" or unfolded datasets.; 1571///; 1572/// <tr><td> `LineStyle(Int_t style)` <td> Select line style by ROOT line style code, default is solid; 1573///; 1574/// <tr><td> `LineColor(Int_t color)` <td> Select line color",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:109995,Testability,log,logic,109995,"inal())) {; 2481 ; 2482 auto rrvInAbsReal = static_cast<RooRealVar const*>(allParamsInAbsReal.find(*rrvFitRes));; 2483 ; 2484 // If this RooAbsReal is a RooRealVar in the fit result, we don't need to; 2485 // propagate anything and can just return the error in the fit result; 2486 if(rrvFitRes->namePtr() == namePtr()) return rrvFitRes->getError();; 2487 ; 2488 // Strip out parameters with zero error; 2489 if (rrvFitRes->getError() <= std::abs(rrvFitRes->getVal()) * std::numeric_limits<double>::epsilon()) continue;; 2490 ; 2491 // Ignore parameters in the fit result that this RooAbsReal doesn't depend on; 2492 if(!rrvInAbsReal) continue;; 2493 ; 2494 // Checking for float equality is a bad. We check if the values are; 2495 // negligibly far away from each other, relative to the uncertainty.; 2496 if(std::abs(rrvInAbsReal->getVal() - rrvFitRes->getVal()) > 0.01 * rrvFitRes->getError()) {; 2497 std::stringstream errMsg;; 2498 errMsg << ""RooAbsReal::getPropagatedError(): the parameters of the RooAbsReal don't have""; 2499 << "" the same values as in the fit result! The logic of getPropagatedError is broken in this case."";; 2500 ; 2501 throw std::runtime_error(errMsg.str());; 2502 }; 2503 ; 2504 paramList.add(*rrvInAbsReal);; 2505 }; 2506 ; 2507 std::vector<double> plusVar;; 2508 std::vector<double> minusVar;; 2509 plusVar.reserve(paramList.size());; 2510 minusVar.reserve(paramList.size());; 2511 ; 2512 // Create std::vector of plus,minus variations for each parameter; 2513 TMatrixDSym V(paramList.size() == fr.floatParsFinal().size() ?; 2514 fr.covarianceMatrix() :; 2515 fr.reducedCovarianceMatrix(paramList)) ;; 2516 ; 2517 for (std::size_t ivar=0 ; ivar<paramList.size() ; ivar++) {; 2518 ; 2519 auto& rrv = static_cast<RooRealVar&>(paramList[ivar]);; 2520 ; 2521 double cenVal = rrv.getVal() ;; 2522 double errVal = sqrt(V(ivar,ivar)) ;; 2523 ; 2524 // Make Plus variation; 2525 rrv.setVal(cenVal+errVal) ;; 2526 plusVar.push_back(getVal(nset)) ;; 2527 ; 2528 // Make Minus var",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:130265,Testability,assert,assert,130265," clipInvalid) const; 2981{; 2982 auto binding = std::make_unique<RooRealBinding>(*this,vars,nset,clipInvalid);; 2983 if(!binding->isValid()) {; 2984 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":bindVars: cannot bind to "" << vars << std::endl ;; 2985 return nullptr;; 2986 }; 2987 return RooFit::makeOwningPtr(std::unique_ptr<RooAbsFunc>{std::move(binding)});; 2988}; 2989 ; 2990 ; 2991 ; 2992////////////////////////////////////////////////////////////////////////////////; 2993/// Copy the cached value of another RooAbsArg to our cache.; 2994/// Warning: This function just copies the cached values of source,; 2995/// it is the callers responsibility to make sure the cache is clean.; 2996 ; 2997void RooAbsReal::copyCache(const RooAbsArg* source, bool /*valueOnly*/, bool setValDirty); 2998{; 2999 auto other = static_cast<const RooAbsReal*>(source);; 3000 assert(dynamic_cast<const RooAbsReal*>(source));; 3001 ; 3002 _value = other->_treeReadBuffer ? other->_treeReadBuffer->operator double() : other->_value;; 3003 ; 3004 if (setValDirty) {; 3005 setValueDirty() ;; 3006 }; 3007}; 3008 ; 3009 ; 3010////////////////////////////////////////////////////////////////////////////////; 3011 ; 3012void RooAbsReal::attachToVStore(RooVectorDataStore& vstore); 3013{; 3014 vstore.addReal(this)->setBuffer(this,&_value);; 3015}; 3016 ; 3017 ; 3018////////////////////////////////////////////////////////////////////////////////; 3019/// Attach object to a branch of given TTree. By default it will; 3020/// register the internal value cache RooAbsReal::_value as branch; 3021/// buffer for a double tree branch with the same name as this; 3022/// object. If no double branch is found with the name of this; 3023/// object, this method looks for a Float_t Int_t, UChar_t and UInt_t, etc; 3024/// branch. If any of these are found, a TreeReadBuffer; 3025/// that branch is created, and saved in _treeReadBuffer.; 3026/// TreeReadBuffer::operator double() can be used to convert the value",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:135141,Testability,assert,assert,135141,"o(""Double_t"")) {; 3079 t.SetBranchAddress(cleanName, &_value);; 3080 }; 3081 else {; 3082 coutE(InputArguments) << ""RooAbsReal::attachToTree("" << GetName() << "") data type "" << typeName << "" is not supported."" << std::endl ;; 3083 }; 3084 }; 3085 } else {; 3086 ; 3087 TString format(cleanName);; 3088 format.Append(""/D"");; 3089 branch = t.Branch(cleanName, &_value, (const Text_t*)format, bufSize);; 3090 }; 3091 ; 3092}; 3093 ; 3094 ; 3095 ; 3096////////////////////////////////////////////////////////////////////////////////; 3097/// Fill the tree branch that associated with this object with its current value; 3098 ; 3099void RooAbsReal::fillTreeBranch(TTree& t); 3100{; 3101 // First determine if branch is taken; 3102 TBranch* branch = t.GetBranch(cleanBranchName()) ;; 3103 if (!branch) {; 3104 coutE(Eval) << ""RooAbsReal::fillTreeBranch("" << GetName() << "") ERROR: not attached to tree: "" << cleanBranchName() << std::endl ;; 3105 assert(0) ;; 3106 }; 3107 branch->Fill() ;; 3108 ; 3109}; 3110 ; 3111 ; 3112 ; 3113////////////////////////////////////////////////////////////////////////////////; 3114/// (De)Activate associated tree branch; 3115 ; 3116void RooAbsReal::setTreeBranchStatus(TTree& t, bool active); 3117{; 3118 TBranch* branch = t.GetBranch(cleanBranchName()) ;; 3119 if (branch) {; 3120 t.SetBranchStatus(cleanBranchName(),active?true:false) ;; 3121 }; 3122}; 3123 ; 3124 ; 3125 ; 3126////////////////////////////////////////////////////////////////////////////////; 3127/// Create a RooRealVar fundamental object with our properties. The new; 3128/// object will be created without any fit limits.; 3129 ; 3130RooFit::OwningPtr<RooAbsArg> RooAbsReal::createFundamental(const char* newname) const; 3131{; 3132 auto fund = std::make_unique<RooRealVar>(newname?newname:GetName(),GetTitle(),_value,getUnit());; 3133 fund->removeRange();; 3134 fund->setPlotLabel(getPlotLabel());; 3135 fund->setAttribute(""fundamentalCopy"");; 3136 return RooFit::makeOwningPtr<RooAbsArg>(std::move",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:146078,Testability,assert,assert,146078,"///////////////////////; 3368/// Interface function to force use of a given normalization range; 3369/// to interpret function value. Needed for functions or p.d.f.s; 3370/// whose shape depends on the choice of normalization such as; 3371/// RooAddPdf; 3372 ; 3373void RooAbsReal::selectNormalizationRange(const char*, bool); 3374{; 3375}; 3376 ; 3377 ; 3378 ; 3379////////////////////////////////////////////////////////////////////////////////; 3380/// Advertise capability to determine maximum value of function for given set of; 3381/// observables. If no direct generator method is provided, this information; 3382/// will assist the accept/reject generator to operate more efficiently as; 3383/// it can skip the initial trial sampling phase to empirically find the function; 3384/// maximum; 3385 ; 3386Int_t RooAbsReal::getMaxVal(const RooArgSet& /*vars*/) const; 3387{; 3388 return 0 ;; 3389}; 3390 ; 3391 ; 3392 ; 3393////////////////////////////////////////////////////////////////////////////////; 3394/// Return maximum value for set of observables identified by code assigned; 3395/// in getMaxVal; 3396 ; 3397double RooAbsReal::maxVal(Int_t /*code*/) const; 3398{; 3399 assert(1) ;; 3400 return 0 ;; 3401}; 3402 ; 3403 ; 3404 ; 3405////////////////////////////////////////////////////////////////////////////////; 3406/// Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream.; 3407 ; 3408void RooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString); 3409{; 3410 if (evalErrorData().mode == Ignore) {; 3411 return ;; 3412 }; 3413 ; 3414 if (evalErrorData().mode == CountErrors) {; 3415 evalErrorData().count++ ;; 3416 return ;; 3417 }; 3418 ; 3419 static bool inLogEvalError = false ;; 3420 ; 3421 if (inLogEvalError) {; 3422 return ;; 3423 }; 3424 inLogEvalError = true ;; 3425 ; 3426 EvalError ee ;; 3427 ee.setMessage(message) ;; 3428 ; 3429 if (serverVa",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:146263,Testability,log,logging,146263,"///////////////////////; 3368/// Interface function to force use of a given normalization range; 3369/// to interpret function value. Needed for functions or p.d.f.s; 3370/// whose shape depends on the choice of normalization such as; 3371/// RooAddPdf; 3372 ; 3373void RooAbsReal::selectNormalizationRange(const char*, bool); 3374{; 3375}; 3376 ; 3377 ; 3378 ; 3379////////////////////////////////////////////////////////////////////////////////; 3380/// Advertise capability to determine maximum value of function for given set of; 3381/// observables. If no direct generator method is provided, this information; 3382/// will assist the accept/reject generator to operate more efficiently as; 3383/// it can skip the initial trial sampling phase to empirically find the function; 3384/// maximum; 3385 ; 3386Int_t RooAbsReal::getMaxVal(const RooArgSet& /*vars*/) const; 3387{; 3388 return 0 ;; 3389}; 3390 ; 3391 ; 3392 ; 3393////////////////////////////////////////////////////////////////////////////////; 3394/// Return maximum value for set of observables identified by code assigned; 3395/// in getMaxVal; 3396 ; 3397double RooAbsReal::maxVal(Int_t /*code*/) const; 3398{; 3399 assert(1) ;; 3400 return 0 ;; 3401}; 3402 ; 3403 ; 3404 ; 3405////////////////////////////////////////////////////////////////////////////////; 3406/// Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream.; 3407 ; 3408void RooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString); 3409{; 3410 if (evalErrorData().mode == Ignore) {; 3411 return ;; 3412 }; 3413 ; 3414 if (evalErrorData().mode == CountErrors) {; 3415 evalErrorData().count++ ;; 3416 return ;; 3417 }; 3418 ; 3419 static bool inLogEvalError = false ;; 3420 ; 3421 if (inLogEvalError) {; 3422 return ;; 3423 }; 3424 inLogEvalError = true ;; 3425 ; 3426 EvalError ee ;; 3427 ee.setMessage(message) ;; 3428 ; 3429 if (serverVa",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:146323,Testability,log,logging,146323,"///////////////////////; 3368/// Interface function to force use of a given normalization range; 3369/// to interpret function value. Needed for functions or p.d.f.s; 3370/// whose shape depends on the choice of normalization such as; 3371/// RooAddPdf; 3372 ; 3373void RooAbsReal::selectNormalizationRange(const char*, bool); 3374{; 3375}; 3376 ; 3377 ; 3378 ; 3379////////////////////////////////////////////////////////////////////////////////; 3380/// Advertise capability to determine maximum value of function for given set of; 3381/// observables. If no direct generator method is provided, this information; 3382/// will assist the accept/reject generator to operate more efficiently as; 3383/// it can skip the initial trial sampling phase to empirically find the function; 3384/// maximum; 3385 ; 3386Int_t RooAbsReal::getMaxVal(const RooArgSet& /*vars*/) const; 3387{; 3388 return 0 ;; 3389}; 3390 ; 3391 ; 3392 ; 3393////////////////////////////////////////////////////////////////////////////////; 3394/// Return maximum value for set of observables identified by code assigned; 3395/// in getMaxVal; 3396 ; 3397double RooAbsReal::maxVal(Int_t /*code*/) const; 3398{; 3399 assert(1) ;; 3400 return 0 ;; 3401}; 3402 ; 3403 ; 3404 ; 3405////////////////////////////////////////////////////////////////////////////////; 3406/// Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream.; 3407 ; 3408void RooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString); 3409{; 3410 if (evalErrorData().mode == Ignore) {; 3411 return ;; 3412 }; 3413 ; 3414 if (evalErrorData().mode == CountErrors) {; 3415 evalErrorData().count++ ;; 3416 return ;; 3417 }; 3418 ; 3419 static bool inLogEvalError = false ;; 3420 ; 3421 if (inLogEvalError) {; 3422 return ;; 3423 }; 3424 inLogEvalError = true ;; 3425 ; 3426 EvalError ee ;; 3427 ee.setMessage(message) ;; 3428 ; 3429 if (serverVa",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:146368,Testability,log,logEvalError,146368,"81/// observables. If no direct generator method is provided, this information; 3382/// will assist the accept/reject generator to operate more efficiently as; 3383/// it can skip the initial trial sampling phase to empirically find the function; 3384/// maximum; 3385 ; 3386Int_t RooAbsReal::getMaxVal(const RooArgSet& /*vars*/) const; 3387{; 3388 return 0 ;; 3389}; 3390 ; 3391 ; 3392 ; 3393////////////////////////////////////////////////////////////////////////////////; 3394/// Return maximum value for set of observables identified by code assigned; 3395/// in getMaxVal; 3396 ; 3397double RooAbsReal::maxVal(Int_t /*code*/) const; 3398{; 3399 assert(1) ;; 3400 return 0 ;; 3401}; 3402 ; 3403 ; 3404 ; 3405////////////////////////////////////////////////////////////////////////////////; 3406/// Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream.; 3407 ; 3408void RooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString); 3409{; 3410 if (evalErrorData().mode == Ignore) {; 3411 return ;; 3412 }; 3413 ; 3414 if (evalErrorData().mode == CountErrors) {; 3415 evalErrorData().count++ ;; 3416 return ;; 3417 }; 3418 ; 3419 static bool inLogEvalError = false ;; 3420 ; 3421 if (inLogEvalError) {; 3422 return ;; 3423 }; 3424 inLogEvalError = true ;; 3425 ; 3426 EvalError ee ;; 3427 ee.setMessage(message) ;; 3428 ; 3429 if (serverValueString) {; 3430 ee.setServerValues(serverValueString) ;; 3431 }; 3432 ; 3433 if (evalErrorData().mode == PrintErrors) {; 3434 oocoutE(nullptr,Eval) << ""RooAbsReal::logEvalError("" << ""<STATIC>"" << "") evaluation error, "" << std::endl; 3435 << "" origin : "" << origName << std::endl; 3436 << "" message : "" << ee._msg << std::endl; 3437 << "" server values: "" << ee._srvval << std::endl ;; 3438 } else if (evalErrorData().mode == CollectErrors) {; 3439 auto &evalErrorList = evalErrorData().errorList[originator];; 3440 evalErrorList.first",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:147059,Testability,log,logEvalError,147059,"eturn 0 ;; 3401}; 3402 ; 3403 ; 3404 ; 3405////////////////////////////////////////////////////////////////////////////////; 3406/// Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream.; 3407 ; 3408void RooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString); 3409{; 3410 if (evalErrorData().mode == Ignore) {; 3411 return ;; 3412 }; 3413 ; 3414 if (evalErrorData().mode == CountErrors) {; 3415 evalErrorData().count++ ;; 3416 return ;; 3417 }; 3418 ; 3419 static bool inLogEvalError = false ;; 3420 ; 3421 if (inLogEvalError) {; 3422 return ;; 3423 }; 3424 inLogEvalError = true ;; 3425 ; 3426 EvalError ee ;; 3427 ee.setMessage(message) ;; 3428 ; 3429 if (serverValueString) {; 3430 ee.setServerValues(serverValueString) ;; 3431 }; 3432 ; 3433 if (evalErrorData().mode == PrintErrors) {; 3434 oocoutE(nullptr,Eval) << ""RooAbsReal::logEvalError("" << ""<STATIC>"" << "") evaluation error, "" << std::endl; 3435 << "" origin : "" << origName << std::endl; 3436 << "" message : "" << ee._msg << std::endl; 3437 << "" server values: "" << ee._srvval << std::endl ;; 3438 } else if (evalErrorData().mode == CollectErrors) {; 3439 auto &evalErrorList = evalErrorData().errorList[originator];; 3440 evalErrorList.first = origName ;; 3441 evalErrorList.second.push_back(ee) ;; 3442 }; 3443 ; 3444 ; 3445 inLogEvalError = false ;; 3446}; 3447 ; 3448 ; 3449 ; 3450////////////////////////////////////////////////////////////////////////////////; 3451/// Log evaluation error message. Evaluation errors may be routed through a different; 3452/// protocol than generic RooFit warning message (which go straight through RooMsgService); 3453/// because evaluation errors can occur in very large numbers in the use of likelihood; 3454/// evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); 3455/// messages reported through this function are not printed but a",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:147956,Testability,log,logEvalError,147956,"lError("" << ""<STATIC>"" << "") evaluation error, "" << std::endl; 3435 << "" origin : "" << origName << std::endl; 3436 << "" message : "" << ee._msg << std::endl; 3437 << "" server values: "" << ee._srvval << std::endl ;; 3438 } else if (evalErrorData().mode == CollectErrors) {; 3439 auto &evalErrorList = evalErrorData().errorList[originator];; 3440 evalErrorList.first = origName ;; 3441 evalErrorList.second.push_back(ee) ;; 3442 }; 3443 ; 3444 ; 3445 inLogEvalError = false ;; 3446}; 3447 ; 3448 ; 3449 ; 3450////////////////////////////////////////////////////////////////////////////////; 3451/// Log evaluation error message. Evaluation errors may be routed through a different; 3452/// protocol than generic RooFit warning message (which go straight through RooMsgService); 3453/// because evaluation errors can occur in very large numbers in the use of likelihood; 3454/// evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); 3455/// messages reported through this function are not printed but all stored in a list,; 3456/// along with server values at the time of reporting. Error messages logged in this; 3457/// way can be printed in a structured way, eliminating duplicates and with the ability; 3458/// to truncate the list by printEvalErrors. This is the standard mode of error logging; 3459/// during MINUIT operations. If enableEvalErrorLogging() is false, all errors; 3460/// reported through this method are passed for immediate printing through RooMsgService.; 3461/// A string with server names and values is constructed automatically for error logging; 3462/// purposes, unless a custom string with similar information is passed as argument.; 3463 ; 3464void RooAbsReal::logEvalError(const char* message, const char* serverValueString) const; 3465{; 3466 if (evalErrorData().mode == Ignore) {; 3467 return ;; 3468 }; 3469 ; 3470 if (evalErrorData().mode == CountErrors) {; 3471 evalErrorData().count++ ;; 3472 return ;; 3473 }; 3474 ; 3475 static bo",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:148194,Testability,log,logged,148194,"< std::endl ;; 3438 } else if (evalErrorData().mode == CollectErrors) {; 3439 auto &evalErrorList = evalErrorData().errorList[originator];; 3440 evalErrorList.first = origName ;; 3441 evalErrorList.second.push_back(ee) ;; 3442 }; 3443 ; 3444 ; 3445 inLogEvalError = false ;; 3446}; 3447 ; 3448 ; 3449 ; 3450////////////////////////////////////////////////////////////////////////////////; 3451/// Log evaluation error message. Evaluation errors may be routed through a different; 3452/// protocol than generic RooFit warning message (which go straight through RooMsgService); 3453/// because evaluation errors can occur in very large numbers in the use of likelihood; 3454/// evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); 3455/// messages reported through this function are not printed but all stored in a list,; 3456/// along with server values at the time of reporting. Error messages logged in this; 3457/// way can be printed in a structured way, eliminating duplicates and with the ability; 3458/// to truncate the list by printEvalErrors. This is the standard mode of error logging; 3459/// during MINUIT operations. If enableEvalErrorLogging() is false, all errors; 3460/// reported through this method are passed for immediate printing through RooMsgService.; 3461/// A string with server names and values is constructed automatically for error logging; 3462/// purposes, unless a custom string with similar information is passed as argument.; 3463 ; 3464void RooAbsReal::logEvalError(const char* message, const char* serverValueString) const; 3465{; 3466 if (evalErrorData().mode == Ignore) {; 3467 return ;; 3468 }; 3469 ; 3470 if (evalErrorData().mode == CountErrors) {; 3471 evalErrorData().count++ ;; 3472 return ;; 3473 }; 3474 ; 3475 static bool inLogEvalError = false ;; 3476 ; 3477 if (inLogEvalError) {; 3478 return ;; 3479 }; 3480 inLogEvalError = true ;; 3481 ; 3482 EvalError ee ;; 3483 ee.setMessage(message) ;; 3484 ; 3485 if (serverVa",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:148387,Testability,log,logging,148387,"originator];; 3440 evalErrorList.first = origName ;; 3441 evalErrorList.second.push_back(ee) ;; 3442 }; 3443 ; 3444 ; 3445 inLogEvalError = false ;; 3446}; 3447 ; 3448 ; 3449 ; 3450////////////////////////////////////////////////////////////////////////////////; 3451/// Log evaluation error message. Evaluation errors may be routed through a different; 3452/// protocol than generic RooFit warning message (which go straight through RooMsgService); 3453/// because evaluation errors can occur in very large numbers in the use of likelihood; 3454/// evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); 3455/// messages reported through this function are not printed but all stored in a list,; 3456/// along with server values at the time of reporting. Error messages logged in this; 3457/// way can be printed in a structured way, eliminating duplicates and with the ability; 3458/// to truncate the list by printEvalErrors. This is the standard mode of error logging; 3459/// during MINUIT operations. If enableEvalErrorLogging() is false, all errors; 3460/// reported through this method are passed for immediate printing through RooMsgService.; 3461/// A string with server names and values is constructed automatically for error logging; 3462/// purposes, unless a custom string with similar information is passed as argument.; 3463 ; 3464void RooAbsReal::logEvalError(const char* message, const char* serverValueString) const; 3465{; 3466 if (evalErrorData().mode == Ignore) {; 3467 return ;; 3468 }; 3469 ; 3470 if (evalErrorData().mode == CountErrors) {; 3471 evalErrorData().count++ ;; 3472 return ;; 3473 }; 3474 ; 3475 static bool inLogEvalError = false ;; 3476 ; 3477 if (inLogEvalError) {; 3478 return ;; 3479 }; 3480 inLogEvalError = true ;; 3481 ; 3482 EvalError ee ;; 3483 ee.setMessage(message) ;; 3484 ; 3485 if (serverValueString) {; 3486 ee.setServerValues(serverValueString) ;; 3487 } else {; 3488 std::string srvval ;; 3489 std::ostringstream",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:148660,Testability,log,logging,148660,"evaluation error message. Evaluation errors may be routed through a different; 3452/// protocol than generic RooFit warning message (which go straight through RooMsgService); 3453/// because evaluation errors can occur in very large numbers in the use of likelihood; 3454/// evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); 3455/// messages reported through this function are not printed but all stored in a list,; 3456/// along with server values at the time of reporting. Error messages logged in this; 3457/// way can be printed in a structured way, eliminating duplicates and with the ability; 3458/// to truncate the list by printEvalErrors. This is the standard mode of error logging; 3459/// during MINUIT operations. If enableEvalErrorLogging() is false, all errors; 3460/// reported through this method are passed for immediate printing through RooMsgService.; 3461/// A string with server names and values is constructed automatically for error logging; 3462/// purposes, unless a custom string with similar information is passed as argument.; 3463 ; 3464void RooAbsReal::logEvalError(const char* message, const char* serverValueString) const; 3465{; 3466 if (evalErrorData().mode == Ignore) {; 3467 return ;; 3468 }; 3469 ; 3470 if (evalErrorData().mode == CountErrors) {; 3471 evalErrorData().count++ ;; 3472 return ;; 3473 }; 3474 ; 3475 static bool inLogEvalError = false ;; 3476 ; 3477 if (inLogEvalError) {; 3478 return ;; 3479 }; 3480 inLogEvalError = true ;; 3481 ; 3482 EvalError ee ;; 3483 ee.setMessage(message) ;; 3484 ; 3485 if (serverValueString) {; 3486 ee.setServerValues(serverValueString) ;; 3487 } else {; 3488 std::string srvval ;; 3489 std::ostringstream oss ;; 3490 bool first(true) ;; 3491 for (Int_t i=0 ; i<numProxies() ; i++) {; 3492 RooAbsProxy* p = getProxy(i) ;; 3493 if (!p) continue ;; 3494 //if (p->name()[0]=='!') continue ;; 3495 if (first) {; 3496 first=false ;; 3497 } else {; 3498 oss << "", "" ;; 3499 }; 3500 p->p",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:148787,Testability,log,logEvalError,148787,"RooMsgService); 3453/// because evaluation errors can occur in very large numbers in the use of likelihood; 3454/// evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); 3455/// messages reported through this function are not printed but all stored in a list,; 3456/// along with server values at the time of reporting. Error messages logged in this; 3457/// way can be printed in a structured way, eliminating duplicates and with the ability; 3458/// to truncate the list by printEvalErrors. This is the standard mode of error logging; 3459/// during MINUIT operations. If enableEvalErrorLogging() is false, all errors; 3460/// reported through this method are passed for immediate printing through RooMsgService.; 3461/// A string with server names and values is constructed automatically for error logging; 3462/// purposes, unless a custom string with similar information is passed as argument.; 3463 ; 3464void RooAbsReal::logEvalError(const char* message, const char* serverValueString) const; 3465{; 3466 if (evalErrorData().mode == Ignore) {; 3467 return ;; 3468 }; 3469 ; 3470 if (evalErrorData().mode == CountErrors) {; 3471 evalErrorData().count++ ;; 3472 return ;; 3473 }; 3474 ; 3475 static bool inLogEvalError = false ;; 3476 ; 3477 if (inLogEvalError) {; 3478 return ;; 3479 }; 3480 inLogEvalError = true ;; 3481 ; 3482 EvalError ee ;; 3483 ee.setMessage(message) ;; 3484 ; 3485 if (serverValueString) {; 3486 ee.setServerValues(serverValueString) ;; 3487 } else {; 3488 std::string srvval ;; 3489 std::ostringstream oss ;; 3490 bool first(true) ;; 3491 for (Int_t i=0 ; i<numProxies() ; i++) {; 3492 RooAbsProxy* p = getProxy(i) ;; 3493 if (!p) continue ;; 3494 //if (p->name()[0]=='!') continue ;; 3495 if (first) {; 3496 first=false ;; 3497 } else {; 3498 oss << "", "" ;; 3499 }; 3500 p->print(oss,true) ;; 3501 }; 3502 ee.setServerValues(oss.str().c_str()) ;; 3503 }; 3504 ; 3505 std::ostringstream oss2 ;; 3506 printStream(oss2,kName|kClassName|k",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:149930,Testability,log,logEvalError,149930,"valErrorData().mode == CountErrors) {; 3471 evalErrorData().count++ ;; 3472 return ;; 3473 }; 3474 ; 3475 static bool inLogEvalError = false ;; 3476 ; 3477 if (inLogEvalError) {; 3478 return ;; 3479 }; 3480 inLogEvalError = true ;; 3481 ; 3482 EvalError ee ;; 3483 ee.setMessage(message) ;; 3484 ; 3485 if (serverValueString) {; 3486 ee.setServerValues(serverValueString) ;; 3487 } else {; 3488 std::string srvval ;; 3489 std::ostringstream oss ;; 3490 bool first(true) ;; 3491 for (Int_t i=0 ; i<numProxies() ; i++) {; 3492 RooAbsProxy* p = getProxy(i) ;; 3493 if (!p) continue ;; 3494 //if (p->name()[0]=='!') continue ;; 3495 if (first) {; 3496 first=false ;; 3497 } else {; 3498 oss << "", "" ;; 3499 }; 3500 p->print(oss,true) ;; 3501 }; 3502 ee.setServerValues(oss.str().c_str()) ;; 3503 }; 3504 ; 3505 std::ostringstream oss2 ;; 3506 printStream(oss2,kName|kClassName|kArgs,kInline) ;; 3507 ; 3508 if (evalErrorData().mode == PrintErrors) {; 3509 coutE(Eval) << ""RooAbsReal::logEvalError("" << GetName() << "") evaluation error, "" << std::endl; 3510 << "" origin : "" << oss2.str() << std::endl; 3511 << "" message : "" << ee._msg << std::endl; 3512 << "" server values: "" << ee._srvval << std::endl ;; 3513 } else if (evalErrorData().mode == CollectErrors) {; 3514 auto &evalErrorList = evalErrorData().errorList[this];; 3515 if (evalErrorList.second.size() >= 2048) {; 3516 // avoid overflowing the error list, so if there are very many, print; 3517 // the oldest one first, and pop it off the list; 3518 const EvalError& oee = evalErrorList.second.front();; 3519 // print to debug stream, since these would normally be suppressed, and; 3520 // we do not want to increase the error count in the message service...; 3521 ccoutD(Eval) << ""RooAbsReal::logEvalError("" << GetName(); 3522 << "") delayed evaluation error, "" << std::endl; 3523 << "" origin : "" << oss2.str() << std::endl; 3524 << "" message : "" << oee._msg << std::endl; 3525 << "" server values: "" << oee._srvval << std::endl ;; 3526 evalError",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:150699,Testability,log,logEvalError,150699," 3503 }; 3504 ; 3505 std::ostringstream oss2 ;; 3506 printStream(oss2,kName|kClassName|kArgs,kInline) ;; 3507 ; 3508 if (evalErrorData().mode == PrintErrors) {; 3509 coutE(Eval) << ""RooAbsReal::logEvalError("" << GetName() << "") evaluation error, "" << std::endl; 3510 << "" origin : "" << oss2.str() << std::endl; 3511 << "" message : "" << ee._msg << std::endl; 3512 << "" server values: "" << ee._srvval << std::endl ;; 3513 } else if (evalErrorData().mode == CollectErrors) {; 3514 auto &evalErrorList = evalErrorData().errorList[this];; 3515 if (evalErrorList.second.size() >= 2048) {; 3516 // avoid overflowing the error list, so if there are very many, print; 3517 // the oldest one first, and pop it off the list; 3518 const EvalError& oee = evalErrorList.second.front();; 3519 // print to debug stream, since these would normally be suppressed, and; 3520 // we do not want to increase the error count in the message service...; 3521 ccoutD(Eval) << ""RooAbsReal::logEvalError("" << GetName(); 3522 << "") delayed evaluation error, "" << std::endl; 3523 << "" origin : "" << oss2.str() << std::endl; 3524 << "" message : "" << oee._msg << std::endl; 3525 << "" server values: "" << oee._srvval << std::endl ;; 3526 evalErrorList.second.pop_front();; 3527 }; 3528 evalErrorList.first = oss2.str() ;; 3529 evalErrorList.second.push_back(ee) ;; 3530 }; 3531 ; 3532 inLogEvalError = false ;; 3533 //coutE(Tracing) << ""RooAbsReal::logEvalError("" << GetName() << "") message = "" << message << std::endl ;; 3534}; 3535 ; 3536 ; 3537 ; 3538 ; 3539////////////////////////////////////////////////////////////////////////////////; 3540/// Clear the stack of evaluation error messages; 3541 ; 3542void RooAbsReal::clearEvalErrorLog(); 3543{; 3544 if (evalErrorData().mode == PrintErrors) {; 3545 return ;; 3546 } else if (evalErrorData().mode == CollectErrors) {; 3547 evalErrorData().errorList.clear() ;; 3548 } else {; 3549 evalErrorData().count = 0 ;; 3550 }; 3551}; 3552 ; 3553 ; 3554///////////////////////////////////",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:151152,Testability,log,logEvalError,151152,"];; 3515 if (evalErrorList.second.size() >= 2048) {; 3516 // avoid overflowing the error list, so if there are very many, print; 3517 // the oldest one first, and pop it off the list; 3518 const EvalError& oee = evalErrorList.second.front();; 3519 // print to debug stream, since these would normally be suppressed, and; 3520 // we do not want to increase the error count in the message service...; 3521 ccoutD(Eval) << ""RooAbsReal::logEvalError("" << GetName(); 3522 << "") delayed evaluation error, "" << std::endl; 3523 << "" origin : "" << oss2.str() << std::endl; 3524 << "" message : "" << oee._msg << std::endl; 3525 << "" server values: "" << oee._srvval << std::endl ;; 3526 evalErrorList.second.pop_front();; 3527 }; 3528 evalErrorList.first = oss2.str() ;; 3529 evalErrorList.second.push_back(ee) ;; 3530 }; 3531 ; 3532 inLogEvalError = false ;; 3533 //coutE(Tracing) << ""RooAbsReal::logEvalError("" << GetName() << "") message = "" << message << std::endl ;; 3534}; 3535 ; 3536 ; 3537 ; 3538 ; 3539////////////////////////////////////////////////////////////////////////////////; 3540/// Clear the stack of evaluation error messages; 3541 ; 3542void RooAbsReal::clearEvalErrorLog(); 3543{; 3544 if (evalErrorData().mode == PrintErrors) {; 3545 return ;; 3546 } else if (evalErrorData().mode == CollectErrors) {; 3547 evalErrorData().errorList.clear() ;; 3548 } else {; 3549 evalErrorData().count = 0 ;; 3550 }; 3551}; 3552 ; 3553 ; 3554////////////////////////////////////////////////////////////////////////////////; 3555/// Retrieve bin boundaries if this distribution is binned in `obs`.; 3556/// \param[in] obs Observable to retrieve boundaries for.; 3557/// \param[in] xlo Beginning of range.; 3558/// \param[in] xhi End of range.; 3559/// \return The caller owns the returned std::list.; 3560std::list<double>* RooAbsReal::binBoundaries(RooAbsRealLValue& /*obs*/, double /*xlo*/, double /*xhi*/) const {; 3561 return nullptr;; 3562}; 3563 ; 3564 ; 3565//////////////////////////////////////////",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:152918,Testability,log,logged,152918,"n boundaries if this distribution is binned in `obs`.; 3556/// \param[in] obs Observable to retrieve boundaries for.; 3557/// \param[in] xlo Beginning of range.; 3558/// \param[in] xhi End of range.; 3559/// \return The caller owns the returned std::list.; 3560std::list<double>* RooAbsReal::binBoundaries(RooAbsRealLValue& /*obs*/, double /*xlo*/, double /*xhi*/) const {; 3561 return nullptr;; 3562}; 3563 ; 3564 ; 3565////////////////////////////////////////////////////////////////////////////////; 3566/// Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable `obs`.; 3567/// \param[in] obs Observable to retrieve sampling hint for.; 3568/// \param[in] xlo Beginning of range.; 3569/// \param[in] xhi End of range.; 3570/// \return The caller owns the returned std::list.; 3571std::list<double>* RooAbsReal::plotSamplingHint(RooAbsRealLValue& /*obs*/, double /*xlo*/, double /*xhi*/) const {; 3572 return nullptr;; 3573}; 3574 ; 3575////////////////////////////////////////////////////////////////////////////////; 3576/// Print all outstanding logged evaluation error on the given ostream. If maxPerNode; 3577/// is zero, only the number of errors for each source (object with unique name) is listed.; 3578/// If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; 3579/// per source of errors. A truncation message is shown if there were more errors logged; 3580/// than shown.; 3581 ; 3582void RooAbsReal::printEvalErrors(std::ostream &os, Int_t maxPerNode); 3583{; 3584 if (evalErrorData().mode == CountErrors) {; 3585 os << evalErrorData().count << "" errors counted"" << std::endl;; 3586 }; 3587 ; 3588 if (maxPerNode < 0); 3589 return;; 3590 ; 3591 for (auto const &item : evalErrorData().errorList) {; 3592 if (maxPerNode == 0) {; 3593 ; 3594 // Only print node name with total number of errors; 3595 os << item.second.first;; 3596 // item.first->printStream(os,kName|kClassName|kArgs,kInline",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:153258,Testability,log,logged,153258,"/////////////////////////////////////////////////////////////; 3566/// Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable `obs`.; 3567/// \param[in] obs Observable to retrieve sampling hint for.; 3568/// \param[in] xlo Beginning of range.; 3569/// \param[in] xhi End of range.; 3570/// \return The caller owns the returned std::list.; 3571std::list<double>* RooAbsReal::plotSamplingHint(RooAbsRealLValue& /*obs*/, double /*xlo*/, double /*xhi*/) const {; 3572 return nullptr;; 3573}; 3574 ; 3575////////////////////////////////////////////////////////////////////////////////; 3576/// Print all outstanding logged evaluation error on the given ostream. If maxPerNode; 3577/// is zero, only the number of errors for each source (object with unique name) is listed.; 3578/// If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; 3579/// per source of errors. A truncation message is shown if there were more errors logged; 3580/// than shown.; 3581 ; 3582void RooAbsReal::printEvalErrors(std::ostream &os, Int_t maxPerNode); 3583{; 3584 if (evalErrorData().mode == CountErrors) {; 3585 os << evalErrorData().count << "" errors counted"" << std::endl;; 3586 }; 3587 ; 3588 if (maxPerNode < 0); 3589 return;; 3590 ; 3591 for (auto const &item : evalErrorData().errorList) {; 3592 if (maxPerNode == 0) {; 3593 ; 3594 // Only print node name with total number of errors; 3595 os << item.second.first;; 3596 // item.first->printStream(os,kName|kClassName|kArgs,kInline) ;; 3597 os << "" has "" << item.second.second.size() << "" errors"" << std::endl;; 3598 ; 3599 } else {; 3600 ; 3601 // Print node name and details of 'maxPerNode' errors; 3602 os << item.second.first << std::endl;; 3603 // item.first->printStream(os,kName|kClassName|kArgs,kSingleLine) ;; 3604 ; 3605 Int_t i(0);; 3606 for (auto const &item2 : item.second.second) {; 3607 os << "" "" << item2._msg << "" @ "" << item2._srvval << std::endl;; 360",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:154587,Testability,log,logged,154587,"<< std::endl;; 3586 }; 3587 ; 3588 if (maxPerNode < 0); 3589 return;; 3590 ; 3591 for (auto const &item : evalErrorData().errorList) {; 3592 if (maxPerNode == 0) {; 3593 ; 3594 // Only print node name with total number of errors; 3595 os << item.second.first;; 3596 // item.first->printStream(os,kName|kClassName|kArgs,kInline) ;; 3597 os << "" has "" << item.second.second.size() << "" errors"" << std::endl;; 3598 ; 3599 } else {; 3600 ; 3601 // Print node name and details of 'maxPerNode' errors; 3602 os << item.second.first << std::endl;; 3603 // item.first->printStream(os,kName|kClassName|kArgs,kSingleLine) ;; 3604 ; 3605 Int_t i(0);; 3606 for (auto const &item2 : item.second.second) {; 3607 os << "" "" << item2._msg << "" @ "" << item2._srvval << std::endl;; 3608 if (i > maxPerNode) {; 3609 os << "" ... (remaining "" << item.second.second.size() - maxPerNode << "" messages suppressed)""; 3610 << std::endl;; 3611 break;; 3612 }; 3613 i++;; 3614 }; 3615 }; 3616 }; 3617}; 3618 ; 3619 ; 3620 ; 3621////////////////////////////////////////////////////////////////////////////////; 3622/// Return the number of logged evaluation errors since the last clearing.; 3623 ; 3624Int_t RooAbsReal::numEvalErrors(); 3625{; 3626 auto &evalErrors = evalErrorData();; 3627 if (evalErrors.mode == CountErrors) {; 3628 return evalErrors.count;; 3629 }; 3630 ; 3631 Int_t ntot(0);; 3632 for (auto const &elem : evalErrors.errorList) {; 3633 ntot += elem.second.second.size();; 3634 }; 3635 return ntot;; 3636}; 3637 ; 3638 ; 3639 ; 3640////////////////////////////////////////////////////////////////////////////////; 3641/// Fix the interpretation of the coefficient of any RooAddPdf component in; 3642/// the expression tree headed by this object to the given set of observables.; 3643///; 3644/// If the force flag is false, the normalization choice is only fixed for those; 3645/// RooAddPdf components that have the default 'automatic' interpretation of; 3646/// coefficients (i.e. the interpretation is defined",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:190104,Testability,log,logging,190104,"| `Integrate(bool flag)` | Integrate function over range specified by X errors rather than take value at bin center.; 4274///; 4275 ; 4276RooFit::OwningPtr<RooAbsReal> RooAbsReal::createChi2(RooDataSet& data, const RooCmdArg& arg1, const RooCmdArg& arg2,; 4277 const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5,; 4278 const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 4279{; 4280 RooLinkedList l ;; 4281 l.Add((TObject*)&arg1) ; l.Add((TObject*)&arg2) ;; 4282 l.Add((TObject*)&arg3) ; l.Add((TObject*)&arg4) ;; 4283 l.Add((TObject*)&arg5) ; l.Add((TObject*)&arg6) ;; 4284 l.Add((TObject*)&arg7) ; l.Add((TObject*)&arg8) ;; 4285 return createChi2(data,l) ;; 4286}; 4287 ; 4288 ; 4289////////////////////////////////////////////////////////////////////////////////; 4290/// See RooAbsReal::createChi2(RooDataSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&); 4291 ; 4292RooFit::OwningPtr<RooAbsReal> RooAbsReal::createChi2(RooDataSet &data, const RooLinkedList &cmdList); 4293{; 4294 return RooFit::makeOwningPtr(RooFit::FitHelpers::createChi2(*this, data, cmdList));; 4295}; 4296 ; 4297 ; 4298 ; 4299////////////////////////////////////////////////////////////////////////////////; 4300/// Return current evaluation error logging mode.; 4301 ; 4302RooAbsReal::ErrorLoggingMode RooAbsReal::evalErrorLoggingMode(); 4303{; 4304 return evalErrorData().mode ;; 4305}; 4306 ; 4307////////////////////////////////////////////////////////////////////////////////; 4308/// Set evaluation error logging mode. Options are; 4309///; 4310/// PrintErrors - Print each error through RooMsgService() as it occurs; 4311/// CollectErrors - Accumulate errors, but do not print them. A subsequent call; 4312/// to printEvalErrors() will print a summary; 4313/// CountErrors - Accumulate error count, but do not print them.; 4314///; 4315 ; 4316void RooAbsReal::setEvalErrorLoggingMode(RooAbsR",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:190367,Testability,log,logging,190367,"3 l.Add((TObject*)&arg5) ; l.Add((TObject*)&arg6) ;; 4284 l.Add((TObject*)&arg7) ; l.Add((TObject*)&arg8) ;; 4285 return createChi2(data,l) ;; 4286}; 4287 ; 4288 ; 4289////////////////////////////////////////////////////////////////////////////////; 4290/// See RooAbsReal::createChi2(RooDataSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&); 4291 ; 4292RooFit::OwningPtr<RooAbsReal> RooAbsReal::createChi2(RooDataSet &data, const RooLinkedList &cmdList); 4293{; 4294 return RooFit::makeOwningPtr(RooFit::FitHelpers::createChi2(*this, data, cmdList));; 4295}; 4296 ; 4297 ; 4298 ; 4299////////////////////////////////////////////////////////////////////////////////; 4300/// Return current evaluation error logging mode.; 4301 ; 4302RooAbsReal::ErrorLoggingMode RooAbsReal::evalErrorLoggingMode(); 4303{; 4304 return evalErrorData().mode ;; 4305}; 4306 ; 4307////////////////////////////////////////////////////////////////////////////////; 4308/// Set evaluation error logging mode. Options are; 4309///; 4310/// PrintErrors - Print each error through RooMsgService() as it occurs; 4311/// CollectErrors - Accumulate errors, but do not print them. A subsequent call; 4312/// to printEvalErrors() will print a summary; 4313/// CountErrors - Accumulate error count, but do not print them.; 4314///; 4315 ; 4316void RooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); 4317{; 4318 evalErrorData().mode = m;; 4319}; 4320 ; 4321 ; 4322////////////////////////////////////////////////////////////////////////////////; 4323 ; 4324void RooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); 4325{; 4326 std::string plist ;; 4327 for (auto const* arg : paramVars) {; 4328 if (!dependsOnValue(*arg)) {; 4329 coutW(InputArguments) << ""RooAbsReal::setParameterizeIntegral("" << GetName(); 4330 << "") function does not depend on listed parameter "" << arg->GetName() << "", ignoring"" << std::endl ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:203152,Testability,test,testArg,203152," stream()Definition ValueChecking.h:82; RooAbsArgCommon abstract base class for objects that represent a value and a ""shape"" in RooFit.Definition RooAbsArg.h:79; RooAbsArg::dependsOnbool dependsOn(const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) constTest whether we depend on (ie, are served by) any object in the specified collection.Definition RooAbsArg.cxx:850; RooAbsArg::recursiveRedirectServersbool recursiveRedirectServers(const RooAbsCollection &newServerList, bool mustReplaceAll=false, bool nameChange=false, bool recurseInNewSet=true)Recursively replace all servers with the new servers in newSet.Definition RooAbsArg.cxx:1289; RooAbsArg::namePtrconst TNamed * namePtr() constDe-duplicated pointer to this object's name.Definition RooAbsArg.h:535; RooAbsArg::constR__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg constDefinition RooAbsArg.h:145; RooAbsArg::setShapeDirtyvoid setShapeDirty()Notify that a shape-like property (e.g. binning) has changed.Definition RooAbsArg.h:467; RooAbsArg::setStringAttributevoid setStringAttribute(const Text_t *key, const Text_t *value)Associate string 'value' to this object under key 'key'.Definition RooAbsArg.cxx:254; RooAbsArg::isValueDirtyAndClearbool isValueDirtyAndClear() constDefinition RooAbsArg.h:408; RooAbsArg::_fastbool _fastDefinition RooAbsArg.h:689; RooAbsArg::getParametersRooFit::OwningPtr< RooArgSet > getParameters(const RooAbsData *data, bool stripDisconnected=true) constCreate a list of leaf nodes in the arg tree starting with ourself as top node that don't match any of...Definition RooAbsArg.cxx:541; RooAbsArg::getObservablesRooFit::OwningPtr< RooArgSet > getObservables(const RooArgSet &set, bool valueOnly=true) constGiven a set of possible observables, return the observables that this PDF depends on.Definition RooAbsArg.cxx:698; RooAbsArg::",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:223522,Testability,log,logging,223522,"mpact, bool verbose=false) overrideRead object contents from stream (dummy for now)Definition RooAbsReal.cxx:426; RooAbsReal::matchArgsbool matchArgs(const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a) constUtility function for use in getAnalyticalIntegral().Definition RooAbsReal.cxx:3146; RooAbsReal::fillTreeBranchvoid fillTreeBranch(TTree &t) overrideFill the tree branch that associated with this object with its current value.Definition RooAbsReal.cxx:3099; RooAbsReal::printMultilinevoid printMultiline(std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const overrideStructure printing.Definition RooAbsReal.cxx:455; RooAbsReal::plotAsymOnvirtual RooPlot * plotAsymOn(RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) constDefinition RooAbsReal.cxx:2199; RooAbsReal::operator==bool operator==(double value) constEquality operator comparing to a double.Definition RooAbsReal.cxx:250; RooAbsReal::evalErrorLoggingModestatic ErrorLoggingMode evalErrorLoggingMode()Return current evaluation error logging mode.Definition RooAbsReal.cxx:4302; RooAbsReal::redirectServersHookbool redirectServersHook(const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) overrideFunction that is called at the end of redirectServers().Definition RooAbsReal.cxx:4474; RooAbsReal::isValidRealvirtual bool isValidReal(double, bool printError=false) constInterface function to check if given value is a valid value for this object. Returns true unless over...Definition RooAbsReal.h:447; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::printValuevoid printValue(std::ostream &os) const overridePrint object value.Definition RooAbsReal.cxx:445; RooAbsReal::isIdenticalbool isIdentical(const RooAbsArg &other, bool assumeSameType=false) const overrideDefinition RooAbsReal.cxx:270; RooA",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:229403,Testability,log,logged,229403,"t char * getPlotLabel() constGet the label associated with the variable.Definition RooAbsReal.cxx:406; RooAbsReal::createRunningIntegralRooFit::OwningPtr< RooAbsReal > createRunningIntegral(const RooArgSet &iset, const RooArgSet &nset={})Calls createRunningIntegral(const RooArgSet&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&,...Definition RooAbsReal.cxx:3706; RooAbsReal::_specIntegratorConfigstd::unique_ptr< RooNumIntConfig > _specIntegratorConfigDefinition RooAbsReal.h:540; RooAbsReal::getAnalyticalIntegralvirtual Int_t getAnalyticalIntegral(RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) constInterface function getAnalyticalIntergral advertises the analytical integrals that are supported.Definition RooAbsReal.cxx:368; RooAbsReal::evalErrorIterstatic std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter()Definition RooAbsReal.cxx:181; RooAbsReal::numEvalErrorsstatic Int_t numEvalErrors()Return the number of logged evaluation errors since the last clearing.Definition RooAbsReal.cxx:3624; RooAbsReal::setEvalErrorLoggingModestatic void setEvalErrorLoggingMode(ErrorLoggingMode m)Set evaluation error logging mode.Definition RooAbsReal.cxx:4316; RooAbsReal::preferredObservableScanOrdervirtual void preferredObservableScanOrder(const RooArgSet &obs, RooArgSet &orderedObs) constInterface method for function objects to indicate their preferred order of observables for scanning t...Definition RooAbsReal.cxx:3694; RooAbsReal::maxValvirtual double maxVal(Int_t code) constReturn maximum value for set of observables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive integrals over functions ...Definition RooAbsReal.cxx:701; RooAbsReal::integralNameSuffi",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:229595,Testability,log,logging,229595,"RooAbsReal > createRunningIntegral(const RooArgSet &iset, const RooArgSet &nset={})Calls createRunningIntegral(const RooArgSet&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&,...Definition RooAbsReal.cxx:3706; RooAbsReal::_specIntegratorConfigstd::unique_ptr< RooNumIntConfig > _specIntegratorConfigDefinition RooAbsReal.h:540; RooAbsReal::getAnalyticalIntegralvirtual Int_t getAnalyticalIntegral(RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) constInterface function getAnalyticalIntergral advertises the analytical integrals that are supported.Definition RooAbsReal.cxx:368; RooAbsReal::evalErrorIterstatic std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter()Definition RooAbsReal.cxx:181; RooAbsReal::numEvalErrorsstatic Int_t numEvalErrors()Return the number of logged evaluation errors since the last clearing.Definition RooAbsReal.cxx:3624; RooAbsReal::setEvalErrorLoggingModestatic void setEvalErrorLoggingMode(ErrorLoggingMode m)Set evaluation error logging mode.Definition RooAbsReal.cxx:4316; RooAbsReal::preferredObservableScanOrdervirtual void preferredObservableScanOrder(const RooArgSet &obs, RooArgSet &orderedObs) constInterface method for function objects to indicate their preferred order of observables for scanning t...Definition RooAbsReal.cxx:3694; RooAbsReal::maxValvirtual double maxVal(Int_t code) constReturn maximum value for set of observables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive integrals over functions ...Definition RooAbsReal.cxx:701; RooAbsReal::integralNameSuffixTString integralNameSuffix(const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) constConstruct strin",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:230948,Testability,log,logEvalErrorvoid,230948,"servables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive integrals over functions ...Definition RooAbsReal.cxx:701; RooAbsReal::integralNameSuffixTString integralNameSuffix(const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsR",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:230965,Testability,log,logEvalError,230965,"servables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive integrals over functions ...Definition RooAbsReal.cxx:701; RooAbsReal::integralNameSuffixTString integralNameSuffix(const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsR",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:231747,Testability,log,logged,231747,"luate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsReal.cxx:3827; RooAbsReal::enableOffsettingvirtual void enableOffsetting(bool)Definition RooAbsReal.cxx:4484; RooAbsReal::clearEvalErrorLogstatic void clearEvalErrorLog()Clear the stack of evaluation error messages.Definition RooAbsReal.cxx:3542; RooAbsReal::createIntObjRooFit::OwningPtr< RooAbsReal > createIntObj(const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) constInternal utility function for createIntegral() that creates the actual integral object.Definition RooAbsReal.cxx:590; RooAbsReal::functorRooFunctor * functor(const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) constReturn a RooFunctor obje",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:244835,Testability,log,logging,244835,"epresentation of binned data based on the TGraphAsymmErrors class.Definition RooHist.h:29; RooLinkedListCollection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list...Definition RooLinkedList.h:44; RooLinkedList::Deletevoid Delete(Option_t *o=nullptr) overrideRemove all elements in collection and delete all elements NB: Collection does not own elements,...Definition RooLinkedList.cxx:578; RooLinkedList::Addvirtual void Add(TObject *arg)Definition RooLinkedList.h:73; RooLinkedList::beginRooLinkedListIterImpl begin() constDefinition RooLinkedList.cxx:761; RooLinkedList::FindObjectTObject * FindObject(const char *name) const overrideReturn pointer to object with given name.Definition RooLinkedList.cxx:534; RooMomentDefinition RooMoment.h:26; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::isActivebool isActive(T self, RooFit::MsgTopic topic, RooFit::MsgLevel level)Check if logging is active for given object/topic/RooFit::MsgLevel combination.Definition RooMsgService.h:186; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooNumIntConfig::defaultConfigstatic RooNumIntConfig & defaultConfig()Return reference to instance of default numeric integrator configuration object.Definition RooNumIntConfig.cxx:44; RooParamBinningImplementation of RooAbsBinning that constructs a binning with a range definition that depends on ext...Definition RooParamBinning.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::removevoid remove(const char *name=nullptr, bool deleteToo=true)Remove object with given name, or last object added if no name is given.Definition RooPlot.cxx:868; RooPlot::drawBeforebool drawBefore(const char *before, const char *target)Change the order in which our contained objects are dr",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:10417,Usability,clear,clearValueDirty,10417," the cache is clean, return the; 297/// cached value, otherwise recalculate on the fly and refill; 298/// the cache; 299 ; 300double RooAbsReal::getValV(const RooArgSet* nset) const; 301{; 302 if (nset && nset->uniqueId().value() != _lastNormSetId) {; 303 const_cast<RooAbsReal*>(this)->setProxyNormSet(nset);; 304 _lastNormSetId = nset->uniqueId().value();; 305 }; 306 ; 307 if (isValueDirtyAndClear()) {; 308 _value = traceEval(nullptr) ;; 309 // clearValueDirty() ;; 310 }; 311 ; 312 return hideOffset() ? _value + offset() : _value;; 313}; 314 ; 315 ; 316////////////////////////////////////////////////////////////////////////////////; 317/// Calculate current value of object, with error tracing wrapper; 318 ; 319double RooAbsReal::traceEval(const RooArgSet* /*nset*/) const; 320{; 321 double value = evaluate() ;; 322 ; 323 if (TMath::IsNaN(value)) {; 324 logEvalError(""function value is NAN"") ;; 325 }; 326 ; 327 //cxcoutD(Tracing) << ""RooAbsReal::getValF("" << GetName() << "") operMode = "" << _operMode << "" recalculated, new value = "" << value << std::endl ;; 328 ; 329 //Standard tracing code goes here; 330 if (!isValidReal(value)) {; 331 coutW(Tracing) << ""RooAbsReal::traceEval("" << GetName(); 332 << ""): validation failed: "" << value << std::endl ;; 333 }; 334 ; 335 //Call optional subclass tracing code; 336 // traceEvalHook(value) ;; 337 ; 338 return value ;; 339}; 340 ; 341 ; 342 ; 343////////////////////////////////////////////////////////////////////////////////; 344/// Variant of getAnalyticalIntegral that is also passed the normalization set; 345/// that should be applied to the integrand of which the integral is requested.; 346/// For certain operator p.d.f it is useful to overload this function rather; 347/// than analyticalIntegralWN() as the additional normalization information; 348/// may be useful in determining a more efficient decomposition of the; 349/// requested integral.; 350 ; 351Int_t RooAbsReal::getAnalyticalIntegralWN(RooArgSet& allDeps, RooArgSet& a",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:44092,Usability,clear,clearEvalErrorLog,44092,"58 if(bin % (xbins*ybins) == 0) {; 1059 zbin++;; 1060 zvar->setVal(zaxis->GetBinCenter(zbin));; 1061 }; 1062 // fall through to next case...; 1063 case 2:; 1064 if(bin % xbins == 0) {; 1065 ybin= (ybin%ybins) + 1;; 1066 yvar->setVal(yaxis->GetBinCenter(ybin));; 1067 }; 1068 // fall through to next case...; 1069 case 1:; 1070 xbin= (xbin%xbins) + 1;; 1071 xvar->setVal(xaxis->GetBinCenter(xbin));; 1072 break;; 1073 default:; 1074 coutE(InputArguments) << ""RooAbsReal::fillHistogram: Internal Error!"" << std::endl;; 1075 break;; 1076 }; 1077 ; 1078 double result= scaleFactor*projected->getVal();; 1079 if (RooAbsReal::numEvalErrors()>0) {; 1080 coutW(Plotting) << ""WARNING: Function evaluation error(s) at coordinates [x]="" << xvar->getVal() ;; 1081 if (hdim==2) ccoutW(Plotting) << "" [y]="" << yvar->getVal() ;; 1082 if (hdim==3) ccoutW(Plotting) << "" [z]="" << zvar->getVal() ;; 1083 ccoutW(Plotting) << std::endl ;; 1084 // RooAbsReal::printEvalErrors(ccoutW(Plotting),10) ;; 1085 result = 0 ;; 1086 }; 1087 RooAbsReal::clearEvalErrorLog() ;; 1088 ; 1089 hist->SetBinContent(hist->GetBin(xbin,ybin,zbin),result);; 1090 if (setError) {; 1091 hist->SetBinError(hist->GetBin(xbin,ybin,zbin),sqrt(result)) ;; 1092 }; 1093 ; 1094 //cout << ""bin "" << bin << "" -> ("" << xbin << "","" << ybin << "","" << zbin << "") = "" << result << std::endl;; 1095 }; 1096 RooAbsReal::setEvalErrorLoggingMode(RooAbsReal::PrintErrors) ;; 1097 ; 1098 // cleanup; 1099 delete cloneSet;; 1100 ; 1101 return hist;; 1102}; 1103 ; 1104 ; 1105 ; 1106////////////////////////////////////////////////////////////////////////////////; 1107/// Fill a RooDataHist with values sampled from this function at the; 1108/// bin centers. If extendedMode is true, the p.d.f. values is multiplied; 1109/// by the number of expected events in each bin; 1110///; 1111/// An optional scaling by a given scaleFactor can be performed.; 1112/// Returns a pointer to the input RooDataHist, or zero; 1113/// in case of an error.; 1114///; 1115/// If cor",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:116747,Usability,clear,clear,116747," const& absReal) {; 2623 RooLinkedList tmp(plotArgList) ;; 2624 RooCmdConfig::stripCmdList(tmp, ""FillColor"");; 2625 absReal.plotOn(frame, tmp);; 2626 };; 2627 ; 2628 // Generate central value curve; 2629 plotFunc(*this);; 2630 RooCurve* cenCurve = frame->getCurve() ;; 2631 if(!cenCurve){; 2632 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOnWithErrorBand: no curve for central value available"" << std::endl;; 2633 return frame;; 2634 }; 2635 frame->remove(nullptr,false) ;; 2636 ; 2637 RooCurve* band(nullptr) ;; 2638 if (!linMethod) {; 2639 ; 2640 // *** Interval method ***; 2641 //; 2642 // Make N variations of parameters samples from V and visualize N% central interval where N% is defined from Z; 2643 ; 2644 // Clone self for internal use; 2645 RooAbsReal* cloneFunc = static_cast<RooAbsReal*>(cloneTree()) ;; 2646 RooArgSet cloneParams;; 2647 cloneFunc->getObservables(&fr.floatParsFinal(), cloneParams) ;; 2648 RooArgSet errorParams{cloneParams};; 2649 if(params) {; 2650 // clear and fill errorParams only with parameters that both in params and cloneParams; 2651 cloneParams.selectCommon(*params, errorParams);; 2652 }; 2653 ; 2654 // Generate 100 random parameter points distributed according to fit result covariance matrix; 2655 RooAbsPdf* paramPdf = fr.createHessePdf(errorParams) ;; 2656 Int_t n = Int_t(100./TMath::Erfc(Z/sqrt(2.))) ;; 2657 if (n<100) n=100 ;; 2658 ; 2659 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") INFO: visualizing "" << Z << ""-sigma uncertainties in parameters ""; 2660 << errorParams << "" from fit result "" << fr.GetName() << "" using "" << n << "" samplings."" << std::endl ;; 2661 ; 2662 // Generate variation curves with above set of parameter values; 2663 double ymin = frame->GetMinimum() ;; 2664 double ymax = frame->GetMaximum() ;; 2665 std::unique_ptr<RooDataSet> generatedData{paramPdf->generate(errorParams,n)};; 2666 std::vector<RooCurve*> cvec ;; 2667 for (int i=0 ; i<generatedData->numEntries() ; i++) {; 2668 cloneParams",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:119233,Usability,clear,clear,119233," // Cleanup; 2681 delete paramPdf ;; 2682 delete cloneFunc ;; 2683 for (std::vector<RooCurve*>::iterator i=cvec.begin() ; i!=cvec.end() ; ++i) {; 2684 delete (*i) ;; 2685 }; 2686 ; 2687 } else {; 2688 ; 2689 // *** Linear Method ***; 2690 //; 2691 // Make a one-sigma up- and down fluctation for each parameter and visualize; 2692 // a from a linearized calculation as follows; 2693 //; 2694 // error(x) = F(a) C_aa' F(a'); 2695 //; 2696 // Where F(a) = (f(x,a+da) - f(x,a-da))/2; 2697 // and C_aa' is the correlation matrix; 2698 ; 2699 // Strip out parameters with zero error; 2700 RooArgList fpf_stripped;; 2701 for (auto const* frv : static_range_cast<RooRealVar*>(fr.floatParsFinal())) {; 2702 if (frv->getError() > frv->getVal() * std::numeric_limits<double>::epsilon()) {; 2703 fpf_stripped.add(*frv);; 2704 }; 2705 }; 2706 ; 2707 // Clone self for internal use; 2708 RooAbsReal* cloneFunc = static_cast<RooAbsReal*>(cloneTree()) ;; 2709 RooArgSet cloneParams;; 2710 cloneFunc->getObservables(&fpf_stripped, cloneParams) ;; 2711 RooArgSet errorParams{cloneParams};; 2712 if(params) {; 2713 // clear and fill errorParams only with parameters that both in params and cloneParams; 2714 cloneParams.selectCommon(*params, errorParams);; 2715 }; 2716 ; 2717 ; 2718 // Make list of parameter instances of cloneFunc in order of error matrix; 2719 RooArgList paramList ;; 2720 const RooArgList& fpf = fr.floatParsFinal() ;; 2721 std::vector<int> fpf_idx ;; 2722 for (std::size_t i=0 ; i<fpf.size() ; i++) {; 2723 RooAbsArg* par = errorParams.find(fpf[i].GetName()) ;; 2724 if (par) {; 2725 paramList.add(*par) ;; 2726 fpf_idx.push_back(i) ;; 2727 }; 2728 }; 2729 ; 2730 std::vector<RooCurve *> plusVar;; 2731 std::vector<RooCurve *> minusVar;; 2732 ; 2733 // Create std::vector of plus,minus variations for each parameter; 2734 ; 2735 TMatrixDSym V(paramList.size() == fr.floatParsFinal().size() ?; 2736 fr.covarianceMatrix():; 2737 fr.reducedCovarianceMatrix(paramList)) ;; 2738 ; 2739 ; 2740 for (std",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:126362,Usability,clear,cleared,126362,"derived; 2877 if(!dynamic_cast<RooAbsRealLValue*>(var)) {; 2878 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: cannot plot variable \""""; 2879 << var->GetName() << ""\"" of type "" << var->ClassName() << std::endl;; 2880 return true;; 2881 }; 2882 ; 2883 // check if we actually depend on the plot variable; 2884 if(!this->dependsOn(*var)) {; 2885 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: WARNING: variable is not an explicit dependent: ""; 2886 << var->GetName() << std::endl;; 2887 }; 2888 ; 2889 return false ;; 2890}; 2891 ; 2892 ; 2893 ; 2894 ; 2895////////////////////////////////////////////////////////////////////////////////; 2896/// Utility function for plotOn() that constructs the set of; 2897/// observables to project when plotting ourselves as function of; 2898/// 'plotVar'. 'allVars' is the list of variables that must be; 2899/// projected, but may contain variables that we do not depend on. If; 2900/// 'silent' is cleared, warnings about inconsistent input parameters; 2901/// will be printed.; 2902 ; 2903void RooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars,; 2904 RooArgSet& projectedVars, bool silent) const; 2905{; 2906 cxcoutD(Plotting) << ""RooAbsReal::makeProjectionSet("" << GetName() << "") plotVar = "" << plotVar->GetName(); 2907 << "" allVars = "" << (allVars?(*allVars):RooArgSet()) << std::endl ;; 2908 ; 2909 projectedVars.removeAll() ;; 2910 if (!allVars) return ;; 2911 ; 2912 // Start out with suggested list of variables; 2913 projectedVars.add(*allVars) ;; 2914 ; 2915 // Take out plot variable; 2916 RooAbsArg *found= projectedVars.find(plotVar->GetName());; 2917 if(found) {; 2918 projectedVars.remove(*found);; 2919 ; 2920 // Take out eventual servers of plotVar; 2921 std::unique_ptr<RooArgSet> plotServers{plotVar->getObservables(&projectedVars)};; 2922 for(RooAbsArg * ps : *plotServers) {; 2923 RooAbsArg* tmp = projectedVars.find(ps->GetName()) ;; 2924 if (tmp) {; 2925 cxcoutD(Plotting",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:151428,Usability,clear,clearEvalErrorLog,151428,"];; 3515 if (evalErrorList.second.size() >= 2048) {; 3516 // avoid overflowing the error list, so if there are very many, print; 3517 // the oldest one first, and pop it off the list; 3518 const EvalError& oee = evalErrorList.second.front();; 3519 // print to debug stream, since these would normally be suppressed, and; 3520 // we do not want to increase the error count in the message service...; 3521 ccoutD(Eval) << ""RooAbsReal::logEvalError("" << GetName(); 3522 << "") delayed evaluation error, "" << std::endl; 3523 << "" origin : "" << oss2.str() << std::endl; 3524 << "" message : "" << oee._msg << std::endl; 3525 << "" server values: "" << oee._srvval << std::endl ;; 3526 evalErrorList.second.pop_front();; 3527 }; 3528 evalErrorList.first = oss2.str() ;; 3529 evalErrorList.second.push_back(ee) ;; 3530 }; 3531 ; 3532 inLogEvalError = false ;; 3533 //coutE(Tracing) << ""RooAbsReal::logEvalError("" << GetName() << "") message = "" << message << std::endl ;; 3534}; 3535 ; 3536 ; 3537 ; 3538 ; 3539////////////////////////////////////////////////////////////////////////////////; 3540/// Clear the stack of evaluation error messages; 3541 ; 3542void RooAbsReal::clearEvalErrorLog(); 3543{; 3544 if (evalErrorData().mode == PrintErrors) {; 3545 return ;; 3546 } else if (evalErrorData().mode == CollectErrors) {; 3547 evalErrorData().errorList.clear() ;; 3548 } else {; 3549 evalErrorData().count = 0 ;; 3550 }; 3551}; 3552 ; 3553 ; 3554////////////////////////////////////////////////////////////////////////////////; 3555/// Retrieve bin boundaries if this distribution is binned in `obs`.; 3556/// \param[in] obs Observable to retrieve boundaries for.; 3557/// \param[in] xlo Beginning of range.; 3558/// \param[in] xhi End of range.; 3559/// \return The caller owns the returned std::list.; 3560std::list<double>* RooAbsReal::binBoundaries(RooAbsRealLValue& /*obs*/, double /*xlo*/, double /*xhi*/) const {; 3561 return nullptr;; 3562}; 3563 ; 3564 ; 3565//////////////////////////////////////////",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:151609,Usability,clear,clear,151609,"count in the message service...; 3521 ccoutD(Eval) << ""RooAbsReal::logEvalError("" << GetName(); 3522 << "") delayed evaluation error, "" << std::endl; 3523 << "" origin : "" << oss2.str() << std::endl; 3524 << "" message : "" << oee._msg << std::endl; 3525 << "" server values: "" << oee._srvval << std::endl ;; 3526 evalErrorList.second.pop_front();; 3527 }; 3528 evalErrorList.first = oss2.str() ;; 3529 evalErrorList.second.push_back(ee) ;; 3530 }; 3531 ; 3532 inLogEvalError = false ;; 3533 //coutE(Tracing) << ""RooAbsReal::logEvalError("" << GetName() << "") message = "" << message << std::endl ;; 3534}; 3535 ; 3536 ; 3537 ; 3538 ; 3539////////////////////////////////////////////////////////////////////////////////; 3540/// Clear the stack of evaluation error messages; 3541 ; 3542void RooAbsReal::clearEvalErrorLog(); 3543{; 3544 if (evalErrorData().mode == PrintErrors) {; 3545 return ;; 3546 } else if (evalErrorData().mode == CollectErrors) {; 3547 evalErrorData().errorList.clear() ;; 3548 } else {; 3549 evalErrorData().count = 0 ;; 3550 }; 3551}; 3552 ; 3553 ; 3554////////////////////////////////////////////////////////////////////////////////; 3555/// Retrieve bin boundaries if this distribution is binned in `obs`.; 3556/// \param[in] obs Observable to retrieve boundaries for.; 3557/// \param[in] xlo Beginning of range.; 3558/// \param[in] xhi End of range.; 3559/// \return The caller owns the returned std::list.; 3560std::list<double>* RooAbsReal::binBoundaries(RooAbsRealLValue& /*obs*/, double /*xlo*/, double /*xhi*/) const {; 3561 return nullptr;; 3562}; 3563 ; 3564 ; 3565////////////////////////////////////////////////////////////////////////////////; 3566/// Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable `obs`.; 3567/// \param[in] obs Observable to retrieve sampling hint for.; 3568/// \param[in] xlo Beginning of range.; 3569/// \param[in] xhi End of range.; 3570/// \return The caller owns the returned",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:154627,Usability,clear,clearing,154627,"<< std::endl;; 3586 }; 3587 ; 3588 if (maxPerNode < 0); 3589 return;; 3590 ; 3591 for (auto const &item : evalErrorData().errorList) {; 3592 if (maxPerNode == 0) {; 3593 ; 3594 // Only print node name with total number of errors; 3595 os << item.second.first;; 3596 // item.first->printStream(os,kName|kClassName|kArgs,kInline) ;; 3597 os << "" has "" << item.second.second.size() << "" errors"" << std::endl;; 3598 ; 3599 } else {; 3600 ; 3601 // Print node name and details of 'maxPerNode' errors; 3602 os << item.second.first << std::endl;; 3603 // item.first->printStream(os,kName|kClassName|kArgs,kSingleLine) ;; 3604 ; 3605 Int_t i(0);; 3606 for (auto const &item2 : item.second.second) {; 3607 os << "" "" << item2._msg << "" @ "" << item2._srvval << std::endl;; 3608 if (i > maxPerNode) {; 3609 os << "" ... (remaining "" << item.second.second.size() - maxPerNode << "" messages suppressed)""; 3610 << std::endl;; 3611 break;; 3612 }; 3613 i++;; 3614 }; 3615 }; 3616 }; 3617}; 3618 ; 3619 ; 3620 ; 3621////////////////////////////////////////////////////////////////////////////////; 3622/// Return the number of logged evaluation errors since the last clearing.; 3623 ; 3624Int_t RooAbsReal::numEvalErrors(); 3625{; 3626 auto &evalErrors = evalErrorData();; 3627 if (evalErrors.mode == CountErrors) {; 3628 return evalErrors.count;; 3629 }; 3630 ; 3631 Int_t ntot(0);; 3632 for (auto const &elem : evalErrors.errorList) {; 3633 ntot += elem.second.second.size();; 3634 }; 3635 return ntot;; 3636}; 3637 ; 3638 ; 3639 ; 3640////////////////////////////////////////////////////////////////////////////////; 3641/// Fix the interpretation of the coefficient of any RooAddPdf component in; 3642/// the expression tree headed by this object to the given set of observables.; 3643///; 3644/// If the force flag is false, the normalization choice is only fixed for those; 3645/// RooAddPdf components that have the default 'automatic' interpretation of; 3646/// coefficients (i.e. the interpretation is defined",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:192516,Usability,learn,learn,192516," 4339 ; 4340/** Base function for computing multiple values of a RooAbsReal.; 4341\param ctx An evaluation context object; 4342**/; 4343void RooAbsReal::doEval(RooFit::EvalContext & ctx) const; 4344{; 4345 std::span<double> output = ctx.output();; 4346 ; 4347 // Find all servers that are serving real numbers to us, retrieve their batch data,; 4348 // and switch them into ""always clean"" operating mode, so they return always the last-set value.; 4349 struct ServerData {; 4350 RooAbsArg* server;; 4351 std::span<const double> batch;; 4352 double oldValue;; 4353 RooAbsArg::OperMode oldOperMode;; 4354 bool oldValueDirty;; 4355 bool oldShapeDirty;; 4356 };; 4357 std::vector<ServerData> ourServers;; 4358 ourServers.reserve(servers().size());; 4359 ; 4360 for (auto server : servers()) {; 4361 auto serverValues = ctx.at(server);; 4362 if(serverValues.empty()) continue;; 4363 ; 4364 // maybe we are still missing inhibit dirty here; 4365 auto oldOperMode = server->operMode();; 4366 // See note at the bottom of this function to learn why we can only set; 4367 // the operation mode to ""always clean"" if there are no other value; 4368 // clients.; 4369 server->setOperMode(RooAbsArg::AClean);; 4370 ourServers.push_back({server,; 4371 serverValues,; 4372 server->isCategory() ? static_cast<RooAbsCategory const*>(server)->getCurrentIndex() : static_cast<RooAbsReal const*>(server)->_value,; 4373 oldOperMode,; 4374 server->_valueDirty,; 4375 server->_shapeDirty});; 4376 // Prevent the server from evaluating; just return cached result, which we will side load:; 4377 }; 4378 ; 4379 ; 4380 // Make sure that we restore all state when we finish:; 4381 struct RestoreStateRAII {; 4382 RestoreStateRAII(std::vector<ServerData>& servers) :; 4383 _servers{servers} { }; 4384 ; 4385 ~RestoreStateRAII() {; 4386 for (auto& serverData : _servers) {; 4387 serverData.server->setCachedValue(serverData.oldValue, true);; 4388 serverData.server->setOperMode(serverData.oldOperMode);; 4389 serverData.server->_va",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:206202,Usability,clear,clear,206202,"Arg::getVariablesRooFit::OwningPtr< RooArgSet > getVariables(bool stripDisconnected=true) constReturn RooArgSet with all variables (tree leaf nodes of expression tree)Definition RooAbsArg.cxx:2154; RooAbsArg::printMultilinevoid printMultiline(std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const overrideImplement multi-line detailed printing.Definition RooAbsArg.cxx:1589; RooAbsArg::cloneTreevirtual RooAbsArg * cloneTree(const char *newname=nullptr) constClone tree expression of objects.Definition RooAbsArg.cxx:2293; RooAbsArg::cleanBranchNameTString cleanBranchName() constConstruct a mangled name from the actual name that is free of any math symbols that might be interpre...Definition RooAbsArg.cxx:2075; RooAbsArg::numProxiesInt_t numProxies() constReturn the number of registered proxies.Definition RooAbsArg.cxx:1457; RooAbsArg::_inhibitDirtystatic bool _inhibitDirtyDefinition RooAbsArg.h:668; RooAbsArg::setAttributevoid setAttribute(const Text_t *name, bool value=true)Set (default) or clear a named boolean attribute of this object.Definition RooAbsArg.cxx:222; RooAbsArg::setProxyNormSetvoid setProxyNormSet(const RooArgSet *nset)Forward a change in the cached normalization argset to all the registered proxies.Definition RooAbsArg.cxx:1468; RooAbsArg::branchNodeServerListvoid branchNodeServerList(RooAbsCollection *list, const RooAbsArg *arg=nullptr, bool recurseNonDerived=false) constFill supplied list with all branch nodes of the arg tree starting with ourself as top node.Definition RooAbsArg.cxx:483; RooAbsArg::getProxyRooAbsProxy * getProxy(Int_t index) constReturn the nth proxy from the proxy list.Definition RooAbsArg.cxx:1444; RooAbsArg::CloneTObject * Clone(const char *newname=nullptr) const overrideMake a clone of an object using the Streamer facility.Definition RooAbsArg.h:91; RooAbsArg::_serverListRefCountList_t _serverListDefinition RooAbsArg.h:606; RooAbsArg::leafNodeServerListvoid leafNodeServerList(RooAbsCollection *list, const ",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:229443,Usability,clear,clearing,229443,"t char * getPlotLabel() constGet the label associated with the variable.Definition RooAbsReal.cxx:406; RooAbsReal::createRunningIntegralRooFit::OwningPtr< RooAbsReal > createRunningIntegral(const RooArgSet &iset, const RooArgSet &nset={})Calls createRunningIntegral(const RooArgSet&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&,...Definition RooAbsReal.cxx:3706; RooAbsReal::_specIntegratorConfigstd::unique_ptr< RooNumIntConfig > _specIntegratorConfigDefinition RooAbsReal.h:540; RooAbsReal::getAnalyticalIntegralvirtual Int_t getAnalyticalIntegral(RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) constInterface function getAnalyticalIntergral advertises the analytical integrals that are supported.Definition RooAbsReal.cxx:368; RooAbsReal::evalErrorIterstatic std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter()Definition RooAbsReal.cxx:181; RooAbsReal::numEvalErrorsstatic Int_t numEvalErrors()Return the number of logged evaluation errors since the last clearing.Definition RooAbsReal.cxx:3624; RooAbsReal::setEvalErrorLoggingModestatic void setEvalErrorLoggingMode(ErrorLoggingMode m)Set evaluation error logging mode.Definition RooAbsReal.cxx:4316; RooAbsReal::preferredObservableScanOrdervirtual void preferredObservableScanOrder(const RooArgSet &obs, RooArgSet &orderedObs) constInterface method for function objects to indicate their preferred order of observables for scanning t...Definition RooAbsReal.cxx:3694; RooAbsReal::maxValvirtual double maxVal(Int_t code) constReturn maximum value for set of observables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive integrals over functions ...Definition RooAbsReal.cxx:701; RooAbsReal::integralNameSuffi",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:232121,Usability,clear,clearEvalErrorLogstatic,232121,"ticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsReal.cxx:3827; RooAbsReal::enableOffsettingvirtual void enableOffsetting(bool)Definition RooAbsReal.cxx:4484; RooAbsReal::clearEvalErrorLogstatic void clearEvalErrorLog()Clear the stack of evaluation error messages.Definition RooAbsReal.cxx:3542; RooAbsReal::createIntObjRooFit::OwningPtr< RooAbsReal > createIntObj(const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) constInternal utility function for createIntegral() that creates the actual integral object.Definition RooAbsReal.cxx:590; RooAbsReal::functorRooFunctor * functor(const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) constReturn a RooFunctor object bound to this RooAbsReal with given definition of observables and paramete...Definition RooAbsReal.cxx:3887; RooAbsReal::createPlotProjectionconst RooAbsReal * createPlotProjection(const RooArgSet &depVars, const RooArgSet &projVars, RooArgSet *&cloneSet) constUtility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a Roo...Definition RooAbsReal.cxx:787; RooAbsReal::plotSamplingHintvirtual std::list< double > * p",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:232150,Usability,clear,clearEvalErrorLog,232150,"ticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsReal.cxx:3827; RooAbsReal::enableOffsettingvirtual void enableOffsetting(bool)Definition RooAbsReal.cxx:4484; RooAbsReal::clearEvalErrorLogstatic void clearEvalErrorLog()Clear the stack of evaluation error messages.Definition RooAbsReal.cxx:3542; RooAbsReal::createIntObjRooFit::OwningPtr< RooAbsReal > createIntObj(const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) constInternal utility function for createIntegral() that creates the actual integral object.Definition RooAbsReal.cxx:590; RooAbsReal::functorRooFunctor * functor(const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) constReturn a RooFunctor object bound to this RooAbsReal with given definition of observables and paramete...Definition RooAbsReal.cxx:3887; RooAbsReal::createPlotProjectionconst RooAbsReal * createPlotProjection(const RooArgSet &depVars, const RooArgSet &projVars, RooArgSet *&cloneSet) constUtility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a Roo...Definition RooAbsReal.cxx:787; RooAbsReal::plotSamplingHintvirtual std::list< double > * p",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8cxx_source.html:242682,Usability,simpl,simple,242682,"Number, double weight, double wgtErr)Set bin content of bin that was last loaded with get(std::size_t).Definition RooDataHist.cxx:1754; RooDataHist::binVolumedouble binVolume(std::size_t i) constReturn bin volume of i-th bin.Definition RooDataHist.h:118; RooDataHist::getconst RooArgSet * get() const overrideGet bin centre of current bin.Definition RooDataHist.h:82; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDerivativeRepresents the first, second, or third order derivative of any RooAbsReal as calculated (numerically)...Definition RooDerivative.h:30; RooFirstMomentDefinition RooFirstMoment.h:26; RooFitResultRooFitResult is a container class to hold the input and output of a PDF fit to a dataset.Definition RooFitResult.h:40; RooFitResult::covarianceMatrixconst TMatrixDSym & covarianceMatrix() constReturn covariance matrix.Definition RooFitResult.cxx:1112; RooFitResult::reducedCovarianceMatrixTMatrixDSym reducedCovarianceMatrix(const RooArgList &params) constReturn a reduced covariance matrix (Note that Vred is a simple sub-matrix of V, row/columns are order...Definition RooFitResult.cxx:1124; RooFitResult::floatParsFinalconst RooArgList & floatParsFinal() constReturn list of floating parameters after fit.Definition RooFitResult.h:111; RooFitResult::createHessePdfRooAbsPdf * createHessePdf(const RooArgSet &params) constReturn a p.d.f that represents the fit result as a multi-variate probability densisty function on the...Definition RooFitResult.cxx:1260; RooFit::Detail::CodeSquashContextA class to maintain the context for squashing of RooFit models into code.Definition CodeSquashContext.h:42; RooFit::EvalContextDefinition EvalContext.h:84; RooFit::EvalContext::atstd::span< const double > at(RooAbsArg const *arg, RooAbsArg const *caller=nullptr)Definition EvalContext.cxx:35; RooFit::EvalContext::outputstd::span< double > output()Definition EvalContext.h:112; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued obj",MatchSource.WIKI,doc/master/RooAbsReal_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:4279,Availability,down,downstream,4279,"ationSet getValV() reacts differently depending on the value of the normalisation set.; 94 /// If the set is `nullptr`, an unnormalised value is returned.; 95 /// \note The normalisation is arbitrary, because it is up to the implementation; 96 /// of the PDF to e.g. leave out normalisation constants for speed reasons. The range; 97 /// of the variables is also ignored.; 98 ///; 99 /// To normalise the result properly, a RooArgSet has to be passed, which contains; 100 /// the variables to normalise over.; 101 /// These are integrated over their current ranges to compute the normalisation constant,; 102 /// and the unnormalised result is divided by this value.; 103 inline double getVal(const RooArgSet* normalisationSet = nullptr) const {; 104 // Sometimes, the calling code uses an empty RooArgSet to request evaluation; 105 // without normalization set instead of following the `nullptr` convention.; 106 // To remove this ambiguity which might not always be correctly handled in; 107 // downstream code, we set `normalisationSet` to nullptr if it is pointing; 108 // to an empty set.; 109 if(normalisationSet && normalisationSet->empty()) {; 110 normalisationSet = nullptr;; 111 }; 112#ifdef ROOFIT_CHECK_CACHED_VALUES; 113 return _DEBUG_getVal(normalisationSet);; 114#else; 115 ; 116#ifndef _WIN32; 117 return (_fast && !_inhibitDirty) ? _value : getValV(normalisationSet) ;; 118#else; 119 return (_fast && !inhibitDirty()) ? _value : getValV(normalisationSet) ;; 120#endif; 121 ; 122#endif; 123 }; 124 ; 125 /// Like getVal(const RooArgSet*), but always requires an argument for normalisation.; 126 inline double getVal(const RooArgSet& normalisationSet) const {; 127 // Sometimes, the calling code uses an empty RooArgSet to request evaluation; 128 // without normalization set instead of following the `nullptr` convention.; 129 // To remove this ambiguity which might not always be correctly handled in; 130 // downstream code, we set `normalisationSet` to nullptr if it is an empty set",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:5208,Availability,down,downstream,5208," remove this ambiguity which might not always be correctly handled in; 107 // downstream code, we set `normalisationSet` to nullptr if it is pointing; 108 // to an empty set.; 109 if(normalisationSet && normalisationSet->empty()) {; 110 normalisationSet = nullptr;; 111 }; 112#ifdef ROOFIT_CHECK_CACHED_VALUES; 113 return _DEBUG_getVal(normalisationSet);; 114#else; 115 ; 116#ifndef _WIN32; 117 return (_fast && !_inhibitDirty) ? _value : getValV(normalisationSet) ;; 118#else; 119 return (_fast && !inhibitDirty()) ? _value : getValV(normalisationSet) ;; 120#endif; 121 ; 122#endif; 123 }; 124 ; 125 /// Like getVal(const RooArgSet*), but always requires an argument for normalisation.; 126 inline double getVal(const RooArgSet& normalisationSet) const {; 127 // Sometimes, the calling code uses an empty RooArgSet to request evaluation; 128 // without normalization set instead of following the `nullptr` convention.; 129 // To remove this ambiguity which might not always be correctly handled in; 130 // downstream code, we set `normalisationSet` to nullptr if it is an empty set.; 131 return _fast ? _value : getValV(normalisationSet.empty() ? nullptr : &normalisationSet) ;; 132 }; 133 ; 134 virtual double getValV(const RooArgSet* normalisationSet = nullptr) const ;; 135 ; 136 double getPropagatedError(const RooFitResult &fr, const RooArgSet &nset = {}) const;; 137 ; 138 bool operator==(double value) const ;; 139 bool operator==(const RooAbsArg& other) const override;; 140 bool isIdentical(const RooAbsArg& other, bool assumeSameType=false) const override;; 141 ; 142 ; 143 inline const Text_t *getUnit() const {; 144 // Return string with unit description; 145 return _unit.Data();; 146 }; 147 inline void setUnit(const char *unit) {; 148 // Set unit description to given string; 149 _unit= unit;; 150 }; 151 TString getTitle(bool appendUnit= false) const;; 152 ; 153 // Lightweight interface adaptors (caller takes ownership); 154 RooFit::OwningPtr<RooAbsFunc> bindVars(const RooArgSet &v",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:12369,Availability,error,error,12369,"Integral(iset,&nset,&cfg,rangeName) ;; 218 }; 219 /// Create integral over observables in iset in range named rangeName using specified configuration for any numeric integration.; 220 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooNumIntConfig& cfg, const char* rangeName=nullptr) const {; 221 return createIntegral(iset,nullptr,&cfg,rangeName) ;; 222 }; 223 virtual RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooArgSet* nset=nullptr, const RooNumIntConfig* cfg=nullptr, const char* rangeName=nullptr) const ;; 224 ; 225 ; 226 void setParameterizeIntegral(const RooArgSet& paramVars) ;; 227 ; 228 // Create running integrals; 229 RooFit::OwningPtr<RooAbsReal> createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset={}) ;; 230 RooFit::OwningPtr<RooAbsReal> createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2={},; 231 const RooCmdArg& arg3={}, const RooCmdArg& arg4={},; 232 const RooCmdArg& arg5={}, const RooCmdArg& arg6={},; 233 const RooCmdArg& arg7={}, const RooCmdArg& arg8={}) ;; 234 RooFit::OwningPtr<RooAbsReal> createIntRI(const RooArgSet& iset, const RooArgSet& nset={}) ;; 235 RooFit::OwningPtr<RooAbsReal> createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder) ;; 236 ; 237 ; 238 // Optimized accept/reject generator support; 239 virtual Int_t getMaxVal(const RooArgSet& vars) const ;; 240 virtual double maxVal(Int_t code) const ;; 241 virtual Int_t minTrialSamples(const RooArgSet& /*arGenObs*/) const { return 0 ; }; 242 ; 243 ; 244 // Plotting options; 245 void setPlotLabel(const char *label);; 246 const char *getPlotLabel() const;; 247 ; 248 virtual double defaultErrorLevel() const {; 249 // Return default level for MINUIT error analysis; 250 return 1.0 ;; 251 }; 252 ; 253 const RooNumIntConfig* getIntegratorConfig() const ;; 254 RooNumIntConfig* getIntegratorConfig() ;; 255 static RooNumIntConfig* defaultIntegratorConfig() ;;",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:15150,Availability,error,error,15150,"onst RooCmdArg& arg4={},; 270 const RooCmdArg& arg5={}, const RooCmdArg& arg6={},; 271 const RooCmdArg& arg7={}, const RooCmdArg& arg8={},; 272 const RooCmdArg& arg9={}, const RooCmdArg& arg10={}; 273 ) const ;; 274 ; 275 ; 276 enum ScaleType { Raw, Relative, NumEvent, RelativeExpected } ;; 277 ; 278 // Fill an existing histogram; 279 TH1 *fillHistogram(TH1 *hist, const RooArgList &plotVars,; 280 double scaleFactor= 1, const RooArgSet *projectedVars= nullptr, bool scaling=true,; 281 const RooArgSet* condObs=nullptr, bool setError=true) const;; 282 ; 283 // Create 1,2, and 3D histograms from and fill it; 284 TH1 *createHistogram(RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) const ;; 285 TH1* createHistogram(const char *name, const RooAbsRealLValue& xvar, RooLinkedList& argList) const ;; 286 TH1 *createHistogram(const char *name, const RooAbsRealLValue& xvar,; 287 const RooCmdArg& arg1={}, const RooCmdArg& arg2={},; 288 const RooCmdArg& arg3={}, const RooCmdArg& arg4={},; 289 const RooCmdArg& arg5={}, const RooCmdArg& arg6={},; 290 const RooCmdArg& arg7={}, const RooCmdArg& arg8={}) const ;; 291 ; 292 // Fill a RooDataHist; 293 RooDataHist* fillDataHist(RooDataHist *hist, const RooArgSet* nset, double scaleFactor,; 294 bool correctForBinVolume=false, bool showProgress=false) const ;; 295 ; 296 // I/O streaming interface (machine readable); 297 bool readFromStream(std::istream& is, bool compact, bool verbose=false) override ;; 298 void writeToStream(std::ostream& os, bool compact) const override ;; 299 ; 300 // Printing interface (human readable); 301 void printValue(std::ostream& os) const override ;; 302 void printMultiline(std::ostream& os, Int_t contents, bool verbose=false, TString indent="""") const override ;; 303 ; 304 inline void setCachedValue(double value, bool notifyClients = true) final;; 305 ; 306 // Evaluation error logging; 307 class EvalError {; 308 public:; 309 EvalError() { }; 310 EvalError(const EvalError& other) : _msg(other.",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:15661,Availability,error,error,15661,"ess=false) const ;; 295 ; 296 // I/O streaming interface (machine readable); 297 bool readFromStream(std::istream& is, bool compact, bool verbose=false) override ;; 298 void writeToStream(std::ostream& os, bool compact) const override ;; 299 ; 300 // Printing interface (human readable); 301 void printValue(std::ostream& os) const override ;; 302 void printMultiline(std::ostream& os, Int_t contents, bool verbose=false, TString indent="""") const override ;; 303 ; 304 inline void setCachedValue(double value, bool notifyClients = true) final;; 305 ; 306 // Evaluation error logging; 307 class EvalError {; 308 public:; 309 EvalError() { }; 310 EvalError(const EvalError& other) : _msg(other._msg), _srvval(other._srvval) { }; 311 void setMessage(const char* tmp) { std::string s(tmp); s.swap(_msg); }; 312 void setServerValues(const char* tmp) { std::string s(tmp); s.swap(_srvval); }; 313 std::string _msg;; 314 std::string _srvval;; 315 } ;; 316 ; 317 enum ErrorLoggingMode { PrintErrors, CollectErrors, CountErrors, Ignore } ;; 318 ; 319 /// Context to temporarily change the error logging mode as long as the context is alive.; 320 class EvalErrorContext {; 321 public:; 322 EvalErrorContext(ErrorLoggingMode m) : _old{evalErrorLoggingMode()} { setEvalErrorLoggingMode(m); }; 323 ; 324 EvalErrorContext(EvalErrorContext const&) = delete;; 325 EvalErrorContext(EvalErrorContext &&) = delete;; 326 EvalErrorContext& operator=(EvalErrorContext const&) = delete;; 327 EvalErrorContext& operator=(EvalErrorContext &&) = delete;; 328 ; 329 ~EvalErrorContext() { setEvalErrorLoggingMode(_old); }; 330 private:; 331 ErrorLoggingMode _old;; 332 };; 333 ; 334 static ErrorLoggingMode evalErrorLoggingMode() ;; 335 static void setEvalErrorLoggingMode(ErrorLoggingMode m) ;; 336 void logEvalError(const char* message, const char* serverValueString=nullptr) const ;; 337 static void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString=nullptr) ",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:15706,Availability,alive,alive,15706,"ess=false) const ;; 295 ; 296 // I/O streaming interface (machine readable); 297 bool readFromStream(std::istream& is, bool compact, bool verbose=false) override ;; 298 void writeToStream(std::ostream& os, bool compact) const override ;; 299 ; 300 // Printing interface (human readable); 301 void printValue(std::ostream& os) const override ;; 302 void printMultiline(std::ostream& os, Int_t contents, bool verbose=false, TString indent="""") const override ;; 303 ; 304 inline void setCachedValue(double value, bool notifyClients = true) final;; 305 ; 306 // Evaluation error logging; 307 class EvalError {; 308 public:; 309 EvalError() { }; 310 EvalError(const EvalError& other) : _msg(other._msg), _srvval(other._srvval) { }; 311 void setMessage(const char* tmp) { std::string s(tmp); s.swap(_msg); }; 312 void setServerValues(const char* tmp) { std::string s(tmp); s.swap(_srvval); }; 313 std::string _msg;; 314 std::string _srvval;; 315 } ;; 316 ; 317 enum ErrorLoggingMode { PrintErrors, CollectErrors, CountErrors, Ignore } ;; 318 ; 319 /// Context to temporarily change the error logging mode as long as the context is alive.; 320 class EvalErrorContext {; 321 public:; 322 EvalErrorContext(ErrorLoggingMode m) : _old{evalErrorLoggingMode()} { setEvalErrorLoggingMode(m); }; 323 ; 324 EvalErrorContext(EvalErrorContext const&) = delete;; 325 EvalErrorContext(EvalErrorContext &&) = delete;; 326 EvalErrorContext& operator=(EvalErrorContext const&) = delete;; 327 EvalErrorContext& operator=(EvalErrorContext &&) = delete;; 328 ; 329 ~EvalErrorContext() { setEvalErrorLoggingMode(_old); }; 330 private:; 331 ErrorLoggingMode _old;; 332 };; 333 ; 334 static ErrorLoggingMode evalErrorLoggingMode() ;; 335 static void setEvalErrorLoggingMode(ErrorLoggingMode m) ;; 336 void logEvalError(const char* message, const char* serverValueString=nullptr) const ;; 337 static void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString=nullptr) ",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:22709,Availability,error,error,22709,"rgProxy& c) const ;; 433 bool matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps,; 434 const RooArgProxy& a, const RooArgProxy& b,; 435 const RooArgProxy& c, const RooArgProxy& d) const ;; 436 ; 437 bool matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps,; 438 const RooArgSet& set) const ;; 439 ; 440 RooFit::OwningPtr<RooAbsReal> createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const ;; 441 void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const ;; 442 ; 443 // Internal consistency checking (needed by RooDataSet); 444 /// Check if current value is valid.; 445 bool isValid() const override { return isValidReal(_value); }; 446 /// Interface function to check if given value is a valid value for this object. Returns true unless overridden.; 447 virtual bool isValidReal(double /*value*/, bool printError = false) const { (void)printError; return true; }; 448 ; 449 // Function evaluation and error tracing; 450 double traceEval(const RooArgSet* set) const ;; 451 ; 452 /// Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; 453 virtual double evaluate() const = 0;; 454 ; 455 // Hooks for RooDataSet interface; 456 void syncCache(const RooArgSet* set=nullptr) override { getVal(set) ; }; 457 void copyCache(const RooAbsArg* source, bool valueOnly=false, bool setValDirty=true) override ;; 458 void attachToTree(TTree& t, Int_t bufSize=32000) override ;; 459 void attachToVStore(RooVectorDataStore& vstore) override ;; 460 void setTreeBranchStatus(TTree& t, bool active) override ;; 461 void fillTreeBranch(TTree& t) override ;; 462 ; 463 struct PlotOpt {; 464 Option_t *drawOptions = ""L"";; 465 double scaleFactor = 1.0;; 466 ScaleType stype = Relative;; 467 const RooAbsData *projData = nullptr;; 468 bool binProjData = false;; 469 const RooArgSet *projSet = nullptr;; 470 double precision = 1e-3;; 471 bool shiftToZero = false;; 472 cons",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:24387,Availability,error,errorFR,24387,"ToZero = false;; 472 const RooArgSet *projDataSet = nullptr;; 473 const char *normRangeName = nullptr;; 474 double rangeLo = 0.0;; 475 double rangeHi = 0.0;; 476 bool postRangeFracScale = false;; 477 RooCurve::WingMode wmode = RooCurve::Extended;; 478 const char *projectionRangeName = nullptr;; 479 bool curveInvisible = false;; 480 const char *curveName = nullptr;; 481 const char *addToCurveName = nullptr;; 482 double addToWgtSelf = 1.0;; 483 double addToWgtOther = 1.0;; 484 Int_t numCPU = 1;; 485 RooFit::MPSplit interleave = RooFit::Interleave;; 486 const char *curveNameSuffix = """";; 487 Int_t numee = 10;; 488 double eeval = 0.0;; 489 bool doeeval = false;; 490 bool progress = false;; 491 const RooFitResult *errorFR = nullptr;; 492 };; 493 ; 494 // Plot implementation functions; 495 virtual RooPlot *plotOn(RooPlot* frame, PlotOpt o) const;; 496 ; 497 virtual RooPlot *plotAsymOn(RooPlot *frame, const RooAbsCategoryLValue& asymCat, PlotOpt o) const;; 498 ; 499 bool matchArgsByName(const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;; 500 ; 501 bool redirectServersHook(const RooAbsCollection & newServerList, bool mustReplaceAll,; 502 bool nameChange, bool isRecursiveStep) override;; 503 ; 504 static void globalSelectComp(bool flag) ;; 505 ; 506 // This struct can be used to flip the global switch to select components.; 507 // Doing this with RAII prevents forgetting to reset the state.; 508 struct GlobalSelectComponentRAII {; 509 GlobalSelectComponentRAII(bool state) :; 510 _oldState{_globalSelectComp} {; 511 if (state != RooAbsReal::_globalSelectComp); 512 RooAbsReal::_globalSelectComp = state;; 513 }; 514 ; 515 ~GlobalSelectComponentRAII() {; 516 if (RooAbsReal::_globalSelectComp != _oldState); 517 RooAbsReal::_globalSelectComp = _oldState;; 518 }; 519 ; 520 bool _oldState;; 521 };; 522 ; 523 ; 524private:; 525 ; 526 /// Debug version of getVal(), which is slow and does error checking.; 527 double _DEBUG_getVal(const RooArgSet* normalisati",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:25598,Availability,error,error,25598,"lse;; 491 const RooFitResult *errorFR = nullptr;; 492 };; 493 ; 494 // Plot implementation functions; 495 virtual RooPlot *plotOn(RooPlot* frame, PlotOpt o) const;; 496 ; 497 virtual RooPlot *plotAsymOn(RooPlot *frame, const RooAbsCategoryLValue& asymCat, PlotOpt o) const;; 498 ; 499 bool matchArgsByName(const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;; 500 ; 501 bool redirectServersHook(const RooAbsCollection & newServerList, bool mustReplaceAll,; 502 bool nameChange, bool isRecursiveStep) override;; 503 ; 504 static void globalSelectComp(bool flag) ;; 505 ; 506 // This struct can be used to flip the global switch to select components.; 507 // Doing this with RAII prevents forgetting to reset the state.; 508 struct GlobalSelectComponentRAII {; 509 GlobalSelectComponentRAII(bool state) :; 510 _oldState{_globalSelectComp} {; 511 if (state != RooAbsReal::_globalSelectComp); 512 RooAbsReal::_globalSelectComp = state;; 513 }; 514 ; 515 ~GlobalSelectComponentRAII() {; 516 if (RooAbsReal::_globalSelectComp != _oldState); 517 RooAbsReal::_globalSelectComp = _oldState;; 518 }; 519 ; 520 bool _oldState;; 521 };; 522 ; 523 ; 524private:; 525 ; 526 /// Debug version of getVal(), which is slow and does error checking.; 527 double _DEBUG_getVal(const RooArgSet* normalisationSet) const;; 528 ; 529 //--------------------------------------------------------------------; 530 ; 531 protected:; 532 ; 533 double _plotMin = 0.0; ///< Minimum of plot range; 534 double _plotMax = 0.0; ///< Maximum of plot range; 535 Int_t _plotBins = 100; ///< Number of plot bins; 536 mutable double _value = 0.0; ///< Cache for current value of object; 537 TString _unit; ///< Unit for objects value; 538 TString _label; ///< Plot label for objects value; 539 bool _forceNumInt = false; ///< Force numerical integration if flag set; 540 std::unique_ptr<RooNumIntConfig> _specIntegratorConfig; // Numeric integrator configuration specific for this object; 541 TreeReadBuffer *_treeR",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:30050,Availability,error,error,30050,"Arg::inhibitDirtybool inhibitDirty() constDelete watch flag.Definition RooAbsArg.cxx:105; RooAbsArg::_inhibitDirtystatic bool _inhibitDirtyDefinition RooAbsArg.h:668; RooAbsCategoryLValueAbstract base class for objects that represent a discrete value that can be set from the outside,...Definition RooAbsCategoryLValue.h:26; RooAbsCollectionAbstract container object that can hold multiple RooAbsArg objects.Definition RooAbsCollection.h:65; RooAbsCollection::emptybool empty() constDefinition RooAbsCollection.h:273; RooAbsDataAbstract base class for binned and unbinned datasets.Definition RooAbsData.h:57; RooAbsFuncAbstract interface for evaluating a real-valued function of one real variable and performing numerica...Definition RooAbsFunc.h:27; RooAbsMomentDefinition RooAbsMoment.h:27; RooAbsRealLValueAbstract base class for objects that represent a real value that may appear on the left hand side of ...Definition RooAbsRealLValue.h:31; RooAbsReal::EvalErrorContextContext to temporarily change the error logging mode as long as the context is alive.Definition RooAbsReal.h:320; RooAbsReal::EvalErrorContext::~EvalErrorContext~EvalErrorContext()Definition RooAbsReal.h:329; RooAbsReal::EvalErrorContext::EvalErrorContextEvalErrorContext(ErrorLoggingMode m)Definition RooAbsReal.h:322; RooAbsReal::EvalErrorContext::operator=EvalErrorContext & operator=(EvalErrorContext const &)=delete; RooAbsReal::EvalErrorContext::_oldErrorLoggingMode _oldDefinition RooAbsReal.h:331; RooAbsReal::EvalErrorContext::operator=EvalErrorContext & operator=(EvalErrorContext &&)=delete; RooAbsReal::EvalErrorContext::EvalErrorContextEvalErrorContext(EvalErrorContext const &)=delete; RooAbsReal::EvalErrorContext::EvalErrorContextEvalErrorContext(EvalErrorContext &&)=delete; RooAbsReal::EvalErrorDefinition RooAbsReal.h:307; RooAbsReal::EvalError::setServerValuesvoid setServerValues(const char *tmp)Definition RooAbsReal.h:312; RooAbsReal::EvalError::_srvvalstd::string _srvvalDefinition RooAbsReal.h:314; Ro",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:30095,Availability,alive,alive,30095,"Arg::inhibitDirtybool inhibitDirty() constDelete watch flag.Definition RooAbsArg.cxx:105; RooAbsArg::_inhibitDirtystatic bool _inhibitDirtyDefinition RooAbsArg.h:668; RooAbsCategoryLValueAbstract base class for objects that represent a discrete value that can be set from the outside,...Definition RooAbsCategoryLValue.h:26; RooAbsCollectionAbstract container object that can hold multiple RooAbsArg objects.Definition RooAbsCollection.h:65; RooAbsCollection::emptybool empty() constDefinition RooAbsCollection.h:273; RooAbsDataAbstract base class for binned and unbinned datasets.Definition RooAbsData.h:57; RooAbsFuncAbstract interface for evaluating a real-valued function of one real variable and performing numerica...Definition RooAbsFunc.h:27; RooAbsMomentDefinition RooAbsMoment.h:27; RooAbsRealLValueAbstract base class for objects that represent a real value that may appear on the left hand side of ...Definition RooAbsRealLValue.h:31; RooAbsReal::EvalErrorContextContext to temporarily change the error logging mode as long as the context is alive.Definition RooAbsReal.h:320; RooAbsReal::EvalErrorContext::~EvalErrorContext~EvalErrorContext()Definition RooAbsReal.h:329; RooAbsReal::EvalErrorContext::EvalErrorContextEvalErrorContext(ErrorLoggingMode m)Definition RooAbsReal.h:322; RooAbsReal::EvalErrorContext::operator=EvalErrorContext & operator=(EvalErrorContext const &)=delete; RooAbsReal::EvalErrorContext::_oldErrorLoggingMode _oldDefinition RooAbsReal.h:331; RooAbsReal::EvalErrorContext::operator=EvalErrorContext & operator=(EvalErrorContext &&)=delete; RooAbsReal::EvalErrorContext::EvalErrorContextEvalErrorContext(EvalErrorContext const &)=delete; RooAbsReal::EvalErrorContext::EvalErrorContextEvalErrorContext(EvalErrorContext &&)=delete; RooAbsReal::EvalErrorDefinition RooAbsReal.h:307; RooAbsReal::EvalError::setServerValuesvoid setServerValues(const char *tmp)Definition RooAbsReal.h:312; RooAbsReal::EvalError::_srvvalstd::string _srvvalDefinition RooAbsReal.h:314; Ro",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:37409,Availability,error,error,37409,"stogramTH1 * fillHistogram(TH1 *hist, const RooArgList &plotVars, double scaleFactor=1, const RooArgSet *projectedVars=nullptr, bool scaling=true, const RooArgSet *condObs=nullptr, bool setError=true) constFill the ROOT histogram 'hist' with values sampled from this function at the bin centers.Definition RooAbsReal.cxx:947; RooAbsReal::createScanRIRooFit::OwningPtr< RooAbsReal > createScanRI(const RooArgSet &iset, const RooArgSet &nset, Int_t numScanBins, Int_t intOrder)Utility function for createRunningIntegral that construct an object implementing the numeric scanning...Definition RooAbsReal.cxx:3810; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const char *rangeName) constCreate integral over observables in iset in range named rangeName.Definition RooAbsReal.h:207; RooAbsReal::defaultErrorLevelvirtual double defaultErrorLevel() constDefinition RooAbsReal.h:248; RooAbsReal::_DEBUG_getValdouble _DEBUG_getVal(const RooArgSet *normalisationSet) constDebug version of getVal(), which is slow and does error checking.Definition RooAbsReal.cxx:4434; RooAbsReal::createFundamentalRooFit::OwningPtr< RooAbsArg > createFundamental(const char *newname=nullptr) const overrideCreate a RooRealVar fundamental object with our properties.Definition RooAbsReal.cxx:3130; RooAbsReal::plotSanityChecksbool plotSanityChecks(RooPlot *frame) constUtility function for plotOn(), perform general sanity check on frame to ensure safe plotting operatio...Definition RooAbsReal.cxx:2860; RooAbsReal::bindVarsRooFit::OwningPtr< RooAbsFunc > bindVars(const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) constCreate an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order).Definition RooAbsReal.cxx:2980; RooAbsReal::selectNormalizationvirtual void selectNormalization(const RooArgSet *depSet=nullptr, bool force=false)Interface function to force use of a given set of observables to interpret functio",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:41182,Availability,error,error,41182,"oAbsReal.cxx:3146; RooAbsReal::fillTreeBranchvoid fillTreeBranch(TTree &t) overrideFill the tree branch that associated with this object with its current value.Definition RooAbsReal.cxx:3099; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooArgSet &nset, const char *rangeName=nullptr) constCreate integral over observables in iset in range named rangeName with integrand normalized over obse...Definition RooAbsReal.h:211; RooAbsReal::printMultilinevoid printMultiline(std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const overrideStructure printing.Definition RooAbsReal.cxx:455; RooAbsReal::plotAsymOnvirtual RooPlot * plotAsymOn(RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) constDefinition RooAbsReal.cxx:2199; RooAbsReal::operator==bool operator==(double value) constEquality operator comparing to a double.Definition RooAbsReal.cxx:250; RooAbsReal::evalErrorLoggingModestatic ErrorLoggingMode evalErrorLoggingMode()Return current evaluation error logging mode.Definition RooAbsReal.cxx:4302; RooAbsReal::redirectServersHookbool redirectServersHook(const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) overrideFunction that is called at the end of redirectServers().Definition RooAbsReal.cxx:4474; RooAbsReal::minTrialSamplesvirtual Int_t minTrialSamples(const RooArgSet &) constDefinition RooAbsReal.h:241; RooAbsReal::isValidRealvirtual bool isValidReal(double, bool printError=false) constInterface function to check if given value is a valid value for this object. Returns true unless over...Definition RooAbsReal.h:447; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::syncCachevoid syncCache(const RooArgSet *set=nullptr) overrideDefinition RooAbsReal.h:456; RooAbsReal::printValuevoid printValue(std::ostr",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:44881,Availability,error,error,44881,"AbsReal.cxx:3675; RooAbsReal::_valuedouble _valueCache for current value of object.Definition RooAbsReal.h:536; RooAbsReal::analyticalIntegralvirtual double analyticalIntegral(Int_t code, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:394; RooAbsReal::attachToTreevoid attachToTree(TTree &t, Int_t bufSize=32000) overrideAttach object to a branch of given TTree.Definition RooAbsReal.cxx:3028; RooAbsReal::BatchInterfaceAccessorfriend class BatchInterfaceAccessorDefinition RooAbsReal.h:399; RooAbsReal::specialIntegratorConfigRooNumIntConfig * specialIntegratorConfig() constReturns the specialized integrator configuration for this RooAbsReal.Definition RooAbsReal.cxx:3282; RooAbsReal::writeToStreamvoid writeToStream(std::ostream &os, bool compact) const overrideWrite object contents to stream (dummy for now)Definition RooAbsReal.cxx:436; RooAbsReal::traceEvaldouble traceEval(const RooArgSet *set) constCalculate current value of object, with error tracing wrapper.Definition RooAbsReal.cxx:319; RooAbsReal::getPropagatedErrordouble getPropagatedError(const RooFitResult &fr, const RooArgSet &nset={}) constPropagates parameter uncertainties to an uncertainty estimate for this RooAbsReal.Definition RooAbsReal.cxx:2472; RooAbsReal::setHideOffsetstatic void setHideOffset(bool flag)Definition RooAbsReal.cxx:191; RooAbsReal::ErrorLoggingModeErrorLoggingModeDefinition RooAbsReal.h:317; RooAbsReal::CountErrors@ CountErrorsDefinition RooAbsReal.h:317; RooAbsReal::CollectErrors@ CollectErrorsDefinition RooAbsReal.h:317; RooAbsReal::PrintErrors@ PrintErrorsDefinition RooAbsReal.h:317; RooAbsReal::Ignore@ IgnoreDefinition RooAbsReal.h:317; RooAbsReal::globalSelectCompstatic void globalSelectComp(bool flag)Global switch controlling the activation of the selectComp() functionality.Definition RooAbsReal.cxx:2966; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooA",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:48460,Availability,error,errors,48460,"CmdArg&, const RooCmdArg&, const RooCmdArg&,...Definition RooAbsReal.cxx:3706; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooNumIntConfig &cfg, const char *rangeName=nullptr) constCreate integral over observables in iset in range named rangeName using specified configuration for a...Definition RooAbsReal.h:220; RooAbsReal::_specIntegratorConfigstd::unique_ptr< RooNumIntConfig > _specIntegratorConfigDefinition RooAbsReal.h:540; RooAbsReal::getAnalyticalIntegralvirtual Int_t getAnalyticalIntegral(RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) constInterface function getAnalyticalIntergral advertises the analytical integrals that are supported.Definition RooAbsReal.cxx:368; RooAbsReal::evalErrorIterstatic std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter()Definition RooAbsReal.cxx:181; RooAbsReal::numEvalErrorsstatic Int_t numEvalErrors()Return the number of logged evaluation errors since the last clearing.Definition RooAbsReal.cxx:3624; RooAbsReal::setEvalErrorLoggingModestatic void setEvalErrorLoggingMode(ErrorLoggingMode m)Set evaluation error logging mode.Definition RooAbsReal.cxx:4316; RooAbsReal::_plotMaxdouble _plotMaxMaximum of plot range.Definition RooAbsReal.h:534; RooAbsReal::preferredObservableScanOrdervirtual void preferredObservableScanOrder(const RooArgSet &obs, RooArgSet &orderedObs) constInterface method for function objects to indicate their preferred order of observables for scanning t...Definition RooAbsReal.cxx:3694; RooAbsReal::maxValvirtual double maxVal(Int_t code) constReturn maximum value for set of observables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive in",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:48628,Availability,error,error,48628,"st RooArgSet &iset, const RooNumIntConfig &cfg, const char *rangeName=nullptr) constCreate integral over observables in iset in range named rangeName using specified configuration for a...Definition RooAbsReal.h:220; RooAbsReal::_specIntegratorConfigstd::unique_ptr< RooNumIntConfig > _specIntegratorConfigDefinition RooAbsReal.h:540; RooAbsReal::getAnalyticalIntegralvirtual Int_t getAnalyticalIntegral(RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) constInterface function getAnalyticalIntergral advertises the analytical integrals that are supported.Definition RooAbsReal.cxx:368; RooAbsReal::evalErrorIterstatic std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter()Definition RooAbsReal.cxx:181; RooAbsReal::numEvalErrorsstatic Int_t numEvalErrors()Return the number of logged evaluation errors since the last clearing.Definition RooAbsReal.cxx:3624; RooAbsReal::setEvalErrorLoggingModestatic void setEvalErrorLoggingMode(ErrorLoggingMode m)Set evaluation error logging mode.Definition RooAbsReal.cxx:4316; RooAbsReal::_plotMaxdouble _plotMaxMaximum of plot range.Definition RooAbsReal.h:534; RooAbsReal::preferredObservableScanOrdervirtual void preferredObservableScanOrder(const RooArgSet &obs, RooArgSet &orderedObs) constInterface method for function objects to indicate their preferred order of observables for scanning t...Definition RooAbsReal.cxx:3694; RooAbsReal::maxValvirtual double maxVal(Int_t code) constReturn maximum value for set of observables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive integrals over functions ...Definition RooAbsReal.cxx:701; RooAbsReal::integralNameSuffixTString integralNameSuffix(const RooArgSet &iset, const RooArgSet *n",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:50183,Availability,error,error,50183,"servables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive integrals over functions ...Definition RooAbsReal.cxx:701; RooAbsReal::integralNameSuffixTString integralNameSuffix(const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::isBinnedDistributionvirtual bool isBinnedDistribution(const RooArgSet &) constTests if the distribution is binned. Unless overridden by derived classes, this always returns false.Definition RooAbsReal.h:346; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the gi",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:51110,Availability,error,error,51110,"bsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::isBinnedDistributionvirtual bool isBinnedDistribution(const RooArgSet &) constTests if the distribution is binned. Unless overridden by derived classes, this always returns false.Definition RooAbsReal.h:346; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsReal.cxx:3827; RooAbsReal::enableOffsettingvirtual void enableOffsetting(bool)Definition RooAbsReal.cxx:4484; RooAbsReal::clearEvalErrorLogstatic void clearEvalErrorLog()Clear the stack of evaluation error messages.Definition RooAbsReal.cxx:3542; RooAbsReal::createIntObjRooFit::OwningPtr< RooAbsReal > createIntObj(const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) constInternal utility function for createIntegral() that creates the actual integral object.Definition RooAbsReal.cxx:590; RooAbsReal::sigmaRooAbsMoment * sigma(RooRealVar &obs, const RooArgSet &nset)Definition RooAbsReal.h:362; RooAbsReal::functorRooFunctor * functor(const RooArgList &ob",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:51544,Availability,error,error,51544,"tconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::isBinnedDistributionvirtual bool isBinnedDistribution(const RooArgSet &) constTests if the distribution is binned. Unless overridden by derived classes, this always returns false.Definition RooAbsReal.h:346; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsReal.cxx:3827; RooAbsReal::enableOffsettingvirtual void enableOffsetting(bool)Definition RooAbsReal.cxx:4484; RooAbsReal::clearEvalErrorLogstatic void clearEvalErrorLog()Clear the stack of evaluation error messages.Definition RooAbsReal.cxx:3542; RooAbsReal::createIntObjRooFit::OwningPtr< RooAbsReal > createIntObj(const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) constInternal utility function for createIntegral() that creates the actual integral object.Definition RooAbsReal.cxx:590; RooAbsReal::sigmaRooAbsMoment * sigma(RooRealVar &obs, const RooArgSet &nset)Definition RooAbsReal.h:362; RooAbsReal::functorRooFunctor * functor(const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) constReturn a RooFunctor object bound to this RooAbsReal with given definition of observables and paramete...Definition RooAbsReal.cxx:3887; RooAbsReal::setCachedValuevoid setCachedValue(double value, bool notifyClients=true) finalOverwrite the value stored in this object's cache.Definition RooAbsReal.h:558; RooAbsReal::_plotBinsInt_t _plotBinsNumber of plot bins.Definition RooA",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:60346,Availability,error,errorFRconst,60346,Real.h:485; RooAbsReal::PlotOpt::projectionRangeNameconst char * projectionRangeNameDefinition RooAbsReal.h:478; RooAbsReal::PlotOpt::eevaldouble eevalDefinition RooAbsReal.h:488; RooAbsReal::PlotOpt::progressbool progressDefinition RooAbsReal.h:490; RooAbsReal::PlotOpt::doeevalbool doeevalDefinition RooAbsReal.h:489; RooAbsReal::PlotOpt::addToWgtSelfdouble addToWgtSelfDefinition RooAbsReal.h:482; RooAbsReal::PlotOpt::shiftToZerobool shiftToZeroDefinition RooAbsReal.h:471; RooAbsReal::PlotOpt::projDataSetconst RooArgSet * projDataSetDefinition RooAbsReal.h:472; RooAbsReal::PlotOpt::binProjDatabool binProjDataDefinition RooAbsReal.h:468; RooAbsReal::PlotOpt::stypeScaleType stypeDefinition RooAbsReal.h:466; RooAbsReal::PlotOpt::curveNameSuffixconst char * curveNameSuffixDefinition RooAbsReal.h:486; RooAbsReal::PlotOpt::addToCurveNameconst char * addToCurveNameDefinition RooAbsReal.h:481; RooAbsReal::PlotOpt::numeeInt_t numeeDefinition RooAbsReal.h:487; RooAbsReal::PlotOpt::errorFRconst RooFitResult * errorFRDefinition RooAbsReal.h:491; RooAbsReal::PlotOpt::rangeHidouble rangeHiDefinition RooAbsReal.h:475; RooAbsReal::PlotOpt::numCPUInt_t numCPUDefinition RooAbsReal.h:484; RooAbsReal::PlotOpt::projSetconst RooArgSet * projSetDefinition RooAbsReal.h:469; RooAbsReal::PlotOpt::postRangeFracScalebool postRangeFracScaleDefinition RooAbsReal.h:476; RooAbsReal::PlotOpt::curveInvisiblebool curveInvisibleDefinition RooAbsReal.h:479; RooAbsReal::PlotOpt::curveNameconst char * curveNameDefinition RooAbsReal.h:480; RooAbsReal::PlotOpt::projDataconst RooAbsData * projDataDefinition RooAbsReal.h:467; RooAbsReal::PlotOpt::drawOptionsOption_t * drawOptionsDefinition RooAbsReal.h:464; RooAbsReal::PlotOpt::rangeLodouble rangeLoDefinition RooAbsReal.h:474; RooFit::UniqueIdA UniqueId can be added as a class member to enhance any class with a unique identifier for each inst...Definition UniqueId.h:39; RooFit::UniqueId::Value_tunsigned long Value_tDefinition UniqueId.h:41; TreeReadBufferDefi,MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:60374,Availability,error,errorFRDefinition,60374,Real.h:485; RooAbsReal::PlotOpt::projectionRangeNameconst char * projectionRangeNameDefinition RooAbsReal.h:478; RooAbsReal::PlotOpt::eevaldouble eevalDefinition RooAbsReal.h:488; RooAbsReal::PlotOpt::progressbool progressDefinition RooAbsReal.h:490; RooAbsReal::PlotOpt::doeevalbool doeevalDefinition RooAbsReal.h:489; RooAbsReal::PlotOpt::addToWgtSelfdouble addToWgtSelfDefinition RooAbsReal.h:482; RooAbsReal::PlotOpt::shiftToZerobool shiftToZeroDefinition RooAbsReal.h:471; RooAbsReal::PlotOpt::projDataSetconst RooArgSet * projDataSetDefinition RooAbsReal.h:472; RooAbsReal::PlotOpt::binProjDatabool binProjDataDefinition RooAbsReal.h:468; RooAbsReal::PlotOpt::stypeScaleType stypeDefinition RooAbsReal.h:466; RooAbsReal::PlotOpt::curveNameSuffixconst char * curveNameSuffixDefinition RooAbsReal.h:486; RooAbsReal::PlotOpt::addToCurveNameconst char * addToCurveNameDefinition RooAbsReal.h:481; RooAbsReal::PlotOpt::numeeInt_t numeeDefinition RooAbsReal.h:487; RooAbsReal::PlotOpt::errorFRconst RooFitResult * errorFRDefinition RooAbsReal.h:491; RooAbsReal::PlotOpt::rangeHidouble rangeHiDefinition RooAbsReal.h:475; RooAbsReal::PlotOpt::numCPUInt_t numCPUDefinition RooAbsReal.h:484; RooAbsReal::PlotOpt::projSetconst RooArgSet * projSetDefinition RooAbsReal.h:469; RooAbsReal::PlotOpt::postRangeFracScalebool postRangeFracScaleDefinition RooAbsReal.h:476; RooAbsReal::PlotOpt::curveInvisiblebool curveInvisibleDefinition RooAbsReal.h:479; RooAbsReal::PlotOpt::curveNameconst char * curveNameDefinition RooAbsReal.h:480; RooAbsReal::PlotOpt::projDataconst RooAbsData * projDataDefinition RooAbsReal.h:467; RooAbsReal::PlotOpt::drawOptionsOption_t * drawOptionsDefinition RooAbsReal.h:464; RooAbsReal::PlotOpt::rangeLodouble rangeLoDefinition RooAbsReal.h:474; RooFit::UniqueIdA UniqueId can be added as a class member to enhance any class with a unique identifier for each inst...Definition UniqueId.h:39; RooFit::UniqueId::Value_tunsigned long Value_tDefinition UniqueId.h:41; TreeReadBufferDefi,MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:3810,Deployability,integrat,integrated,3810,"nst char* name=nullptr);; 84 ~RooAbsReal() override;; 85 ; 86 ; 87 ; 88 ; 89 //////////////////////////////////////////////////////////////////////////////////; 90 /// Evaluate object. Returns either cached value or triggers a recalculation.; 91 /// The recalculation happens by calling getValV(), which in the end calls the; 92 /// virtual evaluate() functions of the respective PDFs.; 93 /// \param[in] normalisationSet getValV() reacts differently depending on the value of the normalisation set.; 94 /// If the set is `nullptr`, an unnormalised value is returned.; 95 /// \note The normalisation is arbitrary, because it is up to the implementation; 96 /// of the PDF to e.g. leave out normalisation constants for speed reasons. The range; 97 /// of the variables is also ignored.; 98 ///; 99 /// To normalise the result properly, a RooArgSet has to be passed, which contains; 100 /// the variables to normalise over.; 101 /// These are integrated over their current ranges to compute the normalisation constant,; 102 /// and the unnormalised result is divided by this value.; 103 inline double getVal(const RooArgSet* normalisationSet = nullptr) const {; 104 // Sometimes, the calling code uses an empty RooArgSet to request evaluation; 105 // without normalization set instead of following the `nullptr` convention.; 106 // To remove this ambiguity which might not always be correctly handled in; 107 // downstream code, we set `normalisationSet` to nullptr if it is pointing; 108 // to an empty set.; 109 if(normalisationSet && normalisationSet->empty()) {; 110 normalisationSet = nullptr;; 111 }; 112#ifdef ROOFIT_CHECK_CACHED_VALUES; 113 return _DEBUG_getVal(normalisationSet);; 114#else; 115 ; 116#ifndef _WIN32; 117 return (_fast && !_inhibitDirty) ? _value : getValV(normalisationSet) ;; 118#else; 119 return (_fast && !inhibitDirty()) ? _value : getValV(normalisationSet) ;; 120#endif; 121 ; 122#endif; 123 }; 124 ; 125 /// Like getVal(const RooArgSet*), but always requires an argument ",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:6463,Deployability,integrat,integration,6463," const override;; 141 ; 142 ; 143 inline const Text_t *getUnit() const {; 144 // Return string with unit description; 145 return _unit.Data();; 146 }; 147 inline void setUnit(const char *unit) {; 148 // Set unit description to given string; 149 _unit= unit;; 150 }; 151 TString getTitle(bool appendUnit= false) const;; 152 ; 153 // Lightweight interface adaptors (caller takes ownership); 154 RooFit::OwningPtr<RooAbsFunc> bindVars(const RooArgSet &vars, const RooArgSet* nset=nullptr, bool clipInvalid=false) const;; 155 ; 156 // Create a fundamental-type object that can hold our value.; 157 RooFit::OwningPtr<RooAbsArg> createFundamental(const char* newname=nullptr) const override;; 158 ; 159 // Analytical integration support; 160 virtual Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 161 virtual double analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 162 virtual Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName=nullptr) const ;; 163 virtual double analyticalIntegral(Int_t code, const char* rangeName=nullptr) const ;; 164 virtual bool forceAnalyticalInt(const RooAbsArg& /*dep*/) const {; 165 // Interface to force RooRealIntegral to offer given observable for internal integration; 166 // even if this is deemed unsafe. This default implementation returns always false; 167 return false ;; 168 }; 169 virtual void forceNumInt(bool flag=true) {; 170 // If flag is true, all advertised analytical integrals will be ignored; 171 // and all integrals are calculated numerically; 172 _forceNumInt = flag ;; 173 }; 174 bool getForceNumInt() const { return _forceNumInt ; }; 175 ; 176 // Chi^2 fits to histograms; 177 virtual RooFit::OwningPtr<RooFitResult> chi2FitTo(RooDataHist& data, const RooCmdArg& arg1={}, const RooCmdArg& arg2={},; 178 const RooCmdArg& arg3={}, const RooCmdArg& arg4={}, const RooCmdArg& a",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:7114,Deployability,integrat,integration,7114," const override;; 141 ; 142 ; 143 inline const Text_t *getUnit() const {; 144 // Return string with unit description; 145 return _unit.Data();; 146 }; 147 inline void setUnit(const char *unit) {; 148 // Set unit description to given string; 149 _unit= unit;; 150 }; 151 TString getTitle(bool appendUnit= false) const;; 152 ; 153 // Lightweight interface adaptors (caller takes ownership); 154 RooFit::OwningPtr<RooAbsFunc> bindVars(const RooArgSet &vars, const RooArgSet* nset=nullptr, bool clipInvalid=false) const;; 155 ; 156 // Create a fundamental-type object that can hold our value.; 157 RooFit::OwningPtr<RooAbsArg> createFundamental(const char* newname=nullptr) const override;; 158 ; 159 // Analytical integration support; 160 virtual Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 161 virtual double analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 162 virtual Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName=nullptr) const ;; 163 virtual double analyticalIntegral(Int_t code, const char* rangeName=nullptr) const ;; 164 virtual bool forceAnalyticalInt(const RooAbsArg& /*dep*/) const {; 165 // Interface to force RooRealIntegral to offer given observable for internal integration; 166 // even if this is deemed unsafe. This default implementation returns always false; 167 return false ;; 168 }; 169 virtual void forceNumInt(bool flag=true) {; 170 // If flag is true, all advertised analytical integrals will be ignored; 171 // and all integrals are calculated numerically; 172 _forceNumInt = flag ;; 173 }; 174 bool getForceNumInt() const { return _forceNumInt ; }; 175 ; 176 // Chi^2 fits to histograms; 177 virtual RooFit::OwningPtr<RooFitResult> chi2FitTo(RooDataHist& data, const RooCmdArg& arg1={}, const RooCmdArg& arg2={},; 178 const RooCmdArg& arg3={}, const RooCmdArg& arg4={}, const RooCmdArg& a",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:10351,Deployability,configurat,configuration,10351,"RooCmdArg& arg3={}, const RooCmdArg& arg4={}, const RooCmdArg& arg5={},; 196 const RooCmdArg& arg6={}, const RooCmdArg& arg7={}, const RooCmdArg& arg8={}) ;; 197 ; 198 virtual RooFit::OwningPtr<RooAbsReal> createProfile(const RooArgSet& paramsOfInterest) ;; 199 ; 200 ; 201 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2={},; 202 const RooCmdArg& arg3={}, const RooCmdArg& arg4={},; 203 const RooCmdArg& arg5={}, const RooCmdArg& arg6={},; 204 const RooCmdArg& arg7={}, const RooCmdArg& arg8={}) const ;; 205 ; 206 /// Create integral over observables in iset in range named rangeName.; 207 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const char* rangeName) const {; 208 return createIntegral(iset,nullptr,nullptr,rangeName) ;; 209 }; 210 /// Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset; 211 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooArgSet& nset, const char* rangeName=nullptr) const {; 212 return createIntegral(iset,&nset,nullptr,rangeName) ;; 213 }; 214 /// Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset while; 215 /// using specified configuration for any numeric integration.; 216 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooArgSet& nset, const RooNumIntConfig& cfg, const char* rangeName=nullptr) const {; 217 return createIntegral(iset,&nset,&cfg,rangeName) ;; 218 }; 219 /// Create integral over observables in iset in range named rangeName using specified configuration for any numeric integration.; 220 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooNumIntConfig& cfg, const char* rangeName=nullptr) const {; 221 return createIntegral(iset,nullptr,&cfg,rangeName) ;; 222 }; 223 virtual RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, cons",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:10381,Deployability,integrat,integration,10381,"RooCmdArg& arg3={}, const RooCmdArg& arg4={}, const RooCmdArg& arg5={},; 196 const RooCmdArg& arg6={}, const RooCmdArg& arg7={}, const RooCmdArg& arg8={}) ;; 197 ; 198 virtual RooFit::OwningPtr<RooAbsReal> createProfile(const RooArgSet& paramsOfInterest) ;; 199 ; 200 ; 201 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2={},; 202 const RooCmdArg& arg3={}, const RooCmdArg& arg4={},; 203 const RooCmdArg& arg5={}, const RooCmdArg& arg6={},; 204 const RooCmdArg& arg7={}, const RooCmdArg& arg8={}) const ;; 205 ; 206 /// Create integral over observables in iset in range named rangeName.; 207 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const char* rangeName) const {; 208 return createIntegral(iset,nullptr,nullptr,rangeName) ;; 209 }; 210 /// Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset; 211 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooArgSet& nset, const char* rangeName=nullptr) const {; 212 return createIntegral(iset,&nset,nullptr,rangeName) ;; 213 }; 214 /// Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset while; 215 /// using specified configuration for any numeric integration.; 216 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooArgSet& nset, const RooNumIntConfig& cfg, const char* rangeName=nullptr) const {; 217 return createIntegral(iset,&nset,&cfg,rangeName) ;; 218 }; 219 /// Create integral over observables in iset in range named rangeName using specified configuration for any numeric integration.; 220 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooNumIntConfig& cfg, const char* rangeName=nullptr) const {; 221 return createIntegral(iset,nullptr,&cfg,rangeName) ;; 222 }; 223 virtual RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, cons",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:10711,Deployability,configurat,configuration,10711,"7={}, const RooCmdArg& arg8={}) const ;; 205 ; 206 /// Create integral over observables in iset in range named rangeName.; 207 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const char* rangeName) const {; 208 return createIntegral(iset,nullptr,nullptr,rangeName) ;; 209 }; 210 /// Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset; 211 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooArgSet& nset, const char* rangeName=nullptr) const {; 212 return createIntegral(iset,&nset,nullptr,rangeName) ;; 213 }; 214 /// Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset while; 215 /// using specified configuration for any numeric integration.; 216 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooArgSet& nset, const RooNumIntConfig& cfg, const char* rangeName=nullptr) const {; 217 return createIntegral(iset,&nset,&cfg,rangeName) ;; 218 }; 219 /// Create integral over observables in iset in range named rangeName using specified configuration for any numeric integration.; 220 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooNumIntConfig& cfg, const char* rangeName=nullptr) const {; 221 return createIntegral(iset,nullptr,&cfg,rangeName) ;; 222 }; 223 virtual RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooArgSet* nset=nullptr, const RooNumIntConfig* cfg=nullptr, const char* rangeName=nullptr) const ;; 224 ; 225 ; 226 void setParameterizeIntegral(const RooArgSet& paramVars) ;; 227 ; 228 // Create running integrals; 229 RooFit::OwningPtr<RooAbsReal> createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset={}) ;; 230 RooFit::OwningPtr<RooAbsReal> createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2={},; 231 const RooCmdArg& arg3={}, const RooCmdArg& arg4={},; 232 const RooCmdA",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:10741,Deployability,integrat,integration,10741,"7={}, const RooCmdArg& arg8={}) const ;; 205 ; 206 /// Create integral over observables in iset in range named rangeName.; 207 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const char* rangeName) const {; 208 return createIntegral(iset,nullptr,nullptr,rangeName) ;; 209 }; 210 /// Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset; 211 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooArgSet& nset, const char* rangeName=nullptr) const {; 212 return createIntegral(iset,&nset,nullptr,rangeName) ;; 213 }; 214 /// Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset while; 215 /// using specified configuration for any numeric integration.; 216 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooArgSet& nset, const RooNumIntConfig& cfg, const char* rangeName=nullptr) const {; 217 return createIntegral(iset,&nset,&cfg,rangeName) ;; 218 }; 219 /// Create integral over observables in iset in range named rangeName using specified configuration for any numeric integration.; 220 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooNumIntConfig& cfg, const char* rangeName=nullptr) const {; 221 return createIntegral(iset,nullptr,&cfg,rangeName) ;; 222 }; 223 virtual RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooArgSet* nset=nullptr, const RooNumIntConfig* cfg=nullptr, const char* rangeName=nullptr) const ;; 224 ; 225 ; 226 void setParameterizeIntegral(const RooArgSet& paramVars) ;; 227 ; 228 // Create running integrals; 229 RooFit::OwningPtr<RooAbsReal> createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset={}) ;; 230 RooFit::OwningPtr<RooAbsReal> createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2={},; 231 const RooCmdArg& arg3={}, const RooCmdArg& arg4={},; 232 const RooCmdA",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:21222,Deployability,integrat,integration,21222,"Obs=nullptr) const;; 385 virtual void doEval(RooFit::EvalContext &) const;; 386 ; 387 virtual bool hasGradient() const { return false; }; 388 virtual void gradient(double *) const {; 389 if(!hasGradient()) throw std::runtime_error(""RooAbsReal::gradient(double *) not implemented by this class!"");; 390 }; 391 ; 392 virtual std::string; 393 buildCallToAnalyticIntegral(Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const;; 394 ; 395 // PlotOn with command list; 396 virtual RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const ;; 397 ; 398protected:; 399 friend class BatchInterfaceAccessor;; 400 friend class RooVectorDataStore;; 401 friend class RooRealBinding;; 402 friend class RooRealSumPdf;; 403 friend class RooRealSumFunc;; 404 friend class RooAddHelpers;; 405 friend class RooAddPdf;; 406 friend class RooAddModel;; 407 friend class AddCacheElem;; 408 friend class RooFit::EvalContext;; 409 ; 410 // Hook for objects with normalization-dependent parameters interpretation; 411 virtual void selectNormalization(const RooArgSet* depSet=nullptr, bool force=false) ;; 412 virtual void selectNormalizationRange(const char* rangeName=nullptr, bool force=false) ;; 413 ; 414 // Helper functions for plotting; 415 bool plotSanityChecks(RooPlot* frame) const ;; 416 void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars,; 417 RooArgSet& projectedVars, bool silent) const ;; 418 ; 419 TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset=nullptr, const char* rangeName=nullptr, bool omitEmpty=false) const ;; 420 ; 421 void plotOnCompSelect(RooArgSet* selNodes) const ;; 422 RooPlot* plotOnWithErrorBand(RooPlot* frame,const RooFitResult& fr, double Z, const RooArgSet* params, const RooLinkedList& argList, bool method1) const ;; 423 ; 424 // Support interface for subclasses to advertise their analytic integration; 425 // and generator capabilities in their analyticalIntegral() and generateEvent(); 426 // implementations.",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:26184,Deployability,integrat,integration,26184,"tate;; 521 };; 522 ; 523 ; 524private:; 525 ; 526 /// Debug version of getVal(), which is slow and does error checking.; 527 double _DEBUG_getVal(const RooArgSet* normalisationSet) const;; 528 ; 529 //--------------------------------------------------------------------; 530 ; 531 protected:; 532 ; 533 double _plotMin = 0.0; ///< Minimum of plot range; 534 double _plotMax = 0.0; ///< Maximum of plot range; 535 Int_t _plotBins = 100; ///< Number of plot bins; 536 mutable double _value = 0.0; ///< Cache for current value of object; 537 TString _unit; ///< Unit for objects value; 538 TString _label; ///< Plot label for objects value; 539 bool _forceNumInt = false; ///< Force numerical integration if flag set; 540 std::unique_ptr<RooNumIntConfig> _specIntegratorConfig; // Numeric integrator configuration specific for this object; 541 TreeReadBuffer *_treeReadBuffer = nullptr; //! A buffer for reading values from trees; 542 bool _selectComp = true; //! Component selection flag for RooAbsPdf::plotCompOn; 543 mutable RooFit::UniqueId<RooArgSet>::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval; ///<!; 544 ; 545 static bool _globalSelectComp; // Global activation switch for component selection; 546 static bool _hideOffset; ///< Offset hiding flag; 547 ; 548 ClassDefOverride(RooAbsReal,3); // Abstract real-valued variable; 549};; 550 ; 551 ; 552////////////////////////////////////////////////////////////////////////////////; 553/// Overwrite the value stored in this object's cache.; 554/// This can be used to fake a computation that resulted in `value`.; 555/// \param[in] value Value to write.; 556/// \param[in] notifyClients If true, notify users of this object that its value changed.; 557/// This is the default.; 558void RooAbsReal::setCachedValue(double value, bool notifyClients) {; 559 _value = value;; 560 ; 561 if (notifyClients) {; 562 setValueDirty();; 563 _valueDirty = false;; 564 }; 565}; 566 ; 567 ; 568#endif; CodeSquashContext.h; EvalContext.h; d#define",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:26280,Deployability,integrat,integrator,26280,"tate;; 521 };; 522 ; 523 ; 524private:; 525 ; 526 /// Debug version of getVal(), which is slow and does error checking.; 527 double _DEBUG_getVal(const RooArgSet* normalisationSet) const;; 528 ; 529 //--------------------------------------------------------------------; 530 ; 531 protected:; 532 ; 533 double _plotMin = 0.0; ///< Minimum of plot range; 534 double _plotMax = 0.0; ///< Maximum of plot range; 535 Int_t _plotBins = 100; ///< Number of plot bins; 536 mutable double _value = 0.0; ///< Cache for current value of object; 537 TString _unit; ///< Unit for objects value; 538 TString _label; ///< Plot label for objects value; 539 bool _forceNumInt = false; ///< Force numerical integration if flag set; 540 std::unique_ptr<RooNumIntConfig> _specIntegratorConfig; // Numeric integrator configuration specific for this object; 541 TreeReadBuffer *_treeReadBuffer = nullptr; //! A buffer for reading values from trees; 542 bool _selectComp = true; //! Component selection flag for RooAbsPdf::plotCompOn; 543 mutable RooFit::UniqueId<RooArgSet>::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval; ///<!; 544 ; 545 static bool _globalSelectComp; // Global activation switch for component selection; 546 static bool _hideOffset; ///< Offset hiding flag; 547 ; 548 ClassDefOverride(RooAbsReal,3); // Abstract real-valued variable; 549};; 550 ; 551 ; 552////////////////////////////////////////////////////////////////////////////////; 553/// Overwrite the value stored in this object's cache.; 554/// This can be used to fake a computation that resulted in `value`.; 555/// \param[in] value Value to write.; 556/// \param[in] notifyClients If true, notify users of this object that its value changed.; 557/// This is the default.; 558void RooAbsReal::setCachedValue(double value, bool notifyClients) {; 559 _value = value;; 560 ; 561 if (notifyClients) {; 562 setValueDirty();; 563 _valueDirty = false;; 564 }; 565}; 566 ; 567 ; 568#endif; CodeSquashContext.h; EvalContext.h; d#define",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:26291,Deployability,configurat,configuration,26291,"tate;; 521 };; 522 ; 523 ; 524private:; 525 ; 526 /// Debug version of getVal(), which is slow and does error checking.; 527 double _DEBUG_getVal(const RooArgSet* normalisationSet) const;; 528 ; 529 //--------------------------------------------------------------------; 530 ; 531 protected:; 532 ; 533 double _plotMin = 0.0; ///< Minimum of plot range; 534 double _plotMax = 0.0; ///< Maximum of plot range; 535 Int_t _plotBins = 100; ///< Number of plot bins; 536 mutable double _value = 0.0; ///< Cache for current value of object; 537 TString _unit; ///< Unit for objects value; 538 TString _label; ///< Plot label for objects value; 539 bool _forceNumInt = false; ///< Force numerical integration if flag set; 540 std::unique_ptr<RooNumIntConfig> _specIntegratorConfig; // Numeric integrator configuration specific for this object; 541 TreeReadBuffer *_treeReadBuffer = nullptr; //! A buffer for reading values from trees; 542 bool _selectComp = true; //! Component selection flag for RooAbsPdf::plotCompOn; 543 mutable RooFit::UniqueId<RooArgSet>::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval; ///<!; 544 ; 545 static bool _globalSelectComp; // Global activation switch for component selection; 546 static bool _hideOffset; ///< Offset hiding flag; 547 ; 548 ClassDefOverride(RooAbsReal,3); // Abstract real-valued variable; 549};; 550 ; 551 ; 552////////////////////////////////////////////////////////////////////////////////; 553/// Overwrite the value stored in this object's cache.; 554/// This can be used to fake a computation that resulted in `value`.; 555/// \param[in] value Value to write.; 556/// \param[in] notifyClients If true, notify users of this object that its value changed.; 557/// This is the default.; 558void RooAbsReal::setCachedValue(double value, bool notifyClients) {; 559 _value = value;; 560 ; 561 if (notifyClients) {; 562 setValueDirty();; 563 _valueDirty = false;; 564 }; 565}; 566 ; 567 ; 568#endif; CodeSquashContext.h; EvalContext.h; d#define",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:35605,Deployability,integrat,integration,35605,"bsReal::numEvalErrorItemsstatic Int_t numEvalErrorItems()Definition RooAbsReal.cxx:176; RooAbsReal::RooAbsRealRooAbsReal()coverity[UNINIT_CTOR] Default constructorDefinition RooAbsReal.cxx:199; RooAbsReal::fixAddCoefNormalizationvirtual void fixAddCoefNormalization(const RooArgSet &addNormSet=RooArgSet(), bool force=true)Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by...Definition RooAbsReal.cxx:3650; RooAbsReal::hasGradientvirtual bool hasGradient() constDefinition RooAbsReal.h:387; RooAbsReal::getAnalyticalIntegralWNvirtual Int_t getAnalyticalIntegralWN(RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) constVariant of getAnalyticalIntegral that is also passed the normalization set that should be applied to ...Definition RooAbsReal.cxx:351; RooAbsReal::isValidbool isValid() const overrideCheck if current value is valid.Definition RooAbsReal.h:445; RooAbsReal::_forceNumIntbool _forceNumIntForce numerical integration if flag set.Definition RooAbsReal.h:539; RooAbsReal::~RooAbsReal~RooAbsReal() overrideDestructor.Definition RooAbsReal.cxx:238; RooAbsReal::setParameterizeIntegralvoid setParameterizeIntegral(const RooArgSet &paramVars)Definition RooAbsReal.cxx:4324; RooAbsReal::matchArgsByNamebool matchArgsByName(const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) constCheck if allArgs contains matching elements for each name in nameList.Definition RooAbsReal.cxx:3241; RooAbsReal::hideOffsetstatic bool hideOffset()Definition RooAbsReal.cxx:192; RooAbsReal::setTreeBranchStatusvoid setTreeBranchStatus(TTree &t, bool active) override(De)Activate associated tree branchDefinition RooAbsReal.cxx:3116; RooAbsReal::fillHistogramTH1 * fillHistogram(TH1 *hist, const RooArgList &plotVars, double scaleFactor=1, const RooArgSet *projectedVars=nullptr, bool scaling=true, const RooArgSet *condObs=nullptr, bool setError=true) constFill the ROOT histogram 'hist' wit",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:39516,Deployability,integrat,integration,39516,"001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Perform a fit to given histogram.Definition RooAbsReal.cxx:4105; RooAbsReal::asTFTF1 * asTF(const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) constReturn a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parame...Definition RooAbsReal.cxx:3911; RooAbsReal::setDatavirtual bool setData(RooAbsData &, bool=true)Definition RooAbsReal.h:367; RooAbsReal::_unitTString _unitUnit for objects value.Definition RooAbsReal.h:537; RooAbsReal::defaultIntegratorConfigstatic RooNumIntConfig * defaultIntegratorConfig()Returns the default numeric integration configuration for all RooAbsReals.Definition RooAbsReal.cxx:3272; RooAbsReal::getValdouble getVal(const RooArgSet &normalisationSet) constLike getVal(const RooArgSet*), but always requires an argument for normalisation.Definition RooAbsReal.h:126; RooAbsReal::readFromStreambool readFromStream(std::istream &is, bool compact, bool verbose=false) overrideRead object contents from stream (dummy for now)Definition RooAbsReal.cxx:426; RooAbsReal::matchArgsbool matchArgs(const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a) constUtility function for use in getAnalyticalIntegral().Definition RooAbsReal.cxx:3146; RooAbsReal::fillTreeBranchvoid fillTreeBranch(TTree &t) overrideFill the tree branch that associated with this object with its current value.Definition RooAbsReal.cxx:3099; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooArgSet &nset, const char *rangeName=nullptr) co",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:39528,Deployability,configurat,configuration,39528,"001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Perform a fit to given histogram.Definition RooAbsReal.cxx:4105; RooAbsReal::asTFTF1 * asTF(const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) constReturn a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parame...Definition RooAbsReal.cxx:3911; RooAbsReal::setDatavirtual bool setData(RooAbsData &, bool=true)Definition RooAbsReal.h:367; RooAbsReal::_unitTString _unitUnit for objects value.Definition RooAbsReal.h:537; RooAbsReal::defaultIntegratorConfigstatic RooNumIntConfig * defaultIntegratorConfig()Returns the default numeric integration configuration for all RooAbsReals.Definition RooAbsReal.cxx:3272; RooAbsReal::getValdouble getVal(const RooArgSet &normalisationSet) constLike getVal(const RooArgSet*), but always requires an argument for normalisation.Definition RooAbsReal.h:126; RooAbsReal::readFromStreambool readFromStream(std::istream &is, bool compact, bool verbose=false) overrideRead object contents from stream (dummy for now)Definition RooAbsReal.cxx:426; RooAbsReal::matchArgsbool matchArgs(const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a) constUtility function for use in getAnalyticalIntegral().Definition RooAbsReal.cxx:3146; RooAbsReal::fillTreeBranchvoid fillTreeBranch(TTree &t) overrideFill the tree branch that associated with this object with its current value.Definition RooAbsReal.cxx:3099; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooArgSet &nset, const char *rangeName=nullptr) co",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:41899,Deployability,integrat,integration,41899,"ategoryLValue &asymCat, PlotOpt o) constDefinition RooAbsReal.cxx:2199; RooAbsReal::operator==bool operator==(double value) constEquality operator comparing to a double.Definition RooAbsReal.cxx:250; RooAbsReal::evalErrorLoggingModestatic ErrorLoggingMode evalErrorLoggingMode()Return current evaluation error logging mode.Definition RooAbsReal.cxx:4302; RooAbsReal::redirectServersHookbool redirectServersHook(const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) overrideFunction that is called at the end of redirectServers().Definition RooAbsReal.cxx:4474; RooAbsReal::minTrialSamplesvirtual Int_t minTrialSamples(const RooArgSet &) constDefinition RooAbsReal.h:241; RooAbsReal::isValidRealvirtual bool isValidReal(double, bool printError=false) constInterface function to check if given value is a valid value for this object. Returns true unless over...Definition RooAbsReal.h:447; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::syncCachevoid syncCache(const RooArgSet *set=nullptr) overrideDefinition RooAbsReal.h:456; RooAbsReal::printValuevoid printValue(std::ostream &os) const overridePrint object value.Definition RooAbsReal.cxx:445; RooAbsReal::forceAnalyticalIntvirtual bool forceAnalyticalInt(const RooAbsArg &) constDefinition RooAbsReal.h:164; RooAbsReal::isIdenticalbool isIdentical(const RooAbsArg &other, bool assumeSameType=false) const overrideDefinition RooAbsReal.cxx:270; RooAbsReal::setUnitvoid setUnit(const char *unit)Definition RooAbsReal.h:147; RooAbsReal::getForceNumIntbool getForceNumInt() constDefinition RooAbsReal.h:174; RooAbsReal::createProfilevirtual RooFit::OwningPtr< RooAbsReal > createProfile(const RooArgSet &paramsOfInterest)Create a RooProfileLL object that eliminates all nuisance parameters in the present function.Definition RooAbsReal.cxx:471; RooAbsReal::_hideOffset",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:41911,Deployability,configurat,configuration,41911,"ategoryLValue &asymCat, PlotOpt o) constDefinition RooAbsReal.cxx:2199; RooAbsReal::operator==bool operator==(double value) constEquality operator comparing to a double.Definition RooAbsReal.cxx:250; RooAbsReal::evalErrorLoggingModestatic ErrorLoggingMode evalErrorLoggingMode()Return current evaluation error logging mode.Definition RooAbsReal.cxx:4302; RooAbsReal::redirectServersHookbool redirectServersHook(const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) overrideFunction that is called at the end of redirectServers().Definition RooAbsReal.cxx:4474; RooAbsReal::minTrialSamplesvirtual Int_t minTrialSamples(const RooArgSet &) constDefinition RooAbsReal.h:241; RooAbsReal::isValidRealvirtual bool isValidReal(double, bool printError=false) constInterface function to check if given value is a valid value for this object. Returns true unless over...Definition RooAbsReal.h:447; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::syncCachevoid syncCache(const RooArgSet *set=nullptr) overrideDefinition RooAbsReal.h:456; RooAbsReal::printValuevoid printValue(std::ostream &os) const overridePrint object value.Definition RooAbsReal.cxx:445; RooAbsReal::forceAnalyticalIntvirtual bool forceAnalyticalInt(const RooAbsArg &) constDefinition RooAbsReal.h:164; RooAbsReal::isIdenticalbool isIdentical(const RooAbsArg &other, bool assumeSameType=false) const overrideDefinition RooAbsReal.cxx:270; RooAbsReal::setUnitvoid setUnit(const char *unit)Definition RooAbsReal.h:147; RooAbsReal::getForceNumIntbool getForceNumInt() constDefinition RooAbsReal.h:174; RooAbsReal::createProfilevirtual RooFit::OwningPtr< RooAbsReal > createProfile(const RooArgSet &paramsOfInterest)Create a RooProfileLL object that eliminates all nuisance parameters in the present function.Definition RooAbsReal.cxx:471; RooAbsReal::_hideOffset",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:44531,Deployability,integrat,integrator,44531,"ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables w...Definition RooAbsReal.cxx:1183; RooAbsReal::fixAddCoefRangevirtual void fixAddCoefRange(const char *rangeName=nullptr, bool force=true)Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by...Definition RooAbsReal.cxx:3675; RooAbsReal::_valuedouble _valueCache for current value of object.Definition RooAbsReal.h:536; RooAbsReal::analyticalIntegralvirtual double analyticalIntegral(Int_t code, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:394; RooAbsReal::attachToTreevoid attachToTree(TTree &t, Int_t bufSize=32000) overrideAttach object to a branch of given TTree.Definition RooAbsReal.cxx:3028; RooAbsReal::BatchInterfaceAccessorfriend class BatchInterfaceAccessorDefinition RooAbsReal.h:399; RooAbsReal::specialIntegratorConfigRooNumIntConfig * specialIntegratorConfig() constReturns the specialized integrator configuration for this RooAbsReal.Definition RooAbsReal.cxx:3282; RooAbsReal::writeToStreamvoid writeToStream(std::ostream &os, bool compact) const overrideWrite object contents to stream (dummy for now)Definition RooAbsReal.cxx:436; RooAbsReal::traceEvaldouble traceEval(const RooArgSet *set) constCalculate current value of object, with error tracing wrapper.Definition RooAbsReal.cxx:319; RooAbsReal::getPropagatedErrordouble getPropagatedError(const RooFitResult &fr, const RooArgSet &nset={}) constPropagates parameter uncertainties to an uncertainty estimate for this RooAbsReal.Definition RooAbsReal.cxx:2472; RooAbsReal::setHideOffsetstatic void setHideOffset(bool flag)Definition RooAbsReal.cxx:191; RooAbsReal::ErrorLoggingModeErrorLoggingModeDefinition RooAbsReal.h:317; RooAbsReal::CountErrors@ CountErrorsDefinition RooAbsReal.h:317; RooAbsReal::CollectErrors@ CollectErrorsDefinition RooAbsReal.h:317; RooAbsReal::PrintErrors@ PrintErrorsDe",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:44542,Deployability,configurat,configuration,44542,"ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables w...Definition RooAbsReal.cxx:1183; RooAbsReal::fixAddCoefRangevirtual void fixAddCoefRange(const char *rangeName=nullptr, bool force=true)Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by...Definition RooAbsReal.cxx:3675; RooAbsReal::_valuedouble _valueCache for current value of object.Definition RooAbsReal.h:536; RooAbsReal::analyticalIntegralvirtual double analyticalIntegral(Int_t code, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:394; RooAbsReal::attachToTreevoid attachToTree(TTree &t, Int_t bufSize=32000) overrideAttach object to a branch of given TTree.Definition RooAbsReal.cxx:3028; RooAbsReal::BatchInterfaceAccessorfriend class BatchInterfaceAccessorDefinition RooAbsReal.h:399; RooAbsReal::specialIntegratorConfigRooNumIntConfig * specialIntegratorConfig() constReturns the specialized integrator configuration for this RooAbsReal.Definition RooAbsReal.cxx:3282; RooAbsReal::writeToStreamvoid writeToStream(std::ostream &os, bool compact) const overrideWrite object contents to stream (dummy for now)Definition RooAbsReal.cxx:436; RooAbsReal::traceEvaldouble traceEval(const RooArgSet *set) constCalculate current value of object, with error tracing wrapper.Definition RooAbsReal.cxx:319; RooAbsReal::getPropagatedErrordouble getPropagatedError(const RooFitResult &fr, const RooArgSet &nset={}) constPropagates parameter uncertainties to an uncertainty estimate for this RooAbsReal.Definition RooAbsReal.cxx:2472; RooAbsReal::setHideOffsetstatic void setHideOffset(bool flag)Definition RooAbsReal.cxx:191; RooAbsReal::ErrorLoggingModeErrorLoggingModeDefinition RooAbsReal.h:317; RooAbsReal::CountErrors@ CountErrorsDefinition RooAbsReal.h:317; RooAbsReal::CollectErrors@ CollectErrorsDefinition RooAbsReal.h:317; RooAbsReal::PrintErrors@ PrintErrorsDe",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:47746,Deployability,configurat,configuration,47746,"r, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) constPlot function or PDF on frame with support for visualization of the uncertainty encoded in the given ...Definition RooAbsReal.cxx:2601; RooAbsReal::_lastNormSetIdRooFit::UniqueId< RooArgSet >::Value_t _lastNormSetIdComponent selection flag for RooAbsPdf::plotCompOn.Definition RooAbsReal.h:543; RooAbsReal::getPlotLabelconst char * getPlotLabel() constGet the label associated with the variable.Definition RooAbsReal.cxx:406; RooAbsReal::forceNumIntvirtual void forceNumInt(bool flag=true)Definition RooAbsReal.h:169; RooAbsReal::createRunningIntegralRooFit::OwningPtr< RooAbsReal > createRunningIntegral(const RooArgSet &iset, const RooArgSet &nset={})Calls createRunningIntegral(const RooArgSet&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&,...Definition RooAbsReal.cxx:3706; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooNumIntConfig &cfg, const char *rangeName=nullptr) constCreate integral over observables in iset in range named rangeName using specified configuration for a...Definition RooAbsReal.h:220; RooAbsReal::_specIntegratorConfigstd::unique_ptr< RooNumIntConfig > _specIntegratorConfigDefinition RooAbsReal.h:540; RooAbsReal::getAnalyticalIntegralvirtual Int_t getAnalyticalIntegral(RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) constInterface function getAnalyticalIntergral advertises the analytical integrals that are supported.Definition RooAbsReal.cxx:368; RooAbsReal::evalErrorIterstatic std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter()Definition RooAbsReal.cxx:181; RooAbsReal::numEvalErrorsstatic Int_t numEvalErrors()Return the number of logged evaluation errors since the last clearing.Definition RooAbsReal.cxx:3624; RooAbsReal::setEvalErrorLoggingModestatic void setEvalErrorLoggingMode(ErrorLoggingMode m)Set evaluation er",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:49732,Deployability,integrat,integrated,49732,"Set evaluation error logging mode.Definition RooAbsReal.cxx:4316; RooAbsReal::_plotMaxdouble _plotMaxMaximum of plot range.Definition RooAbsReal.h:534; RooAbsReal::preferredObservableScanOrdervirtual void preferredObservableScanOrder(const RooArgSet &obs, RooArgSet &orderedObs) constInterface method for function objects to indicate their preferred order of observables for scanning t...Definition RooAbsReal.cxx:3694; RooAbsReal::maxValvirtual double maxVal(Int_t code) constReturn maximum value for set of observables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive integrals over functions ...Definition RooAbsReal.cxx:701; RooAbsReal::integralNameSuffixTString integralNameSuffix(const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:50662,Deployability,integrat,integration,50662,"itEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::isBinnedDistributionvirtual bool isBinnedDistribution(const RooArgSet &) constTests if the distribution is binned. Unless overridden by derived classes, this always returns false.Definition RooAbsReal.h:346; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsReal.cxx:3827; RooAbsReal::enableOffsettingvirtual void enableOffsetting(bool)Definition RooAbsReal.cxx:4484; RooAbsReal::clearEvalErrorLogstatic void clearEvalErrorLog()Clear the stack of evaluation error messages.Definition RooAbsReal.cxx:3542; RooAbsReal::createIntObjRooFit::OwningPtr",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:50674,Deployability,configurat,configuration,50674,"itEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::isBinnedDistributionvirtual bool isBinnedDistribution(const RooArgSet &) constTests if the distribution is binned. Unless overridden by derived classes, this always returns false.Definition RooAbsReal.h:346; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsReal.cxx:3827; RooAbsReal::enableOffsettingvirtual void enableOffsetting(bool)Definition RooAbsReal.cxx:4484; RooAbsReal::clearEvalErrorLogstatic void clearEvalErrorLog()Clear the stack of evaluation error messages.Definition RooAbsReal.cxx:3542; RooAbsReal::createIntObjRooFit::OwningPtr",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:56534,Deployability,configurat,configuration,56534,".h:39; RooCurve::Extended@ ExtendedDefinition RooCurve.h:39; RooDataHistContainer class to hold N-dimensional binned data.Definition RooDataHist.h:40; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDerivativeRepresents the first, second, or third order derivative of any RooAbsReal as calculated (numerically)...Definition RooDerivative.h:30; RooFitResultRooFitResult is a container class to hold the input and output of a PDF fit to a dataset.Definition RooFitResult.h:40; RooFit::Detail::CodeSquashContextA class to maintain the context for squashing of RooFit models into code.Definition CodeSquashContext.h:42; RooFit::EvalContextDefinition EvalContext.h:84; RooFunctorLightweight interface adaptor that exports a RooAbsPdf as a functor.Definition RooFunctor.h:25; RooLinkedListCollection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list...Definition RooLinkedList.h:44; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooRealBindingLightweight interface adaptor that binds a RooAbsReal object to a subset of its servers and present i...Definition RooRealBinding.h:30; RooRealSumFuncDefinition RooRealSumFunc.h:26; RooRealSumPdfImplements a PDF constructed from a sum of functions:Definition RooRealSumPdf.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooStringViewThe RooStringView is a wrapper around a C-style string that can also be constructed from a std::strin...Definition RooStringView.h:27; RooVectorDataStoreUses std::vector to store data columns.Definition RooVectorDataStore.h:41; TF11-Dim function classDefinition TF1.h:233; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Def",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:56582,Deployability,integrat,integrators,56582,".h:39; RooCurve::Extended@ ExtendedDefinition RooCurve.h:39; RooDataHistContainer class to hold N-dimensional binned data.Definition RooDataHist.h:40; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDerivativeRepresents the first, second, or third order derivative of any RooAbsReal as calculated (numerically)...Definition RooDerivative.h:30; RooFitResultRooFitResult is a container class to hold the input and output of a PDF fit to a dataset.Definition RooFitResult.h:40; RooFit::Detail::CodeSquashContextA class to maintain the context for squashing of RooFit models into code.Definition CodeSquashContext.h:42; RooFit::EvalContextDefinition EvalContext.h:84; RooFunctorLightweight interface adaptor that exports a RooAbsPdf as a functor.Definition RooFunctor.h:25; RooLinkedListCollection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list...Definition RooLinkedList.h:44; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooRealBindingLightweight interface adaptor that binds a RooAbsReal object to a subset of its servers and present i...Definition RooRealBinding.h:30; RooRealSumFuncDefinition RooRealSumFunc.h:26; RooRealSumPdfImplements a PDF constructed from a sum of functions:Definition RooRealSumPdf.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooStringViewThe RooStringView is a wrapper around a C-style string that can also be constructed from a std::strin...Definition RooStringView.h:27; RooVectorDataStoreUses std::vector to store data columns.Definition RooVectorDataStore.h:41; TF11-Dim function classDefinition TF1.h:233; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Def",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:6106,Energy Efficiency,adapt,adaptors,6106,"ntion.; 129 // To remove this ambiguity which might not always be correctly handled in; 130 // downstream code, we set `normalisationSet` to nullptr if it is an empty set.; 131 return _fast ? _value : getValV(normalisationSet.empty() ? nullptr : &normalisationSet) ;; 132 }; 133 ; 134 virtual double getValV(const RooArgSet* normalisationSet = nullptr) const ;; 135 ; 136 double getPropagatedError(const RooFitResult &fr, const RooArgSet &nset = {}) const;; 137 ; 138 bool operator==(double value) const ;; 139 bool operator==(const RooAbsArg& other) const override;; 140 bool isIdentical(const RooAbsArg& other, bool assumeSameType=false) const override;; 141 ; 142 ; 143 inline const Text_t *getUnit() const {; 144 // Return string with unit description; 145 return _unit.Data();; 146 }; 147 inline void setUnit(const char *unit) {; 148 // Set unit description to given string; 149 _unit= unit;; 150 }; 151 TString getTitle(bool appendUnit= false) const;; 152 ; 153 // Lightweight interface adaptors (caller takes ownership); 154 RooFit::OwningPtr<RooAbsFunc> bindVars(const RooArgSet &vars, const RooArgSet* nset=nullptr, bool clipInvalid=false) const;; 155 ; 156 // Create a fundamental-type object that can hold our value.; 157 RooFit::OwningPtr<RooAbsArg> createFundamental(const char* newname=nullptr) const override;; 158 ; 159 // Analytical integration support; 160 virtual Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 161 virtual double analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 162 virtual Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName=nullptr) const ;; 163 virtual double analyticalIntegral(Int_t code, const char* rangeName=nullptr) const ;; 164 virtual bool forceAnalyticalInt(const RooAbsArg& /*dep*/) const {; 165 // Interface to force RooRealIntegral to offer given observable for internal ",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:38039,Energy Efficiency,adapt,adaptor,38039,"wningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const char *rangeName) constCreate integral over observables in iset in range named rangeName.Definition RooAbsReal.h:207; RooAbsReal::defaultErrorLevelvirtual double defaultErrorLevel() constDefinition RooAbsReal.h:248; RooAbsReal::_DEBUG_getValdouble _DEBUG_getVal(const RooArgSet *normalisationSet) constDebug version of getVal(), which is slow and does error checking.Definition RooAbsReal.cxx:4434; RooAbsReal::createFundamentalRooFit::OwningPtr< RooAbsArg > createFundamental(const char *newname=nullptr) const overrideCreate a RooRealVar fundamental object with our properties.Definition RooAbsReal.cxx:3130; RooAbsReal::plotSanityChecksbool plotSanityChecks(RooPlot *frame) constUtility function for plotOn(), perform general sanity check on frame to ensure safe plotting operatio...Definition RooAbsReal.cxx:2860; RooAbsReal::bindVarsRooFit::OwningPtr< RooAbsFunc > bindVars(const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) constCreate an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order).Definition RooAbsReal.cxx:2980; RooAbsReal::selectNormalizationvirtual void selectNormalization(const RooArgSet *depSet=nullptr, bool force=false)Interface function to force use of a given set of observables to interpret function value.Definition RooAbsReal.cxx:3360; RooAbsReal::derivativeRooDerivative * derivative(RooRealVar &obs, Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Perform a fit to given histogram.Definition RooAbsReal.cxx:4105; RooAbsReal::asTFTF1 * asTF",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:54894,Energy Efficiency,efficient,efficient,54894,"tility function for plotOn() that constructs the set of observables to project when plotting ourselv...Definition RooAbsReal.cxx:2903; RooAbsReal::getMaxValvirtual Int_t getMaxVal(const RooArgSet &vars) constAdvertise capability to determine maximum value of function for given set of observables.Definition RooAbsReal.cxx:3386; RooAbsReal::_plotMindouble _plotMinMinimum of plot range.Definition RooAbsReal.h:533; RooAbsReal::meanRooAbsMoment * mean(RooRealVar &obs, const RooArgSet &nset)Definition RooAbsReal.h:360; RooAbsReal::createChi2virtual RooFit::OwningPtr< RooAbsReal > createChi2(RooDataHist &data, const RooLinkedList &cmdList)Definition RooAbsReal.cxx:4200; RooAbsReal::offsetvirtual double offset() constDefinition RooAbsReal.h:371; RooAbsReal::sigmaRooAbsMoment * sigma(RooRealVar &obs)Definition RooAbsReal.h:361; RooAbsReal::_globalSelectCompstatic bool _globalSelectCompDefinition RooAbsReal.h:545; RooAddHelpersDefinition RooAddHelpers.h:56; RooAddModelRooAddModel is an efficient implementation of a sum of PDFs of the form.Definition RooAddModel.h:27; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgProxyAbstract interface for RooAbsArg proxy classes.Definition RooArgProxy.h:24; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooCmdArgNamed container for two doubles, two integers two object points and three string pointers that can be...Definition RooCmdArg.h:26; RooCurve::WingModeWingModeDefinition RooCurve.h:39; RooCurve::Extended@ ExtendedDefinition RooCurve.h:39; RooDataHistContainer class to hold N-dimensional binned data.Definition RooDataHist.h:40; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDerivativeRepresents the first, second, or third order derivative of any RooAbsReal as calculated (numerically)...",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:56287,Energy Efficiency,adapt,adaptor,56287,"ontainer object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooCmdArgNamed container for two doubles, two integers two object points and three string pointers that can be...Definition RooCmdArg.h:26; RooCurve::WingModeWingModeDefinition RooCurve.h:39; RooCurve::Extended@ ExtendedDefinition RooCurve.h:39; RooDataHistContainer class to hold N-dimensional binned data.Definition RooDataHist.h:40; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDerivativeRepresents the first, second, or third order derivative of any RooAbsReal as calculated (numerically)...Definition RooDerivative.h:30; RooFitResultRooFitResult is a container class to hold the input and output of a PDF fit to a dataset.Definition RooFitResult.h:40; RooFit::Detail::CodeSquashContextA class to maintain the context for squashing of RooFit models into code.Definition CodeSquashContext.h:42; RooFit::EvalContextDefinition EvalContext.h:84; RooFunctorLightweight interface adaptor that exports a RooAbsPdf as a functor.Definition RooFunctor.h:25; RooLinkedListCollection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list...Definition RooLinkedList.h:44; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooRealBindingLightweight interface adaptor that binds a RooAbsReal object to a subset of its servers and present i...Definition RooRealBinding.h:30; RooRealSumFuncDefinition RooRealSumFunc.h:26; RooRealSumPdfImplements a PDF constructed from a sum of functions:Definition RooRealSumPdf.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooStringViewThe RooStringView is a wrapper around a C-style string that can also be constructed from a std::strin...Definition RooStringView.h:27; RooVectorDataStor",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:56785,Energy Efficiency,adapt,adaptor,56785,"esents the first, second, or third order derivative of any RooAbsReal as calculated (numerically)...Definition RooDerivative.h:30; RooFitResultRooFitResult is a container class to hold the input and output of a PDF fit to a dataset.Definition RooFitResult.h:40; RooFit::Detail::CodeSquashContextA class to maintain the context for squashing of RooFit models into code.Definition CodeSquashContext.h:42; RooFit::EvalContextDefinition EvalContext.h:84; RooFunctorLightweight interface adaptor that exports a RooAbsPdf as a functor.Definition RooFunctor.h:25; RooLinkedListCollection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list...Definition RooLinkedList.h:44; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooRealBindingLightweight interface adaptor that binds a RooAbsReal object to a subset of its servers and present i...Definition RooRealBinding.h:30; RooRealSumFuncDefinition RooRealSumFunc.h:26; RooRealSumPdfImplements a PDF constructed from a sum of functions:Definition RooRealSumPdf.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooStringViewThe RooStringView is a wrapper around a C-style string that can also be constructed from a std::strin...Definition RooStringView.h:27; RooVectorDataStoreUses std::vector to store data columns.Definition RooVectorDataStore.h:41; TF11-Dim function classDefinition TF1.h:233; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH3F3-D histogram with a float per channel (see TH1 documentation)Definition TH3.h:317; TListA doubly linked list.Definition TList.h:38; ",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:2260,Integrability,interface,interfaces,2260,"; 30class RooDataSet ;; 31class RooPlot;; 32class RooRealVar;; 33class RooAbsFunc;; 34class RooAbsCategoryLValue ;; 35class RooLinkedList ;; 36class RooNumIntConfig ;; 37class RooDataHist ;; 38class RooFunctor ;; 39class RooFitResult ;; 40class RooAbsMoment ;; 41class RooDerivative ;; 42class RooVectorDataStore ;; 43struct TreeReadBuffer; /// A space to attach TBranches; 44namespace RooBatchCompute {; 45struct RunContext;; 46}; 47 ; 48class TH1;; 49class TH1F;; 50class TH2F;; 51class TH3F;; 52 ; 53#include <iostream>; 54#include <list>; 55#include <map>; 56#include <string>; 57#include <sstream>; 58 ; 59class RooAbsReal : public RooAbsArg {; 60public:; 61 using value_type = double;; 62 ; 63 /// A RooAbsReal::Ref can be constructed from a `RooAbsReal&` or a `double`; 64 /// that will be implicitly converted to a RooConstVar&. The RooAbsReal::Ref; 65 /// can be used as a replacement for `RooAbsReal&`. With this type; 66 /// definition, you can write RooFit interfaces that accept both RooAbsReal,; 67 /// or simply a number that will be implicitly converted to a RooConstVar&.; 68 class Ref {; 69 public:; 70 inline Ref(RooAbsReal &ref) : _ref{ref} {}; 71 Ref(double val);; 72 inline operator RooAbsReal &() const { return _ref; }; 73 ; 74 private:; 75 RooAbsReal &_ref;; 76 };; 77 ; 78 // Constructors, assignment etc; 79 RooAbsReal() ;; 80 RooAbsReal(const char *name, const char *title, const char *unit= """") ;; 81 RooAbsReal(const char *name, const char *title, double minVal, double maxVal,; 82 const char *unit= """") ;; 83 RooAbsReal(const RooAbsReal& other, const char* name=nullptr);; 84 ~RooAbsReal() override;; 85 ; 86 ; 87 ; 88 ; 89 //////////////////////////////////////////////////////////////////////////////////; 90 /// Evaluate object. Returns either cached value or triggers a recalculation.; 91 /// The recalculation happens by calling getValV(), which in the end calls the; 92 /// virtual evaluate() functions of the respective PDFs.; 93 /// \param[in] normalisationSet ",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:3320,Integrability,depend,depending,3320,"simply a number that will be implicitly converted to a RooConstVar&.; 68 class Ref {; 69 public:; 70 inline Ref(RooAbsReal &ref) : _ref{ref} {}; 71 Ref(double val);; 72 inline operator RooAbsReal &() const { return _ref; }; 73 ; 74 private:; 75 RooAbsReal &_ref;; 76 };; 77 ; 78 // Constructors, assignment etc; 79 RooAbsReal() ;; 80 RooAbsReal(const char *name, const char *title, const char *unit= """") ;; 81 RooAbsReal(const char *name, const char *title, double minVal, double maxVal,; 82 const char *unit= """") ;; 83 RooAbsReal(const RooAbsReal& other, const char* name=nullptr);; 84 ~RooAbsReal() override;; 85 ; 86 ; 87 ; 88 ; 89 //////////////////////////////////////////////////////////////////////////////////; 90 /// Evaluate object. Returns either cached value or triggers a recalculation.; 91 /// The recalculation happens by calling getValV(), which in the end calls the; 92 /// virtual evaluate() functions of the respective PDFs.; 93 /// \param[in] normalisationSet getValV() reacts differently depending on the value of the normalisation set.; 94 /// If the set is `nullptr`, an unnormalised value is returned.; 95 /// \note The normalisation is arbitrary, because it is up to the implementation; 96 /// of the PDF to e.g. leave out normalisation constants for speed reasons. The range; 97 /// of the variables is also ignored.; 98 ///; 99 /// To normalise the result properly, a RooArgSet has to be passed, which contains; 100 /// the variables to normalise over.; 101 /// These are integrated over their current ranges to compute the normalisation constant,; 102 /// and the unnormalised result is divided by this value.; 103 inline double getVal(const RooArgSet* normalisationSet = nullptr) const {; 104 // Sometimes, the calling code uses an empty RooArgSet to request evaluation; 105 // without normalization set instead of following the `nullptr` convention.; 106 // To remove this ambiguity which might not always be correctly handled in; 107 // downstream code, we set `normali",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:3810,Integrability,integrat,integrated,3810,"nst char* name=nullptr);; 84 ~RooAbsReal() override;; 85 ; 86 ; 87 ; 88 ; 89 //////////////////////////////////////////////////////////////////////////////////; 90 /// Evaluate object. Returns either cached value or triggers a recalculation.; 91 /// The recalculation happens by calling getValV(), which in the end calls the; 92 /// virtual evaluate() functions of the respective PDFs.; 93 /// \param[in] normalisationSet getValV() reacts differently depending on the value of the normalisation set.; 94 /// If the set is `nullptr`, an unnormalised value is returned.; 95 /// \note The normalisation is arbitrary, because it is up to the implementation; 96 /// of the PDF to e.g. leave out normalisation constants for speed reasons. The range; 97 /// of the variables is also ignored.; 98 ///; 99 /// To normalise the result properly, a RooArgSet has to be passed, which contains; 100 /// the variables to normalise over.; 101 /// These are integrated over their current ranges to compute the normalisation constant,; 102 /// and the unnormalised result is divided by this value.; 103 inline double getVal(const RooArgSet* normalisationSet = nullptr) const {; 104 // Sometimes, the calling code uses an empty RooArgSet to request evaluation; 105 // without normalization set instead of following the `nullptr` convention.; 106 // To remove this ambiguity which might not always be correctly handled in; 107 // downstream code, we set `normalisationSet` to nullptr if it is pointing; 108 // to an empty set.; 109 if(normalisationSet && normalisationSet->empty()) {; 110 normalisationSet = nullptr;; 111 }; 112#ifdef ROOFIT_CHECK_CACHED_VALUES; 113 return _DEBUG_getVal(normalisationSet);; 114#else; 115 ; 116#ifndef _WIN32; 117 return (_fast && !_inhibitDirty) ? _value : getValV(normalisationSet) ;; 118#else; 119 return (_fast && !inhibitDirty()) ? _value : getValV(normalisationSet) ;; 120#endif; 121 ; 122#endif; 123 }; 124 ; 125 /// Like getVal(const RooArgSet*), but always requires an argument ",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:6096,Integrability,interface,interface,6096,"ntion.; 129 // To remove this ambiguity which might not always be correctly handled in; 130 // downstream code, we set `normalisationSet` to nullptr if it is an empty set.; 131 return _fast ? _value : getValV(normalisationSet.empty() ? nullptr : &normalisationSet) ;; 132 }; 133 ; 134 virtual double getValV(const RooArgSet* normalisationSet = nullptr) const ;; 135 ; 136 double getPropagatedError(const RooFitResult &fr, const RooArgSet &nset = {}) const;; 137 ; 138 bool operator==(double value) const ;; 139 bool operator==(const RooAbsArg& other) const override;; 140 bool isIdentical(const RooAbsArg& other, bool assumeSameType=false) const override;; 141 ; 142 ; 143 inline const Text_t *getUnit() const {; 144 // Return string with unit description; 145 return _unit.Data();; 146 }; 147 inline void setUnit(const char *unit) {; 148 // Set unit description to given string; 149 _unit= unit;; 150 }; 151 TString getTitle(bool appendUnit= false) const;; 152 ; 153 // Lightweight interface adaptors (caller takes ownership); 154 RooFit::OwningPtr<RooAbsFunc> bindVars(const RooArgSet &vars, const RooArgSet* nset=nullptr, bool clipInvalid=false) const;; 155 ; 156 // Create a fundamental-type object that can hold our value.; 157 RooFit::OwningPtr<RooAbsArg> createFundamental(const char* newname=nullptr) const override;; 158 ; 159 // Analytical integration support; 160 virtual Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 161 virtual double analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 162 virtual Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName=nullptr) const ;; 163 virtual double analyticalIntegral(Int_t code, const char* rangeName=nullptr) const ;; 164 virtual bool forceAnalyticalInt(const RooAbsArg& /*dep*/) const {; 165 // Interface to force RooRealIntegral to offer given observable for internal ",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:6463,Integrability,integrat,integration,6463," const override;; 141 ; 142 ; 143 inline const Text_t *getUnit() const {; 144 // Return string with unit description; 145 return _unit.Data();; 146 }; 147 inline void setUnit(const char *unit) {; 148 // Set unit description to given string; 149 _unit= unit;; 150 }; 151 TString getTitle(bool appendUnit= false) const;; 152 ; 153 // Lightweight interface adaptors (caller takes ownership); 154 RooFit::OwningPtr<RooAbsFunc> bindVars(const RooArgSet &vars, const RooArgSet* nset=nullptr, bool clipInvalid=false) const;; 155 ; 156 // Create a fundamental-type object that can hold our value.; 157 RooFit::OwningPtr<RooAbsArg> createFundamental(const char* newname=nullptr) const override;; 158 ; 159 // Analytical integration support; 160 virtual Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 161 virtual double analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 162 virtual Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName=nullptr) const ;; 163 virtual double analyticalIntegral(Int_t code, const char* rangeName=nullptr) const ;; 164 virtual bool forceAnalyticalInt(const RooAbsArg& /*dep*/) const {; 165 // Interface to force RooRealIntegral to offer given observable for internal integration; 166 // even if this is deemed unsafe. This default implementation returns always false; 167 return false ;; 168 }; 169 virtual void forceNumInt(bool flag=true) {; 170 // If flag is true, all advertised analytical integrals will be ignored; 171 // and all integrals are calculated numerically; 172 _forceNumInt = flag ;; 173 }; 174 bool getForceNumInt() const { return _forceNumInt ; }; 175 ; 176 // Chi^2 fits to histograms; 177 virtual RooFit::OwningPtr<RooFitResult> chi2FitTo(RooDataHist& data, const RooCmdArg& arg1={}, const RooCmdArg& arg2={},; 178 const RooCmdArg& arg3={}, const RooCmdArg& arg4={}, const RooCmdArg& a",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:7114,Integrability,integrat,integration,7114," const override;; 141 ; 142 ; 143 inline const Text_t *getUnit() const {; 144 // Return string with unit description; 145 return _unit.Data();; 146 }; 147 inline void setUnit(const char *unit) {; 148 // Set unit description to given string; 149 _unit= unit;; 150 }; 151 TString getTitle(bool appendUnit= false) const;; 152 ; 153 // Lightweight interface adaptors (caller takes ownership); 154 RooFit::OwningPtr<RooAbsFunc> bindVars(const RooArgSet &vars, const RooArgSet* nset=nullptr, bool clipInvalid=false) const;; 155 ; 156 // Create a fundamental-type object that can hold our value.; 157 RooFit::OwningPtr<RooAbsArg> createFundamental(const char* newname=nullptr) const override;; 158 ; 159 // Analytical integration support; 160 virtual Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 161 virtual double analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 162 virtual Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName=nullptr) const ;; 163 virtual double analyticalIntegral(Int_t code, const char* rangeName=nullptr) const ;; 164 virtual bool forceAnalyticalInt(const RooAbsArg& /*dep*/) const {; 165 // Interface to force RooRealIntegral to offer given observable for internal integration; 166 // even if this is deemed unsafe. This default implementation returns always false; 167 return false ;; 168 }; 169 virtual void forceNumInt(bool flag=true) {; 170 // If flag is true, all advertised analytical integrals will be ignored; 171 // and all integrals are calculated numerically; 172 _forceNumInt = flag ;; 173 }; 174 bool getForceNumInt() const { return _forceNumInt ; }; 175 ; 176 // Chi^2 fits to histograms; 177 virtual RooFit::OwningPtr<RooFitResult> chi2FitTo(RooDataHist& data, const RooCmdArg& arg1={}, const RooCmdArg& arg2={},; 178 const RooCmdArg& arg3={}, const RooCmdArg& arg4={}, const RooCmdArg& a",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:10381,Integrability,integrat,integration,10381,"RooCmdArg& arg3={}, const RooCmdArg& arg4={}, const RooCmdArg& arg5={},; 196 const RooCmdArg& arg6={}, const RooCmdArg& arg7={}, const RooCmdArg& arg8={}) ;; 197 ; 198 virtual RooFit::OwningPtr<RooAbsReal> createProfile(const RooArgSet& paramsOfInterest) ;; 199 ; 200 ; 201 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2={},; 202 const RooCmdArg& arg3={}, const RooCmdArg& arg4={},; 203 const RooCmdArg& arg5={}, const RooCmdArg& arg6={},; 204 const RooCmdArg& arg7={}, const RooCmdArg& arg8={}) const ;; 205 ; 206 /// Create integral over observables in iset in range named rangeName.; 207 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const char* rangeName) const {; 208 return createIntegral(iset,nullptr,nullptr,rangeName) ;; 209 }; 210 /// Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset; 211 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooArgSet& nset, const char* rangeName=nullptr) const {; 212 return createIntegral(iset,&nset,nullptr,rangeName) ;; 213 }; 214 /// Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset while; 215 /// using specified configuration for any numeric integration.; 216 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooArgSet& nset, const RooNumIntConfig& cfg, const char* rangeName=nullptr) const {; 217 return createIntegral(iset,&nset,&cfg,rangeName) ;; 218 }; 219 /// Create integral over observables in iset in range named rangeName using specified configuration for any numeric integration.; 220 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooNumIntConfig& cfg, const char* rangeName=nullptr) const {; 221 return createIntegral(iset,nullptr,&cfg,rangeName) ;; 222 }; 223 virtual RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, cons",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:10741,Integrability,integrat,integration,10741,"7={}, const RooCmdArg& arg8={}) const ;; 205 ; 206 /// Create integral over observables in iset in range named rangeName.; 207 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const char* rangeName) const {; 208 return createIntegral(iset,nullptr,nullptr,rangeName) ;; 209 }; 210 /// Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset; 211 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooArgSet& nset, const char* rangeName=nullptr) const {; 212 return createIntegral(iset,&nset,nullptr,rangeName) ;; 213 }; 214 /// Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset while; 215 /// using specified configuration for any numeric integration.; 216 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooArgSet& nset, const RooNumIntConfig& cfg, const char* rangeName=nullptr) const {; 217 return createIntegral(iset,&nset,&cfg,rangeName) ;; 218 }; 219 /// Create integral over observables in iset in range named rangeName using specified configuration for any numeric integration.; 220 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooNumIntConfig& cfg, const char* rangeName=nullptr) const {; 221 return createIntegral(iset,nullptr,&cfg,rangeName) ;; 222 }; 223 virtual RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooArgSet* nset=nullptr, const RooNumIntConfig* cfg=nullptr, const char* rangeName=nullptr) const ;; 224 ; 225 ; 226 void setParameterizeIntegral(const RooArgSet& paramVars) ;; 227 ; 228 // Create running integrals; 229 RooFit::OwningPtr<RooAbsReal> createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset={}) ;; 230 RooFit::OwningPtr<RooAbsReal> createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2={},; 231 const RooCmdArg& arg3={}, const RooCmdArg& arg4={},; 232 const RooCmdA",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:14628,Integrability,interface,interface,14628,"onst RooCmdArg& arg4={},; 270 const RooCmdArg& arg5={}, const RooCmdArg& arg6={},; 271 const RooCmdArg& arg7={}, const RooCmdArg& arg8={},; 272 const RooCmdArg& arg9={}, const RooCmdArg& arg10={}; 273 ) const ;; 274 ; 275 ; 276 enum ScaleType { Raw, Relative, NumEvent, RelativeExpected } ;; 277 ; 278 // Fill an existing histogram; 279 TH1 *fillHistogram(TH1 *hist, const RooArgList &plotVars,; 280 double scaleFactor= 1, const RooArgSet *projectedVars= nullptr, bool scaling=true,; 281 const RooArgSet* condObs=nullptr, bool setError=true) const;; 282 ; 283 // Create 1,2, and 3D histograms from and fill it; 284 TH1 *createHistogram(RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) const ;; 285 TH1* createHistogram(const char *name, const RooAbsRealLValue& xvar, RooLinkedList& argList) const ;; 286 TH1 *createHistogram(const char *name, const RooAbsRealLValue& xvar,; 287 const RooCmdArg& arg1={}, const RooCmdArg& arg2={},; 288 const RooCmdArg& arg3={}, const RooCmdArg& arg4={},; 289 const RooCmdArg& arg5={}, const RooCmdArg& arg6={},; 290 const RooCmdArg& arg7={}, const RooCmdArg& arg8={}) const ;; 291 ; 292 // Fill a RooDataHist; 293 RooDataHist* fillDataHist(RooDataHist *hist, const RooArgSet* nset, double scaleFactor,; 294 bool correctForBinVolume=false, bool showProgress=false) const ;; 295 ; 296 // I/O streaming interface (machine readable); 297 bool readFromStream(std::istream& is, bool compact, bool verbose=false) override ;; 298 void writeToStream(std::ostream& os, bool compact) const override ;; 299 ; 300 // Printing interface (human readable); 301 void printValue(std::ostream& os) const override ;; 302 void printMultiline(std::ostream& os, Int_t contents, bool verbose=false, TString indent="""") const override ;; 303 ; 304 inline void setCachedValue(double value, bool notifyClients = true) final;; 305 ; 306 // Evaluation error logging; 307 class EvalError {; 308 public:; 309 EvalError() { }; 310 EvalError(const EvalError& other) : _msg(other.",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:14841,Integrability,interface,interface,14841,"onst RooCmdArg& arg4={},; 270 const RooCmdArg& arg5={}, const RooCmdArg& arg6={},; 271 const RooCmdArg& arg7={}, const RooCmdArg& arg8={},; 272 const RooCmdArg& arg9={}, const RooCmdArg& arg10={}; 273 ) const ;; 274 ; 275 ; 276 enum ScaleType { Raw, Relative, NumEvent, RelativeExpected } ;; 277 ; 278 // Fill an existing histogram; 279 TH1 *fillHistogram(TH1 *hist, const RooArgList &plotVars,; 280 double scaleFactor= 1, const RooArgSet *projectedVars= nullptr, bool scaling=true,; 281 const RooArgSet* condObs=nullptr, bool setError=true) const;; 282 ; 283 // Create 1,2, and 3D histograms from and fill it; 284 TH1 *createHistogram(RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) const ;; 285 TH1* createHistogram(const char *name, const RooAbsRealLValue& xvar, RooLinkedList& argList) const ;; 286 TH1 *createHistogram(const char *name, const RooAbsRealLValue& xvar,; 287 const RooCmdArg& arg1={}, const RooCmdArg& arg2={},; 288 const RooCmdArg& arg3={}, const RooCmdArg& arg4={},; 289 const RooCmdArg& arg5={}, const RooCmdArg& arg6={},; 290 const RooCmdArg& arg7={}, const RooCmdArg& arg8={}) const ;; 291 ; 292 // Fill a RooDataHist; 293 RooDataHist* fillDataHist(RooDataHist *hist, const RooArgSet* nset, double scaleFactor,; 294 bool correctForBinVolume=false, bool showProgress=false) const ;; 295 ; 296 // I/O streaming interface (machine readable); 297 bool readFromStream(std::istream& is, bool compact, bool verbose=false) override ;; 298 void writeToStream(std::ostream& os, bool compact) const override ;; 299 ; 300 // Printing interface (human readable); 301 void printValue(std::ostream& os) const override ;; 302 void printMultiline(std::ostream& os, Int_t contents, bool verbose=false, TString indent="""") const override ;; 303 ; 304 inline void setCachedValue(double value, bool notifyClients = true) final;; 305 ; 306 // Evaluation error logging; 307 class EvalError {; 308 public:; 309 EvalError() { }; 310 EvalError(const EvalError& other) : _msg(other.",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:16383,Integrability,message,message,16383,"tmp) { std::string s(tmp); s.swap(_msg); }; 312 void setServerValues(const char* tmp) { std::string s(tmp); s.swap(_srvval); }; 313 std::string _msg;; 314 std::string _srvval;; 315 } ;; 316 ; 317 enum ErrorLoggingMode { PrintErrors, CollectErrors, CountErrors, Ignore } ;; 318 ; 319 /// Context to temporarily change the error logging mode as long as the context is alive.; 320 class EvalErrorContext {; 321 public:; 322 EvalErrorContext(ErrorLoggingMode m) : _old{evalErrorLoggingMode()} { setEvalErrorLoggingMode(m); }; 323 ; 324 EvalErrorContext(EvalErrorContext const&) = delete;; 325 EvalErrorContext(EvalErrorContext &&) = delete;; 326 EvalErrorContext& operator=(EvalErrorContext const&) = delete;; 327 EvalErrorContext& operator=(EvalErrorContext &&) = delete;; 328 ; 329 ~EvalErrorContext() { setEvalErrorLoggingMode(_old); }; 330 private:; 331 ErrorLoggingMode _old;; 332 };; 333 ; 334 static ErrorLoggingMode evalErrorLoggingMode() ;; 335 static void setEvalErrorLoggingMode(ErrorLoggingMode m) ;; 336 void logEvalError(const char* message, const char* serverValueString=nullptr) const ;; 337 static void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString=nullptr) ;; 338 static void printEvalErrors(std::ostream&os=std::cout, Int_t maxPerNode=10000000) ;; 339 static Int_t numEvalErrors() ;; 340 static Int_t numEvalErrorItems();; 341 static std::map<const RooAbsArg *, std::pair<std::string, std::list<RooAbsReal::EvalError>>>::iterator evalErrorIter();; 342 ; 343 static void clearEvalErrorLog() ;; 344 ; 345 /// Tests if the distribution is binned. Unless overridden by derived classes, this always returns false.; 346 virtual bool isBinnedDistribution(const RooArgSet& /*obs*/) const { return false ; }; 347 virtual std::list<double>* binBoundaries(RooAbsRealLValue& obs, double xlo, double xhi) const;; 348 virtual std::list<double>* plotSamplingHint(RooAbsRealLValue& obs, double xlo, double xhi) const;; 349 ; 350 Ro",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:16533,Integrability,message,message,16533,"tmp) { std::string s(tmp); s.swap(_msg); }; 312 void setServerValues(const char* tmp) { std::string s(tmp); s.swap(_srvval); }; 313 std::string _msg;; 314 std::string _srvval;; 315 } ;; 316 ; 317 enum ErrorLoggingMode { PrintErrors, CollectErrors, CountErrors, Ignore } ;; 318 ; 319 /// Context to temporarily change the error logging mode as long as the context is alive.; 320 class EvalErrorContext {; 321 public:; 322 EvalErrorContext(ErrorLoggingMode m) : _old{evalErrorLoggingMode()} { setEvalErrorLoggingMode(m); }; 323 ; 324 EvalErrorContext(EvalErrorContext const&) = delete;; 325 EvalErrorContext(EvalErrorContext &&) = delete;; 326 EvalErrorContext& operator=(EvalErrorContext const&) = delete;; 327 EvalErrorContext& operator=(EvalErrorContext &&) = delete;; 328 ; 329 ~EvalErrorContext() { setEvalErrorLoggingMode(_old); }; 330 private:; 331 ErrorLoggingMode _old;; 332 };; 333 ; 334 static ErrorLoggingMode evalErrorLoggingMode() ;; 335 static void setEvalErrorLoggingMode(ErrorLoggingMode m) ;; 336 void logEvalError(const char* message, const char* serverValueString=nullptr) const ;; 337 static void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString=nullptr) ;; 338 static void printEvalErrors(std::ostream&os=std::cout, Int_t maxPerNode=10000000) ;; 339 static Int_t numEvalErrors() ;; 340 static Int_t numEvalErrorItems();; 341 static std::map<const RooAbsArg *, std::pair<std::string, std::list<RooAbsReal::EvalError>>>::iterator evalErrorIter();; 342 ; 343 static void clearEvalErrorLog() ;; 344 ; 345 /// Tests if the distribution is binned. Unless overridden by derived classes, this always returns false.; 346 virtual bool isBinnedDistribution(const RooArgSet& /*obs*/) const { return false ; }; 347 virtual std::list<double>* binBoundaries(RooAbsRealLValue& obs, double xlo, double xhi) const;; 348 virtual std::list<double>* plotSamplingHint(RooAbsRealLValue& obs, double xlo, double xhi) const;; 349 ; 350 Ro",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:19216,Integrability,depend,dependentVars,19216,"ooRealVar& obs) { return moment(obs,2,true,true) ; }; 362 RooAbsMoment* sigma(RooRealVar& obs, const RooArgSet& nset) { return moment(obs,nset,2,true,true,true) ; }; 363 ; 364 double findRoot(RooRealVar& x, double xmin, double xmax, double yval) ;; 365 ; 366 ; 367 virtual bool setData(RooAbsData& /*data*/, bool /*cloneData*/=true) { return true ; }; 368 ; 369 virtual void enableOffsetting(bool);; 370 virtual bool isOffsetting() const { return false ; }; 371 virtual double offset() const { return 0 ; }; 372 ; 373 static void setHideOffset(bool flag);; 374 static bool hideOffset() ;; 375 ; 376 bool isSelectedComp() const ;; 377 void selectComp(bool flag) {; 378 // If flag is true, only selected component will be included in evaluates of RooAddPdf components; 379 _selectComp = flag ;; 380 }; 381 ; 382 const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const ;; 383 const RooAbsReal *createPlotProjection(const RooArgSet &dependentVars, const RooArgSet *projectedVars,; 384 RooArgSet *&cloneSet, const char* rangeName=nullptr, const RooArgSet* condObs=nullptr) const;; 385 virtual void doEval(RooFit::EvalContext &) const;; 386 ; 387 virtual bool hasGradient() const { return false; }; 388 virtual void gradient(double *) const {; 389 if(!hasGradient()) throw std::runtime_error(""RooAbsReal::gradient(double *) not implemented by this class!"");; 390 }; 391 ; 392 virtual std::string; 393 buildCallToAnalyticIntegral(Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const;; 394 ; 395 // PlotOn with command list; 396 virtual RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const ;; 397 ; 398protected:; 399 friend class BatchInterfaceAccessor;; 400 friend class RooVectorDataStore;; 401 friend class RooRealBinding;; 402 friend class RooRealSumPdf;; 403 friend class RooRealSumFunc;; 404 friend class RooAddHelpers;; 405 friend class RooAddPdf;; 406 friend class RooAddModel;; 407 friend class Ad",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:20324,Integrability,depend,dependent,20324,"oArgSet* condObs=nullptr) const;; 385 virtual void doEval(RooFit::EvalContext &) const;; 386 ; 387 virtual bool hasGradient() const { return false; }; 388 virtual void gradient(double *) const {; 389 if(!hasGradient()) throw std::runtime_error(""RooAbsReal::gradient(double *) not implemented by this class!"");; 390 }; 391 ; 392 virtual std::string; 393 buildCallToAnalyticIntegral(Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const;; 394 ; 395 // PlotOn with command list; 396 virtual RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const ;; 397 ; 398protected:; 399 friend class BatchInterfaceAccessor;; 400 friend class RooVectorDataStore;; 401 friend class RooRealBinding;; 402 friend class RooRealSumPdf;; 403 friend class RooRealSumFunc;; 404 friend class RooAddHelpers;; 405 friend class RooAddPdf;; 406 friend class RooAddModel;; 407 friend class AddCacheElem;; 408 friend class RooFit::EvalContext;; 409 ; 410 // Hook for objects with normalization-dependent parameters interpretation; 411 virtual void selectNormalization(const RooArgSet* depSet=nullptr, bool force=false) ;; 412 virtual void selectNormalizationRange(const char* rangeName=nullptr, bool force=false) ;; 413 ; 414 // Helper functions for plotting; 415 bool plotSanityChecks(RooPlot* frame) const ;; 416 void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars,; 417 RooArgSet& projectedVars, bool silent) const ;; 418 ; 419 TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset=nullptr, const char* rangeName=nullptr, bool omitEmpty=false) const ;; 420 ; 421 void plotOnCompSelect(RooArgSet* selNodes) const ;; 422 RooPlot* plotOnWithErrorBand(RooPlot* frame,const RooFitResult& fr, double Z, const RooArgSet* params, const RooLinkedList& argList, bool method1) const ;; 423 ; 424 // Support interface for subclasses to advertise their analytic integration; 425 // and generator capabilities in their analyticalIntegral() and generateEvent(); 426 // im",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:21169,Integrability,interface,interface,21169,"Obs=nullptr) const;; 385 virtual void doEval(RooFit::EvalContext &) const;; 386 ; 387 virtual bool hasGradient() const { return false; }; 388 virtual void gradient(double *) const {; 389 if(!hasGradient()) throw std::runtime_error(""RooAbsReal::gradient(double *) not implemented by this class!"");; 390 }; 391 ; 392 virtual std::string; 393 buildCallToAnalyticIntegral(Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const;; 394 ; 395 // PlotOn with command list; 396 virtual RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const ;; 397 ; 398protected:; 399 friend class BatchInterfaceAccessor;; 400 friend class RooVectorDataStore;; 401 friend class RooRealBinding;; 402 friend class RooRealSumPdf;; 403 friend class RooRealSumFunc;; 404 friend class RooAddHelpers;; 405 friend class RooAddPdf;; 406 friend class RooAddModel;; 407 friend class AddCacheElem;; 408 friend class RooFit::EvalContext;; 409 ; 410 // Hook for objects with normalization-dependent parameters interpretation; 411 virtual void selectNormalization(const RooArgSet* depSet=nullptr, bool force=false) ;; 412 virtual void selectNormalizationRange(const char* rangeName=nullptr, bool force=false) ;; 413 ; 414 // Helper functions for plotting; 415 bool plotSanityChecks(RooPlot* frame) const ;; 416 void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars,; 417 RooArgSet& projectedVars, bool silent) const ;; 418 ; 419 TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset=nullptr, const char* rangeName=nullptr, bool omitEmpty=false) const ;; 420 ; 421 void plotOnCompSelect(RooArgSet* selNodes) const ;; 422 RooPlot* plotOnWithErrorBand(RooPlot* frame,const RooFitResult& fr, double Z, const RooArgSet* params, const RooLinkedList& argList, bool method1) const ;; 423 ; 424 // Support interface for subclasses to advertise their analytic integration; 425 // and generator capabilities in their analyticalIntegral() and generateEvent(); 426 // implementations.",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:21222,Integrability,integrat,integration,21222,"Obs=nullptr) const;; 385 virtual void doEval(RooFit::EvalContext &) const;; 386 ; 387 virtual bool hasGradient() const { return false; }; 388 virtual void gradient(double *) const {; 389 if(!hasGradient()) throw std::runtime_error(""RooAbsReal::gradient(double *) not implemented by this class!"");; 390 }; 391 ; 392 virtual std::string; 393 buildCallToAnalyticIntegral(Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const;; 394 ; 395 // PlotOn with command list; 396 virtual RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const ;; 397 ; 398protected:; 399 friend class BatchInterfaceAccessor;; 400 friend class RooVectorDataStore;; 401 friend class RooRealBinding;; 402 friend class RooRealSumPdf;; 403 friend class RooRealSumFunc;; 404 friend class RooAddHelpers;; 405 friend class RooAddPdf;; 406 friend class RooAddModel;; 407 friend class AddCacheElem;; 408 friend class RooFit::EvalContext;; 409 ; 410 // Hook for objects with normalization-dependent parameters interpretation; 411 virtual void selectNormalization(const RooArgSet* depSet=nullptr, bool force=false) ;; 412 virtual void selectNormalizationRange(const char* rangeName=nullptr, bool force=false) ;; 413 ; 414 // Helper functions for plotting; 415 bool plotSanityChecks(RooPlot* frame) const ;; 416 void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars,; 417 RooArgSet& projectedVars, bool silent) const ;; 418 ; 419 TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset=nullptr, const char* rangeName=nullptr, bool omitEmpty=false) const ;; 420 ; 421 void plotOnCompSelect(RooArgSet* selNodes) const ;; 422 RooPlot* plotOnWithErrorBand(RooPlot* frame,const RooFitResult& fr, double Z, const RooArgSet* params, const RooLinkedList& argList, bool method1) const ;; 423 ; 424 // Support interface for subclasses to advertise their analytic integration; 425 // and generator capabilities in their analyticalIntegral() and generateEvent(); 426 // implementations.",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:22955,Integrability,interface,interface,22955,"Integration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const ;; 442 ; 443 // Internal consistency checking (needed by RooDataSet); 444 /// Check if current value is valid.; 445 bool isValid() const override { return isValidReal(_value); }; 446 /// Interface function to check if given value is a valid value for this object. Returns true unless overridden.; 447 virtual bool isValidReal(double /*value*/, bool printError = false) const { (void)printError; return true; }; 448 ; 449 // Function evaluation and error tracing; 450 double traceEval(const RooArgSet* set) const ;; 451 ; 452 /// Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; 453 virtual double evaluate() const = 0;; 454 ; 455 // Hooks for RooDataSet interface; 456 void syncCache(const RooArgSet* set=nullptr) override { getVal(set) ; }; 457 void copyCache(const RooAbsArg* source, bool valueOnly=false, bool setValDirty=true) override ;; 458 void attachToTree(TTree& t, Int_t bufSize=32000) override ;; 459 void attachToVStore(RooVectorDataStore& vstore) override ;; 460 void setTreeBranchStatus(TTree& t, bool active) override ;; 461 void fillTreeBranch(TTree& t) override ;; 462 ; 463 struct PlotOpt {; 464 Option_t *drawOptions = ""L"";; 465 double scaleFactor = 1.0;; 466 ScaleType stype = Relative;; 467 const RooAbsData *projData = nullptr;; 468 bool binProjData = false;; 469 const RooArgSet *projSet = nullptr;; 470 double precision = 1e-3;; 471 bool shiftToZero = false;; 472 const RooArgSet *projDataSet = nullptr;; 473 const char *normRangeName = nullptr;; 474 double rangeLo = 0.0;; 475 double rangeHi = 0.0;; 476 bool postRangeFracScale = false;; 477 RooCurve::WingMode wmode = RooCurve::Extended;; 478 const char *projectionRangeName = nullptr;; 479 bool curveInvisible = false;; 480 const char *curveName = nullptr;; 481 const char *addToCurveName = nullptr;; 482 double addToWgtSelf = 1.0;; 483 double addToWgtOther = 1.0;; 484 Int_t numCPU = 1;; 485 RooF",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:26184,Integrability,integrat,integration,26184,"tate;; 521 };; 522 ; 523 ; 524private:; 525 ; 526 /// Debug version of getVal(), which is slow and does error checking.; 527 double _DEBUG_getVal(const RooArgSet* normalisationSet) const;; 528 ; 529 //--------------------------------------------------------------------; 530 ; 531 protected:; 532 ; 533 double _plotMin = 0.0; ///< Minimum of plot range; 534 double _plotMax = 0.0; ///< Maximum of plot range; 535 Int_t _plotBins = 100; ///< Number of plot bins; 536 mutable double _value = 0.0; ///< Cache for current value of object; 537 TString _unit; ///< Unit for objects value; 538 TString _label; ///< Plot label for objects value; 539 bool _forceNumInt = false; ///< Force numerical integration if flag set; 540 std::unique_ptr<RooNumIntConfig> _specIntegratorConfig; // Numeric integrator configuration specific for this object; 541 TreeReadBuffer *_treeReadBuffer = nullptr; //! A buffer for reading values from trees; 542 bool _selectComp = true; //! Component selection flag for RooAbsPdf::plotCompOn; 543 mutable RooFit::UniqueId<RooArgSet>::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval; ///<!; 544 ; 545 static bool _globalSelectComp; // Global activation switch for component selection; 546 static bool _hideOffset; ///< Offset hiding flag; 547 ; 548 ClassDefOverride(RooAbsReal,3); // Abstract real-valued variable; 549};; 550 ; 551 ; 552////////////////////////////////////////////////////////////////////////////////; 553/// Overwrite the value stored in this object's cache.; 554/// This can be used to fake a computation that resulted in `value`.; 555/// \param[in] value Value to write.; 556/// \param[in] notifyClients If true, notify users of this object that its value changed.; 557/// This is the default.; 558void RooAbsReal::setCachedValue(double value, bool notifyClients) {; 559 _value = value;; 560 ; 561 if (notifyClients) {; 562 setValueDirty();; 563 _valueDirty = false;; 564 }; 565}; 566 ; 567 ; 568#endif; CodeSquashContext.h; EvalContext.h; d#define",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:26280,Integrability,integrat,integrator,26280,"tate;; 521 };; 522 ; 523 ; 524private:; 525 ; 526 /// Debug version of getVal(), which is slow and does error checking.; 527 double _DEBUG_getVal(const RooArgSet* normalisationSet) const;; 528 ; 529 //--------------------------------------------------------------------; 530 ; 531 protected:; 532 ; 533 double _plotMin = 0.0; ///< Minimum of plot range; 534 double _plotMax = 0.0; ///< Maximum of plot range; 535 Int_t _plotBins = 100; ///< Number of plot bins; 536 mutable double _value = 0.0; ///< Cache for current value of object; 537 TString _unit; ///< Unit for objects value; 538 TString _label; ///< Plot label for objects value; 539 bool _forceNumInt = false; ///< Force numerical integration if flag set; 540 std::unique_ptr<RooNumIntConfig> _specIntegratorConfig; // Numeric integrator configuration specific for this object; 541 TreeReadBuffer *_treeReadBuffer = nullptr; //! A buffer for reading values from trees; 542 bool _selectComp = true; //! Component selection flag for RooAbsPdf::plotCompOn; 543 mutable RooFit::UniqueId<RooArgSet>::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval; ///<!; 544 ; 545 static bool _globalSelectComp; // Global activation switch for component selection; 546 static bool _hideOffset; ///< Offset hiding flag; 547 ; 548 ClassDefOverride(RooAbsReal,3); // Abstract real-valued variable; 549};; 550 ; 551 ; 552////////////////////////////////////////////////////////////////////////////////; 553/// Overwrite the value stored in this object's cache.; 554/// This can be used to fake a computation that resulted in `value`.; 555/// \param[in] value Value to write.; 556/// \param[in] notifyClients If true, notify users of this object that its value changed.; 557/// This is the default.; 558void RooAbsReal::setCachedValue(double value, bool notifyClients) {; 559 _value = value;; 560 ; 561 if (notifyClients) {; 562 setValueDirty();; 563 _valueDirty = false;; 564 }; 565}; 566 ; 567 ; 568#endif; CodeSquashContext.h; EvalContext.h; d#define",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:29669,Integrability,interface,interface,29669,"nt a value and a ""shape"" in RooFit.Definition RooAbsArg.h:79; RooAbsArg::_fastbool _fastDefinition RooAbsArg.h:689; RooAbsArg::_valueDirtybool _valueDirtyDefinition RooAbsArg.h:685; RooAbsArg::setValueDirtyvoid setValueDirty()Mark the element dirty. This forces a re-evaluation when a value is requested.Definition RooAbsArg.h:462; RooAbsArg::inhibitDirtybool inhibitDirty() constDelete watch flag.Definition RooAbsArg.cxx:105; RooAbsArg::_inhibitDirtystatic bool _inhibitDirtyDefinition RooAbsArg.h:668; RooAbsCategoryLValueAbstract base class for objects that represent a discrete value that can be set from the outside,...Definition RooAbsCategoryLValue.h:26; RooAbsCollectionAbstract container object that can hold multiple RooAbsArg objects.Definition RooAbsCollection.h:65; RooAbsCollection::emptybool empty() constDefinition RooAbsCollection.h:273; RooAbsDataAbstract base class for binned and unbinned datasets.Definition RooAbsData.h:57; RooAbsFuncAbstract interface for evaluating a real-valued function of one real variable and performing numerica...Definition RooAbsFunc.h:27; RooAbsMomentDefinition RooAbsMoment.h:27; RooAbsRealLValueAbstract base class for objects that represent a real value that may appear on the left hand side of ...Definition RooAbsRealLValue.h:31; RooAbsReal::EvalErrorContextContext to temporarily change the error logging mode as long as the context is alive.Definition RooAbsReal.h:320; RooAbsReal::EvalErrorContext::~EvalErrorContext~EvalErrorContext()Definition RooAbsReal.h:329; RooAbsReal::EvalErrorContext::EvalErrorContextEvalErrorContext(ErrorLoggingMode m)Definition RooAbsReal.h:322; RooAbsReal::EvalErrorContext::operator=EvalErrorContext & operator=(EvalErrorContext const &)=delete; RooAbsReal::EvalErrorContext::_oldErrorLoggingMode _oldDefinition RooAbsReal.h:331; RooAbsReal::EvalErrorContext::operator=EvalErrorContext & operator=(EvalErrorContext &&)=delete; RooAbsReal::EvalErrorContext::EvalErrorContextEvalErrorContext(EvalErrorContext cons",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:35605,Integrability,integrat,integration,35605,"bsReal::numEvalErrorItemsstatic Int_t numEvalErrorItems()Definition RooAbsReal.cxx:176; RooAbsReal::RooAbsRealRooAbsReal()coverity[UNINIT_CTOR] Default constructorDefinition RooAbsReal.cxx:199; RooAbsReal::fixAddCoefNormalizationvirtual void fixAddCoefNormalization(const RooArgSet &addNormSet=RooArgSet(), bool force=true)Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by...Definition RooAbsReal.cxx:3650; RooAbsReal::hasGradientvirtual bool hasGradient() constDefinition RooAbsReal.h:387; RooAbsReal::getAnalyticalIntegralWNvirtual Int_t getAnalyticalIntegralWN(RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) constVariant of getAnalyticalIntegral that is also passed the normalization set that should be applied to ...Definition RooAbsReal.cxx:351; RooAbsReal::isValidbool isValid() const overrideCheck if current value is valid.Definition RooAbsReal.h:445; RooAbsReal::_forceNumIntbool _forceNumIntForce numerical integration if flag set.Definition RooAbsReal.h:539; RooAbsReal::~RooAbsReal~RooAbsReal() overrideDestructor.Definition RooAbsReal.cxx:238; RooAbsReal::setParameterizeIntegralvoid setParameterizeIntegral(const RooArgSet &paramVars)Definition RooAbsReal.cxx:4324; RooAbsReal::matchArgsByNamebool matchArgsByName(const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) constCheck if allArgs contains matching elements for each name in nameList.Definition RooAbsReal.cxx:3241; RooAbsReal::hideOffsetstatic bool hideOffset()Definition RooAbsReal.cxx:192; RooAbsReal::setTreeBranchStatusvoid setTreeBranchStatus(TTree &t, bool active) override(De)Activate associated tree branchDefinition RooAbsReal.cxx:3116; RooAbsReal::fillHistogramTH1 * fillHistogram(TH1 *hist, const RooArgList &plotVars, double scaleFactor=1, const RooArgSet *projectedVars=nullptr, bool scaling=true, const RooArgSet *condObs=nullptr, bool setError=true) constFill the ROOT histogram 'hist' wit",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:38029,Integrability,interface,interface,38029,"wningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const char *rangeName) constCreate integral over observables in iset in range named rangeName.Definition RooAbsReal.h:207; RooAbsReal::defaultErrorLevelvirtual double defaultErrorLevel() constDefinition RooAbsReal.h:248; RooAbsReal::_DEBUG_getValdouble _DEBUG_getVal(const RooArgSet *normalisationSet) constDebug version of getVal(), which is slow and does error checking.Definition RooAbsReal.cxx:4434; RooAbsReal::createFundamentalRooFit::OwningPtr< RooAbsArg > createFundamental(const char *newname=nullptr) const overrideCreate a RooRealVar fundamental object with our properties.Definition RooAbsReal.cxx:3130; RooAbsReal::plotSanityChecksbool plotSanityChecks(RooPlot *frame) constUtility function for plotOn(), perform general sanity check on frame to ensure safe plotting operatio...Definition RooAbsReal.cxx:2860; RooAbsReal::bindVarsRooFit::OwningPtr< RooAbsFunc > bindVars(const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) constCreate an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order).Definition RooAbsReal.cxx:2980; RooAbsReal::selectNormalizationvirtual void selectNormalization(const RooArgSet *depSet=nullptr, bool force=false)Interface function to force use of a given set of observables to interpret function value.Definition RooAbsReal.cxx:3360; RooAbsReal::derivativeRooDerivative * derivative(RooRealVar &obs, Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Perform a fit to given histogram.Definition RooAbsReal.cxx:4105; RooAbsReal::asTFTF1 * asTF",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:39516,Integrability,integrat,integration,39516,"001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Perform a fit to given histogram.Definition RooAbsReal.cxx:4105; RooAbsReal::asTFTF1 * asTF(const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) constReturn a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parame...Definition RooAbsReal.cxx:3911; RooAbsReal::setDatavirtual bool setData(RooAbsData &, bool=true)Definition RooAbsReal.h:367; RooAbsReal::_unitTString _unitUnit for objects value.Definition RooAbsReal.h:537; RooAbsReal::defaultIntegratorConfigstatic RooNumIntConfig * defaultIntegratorConfig()Returns the default numeric integration configuration for all RooAbsReals.Definition RooAbsReal.cxx:3272; RooAbsReal::getValdouble getVal(const RooArgSet &normalisationSet) constLike getVal(const RooArgSet*), but always requires an argument for normalisation.Definition RooAbsReal.h:126; RooAbsReal::readFromStreambool readFromStream(std::istream &is, bool compact, bool verbose=false) overrideRead object contents from stream (dummy for now)Definition RooAbsReal.cxx:426; RooAbsReal::matchArgsbool matchArgs(const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a) constUtility function for use in getAnalyticalIntegral().Definition RooAbsReal.cxx:3146; RooAbsReal::fillTreeBranchvoid fillTreeBranch(TTree &t) overrideFill the tree branch that associated with this object with its current value.Definition RooAbsReal.cxx:3099; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooArgSet &nset, const char *rangeName=nullptr) co",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:41899,Integrability,integrat,integration,41899,"ategoryLValue &asymCat, PlotOpt o) constDefinition RooAbsReal.cxx:2199; RooAbsReal::operator==bool operator==(double value) constEquality operator comparing to a double.Definition RooAbsReal.cxx:250; RooAbsReal::evalErrorLoggingModestatic ErrorLoggingMode evalErrorLoggingMode()Return current evaluation error logging mode.Definition RooAbsReal.cxx:4302; RooAbsReal::redirectServersHookbool redirectServersHook(const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) overrideFunction that is called at the end of redirectServers().Definition RooAbsReal.cxx:4474; RooAbsReal::minTrialSamplesvirtual Int_t minTrialSamples(const RooArgSet &) constDefinition RooAbsReal.h:241; RooAbsReal::isValidRealvirtual bool isValidReal(double, bool printError=false) constInterface function to check if given value is a valid value for this object. Returns true unless over...Definition RooAbsReal.h:447; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::syncCachevoid syncCache(const RooArgSet *set=nullptr) overrideDefinition RooAbsReal.h:456; RooAbsReal::printValuevoid printValue(std::ostream &os) const overridePrint object value.Definition RooAbsReal.cxx:445; RooAbsReal::forceAnalyticalIntvirtual bool forceAnalyticalInt(const RooAbsArg &) constDefinition RooAbsReal.h:164; RooAbsReal::isIdenticalbool isIdentical(const RooAbsArg &other, bool assumeSameType=false) const overrideDefinition RooAbsReal.cxx:270; RooAbsReal::setUnitvoid setUnit(const char *unit)Definition RooAbsReal.h:147; RooAbsReal::getForceNumIntbool getForceNumInt() constDefinition RooAbsReal.h:174; RooAbsReal::createProfilevirtual RooFit::OwningPtr< RooAbsReal > createProfile(const RooArgSet &paramsOfInterest)Create a RooProfileLL object that eliminates all nuisance parameters in the present function.Definition RooAbsReal.cxx:471; RooAbsReal::_hideOffset",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:44531,Integrability,integrat,integrator,44531,"ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables w...Definition RooAbsReal.cxx:1183; RooAbsReal::fixAddCoefRangevirtual void fixAddCoefRange(const char *rangeName=nullptr, bool force=true)Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by...Definition RooAbsReal.cxx:3675; RooAbsReal::_valuedouble _valueCache for current value of object.Definition RooAbsReal.h:536; RooAbsReal::analyticalIntegralvirtual double analyticalIntegral(Int_t code, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:394; RooAbsReal::attachToTreevoid attachToTree(TTree &t, Int_t bufSize=32000) overrideAttach object to a branch of given TTree.Definition RooAbsReal.cxx:3028; RooAbsReal::BatchInterfaceAccessorfriend class BatchInterfaceAccessorDefinition RooAbsReal.h:399; RooAbsReal::specialIntegratorConfigRooNumIntConfig * specialIntegratorConfig() constReturns the specialized integrator configuration for this RooAbsReal.Definition RooAbsReal.cxx:3282; RooAbsReal::writeToStreamvoid writeToStream(std::ostream &os, bool compact) const overrideWrite object contents to stream (dummy for now)Definition RooAbsReal.cxx:436; RooAbsReal::traceEvaldouble traceEval(const RooArgSet *set) constCalculate current value of object, with error tracing wrapper.Definition RooAbsReal.cxx:319; RooAbsReal::getPropagatedErrordouble getPropagatedError(const RooFitResult &fr, const RooArgSet &nset={}) constPropagates parameter uncertainties to an uncertainty estimate for this RooAbsReal.Definition RooAbsReal.cxx:2472; RooAbsReal::setHideOffsetstatic void setHideOffset(bool flag)Definition RooAbsReal.cxx:191; RooAbsReal::ErrorLoggingModeErrorLoggingModeDefinition RooAbsReal.h:317; RooAbsReal::CountErrors@ CountErrorsDefinition RooAbsReal.h:317; RooAbsReal::CollectErrors@ CollectErrorsDefinition RooAbsReal.h:317; RooAbsReal::PrintErrors@ PrintErrorsDe",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:44895,Integrability,wrap,wrapper,44895,"AbsReal.cxx:3675; RooAbsReal::_valuedouble _valueCache for current value of object.Definition RooAbsReal.h:536; RooAbsReal::analyticalIntegralvirtual double analyticalIntegral(Int_t code, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:394; RooAbsReal::attachToTreevoid attachToTree(TTree &t, Int_t bufSize=32000) overrideAttach object to a branch of given TTree.Definition RooAbsReal.cxx:3028; RooAbsReal::BatchInterfaceAccessorfriend class BatchInterfaceAccessorDefinition RooAbsReal.h:399; RooAbsReal::specialIntegratorConfigRooNumIntConfig * specialIntegratorConfig() constReturns the specialized integrator configuration for this RooAbsReal.Definition RooAbsReal.cxx:3282; RooAbsReal::writeToStreamvoid writeToStream(std::ostream &os, bool compact) const overrideWrite object contents to stream (dummy for now)Definition RooAbsReal.cxx:436; RooAbsReal::traceEvaldouble traceEval(const RooArgSet *set) constCalculate current value of object, with error tracing wrapper.Definition RooAbsReal.cxx:319; RooAbsReal::getPropagatedErrordouble getPropagatedError(const RooFitResult &fr, const RooArgSet &nset={}) constPropagates parameter uncertainties to an uncertainty estimate for this RooAbsReal.Definition RooAbsReal.cxx:2472; RooAbsReal::setHideOffsetstatic void setHideOffset(bool flag)Definition RooAbsReal.cxx:191; RooAbsReal::ErrorLoggingModeErrorLoggingModeDefinition RooAbsReal.h:317; RooAbsReal::CountErrors@ CountErrorsDefinition RooAbsReal.h:317; RooAbsReal::CollectErrors@ CollectErrorsDefinition RooAbsReal.h:317; RooAbsReal::PrintErrors@ PrintErrorsDefinition RooAbsReal.h:317; RooAbsReal::Ignore@ IgnoreDefinition RooAbsReal.h:317; RooAbsReal::globalSelectCompstatic void globalSelectComp(bool flag)Global switch controlling the activation of the selectComp() functionality.Definition RooAbsReal.cxx:2966; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooA",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:49732,Integrability,integrat,integrated,49732,"Set evaluation error logging mode.Definition RooAbsReal.cxx:4316; RooAbsReal::_plotMaxdouble _plotMaxMaximum of plot range.Definition RooAbsReal.h:534; RooAbsReal::preferredObservableScanOrdervirtual void preferredObservableScanOrder(const RooArgSet &obs, RooArgSet &orderedObs) constInterface method for function objects to indicate their preferred order of observables for scanning t...Definition RooAbsReal.cxx:3694; RooAbsReal::maxValvirtual double maxVal(Int_t code) constReturn maximum value for set of observables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive integrals over functions ...Definition RooAbsReal.cxx:701; RooAbsReal::integralNameSuffixTString integralNameSuffix(const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:50115,Integrability,message,message,50115,"servables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive integrals over functions ...Definition RooAbsReal.cxx:701; RooAbsReal::integralNameSuffixTString integralNameSuffix(const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::isBinnedDistributionvirtual bool isBinnedDistribution(const RooArgSet &) constTests if the distribution is binned. Unless overridden by derived classes, this always returns false.Definition RooAbsReal.h:346; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the gi",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:50189,Integrability,message,message,50189,"servables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive integrals over functions ...Definition RooAbsReal.cxx:701; RooAbsReal::integralNameSuffixTString integralNameSuffix(const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::isBinnedDistributionvirtual bool isBinnedDistribution(const RooArgSet &) constTests if the distribution is binned. Unless overridden by derived classes, this always returns false.Definition RooAbsReal.h:346; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the gi",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:50662,Integrability,integrat,integration,50662,"itEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::isBinnedDistributionvirtual bool isBinnedDistribution(const RooArgSet &) constTests if the distribution is binned. Unless overridden by derived classes, this always returns false.Definition RooAbsReal.h:346; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsReal.cxx:3827; RooAbsReal::enableOffsettingvirtual void enableOffsetting(bool)Definition RooAbsReal.cxx:4484; RooAbsReal::clearEvalErrorLogstatic void clearEvalErrorLog()Clear the stack of evaluation error messages.Definition RooAbsReal.cxx:3542; RooAbsReal::createIntObjRooFit::OwningPtr",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:51550,Integrability,message,messages,51550,"tconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::isBinnedDistributionvirtual bool isBinnedDistribution(const RooArgSet &) constTests if the distribution is binned. Unless overridden by derived classes, this always returns false.Definition RooAbsReal.h:346; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsReal.cxx:3827; RooAbsReal::enableOffsettingvirtual void enableOffsetting(bool)Definition RooAbsReal.cxx:4484; RooAbsReal::clearEvalErrorLogstatic void clearEvalErrorLog()Clear the stack of evaluation error messages.Definition RooAbsReal.cxx:3542; RooAbsReal::createIntObjRooFit::OwningPtr< RooAbsReal > createIntObj(const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) constInternal utility function for createIntegral() that creates the actual integral object.Definition RooAbsReal.cxx:590; RooAbsReal::sigmaRooAbsMoment * sigma(RooRealVar &obs, const RooArgSet &nset)Definition RooAbsReal.h:362; RooAbsReal::functorRooFunctor * functor(const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) constReturn a RooFunctor object bound to this RooAbsReal with given definition of observables and paramete...Definition RooAbsReal.cxx:3887; RooAbsReal::setCachedValuevoid setCachedValue(double value, bool notifyClients=true) finalOverwrite the value stored in this object's cache.Definition RooAbsReal.h:558; RooAbsReal::_plotBinsInt_t _plotBinsNumber of plot bins.Definition RooA",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:55199,Integrability,interface,interface,55199,"ition RooAbsReal.cxx:3386; RooAbsReal::_plotMindouble _plotMinMinimum of plot range.Definition RooAbsReal.h:533; RooAbsReal::meanRooAbsMoment * mean(RooRealVar &obs, const RooArgSet &nset)Definition RooAbsReal.h:360; RooAbsReal::createChi2virtual RooFit::OwningPtr< RooAbsReal > createChi2(RooDataHist &data, const RooLinkedList &cmdList)Definition RooAbsReal.cxx:4200; RooAbsReal::offsetvirtual double offset() constDefinition RooAbsReal.h:371; RooAbsReal::sigmaRooAbsMoment * sigma(RooRealVar &obs)Definition RooAbsReal.h:361; RooAbsReal::_globalSelectCompstatic bool _globalSelectCompDefinition RooAbsReal.h:545; RooAddHelpersDefinition RooAddHelpers.h:56; RooAddModelRooAddModel is an efficient implementation of a sum of PDFs of the form.Definition RooAddModel.h:27; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgProxyAbstract interface for RooAbsArg proxy classes.Definition RooArgProxy.h:24; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooCmdArgNamed container for two doubles, two integers two object points and three string pointers that can be...Definition RooCmdArg.h:26; RooCurve::WingModeWingModeDefinition RooCurve.h:39; RooCurve::Extended@ ExtendedDefinition RooCurve.h:39; RooDataHistContainer class to hold N-dimensional binned data.Definition RooDataHist.h:40; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDerivativeRepresents the first, second, or third order derivative of any RooAbsReal as calculated (numerically)...Definition RooDerivative.h:30; RooFitResultRooFitResult is a container class to hold the input and output of a PDF fit to a dataset.Definition RooFitResult.h:40; RooFit::Detail::CodeSquashContextA class to maintain the context for squashing of RooFit models into code.Definition CodeSquashContext.h:42",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:56277,Integrability,interface,interface,56277,"ontainer object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooCmdArgNamed container for two doubles, two integers two object points and three string pointers that can be...Definition RooCmdArg.h:26; RooCurve::WingModeWingModeDefinition RooCurve.h:39; RooCurve::Extended@ ExtendedDefinition RooCurve.h:39; RooDataHistContainer class to hold N-dimensional binned data.Definition RooDataHist.h:40; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDerivativeRepresents the first, second, or third order derivative of any RooAbsReal as calculated (numerically)...Definition RooDerivative.h:30; RooFitResultRooFitResult is a container class to hold the input and output of a PDF fit to a dataset.Definition RooFitResult.h:40; RooFit::Detail::CodeSquashContextA class to maintain the context for squashing of RooFit models into code.Definition CodeSquashContext.h:42; RooFit::EvalContextDefinition EvalContext.h:84; RooFunctorLightweight interface adaptor that exports a RooAbsPdf as a functor.Definition RooFunctor.h:25; RooLinkedListCollection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list...Definition RooLinkedList.h:44; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooRealBindingLightweight interface adaptor that binds a RooAbsReal object to a subset of its servers and present i...Definition RooRealBinding.h:30; RooRealSumFuncDefinition RooRealSumFunc.h:26; RooRealSumPdfImplements a PDF constructed from a sum of functions:Definition RooRealSumPdf.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooStringViewThe RooStringView is a wrapper around a C-style string that can also be constructed from a std::strin...Definition RooStringView.h:27; RooVectorDataStor",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:56582,Integrability,integrat,integrators,56582,".h:39; RooCurve::Extended@ ExtendedDefinition RooCurve.h:39; RooDataHistContainer class to hold N-dimensional binned data.Definition RooDataHist.h:40; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDerivativeRepresents the first, second, or third order derivative of any RooAbsReal as calculated (numerically)...Definition RooDerivative.h:30; RooFitResultRooFitResult is a container class to hold the input and output of a PDF fit to a dataset.Definition RooFitResult.h:40; RooFit::Detail::CodeSquashContextA class to maintain the context for squashing of RooFit models into code.Definition CodeSquashContext.h:42; RooFit::EvalContextDefinition EvalContext.h:84; RooFunctorLightweight interface adaptor that exports a RooAbsPdf as a functor.Definition RooFunctor.h:25; RooLinkedListCollection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list...Definition RooLinkedList.h:44; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooRealBindingLightweight interface adaptor that binds a RooAbsReal object to a subset of its servers and present i...Definition RooRealBinding.h:30; RooRealSumFuncDefinition RooRealSumFunc.h:26; RooRealSumPdfImplements a PDF constructed from a sum of functions:Definition RooRealSumPdf.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooStringViewThe RooStringView is a wrapper around a C-style string that can also be constructed from a std::strin...Definition RooStringView.h:27; RooVectorDataStoreUses std::vector to store data columns.Definition RooVectorDataStore.h:41; TF11-Dim function classDefinition TF1.h:233; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Def",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:56775,Integrability,interface,interface,56775,"esents the first, second, or third order derivative of any RooAbsReal as calculated (numerically)...Definition RooDerivative.h:30; RooFitResultRooFitResult is a container class to hold the input and output of a PDF fit to a dataset.Definition RooFitResult.h:40; RooFit::Detail::CodeSquashContextA class to maintain the context for squashing of RooFit models into code.Definition CodeSquashContext.h:42; RooFit::EvalContextDefinition EvalContext.h:84; RooFunctorLightweight interface adaptor that exports a RooAbsPdf as a functor.Definition RooFunctor.h:25; RooLinkedListCollection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list...Definition RooLinkedList.h:44; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooRealBindingLightweight interface adaptor that binds a RooAbsReal object to a subset of its servers and present i...Definition RooRealBinding.h:30; RooRealSumFuncDefinition RooRealSumFunc.h:26; RooRealSumPdfImplements a PDF constructed from a sum of functions:Definition RooRealSumPdf.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooStringViewThe RooStringView is a wrapper around a C-style string that can also be constructed from a std::strin...Definition RooStringView.h:27; RooVectorDataStoreUses std::vector to store data columns.Definition RooVectorDataStore.h:41; TF11-Dim function classDefinition TF1.h:233; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH3F3-D histogram with a float per channel (see TH1 documentation)Definition TH3.h:317; TListA doubly linked list.Definition TList.h:38; ",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:57162,Integrability,wrap,wrapper,57162,"on CodeSquashContext.h:42; RooFit::EvalContextDefinition EvalContext.h:84; RooFunctorLightweight interface adaptor that exports a RooAbsPdf as a functor.Definition RooFunctor.h:25; RooLinkedListCollection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list...Definition RooLinkedList.h:44; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooRealBindingLightweight interface adaptor that binds a RooAbsReal object to a subset of its servers and present i...Definition RooRealBinding.h:30; RooRealSumFuncDefinition RooRealSumFunc.h:26; RooRealSumPdfImplements a PDF constructed from a sum of functions:Definition RooRealSumPdf.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooStringViewThe RooStringView is a wrapper around a C-style string that can also be constructed from a std::strin...Definition RooStringView.h:27; RooVectorDataStoreUses std::vector to store data columns.Definition RooVectorDataStore.h:41; TF11-Dim function classDefinition TF1.h:233; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH3F3-D histogram with a float per channel (see TH1 documentation)Definition TH3.h:317; TListA doubly linked list.Definition TList.h:38; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; double; int; xDouble_t x[n]Definition legend1.C:17; RooBatchComputeNamespace for dispatching RooFit computations to various backends.Definition RooBatchCompute.h:37; RooFit::MPSplitMPSplitDefinit",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:3627,Modifiability,variab,variables,3627,"ooAbsReal() ;; 80 RooAbsReal(const char *name, const char *title, const char *unit= """") ;; 81 RooAbsReal(const char *name, const char *title, double minVal, double maxVal,; 82 const char *unit= """") ;; 83 RooAbsReal(const RooAbsReal& other, const char* name=nullptr);; 84 ~RooAbsReal() override;; 85 ; 86 ; 87 ; 88 ; 89 //////////////////////////////////////////////////////////////////////////////////; 90 /// Evaluate object. Returns either cached value or triggers a recalculation.; 91 /// The recalculation happens by calling getValV(), which in the end calls the; 92 /// virtual evaluate() functions of the respective PDFs.; 93 /// \param[in] normalisationSet getValV() reacts differently depending on the value of the normalisation set.; 94 /// If the set is `nullptr`, an unnormalised value is returned.; 95 /// \note The normalisation is arbitrary, because it is up to the implementation; 96 /// of the PDF to e.g. leave out normalisation constants for speed reasons. The range; 97 /// of the variables is also ignored.; 98 ///; 99 /// To normalise the result properly, a RooArgSet has to be passed, which contains; 100 /// the variables to normalise over.; 101 /// These are integrated over their current ranges to compute the normalisation constant,; 102 /// and the unnormalised result is divided by this value.; 103 inline double getVal(const RooArgSet* normalisationSet = nullptr) const {; 104 // Sometimes, the calling code uses an empty RooArgSet to request evaluation; 105 // without normalization set instead of following the `nullptr` convention.; 106 // To remove this ambiguity which might not always be correctly handled in; 107 // downstream code, we set `normalisationSet` to nullptr if it is pointing; 108 // to an empty set.; 109 if(normalisationSet && normalisationSet->empty()) {; 110 normalisationSet = nullptr;; 111 }; 112#ifdef ROOFIT_CHECK_CACHED_VALUES; 113 return _DEBUG_getVal(normalisationSet);; 114#else; 115 ; 116#ifndef _WIN32; 117 return (_fast && !_inhibitDirty",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:3762,Modifiability,variab,variables,3762,"RooAbsReal(const char *name, const char *title, double minVal, double maxVal,; 82 const char *unit= """") ;; 83 RooAbsReal(const RooAbsReal& other, const char* name=nullptr);; 84 ~RooAbsReal() override;; 85 ; 86 ; 87 ; 88 ; 89 //////////////////////////////////////////////////////////////////////////////////; 90 /// Evaluate object. Returns either cached value or triggers a recalculation.; 91 /// The recalculation happens by calling getValV(), which in the end calls the; 92 /// virtual evaluate() functions of the respective PDFs.; 93 /// \param[in] normalisationSet getValV() reacts differently depending on the value of the normalisation set.; 94 /// If the set is `nullptr`, an unnormalised value is returned.; 95 /// \note The normalisation is arbitrary, because it is up to the implementation; 96 /// of the PDF to e.g. leave out normalisation constants for speed reasons. The range; 97 /// of the variables is also ignored.; 98 ///; 99 /// To normalise the result properly, a RooArgSet has to be passed, which contains; 100 /// the variables to normalise over.; 101 /// These are integrated over their current ranges to compute the normalisation constant,; 102 /// and the unnormalised result is divided by this value.; 103 inline double getVal(const RooArgSet* normalisationSet = nullptr) const {; 104 // Sometimes, the calling code uses an empty RooArgSet to request evaluation; 105 // without normalization set instead of following the `nullptr` convention.; 106 // To remove this ambiguity which might not always be correctly handled in; 107 // downstream code, we set `normalisationSet` to nullptr if it is pointing; 108 // to an empty set.; 109 if(normalisationSet && normalisationSet->empty()) {; 110 normalisationSet = nullptr;; 111 }; 112#ifdef ROOFIT_CHECK_CACHED_VALUES; 113 return _DEBUG_getVal(normalisationSet);; 114#else; 115 ; 116#ifndef _WIN32; 117 return (_fast && !_inhibitDirty) ? _value : getValV(normalisationSet) ;; 118#else; 119 return (_fast && !inhibitDirty()) ? _va",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:6106,Modifiability,adapt,adaptors,6106,"ntion.; 129 // To remove this ambiguity which might not always be correctly handled in; 130 // downstream code, we set `normalisationSet` to nullptr if it is an empty set.; 131 return _fast ? _value : getValV(normalisationSet.empty() ? nullptr : &normalisationSet) ;; 132 }; 133 ; 134 virtual double getValV(const RooArgSet* normalisationSet = nullptr) const ;; 135 ; 136 double getPropagatedError(const RooFitResult &fr, const RooArgSet &nset = {}) const;; 137 ; 138 bool operator==(double value) const ;; 139 bool operator==(const RooAbsArg& other) const override;; 140 bool isIdentical(const RooAbsArg& other, bool assumeSameType=false) const override;; 141 ; 142 ; 143 inline const Text_t *getUnit() const {; 144 // Return string with unit description; 145 return _unit.Data();; 146 }; 147 inline void setUnit(const char *unit) {; 148 // Set unit description to given string; 149 _unit= unit;; 150 }; 151 TString getTitle(bool appendUnit= false) const;; 152 ; 153 // Lightweight interface adaptors (caller takes ownership); 154 RooFit::OwningPtr<RooAbsFunc> bindVars(const RooArgSet &vars, const RooArgSet* nset=nullptr, bool clipInvalid=false) const;; 155 ; 156 // Create a fundamental-type object that can hold our value.; 157 RooFit::OwningPtr<RooAbsArg> createFundamental(const char* newname=nullptr) const override;; 158 ; 159 // Analytical integration support; 160 virtual Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 161 virtual double analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 162 virtual Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName=nullptr) const ;; 163 virtual double analyticalIntegral(Int_t code, const char* rangeName=nullptr) const ;; 164 virtual bool forceAnalyticalInt(const RooAbsArg& /*dep*/) const {; 165 // Interface to force RooRealIntegral to offer given observable for internal ",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:10351,Modifiability,config,configuration,10351,"RooCmdArg& arg3={}, const RooCmdArg& arg4={}, const RooCmdArg& arg5={},; 196 const RooCmdArg& arg6={}, const RooCmdArg& arg7={}, const RooCmdArg& arg8={}) ;; 197 ; 198 virtual RooFit::OwningPtr<RooAbsReal> createProfile(const RooArgSet& paramsOfInterest) ;; 199 ; 200 ; 201 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2={},; 202 const RooCmdArg& arg3={}, const RooCmdArg& arg4={},; 203 const RooCmdArg& arg5={}, const RooCmdArg& arg6={},; 204 const RooCmdArg& arg7={}, const RooCmdArg& arg8={}) const ;; 205 ; 206 /// Create integral over observables in iset in range named rangeName.; 207 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const char* rangeName) const {; 208 return createIntegral(iset,nullptr,nullptr,rangeName) ;; 209 }; 210 /// Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset; 211 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooArgSet& nset, const char* rangeName=nullptr) const {; 212 return createIntegral(iset,&nset,nullptr,rangeName) ;; 213 }; 214 /// Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset while; 215 /// using specified configuration for any numeric integration.; 216 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooArgSet& nset, const RooNumIntConfig& cfg, const char* rangeName=nullptr) const {; 217 return createIntegral(iset,&nset,&cfg,rangeName) ;; 218 }; 219 /// Create integral over observables in iset in range named rangeName using specified configuration for any numeric integration.; 220 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooNumIntConfig& cfg, const char* rangeName=nullptr) const {; 221 return createIntegral(iset,nullptr,&cfg,rangeName) ;; 222 }; 223 virtual RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, cons",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:10711,Modifiability,config,configuration,10711,"7={}, const RooCmdArg& arg8={}) const ;; 205 ; 206 /// Create integral over observables in iset in range named rangeName.; 207 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const char* rangeName) const {; 208 return createIntegral(iset,nullptr,nullptr,rangeName) ;; 209 }; 210 /// Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset; 211 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooArgSet& nset, const char* rangeName=nullptr) const {; 212 return createIntegral(iset,&nset,nullptr,rangeName) ;; 213 }; 214 /// Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset while; 215 /// using specified configuration for any numeric integration.; 216 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooArgSet& nset, const RooNumIntConfig& cfg, const char* rangeName=nullptr) const {; 217 return createIntegral(iset,&nset,&cfg,rangeName) ;; 218 }; 219 /// Create integral over observables in iset in range named rangeName using specified configuration for any numeric integration.; 220 RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooNumIntConfig& cfg, const char* rangeName=nullptr) const {; 221 return createIntegral(iset,nullptr,&cfg,rangeName) ;; 222 }; 223 virtual RooFit::OwningPtr<RooAbsReal> createIntegral(const RooArgSet& iset, const RooArgSet* nset=nullptr, const RooNumIntConfig* cfg=nullptr, const char* rangeName=nullptr) const ;; 224 ; 225 ; 226 void setParameterizeIntegral(const RooArgSet& paramVars) ;; 227 ; 228 // Create running integrals; 229 RooFit::OwningPtr<RooAbsReal> createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset={}) ;; 230 RooFit::OwningPtr<RooAbsReal> createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2={},; 231 const RooCmdArg& arg3={}, const RooCmdArg& arg4={},; 232 const RooCmdA",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:12788,Modifiability,config,config,12788,,MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:26291,Modifiability,config,configuration,26291,"tate;; 521 };; 522 ; 523 ; 524private:; 525 ; 526 /// Debug version of getVal(), which is slow and does error checking.; 527 double _DEBUG_getVal(const RooArgSet* normalisationSet) const;; 528 ; 529 //--------------------------------------------------------------------; 530 ; 531 protected:; 532 ; 533 double _plotMin = 0.0; ///< Minimum of plot range; 534 double _plotMax = 0.0; ///< Maximum of plot range; 535 Int_t _plotBins = 100; ///< Number of plot bins; 536 mutable double _value = 0.0; ///< Cache for current value of object; 537 TString _unit; ///< Unit for objects value; 538 TString _label; ///< Plot label for objects value; 539 bool _forceNumInt = false; ///< Force numerical integration if flag set; 540 std::unique_ptr<RooNumIntConfig> _specIntegratorConfig; // Numeric integrator configuration specific for this object; 541 TreeReadBuffer *_treeReadBuffer = nullptr; //! A buffer for reading values from trees; 542 bool _selectComp = true; //! Component selection flag for RooAbsPdf::plotCompOn; 543 mutable RooFit::UniqueId<RooArgSet>::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval; ///<!; 544 ; 545 static bool _globalSelectComp; // Global activation switch for component selection; 546 static bool _hideOffset; ///< Offset hiding flag; 547 ; 548 ClassDefOverride(RooAbsReal,3); // Abstract real-valued variable; 549};; 550 ; 551 ; 552////////////////////////////////////////////////////////////////////////////////; 553/// Overwrite the value stored in this object's cache.; 554/// This can be used to fake a computation that resulted in `value`.; 555/// \param[in] value Value to write.; 556/// \param[in] notifyClients If true, notify users of this object that its value changed.; 557/// This is the default.; 558void RooAbsReal::setCachedValue(double value, bool notifyClients) {; 559 _value = value;; 560 ; 561 if (notifyClients) {; 562 setValueDirty();; 563 _valueDirty = false;; 564 }; 565}; 566 ; 567 ; 568#endif; CodeSquashContext.h; EvalContext.h; d#define",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:26832,Modifiability,variab,variable,26832,"tate;; 521 };; 522 ; 523 ; 524private:; 525 ; 526 /// Debug version of getVal(), which is slow and does error checking.; 527 double _DEBUG_getVal(const RooArgSet* normalisationSet) const;; 528 ; 529 //--------------------------------------------------------------------; 530 ; 531 protected:; 532 ; 533 double _plotMin = 0.0; ///< Minimum of plot range; 534 double _plotMax = 0.0; ///< Maximum of plot range; 535 Int_t _plotBins = 100; ///< Number of plot bins; 536 mutable double _value = 0.0; ///< Cache for current value of object; 537 TString _unit; ///< Unit for objects value; 538 TString _label; ///< Plot label for objects value; 539 bool _forceNumInt = false; ///< Force numerical integration if flag set; 540 std::unique_ptr<RooNumIntConfig> _specIntegratorConfig; // Numeric integrator configuration specific for this object; 541 TreeReadBuffer *_treeReadBuffer = nullptr; //! A buffer for reading values from trees; 542 bool _selectComp = true; //! Component selection flag for RooAbsPdf::plotCompOn; 543 mutable RooFit::UniqueId<RooArgSet>::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval; ///<!; 544 ; 545 static bool _globalSelectComp; // Global activation switch for component selection; 546 static bool _hideOffset; ///< Offset hiding flag; 547 ; 548 ClassDefOverride(RooAbsReal,3); // Abstract real-valued variable; 549};; 550 ; 551 ; 552////////////////////////////////////////////////////////////////////////////////; 553/// Overwrite the value stored in this object's cache.; 554/// This can be used to fake a computation that resulted in `value`.; 555/// \param[in] value Value to write.; 556/// \param[in] notifyClients If true, notify users of this object that its value changed.; 557/// This is the default.; 558void RooAbsReal::setCachedValue(double value, bool notifyClients) {; 559 _value = value;; 560 ; 561 if (notifyClients) {; 562 setValueDirty();; 563 _valueDirty = false;; 564 }; 565}; 566 ; 567 ; 568#endif; CodeSquashContext.h; EvalContext.h; d#define",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:29729,Modifiability,variab,variable,29729,"nt a value and a ""shape"" in RooFit.Definition RooAbsArg.h:79; RooAbsArg::_fastbool _fastDefinition RooAbsArg.h:689; RooAbsArg::_valueDirtybool _valueDirtyDefinition RooAbsArg.h:685; RooAbsArg::setValueDirtyvoid setValueDirty()Mark the element dirty. This forces a re-evaluation when a value is requested.Definition RooAbsArg.h:462; RooAbsArg::inhibitDirtybool inhibitDirty() constDelete watch flag.Definition RooAbsArg.cxx:105; RooAbsArg::_inhibitDirtystatic bool _inhibitDirtyDefinition RooAbsArg.h:668; RooAbsCategoryLValueAbstract base class for objects that represent a discrete value that can be set from the outside,...Definition RooAbsCategoryLValue.h:26; RooAbsCollectionAbstract container object that can hold multiple RooAbsArg objects.Definition RooAbsCollection.h:65; RooAbsCollection::emptybool empty() constDefinition RooAbsCollection.h:273; RooAbsDataAbstract base class for binned and unbinned datasets.Definition RooAbsData.h:57; RooAbsFuncAbstract interface for evaluating a real-valued function of one real variable and performing numerica...Definition RooAbsFunc.h:27; RooAbsMomentDefinition RooAbsMoment.h:27; RooAbsRealLValueAbstract base class for objects that represent a real value that may appear on the left hand side of ...Definition RooAbsRealLValue.h:31; RooAbsReal::EvalErrorContextContext to temporarily change the error logging mode as long as the context is alive.Definition RooAbsReal.h:320; RooAbsReal::EvalErrorContext::~EvalErrorContext~EvalErrorContext()Definition RooAbsReal.h:329; RooAbsReal::EvalErrorContext::EvalErrorContextEvalErrorContext(ErrorLoggingMode m)Definition RooAbsReal.h:322; RooAbsReal::EvalErrorContext::operator=EvalErrorContext & operator=(EvalErrorContext const &)=delete; RooAbsReal::EvalErrorContext::_oldErrorLoggingMode _oldDefinition RooAbsReal.h:331; RooAbsReal::EvalErrorContext::operator=EvalErrorContext & operator=(EvalErrorContext &&)=delete; RooAbsReal::EvalErrorContext::EvalErrorContextEvalErrorContext(EvalErrorContext cons",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:38039,Modifiability,adapt,adaptor,38039,"wningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const char *rangeName) constCreate integral over observables in iset in range named rangeName.Definition RooAbsReal.h:207; RooAbsReal::defaultErrorLevelvirtual double defaultErrorLevel() constDefinition RooAbsReal.h:248; RooAbsReal::_DEBUG_getValdouble _DEBUG_getVal(const RooArgSet *normalisationSet) constDebug version of getVal(), which is slow and does error checking.Definition RooAbsReal.cxx:4434; RooAbsReal::createFundamentalRooFit::OwningPtr< RooAbsArg > createFundamental(const char *newname=nullptr) const overrideCreate a RooRealVar fundamental object with our properties.Definition RooAbsReal.cxx:3130; RooAbsReal::plotSanityChecksbool plotSanityChecks(RooPlot *frame) constUtility function for plotOn(), perform general sanity check on frame to ensure safe plotting operatio...Definition RooAbsReal.cxx:2860; RooAbsReal::bindVarsRooFit::OwningPtr< RooAbsFunc > bindVars(const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) constCreate an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order).Definition RooAbsReal.cxx:2980; RooAbsReal::selectNormalizationvirtual void selectNormalization(const RooArgSet *depSet=nullptr, bool force=false)Interface function to force use of a given set of observables to interpret function value.Definition RooAbsReal.cxx:3360; RooAbsReal::derivativeRooDerivative * derivative(RooRealVar &obs, Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Perform a fit to given histogram.Definition RooAbsReal.cxx:4105; RooAbsReal::asTFTF1 * asTF",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:38086,Modifiability,variab,variables,38086,"wningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const char *rangeName) constCreate integral over observables in iset in range named rangeName.Definition RooAbsReal.h:207; RooAbsReal::defaultErrorLevelvirtual double defaultErrorLevel() constDefinition RooAbsReal.h:248; RooAbsReal::_DEBUG_getValdouble _DEBUG_getVal(const RooArgSet *normalisationSet) constDebug version of getVal(), which is slow and does error checking.Definition RooAbsReal.cxx:4434; RooAbsReal::createFundamentalRooFit::OwningPtr< RooAbsArg > createFundamental(const char *newname=nullptr) const overrideCreate a RooRealVar fundamental object with our properties.Definition RooAbsReal.cxx:3130; RooAbsReal::plotSanityChecksbool plotSanityChecks(RooPlot *frame) constUtility function for plotOn(), perform general sanity check on frame to ensure safe plotting operatio...Definition RooAbsReal.cxx:2860; RooAbsReal::bindVarsRooFit::OwningPtr< RooAbsFunc > bindVars(const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) constCreate an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order).Definition RooAbsReal.cxx:2980; RooAbsReal::selectNormalizationvirtual void selectNormalization(const RooArgSet *depSet=nullptr, bool force=false)Interface function to force use of a given set of observables to interpret function value.Definition RooAbsReal.cxx:3360; RooAbsReal::derivativeRooDerivative * derivative(RooRealVar &obs, Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Perform a fit to given histogram.Definition RooAbsReal.cxx:4105; RooAbsReal::asTFTF1 * asTF",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:39528,Modifiability,config,configuration,39528,"001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Perform a fit to given histogram.Definition RooAbsReal.cxx:4105; RooAbsReal::asTFTF1 * asTF(const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) constReturn a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parame...Definition RooAbsReal.cxx:3911; RooAbsReal::setDatavirtual bool setData(RooAbsData &, bool=true)Definition RooAbsReal.h:367; RooAbsReal::_unitTString _unitUnit for objects value.Definition RooAbsReal.h:537; RooAbsReal::defaultIntegratorConfigstatic RooNumIntConfig * defaultIntegratorConfig()Returns the default numeric integration configuration for all RooAbsReals.Definition RooAbsReal.cxx:3272; RooAbsReal::getValdouble getVal(const RooArgSet &normalisationSet) constLike getVal(const RooArgSet*), but always requires an argument for normalisation.Definition RooAbsReal.h:126; RooAbsReal::readFromStreambool readFromStream(std::istream &is, bool compact, bool verbose=false) overrideRead object contents from stream (dummy for now)Definition RooAbsReal.cxx:426; RooAbsReal::matchArgsbool matchArgs(const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a) constUtility function for use in getAnalyticalIntegral().Definition RooAbsReal.cxx:3146; RooAbsReal::fillTreeBranchvoid fillTreeBranch(TTree &t) overrideFill the tree branch that associated with this object with its current value.Definition RooAbsReal.cxx:3099; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooArgSet &nset, const char *rangeName=nullptr) co",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:41911,Modifiability,config,configuration,41911,"ategoryLValue &asymCat, PlotOpt o) constDefinition RooAbsReal.cxx:2199; RooAbsReal::operator==bool operator==(double value) constEquality operator comparing to a double.Definition RooAbsReal.cxx:250; RooAbsReal::evalErrorLoggingModestatic ErrorLoggingMode evalErrorLoggingMode()Return current evaluation error logging mode.Definition RooAbsReal.cxx:4302; RooAbsReal::redirectServersHookbool redirectServersHook(const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) overrideFunction that is called at the end of redirectServers().Definition RooAbsReal.cxx:4474; RooAbsReal::minTrialSamplesvirtual Int_t minTrialSamples(const RooArgSet &) constDefinition RooAbsReal.h:241; RooAbsReal::isValidRealvirtual bool isValidReal(double, bool printError=false) constInterface function to check if given value is a valid value for this object. Returns true unless over...Definition RooAbsReal.h:447; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::syncCachevoid syncCache(const RooArgSet *set=nullptr) overrideDefinition RooAbsReal.h:456; RooAbsReal::printValuevoid printValue(std::ostream &os) const overridePrint object value.Definition RooAbsReal.cxx:445; RooAbsReal::forceAnalyticalIntvirtual bool forceAnalyticalInt(const RooAbsArg &) constDefinition RooAbsReal.h:164; RooAbsReal::isIdenticalbool isIdentical(const RooAbsArg &other, bool assumeSameType=false) const overrideDefinition RooAbsReal.cxx:270; RooAbsReal::setUnitvoid setUnit(const char *unit)Definition RooAbsReal.h:147; RooAbsReal::getForceNumIntbool getForceNumInt() constDefinition RooAbsReal.h:174; RooAbsReal::createProfilevirtual RooFit::OwningPtr< RooAbsReal > createProfile(const RooArgSet &paramsOfInterest)Create a RooProfileLL object that eliminates all nuisance parameters in the present function.Definition RooAbsReal.cxx:471; RooAbsReal::_hideOffset",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:43568,Modifiability,variab,variables,43568,"AbsReal::setUnitvoid setUnit(const char *unit)Definition RooAbsReal.h:147; RooAbsReal::getForceNumIntbool getForceNumInt() constDefinition RooAbsReal.h:174; RooAbsReal::createProfilevirtual RooFit::OwningPtr< RooAbsReal > createProfile(const RooArgSet &paramsOfInterest)Create a RooProfileLL object that eliminates all nuisance parameters in the present function.Definition RooAbsReal.cxx:471; RooAbsReal::_hideOffsetstatic bool _hideOffsetOffset hiding flag.Definition RooAbsReal.h:546; RooAbsReal::attachToVStorevoid attachToVStore(RooVectorDataStore &vstore) overrideDefinition RooAbsReal.cxx:3012; RooAbsReal::copyCachevoid copyCache(const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) overrideCopy the cached value of another RooAbsArg to our cache.Definition RooAbsReal.cxx:2997; RooAbsReal::gradientvirtual void gradient(double *) constDefinition RooAbsReal.h:388; RooAbsReal::createHistogramTH1 * createHistogram(RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) constCreate and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables w...Definition RooAbsReal.cxx:1183; RooAbsReal::fixAddCoefRangevirtual void fixAddCoefRange(const char *rangeName=nullptr, bool force=true)Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by...Definition RooAbsReal.cxx:3675; RooAbsReal::_valuedouble _valueCache for current value of object.Definition RooAbsReal.h:536; RooAbsReal::analyticalIntegralvirtual double analyticalIntegral(Int_t code, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:394; RooAbsReal::attachToTreevoid attachToTree(TTree &t, Int_t bufSize=32000) overrideAttach object to a branch of given TTree.Definition RooAbsReal.cxx:3028; RooAbsReal::BatchInterfaceAccessorfriend class BatchInterfaceAccessorDefinition RooAbsReal.h:399; RooAbsReal::specialIntegratorConfigRooNu",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:44542,Modifiability,config,configuration,44542,"ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables w...Definition RooAbsReal.cxx:1183; RooAbsReal::fixAddCoefRangevirtual void fixAddCoefRange(const char *rangeName=nullptr, bool force=true)Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by...Definition RooAbsReal.cxx:3675; RooAbsReal::_valuedouble _valueCache for current value of object.Definition RooAbsReal.h:536; RooAbsReal::analyticalIntegralvirtual double analyticalIntegral(Int_t code, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:394; RooAbsReal::attachToTreevoid attachToTree(TTree &t, Int_t bufSize=32000) overrideAttach object to a branch of given TTree.Definition RooAbsReal.cxx:3028; RooAbsReal::BatchInterfaceAccessorfriend class BatchInterfaceAccessorDefinition RooAbsReal.h:399; RooAbsReal::specialIntegratorConfigRooNumIntConfig * specialIntegratorConfig() constReturns the specialized integrator configuration for this RooAbsReal.Definition RooAbsReal.cxx:3282; RooAbsReal::writeToStreamvoid writeToStream(std::ostream &os, bool compact) const overrideWrite object contents to stream (dummy for now)Definition RooAbsReal.cxx:436; RooAbsReal::traceEvaldouble traceEval(const RooArgSet *set) constCalculate current value of object, with error tracing wrapper.Definition RooAbsReal.cxx:319; RooAbsReal::getPropagatedErrordouble getPropagatedError(const RooFitResult &fr, const RooArgSet &nset={}) constPropagates parameter uncertainties to an uncertainty estimate for this RooAbsReal.Definition RooAbsReal.cxx:2472; RooAbsReal::setHideOffsetstatic void setHideOffset(bool flag)Definition RooAbsReal.cxx:191; RooAbsReal::ErrorLoggingModeErrorLoggingModeDefinition RooAbsReal.h:317; RooAbsReal::CountErrors@ CountErrorsDefinition RooAbsReal.h:317; RooAbsReal::CollectErrors@ CollectErrorsDefinition RooAbsReal.h:317; RooAbsReal::PrintErrors@ PrintErrorsDe",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:47103,Modifiability,variab,variable,47103,"al.h:216; RooAbsReal::momentRooAbsMoment * moment(RooRealVar &obs, Int_t order, bool central, bool takeRoot)Return function representing moment of function of given order.Definition RooAbsReal.cxx:4015; RooAbsReal::buildCallToAnalyticIntegralvirtual std::string buildCallToAnalyticIntegral(Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) constThis function defines the analytical integral translation for the class.Definition RooAbsReal.cxx:4425; RooAbsReal::plotOnWithErrorBandRooPlot * plotOnWithErrorBand(RooPlot *frame, const RooFitResult &fr, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) constPlot function or PDF on frame with support for visualization of the uncertainty encoded in the given ...Definition RooAbsReal.cxx:2601; RooAbsReal::_lastNormSetIdRooFit::UniqueId< RooArgSet >::Value_t _lastNormSetIdComponent selection flag for RooAbsPdf::plotCompOn.Definition RooAbsReal.h:543; RooAbsReal::getPlotLabelconst char * getPlotLabel() constGet the label associated with the variable.Definition RooAbsReal.cxx:406; RooAbsReal::forceNumIntvirtual void forceNumInt(bool flag=true)Definition RooAbsReal.h:169; RooAbsReal::createRunningIntegralRooFit::OwningPtr< RooAbsReal > createRunningIntegral(const RooArgSet &iset, const RooArgSet &nset={})Calls createRunningIntegral(const RooArgSet&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&,...Definition RooAbsReal.cxx:3706; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooNumIntConfig &cfg, const char *rangeName=nullptr) constCreate integral over observables in iset in range named rangeName using specified configuration for a...Definition RooAbsReal.h:220; RooAbsReal::_specIntegratorConfigstd::unique_ptr< RooNumIntConfig > _specIntegratorConfigDefinition RooAbsReal.h:540; RooAbsReal::getAnalyticalIntegralvirtual Int_t getAnalyticalIntegral(RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) con",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:47746,Modifiability,config,configuration,47746,"r, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) constPlot function or PDF on frame with support for visualization of the uncertainty encoded in the given ...Definition RooAbsReal.cxx:2601; RooAbsReal::_lastNormSetIdRooFit::UniqueId< RooArgSet >::Value_t _lastNormSetIdComponent selection flag for RooAbsPdf::plotCompOn.Definition RooAbsReal.h:543; RooAbsReal::getPlotLabelconst char * getPlotLabel() constGet the label associated with the variable.Definition RooAbsReal.cxx:406; RooAbsReal::forceNumIntvirtual void forceNumInt(bool flag=true)Definition RooAbsReal.h:169; RooAbsReal::createRunningIntegralRooFit::OwningPtr< RooAbsReal > createRunningIntegral(const RooArgSet &iset, const RooArgSet &nset={})Calls createRunningIntegral(const RooArgSet&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&,...Definition RooAbsReal.cxx:3706; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooNumIntConfig &cfg, const char *rangeName=nullptr) constCreate integral over observables in iset in range named rangeName using specified configuration for a...Definition RooAbsReal.h:220; RooAbsReal::_specIntegratorConfigstd::unique_ptr< RooNumIntConfig > _specIntegratorConfigDefinition RooAbsReal.h:540; RooAbsReal::getAnalyticalIntegralvirtual Int_t getAnalyticalIntegral(RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) constInterface function getAnalyticalIntergral advertises the analytical integrals that are supported.Definition RooAbsReal.cxx:368; RooAbsReal::evalErrorIterstatic std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter()Definition RooAbsReal.cxx:181; RooAbsReal::numEvalErrorsstatic Int_t numEvalErrors()Return the number of logged evaluation errors since the last clearing.Definition RooAbsReal.cxx:3624; RooAbsReal::setEvalErrorLoggingModestatic void setEvalErrorLoggingMode(ErrorLoggingMode m)Set evaluation er",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:50006,Modifiability,variab,variable,50006,"ables for scanning t...Definition RooAbsReal.cxx:3694; RooAbsReal::maxValvirtual double maxVal(Int_t code) constReturn maximum value for set of observables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive integrals over functions ...Definition RooAbsReal.cxx:701; RooAbsReal::integralNameSuffixTString integralNameSuffix(const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::isBinnedDistributionvirtual bool isBinnedDistribution(const RooArgSet &) constTests if the distribution is binned. Unless overridden by derived classes, this always returns false.Definition RooAbsReal.h:346; RooAbsReal::printE",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:50674,Modifiability,config,configuration,50674,"itEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::isBinnedDistributionvirtual bool isBinnedDistribution(const RooArgSet &) constTests if the distribution is binned. Unless overridden by derived classes, this always returns false.Definition RooAbsReal.h:346; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsReal.cxx:3827; RooAbsReal::enableOffsettingvirtual void enableOffsetting(bool)Definition RooAbsReal.cxx:4484; RooAbsReal::clearEvalErrorLogstatic void clearEvalErrorLog()Clear the stack of evaluation error messages.Definition RooAbsReal.cxx:3542; RooAbsReal::createIntObjRooFit::OwningPtr",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:53161,Modifiability,variab,variable,53161,"gSet()) constReturn a RooFunctor object bound to this RooAbsReal with given definition of observables and paramete...Definition RooAbsReal.cxx:3887; RooAbsReal::setCachedValuevoid setCachedValue(double value, bool notifyClients=true) finalOverwrite the value stored in this object's cache.Definition RooAbsReal.h:558; RooAbsReal::_plotBinsInt_t _plotBinsNumber of plot bins.Definition RooAbsReal.h:535; RooAbsReal::createPlotProjectionconst RooAbsReal * createPlotProjection(const RooArgSet &depVars, const RooArgSet &projVars, RooArgSet *&cloneSet) constUtility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a Roo...Definition RooAbsReal.cxx:787; RooAbsReal::plotSamplingHintvirtual std::list< double > * plotSamplingHint(RooAbsRealLValue &obs, double xlo, double xhi) constInterface for returning an optional hint for initial sampling points when constructing a curve projec...Definition RooAbsReal.cxx:3571; RooAbsReal::setPlotLabelvoid setPlotLabel(const char *label)Set the label associated with this variable.Definition RooAbsReal.cxx:416; RooAbsReal::plotOnvirtual RooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) constPlot (project) PDF on specified frame.Definition RooAbsReal.cxx:1611; RooAbsReal::doEvalvirtual void doEval(RooFit::EvalContext &) constBase function for computing multiple values of a RooAbsReal.Definition RooAbsReal.cxx:4343; RooAbsReal::makeProjectionSetvoid makeProjectionSet(const RooAbsArg *plotVar, const RooArgSet *allVars, RooArgSet &projectedVars, bool silent) constUtility function for plotOn() that constructs the set of observables to project when plotting ourselv...Definition RooAbsReal.cxx:2903; RooAbsReal::getMaxValvirtual Int_t getMaxVal(const RooArgSet &vars) constAd",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:56287,Modifiability,adapt,adaptor,56287,"ontainer object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooCmdArgNamed container for two doubles, two integers two object points and three string pointers that can be...Definition RooCmdArg.h:26; RooCurve::WingModeWingModeDefinition RooCurve.h:39; RooCurve::Extended@ ExtendedDefinition RooCurve.h:39; RooDataHistContainer class to hold N-dimensional binned data.Definition RooDataHist.h:40; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDerivativeRepresents the first, second, or third order derivative of any RooAbsReal as calculated (numerically)...Definition RooDerivative.h:30; RooFitResultRooFitResult is a container class to hold the input and output of a PDF fit to a dataset.Definition RooFitResult.h:40; RooFit::Detail::CodeSquashContextA class to maintain the context for squashing of RooFit models into code.Definition CodeSquashContext.h:42; RooFit::EvalContextDefinition EvalContext.h:84; RooFunctorLightweight interface adaptor that exports a RooAbsPdf as a functor.Definition RooFunctor.h:25; RooLinkedListCollection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list...Definition RooLinkedList.h:44; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooRealBindingLightweight interface adaptor that binds a RooAbsReal object to a subset of its servers and present i...Definition RooRealBinding.h:30; RooRealSumFuncDefinition RooRealSumFunc.h:26; RooRealSumPdfImplements a PDF constructed from a sum of functions:Definition RooRealSumPdf.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooStringViewThe RooStringView is a wrapper around a C-style string that can also be constructed from a std::strin...Definition RooStringView.h:27; RooVectorDataStor",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:56534,Modifiability,config,configuration,56534,".h:39; RooCurve::Extended@ ExtendedDefinition RooCurve.h:39; RooDataHistContainer class to hold N-dimensional binned data.Definition RooDataHist.h:40; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDerivativeRepresents the first, second, or third order derivative of any RooAbsReal as calculated (numerically)...Definition RooDerivative.h:30; RooFitResultRooFitResult is a container class to hold the input and output of a PDF fit to a dataset.Definition RooFitResult.h:40; RooFit::Detail::CodeSquashContextA class to maintain the context for squashing of RooFit models into code.Definition CodeSquashContext.h:42; RooFit::EvalContextDefinition EvalContext.h:84; RooFunctorLightweight interface adaptor that exports a RooAbsPdf as a functor.Definition RooFunctor.h:25; RooLinkedListCollection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list...Definition RooLinkedList.h:44; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooRealBindingLightweight interface adaptor that binds a RooAbsReal object to a subset of its servers and present i...Definition RooRealBinding.h:30; RooRealSumFuncDefinition RooRealSumFunc.h:26; RooRealSumPdfImplements a PDF constructed from a sum of functions:Definition RooRealSumPdf.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooStringViewThe RooStringView is a wrapper around a C-style string that can also be constructed from a std::strin...Definition RooStringView.h:27; RooVectorDataStoreUses std::vector to store data columns.Definition RooVectorDataStore.h:41; TF11-Dim function classDefinition TF1.h:233; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Def",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:56785,Modifiability,adapt,adaptor,56785,"esents the first, second, or third order derivative of any RooAbsReal as calculated (numerically)...Definition RooDerivative.h:30; RooFitResultRooFitResult is a container class to hold the input and output of a PDF fit to a dataset.Definition RooFitResult.h:40; RooFit::Detail::CodeSquashContextA class to maintain the context for squashing of RooFit models into code.Definition CodeSquashContext.h:42; RooFit::EvalContextDefinition EvalContext.h:84; RooFunctorLightweight interface adaptor that exports a RooAbsPdf as a functor.Definition RooFunctor.h:25; RooLinkedListCollection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list...Definition RooLinkedList.h:44; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooRealBindingLightweight interface adaptor that binds a RooAbsReal object to a subset of its servers and present i...Definition RooRealBinding.h:30; RooRealSumFuncDefinition RooRealSumFunc.h:26; RooRealSumPdfImplements a PDF constructed from a sum of functions:Definition RooRealSumPdf.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooStringViewThe RooStringView is a wrapper around a C-style string that can also be constructed from a std::strin...Definition RooStringView.h:27; RooVectorDataStoreUses std::vector to store data columns.Definition RooVectorDataStore.h:41; TF11-Dim function classDefinition TF1.h:233; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH3F3-D histogram with a float per channel (see TH1 documentation)Definition TH3.h:317; TListA doubly linked list.Definition TList.h:38; ",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:61186,Modifiability,enhance,enhance,61186,rogressbool progressDefinition RooAbsReal.h:490; RooAbsReal::PlotOpt::doeevalbool doeevalDefinition RooAbsReal.h:489; RooAbsReal::PlotOpt::addToWgtSelfdouble addToWgtSelfDefinition RooAbsReal.h:482; RooAbsReal::PlotOpt::shiftToZerobool shiftToZeroDefinition RooAbsReal.h:471; RooAbsReal::PlotOpt::projDataSetconst RooArgSet * projDataSetDefinition RooAbsReal.h:472; RooAbsReal::PlotOpt::binProjDatabool binProjDataDefinition RooAbsReal.h:468; RooAbsReal::PlotOpt::stypeScaleType stypeDefinition RooAbsReal.h:466; RooAbsReal::PlotOpt::curveNameSuffixconst char * curveNameSuffixDefinition RooAbsReal.h:486; RooAbsReal::PlotOpt::addToCurveNameconst char * addToCurveNameDefinition RooAbsReal.h:481; RooAbsReal::PlotOpt::numeeInt_t numeeDefinition RooAbsReal.h:487; RooAbsReal::PlotOpt::errorFRconst RooFitResult * errorFRDefinition RooAbsReal.h:491; RooAbsReal::PlotOpt::rangeHidouble rangeHiDefinition RooAbsReal.h:475; RooAbsReal::PlotOpt::numCPUInt_t numCPUDefinition RooAbsReal.h:484; RooAbsReal::PlotOpt::projSetconst RooArgSet * projSetDefinition RooAbsReal.h:469; RooAbsReal::PlotOpt::postRangeFracScalebool postRangeFracScaleDefinition RooAbsReal.h:476; RooAbsReal::PlotOpt::curveInvisiblebool curveInvisibleDefinition RooAbsReal.h:479; RooAbsReal::PlotOpt::curveNameconst char * curveNameDefinition RooAbsReal.h:480; RooAbsReal::PlotOpt::projDataconst RooAbsData * projDataDefinition RooAbsReal.h:467; RooAbsReal::PlotOpt::drawOptionsOption_t * drawOptionsDefinition RooAbsReal.h:464; RooAbsReal::PlotOpt::rangeLodouble rangeLoDefinition RooAbsReal.h:474; RooFit::UniqueIdA UniqueId can be added as a class member to enhance any class with a unique identifier for each inst...Definition UniqueId.h:39; RooFit::UniqueId::Value_tunsigned long Value_tDefinition UniqueId.h:41; TreeReadBufferDefinition TreeReadBuffer.h:18; mTMarker mDefinition textangle.C:8. roofitroofitcoreincRooAbsReal.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:50 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:3069,Performance,cache,cached,3069,"ill be implicitly converted to a RooConstVar&. The RooAbsReal::Ref; 65 /// can be used as a replacement for `RooAbsReal&`. With this type; 66 /// definition, you can write RooFit interfaces that accept both RooAbsReal,; 67 /// or simply a number that will be implicitly converted to a RooConstVar&.; 68 class Ref {; 69 public:; 70 inline Ref(RooAbsReal &ref) : _ref{ref} {}; 71 Ref(double val);; 72 inline operator RooAbsReal &() const { return _ref; }; 73 ; 74 private:; 75 RooAbsReal &_ref;; 76 };; 77 ; 78 // Constructors, assignment etc; 79 RooAbsReal() ;; 80 RooAbsReal(const char *name, const char *title, const char *unit= """") ;; 81 RooAbsReal(const char *name, const char *title, double minVal, double maxVal,; 82 const char *unit= """") ;; 83 RooAbsReal(const RooAbsReal& other, const char* name=nullptr);; 84 ~RooAbsReal() override;; 85 ; 86 ; 87 ; 88 ; 89 //////////////////////////////////////////////////////////////////////////////////; 90 /// Evaluate object. Returns either cached value or triggers a recalculation.; 91 /// The recalculation happens by calling getValV(), which in the end calls the; 92 /// virtual evaluate() functions of the respective PDFs.; 93 /// \param[in] normalisationSet getValV() reacts differently depending on the value of the normalisation set.; 94 /// If the set is `nullptr`, an unnormalised value is returned.; 95 /// \note The normalisation is arbitrary, because it is up to the implementation; 96 /// of the PDF to e.g. leave out normalisation constants for speed reasons. The range; 97 /// of the variables is also ignored.; 98 ///; 99 /// To normalise the result properly, a RooArgSet has to be passed, which contains; 100 /// the variables to normalise over.; 101 /// These are integrated over their current ranges to compute the normalisation constant,; 102 /// and the unnormalised result is divided by this value.; 103 inline double getVal(const RooArgSet* normalisationSet = nullptr) const {; 104 // Sometimes, the calling code uses an empty RooA",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:26997,Performance,cache,cache,26997,"tate;; 521 };; 522 ; 523 ; 524private:; 525 ; 526 /// Debug version of getVal(), which is slow and does error checking.; 527 double _DEBUG_getVal(const RooArgSet* normalisationSet) const;; 528 ; 529 //--------------------------------------------------------------------; 530 ; 531 protected:; 532 ; 533 double _plotMin = 0.0; ///< Minimum of plot range; 534 double _plotMax = 0.0; ///< Maximum of plot range; 535 Int_t _plotBins = 100; ///< Number of plot bins; 536 mutable double _value = 0.0; ///< Cache for current value of object; 537 TString _unit; ///< Unit for objects value; 538 TString _label; ///< Plot label for objects value; 539 bool _forceNumInt = false; ///< Force numerical integration if flag set; 540 std::unique_ptr<RooNumIntConfig> _specIntegratorConfig; // Numeric integrator configuration specific for this object; 541 TreeReadBuffer *_treeReadBuffer = nullptr; //! A buffer for reading values from trees; 542 bool _selectComp = true; //! Component selection flag for RooAbsPdf::plotCompOn; 543 mutable RooFit::UniqueId<RooArgSet>::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval; ///<!; 544 ; 545 static bool _globalSelectComp; // Global activation switch for component selection; 546 static bool _hideOffset; ///< Offset hiding flag; 547 ; 548 ClassDefOverride(RooAbsReal,3); // Abstract real-valued variable; 549};; 550 ; 551 ; 552////////////////////////////////////////////////////////////////////////////////; 553/// Overwrite the value stored in this object's cache.; 554/// This can be used to fake a computation that resulted in `value`.; 555/// \param[in] value Value to write.; 556/// \param[in] notifyClients If true, notify users of this object that its value changed.; 557/// This is the default.; 558void RooAbsReal::setCachedValue(double value, bool notifyClients) {; 559 _value = value;; 560 ; 561 if (notifyClients) {; 562 setValueDirty();; 563 _valueDirty = false;; 564 }; 565}; 566 ; 567 ; 568#endif; CodeSquashContext.h; EvalContext.h; d#define",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:29742,Performance,perform,performing,29742,"nt a value and a ""shape"" in RooFit.Definition RooAbsArg.h:79; RooAbsArg::_fastbool _fastDefinition RooAbsArg.h:689; RooAbsArg::_valueDirtybool _valueDirtyDefinition RooAbsArg.h:685; RooAbsArg::setValueDirtyvoid setValueDirty()Mark the element dirty. This forces a re-evaluation when a value is requested.Definition RooAbsArg.h:462; RooAbsArg::inhibitDirtybool inhibitDirty() constDelete watch flag.Definition RooAbsArg.cxx:105; RooAbsArg::_inhibitDirtystatic bool _inhibitDirtyDefinition RooAbsArg.h:668; RooAbsCategoryLValueAbstract base class for objects that represent a discrete value that can be set from the outside,...Definition RooAbsCategoryLValue.h:26; RooAbsCollectionAbstract container object that can hold multiple RooAbsArg objects.Definition RooAbsCollection.h:65; RooAbsCollection::emptybool empty() constDefinition RooAbsCollection.h:273; RooAbsDataAbstract base class for binned and unbinned datasets.Definition RooAbsData.h:57; RooAbsFuncAbstract interface for evaluating a real-valued function of one real variable and performing numerica...Definition RooAbsFunc.h:27; RooAbsMomentDefinition RooAbsMoment.h:27; RooAbsRealLValueAbstract base class for objects that represent a real value that may appear on the left hand side of ...Definition RooAbsRealLValue.h:31; RooAbsReal::EvalErrorContextContext to temporarily change the error logging mode as long as the context is alive.Definition RooAbsReal.h:320; RooAbsReal::EvalErrorContext::~EvalErrorContext~EvalErrorContext()Definition RooAbsReal.h:329; RooAbsReal::EvalErrorContext::EvalErrorContextEvalErrorContext(ErrorLoggingMode m)Definition RooAbsReal.h:322; RooAbsReal::EvalErrorContext::operator=EvalErrorContext & operator=(EvalErrorContext const &)=delete; RooAbsReal::EvalErrorContext::_oldErrorLoggingMode _oldDefinition RooAbsReal.h:331; RooAbsReal::EvalErrorContext::operator=EvalErrorContext & operator=(EvalErrorContext &&)=delete; RooAbsReal::EvalErrorContext::EvalErrorContextEvalErrorContext(EvalErrorContext cons",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:37770,Performance,perform,perform,37770,"ArgSet &iset, const RooArgSet &nset, Int_t numScanBins, Int_t intOrder)Utility function for createRunningIntegral that construct an object implementing the numeric scanning...Definition RooAbsReal.cxx:3810; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const char *rangeName) constCreate integral over observables in iset in range named rangeName.Definition RooAbsReal.h:207; RooAbsReal::defaultErrorLevelvirtual double defaultErrorLevel() constDefinition RooAbsReal.h:248; RooAbsReal::_DEBUG_getValdouble _DEBUG_getVal(const RooArgSet *normalisationSet) constDebug version of getVal(), which is slow and does error checking.Definition RooAbsReal.cxx:4434; RooAbsReal::createFundamentalRooFit::OwningPtr< RooAbsArg > createFundamental(const char *newname=nullptr) const overrideCreate a RooRealVar fundamental object with our properties.Definition RooAbsReal.cxx:3130; RooAbsReal::plotSanityChecksbool plotSanityChecks(RooPlot *frame) constUtility function for plotOn(), perform general sanity check on frame to ensure safe plotting operatio...Definition RooAbsReal.cxx:2860; RooAbsReal::bindVarsRooFit::OwningPtr< RooAbsFunc > bindVars(const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) constCreate an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order).Definition RooAbsReal.cxx:2980; RooAbsReal::selectNormalizationvirtual void selectNormalization(const RooArgSet *depSet=nullptr, bool force=false)Interface function to force use of a given set of observables to interpret function value.Definition RooAbsReal.cxx:3360; RooAbsReal::derivativeRooDerivative * derivative(RooRealVar &obs, Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:43187,Performance,cache,cached,43187,"const overridePrint object value.Definition RooAbsReal.cxx:445; RooAbsReal::forceAnalyticalIntvirtual bool forceAnalyticalInt(const RooAbsArg &) constDefinition RooAbsReal.h:164; RooAbsReal::isIdenticalbool isIdentical(const RooAbsArg &other, bool assumeSameType=false) const overrideDefinition RooAbsReal.cxx:270; RooAbsReal::setUnitvoid setUnit(const char *unit)Definition RooAbsReal.h:147; RooAbsReal::getForceNumIntbool getForceNumInt() constDefinition RooAbsReal.h:174; RooAbsReal::createProfilevirtual RooFit::OwningPtr< RooAbsReal > createProfile(const RooArgSet &paramsOfInterest)Create a RooProfileLL object that eliminates all nuisance parameters in the present function.Definition RooAbsReal.cxx:471; RooAbsReal::_hideOffsetstatic bool _hideOffsetOffset hiding flag.Definition RooAbsReal.h:546; RooAbsReal::attachToVStorevoid attachToVStore(RooVectorDataStore &vstore) overrideDefinition RooAbsReal.cxx:3012; RooAbsReal::copyCachevoid copyCache(const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) overrideCopy the cached value of another RooAbsArg to our cache.Definition RooAbsReal.cxx:2997; RooAbsReal::gradientvirtual void gradient(double *) constDefinition RooAbsReal.h:388; RooAbsReal::createHistogramTH1 * createHistogram(RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) constCreate and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables w...Definition RooAbsReal.cxx:1183; RooAbsReal::fixAddCoefRangevirtual void fixAddCoefRange(const char *rangeName=nullptr, bool force=true)Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by...Definition RooAbsReal.cxx:3675; RooAbsReal::_valuedouble _valueCache for current value of object.Definition RooAbsReal.h:536; RooAbsReal::analyticalIntegralvirtual double analyticalIntegral(Int_t code, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Defi",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:43228,Performance,cache,cache,43228,"const overridePrint object value.Definition RooAbsReal.cxx:445; RooAbsReal::forceAnalyticalIntvirtual bool forceAnalyticalInt(const RooAbsArg &) constDefinition RooAbsReal.h:164; RooAbsReal::isIdenticalbool isIdentical(const RooAbsArg &other, bool assumeSameType=false) const overrideDefinition RooAbsReal.cxx:270; RooAbsReal::setUnitvoid setUnit(const char *unit)Definition RooAbsReal.h:147; RooAbsReal::getForceNumIntbool getForceNumInt() constDefinition RooAbsReal.h:174; RooAbsReal::createProfilevirtual RooFit::OwningPtr< RooAbsReal > createProfile(const RooArgSet &paramsOfInterest)Create a RooProfileLL object that eliminates all nuisance parameters in the present function.Definition RooAbsReal.cxx:471; RooAbsReal::_hideOffsetstatic bool _hideOffsetOffset hiding flag.Definition RooAbsReal.h:546; RooAbsReal::attachToVStorevoid attachToVStore(RooVectorDataStore &vstore) overrideDefinition RooAbsReal.cxx:3012; RooAbsReal::copyCachevoid copyCache(const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) overrideCopy the cached value of another RooAbsArg to our cache.Definition RooAbsReal.cxx:2997; RooAbsReal::gradientvirtual void gradient(double *) constDefinition RooAbsReal.h:388; RooAbsReal::createHistogramTH1 * createHistogram(RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) constCreate and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables w...Definition RooAbsReal.cxx:1183; RooAbsReal::fixAddCoefRangevirtual void fixAddCoefRange(const char *rangeName=nullptr, bool force=true)Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by...Definition RooAbsReal.cxx:3675; RooAbsReal::_valuedouble _valueCache for current value of object.Definition RooAbsReal.h:536; RooAbsReal::analyticalIntegralvirtual double analyticalIntegral(Int_t code, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Defi",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:52396,Performance,cache,cache,52396,"Definition RooAbsReal.cxx:3827; RooAbsReal::enableOffsettingvirtual void enableOffsetting(bool)Definition RooAbsReal.cxx:4484; RooAbsReal::clearEvalErrorLogstatic void clearEvalErrorLog()Clear the stack of evaluation error messages.Definition RooAbsReal.cxx:3542; RooAbsReal::createIntObjRooFit::OwningPtr< RooAbsReal > createIntObj(const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) constInternal utility function for createIntegral() that creates the actual integral object.Definition RooAbsReal.cxx:590; RooAbsReal::sigmaRooAbsMoment * sigma(RooRealVar &obs, const RooArgSet &nset)Definition RooAbsReal.h:362; RooAbsReal::functorRooFunctor * functor(const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) constReturn a RooFunctor object bound to this RooAbsReal with given definition of observables and paramete...Definition RooAbsReal.cxx:3887; RooAbsReal::setCachedValuevoid setCachedValue(double value, bool notifyClients=true) finalOverwrite the value stored in this object's cache.Definition RooAbsReal.h:558; RooAbsReal::_plotBinsInt_t _plotBinsNumber of plot bins.Definition RooAbsReal.h:535; RooAbsReal::createPlotProjectionconst RooAbsReal * createPlotProjection(const RooArgSet &depVars, const RooArgSet &projVars, RooArgSet *&cloneSet) constUtility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a Roo...Definition RooAbsReal.cxx:787; RooAbsReal::plotSamplingHintvirtual std::list< double > * plotSamplingHint(RooAbsRealLValue &obs, double xlo, double xhi) constInterface for returning an optional hint for initial sampling points when constructing a curve projec...Definition RooAbsReal.cxx:3571; RooAbsReal::setPlotLabelvoid setPlotLabel(const char *label)Set the label associated with this variable.Definition RooAbsReal.cxx:416; RooAbsReal::plotOnvirtual RooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:7157,Safety,unsafe,unsafe,7157," const override;; 141 ; 142 ; 143 inline const Text_t *getUnit() const {; 144 // Return string with unit description; 145 return _unit.Data();; 146 }; 147 inline void setUnit(const char *unit) {; 148 // Set unit description to given string; 149 _unit= unit;; 150 }; 151 TString getTitle(bool appendUnit= false) const;; 152 ; 153 // Lightweight interface adaptors (caller takes ownership); 154 RooFit::OwningPtr<RooAbsFunc> bindVars(const RooArgSet &vars, const RooArgSet* nset=nullptr, bool clipInvalid=false) const;; 155 ; 156 // Create a fundamental-type object that can hold our value.; 157 RooFit::OwningPtr<RooAbsArg> createFundamental(const char* newname=nullptr) const override;; 158 ; 159 // Analytical integration support; 160 virtual Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 161 virtual double analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName=nullptr) const ;; 162 virtual Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName=nullptr) const ;; 163 virtual double analyticalIntegral(Int_t code, const char* rangeName=nullptr) const ;; 164 virtual bool forceAnalyticalInt(const RooAbsArg& /*dep*/) const {; 165 // Interface to force RooRealIntegral to offer given observable for internal integration; 166 // even if this is deemed unsafe. This default implementation returns always false; 167 return false ;; 168 }; 169 virtual void forceNumInt(bool flag=true) {; 170 // If flag is true, all advertised analytical integrals will be ignored; 171 // and all integrals are calculated numerically; 172 _forceNumInt = flag ;; 173 }; 174 bool getForceNumInt() const { return _forceNumInt ; }; 175 ; 176 // Chi^2 fits to histograms; 177 virtual RooFit::OwningPtr<RooFitResult> chi2FitTo(RooDataHist& data, const RooCmdArg& arg1={}, const RooCmdArg& arg2={},; 178 const RooCmdArg& arg3={}, const RooCmdArg& arg4={}, const RooCmdArg& a",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:37786,Safety,sanity check,sanity check,37786,"ArgSet &iset, const RooArgSet &nset, Int_t numScanBins, Int_t intOrder)Utility function for createRunningIntegral that construct an object implementing the numeric scanning...Definition RooAbsReal.cxx:3810; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const char *rangeName) constCreate integral over observables in iset in range named rangeName.Definition RooAbsReal.h:207; RooAbsReal::defaultErrorLevelvirtual double defaultErrorLevel() constDefinition RooAbsReal.h:248; RooAbsReal::_DEBUG_getValdouble _DEBUG_getVal(const RooArgSet *normalisationSet) constDebug version of getVal(), which is slow and does error checking.Definition RooAbsReal.cxx:4434; RooAbsReal::createFundamentalRooFit::OwningPtr< RooAbsArg > createFundamental(const char *newname=nullptr) const overrideCreate a RooRealVar fundamental object with our properties.Definition RooAbsReal.cxx:3130; RooAbsReal::plotSanityChecksbool plotSanityChecks(RooPlot *frame) constUtility function for plotOn(), perform general sanity check on frame to ensure safe plotting operatio...Definition RooAbsReal.cxx:2860; RooAbsReal::bindVarsRooFit::OwningPtr< RooAbsFunc > bindVars(const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) constCreate an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order).Definition RooAbsReal.cxx:2980; RooAbsReal::selectNormalizationvirtual void selectNormalization(const RooArgSet *depSet=nullptr, bool force=false)Interface function to force use of a given set of observables to interpret function value.Definition RooAbsReal.cxx:3360; RooAbsReal::derivativeRooDerivative * derivative(RooRealVar &obs, Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:37818,Safety,safe,safe,37818,"ArgSet &iset, const RooArgSet &nset, Int_t numScanBins, Int_t intOrder)Utility function for createRunningIntegral that construct an object implementing the numeric scanning...Definition RooAbsReal.cxx:3810; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const char *rangeName) constCreate integral over observables in iset in range named rangeName.Definition RooAbsReal.h:207; RooAbsReal::defaultErrorLevelvirtual double defaultErrorLevel() constDefinition RooAbsReal.h:248; RooAbsReal::_DEBUG_getValdouble _DEBUG_getVal(const RooArgSet *normalisationSet) constDebug version of getVal(), which is slow and does error checking.Definition RooAbsReal.cxx:4434; RooAbsReal::createFundamentalRooFit::OwningPtr< RooAbsArg > createFundamental(const char *newname=nullptr) const overrideCreate a RooRealVar fundamental object with our properties.Definition RooAbsReal.cxx:3130; RooAbsReal::plotSanityChecksbool plotSanityChecks(RooPlot *frame) constUtility function for plotOn(), perform general sanity check on frame to ensure safe plotting operatio...Definition RooAbsReal.cxx:2860; RooAbsReal::bindVarsRooFit::OwningPtr< RooAbsFunc > bindVars(const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) constCreate an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order).Definition RooAbsReal.cxx:2980; RooAbsReal::selectNormalizationvirtual void selectNormalization(const RooArgSet *depSet=nullptr, bool force=false)Interface function to force use of a given set of observables to interpret function value.Definition RooAbsReal.cxx:3360; RooAbsReal::derivativeRooDerivative * derivative(RooRealVar &obs, Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:15156,Testability,log,logging,15156,"onst RooCmdArg& arg4={},; 270 const RooCmdArg& arg5={}, const RooCmdArg& arg6={},; 271 const RooCmdArg& arg7={}, const RooCmdArg& arg8={},; 272 const RooCmdArg& arg9={}, const RooCmdArg& arg10={}; 273 ) const ;; 274 ; 275 ; 276 enum ScaleType { Raw, Relative, NumEvent, RelativeExpected } ;; 277 ; 278 // Fill an existing histogram; 279 TH1 *fillHistogram(TH1 *hist, const RooArgList &plotVars,; 280 double scaleFactor= 1, const RooArgSet *projectedVars= nullptr, bool scaling=true,; 281 const RooArgSet* condObs=nullptr, bool setError=true) const;; 282 ; 283 // Create 1,2, and 3D histograms from and fill it; 284 TH1 *createHistogram(RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) const ;; 285 TH1* createHistogram(const char *name, const RooAbsRealLValue& xvar, RooLinkedList& argList) const ;; 286 TH1 *createHistogram(const char *name, const RooAbsRealLValue& xvar,; 287 const RooCmdArg& arg1={}, const RooCmdArg& arg2={},; 288 const RooCmdArg& arg3={}, const RooCmdArg& arg4={},; 289 const RooCmdArg& arg5={}, const RooCmdArg& arg6={},; 290 const RooCmdArg& arg7={}, const RooCmdArg& arg8={}) const ;; 291 ; 292 // Fill a RooDataHist; 293 RooDataHist* fillDataHist(RooDataHist *hist, const RooArgSet* nset, double scaleFactor,; 294 bool correctForBinVolume=false, bool showProgress=false) const ;; 295 ; 296 // I/O streaming interface (machine readable); 297 bool readFromStream(std::istream& is, bool compact, bool verbose=false) override ;; 298 void writeToStream(std::ostream& os, bool compact) const override ;; 299 ; 300 // Printing interface (human readable); 301 void printValue(std::ostream& os) const override ;; 302 void printMultiline(std::ostream& os, Int_t contents, bool verbose=false, TString indent="""") const override ;; 303 ; 304 inline void setCachedValue(double value, bool notifyClients = true) final;; 305 ; 306 // Evaluation error logging; 307 class EvalError {; 308 public:; 309 EvalError() { }; 310 EvalError(const EvalError& other) : _msg(other.",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:15667,Testability,log,logging,15667,"ess=false) const ;; 295 ; 296 // I/O streaming interface (machine readable); 297 bool readFromStream(std::istream& is, bool compact, bool verbose=false) override ;; 298 void writeToStream(std::ostream& os, bool compact) const override ;; 299 ; 300 // Printing interface (human readable); 301 void printValue(std::ostream& os) const override ;; 302 void printMultiline(std::ostream& os, Int_t contents, bool verbose=false, TString indent="""") const override ;; 303 ; 304 inline void setCachedValue(double value, bool notifyClients = true) final;; 305 ; 306 // Evaluation error logging; 307 class EvalError {; 308 public:; 309 EvalError() { }; 310 EvalError(const EvalError& other) : _msg(other._msg), _srvval(other._srvval) { }; 311 void setMessage(const char* tmp) { std::string s(tmp); s.swap(_msg); }; 312 void setServerValues(const char* tmp) { std::string s(tmp); s.swap(_srvval); }; 313 std::string _msg;; 314 std::string _srvval;; 315 } ;; 316 ; 317 enum ErrorLoggingMode { PrintErrors, CollectErrors, CountErrors, Ignore } ;; 318 ; 319 /// Context to temporarily change the error logging mode as long as the context is alive.; 320 class EvalErrorContext {; 321 public:; 322 EvalErrorContext(ErrorLoggingMode m) : _old{evalErrorLoggingMode()} { setEvalErrorLoggingMode(m); }; 323 ; 324 EvalErrorContext(EvalErrorContext const&) = delete;; 325 EvalErrorContext(EvalErrorContext &&) = delete;; 326 EvalErrorContext& operator=(EvalErrorContext const&) = delete;; 327 EvalErrorContext& operator=(EvalErrorContext &&) = delete;; 328 ; 329 ~EvalErrorContext() { setEvalErrorLoggingMode(_old); }; 330 private:; 331 ErrorLoggingMode _old;; 332 };; 333 ; 334 static ErrorLoggingMode evalErrorLoggingMode() ;; 335 static void setEvalErrorLoggingMode(ErrorLoggingMode m) ;; 336 void logEvalError(const char* message, const char* serverValueString=nullptr) const ;; 337 static void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString=nullptr) ",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:16358,Testability,log,logEvalError,16358,"tmp) { std::string s(tmp); s.swap(_msg); }; 312 void setServerValues(const char* tmp) { std::string s(tmp); s.swap(_srvval); }; 313 std::string _msg;; 314 std::string _srvval;; 315 } ;; 316 ; 317 enum ErrorLoggingMode { PrintErrors, CollectErrors, CountErrors, Ignore } ;; 318 ; 319 /// Context to temporarily change the error logging mode as long as the context is alive.; 320 class EvalErrorContext {; 321 public:; 322 EvalErrorContext(ErrorLoggingMode m) : _old{evalErrorLoggingMode()} { setEvalErrorLoggingMode(m); }; 323 ; 324 EvalErrorContext(EvalErrorContext const&) = delete;; 325 EvalErrorContext(EvalErrorContext &&) = delete;; 326 EvalErrorContext& operator=(EvalErrorContext const&) = delete;; 327 EvalErrorContext& operator=(EvalErrorContext &&) = delete;; 328 ; 329 ~EvalErrorContext() { setEvalErrorLoggingMode(_old); }; 330 private:; 331 ErrorLoggingMode _old;; 332 };; 333 ; 334 static ErrorLoggingMode evalErrorLoggingMode() ;; 335 static void setEvalErrorLoggingMode(ErrorLoggingMode m) ;; 336 void logEvalError(const char* message, const char* serverValueString=nullptr) const ;; 337 static void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString=nullptr) ;; 338 static void printEvalErrors(std::ostream&os=std::cout, Int_t maxPerNode=10000000) ;; 339 static Int_t numEvalErrors() ;; 340 static Int_t numEvalErrorItems();; 341 static std::map<const RooAbsArg *, std::pair<std::string, std::list<RooAbsReal::EvalError>>>::iterator evalErrorIter();; 342 ; 343 static void clearEvalErrorLog() ;; 344 ; 345 /// Tests if the distribution is binned. Unless overridden by derived classes, this always returns false.; 346 virtual bool isBinnedDistribution(const RooArgSet& /*obs*/) const { return false ; }; 347 virtual std::list<double>* binBoundaries(RooAbsRealLValue& obs, double xlo, double xhi) const;; 348 virtual std::list<double>* plotSamplingHint(RooAbsRealLValue& obs, double xlo, double xhi) const;; 349 ; 350 Ro",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:16456,Testability,log,logEvalError,16456,"tmp) { std::string s(tmp); s.swap(_msg); }; 312 void setServerValues(const char* tmp) { std::string s(tmp); s.swap(_srvval); }; 313 std::string _msg;; 314 std::string _srvval;; 315 } ;; 316 ; 317 enum ErrorLoggingMode { PrintErrors, CollectErrors, CountErrors, Ignore } ;; 318 ; 319 /// Context to temporarily change the error logging mode as long as the context is alive.; 320 class EvalErrorContext {; 321 public:; 322 EvalErrorContext(ErrorLoggingMode m) : _old{evalErrorLoggingMode()} { setEvalErrorLoggingMode(m); }; 323 ; 324 EvalErrorContext(EvalErrorContext const&) = delete;; 325 EvalErrorContext(EvalErrorContext &&) = delete;; 326 EvalErrorContext& operator=(EvalErrorContext const&) = delete;; 327 EvalErrorContext& operator=(EvalErrorContext &&) = delete;; 328 ; 329 ~EvalErrorContext() { setEvalErrorLoggingMode(_old); }; 330 private:; 331 ErrorLoggingMode _old;; 332 };; 333 ; 334 static ErrorLoggingMode evalErrorLoggingMode() ;; 335 static void setEvalErrorLoggingMode(ErrorLoggingMode m) ;; 336 void logEvalError(const char* message, const char* serverValueString=nullptr) const ;; 337 static void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString=nullptr) ;; 338 static void printEvalErrors(std::ostream&os=std::cout, Int_t maxPerNode=10000000) ;; 339 static Int_t numEvalErrors() ;; 340 static Int_t numEvalErrorItems();; 341 static std::map<const RooAbsArg *, std::pair<std::string, std::list<RooAbsReal::EvalError>>>::iterator evalErrorIter();; 342 ; 343 static void clearEvalErrorLog() ;; 344 ; 345 /// Tests if the distribution is binned. Unless overridden by derived classes, this always returns false.; 346 virtual bool isBinnedDistribution(const RooArgSet& /*obs*/) const { return false ; }; 347 virtual std::list<double>* binBoundaries(RooAbsRealLValue& obs, double xlo, double xhi) const;; 348 virtual std::list<double>* plotSamplingHint(RooAbsRealLValue& obs, double xlo, double xhi) const;; 349 ; 350 Ro",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:30056,Testability,log,logging,30056,"Arg::inhibitDirtybool inhibitDirty() constDelete watch flag.Definition RooAbsArg.cxx:105; RooAbsArg::_inhibitDirtystatic bool _inhibitDirtyDefinition RooAbsArg.h:668; RooAbsCategoryLValueAbstract base class for objects that represent a discrete value that can be set from the outside,...Definition RooAbsCategoryLValue.h:26; RooAbsCollectionAbstract container object that can hold multiple RooAbsArg objects.Definition RooAbsCollection.h:65; RooAbsCollection::emptybool empty() constDefinition RooAbsCollection.h:273; RooAbsDataAbstract base class for binned and unbinned datasets.Definition RooAbsData.h:57; RooAbsFuncAbstract interface for evaluating a real-valued function of one real variable and performing numerica...Definition RooAbsFunc.h:27; RooAbsMomentDefinition RooAbsMoment.h:27; RooAbsRealLValueAbstract base class for objects that represent a real value that may appear on the left hand side of ...Definition RooAbsRealLValue.h:31; RooAbsReal::EvalErrorContextContext to temporarily change the error logging mode as long as the context is alive.Definition RooAbsReal.h:320; RooAbsReal::EvalErrorContext::~EvalErrorContext~EvalErrorContext()Definition RooAbsReal.h:329; RooAbsReal::EvalErrorContext::EvalErrorContextEvalErrorContext(ErrorLoggingMode m)Definition RooAbsReal.h:322; RooAbsReal::EvalErrorContext::operator=EvalErrorContext & operator=(EvalErrorContext const &)=delete; RooAbsReal::EvalErrorContext::_oldErrorLoggingMode _oldDefinition RooAbsReal.h:331; RooAbsReal::EvalErrorContext::operator=EvalErrorContext & operator=(EvalErrorContext &&)=delete; RooAbsReal::EvalErrorContext::EvalErrorContextEvalErrorContext(EvalErrorContext const &)=delete; RooAbsReal::EvalErrorContext::EvalErrorContextEvalErrorContext(EvalErrorContext &&)=delete; RooAbsReal::EvalErrorDefinition RooAbsReal.h:307; RooAbsReal::EvalError::setServerValuesvoid setServerValues(const char *tmp)Definition RooAbsReal.h:312; RooAbsReal::EvalError::_srvvalstd::string _srvvalDefinition RooAbsReal.h:314; Ro",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:41188,Testability,log,logging,41188,"oAbsReal.cxx:3146; RooAbsReal::fillTreeBranchvoid fillTreeBranch(TTree &t) overrideFill the tree branch that associated with this object with its current value.Definition RooAbsReal.cxx:3099; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooArgSet &nset, const char *rangeName=nullptr) constCreate integral over observables in iset in range named rangeName with integrand normalized over obse...Definition RooAbsReal.h:211; RooAbsReal::printMultilinevoid printMultiline(std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const overrideStructure printing.Definition RooAbsReal.cxx:455; RooAbsReal::plotAsymOnvirtual RooPlot * plotAsymOn(RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) constDefinition RooAbsReal.cxx:2199; RooAbsReal::operator==bool operator==(double value) constEquality operator comparing to a double.Definition RooAbsReal.cxx:250; RooAbsReal::evalErrorLoggingModestatic ErrorLoggingMode evalErrorLoggingMode()Return current evaluation error logging mode.Definition RooAbsReal.cxx:4302; RooAbsReal::redirectServersHookbool redirectServersHook(const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) overrideFunction that is called at the end of redirectServers().Definition RooAbsReal.cxx:4474; RooAbsReal::minTrialSamplesvirtual Int_t minTrialSamples(const RooArgSet &) constDefinition RooAbsReal.h:241; RooAbsReal::isValidRealvirtual bool isValidReal(double, bool printError=false) constInterface function to check if given value is a valid value for this object. Returns true unless over...Definition RooAbsReal.h:447; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::syncCachevoid syncCache(const RooArgSet *set=nullptr) overrideDefinition RooAbsReal.h:456; RooAbsReal::printValuevoid printValue(std::ostr",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:48442,Testability,log,logged,48442,"CmdArg&, const RooCmdArg&, const RooCmdArg&,...Definition RooAbsReal.cxx:3706; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooNumIntConfig &cfg, const char *rangeName=nullptr) constCreate integral over observables in iset in range named rangeName using specified configuration for a...Definition RooAbsReal.h:220; RooAbsReal::_specIntegratorConfigstd::unique_ptr< RooNumIntConfig > _specIntegratorConfigDefinition RooAbsReal.h:540; RooAbsReal::getAnalyticalIntegralvirtual Int_t getAnalyticalIntegral(RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) constInterface function getAnalyticalIntergral advertises the analytical integrals that are supported.Definition RooAbsReal.cxx:368; RooAbsReal::evalErrorIterstatic std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter()Definition RooAbsReal.cxx:181; RooAbsReal::numEvalErrorsstatic Int_t numEvalErrors()Return the number of logged evaluation errors since the last clearing.Definition RooAbsReal.cxx:3624; RooAbsReal::setEvalErrorLoggingModestatic void setEvalErrorLoggingMode(ErrorLoggingMode m)Set evaluation error logging mode.Definition RooAbsReal.cxx:4316; RooAbsReal::_plotMaxdouble _plotMaxMaximum of plot range.Definition RooAbsReal.h:534; RooAbsReal::preferredObservableScanOrdervirtual void preferredObservableScanOrder(const RooArgSet &obs, RooArgSet &orderedObs) constInterface method for function objects to indicate their preferred order of observables for scanning t...Definition RooAbsReal.cxx:3694; RooAbsReal::maxValvirtual double maxVal(Int_t code) constReturn maximum value for set of observables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive in",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:48634,Testability,log,logging,48634,"st RooArgSet &iset, const RooNumIntConfig &cfg, const char *rangeName=nullptr) constCreate integral over observables in iset in range named rangeName using specified configuration for a...Definition RooAbsReal.h:220; RooAbsReal::_specIntegratorConfigstd::unique_ptr< RooNumIntConfig > _specIntegratorConfigDefinition RooAbsReal.h:540; RooAbsReal::getAnalyticalIntegralvirtual Int_t getAnalyticalIntegral(RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) constInterface function getAnalyticalIntergral advertises the analytical integrals that are supported.Definition RooAbsReal.cxx:368; RooAbsReal::evalErrorIterstatic std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter()Definition RooAbsReal.cxx:181; RooAbsReal::numEvalErrorsstatic Int_t numEvalErrors()Return the number of logged evaluation errors since the last clearing.Definition RooAbsReal.cxx:3624; RooAbsReal::setEvalErrorLoggingModestatic void setEvalErrorLoggingMode(ErrorLoggingMode m)Set evaluation error logging mode.Definition RooAbsReal.cxx:4316; RooAbsReal::_plotMaxdouble _plotMaxMaximum of plot range.Definition RooAbsReal.h:534; RooAbsReal::preferredObservableScanOrdervirtual void preferredObservableScanOrder(const RooArgSet &obs, RooArgSet &orderedObs) constInterface method for function objects to indicate their preferred order of observables for scanning t...Definition RooAbsReal.cxx:3694; RooAbsReal::maxValvirtual double maxVal(Int_t code) constReturn maximum value for set of observables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive integrals over functions ...Definition RooAbsReal.cxx:701; RooAbsReal::integralNameSuffixTString integralNameSuffix(const RooArgSet &iset, const RooArgSet *n",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:50073,Testability,log,logEvalErrorvoid,50073,"servables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive integrals over functions ...Definition RooAbsReal.cxx:701; RooAbsReal::integralNameSuffixTString integralNameSuffix(const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::isBinnedDistributionvirtual bool isBinnedDistribution(const RooArgSet &) constTests if the distribution is binned. Unless overridden by derived classes, this always returns false.Definition RooAbsReal.h:346; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the gi",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:50090,Testability,log,logEvalError,50090,"servables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive integrals over functions ...Definition RooAbsReal.cxx:701; RooAbsReal::integralNameSuffixTString integralNameSuffix(const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) constConstruct string with unique suffix name to give to integral object that encodes integrated observabl...Definition RooAbsReal.cxx:755; RooAbsReal::evaluatevirtual double evaluate() const =0Evaluate this PDF / function / constant. Needs to be overridden by all derived classes.; RooAbsReal::getTitleTString getTitle(bool appendUnit=false) constReturn this variable's title string.Definition RooAbsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::isBinnedDistributionvirtual bool isBinnedDistribution(const RooArgSet &) constTests if the distribution is binned. Unless overridden by derived classes, this always returns false.Definition RooAbsReal.h:346; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the gi",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:51092,Testability,log,logged,51092,"bsReal.cxx:285; RooAbsReal::logEvalErrorvoid logEvalError(const char *message, const char *serverValueString=nullptr) constLog evaluation error message.Definition RooAbsReal.cxx:3464; RooAbsReal::analyticalIntegralWNvirtual double analyticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::isBinnedDistributionvirtual bool isBinnedDistribution(const RooArgSet &) constTests if the distribution is binned. Unless overridden by derived classes, this always returns false.Definition RooAbsReal.h:346; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsReal.cxx:3827; RooAbsReal::enableOffsettingvirtual void enableOffsetting(bool)Definition RooAbsReal.cxx:4484; RooAbsReal::clearEvalErrorLogstatic void clearEvalErrorLog()Clear the stack of evaluation error messages.Definition RooAbsReal.cxx:3542; RooAbsReal::createIntObjRooFit::OwningPtr< RooAbsReal > createIntObj(const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) constInternal utility function for createIntegral() that creates the actual integral object.Definition RooAbsReal.cxx:590; RooAbsReal::sigmaRooAbsMoment * sigma(RooRealVar &obs, const RooArgSet &nset)Definition RooAbsReal.h:362; RooAbsReal::functorRooFunctor * functor(const RooArgList &ob",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:2311,Usability,simpl,simply,2311,"; 30class RooDataSet ;; 31class RooPlot;; 32class RooRealVar;; 33class RooAbsFunc;; 34class RooAbsCategoryLValue ;; 35class RooLinkedList ;; 36class RooNumIntConfig ;; 37class RooDataHist ;; 38class RooFunctor ;; 39class RooFitResult ;; 40class RooAbsMoment ;; 41class RooDerivative ;; 42class RooVectorDataStore ;; 43struct TreeReadBuffer; /// A space to attach TBranches; 44namespace RooBatchCompute {; 45struct RunContext;; 46}; 47 ; 48class TH1;; 49class TH1F;; 50class TH2F;; 51class TH3F;; 52 ; 53#include <iostream>; 54#include <list>; 55#include <map>; 56#include <string>; 57#include <sstream>; 58 ; 59class RooAbsReal : public RooAbsArg {; 60public:; 61 using value_type = double;; 62 ; 63 /// A RooAbsReal::Ref can be constructed from a `RooAbsReal&` or a `double`; 64 /// that will be implicitly converted to a RooConstVar&. The RooAbsReal::Ref; 65 /// can be used as a replacement for `RooAbsReal&`. With this type; 66 /// definition, you can write RooFit interfaces that accept both RooAbsReal,; 67 /// or simply a number that will be implicitly converted to a RooConstVar&.; 68 class Ref {; 69 public:; 70 inline Ref(RooAbsReal &ref) : _ref{ref} {}; 71 Ref(double val);; 72 inline operator RooAbsReal &() const { return _ref; }; 73 ; 74 private:; 75 RooAbsReal &_ref;; 76 };; 77 ; 78 // Constructors, assignment etc; 79 RooAbsReal() ;; 80 RooAbsReal(const char *name, const char *title, const char *unit= """") ;; 81 RooAbsReal(const char *name, const char *title, double minVal, double maxVal,; 82 const char *unit= """") ;; 83 RooAbsReal(const RooAbsReal& other, const char* name=nullptr);; 84 ~RooAbsReal() override;; 85 ; 86 ; 87 ; 88 ; 89 //////////////////////////////////////////////////////////////////////////////////; 90 /// Evaluate object. Returns either cached value or triggers a recalculation.; 91 /// The recalculation happens by calling getValV(), which in the end calls the; 92 /// virtual evaluate() functions of the respective PDFs.; 93 /// \param[in] normalisationSet ",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:16895,Usability,clear,clearEvalErrorLog,16895,"tmp) { std::string s(tmp); s.swap(_msg); }; 312 void setServerValues(const char* tmp) { std::string s(tmp); s.swap(_srvval); }; 313 std::string _msg;; 314 std::string _srvval;; 315 } ;; 316 ; 317 enum ErrorLoggingMode { PrintErrors, CollectErrors, CountErrors, Ignore } ;; 318 ; 319 /// Context to temporarily change the error logging mode as long as the context is alive.; 320 class EvalErrorContext {; 321 public:; 322 EvalErrorContext(ErrorLoggingMode m) : _old{evalErrorLoggingMode()} { setEvalErrorLoggingMode(m); }; 323 ; 324 EvalErrorContext(EvalErrorContext const&) = delete;; 325 EvalErrorContext(EvalErrorContext &&) = delete;; 326 EvalErrorContext& operator=(EvalErrorContext const&) = delete;; 327 EvalErrorContext& operator=(EvalErrorContext &&) = delete;; 328 ; 329 ~EvalErrorContext() { setEvalErrorLoggingMode(_old); }; 330 private:; 331 ErrorLoggingMode _old;; 332 };; 333 ; 334 static ErrorLoggingMode evalErrorLoggingMode() ;; 335 static void setEvalErrorLoggingMode(ErrorLoggingMode m) ;; 336 void logEvalError(const char* message, const char* serverValueString=nullptr) const ;; 337 static void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString=nullptr) ;; 338 static void printEvalErrors(std::ostream&os=std::cout, Int_t maxPerNode=10000000) ;; 339 static Int_t numEvalErrors() ;; 340 static Int_t numEvalErrorItems();; 341 static std::map<const RooAbsArg *, std::pair<std::string, std::list<RooAbsReal::EvalError>>>::iterator evalErrorIter();; 342 ; 343 static void clearEvalErrorLog() ;; 344 ; 345 /// Tests if the distribution is binned. Unless overridden by derived classes, this always returns false.; 346 virtual bool isBinnedDistribution(const RooArgSet& /*obs*/) const { return false ; }; 347 virtual std::list<double>* binBoundaries(RooAbsRealLValue& obs, double xlo, double xhi) const;; 348 virtual std::list<double>* plotSamplingHint(RooAbsRealLValue& obs, double xlo, double xhi) const;; 349 ; 350 Ro",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:48482,Usability,clear,clearing,48482,"CmdArg&, const RooCmdArg&, const RooCmdArg&,...Definition RooAbsReal.cxx:3706; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooNumIntConfig &cfg, const char *rangeName=nullptr) constCreate integral over observables in iset in range named rangeName using specified configuration for a...Definition RooAbsReal.h:220; RooAbsReal::_specIntegratorConfigstd::unique_ptr< RooNumIntConfig > _specIntegratorConfigDefinition RooAbsReal.h:540; RooAbsReal::getAnalyticalIntegralvirtual Int_t getAnalyticalIntegral(RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) constInterface function getAnalyticalIntergral advertises the analytical integrals that are supported.Definition RooAbsReal.cxx:368; RooAbsReal::evalErrorIterstatic std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter()Definition RooAbsReal.cxx:181; RooAbsReal::numEvalErrorsstatic Int_t numEvalErrors()Return the number of logged evaluation errors since the last clearing.Definition RooAbsReal.cxx:3624; RooAbsReal::setEvalErrorLoggingModestatic void setEvalErrorLoggingMode(ErrorLoggingMode m)Set evaluation error logging mode.Definition RooAbsReal.cxx:4316; RooAbsReal::_plotMaxdouble _plotMaxMaximum of plot range.Definition RooAbsReal.h:534; RooAbsReal::preferredObservableScanOrdervirtual void preferredObservableScanOrder(const RooArgSet &obs, RooArgSet &orderedObs) constInterface method for function objects to indicate their preferred order of observables for scanning t...Definition RooAbsReal.cxx:3694; RooAbsReal::maxValvirtual double maxVal(Int_t code) constReturn maximum value for set of observables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive in",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:51466,Usability,clear,clearEvalErrorLogstatic,51466,"tconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::isBinnedDistributionvirtual bool isBinnedDistribution(const RooArgSet &) constTests if the distribution is binned. Unless overridden by derived classes, this always returns false.Definition RooAbsReal.h:346; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsReal.cxx:3827; RooAbsReal::enableOffsettingvirtual void enableOffsetting(bool)Definition RooAbsReal.cxx:4484; RooAbsReal::clearEvalErrorLogstatic void clearEvalErrorLog()Clear the stack of evaluation error messages.Definition RooAbsReal.cxx:3542; RooAbsReal::createIntObjRooFit::OwningPtr< RooAbsReal > createIntObj(const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) constInternal utility function for createIntegral() that creates the actual integral object.Definition RooAbsReal.cxx:590; RooAbsReal::sigmaRooAbsMoment * sigma(RooRealVar &obs, const RooArgSet &nset)Definition RooAbsReal.h:362; RooAbsReal::functorRooFunctor * functor(const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) constReturn a RooFunctor object bound to this RooAbsReal with given definition of observables and paramete...Definition RooAbsReal.cxx:3887; RooAbsReal::setCachedValuevoid setCachedValue(double value, bool notifyClients=true) finalOverwrite the value stored in this object's cache.Definition RooAbsReal.h:558; RooAbsReal::_plotBinsInt_t _plotBinsNumber of plot bins.Definition RooA",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAbsReal_8h_source.html:51495,Usability,clear,clearEvalErrorLog,51495,"tconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::isBinnedDistributionvirtual bool isBinnedDistribution(const RooArgSet &) constTests if the distribution is binned. Unless overridden by derived classes, this always returns false.Definition RooAbsReal.h:346; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsReal.cxx:3827; RooAbsReal::enableOffsettingvirtual void enableOffsetting(bool)Definition RooAbsReal.cxx:4484; RooAbsReal::clearEvalErrorLogstatic void clearEvalErrorLog()Clear the stack of evaluation error messages.Definition RooAbsReal.cxx:3542; RooAbsReal::createIntObjRooFit::OwningPtr< RooAbsReal > createIntObj(const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) constInternal utility function for createIntegral() that creates the actual integral object.Definition RooAbsReal.cxx:590; RooAbsReal::sigmaRooAbsMoment * sigma(RooRealVar &obs, const RooArgSet &nset)Definition RooAbsReal.h:362; RooAbsReal::functorRooFunctor * functor(const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) constReturn a RooFunctor object bound to this RooAbsReal with given definition of observables and paramete...Definition RooAbsReal.cxx:3887; RooAbsReal::setCachedValuevoid setCachedValue(double value, bool notifyClients=true) finalOverwrite the value stored in this object's cache.Definition RooAbsReal.h:558; RooAbsReal::_plotBinsInt_t _plotBinsNumber of plot bins.Definition RooA",MatchSource.WIKI,doc/master/RooAbsReal_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html
https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html:1165,Availability,toler,tolerance,1165,"ses |; Macros |; Typedefs |; Enumerations |; Functions |; Variables ; RooAdaptiveGaussKronrodIntegrator1D.cxx File Reference. #include <cassert>; #include <cstdlib>; #include ""TClass.h""; #include ""Riostream.h""; #include ""RooAdaptiveGaussKronrodIntegrator1D.h""; #include ""RooArgSet.h""; #include ""RooRealVar.h""; #include ""RooNumber.h""; #include ""RooNumIntFactory.h""; #include ""TMath.h""; #include ""RooMsgService.h"". Include dependency graph for RooAdaptiveGaussKronrodIntegrator1D.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  extrapolation_table;  ; struct  gsl_function_struct;  ; struct  gsl_integration_workspace;  ; struct  il_params;  ; struct  iu_params;  . Macros; #define GSL_COERCE_DBL(x)   (gsl_coerce_double(x));  ; #define GSL_DBL_EPSILON   2.2204460492503131e-16;  ; #define GSL_DBL_MAX   1.7976931348623157e+308;  ; #define GSL_DBL_MIN   2.2250738585072014e-308;  ; #define GSL_EBADTOL   13 /* user specified an invalid tolerance */;  ; #define GSL_EDIVERGE   6;  ; #define GSL_EDOM   1 /* input domain error, e.g sqrt(-1) */;  ; #define GSL_EFAILED   5;  ; #define GSL_EINVAL   2;  ; #define GSL_EMAXITER   3;  ; #define GSL_ENOMEM   8 /* malloc failed */;  ; #define GSL_EROUND   7;  ; #define GSL_ERROR(a, b)   oocoutE(nullptr,Integration) << ""RooAdaptiveGaussKronrodIntegrator1D::integral() ERROR: "" << a << endl ; return b ;;  ; #define GSL_ERROR_VAL(reason, gsl_errno, value)   return value ;;  ; #define GSL_ESING   4;  ; #define GSL_ETOL   14 /* failed to reach the specified tolerance */;  ; #define GSL_FN_EVAL(F, x)   (*((F)->function))(x,(F)->params);  ; #define GSL_MAX(a, b)   ((a) > (b) ? (a) : (b));  ; #define GSL_SUCCESS   0;  . Typedefs; typedef struct gsl_function_struct gsl_function;  ; typedef void gsl_integration_rule(const gsl_function *f, double a, double b, double *result, double *abserr, double *defabs, double *resabs);  . Enumerations; enum  { ;   GSL_INTEG_GAUSS15 = 1; , GSL_INTEG_GAUSS21 = 2",MatchSource.WIKI,doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html
https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html:1248,Availability,error,error,1248,"ses |; Macros |; Typedefs |; Enumerations |; Functions |; Variables ; RooAdaptiveGaussKronrodIntegrator1D.cxx File Reference. #include <cassert>; #include <cstdlib>; #include ""TClass.h""; #include ""Riostream.h""; #include ""RooAdaptiveGaussKronrodIntegrator1D.h""; #include ""RooArgSet.h""; #include ""RooRealVar.h""; #include ""RooNumber.h""; #include ""RooNumIntFactory.h""; #include ""TMath.h""; #include ""RooMsgService.h"". Include dependency graph for RooAdaptiveGaussKronrodIntegrator1D.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  extrapolation_table;  ; struct  gsl_function_struct;  ; struct  gsl_integration_workspace;  ; struct  il_params;  ; struct  iu_params;  . Macros; #define GSL_COERCE_DBL(x)   (gsl_coerce_double(x));  ; #define GSL_DBL_EPSILON   2.2204460492503131e-16;  ; #define GSL_DBL_MAX   1.7976931348623157e+308;  ; #define GSL_DBL_MIN   2.2250738585072014e-308;  ; #define GSL_EBADTOL   13 /* user specified an invalid tolerance */;  ; #define GSL_EDIVERGE   6;  ; #define GSL_EDOM   1 /* input domain error, e.g sqrt(-1) */;  ; #define GSL_EFAILED   5;  ; #define GSL_EINVAL   2;  ; #define GSL_EMAXITER   3;  ; #define GSL_ENOMEM   8 /* malloc failed */;  ; #define GSL_EROUND   7;  ; #define GSL_ERROR(a, b)   oocoutE(nullptr,Integration) << ""RooAdaptiveGaussKronrodIntegrator1D::integral() ERROR: "" << a << endl ; return b ;;  ; #define GSL_ERROR_VAL(reason, gsl_errno, value)   return value ;;  ; #define GSL_ESING   4;  ; #define GSL_ETOL   14 /* failed to reach the specified tolerance */;  ; #define GSL_FN_EVAL(F, x)   (*((F)->function))(x,(F)->params);  ; #define GSL_MAX(a, b)   ((a) > (b) ? (a) : (b));  ; #define GSL_SUCCESS   0;  . Typedefs; typedef struct gsl_function_struct gsl_function;  ; typedef void gsl_integration_rule(const gsl_function *f, double a, double b, double *result, double *abserr, double *defabs, double *resabs);  . Enumerations; enum  { ;   GSL_INTEG_GAUSS15 = 1; , GSL_INTEG_GAUSS21 = 2",MatchSource.WIKI,doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html
https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html:1729,Availability,toler,tolerance,1729,"rvice.h"". Include dependency graph for RooAdaptiveGaussKronrodIntegrator1D.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  extrapolation_table;  ; struct  gsl_function_struct;  ; struct  gsl_integration_workspace;  ; struct  il_params;  ; struct  iu_params;  . Macros; #define GSL_COERCE_DBL(x)   (gsl_coerce_double(x));  ; #define GSL_DBL_EPSILON   2.2204460492503131e-16;  ; #define GSL_DBL_MAX   1.7976931348623157e+308;  ; #define GSL_DBL_MIN   2.2250738585072014e-308;  ; #define GSL_EBADTOL   13 /* user specified an invalid tolerance */;  ; #define GSL_EDIVERGE   6;  ; #define GSL_EDOM   1 /* input domain error, e.g sqrt(-1) */;  ; #define GSL_EFAILED   5;  ; #define GSL_EINVAL   2;  ; #define GSL_EMAXITER   3;  ; #define GSL_ENOMEM   8 /* malloc failed */;  ; #define GSL_EROUND   7;  ; #define GSL_ERROR(a, b)   oocoutE(nullptr,Integration) << ""RooAdaptiveGaussKronrodIntegrator1D::integral() ERROR: "" << a << endl ; return b ;;  ; #define GSL_ERROR_VAL(reason, gsl_errno, value)   return value ;;  ; #define GSL_ESING   4;  ; #define GSL_ETOL   14 /* failed to reach the specified tolerance */;  ; #define GSL_FN_EVAL(F, x)   (*((F)->function))(x,(F)->params);  ; #define GSL_MAX(a, b)   ((a) > (b) ? (a) : (b));  ; #define GSL_SUCCESS   0;  . Typedefs; typedef struct gsl_function_struct gsl_function;  ; typedef void gsl_integration_rule(const gsl_function *f, double a, double b, double *result, double *abserr, double *defabs, double *resabs);  . Enumerations; enum  { ;   GSL_INTEG_GAUSS15 = 1; , GSL_INTEG_GAUSS21 = 2; , GSL_INTEG_GAUSS31 = 3; , GSL_INTEG_GAUSS41 = 4; , ;   GSL_INTEG_GAUSS51 = 5; , GSL_INTEG_GAUSS61 = 6. };  . Functions; static void append_table (struct extrapolation_table *table, double y);  ; double gsl_coerce_double (const double x);  ; int gsl_integration_qag (const gsl_function *f, double a, double b, double epsabs, double epsrel, size_t limit, int key, gsl_integration_workspace *workspace, ",MatchSource.WIKI,doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html
https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html:6234,Availability,error,error,6234,"t gsl_function *f, const double a, const double b, const double epsabs, const double epsrel, const size_t limit, gsl_integration_workspace *workspace, double *result, double *abserr, gsl_integration_rule *q);  ; static void qelg (struct extrapolation_table *table, double *result, double *abserr);  ; static void qpsrt (gsl_integration_workspace *workspace);  ; static double rescale_error (double err, const double result_abs, const double result_asc);  ; static void reset_nrmax (gsl_integration_workspace *workspace);  ; static void retrieve (const gsl_integration_workspace *workspace, double *a, double *b, double *r, double *e);  ; double RooAdaptiveGaussKronrodIntegrator1D_GSL_GlueFunction (double x, void *data);  Glue function interacing to GSL code. ;  ; static void set_initial_result (gsl_integration_workspace *workspace, double result, double error);  ; static int subinterval_too_small (double a1, double a2, double b2);  ; static double sum_results (const gsl_integration_workspace *workspace);  ; static int test_positivity (double result, double resabs);  ; static void update (gsl_integration_workspace *workspace, double a1, double b1, double area1, double error1, double a2, double b2, double area2, double error2);  . Variables; static Roo_reg_AGKInteg1D instance;  ; static const double wgA [4];  ; static const double wgB [5];  ; static const double wgC [8];  ; static const double wgD [11];  ; static const double wgE [13];  ; static const double wgF [15];  ; static const double wgkA [8];  ; static const double wgkB [11];  ; static const double wgkC [16];  ; static const double wgkD [21];  ; static const double wgkE [26];  ; static const double wgkF [31];  ; static const double xgkA [8];  ; static const double xgkB [11];  ; static const double xgkC [16];  ; static const double xgkD [21];  ; static const double xgkE [26];  ; static const double xgkF [31];  . Macro Definition Documentation. ◆ GSL_COERCE_DBL. #define GSL_COERCE_DBL; (;  ; x);    (gsl_coerce_double(x)",MatchSource.WIKI,doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html
https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html:7929,Availability,toler,tolerance,7929,"double wgkB [11];  ; static const double wgkC [16];  ; static const double wgkD [21];  ; static const double wgkE [26];  ; static const double wgkF [31];  ; static const double xgkA [8];  ; static const double xgkB [11];  ; static const double xgkC [16];  ; static const double xgkD [21];  ; static const double xgkE [26];  ; static const double xgkF [31];  . Macro Definition Documentation. ◆ GSL_COERCE_DBL. #define GSL_COERCE_DBL; (;  ; x);    (gsl_coerce_double(x)). Definition at line 414 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_DBL_EPSILON. #define GSL_DBL_EPSILON   2.2204460492503131e-16. Definition at line 387 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_DBL_MAX. #define GSL_DBL_MAX   1.7976931348623157e+308. Definition at line 386 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_DBL_MIN. #define GSL_DBL_MIN   2.2250738585072014e-308. Definition at line 385 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_EBADTOL. #define GSL_EBADTOL   13 /* user specified an invalid tolerance */. Definition at line 382 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_EDIVERGE. #define GSL_EDIVERGE   6. Definition at line 393 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_EDOM. #define GSL_EDOM   1 /* input domain error, e.g sqrt(-1) */. Definition at line 380 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_EFAILED. #define GSL_EFAILED   5. Definition at line 392 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_EINVAL. #define GSL_EINVAL   2. Definition at line 389 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_EMAXITER. #define GSL_EMAXITER   3. Definition at line 390 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_ENOMEM. #define GSL_ENOMEM   8 /* malloc failed */. Definition at line 381 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_EROUND. #define GSL_EROUND   7. Definition at line 394 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_ERROR. #define GSL_ERROR; (;  ; a, .  ; b . );    oo",MatchSource.WIKI,doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html
https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html:8178,Availability,error,error,8178," ; static const double xgkD [21];  ; static const double xgkE [26];  ; static const double xgkF [31];  . Macro Definition Documentation. ◆ GSL_COERCE_DBL. #define GSL_COERCE_DBL; (;  ; x);    (gsl_coerce_double(x)). Definition at line 414 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_DBL_EPSILON. #define GSL_DBL_EPSILON   2.2204460492503131e-16. Definition at line 387 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_DBL_MAX. #define GSL_DBL_MAX   1.7976931348623157e+308. Definition at line 386 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_DBL_MIN. #define GSL_DBL_MIN   2.2250738585072014e-308. Definition at line 385 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_EBADTOL. #define GSL_EBADTOL   13 /* user specified an invalid tolerance */. Definition at line 382 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_EDIVERGE. #define GSL_EDIVERGE   6. Definition at line 393 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_EDOM. #define GSL_EDOM   1 /* input domain error, e.g sqrt(-1) */. Definition at line 380 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_EFAILED. #define GSL_EFAILED   5. Definition at line 392 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_EINVAL. #define GSL_EINVAL   2. Definition at line 389 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_EMAXITER. #define GSL_EMAXITER   3. Definition at line 390 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_ENOMEM. #define GSL_ENOMEM   8 /* malloc failed */. Definition at line 381 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_EROUND. #define GSL_EROUND   7. Definition at line 394 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_ERROR. #define GSL_ERROR; (;  ; a, .  ; b . );    oocoutE(nullptr,Integration) << ""RooAdaptiveGaussKronrodIntegrator1D::integral() ERROR: "" << a << endl ; return b ;. Definition at line 384 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_ERROR_VAL. #define GSL_ERROR_VAL; (;  ; reason, .  ; gsl_errno,",MatchSource.WIKI,doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html
https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html:9447,Availability,toler,tolerance,9447,"efinition at line 389 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_EMAXITER. #define GSL_EMAXITER   3. Definition at line 390 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_ENOMEM. #define GSL_ENOMEM   8 /* malloc failed */. Definition at line 381 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_EROUND. #define GSL_EROUND   7. Definition at line 394 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_ERROR. #define GSL_ERROR; (;  ; a, .  ; b . );    oocoutE(nullptr,Integration) << ""RooAdaptiveGaussKronrodIntegrator1D::integral() ERROR: "" << a << endl ; return b ;. Definition at line 384 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_ERROR_VAL. #define GSL_ERROR_VAL; (;  ; reason, .  ; gsl_errno, .  ; value . );    return value ;. Definition at line 396 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_ESING. #define GSL_ESING   4. Definition at line 391 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_ETOL. #define GSL_ETOL   14 /* failed to reach the specified tolerance */. Definition at line 383 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_FN_EVAL. #define GSL_FN_EVAL; (;  ; F, .  ; x . );    (*((F)->function))(x,(F)->params). Definition at line 68 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_MAX. #define GSL_MAX; (;  ; a, .  ; b . );    ((a) > (b) ? (a) : (b)). Definition at line 398 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ GSL_SUCCESS. #define GSL_SUCCESS   0. Definition at line 379 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. Typedef Documentation. ◆ gsl_function. typedef struct gsl_function_struct gsl_function. Definition at line 67 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ gsl_integration_rule. typedef void gsl_integration_rule(const gsl_function *f, double a, double b, double *result, double *abserr, double *defabs, double *resabs). Definition at line 425 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. Enumeration Type Documentation. ◆ anonymous enum. anonymous enum. Enu",MatchSource.WIKI,doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html
https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html:18630,Availability,error,error,18630,"c double rescale_error ; (; double ; err, . const double ; result_abs, . const double ; result_asc . ). static . Definition at line 992 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ reset_nrmax(). static void reset_nrmax ; (; gsl_integration_workspace * ; workspace). inlinestatic . Definition at line 1687 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ retrieve(). static void retrieve ; (; const gsl_integration_workspace * ; workspace, . double * ; a, . double * ; b, . double * ; r, . double * ; e . ). inlinestatic . Definition at line 688 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ RooAdaptiveGaussKronrodIntegrator1D_GSL_GlueFunction(). double RooAdaptiveGaussKronrodIntegrator1D_GSL_GlueFunction ; (; double ; x, . void * ; data . ). Glue function interacing to GSL code. ; Definition at line 301 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ set_initial_result(). static void set_initial_result ; (; gsl_integration_workspace * ; workspace, . double ; result, . double ; error . ). inlinestatic . Definition at line 514 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ subinterval_too_small(). static int subinterval_too_small ; (; double ; a1, . double ; a2, . double ; b2 . ). inlinestatic . Definition at line 727 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ sum_results(). static double sum_results ; (; const gsl_integration_workspace * ; workspace). inlinestatic . Definition at line 707 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ test_positivity(). static int test_positivity ; (; double ; result, . double ; resabs . ). inlinestatic . Definition at line 1987 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ update(). static void update ; (; gsl_integration_workspace * ; workspace, . double ; a1, . double ; b1, . double ; area1, . double ; error1, . double ; a2, . double ; b2, . double ; area2, . double ; error2 . ). inlinestatic . Definition at line 633 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. Variable Documentation. ◆ instance. ",MatchSource.WIKI,doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html
https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html:6465,Deployability,update,update,6465,"t gsl_function *f, const double a, const double b, const double epsabs, const double epsrel, const size_t limit, gsl_integration_workspace *workspace, double *result, double *abserr, gsl_integration_rule *q);  ; static void qelg (struct extrapolation_table *table, double *result, double *abserr);  ; static void qpsrt (gsl_integration_workspace *workspace);  ; static double rescale_error (double err, const double result_abs, const double result_asc);  ; static void reset_nrmax (gsl_integration_workspace *workspace);  ; static void retrieve (const gsl_integration_workspace *workspace, double *a, double *b, double *r, double *e);  ; double RooAdaptiveGaussKronrodIntegrator1D_GSL_GlueFunction (double x, void *data);  Glue function interacing to GSL code. ;  ; static void set_initial_result (gsl_integration_workspace *workspace, double result, double error);  ; static int subinterval_too_small (double a1, double a2, double b2);  ; static double sum_results (const gsl_integration_workspace *workspace);  ; static int test_positivity (double result, double resabs);  ; static void update (gsl_integration_workspace *workspace, double a1, double b1, double area1, double error1, double a2, double b2, double area2, double error2);  . Variables; static Roo_reg_AGKInteg1D instance;  ; static const double wgA [4];  ; static const double wgB [5];  ; static const double wgC [8];  ; static const double wgD [11];  ; static const double wgE [13];  ; static const double wgF [15];  ; static const double wgkA [8];  ; static const double wgkB [11];  ; static const double wgkC [16];  ; static const double wgkD [21];  ; static const double wgkE [26];  ; static const double wgkF [31];  ; static const double xgkA [8];  ; static const double xgkB [11];  ; static const double xgkC [16];  ; static const double xgkD [21];  ; static const double xgkE [26];  ; static const double xgkF [31];  . Macro Definition Documentation. ◆ GSL_COERCE_DBL. #define GSL_COERCE_DBL; (;  ; x);    (gsl_coerce_double(x)",MatchSource.WIKI,doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html
https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html:19293,Deployability,update,update,19293,"RooAdaptiveGaussKronrodIntegrator1D_GSL_GlueFunction ; (; double ; x, . void * ; data . ). Glue function interacing to GSL code. ; Definition at line 301 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ set_initial_result(). static void set_initial_result ; (; gsl_integration_workspace * ; workspace, . double ; result, . double ; error . ). inlinestatic . Definition at line 514 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ subinterval_too_small(). static int subinterval_too_small ; (; double ; a1, . double ; a2, . double ; b2 . ). inlinestatic . Definition at line 727 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ sum_results(). static double sum_results ; (; const gsl_integration_workspace * ; workspace). inlinestatic . Definition at line 707 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ test_positivity(). static int test_positivity ; (; double ; result, . double ; resabs . ). inlinestatic . Definition at line 1987 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ update(). static void update ; (; gsl_integration_workspace * ; workspace, . double ; a1, . double ; b1, . double ; area1, . double ; error1, . double ; a2, . double ; b2, . double ; area2, . double ; error2 . ). inlinestatic . Definition at line 633 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. Variable Documentation. ◆ instance. Roo_reg_AGKInteg1D instance. static . Definition at line 151 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ wgA. const double wgA[4]. static . Initial value:= ; {; 0.129484966168869693270611432679082,; 0.279705391489276667901467771423780,; 0.381830050505118944950369775488975,; 0.417959183673469387755102040816327; }. Definition at line 1121 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ wgB. const double wgB[5]. static . Initial value:= ; {; 0.066671344308688137593568809893332,; 0.149451349150580593145776339657697,; 0.219086362515982043995534934228163,; 0.269266719309996355091226921569469,; 0.295524224714752870173892994651338; }. Definition at line 117",MatchSource.WIKI,doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html
https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html:19315,Deployability,update,update,19315,"_GlueFunction ; (; double ; x, . void * ; data . ). Glue function interacing to GSL code. ; Definition at line 301 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ set_initial_result(). static void set_initial_result ; (; gsl_integration_workspace * ; workspace, . double ; result, . double ; error . ). inlinestatic . Definition at line 514 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ subinterval_too_small(). static int subinterval_too_small ; (; double ; a1, . double ; a2, . double ; b2 . ). inlinestatic . Definition at line 727 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ sum_results(). static double sum_results ; (; const gsl_integration_workspace * ; workspace). inlinestatic . Definition at line 707 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ test_positivity(). static int test_positivity ; (; double ; result, . double ; resabs . ). inlinestatic . Definition at line 1987 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ update(). static void update ; (; gsl_integration_workspace * ; workspace, . double ; a1, . double ; b1, . double ; area1, . double ; error1, . double ; a2, . double ; b2, . double ; area2, . double ; error2 . ). inlinestatic . Definition at line 633 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. Variable Documentation. ◆ instance. Roo_reg_AGKInteg1D instance. static . Definition at line 151 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ wgA. const double wgA[4]. static . Initial value:= ; {; 0.129484966168869693270611432679082,; 0.279705391489276667901467771423780,; 0.381830050505118944950369775488975,; 0.417959183673469387755102040816327; }. Definition at line 1121 of file RooAdaptiveGaussKronrodIntegrator1D.cxx. ◆ wgB. const double wgB[5]. static . Initial value:= ; {; 0.066671344308688137593568809893332,; 0.149451349150580593145776339657697,; 0.219086362515982043995534934228163,; 0.269266719309996355091226921569469,; 0.295524224714752870173892994651338; }. Definition at line 1174 of file RooAdaptiveGaussKronrodIntegra",MatchSource.WIKI,doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html
https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html:592,Integrability,depend,dependency,592,". ROOT: roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Macros |; Typedefs |; Enumerations |; Functions |; Variables ; RooAdaptiveGaussKronrodIntegrator1D.cxx File Reference. #include <cassert>; #include <cstdlib>; #include ""TClass.h""; #include ""Riostream.h""; #include ""RooAdaptiveGaussKronrodIntegrator1D.h""; #include ""RooArgSet.h""; #include ""RooRealVar.h""; #include ""RooNumber.h""; #include ""RooNumIntFactory.h""; #include ""TMath.h""; #include ""RooMsgService.h"". Include dependency graph for RooAdaptiveGaussKronrodIntegrator1D.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  extrapolation_table;  ; struct  gsl_function_struct;  ; struct  gsl_integration_workspace;  ; struct  il_params;  ; struct  iu_params;  . Macros; #define GSL_COERCE_DBL(x)   (gsl_coerce_double(x));  ; #define GSL_DBL_EPSILON   2.2204460492503131e-16;  ; #define GSL_DBL_MAX   1.7976931348623157e+308;  ; #define GSL_DBL_MIN   2.2250738585072014e-308;  ; #define GSL_EBADTOL   13 /* user specified an invalid tolerance */;  ; #define GSL_EDIVERGE   6;  ; #define GSL_EDOM   1 /* input domain error, e.g sqrt(-1) */;  ; #define GSL_EFAILED   5;  ; #define GSL_EINVAL   2;  ; #define GSL_EMAXITER   3;  ; #define GSL_ENOMEM   8 /* malloc failed */;  ; #define GSL_EROUND   7;  ; #define GSL_ERROR(a, b)   oocoutE(nullptr,Integration) << ""RooAdaptiveGaussKronrodIntegrator1D::integral() ERROR: "" << a << endl ; return b ;;  ; #define GSL_ERROR_VAL(reason, gsl_errno, value)   return value ;;  ; #define GSL_ESING   4;  ; #define GSL_ETOL   14 /* failed to reach the specified tolerance */;  ; #define GSL_FN_EVAL(F, x)   (*((F)->function))(x,(F)->params);  ; #define GSL_MAX(a, b)   ((a) > (b) ? (a) : (b));  ; #define GSL_SUCCESS   0;  . Typedefs; typedef struct gsl_function_struct gsl_function;  ; typedef void gsl_integration_rule(const gsl_fun",MatchSource.WIKI,doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooAdaptiveGaussKronrodIntegrator1D_8cxx.html
https://root.cern/doc/master/RooArgSet_8h_source.html:2195,Availability,error,errors,2195,"from one or more; 31 /// RooFit objects. The set will not own its contents.; 32 /// \tparam Ts Parameter pack of objects that derive from RooAbsArg or RooFit collections; or a name.; 33 /// \param arg A RooFit object.; 34 /// Note that you can also pass a `double` as first argument; 35 /// when constructing a RooArgSet, and another templated; 36 /// constructor will be used where a RooConstVar is implicitly; 37 /// created from the `double` value.; 38 /// \param moreArgsOrName Arbitrary number of; 39 /// - Further RooFit objects that derive from RooAbsArg; 40 /// - RooFit collections of such objects; 41 /// - `double`s from which a RooConstVar is implicitly created via `RooFit::RooConst`.; 42 /// - A name for the set. Given multiple names, the last-given name prevails.; 43 template<typename... Args_t>; 44 RooArgSet(const RooAbsArg& arg, Args_t &&... moreArgsOrName); 45 /*NB: Making this a delegating constructor led to linker errors with MSVC*/; 46 {; 47 // This constructor should cause a failed static_assert if any of the input; 48 // arguments is a temporary (r-value reference), which will be checked in; 49 // processArg. This works statically because of the universal reference; 50 // mechanism with templated functions.; 51 // Unfortunately, we can't check the first arg, because it's type can't be; 52 // a template parameter and hence a universal reference can't be used.; 53 // This problem is solved by introducing another templated constructor below,; 54 // which accepts a RooAbsArg && as the first argument which is forwarded to; 55 // be the second argument for this constructor.; 56 processArgs(arg, std::forward<Args_t>(moreArgsOrName)...);; 57 }; 58 ; 59 /// This constructor will provoke a `static_assert`, because passing a; 60 /// RooAbsArg as r-value reference is not allowed.; 61 template<typename... Args_t>; 62 RooArgSet(RooAbsArg && arg, Args_t &&... moreArgsOrName); 63 : RooArgSet{arg, std::move(arg), std::forward<Args_t>(moreArgsOrName)...} {}; 64 ; 65 temp",MatchSource.WIKI,doc/master/RooArgSet_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooArgSet_8h_source.html
https://root.cern/doc/master/RooArgSet_8h_source.html:6045,Integrability,interface,interface,6045,"coll, const char* name="""") ;; 108 explicit RooArgSet(const char *name);; 109 ; 110 ~RooArgSet() override;; 111 TObject* clone(const char* newname) const override { return new RooArgSet(*this,newname); }; 112 TObject* create(const char* newname) const override { return new RooArgSet(newname); }; 113 RooArgSet& operator=(const RooArgSet& other) { RooAbsCollection::operator=(other) ; return *this ;}; 114 ; 115 using RooAbsCollection::operator[];; 116 RooAbsArg& operator[](const TString& str) const;; 117 ; 118 ; 119 /// Shortcut for readFromStream(std::istream&, bool, const char*, const char*, bool), setting; 120 /// `flagReadAtt` and `section` to 0.; 121 virtual bool readFromStream(std::istream& is, bool compact, bool verbose=false) {; 122 // I/O streaming interface (machine readable); 123 return readFromStream(is, compact, nullptr, nullptr, verbose) ;; 124 }; 125 bool readFromStream(std::istream& is, bool compact, const char* flagReadAtt, const char* section, bool verbose=false) ;; 126 virtual void writeToStream(std::ostream& os, bool compact, const char* section=nullptr) const;; 127 void writeToFile(const char* fileName) const ;; 128 bool readFromFile(const char* fileName, const char* flagReadAtt=nullptr, const char* section=nullptr, bool verbose=false) ;; 129 ; 130 ; 131 /// Check if this exact instance is in this collection.; 132 bool containsInstance(const RooAbsArg& var) const override {; 133 return find(var) == &var;; 134 }; 135 ; 136 static void cleanup() ;; 137 ; 138 bool isInRange(const char* rangeSpec) ;; 139 ; 140 using RooAbsCollection::selectCommon;; 141 using RooAbsCollection::snapshot;; 142 ; 143 /// Use RooAbsCollection::selectByName(), but return as RooArgSet.; 144 inline RooArgSet* selectByName(const char* nameList, bool verbose=false) const {; 145 return static_cast<RooArgSet*>(RooAbsCollection::selectByName(nameList, verbose));; 146 }; 147 ; 148 /// Use RooAbsCollection::selecCommon(), but return as RooArgSet.; 149 inline RooArgSet* selectCommon(con",MatchSource.WIKI,doc/master/RooArgSet_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooArgSet_8h_source.html
https://root.cern/doc/master/RooLagrangianMorphFunc_8cxx.html:1143,Integrability,depend,dependency,1143," Namespaces |; Macros |; Typedefs |; Functions |; Variables ; RooLagrangianMorphFunc.cxx File Reference. #include ""Riostream.h""; #include ""RooAbsCollection.h""; #include ""RooArgList.h""; #include ""RooArgProxy.h""; #include ""RooArgSet.h""; #include ""RooBinning.h""; #include ""RooDataHist.h""; #include ""RooFormulaVar.h""; #include ""RooHistFunc.h""; #include ""RooLagrangianMorphFunc.h""; #include ""RooLinearCombination.h""; #include ""RooParamHistFunc.h""; #include ""RooProduct.h""; #include ""RooRealVar.h""; #include ""RooWorkspace.h""; #include ""RooFactoryWSTool.h""; #include ""ROOT/StringUtils.hxx""; #include ""TFile.h""; #include ""TFolder.h""; #include ""TH1.h""; #include ""TMap.h""; #include ""TParameter.h""; #include ""TRandom3.h""; #include <algorithm>; #include <array>; #include <cmath>; #include <cstddef>; #include <iostream>; #include <limits>; #include <map>; #include <memory>; #include <sstream>; #include <stdexcept>; #include <type_traits>; #include <typeinfo>; #include ""TDecompLU.h"". Include dependency graph for RooLagrangianMorphFunc.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  RooLagrangianMorphFunc::CacheElem;  ; struct  is_specialization< Test, Ref >;  ; struct  is_specialization< Ref< Args... >, Ref >;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Macros; #define NaN   std::numeric_limits<double>::quiet_NaN();  . Typedefs; typedef TMatrixD Matrix;  . Functions; Matrix diagMatrix (size_t n);  create a new diagonal matrix of size n ;  ; double invertMatrix (const Matrix &matrix, Matrix &inverse);  ; TMatrixD makeRootMatrix (const Matrix &in);  convert a matrix into a TMatrixD ;  ; Matrix makeSuperMatrix (const TMatrixD &in);  convert a TMatrixD into a Matrix ;  ; void printMatrix (const TMatrixD &mat);  write a matrix ;  ; template<class MatrixT > ; size_t size (const MatrixT &mat",MatchSource.WIKI,doc/master/RooLagrangianMorphFunc_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RooLagrangianMorphFunc_8cxx.html
https://root.cern/doc/master/rootclingTCling_8cxx_source.html:1850,Deployability,install,installation,1850,"tclingTCling.h""; 20 ; 21#undef R__DLLEXPORT; 22 ; 23#ifdef __FreeBSD__; 24char* __progname;; 25char** environ;; 26#endif; 27 ; 28#include ""TROOT.h""; 29#include ""TCling.h""; 30 ; 31extern ""C""; 32const char ** *TROOT__GetExtraInterpreterArgs(); 33{; 34 return &TROOT::GetExtraInterpreterArgs();; 35}; 36 ; 37extern ""C""; 38const char *TROOT__GetIncludeDir(); 39{; 40 return TROOT::GetIncludeDir();; 41}; 42 ; 43extern ""C""; 44const char *TROOT__GetEtcDir(); 45{; 46 return TROOT::GetEtcDir();; 47}; 48 ; 49extern ""C""; 50cling::Interpreter *TCling__GetInterpreter(); 51{; 52 static auto triggerInitialization = gROOT;; 53 (void)triggerInitialization;; 54 return (cling::Interpreter *)((TCling *)gCling)->GetInterpreterImpl();; 55}; 56 ; TCling.h; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3046; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2966; TROOT__GetExtraInterpreterArgsconst char *** TROOT__GetExtraInterpreterArgs()Definition rootclingTCling.cxx:32; TROOT__GetEtcDirconst char * TROOT__GetEtcDir()Definition rootclingTCling.cxx:44; TROOT__GetIncludeDirconst char * TROOT__GetIncludeDir()Definition rootclingTCling.cxx:38; TCling__GetInterpretercling::Interpreter * TCling__GetInterpreter()Definition rootclingTCling.cxx:50; rootclingTCling.h. coremetaclingsrcrootclingTCling.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:11 (GVA Time) using Doxygen 1.9.8   ",MatchSource.WIKI,doc/master/rootclingTCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootclingTCling_8cxx_source.html
https://root.cern/doc/master/rootclingTCling_8cxx_source.html:2000,Deployability,install,installation,2000,"gTCling.h""; 20 ; 21#undef R__DLLEXPORT; 22 ; 23#ifdef __FreeBSD__; 24char* __progname;; 25char** environ;; 26#endif; 27 ; 28#include ""TROOT.h""; 29#include ""TCling.h""; 30 ; 31extern ""C""; 32const char ** *TROOT__GetExtraInterpreterArgs(); 33{; 34 return &TROOT::GetExtraInterpreterArgs();; 35}; 36 ; 37extern ""C""; 38const char *TROOT__GetIncludeDir(); 39{; 40 return TROOT::GetIncludeDir();; 41}; 42 ; 43extern ""C""; 44const char *TROOT__GetEtcDir(); 45{; 46 return TROOT::GetEtcDir();; 47}; 48 ; 49extern ""C""; 50cling::Interpreter *TCling__GetInterpreter(); 51{; 52 static auto triggerInitialization = gROOT;; 53 (void)triggerInitialization;; 54 return (cling::Interpreter *)((TCling *)gCling)->GetInterpreterImpl();; 55}; 56 ; TCling.h; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3046; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2966; TROOT__GetExtraInterpreterArgsconst char *** TROOT__GetExtraInterpreterArgs()Definition rootclingTCling.cxx:32; TROOT__GetEtcDirconst char * TROOT__GetEtcDir()Definition rootclingTCling.cxx:44; TROOT__GetIncludeDirconst char * TROOT__GetIncludeDir()Definition rootclingTCling.cxx:38; TCling__GetInterpretercling::Interpreter * TCling__GetInterpreter()Definition rootclingTCling.cxx:50; rootclingTCling.h. coremetaclingsrcrootclingTCling.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rootclingTCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootclingTCling_8cxx_source.html
https://root.cern/doc/master/rootclingTCling_8cxx_source.html:1695,Integrability,interface,interface,1695,"e; 15# define R__DLLEXPORT __attribute__ ((visibility (""default""))); 16# endif; 17#endif; 18 ; 19#include ""rootclingTCling.h""; 20 ; 21#undef R__DLLEXPORT; 22 ; 23#ifdef __FreeBSD__; 24char* __progname;; 25char** environ;; 26#endif; 27 ; 28#include ""TROOT.h""; 29#include ""TCling.h""; 30 ; 31extern ""C""; 32const char ** *TROOT__GetExtraInterpreterArgs(); 33{; 34 return &TROOT::GetExtraInterpreterArgs();; 35}; 36 ; 37extern ""C""; 38const char *TROOT__GetIncludeDir(); 39{; 40 return TROOT::GetIncludeDir();; 41}; 42 ; 43extern ""C""; 44const char *TROOT__GetEtcDir(); 45{; 46 return TROOT::GetEtcDir();; 47}; 48 ; 49extern ""C""; 50cling::Interpreter *TCling__GetInterpreter(); 51{; 52 static auto triggerInitialization = gROOT;; 53 (void)triggerInitialization;; 54 return (cling::Interpreter *)((TCling *)gCling)->GetInterpreterImpl();; 55}; 56 ; TCling.h; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3046; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2966; TROOT__GetExtraInterpreterArgsconst char *** TROOT__GetExtraInterpreterArgs()Definition rootclingTCling.cxx:32; TROOT__GetEtcDirconst char * TROOT__GetEtcDir()Definition rootclingTCling.cxx:44; TROOT__GetIncludeDirconst char * TROOT__GetIncludeDir()Definition rootclingTCling.cxx:38; TCling__GetInterpretercling::Interpreter * TCling__GetInterpreter()Definition rootclingTCling.cxx:50; rootclingTCling.h. coremetaclingsrcrootclingT",MatchSource.WIKI,doc/master/rootclingTCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootclingTCling_8cxx_source.html
https://root.cern/doc/master/rootclingTCling_8cxx_source.html:2182,Integrability,inject,inject,2182,"gTCling.h""; 20 ; 21#undef R__DLLEXPORT; 22 ; 23#ifdef __FreeBSD__; 24char* __progname;; 25char** environ;; 26#endif; 27 ; 28#include ""TROOT.h""; 29#include ""TCling.h""; 30 ; 31extern ""C""; 32const char ** *TROOT__GetExtraInterpreterArgs(); 33{; 34 return &TROOT::GetExtraInterpreterArgs();; 35}; 36 ; 37extern ""C""; 38const char *TROOT__GetIncludeDir(); 39{; 40 return TROOT::GetIncludeDir();; 41}; 42 ; 43extern ""C""; 44const char *TROOT__GetEtcDir(); 45{; 46 return TROOT::GetEtcDir();; 47}; 48 ; 49extern ""C""; 50cling::Interpreter *TCling__GetInterpreter(); 51{; 52 static auto triggerInitialization = gROOT;; 53 (void)triggerInitialization;; 54 return (cling::Interpreter *)((TCling *)gCling)->GetInterpreterImpl();; 55}; 56 ; TCling.h; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3046; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2966; TROOT__GetExtraInterpreterArgsconst char *** TROOT__GetExtraInterpreterArgs()Definition rootclingTCling.cxx:32; TROOT__GetEtcDirconst char * TROOT__GetEtcDir()Definition rootclingTCling.cxx:44; TROOT__GetIncludeDirconst char * TROOT__GetIncludeDir()Definition rootclingTCling.cxx:38; TCling__GetInterpretercling::Interpreter * TCling__GetInterpreter()Definition rootclingTCling.cxx:50; rootclingTCling.h. coremetaclingsrcrootclingTCling.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rootclingTCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootclingTCling_8cxx_source.html
https://root.cern/doc/master/rootclingTCling_8cxx_source.html:2223,Integrability,interface,interface,2223,"gTCling.h""; 20 ; 21#undef R__DLLEXPORT; 22 ; 23#ifdef __FreeBSD__; 24char* __progname;; 25char** environ;; 26#endif; 27 ; 28#include ""TROOT.h""; 29#include ""TCling.h""; 30 ; 31extern ""C""; 32const char ** *TROOT__GetExtraInterpreterArgs(); 33{; 34 return &TROOT::GetExtraInterpreterArgs();; 35}; 36 ; 37extern ""C""; 38const char *TROOT__GetIncludeDir(); 39{; 40 return TROOT::GetIncludeDir();; 41}; 42 ; 43extern ""C""; 44const char *TROOT__GetEtcDir(); 45{; 46 return TROOT::GetEtcDir();; 47}; 48 ; 49extern ""C""; 50cling::Interpreter *TCling__GetInterpreter(); 51{; 52 static auto triggerInitialization = gROOT;; 53 (void)triggerInitialization;; 54 return (cling::Interpreter *)((TCling *)gCling)->GetInterpreterImpl();; 55}; 56 ; TCling.h; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3046; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2966; TROOT__GetExtraInterpreterArgsconst char *** TROOT__GetExtraInterpreterArgs()Definition rootclingTCling.cxx:32; TROOT__GetEtcDirconst char * TROOT__GetEtcDir()Definition rootclingTCling.cxx:44; TROOT__GetIncludeDirconst char * TROOT__GetIncludeDir()Definition rootclingTCling.cxx:38; TCling__GetInterpretercling::Interpreter * TCling__GetInterpreter()Definition rootclingTCling.cxx:50; rootclingTCling.h. coremetaclingsrcrootclingTCling.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rootclingTCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootclingTCling_8cxx_source.html
https://root.cern/doc/master/rootclingTCling_8cxx_source.html:2182,Security,inject,inject,2182,"gTCling.h""; 20 ; 21#undef R__DLLEXPORT; 22 ; 23#ifdef __FreeBSD__; 24char* __progname;; 25char** environ;; 26#endif; 27 ; 28#include ""TROOT.h""; 29#include ""TCling.h""; 30 ; 31extern ""C""; 32const char ** *TROOT__GetExtraInterpreterArgs(); 33{; 34 return &TROOT::GetExtraInterpreterArgs();; 35}; 36 ; 37extern ""C""; 38const char *TROOT__GetIncludeDir(); 39{; 40 return TROOT::GetIncludeDir();; 41}; 42 ; 43extern ""C""; 44const char *TROOT__GetEtcDir(); 45{; 46 return TROOT::GetEtcDir();; 47}; 48 ; 49extern ""C""; 50cling::Interpreter *TCling__GetInterpreter(); 51{; 52 static auto triggerInitialization = gROOT;; 53 (void)triggerInitialization;; 54 return (cling::Interpreter *)((TCling *)gCling)->GetInterpreterImpl();; 55}; 56 ; TCling.h; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3046; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2966; TROOT__GetExtraInterpreterArgsconst char *** TROOT__GetExtraInterpreterArgs()Definition rootclingTCling.cxx:32; TROOT__GetEtcDirconst char * TROOT__GetEtcDir()Definition rootclingTCling.cxx:44; TROOT__GetIncludeDirconst char * TROOT__GetIncludeDir()Definition rootclingTCling.cxx:38; TCling__GetInterpretercling::Interpreter * TCling__GetInterpreter()Definition rootclingTCling.cxx:50; rootclingTCling.h. coremetaclingsrcrootclingTCling.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rootclingTCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootclingTCling_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:19307,Availability,error,errors,19307," gOptSink (llvm::cl::ZeroOrMore, llvm::cl::Sink, llvm::cl::desc(""Consumes all unrecognized options.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptSplit (""split"", llvm::cl::desc(""Split the dictionary into two parts: one containing the IO (ClassDef)\; information and another the interactivity support.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::list< std::string > gOptSysIncludePaths (""isystem"", llvm::cl::ZeroOrMore, llvm::cl::desc(""Specify a system include path.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptSystemModuleByproducts (""mSystemByproducts"", llvm::cl::Hidden, llvm::cl::desc(""Allow implicit build of system modules.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptUmbrellaInput (""umbrellaHeader"", llvm::cl::desc(""A single header including all headers instead of specifying them on the command line.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< VerboseLevel > gOptVerboseLevel (llvm::cl::desc(""Choose verbosity level:""), llvm::cl::values(clEnumVal(v, ""Show errors.""), clEnumVal(v0, ""Show only fatal errors.""), clEnumVal(v1, ""Show errors (the same as -v).""), clEnumVal(v2, ""Show warnings (default).""), clEnumVal(v3, ""Show notes.""), clEnumVal(v4, ""Show information."")), llvm::cl::init(v2), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::list< std::string > gOptWDiags (""W"", llvm::cl::Prefix, llvm::cl::ZeroOrMore, llvm::cl::desc(""Specify compiler diagnostics options.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptWriteEmptyRootPCM (""writeEmptyRootPCM"", llvm::cl::Hidden, llvm::cl::desc(""Does not include the header files as it assumes they exist in the pch.""), llvm::cl::cat(gRootclingOptions));  ; const std::string gPathSeparator (ROOT::TMetaUtils::GetPathSeparator());  ; llvm::StringRef GrabIndex (const cling::Interpreter &interp, const clang::FieldDecl &member, int printError);  GrabIndex returns a static string (so use it or copy",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:19349,Availability,error,errors,19349,"cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptSplit (""split"", llvm::cl::desc(""Split the dictionary into two parts: one containing the IO (ClassDef)\; information and another the interactivity support.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::list< std::string > gOptSysIncludePaths (""isystem"", llvm::cl::ZeroOrMore, llvm::cl::desc(""Specify a system include path.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptSystemModuleByproducts (""mSystemByproducts"", llvm::cl::Hidden, llvm::cl::desc(""Allow implicit build of system modules.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptUmbrellaInput (""umbrellaHeader"", llvm::cl::desc(""A single header including all headers instead of specifying them on the command line.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< VerboseLevel > gOptVerboseLevel (llvm::cl::desc(""Choose verbosity level:""), llvm::cl::values(clEnumVal(v, ""Show errors.""), clEnumVal(v0, ""Show only fatal errors.""), clEnumVal(v1, ""Show errors (the same as -v).""), clEnumVal(v2, ""Show warnings (default).""), clEnumVal(v3, ""Show notes.""), clEnumVal(v4, ""Show information."")), llvm::cl::init(v2), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::list< std::string > gOptWDiags (""W"", llvm::cl::Prefix, llvm::cl::ZeroOrMore, llvm::cl::desc(""Specify compiler diagnostics options.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptWriteEmptyRootPCM (""writeEmptyRootPCM"", llvm::cl::Hidden, llvm::cl::desc(""Does not include the header files as it assumes they exist in the pch.""), llvm::cl::cat(gRootclingOptions));  ; const std::string gPathSeparator (ROOT::TMetaUtils::GetPathSeparator());  ; llvm::StringRef GrabIndex (const cling::Interpreter &interp, const clang::FieldDecl &member, int printError);  GrabIndex returns a static string (so use it or copy it immediately, do not call GrabIndex twice in the same expression) containing the size of the array data membe",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:19380,Availability,error,errors,19380,"opt< bool > gOptSplit (""split"", llvm::cl::desc(""Split the dictionary into two parts: one containing the IO (ClassDef)\; information and another the interactivity support.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::list< std::string > gOptSysIncludePaths (""isystem"", llvm::cl::ZeroOrMore, llvm::cl::desc(""Specify a system include path.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptSystemModuleByproducts (""mSystemByproducts"", llvm::cl::Hidden, llvm::cl::desc(""Allow implicit build of system modules.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptUmbrellaInput (""umbrellaHeader"", llvm::cl::desc(""A single header including all headers instead of specifying them on the command line.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< VerboseLevel > gOptVerboseLevel (llvm::cl::desc(""Choose verbosity level:""), llvm::cl::values(clEnumVal(v, ""Show errors.""), clEnumVal(v0, ""Show only fatal errors.""), clEnumVal(v1, ""Show errors (the same as -v).""), clEnumVal(v2, ""Show warnings (default).""), clEnumVal(v3, ""Show notes.""), clEnumVal(v4, ""Show information."")), llvm::cl::init(v2), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::list< std::string > gOptWDiags (""W"", llvm::cl::Prefix, llvm::cl::ZeroOrMore, llvm::cl::desc(""Specify compiler diagnostics options.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptWriteEmptyRootPCM (""writeEmptyRootPCM"", llvm::cl::Hidden, llvm::cl::desc(""Does not include the header files as it assumes they exist in the pch.""), llvm::cl::cat(gRootclingOptions));  ; const std::string gPathSeparator (ROOT::TMetaUtils::GetPathSeparator());  ; llvm::StringRef GrabIndex (const cling::Interpreter &interp, const clang::FieldDecl &member, int printError);  GrabIndex returns a static string (so use it or copy it immediately, do not call GrabIndex twice in the same expression) containing the size of the array data member. ;  ; static llvm::cl::OptionCategory gRoot",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:51897,Availability,error,errors,51897,"ion and another the interactivity support."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptSysIncludePaths(). static llvm::cl::list< std::string > gOptSysIncludePaths ; (; ""isystem"" ; , . llvm::cl::ZeroOrMore ; , . llvm::cl::desc(""Specify a system include path."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptSystemModuleByproducts(). static llvm::cl::opt< bool > gOptSystemModuleByproducts ; (; ""mSystemByproducts"" ; , . llvm::cl::Hidden ; , . llvm::cl::desc(""Allow implicit build of system modules."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptUmbrellaInput(). static llvm::cl::opt< bool > gOptUmbrellaInput ; (; ""umbrellaHeader"" ; , . llvm::cl::desc(""A single header including all headers instead of specifying them on the command line."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptVerboseLevel(). static llvm::cl::opt< VerboseLevel > gOptVerboseLevel ; (; llvm::cl::desc(""Choose verbosity level:"") ; , . llvm::cl::values(clEnumVal(v, ""Show errors.""), clEnumVal(v0, ""Show only fatal errors.""), clEnumVal(v1, ""Show errors (the same as -v).""), clEnumVal(v2, ""Show warnings (default).""), clEnumVal(v3, ""Show notes.""), clEnumVal(v4, ""Show information."")) ; , . llvm::cl::init(v2) ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptWDiags(). static llvm::cl::list< std::string > gOptWDiags ; (; ""W"" ; , . llvm::cl::Prefix ; , . llvm::cl::ZeroOrMore ; , . llvm::cl::desc(""Specify compiler diagnostics options."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptWriteEmptyRootPCM(). static llvm::cl::opt< bool > gOptWriteEmptyRootPCM ; (; ""writeEmptyRootPCM"" ; , . llvm::cl::Hidden ; , . llvm::cl::desc(""Does not include the header files as it assumes they exist in the pch."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gPathSeparator(). const std::string gPathSeparator ; (; ROOT::TMetaUtils::GetPathSeparator() ; ). ◆ GrabIndex(). llvm::StringRef GrabIndex ; (; const cling::Interpreter & ; i",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:51939,Availability,error,errors,51939,") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptSysIncludePaths(). static llvm::cl::list< std::string > gOptSysIncludePaths ; (; ""isystem"" ; , . llvm::cl::ZeroOrMore ; , . llvm::cl::desc(""Specify a system include path."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptSystemModuleByproducts(). static llvm::cl::opt< bool > gOptSystemModuleByproducts ; (; ""mSystemByproducts"" ; , . llvm::cl::Hidden ; , . llvm::cl::desc(""Allow implicit build of system modules."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptUmbrellaInput(). static llvm::cl::opt< bool > gOptUmbrellaInput ; (; ""umbrellaHeader"" ; , . llvm::cl::desc(""A single header including all headers instead of specifying them on the command line."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptVerboseLevel(). static llvm::cl::opt< VerboseLevel > gOptVerboseLevel ; (; llvm::cl::desc(""Choose verbosity level:"") ; , . llvm::cl::values(clEnumVal(v, ""Show errors.""), clEnumVal(v0, ""Show only fatal errors.""), clEnumVal(v1, ""Show errors (the same as -v).""), clEnumVal(v2, ""Show warnings (default).""), clEnumVal(v3, ""Show notes.""), clEnumVal(v4, ""Show information."")) ; , . llvm::cl::init(v2) ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptWDiags(). static llvm::cl::list< std::string > gOptWDiags ; (; ""W"" ; , . llvm::cl::Prefix ; , . llvm::cl::ZeroOrMore ; , . llvm::cl::desc(""Specify compiler diagnostics options."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptWriteEmptyRootPCM(). static llvm::cl::opt< bool > gOptWriteEmptyRootPCM ; (; ""writeEmptyRootPCM"" ; , . llvm::cl::Hidden ; , . llvm::cl::desc(""Does not include the header files as it assumes they exist in the pch."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gPathSeparator(). const std::string gPathSeparator ; (; ROOT::TMetaUtils::GetPathSeparator() ; ). ◆ GrabIndex(). llvm::StringRef GrabIndex ; (; const cling::Interpreter & ; interp, . const clang::FieldDecl & ; member,",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:51970,Availability,error,errors,51970," ). static . ◆ gOptSysIncludePaths(). static llvm::cl::list< std::string > gOptSysIncludePaths ; (; ""isystem"" ; , . llvm::cl::ZeroOrMore ; , . llvm::cl::desc(""Specify a system include path."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptSystemModuleByproducts(). static llvm::cl::opt< bool > gOptSystemModuleByproducts ; (; ""mSystemByproducts"" ; , . llvm::cl::Hidden ; , . llvm::cl::desc(""Allow implicit build of system modules."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptUmbrellaInput(). static llvm::cl::opt< bool > gOptUmbrellaInput ; (; ""umbrellaHeader"" ; , . llvm::cl::desc(""A single header including all headers instead of specifying them on the command line."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptVerboseLevel(). static llvm::cl::opt< VerboseLevel > gOptVerboseLevel ; (; llvm::cl::desc(""Choose verbosity level:"") ; , . llvm::cl::values(clEnumVal(v, ""Show errors.""), clEnumVal(v0, ""Show only fatal errors.""), clEnumVal(v1, ""Show errors (the same as -v).""), clEnumVal(v2, ""Show warnings (default).""), clEnumVal(v3, ""Show notes.""), clEnumVal(v4, ""Show information."")) ; , . llvm::cl::init(v2) ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptWDiags(). static llvm::cl::list< std::string > gOptWDiags ; (; ""W"" ; , . llvm::cl::Prefix ; , . llvm::cl::ZeroOrMore ; , . llvm::cl::desc(""Specify compiler diagnostics options."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptWriteEmptyRootPCM(). static llvm::cl::opt< bool > gOptWriteEmptyRootPCM ; (; ""writeEmptyRootPCM"" ; , . llvm::cl::Hidden ; , . llvm::cl::desc(""Does not include the header files as it assumes they exist in the pch."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gPathSeparator(). const std::string gPathSeparator ; (; ROOT::TMetaUtils::GetPathSeparator() ; ). ◆ GrabIndex(). llvm::StringRef GrabIndex ; (; const cling::Interpreter & ; interp, . const clang::FieldDecl & ; member, . int ; printError . ). GrabIndex returns a ",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:53130,Availability,error,error,53130,"RootclingOptions) ;  . ). static . ◆ gOptWDiags(). static llvm::cl::list< std::string > gOptWDiags ; (; ""W"" ; , . llvm::cl::Prefix ; , . llvm::cl::ZeroOrMore ; , . llvm::cl::desc(""Specify compiler diagnostics options."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptWriteEmptyRootPCM(). static llvm::cl::opt< bool > gOptWriteEmptyRootPCM ; (; ""writeEmptyRootPCM"" ; , . llvm::cl::Hidden ; , . llvm::cl::desc(""Does not include the header files as it assumes they exist in the pch."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gPathSeparator(). const std::string gPathSeparator ; (; ROOT::TMetaUtils::GetPathSeparator() ; ). ◆ GrabIndex(). llvm::StringRef GrabIndex ; (; const cling::Interpreter & ; interp, . const clang::FieldDecl & ; member, . int ; printError . ). GrabIndex returns a static string (so use it or copy it immediately, do not call GrabIndex twice in the same expression) containing the size of the array data member. ; In case of error, or if the size is not specified, GrabIndex returns 0. ; Definition at line 1352 of file rootcling_impl.cxx. ◆ gRootclingOptions(). static llvm::cl::OptionCategory gRootclingOptions ; (; ""rootcling common options"" ; ). static . ◆ HasPath(). bool HasPath ; (; const std::string & ; name). Check if file has a path. ; Definition at line 2166 of file rootcling_impl.cxx. ◆ IncludeHeaders(). static bool IncludeHeaders ; (; const std::vector< std::string > & ; headers, . cling::Interpreter & ; interpreter . ). static . Includes all given headers in the interpreter. ; Returns true when we could include the headers and otherwise false on an error when including. ; Definition at line 2048 of file rootcling_impl.cxx. ◆ InheritsFromTObject(). bool InheritsFromTObject ; (; const clang::RecordDecl * ; cl, . const cling::Interpreter & ; interp . ). Definition at line 431 of file rootcling_impl.cxx. ◆ InheritsFromTSelector(). bool InheritsFromTSelector ; (; const clang::RecordDecl * ; cl, . const cling::Interpreter & ;",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:53775,Availability,error,error,53775,"thSeparator ; (; ROOT::TMetaUtils::GetPathSeparator() ; ). ◆ GrabIndex(). llvm::StringRef GrabIndex ; (; const cling::Interpreter & ; interp, . const clang::FieldDecl & ; member, . int ; printError . ). GrabIndex returns a static string (so use it or copy it immediately, do not call GrabIndex twice in the same expression) containing the size of the array data member. ; In case of error, or if the size is not specified, GrabIndex returns 0. ; Definition at line 1352 of file rootcling_impl.cxx. ◆ gRootclingOptions(). static llvm::cl::OptionCategory gRootclingOptions ; (; ""rootcling common options"" ; ). static . ◆ HasPath(). bool HasPath ; (; const std::string & ; name). Check if file has a path. ; Definition at line 2166 of file rootcling_impl.cxx. ◆ IncludeHeaders(). static bool IncludeHeaders ; (; const std::vector< std::string > & ; headers, . cling::Interpreter & ; interpreter . ). static . Includes all given headers in the interpreter. ; Returns true when we could include the headers and otherwise false on an error when including. ; Definition at line 2048 of file rootcling_impl.cxx. ◆ InheritsFromTObject(). bool InheritsFromTObject ; (; const clang::RecordDecl * ; cl, . const cling::Interpreter & ; interp . ). Definition at line 431 of file rootcling_impl.cxx. ◆ InheritsFromTSelector(). bool InheritsFromTSelector ; (; const clang::RecordDecl * ; cl, . const cling::Interpreter & ; interp . ). Definition at line 443 of file rootcling_impl.cxx. ◆ InjectModuleUtilHeader(). static bool InjectModuleUtilHeader ; (; const char * ; argv0, . TModuleGenerator & ; modGen, . cling::Interpreter & ; interp, . bool ; umbrella . ). static . Write the extra header injected into the module: umbrella header if (umbrella) else content header. ; Definition at line 1972 of file rootcling_impl.cxx. ◆ IsCorrectClingArgument(). bool IsCorrectClingArgument ; (; const std::string & ; argument). Check if the argument is a sane cling argument. ; Performing the following checks: 1) It does not",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:11387,Deployability,update,updates,11387,"es (std::ostream &dictStream, const std::string &includeForSource, const std::string &extraIncludes);  ; const std::string GenerateStringFromHeadersForClasses (const HeadersDeclsMap_t &headersClassesMap, const std::string &detectedUmbrella, bool payLoadOnly=false);  Generate a string for the dictionary from the headers-classes map. ;  ; int GenReflexMain (int argc, char **argv);  Translate the arguments of genreflex into rootcling ones and forward them to the RootCling function. ;  ; const char * GetExePath ();  Returns the executable path name, used e.g. by SetRootSys(). ;  ; std::pair< std::string, std::string > GetExternalNamespaceAndContainedEntities (const std::string line);  Performance is not critical here. ;  ; size_t GetFullArrayLength (const clang::ConstantArrayType *arrayType);  ; std::string GetFwdDeclnArgsToKeepString (const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt, cling::Interpreter &interp);  ; static llvm::StringRef GetModuleNameFromRdictName (llvm::StringRef rdictName);  ; void GetMostExternalEnclosingClassName (const clang::DeclContext &theContext, std::string &ctxtName, const cling::Interpreter &interpreter, bool treatParent=true);  Extract the proper autoload key for nested classes The routine does not erase the name, just updates it. ;  ; void GetMostExternalEnclosingClassNameFromDecl (const clang::Decl &theDecl, std::string &ctxtName, const cling::Interpreter &interpreter);  ; string GetNonConstMemberName (const clang::FieldDecl &m, const string &prefix="""");  Return the name of the data member so that it can be used by non-const operation (so it includes a const_cast if necessary). ;  ; clang::QualType GetPointeeTypeIfPossible (const clang::QualType &qt);  Get the pointee type if possible. ;  ; const std::string gLibraryExtension ("".so"");  ; static llvm::cl::list< std::string > gOptBareClingSink (llvm::cl::OneOrMore, llvm::cl::Sink, llvm::cl::desc(""Consumes options and sends them to cling.""), llvm::cl::cat(gRootclingOptions), llvm::cl::sub(g",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:41560,Deployability,update,updates,41560,"ring > GetExternalNamespaceAndContainedEntities ; (; const std::string ; line). Performance is not critical here. ; Definition at line 2356 of file rootcling_impl.cxx. ◆ GetFullArrayLength(). size_t GetFullArrayLength ; (; const clang::ConstantArrayType * ; arrayType). Definition at line 417 of file rootcling_impl.cxx. ◆ GetFwdDeclnArgsToKeepString(). std::string GetFwdDeclnArgsToKeepString ; (; const ROOT::TMetaUtils::TNormalizedCtxt & ; normCtxt, . cling::Interpreter & ; interp . ). Definition at line 3047 of file rootcling_impl.cxx. ◆ GetModuleNameFromRdictName(). static llvm::StringRef GetModuleNameFromRdictName ; (; llvm::StringRef ; rdictName). static . Definition at line 4013 of file rootcling_impl.cxx. ◆ GetMostExternalEnclosingClassName(). void GetMostExternalEnclosingClassName ; (; const clang::DeclContext & ; theContext, . std::string & ; ctxtName, . const cling::Interpreter & ; interpreter, . bool ; treatParent = true . ). Extract the proper autoload key for nested classes The routine does not erase the name, just updates it. ; Definition at line 2195 of file rootcling_impl.cxx. ◆ GetMostExternalEnclosingClassNameFromDecl(). void GetMostExternalEnclosingClassNameFromDecl ; (; const clang::Decl & ; theDecl, . std::string & ; ctxtName, . const cling::Interpreter & ; interpreter . ). Definition at line 2213 of file rootcling_impl.cxx. ◆ GetNonConstMemberName(). string GetNonConstMemberName ; (; const clang::FieldDecl & ; m, . const string & ; prefix = """" . ). Return the name of the data member so that it can be used by non-const operation (so it includes a const_cast if necessary). ; Definition at line 830 of file rootcling_impl.cxx. ◆ GetPointeeTypeIfPossible(). clang::QualType GetPointeeTypeIfPossible ; (; const clang::QualType & ; qt). Get the pointee type if possible. ; Definition at line 3071 of file rootcling_impl.cxx. ◆ gLibraryExtension(). const std::string gLibraryExtension ; (; "".so"" ; ). ◆ gOptBareClingSink(). static llvm::cl::list< std::string > ",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:2003,Integrability,depend,dependency,2003,"g/AST/CXXInheritance.h""; #include ""clang/Basic/Diagnostic.h""; #include ""clang/Frontend/CompilerInstance.h""; #include ""clang/Frontend/FrontendActions.h""; #include ""clang/Frontend/FrontendDiagnostic.h""; #include ""clang/Lex/HeaderSearch.h""; #include ""clang/Lex/Preprocessor.h""; #include ""clang/Lex/ModuleMap.h""; #include ""clang/Lex/Pragma.h""; #include ""clang/Sema/Sema.h""; #include ""clang/Serialization/ASTWriter.h""; #include ""cling/Utils/AST.h""; #include ""llvm/ADT/StringRef.h""; #include ""llvm/Support/CommandLine.h""; #include ""llvm/Support/Path.h""; #include ""llvm/Support/PrettyStackTrace.h""; #include ""llvm/Support/Signals.h""; #include ""RtypesCore.h""; #include ""TModuleGenerator.h""; #include ""TClassEdit.h""; #include ""TClingUtils.h""; #include ""RStl.h""; #include ""XMLReader.h""; #include ""LinkdefReader.h""; #include ""DictSelectionReader.h""; #include ""SelectionRules.h""; #include ""Scanner.h""; #include ""strlcpy.h""; #include ""OptionParser.h""; #include ""clang/Basic/LangOptions.def"". Include dependency graph for rootcling_impl.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  CheckModuleBuildClient;  Custom diag client for clang that verifies that each implicitly build module is a system module. More...;  ; class  tempFileNamesCatalog;  Little helper class to bookkeep the files names which we want to make temporary. More...;  ; class  TRootClingCallbacks;  . Namespaces; namespace  genreflex;  . Macros; #define ENUM_LANGOPT(Name, Type, Bits, Default, Description);  ; #define LANGOPT(Name, Bits, Default, Description)    ROOT::TMetaUtils::Info(nullptr, ""%s = %d // %s\n"", #Name, (int)LangOpts.Name, Description);;  ; #define rootclingStringify(s)   rootclingStringifyx(s);  ; #define rootclingStringifyx(s)   #s;  . Typedefs; using HeadersDeclsMap_t = std::map< std::string, std::list< std::string > >;  . Enumerations; enum  VerboseLevel { ;   v = ROOT::TMetaUtils::kError; , v0 = ROOT::TMetaUtils::kFatal; , v1 = v; , v2 = ROOT::TMetaUtils",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:11349,Integrability,rout,routine,11349,"es (std::ostream &dictStream, const std::string &includeForSource, const std::string &extraIncludes);  ; const std::string GenerateStringFromHeadersForClasses (const HeadersDeclsMap_t &headersClassesMap, const std::string &detectedUmbrella, bool payLoadOnly=false);  Generate a string for the dictionary from the headers-classes map. ;  ; int GenReflexMain (int argc, char **argv);  Translate the arguments of genreflex into rootcling ones and forward them to the RootCling function. ;  ; const char * GetExePath ();  Returns the executable path name, used e.g. by SetRootSys(). ;  ; std::pair< std::string, std::string > GetExternalNamespaceAndContainedEntities (const std::string line);  Performance is not critical here. ;  ; size_t GetFullArrayLength (const clang::ConstantArrayType *arrayType);  ; std::string GetFwdDeclnArgsToKeepString (const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt, cling::Interpreter &interp);  ; static llvm::StringRef GetModuleNameFromRdictName (llvm::StringRef rdictName);  ; void GetMostExternalEnclosingClassName (const clang::DeclContext &theContext, std::string &ctxtName, const cling::Interpreter &interpreter, bool treatParent=true);  Extract the proper autoload key for nested classes The routine does not erase the name, just updates it. ;  ; void GetMostExternalEnclosingClassNameFromDecl (const clang::Decl &theDecl, std::string &ctxtName, const cling::Interpreter &interpreter);  ; string GetNonConstMemberName (const clang::FieldDecl &m, const string &prefix="""");  Return the name of the data member so that it can be used by non-const operation (so it includes a const_cast if necessary). ;  ; clang::QualType GetPointeeTypeIfPossible (const clang::QualType &qt);  Get the pointee type if possible. ;  ; const std::string gLibraryExtension ("".so"");  ; static llvm::cl::list< std::string > gOptBareClingSink (llvm::cl::OneOrMore, llvm::cl::Sink, llvm::cl::desc(""Consumes options and sends them to cling.""), llvm::cl::cat(gRootclingOptions), llvm::cl::sub(g",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:15445,Integrability,depend,dependent,15445,"ignores the dictionary generation. \; When -r is present rootcling becomes a tool to generate rootmaps (and capability files).""), llvm::cl::Hidden, llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::list< std::string > gOptIncludePaths (""I"", llvm::cl::Prefix, llvm::cl::ZeroOrMore, llvm::cl::desc(""Specify an include path.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptInlineInput (""inlineInputHeader"", llvm::cl::desc(""Does not generate #include <header> but expands the header content.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptInterpreterOnly (""interpreteronly"", llvm::cl::desc(""Generate minimal dictionary for interactivity (without IO information).""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< std::string > gOptISysRoot (""isysroot"", llvm::cl::Prefix, llvm::cl::Hidden, llvm::cl::desc(""Specify an isysroot.""), llvm::cl::cat(gRootclingOptions), llvm::cl::init(""-""));  ; static llvm::cl::opt< std::string > gOptLibListPrefix (""lib-list-prefix"", llvm::cl::desc(""An ACLiC feature which exports the list of dependent libraries.""), llvm::cl::Hidden, llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::list< std::string > gOptModuleByproducts (""mByproduct"", llvm::cl::ZeroOrMore, llvm::cl::Hidden, llvm::cl::desc(""The list of the expected implicit modules build as part of building the current module.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::list< std::string > gOptModuleDependencies (""m"", llvm::cl::desc(""The list of dependent modules of the dictionary.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::list< std::string > gOptModuleMapFiles (""moduleMapFile"", llvm::cl::desc(""Specify a C++ modulemap file.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptMultiDict (""multiDict"", llvm::cl::desc(""If this library has multiple separate LinkDef files.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptNoDictSelection (""noDictSelection"", llvm:",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:15877,Integrability,depend,dependent,15877,"include <header> but expands the header content.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptInterpreterOnly (""interpreteronly"", llvm::cl::desc(""Generate minimal dictionary for interactivity (without IO information).""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< std::string > gOptISysRoot (""isysroot"", llvm::cl::Prefix, llvm::cl::Hidden, llvm::cl::desc(""Specify an isysroot.""), llvm::cl::cat(gRootclingOptions), llvm::cl::init(""-""));  ; static llvm::cl::opt< std::string > gOptLibListPrefix (""lib-list-prefix"", llvm::cl::desc(""An ACLiC feature which exports the list of dependent libraries.""), llvm::cl::Hidden, llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::list< std::string > gOptModuleByproducts (""mByproduct"", llvm::cl::ZeroOrMore, llvm::cl::Hidden, llvm::cl::desc(""The list of the expected implicit modules build as part of building the current module.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::list< std::string > gOptModuleDependencies (""m"", llvm::cl::desc(""The list of dependent modules of the dictionary.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::list< std::string > gOptModuleMapFiles (""moduleMapFile"", llvm::cl::desc(""Specify a C++ modulemap file.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptMultiDict (""multiDict"", llvm::cl::desc(""If this library has multiple separate LinkDef files.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptNoDictSelection (""noDictSelection"", llvm::cl::Hidden, llvm::cl::desc(""Do not run the selection rules. Useful when in -onepcm mode.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptNoGlobalUsingStd (""noGlobalUsingStd"", llvm::cl::desc(""Do not declare {using namespace std} in dictionary global scope.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptNoIncludePaths (""noIncludePaths"", llvm::cl::desc(""Do not store include paths but rely on the env variable ROOT_IN",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:21271,Integrability,inject,injected,21271,"ldDecl &member, int printError);  GrabIndex returns a static string (so use it or copy it immediately, do not call GrabIndex twice in the same expression) containing the size of the array data member. ;  ; static llvm::cl::OptionCategory gRootclingOptions (""rootcling common options"");  ; bool HasPath (const std::string &name);  Check if file has a path. ;  ; void genreflex::header2outputName (std::string &fileName);  Replace the extension with ""_rflx.cpp"". ;  ; void genreflex::headers2outputsNames (const std::vector< std::string > &headersNames, std::vector< std::string > &ofilesnames);  Get a proper name for the output file. ;  ; static bool IncludeHeaders (const std::vector< std::string > &headers, cling::Interpreter &interpreter);  Includes all given headers in the interpreter. ;  ; bool InheritsFromTObject (const clang::RecordDecl *cl, const cling::Interpreter &interp);  ; bool InheritsFromTSelector (const clang::RecordDecl *cl, const cling::Interpreter &interp);  ; static bool InjectModuleUtilHeader (const char *argv0, TModuleGenerator &modGen, cling::Interpreter &interp, bool umbrella);  Write the extra header injected into the module: umbrella header if (umbrella) else content header. ;  ; int genreflex::invokeManyRootCling (const std::string &verbosity, const std::string &selectionFileName, const std::string &targetLibName, bool multiDict, const std::vector< std::string > &pcmsNames, const std::vector< std::string > &includes, const std::vector< std::string > &preprocDefines, const std::vector< std::string > &preprocUndefines, const std::vector< std::string > &warnings, const std::string &rootmapFileName, const std::string &rootmapLibName, bool interpreteronly, bool doSplit, bool isCxxmodule, bool writeEmptyRootPCM, bool selSyntaxOnly, bool noIncludePaths, bool noGlobalUsingStd, const std::vector< std::string > &headersNames, bool failOnWarnings, bool printRootclingInvocation, const std::string &outputDirName_const="""");  Get the right ofilenames and invoke se",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:41522,Integrability,rout,routine,41522,"ring > GetExternalNamespaceAndContainedEntities ; (; const std::string ; line). Performance is not critical here. ; Definition at line 2356 of file rootcling_impl.cxx. ◆ GetFullArrayLength(). size_t GetFullArrayLength ; (; const clang::ConstantArrayType * ; arrayType). Definition at line 417 of file rootcling_impl.cxx. ◆ GetFwdDeclnArgsToKeepString(). std::string GetFwdDeclnArgsToKeepString ; (; const ROOT::TMetaUtils::TNormalizedCtxt & ; normCtxt, . cling::Interpreter & ; interp . ). Definition at line 3047 of file rootcling_impl.cxx. ◆ GetModuleNameFromRdictName(). static llvm::StringRef GetModuleNameFromRdictName ; (; llvm::StringRef ; rdictName). static . Definition at line 4013 of file rootcling_impl.cxx. ◆ GetMostExternalEnclosingClassName(). void GetMostExternalEnclosingClassName ; (; const clang::DeclContext & ; theContext, . std::string & ; ctxtName, . const cling::Interpreter & ; interpreter, . bool ; treatParent = true . ). Extract the proper autoload key for nested classes The routine does not erase the name, just updates it. ; Definition at line 2195 of file rootcling_impl.cxx. ◆ GetMostExternalEnclosingClassNameFromDecl(). void GetMostExternalEnclosingClassNameFromDecl ; (; const clang::Decl & ; theDecl, . std::string & ; ctxtName, . const cling::Interpreter & ; interpreter . ). Definition at line 2213 of file rootcling_impl.cxx. ◆ GetNonConstMemberName(). string GetNonConstMemberName ; (; const clang::FieldDecl & ; m, . const string & ; prefix = """" . ). Return the name of the data member so that it can be used by non-const operation (so it includes a const_cast if necessary). ; Definition at line 830 of file rootcling_impl.cxx. ◆ GetPointeeTypeIfPossible(). clang::QualType GetPointeeTypeIfPossible ; (; const clang::QualType & ; qt). Get the pointee type if possible. ; Definition at line 3071 of file rootcling_impl.cxx. ◆ gLibraryExtension(). const std::string gLibraryExtension ; (; "".so"" ; ). ◆ gOptBareClingSink(). static llvm::cl::list< std::string > ",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:46960,Integrability,depend,dependent,46960,"rMore ; , . llvm::cl::desc(""Specify an include path."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptInlineInput(). static llvm::cl::opt< bool > gOptInlineInput ; (; ""inlineInputHeader"" ; , . llvm::cl::desc(""Does not generate #include <header> but expands the header content."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptInterpreterOnly(). static llvm::cl::opt< bool > gOptInterpreterOnly ; (; ""interpreteronly"" ; , . llvm::cl::desc(""Generate minimal dictionary for interactivity (without IO information)."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptISysRoot(). static llvm::cl::opt< std::string > gOptISysRoot ; (; ""isysroot"" ; , . llvm::cl::Prefix ; , . llvm::cl::Hidden ; , . llvm::cl::desc(""Specify an isysroot."") ; , . llvm::cl::cat(gRootclingOptions) ; , . llvm::cl::init(""-"") ;  . ). static . ◆ gOptLibListPrefix(). static llvm::cl::opt< std::string > gOptLibListPrefix ; (; ""lib-list-prefix"" ; , . llvm::cl::desc(""An ACLiC feature which exports the list of dependent libraries."") ; , . llvm::cl::Hidden ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptModuleByproducts(). static llvm::cl::list< std::string > gOptModuleByproducts ; (; ""mByproduct"" ; , . llvm::cl::ZeroOrMore ; , . llvm::cl::Hidden ; , . llvm::cl::desc(""The list of the expected implicit modules build as part of building the current module."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptModuleDependencies(). static llvm::cl::list< std::string > gOptModuleDependencies ; (; ""m"" ; , . llvm::cl::desc(""The list of dependent modules of the dictionary."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptModuleMapFiles(). static llvm::cl::list< std::string > gOptModuleMapFiles ; (; ""moduleMapFile"" ; , . llvm::cl::desc(""Specify a C++ modulemap file."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptMultiDict(). static llvm::cl::opt< bool > gOptMultiDict ; (; ""multiDict"" ; , . llvm::cl::desc(""If this library has ",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:47513,Integrability,depend,dependent,47513,"ions) ;  . ). static . ◆ gOptISysRoot(). static llvm::cl::opt< std::string > gOptISysRoot ; (; ""isysroot"" ; , . llvm::cl::Prefix ; , . llvm::cl::Hidden ; , . llvm::cl::desc(""Specify an isysroot."") ; , . llvm::cl::cat(gRootclingOptions) ; , . llvm::cl::init(""-"") ;  . ). static . ◆ gOptLibListPrefix(). static llvm::cl::opt< std::string > gOptLibListPrefix ; (; ""lib-list-prefix"" ; , . llvm::cl::desc(""An ACLiC feature which exports the list of dependent libraries."") ; , . llvm::cl::Hidden ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptModuleByproducts(). static llvm::cl::list< std::string > gOptModuleByproducts ; (; ""mByproduct"" ; , . llvm::cl::ZeroOrMore ; , . llvm::cl::Hidden ; , . llvm::cl::desc(""The list of the expected implicit modules build as part of building the current module."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptModuleDependencies(). static llvm::cl::list< std::string > gOptModuleDependencies ; (; ""m"" ; , . llvm::cl::desc(""The list of dependent modules of the dictionary."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptModuleMapFiles(). static llvm::cl::list< std::string > gOptModuleMapFiles ; (; ""moduleMapFile"" ; , . llvm::cl::desc(""Specify a C++ modulemap file."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptMultiDict(). static llvm::cl::opt< bool > gOptMultiDict ; (; ""multiDict"" ; , . llvm::cl::desc(""If this library has multiple separate LinkDef files."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptNoDictSelection(). static llvm::cl::opt< bool > gOptNoDictSelection ; (; ""noDictSelection"" ; , . llvm::cl::Hidden ; , . llvm::cl::desc(""Do not run the selection rules. Useful when in -onepcm mode."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptNoGlobalUsingStd(). static llvm::cl::opt< bool > gOptNoGlobalUsingStd ; (; ""noGlobalUsingStd"" ; , . llvm::cl::desc(""Do not declare {using namespace std} in dictionary global scope."") ; , . llvm::cl::cat(gRootclingOption",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:54426,Integrability,inject,injected,54426,"Definition at line 2166 of file rootcling_impl.cxx. ◆ IncludeHeaders(). static bool IncludeHeaders ; (; const std::vector< std::string > & ; headers, . cling::Interpreter & ; interpreter . ). static . Includes all given headers in the interpreter. ; Returns true when we could include the headers and otherwise false on an error when including. ; Definition at line 2048 of file rootcling_impl.cxx. ◆ InheritsFromTObject(). bool InheritsFromTObject ; (; const clang::RecordDecl * ; cl, . const cling::Interpreter & ; interp . ). Definition at line 431 of file rootcling_impl.cxx. ◆ InheritsFromTSelector(). bool InheritsFromTSelector ; (; const clang::RecordDecl * ; cl, . const cling::Interpreter & ; interp . ). Definition at line 443 of file rootcling_impl.cxx. ◆ InjectModuleUtilHeader(). static bool InjectModuleUtilHeader ; (; const char * ; argv0, . TModuleGenerator & ; modGen, . cling::Interpreter & ; interp, . bool ; umbrella . ). static . Write the extra header injected into the module: umbrella header if (umbrella) else content header. ; Definition at line 1972 of file rootcling_impl.cxx. ◆ IsCorrectClingArgument(). bool IsCorrectClingArgument ; (; const std::string & ; argument). Check if the argument is a sane cling argument. ; Performing the following checks: 1) It does not start with ""--"" and is not the –param option. ; Definition at line 3419 of file rootcling_impl.cxx. ◆ IsGoodForAutoParseMap(). bool IsGoodForAutoParseMap ; (; const clang::RecordDecl & ; rcd). Check if the class good for being an autoparse key. ; We exclude from this set stl containers of pods/strings TODO: we may use also __gnu_cxx:: ; Definition at line 3169 of file rootcling_impl.cxx. ◆ IsGoodLibraryName(). bool IsGoodLibraryName ; (; const std::string & ; name). Definition at line 5563 of file rootcling_impl.cxx. ◆ IsImplementationName(). bool IsImplementationName ; (; const std::string & ; filename). Definition at line 3410 of file rootcling_impl.cxx. ◆ IsLinkdefFile(). bool IsLinkdefFile ",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:16811,Modifiability,variab,variable,16811,"le.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::list< std::string > gOptModuleDependencies (""m"", llvm::cl::desc(""The list of dependent modules of the dictionary.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::list< std::string > gOptModuleMapFiles (""moduleMapFile"", llvm::cl::desc(""Specify a C++ modulemap file.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptMultiDict (""multiDict"", llvm::cl::desc(""If this library has multiple separate LinkDef files.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptNoDictSelection (""noDictSelection"", llvm::cl::Hidden, llvm::cl::desc(""Do not run the selection rules. Useful when in -onepcm mode.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptNoGlobalUsingStd (""noGlobalUsingStd"", llvm::cl::desc(""Do not declare {using namespace std} in dictionary global scope.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptNoIncludePaths (""noIncludePaths"", llvm::cl::desc(""Do not store include paths but rely on the env variable ROOT_INCLUDE_PATH.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptP (""p"", llvm::cl::desc(""Deprecated, legacy flag which is ignored.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::list< std::string > gOptPPDefines (""D"", llvm::cl::Prefix, llvm::cl::ZeroOrMore, llvm::cl::desc(""Specify defined macros.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::list< std::string > gOptPPUndefines (""U"", llvm::cl::Prefix, llvm::cl::ZeroOrMore, llvm::cl::desc(""Specify undefined macros.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptReflex (""reflex"", llvm::cl::desc(""Behave internally like genreflex.""), llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< bool > gOptRootBuild (""rootbuild"", llvm::cl::desc(""If we are building ROOT.""), llvm::cl::Hidden, llvm::cl::cat(gRootclingOptions));  ; static llvm::cl::opt< std::string > gOptRootMapFileName (""rm",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:25405,Modifiability,config,config,25405,");  Check whether the #pragma line contains expectedTokens (0-terminated array). ;  ; void ParseRootMapFile (ifstream &file, map< string, string > &autoloads);  Parse the rootmap and add entries to the autoload map. ;  ; void ParseRootMapFileNewFormat (ifstream &file, map< string, string > &autoloads);  Parse the rootmap and add entries to the autoload map, using the new format. ;  ; bool ProcessAndAppendIfNotThere (const std::string &el, std::list< std::string > &el_list, std::unordered_set< std::string > &el_set);  Separate multiline strings. ;  ; std::list< std::string > RecordDecl2Headers (const clang::CXXRecordDecl &rcd, const cling::Interpreter &interp, std::set< const clang::CXXRecordDecl * > &visitedDecls);  Extract the list of headers necessary for the Decl. ;  ; void RecordDeclCallback (const clang::RecordDecl *recordDecl);  ; void RiseWarningIfPresent (std::vector< ROOT::option::Option > &options, int optionIndex, const char *descriptor);  ; int ROOT_rootcling_Driver (int argc, char **argv, const ROOT::Internal::RootCling::DriverConfig &config);  ; int RootClingMain (int argc, char **argv, bool isGenreflex=false);  ; void SetRootSys ();  Set the ROOTSYS env var based on the executable location. ;  ; int STLContainerStreamer (const clang::FieldDecl &m, int rwmode, const cling::Interpreter &interp, const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt, std::ostream &dictStream);  Create Streamer code for an STL container. ;  ; int STLStringStreamer (const clang::FieldDecl &m, int rwmode, std::ostream &dictStream);  Create Streamer code for a standard string object. ;  ; void StrcpyArg (string &dest, const char *original);  Copy the command line argument, stripping MODULE/inc if necessary. ;  ; char * genreflex::string2charptr (const std::string &str);  The caller is responsible for deleting the string! ;  ; bool Which (cling::Interpreter &interp, const char *fname, string &pname);  Find file name in path specified via -I statements to Cling. ;  ; void WriteArray",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:48700,Modifiability,variab,variable,48700,"pFiles ; (; ""moduleMapFile"" ; , . llvm::cl::desc(""Specify a C++ modulemap file."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptMultiDict(). static llvm::cl::opt< bool > gOptMultiDict ; (; ""multiDict"" ; , . llvm::cl::desc(""If this library has multiple separate LinkDef files."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptNoDictSelection(). static llvm::cl::opt< bool > gOptNoDictSelection ; (; ""noDictSelection"" ; , . llvm::cl::Hidden ; , . llvm::cl::desc(""Do not run the selection rules. Useful when in -onepcm mode."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptNoGlobalUsingStd(). static llvm::cl::opt< bool > gOptNoGlobalUsingStd ; (; ""noGlobalUsingStd"" ; , . llvm::cl::desc(""Do not declare {using namespace std} in dictionary global scope."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptNoIncludePaths(). static llvm::cl::opt< bool > gOptNoIncludePaths ; (; ""noIncludePaths"" ; , . llvm::cl::desc(""Do not store include paths but rely on the env variable ROOT_INCLUDE_PATH."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptP(). static llvm::cl::opt< bool > gOptP ; (; ""p"" ; , . llvm::cl::desc(""Deprecated, legacy flag which is ignored."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptPPDefines(). static llvm::cl::list< std::string > gOptPPDefines ; (; ""D"" ; , . llvm::cl::Prefix ; , . llvm::cl::ZeroOrMore ; , . llvm::cl::desc(""Specify defined macros."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptPPUndefines(). static llvm::cl::list< std::string > gOptPPUndefines ; (; ""U"" ; , . llvm::cl::Prefix ; , . llvm::cl::ZeroOrMore ; , . llvm::cl::desc(""Specify undefined macros."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptReflex(). static llvm::cl::opt< bool > gOptReflex ; (; ""reflex"" ; , . llvm::cl::desc(""Behave internally like genreflex."") ; , . llvm::cl::cat(gRootclingOptions) ;  . ). static . ◆ gOptRootBuild(). static llvm::cl::opt< bool > gOptRootBuild ;",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:56999,Modifiability,variab,variable,56999,"upportedClassName(). bool IsSupportedClassName ; (; const char * ; name). Definition at line 3439 of file rootcling_impl.cxx. ◆ LoadLibraryMap(). void LoadLibraryMap ; (; const std::string & ; fileListName, . map< string, string > & ; autoloads . ). Fill the map of libraries to be loaded in presence of a class Transparently support the old and new rootmap file format. ; Definition at line 692 of file rootcling_impl.cxx. ◆ MaybeSuppressWin32CrashDialogs(). static void MaybeSuppressWin32CrashDialogs ; (; ). static . Definition at line 3675 of file rootcling_impl.cxx. ◆ ModuleContainsHeaders(). static bool ModuleContainsHeaders ; (; TModuleGenerator & ; modGen, . clang::HeaderSearch & ; headerSearch, . clang::Module * ; module, . std::vector< std::array< std::string, 2 > > & ; missingHeaders . ). static . Returns true iff a given module (and its submodules) contains all headers needed by the given ModuleGenerator. ; The names of all header files that are needed by the ModuleGenerator but are not in the given module will be inserted into the MissingHeader variable. Returns true iff the PCH was successfully generated. ; Definition at line 3881 of file rootcling_impl.cxx. ◆ Namespace__HasMethod(). bool Namespace__HasMethod ; (; const clang::NamespaceDecl * ; cl, . const char * ; name, . const cling::Interpreter & ; interp . ). Definition at line 245 of file rootcling_impl.cxx. ◆ NeedsSelection(). bool NeedsSelection ; (; const char * ; name). Definition at line 3426 of file rootcling_impl.cxx. ◆ ParsePragmaLine(). bool ParsePragmaLine ; (; const std::string & ; line, . const char * ; expectedTokens[], . size_t * ; end = nullptr . ). Check whether the #pragma line contains expectedTokens (0-terminated array). ; Definition at line 549 of file rootcling_impl.cxx. ◆ ParseRootMapFile(). void ParseRootMapFile ; (; ifstream & ; file, . map< string, string > & ; autoloads . ). Parse the rootmap and add entries to the autoload map. ; Definition at line 627 of file rootcling_impl.cx",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:59279,Modifiability,config,config,59279," ; (; const std::string & ; el, . std::list< std::string > & ; el_list, . std::unordered_set< std::string > & ; el_set . ). Separate multiline strings. ; Definition at line 2415 of file rootcling_impl.cxx. ◆ RecordDecl2Headers(). std::list< std::string > RecordDecl2Headers ; (; const clang::CXXRecordDecl & ; rcd, . const cling::Interpreter & ; interp, . std::set< const clang::CXXRecordDecl * > & ; visitedDecls . ). Extract the list of headers necessary for the Decl. ; Definition at line 3086 of file rootcling_impl.cxx. ◆ RecordDeclCallback(). void RecordDeclCallback ; (; const clang::RecordDecl * ; recordDecl). Definition at line 575 of file rootcling_impl.cxx. ◆ RiseWarningIfPresent(). void RiseWarningIfPresent ; (; std::vector< ROOT::option::Option > & ; options, . int ; optionIndex, . const char * ; descriptor . ). Definition at line 5550 of file rootcling_impl.cxx. ◆ ROOT_rootcling_Driver(). int ROOT_rootcling_Driver ; (; int ; argc, . char ** ; argv, . const ROOT::Internal::RootCling::DriverConfig & ; config . ). Definition at line 6225 of file rootcling_impl.cxx. ◆ RootClingMain(). int RootClingMain ; (; int ; argc, . char ** ; argv, . bool ; isGenreflex = false . ). Definition at line 4025 of file rootcling_impl.cxx. ◆ SetRootSys(). void SetRootSys ; (; ). Set the ROOTSYS env var based on the executable location. ; Definition at line 482 of file rootcling_impl.cxx. ◆ STLContainerStreamer(). int STLContainerStreamer ; (; const clang::FieldDecl & ; m, . int ; rwmode, . const cling::Interpreter & ; interp, . const ROOT::TMetaUtils::TNormalizedCtxt & ; normCtxt, . std::ostream & ; dictStream . ). Create Streamer code for an STL container. ; Returns 1 if data member was an STL container and if Streamer code has been created, 0 otherwise. ; Definition at line 855 of file rootcling_impl.cxx. ◆ STLStringStreamer(). int STLStringStreamer ; (; const clang::FieldDecl & ; m, . int ; rwmode, . std::ostream & ; dictStream . ). Create Streamer code for a standard string obje",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:23645,Performance,load,loaded,23645,"::vector< std::string > &preprocDefines, const std::vector< std::string > &preprocUndefines, const std::vector< std::string > &warnings, const std::string &rootmapFileName, const std::string &rootmapLibName, bool interpreteronly, bool doSplit, bool isCxxmodule, bool writeEmptyRootPCM, bool selSyntaxOnly, bool noIncludePaths, bool noGlobalUsingStd, const std::vector< std::string > &headersNames, bool failOnWarnings, bool printRootclingInvocation, const std::string &ofilename);  ; bool IsCorrectClingArgument (const std::string &argument);  Check if the argument is a sane cling argument. ;  ; bool IsGoodForAutoParseMap (const clang::RecordDecl &rcd);  Check if the class good for being an autoparse key. ;  ; bool IsGoodLibraryName (const std::string &name);  ; bool IsImplementationName (const std::string &filename);  ; bool IsLinkdefFile (const clang::PresumedLoc &PLoc);  ; bool isPointerToPointer (const clang::FieldDecl &m);  ; bool IsSelectionFile (const char *filename);  ; bool IsSelectionXml (const char *filename);  ; bool IsSupportedClassName (const char *name);  ; void LoadLibraryMap (const std::string &fileListName, map< string, string > &autoloads);  Fill the map of libraries to be loaded in presence of a class Transparently support the old and new rootmap file format. ;  ; static void MaybeSuppressWin32CrashDialogs ();  ; static bool ModuleContainsHeaders (TModuleGenerator &modGen, clang::HeaderSearch &headerSearch, clang::Module *module, std::vector< std::array< std::string, 2 > > &missingHeaders);  Returns true iff a given module (and its submodules) contains all headers needed by the given ModuleGenerator. ;  ; bool Namespace__HasMethod (const clang::NamespaceDecl *cl, const char *name, const cling::Interpreter &interp);  ; bool NeedsSelection (const char *name);  ; bool ParsePragmaLine (const std::string &line, const char *expectedTokens[], size_t *end=nullptr);  Check whether the #pragma line contains expectedTokens (0-terminated array). ;  ; void ParseRoot",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:56213,Performance,load,loaded,56213,"563 of file rootcling_impl.cxx. ◆ IsImplementationName(). bool IsImplementationName ; (; const std::string & ; filename). Definition at line 3410 of file rootcling_impl.cxx. ◆ IsLinkdefFile(). bool IsLinkdefFile ; (; const clang::PresumedLoc & ; PLoc). Definition at line 467 of file rootcling_impl.cxx. ◆ isPointerToPointer(). bool isPointerToPointer ; (; const clang::FieldDecl & ; m). Definition at line 1152 of file rootcling_impl.cxx. ◆ IsSelectionFile(). bool IsSelectionFile ; (; const char * ; filename). Definition at line 474 of file rootcling_impl.cxx. ◆ IsSelectionXml(). bool IsSelectionXml ; (; const char * ; filename). Definition at line 454 of file rootcling_impl.cxx. ◆ IsSupportedClassName(). bool IsSupportedClassName ; (; const char * ; name). Definition at line 3439 of file rootcling_impl.cxx. ◆ LoadLibraryMap(). void LoadLibraryMap ; (; const std::string & ; fileListName, . map< string, string > & ; autoloads . ). Fill the map of libraries to be loaded in presence of a class Transparently support the old and new rootmap file format. ; Definition at line 692 of file rootcling_impl.cxx. ◆ MaybeSuppressWin32CrashDialogs(). static void MaybeSuppressWin32CrashDialogs ; (; ). static . Definition at line 3675 of file rootcling_impl.cxx. ◆ ModuleContainsHeaders(). static bool ModuleContainsHeaders ; (; TModuleGenerator & ; modGen, . clang::HeaderSearch & ; headerSearch, . clang::Module * ; module, . std::vector< std::array< std::string, 2 > > & ; missingHeaders . ). static . Returns true iff a given module (and its submodules) contains all headers needed by the given ModuleGenerator. ; The names of all header files that are needed by the ModuleGenerator but are not in the given module will be inserted into the MissingHeader variable. Returns true iff the PCH was successfully generated. ; Definition at line 3881 of file rootcling_impl.cxx. ◆ Namespace__HasMethod(). bool Namespace__HasMethod ; (; const clang::NamespaceDecl * ; cl, . const char * ; name, . const cl",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:10343,Safety,detect,detectedUmbrella,10343," dictionary parsing is done and these headers cannot be selected anymore. ;  ; static llvm::cl::SubCommand gBareClingSubcommand (""bare-cling"", ""Call directly cling and exit."");  ; static bool GenerateAllDict (TModuleGenerator &modGen, clang::CompilerInstance *compilerInstance, const std::string &currentDirectory);  Generates a PCH from the given ModuleGenerator and CompilerInstance. ;  ; int GenerateFullDict (std::ostream &dictStream, cling::Interpreter &interp, RScanner &scan, const ROOT::TMetaUtils::RConstructorTypes &ctorTypes, bool isSplit, bool isGenreflex, bool isSelXML, bool writeEmptyRootPCM);  ; static std::string GenerateFwdDeclString (const RScanner &scan, const cling::Interpreter &interp);  Generate the fwd declarations of the selected entities. ;  ; void GenerateLinkdef (llvm::cl::list< std::string > &InputFiles, std::string &code_for_parser);  ; void GenerateNecessaryIncludes (std::ostream &dictStream, const std::string &includeForSource, const std::string &extraIncludes);  ; const std::string GenerateStringFromHeadersForClasses (const HeadersDeclsMap_t &headersClassesMap, const std::string &detectedUmbrella, bool payLoadOnly=false);  Generate a string for the dictionary from the headers-classes map. ;  ; int GenReflexMain (int argc, char **argv);  Translate the arguments of genreflex into rootcling ones and forward them to the RootCling function. ;  ; const char * GetExePath ();  Returns the executable path name, used e.g. by SetRootSys(). ;  ; std::pair< std::string, std::string > GetExternalNamespaceAndContainedEntities (const std::string line);  Performance is not critical here. ;  ; size_t GetFullArrayLength (const clang::ConstantArrayType *arrayType);  ; std::string GetFwdDeclnArgsToKeepString (const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt, cling::Interpreter &interp);  ; static llvm::StringRef GetModuleNameFromRdictName (llvm::StringRef rdictName);  ; void GetMostExternalEnclosingClassName (const clang::DeclContext &theContext, std::string &",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:38756,Safety,detect,detectedUmbrella,38756,"ctorTypes, . bool ; isSplit, . bool ; isGenreflex, . bool ; isSelXML, . bool ; writeEmptyRootPCM . ). Definition at line 2652 of file rootcling_impl.cxx. ◆ GenerateFwdDeclString(). static std::string GenerateFwdDeclString ; (; const RScanner & ; scan, . const cling::Interpreter & ; interp . ). static . Generate the fwd declarations of the selected entities. ; Definition at line 3302 of file rootcling_impl.cxx. ◆ GenerateLinkdef(). void GenerateLinkdef ; (; llvm::cl::list< std::string > & ; InputFiles, . std::string & ; code_for_parser . ). Definition at line 1847 of file rootcling_impl.cxx. ◆ GenerateNecessaryIncludes(). void GenerateNecessaryIncludes ; (; std::ostream & ; dictStream, . const std::string & ; includeForSource, . const std::string & ; extraIncludes . ). Definition at line 2862 of file rootcling_impl.cxx. ◆ GenerateStringFromHeadersForClasses(). const std::string GenerateStringFromHeadersForClasses ; (; const HeadersDeclsMap_t & ; headersClassesMap, . const std::string & ; detectedUmbrella, . bool ; payLoadOnly = false . ). Generate a string for the dictionary from the headers-classes map. ; Definition at line 3378 of file rootcling_impl.cxx. ◆ GenReflexMain(). int GenReflexMain ; (; int ; argc, . char ** ; argv . ). Translate the arguments of genreflex into rootcling ones and forward them to the RootCling function. ; These are two typical genreflex and rootcling commandlines 1) genreflex header1.h [header2.h ...] [options] [preprocessor options] 2) rootcling [-v] [-v0-4] [-f] [out.cxx] [-s sharedlib.so] [-m pcmfilename] header1.h[{+,-}][!] ..headerN.h[{+,-}][!] [{LinkDef.h,selectionRules.xml}] The rules with which the arguments are translated are (1st column genreflex): –debug -v4 –quiet -v0 -o ofile positional arg after -f -s selection file Last argument of the call –fail_on_warning Wrap ROOT::TMetaUtils::Warning and throw if selected; New arguments: -l –library targetLib name (new) -s targetLib name -m pcmname (can be many -m) (new) -m pcmname (can ",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:21271,Security,inject,injected,21271,"ldDecl &member, int printError);  GrabIndex returns a static string (so use it or copy it immediately, do not call GrabIndex twice in the same expression) containing the size of the array data member. ;  ; static llvm::cl::OptionCategory gRootclingOptions (""rootcling common options"");  ; bool HasPath (const std::string &name);  Check if file has a path. ;  ; void genreflex::header2outputName (std::string &fileName);  Replace the extension with ""_rflx.cpp"". ;  ; void genreflex::headers2outputsNames (const std::vector< std::string > &headersNames, std::vector< std::string > &ofilesnames);  Get a proper name for the output file. ;  ; static bool IncludeHeaders (const std::vector< std::string > &headers, cling::Interpreter &interpreter);  Includes all given headers in the interpreter. ;  ; bool InheritsFromTObject (const clang::RecordDecl *cl, const cling::Interpreter &interp);  ; bool InheritsFromTSelector (const clang::RecordDecl *cl, const cling::Interpreter &interp);  ; static bool InjectModuleUtilHeader (const char *argv0, TModuleGenerator &modGen, cling::Interpreter &interp, bool umbrella);  Write the extra header injected into the module: umbrella header if (umbrella) else content header. ;  ; int genreflex::invokeManyRootCling (const std::string &verbosity, const std::string &selectionFileName, const std::string &targetLibName, bool multiDict, const std::vector< std::string > &pcmsNames, const std::vector< std::string > &includes, const std::vector< std::string > &preprocDefines, const std::vector< std::string > &preprocUndefines, const std::vector< std::string > &warnings, const std::string &rootmapFileName, const std::string &rootmapLibName, bool interpreteronly, bool doSplit, bool isCxxmodule, bool writeEmptyRootPCM, bool selSyntaxOnly, bool noIncludePaths, bool noGlobalUsingStd, const std::vector< std::string > &headersNames, bool failOnWarnings, bool printRootclingInvocation, const std::string &outputDirName_const="""");  Get the right ofilenames and invoke se",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:54426,Security,inject,injected,54426,"Definition at line 2166 of file rootcling_impl.cxx. ◆ IncludeHeaders(). static bool IncludeHeaders ; (; const std::vector< std::string > & ; headers, . cling::Interpreter & ; interpreter . ). static . Includes all given headers in the interpreter. ; Returns true when we could include the headers and otherwise false on an error when including. ; Definition at line 2048 of file rootcling_impl.cxx. ◆ InheritsFromTObject(). bool InheritsFromTObject ; (; const clang::RecordDecl * ; cl, . const cling::Interpreter & ; interp . ). Definition at line 431 of file rootcling_impl.cxx. ◆ InheritsFromTSelector(). bool InheritsFromTSelector ; (; const clang::RecordDecl * ; cl, . const cling::Interpreter & ; interp . ). Definition at line 443 of file rootcling_impl.cxx. ◆ InjectModuleUtilHeader(). static bool InjectModuleUtilHeader ; (; const char * ; argv0, . TModuleGenerator & ; modGen, . cling::Interpreter & ; interp, . bool ; umbrella . ). static . Write the extra header injected into the module: umbrella header if (umbrella) else content header. ; Definition at line 1972 of file rootcling_impl.cxx. ◆ IsCorrectClingArgument(). bool IsCorrectClingArgument ; (; const std::string & ; argument). Check if the argument is a sane cling argument. ; Performing the following checks: 1) It does not start with ""--"" and is not the –param option. ; Definition at line 3419 of file rootcling_impl.cxx. ◆ IsGoodForAutoParseMap(). bool IsGoodForAutoParseMap ; (; const clang::RecordDecl & ; rcd). Check if the class good for being an autoparse key. ; We exclude from this set stl containers of pods/strings TODO: we may use also __gnu_cxx:: ; Definition at line 3169 of file rootcling_impl.cxx. ◆ IsGoodLibraryName(). bool IsGoodLibraryName ; (; const std::string & ; name). Definition at line 5563 of file rootcling_impl.cxx. ◆ IsImplementationName(). bool IsImplementationName ; (; const std::string & ; filename). Definition at line 3410 of file rootcling_impl.cxx. ◆ IsLinkdefFile(). bool IsLinkdefFile ",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx.html:39850,Usability,feedback,feedback,39850," ). Generate a string for the dictionary from the headers-classes map. ; Definition at line 3378 of file rootcling_impl.cxx. ◆ GenReflexMain(). int GenReflexMain ; (; int ; argc, . char ** ; argv . ). Translate the arguments of genreflex into rootcling ones and forward them to the RootCling function. ; These are two typical genreflex and rootcling commandlines 1) genreflex header1.h [header2.h ...] [options] [preprocessor options] 2) rootcling [-v] [-v0-4] [-f] [out.cxx] [-s sharedlib.so] [-m pcmfilename] header1.h[{+,-}][!] ..headerN.h[{+,-}][!] [{LinkDef.h,selectionRules.xml}] The rules with which the arguments are translated are (1st column genreflex): –debug -v4 –quiet -v0 -o ofile positional arg after -f -s selection file Last argument of the call –fail_on_warning Wrap ROOT::TMetaUtils::Warning and throw if selected; New arguments: -l –library targetLib name (new) -s targetLib name -m pcmname (can be many -m) (new) -m pcmname (can be many -m) –rootmap -rmf (new) –rootmap-lib -rml (new); genreflex options which rise warnings (feedback is desirable) –no_membertypedefs (it should be irrelevant) –no_templatetypedefs (it should be irrelevant); genreflex options which are ignored (know for sure they are not needed) –pool, –dataonly –interpreteronly –gccxml{path,opt,post}; Exceptions The –deep option of genreflex is passed as function parameter to rootcling since it's not needed at the moment there. ; Definition at line 5608 of file rootcling_impl.cxx. ◆ GetExePath(). const char * GetExePath ; (; ). Returns the executable path name, used e.g. by SetRootSys(). ; Definition at line 196 of file rootcling_impl.cxx. ◆ GetExternalNamespaceAndContainedEntities(). std::pair< std::string, std::string > GetExternalNamespaceAndContainedEntities ; (; const std::string ; line). Performance is not critical here. ; Definition at line 2356 of file rootcling_impl.cxx. ◆ GetFullArrayLength(). size_t GetFullArrayLength ; (; const clang::ConstantArrayType * ; arrayType). Definition at li",MatchSource.WIKI,doc/master/rootcling__impl_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:1459,Availability,error,error,1459,"he licensing terms see $ROOTSYS/LICENSE. *; 8 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11#include ""rootcling_impl.h""; 12#include ""rootclingCommandLineOptionsHelp.h""; 13 ; 14#include ""RConfigure.h""; 15#include <ROOT/RConfig.hxx>; 16#include <ROOT/FoundationUtils.hxx>; 17#include ""snprintf.h""; 18 ; 19#include <iostream>; 20#include <iomanip>; 21#include <memory>; 22#include <vector>; 23#include <algorithm>; 24#include <cstdio>; 25 ; 26#include <errno.h>; 27#include <string>; 28#include <list>; 29#include <sstream>; 30#include <map>; 31#include <fstream>; 32#include <sys/stat.h>; 33#include <unordered_map>; 34#include <unordered_set>; 35#include <numeric>; 36 ; 37 ; 38#ifdef _WIN32; 39#ifdef system; 40#undef system; 41#endif; 42#undef UNICODE; 43#include <windows.h>; 44#include <Tlhelp32.h> // for MAX_MODULE_NAME32; 45#include <process.h>; 46#define PATH_MAX _MAX_PATH; 47#ifdef interface; 48// prevent error coming from clang/AST/Attrs.inc; 49#undef interface; 50#endif; 51#endif; 52 ; 53#ifdef __APPLE__; 54#include <mach-o/dyld.h>; 55#endif; 56 ; 57#ifdef R__FBSD; 58#include <sys/param.h>; 59#include <sys/user.h>; 60#include <sys/types.h>; 61#include <libutil.h>; 62#include <libprocstat.h>; 63#endif // R__FBSD; 64 ; 65#if !defined(R__WIN32); 66#include <limits.h>; 67#include <unistd.h>; 68#endif; 69 ; 70 ; 71#include ""cling/Interpreter/Interpreter.h""; 72#include ""cling/Interpreter/InterpreterCallbacks.h""; 73#include ""cling/Interpreter/LookupHelper.h""; 74#include ""cling/Interpreter/Value.h""; 75#include ""clang/AST/CXXInheritance.h""; 76#include ""clang/Basic/Diagnostic.h""; 77#include ""clang/Frontend/CompilerInstance.h""; 78#include ""clang/Frontend/FrontendActions.h""; 79#include ""clang/Frontend/FrontendDiagnostic.h""; 80#include ""clang/Lex/HeaderSearch.h""; 81#include ""clang/Lex/Preprocessor.h""; 82#include ""clang/Lex/ModuleMap.h""; 83#include ""clang/Lex/Pragma.h""; 84#include """,MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:17711,Availability,error,error,17711,"e + (len - xmllen), "".xml""));; 460 } else {; 461 return false;; 462 }; 463}; 464 ; 465////////////////////////////////////////////////////////////////////////////////; 466 ; 467bool IsLinkdefFile(const clang::PresumedLoc& PLoc); 468{; 469 return ROOT::TMetaUtils::IsLinkdefFile(PLoc.getFilename());; 470}; 471 ; 472////////////////////////////////////////////////////////////////////////////////; 473 ; 474bool IsSelectionFile(const char *filename); 475{; 476 return ROOT::TMetaUtils::IsLinkdefFile(filename) || IsSelectionXml(filename);; 477}; 478 ; 479////////////////////////////////////////////////////////////////////////////////; 480/// Set the ROOTSYS env var based on the executable location.; 481 ; 482void SetRootSys(); 483{; 484 const char *exepath = GetExePath();; 485 if (exepath && *exepath) {; 486#if !defined(_WIN32); 487 char *ep = new char[PATH_MAX];; 488 if (!realpath(exepath, ep)) {; 489 fprintf(stderr, ""rootcling: error getting realpath of rootcling!"");; 490 strlcpy(ep, exepath, PATH_MAX);; 491 }; 492#else; 493 int nche = strlen(exepath) + 1;; 494 char *ep = new char[nche];; 495 strlcpy(ep, exepath, nche);; 496#endif; 497 char *s;; 498 ; 499 if ((s = strrchr(ep, '/'))) {; 500 // $ROOTSYS/bin/rootcling; 501 int removesubdirs = 2;; 502 if (!strncmp(s + 1, ""rootcling_stage1.exe"", 20)) {; 503 // $ROOTSYS/bin/rootcling_stage1.exe; 504 removesubdirs = 2;; 505 gBuildingROOT = true;; 506 } else if (!strncmp(s + 1, ""rootcling_stage1"", 16)) {; 507 // $ROOTSYS/core/rootcling_stage1/src/rootcling_stage1; 508 removesubdirs = 4;; 509 gBuildingROOT = true;; 510 }; 511 for (int i = 1; s && i < removesubdirs; ++i) {; 512 *s = 0;; 513 s = strrchr(ep, '/');; 514 }; 515 if (s) *s = 0;; 516 } else {; 517 // There was no slashes at all let now change ROOTSYS; 518 delete [] ep;; 519 return;; 520 }; 521 ; 522 if (!gBuildingROOT) {; 523 delete [] ep;; 524 return; // don't mess with user's ROOTSYS.; 525 }; 526 ; 527 int ncha = strlen(ep) + 10;; 528 char *env = new char[ncha];; 529 sn",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:25965,Availability,error,error,25965,"aUtils::GetFuncWithProto(llvm::dyn_cast<clang::Decl>(cl->getDeclContext()), what, proto, interp,; 737 false /*diags*/);; 738 if (!method) {; 739 // This intended to find the global scope.; 740 clang::TranslationUnitDecl *TU =; 741 cl->getASTContext().getTranslationUnitDecl();; 742 method = ROOT::TMetaUtils::GetFuncWithProto(TU, what, proto, interp,; 743 false /*diags*/);; 744 }; 745 bool has_input_error = false;; 746 if (method != nullptr && (method->getAccess() == clang::AS_public || method->getAccess() == clang::AS_none)) {; 747 std::string filename = ROOT::TMetaUtils::GetFileName(*method, interp);; 748 if (strstr(filename.c_str(), ""TBuffer.h"") != nullptr ||; 749 strstr(filename.c_str(), ""Rtypes.h"") != nullptr) {; 750 ; 751 has_input_error = true;; 752 }; 753 } else {; 754 has_input_error = true;; 755 }; 756 if (has_input_error) {; 757 // We don't want to generate duplicated error messages in several dictionaries (when generating temporaries); 758 const char *maybeconst = """";; 759 const char *mayberef = ""&"";; 760 if (what[strlen(what) - 1] == '<') {; 761 maybeconst = ""const "";; 762 mayberef = """";; 763 }; 764 ROOT::TMetaUtils::Error(nullptr,; 765 ""in this version of ROOT, the option '!' used in a linkdef file\n""; 766 "" implies the actual existence of customized operators.\n""; 767 "" The following declaration is now required:\n""; 768 "" TBuffer &%s(TBuffer &,%s%s *%s);\n"", what, maybeconst, fullname.c_str(), mayberef);; 769 }; 770 return has_input_error;; 771 ; 772}; 773 ; 774////////////////////////////////////////////////////////////////////////////////; 775/// Check if the operator>> has been properly declared if the user has; 776/// requested a custom version.; 777 ; 778bool CheckInputOperator(const clang::RecordDecl *cl, cling::Interpreter &interp); 779{; 780 string fullname;; 781 ROOT::TMetaUtils::GetQualifiedName(fullname, *cl);; 782 int ncha = fullname.length() + 13;; 783 char *proto = new char[ncha];; 784 snprintf(proto, ncha, ""TBuffer&,%s*&"", fullname.c_str(",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:50923,Availability,error,error,50923,"rk; 1329 << "" static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstance();""; 1330 << "" R__UseDummy(_R__UNIQUE_DICT_(Init));"" << std::endl;; 1331 ; 1332 if (!Namespace__HasMethod(cl, ""Dictionary"", interp)) {; 1333 dictStream << std::endl << "" // Dictionary for non-ClassDef classes"" << std::endl; 1334 << "" static TClass *"" << mappedname.c_str() << ""_Dictionary() {"" << std::endl; 1335 << "" return GenerateInitInstance()->GetClass();"" << std::endl; 1336 << "" }"" << std::endl << std::endl;; 1337 }; 1338 ; 1339 dictStream << "" }"" << std::endl;; 1340 while (nesting--) {; 1341 dictStream << ""}"" << std::endl;; 1342 }; 1343 dictStream << std::endl;; 1344}; 1345 ; 1346////////////////////////////////////////////////////////////////////////////////; 1347/// GrabIndex returns a static string (so use it or copy it immediately, do not; 1348/// call GrabIndex twice in the same expression) containing the size of the; 1349/// array data member.; 1350/// In case of error, or if the size is not specified, GrabIndex returns 0.; 1351 ; 1352llvm::StringRef GrabIndex(const cling::Interpreter& interp, const clang::FieldDecl &member, int printError); 1353{; 1354 int error;; 1355 llvm::StringRef where;; 1356 ; 1357 llvm::StringRef index = ROOT::TMetaUtils::DataMemberInfo__ValidArrayIndex(interp, member, &error, &where);; 1358 if (index.size() == 0 && printError) {; 1359 const char *errorstring;; 1360 switch (error) {; 1361 case TMetaUtils::NOT_INT:; 1362 errorstring = ""is not an integer"";; 1363 break;; 1364 case TMetaUtils::NOT_DEF:; 1365 errorstring = ""has not been defined before the array"";; 1366 break;; 1367 case TMetaUtils::IS_PRIVATE:; 1368 errorstring = ""is a private member of a parent class"";; 1369 break;; 1370 case TMetaUtils::UNKNOWN:; 1371 errorstring = ""is not known"";; 1372 break;; 1373 default:; 1374 errorstring = ""UNKNOWN ERROR!!!!"";; 1375 }; 1376 ; 1377 if (where.size() == 0) {; 1378 ROOT::TMetaUtils::Error(nullptr, ""*** Datamember %s::%s: no size indication!\",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:51121,Availability,error,error,51121,"hod(cl, ""Dictionary"", interp)) {; 1333 dictStream << std::endl << "" // Dictionary for non-ClassDef classes"" << std::endl; 1334 << "" static TClass *"" << mappedname.c_str() << ""_Dictionary() {"" << std::endl; 1335 << "" return GenerateInitInstance()->GetClass();"" << std::endl; 1336 << "" }"" << std::endl << std::endl;; 1337 }; 1338 ; 1339 dictStream << "" }"" << std::endl;; 1340 while (nesting--) {; 1341 dictStream << ""}"" << std::endl;; 1342 }; 1343 dictStream << std::endl;; 1344}; 1345 ; 1346////////////////////////////////////////////////////////////////////////////////; 1347/// GrabIndex returns a static string (so use it or copy it immediately, do not; 1348/// call GrabIndex twice in the same expression) containing the size of the; 1349/// array data member.; 1350/// In case of error, or if the size is not specified, GrabIndex returns 0.; 1351 ; 1352llvm::StringRef GrabIndex(const cling::Interpreter& interp, const clang::FieldDecl &member, int printError); 1353{; 1354 int error;; 1355 llvm::StringRef where;; 1356 ; 1357 llvm::StringRef index = ROOT::TMetaUtils::DataMemberInfo__ValidArrayIndex(interp, member, &error, &where);; 1358 if (index.size() == 0 && printError) {; 1359 const char *errorstring;; 1360 switch (error) {; 1361 case TMetaUtils::NOT_INT:; 1362 errorstring = ""is not an integer"";; 1363 break;; 1364 case TMetaUtils::NOT_DEF:; 1365 errorstring = ""has not been defined before the array"";; 1366 break;; 1367 case TMetaUtils::IS_PRIVATE:; 1368 errorstring = ""is a private member of a parent class"";; 1369 break;; 1370 case TMetaUtils::UNKNOWN:; 1371 errorstring = ""is not known"";; 1372 break;; 1373 default:; 1374 errorstring = ""UNKNOWN ERROR!!!!"";; 1375 }; 1376 ; 1377 if (where.size() == 0) {; 1378 ROOT::TMetaUtils::Error(nullptr, ""*** Datamember %s::%s: no size indication!\n"",; 1379 member.getParent()->getName().str().c_str(), member.getName().str().c_str());; 1380 } else {; 1381 ROOT::TMetaUtils::Error(nullptr, ""*** Datamember %s::%s: size of array (%s) %s!\n"",; 1",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:51261,Availability,error,error,51261,"hod(cl, ""Dictionary"", interp)) {; 1333 dictStream << std::endl << "" // Dictionary for non-ClassDef classes"" << std::endl; 1334 << "" static TClass *"" << mappedname.c_str() << ""_Dictionary() {"" << std::endl; 1335 << "" return GenerateInitInstance()->GetClass();"" << std::endl; 1336 << "" }"" << std::endl << std::endl;; 1337 }; 1338 ; 1339 dictStream << "" }"" << std::endl;; 1340 while (nesting--) {; 1341 dictStream << ""}"" << std::endl;; 1342 }; 1343 dictStream << std::endl;; 1344}; 1345 ; 1346////////////////////////////////////////////////////////////////////////////////; 1347/// GrabIndex returns a static string (so use it or copy it immediately, do not; 1348/// call GrabIndex twice in the same expression) containing the size of the; 1349/// array data member.; 1350/// In case of error, or if the size is not specified, GrabIndex returns 0.; 1351 ; 1352llvm::StringRef GrabIndex(const cling::Interpreter& interp, const clang::FieldDecl &member, int printError); 1353{; 1354 int error;; 1355 llvm::StringRef where;; 1356 ; 1357 llvm::StringRef index = ROOT::TMetaUtils::DataMemberInfo__ValidArrayIndex(interp, member, &error, &where);; 1358 if (index.size() == 0 && printError) {; 1359 const char *errorstring;; 1360 switch (error) {; 1361 case TMetaUtils::NOT_INT:; 1362 errorstring = ""is not an integer"";; 1363 break;; 1364 case TMetaUtils::NOT_DEF:; 1365 errorstring = ""has not been defined before the array"";; 1366 break;; 1367 case TMetaUtils::IS_PRIVATE:; 1368 errorstring = ""is a private member of a parent class"";; 1369 break;; 1370 case TMetaUtils::UNKNOWN:; 1371 errorstring = ""is not known"";; 1372 break;; 1373 default:; 1374 errorstring = ""UNKNOWN ERROR!!!!"";; 1375 }; 1376 ; 1377 if (where.size() == 0) {; 1378 ROOT::TMetaUtils::Error(nullptr, ""*** Datamember %s::%s: no size indication!\n"",; 1379 member.getParent()->getName().str().c_str(), member.getName().str().c_str());; 1380 } else {; 1381 ROOT::TMetaUtils::Error(nullptr, ""*** Datamember %s::%s: size of array (%s) %s!\n"",; 1",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:51340,Availability,error,errorstring,51340,"; 1342 }; 1343 dictStream << std::endl;; 1344}; 1345 ; 1346////////////////////////////////////////////////////////////////////////////////; 1347/// GrabIndex returns a static string (so use it or copy it immediately, do not; 1348/// call GrabIndex twice in the same expression) containing the size of the; 1349/// array data member.; 1350/// In case of error, or if the size is not specified, GrabIndex returns 0.; 1351 ; 1352llvm::StringRef GrabIndex(const cling::Interpreter& interp, const clang::FieldDecl &member, int printError); 1353{; 1354 int error;; 1355 llvm::StringRef where;; 1356 ; 1357 llvm::StringRef index = ROOT::TMetaUtils::DataMemberInfo__ValidArrayIndex(interp, member, &error, &where);; 1358 if (index.size() == 0 && printError) {; 1359 const char *errorstring;; 1360 switch (error) {; 1361 case TMetaUtils::NOT_INT:; 1362 errorstring = ""is not an integer"";; 1363 break;; 1364 case TMetaUtils::NOT_DEF:; 1365 errorstring = ""has not been defined before the array"";; 1366 break;; 1367 case TMetaUtils::IS_PRIVATE:; 1368 errorstring = ""is a private member of a parent class"";; 1369 break;; 1370 case TMetaUtils::UNKNOWN:; 1371 errorstring = ""is not known"";; 1372 break;; 1373 default:; 1374 errorstring = ""UNKNOWN ERROR!!!!"";; 1375 }; 1376 ; 1377 if (where.size() == 0) {; 1378 ROOT::TMetaUtils::Error(nullptr, ""*** Datamember %s::%s: no size indication!\n"",; 1379 member.getParent()->getName().str().c_str(), member.getName().str().c_str());; 1380 } else {; 1381 ROOT::TMetaUtils::Error(nullptr, ""*** Datamember %s::%s: size of array (%s) %s!\n"",; 1382 member.getParent()->getName().str().c_str(), member.getName().str().c_str(), where.str().c_str(), errorstring);; 1383 }; 1384 }; 1385 return index;; 1386}; 1387 ; 1388////////////////////////////////////////////////////////////////////////////////; 1389 ; 1390void WriteStreamer(const ROOT::TMetaUtils::AnnotatedRecordDecl &cl,; 1391 const cling::Interpreter &interp,; 1392 const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt,; 1",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:51367,Availability,error,error,51367,"; 1342 }; 1343 dictStream << std::endl;; 1344}; 1345 ; 1346////////////////////////////////////////////////////////////////////////////////; 1347/// GrabIndex returns a static string (so use it or copy it immediately, do not; 1348/// call GrabIndex twice in the same expression) containing the size of the; 1349/// array data member.; 1350/// In case of error, or if the size is not specified, GrabIndex returns 0.; 1351 ; 1352llvm::StringRef GrabIndex(const cling::Interpreter& interp, const clang::FieldDecl &member, int printError); 1353{; 1354 int error;; 1355 llvm::StringRef where;; 1356 ; 1357 llvm::StringRef index = ROOT::TMetaUtils::DataMemberInfo__ValidArrayIndex(interp, member, &error, &where);; 1358 if (index.size() == 0 && printError) {; 1359 const char *errorstring;; 1360 switch (error) {; 1361 case TMetaUtils::NOT_INT:; 1362 errorstring = ""is not an integer"";; 1363 break;; 1364 case TMetaUtils::NOT_DEF:; 1365 errorstring = ""has not been defined before the array"";; 1366 break;; 1367 case TMetaUtils::IS_PRIVATE:; 1368 errorstring = ""is a private member of a parent class"";; 1369 break;; 1370 case TMetaUtils::UNKNOWN:; 1371 errorstring = ""is not known"";; 1372 break;; 1373 default:; 1374 errorstring = ""UNKNOWN ERROR!!!!"";; 1375 }; 1376 ; 1377 if (where.size() == 0) {; 1378 ROOT::TMetaUtils::Error(nullptr, ""*** Datamember %s::%s: no size indication!\n"",; 1379 member.getParent()->getName().str().c_str(), member.getName().str().c_str());; 1380 } else {; 1381 ROOT::TMetaUtils::Error(nullptr, ""*** Datamember %s::%s: size of array (%s) %s!\n"",; 1382 member.getParent()->getName().str().c_str(), member.getName().str().c_str(), where.str().c_str(), errorstring);; 1383 }; 1384 }; 1385 return index;; 1386}; 1387 ; 1388////////////////////////////////////////////////////////////////////////////////; 1389 ; 1390void WriteStreamer(const ROOT::TMetaUtils::AnnotatedRecordDecl &cl,; 1391 const cling::Interpreter &interp,; 1392 const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt,; 1",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:51414,Availability,error,errorstring,51414,"; 1342 }; 1343 dictStream << std::endl;; 1344}; 1345 ; 1346////////////////////////////////////////////////////////////////////////////////; 1347/// GrabIndex returns a static string (so use it or copy it immediately, do not; 1348/// call GrabIndex twice in the same expression) containing the size of the; 1349/// array data member.; 1350/// In case of error, or if the size is not specified, GrabIndex returns 0.; 1351 ; 1352llvm::StringRef GrabIndex(const cling::Interpreter& interp, const clang::FieldDecl &member, int printError); 1353{; 1354 int error;; 1355 llvm::StringRef where;; 1356 ; 1357 llvm::StringRef index = ROOT::TMetaUtils::DataMemberInfo__ValidArrayIndex(interp, member, &error, &where);; 1358 if (index.size() == 0 && printError) {; 1359 const char *errorstring;; 1360 switch (error) {; 1361 case TMetaUtils::NOT_INT:; 1362 errorstring = ""is not an integer"";; 1363 break;; 1364 case TMetaUtils::NOT_DEF:; 1365 errorstring = ""has not been defined before the array"";; 1366 break;; 1367 case TMetaUtils::IS_PRIVATE:; 1368 errorstring = ""is a private member of a parent class"";; 1369 break;; 1370 case TMetaUtils::UNKNOWN:; 1371 errorstring = ""is not known"";; 1372 break;; 1373 default:; 1374 errorstring = ""UNKNOWN ERROR!!!!"";; 1375 }; 1376 ; 1377 if (where.size() == 0) {; 1378 ROOT::TMetaUtils::Error(nullptr, ""*** Datamember %s::%s: no size indication!\n"",; 1379 member.getParent()->getName().str().c_str(), member.getName().str().c_str());; 1380 } else {; 1381 ROOT::TMetaUtils::Error(nullptr, ""*** Datamember %s::%s: size of array (%s) %s!\n"",; 1382 member.getParent()->getName().str().c_str(), member.getName().str().c_str(), where.str().c_str(), errorstring);; 1383 }; 1384 }; 1385 return index;; 1386}; 1387 ; 1388////////////////////////////////////////////////////////////////////////////////; 1389 ; 1390void WriteStreamer(const ROOT::TMetaUtils::AnnotatedRecordDecl &cl,; 1391 const cling::Interpreter &interp,; 1392 const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt,; 1",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:51500,Availability,error,errorstring,51500,"; 1342 }; 1343 dictStream << std::endl;; 1344}; 1345 ; 1346////////////////////////////////////////////////////////////////////////////////; 1347/// GrabIndex returns a static string (so use it or copy it immediately, do not; 1348/// call GrabIndex twice in the same expression) containing the size of the; 1349/// array data member.; 1350/// In case of error, or if the size is not specified, GrabIndex returns 0.; 1351 ; 1352llvm::StringRef GrabIndex(const cling::Interpreter& interp, const clang::FieldDecl &member, int printError); 1353{; 1354 int error;; 1355 llvm::StringRef where;; 1356 ; 1357 llvm::StringRef index = ROOT::TMetaUtils::DataMemberInfo__ValidArrayIndex(interp, member, &error, &where);; 1358 if (index.size() == 0 && printError) {; 1359 const char *errorstring;; 1360 switch (error) {; 1361 case TMetaUtils::NOT_INT:; 1362 errorstring = ""is not an integer"";; 1363 break;; 1364 case TMetaUtils::NOT_DEF:; 1365 errorstring = ""has not been defined before the array"";; 1366 break;; 1367 case TMetaUtils::IS_PRIVATE:; 1368 errorstring = ""is a private member of a parent class"";; 1369 break;; 1370 case TMetaUtils::UNKNOWN:; 1371 errorstring = ""is not known"";; 1372 break;; 1373 default:; 1374 errorstring = ""UNKNOWN ERROR!!!!"";; 1375 }; 1376 ; 1377 if (where.size() == 0) {; 1378 ROOT::TMetaUtils::Error(nullptr, ""*** Datamember %s::%s: no size indication!\n"",; 1379 member.getParent()->getName().str().c_str(), member.getName().str().c_str());; 1380 } else {; 1381 ROOT::TMetaUtils::Error(nullptr, ""*** Datamember %s::%s: size of array (%s) %s!\n"",; 1382 member.getParent()->getName().str().c_str(), member.getName().str().c_str(), where.str().c_str(), errorstring);; 1383 }; 1384 }; 1385 return index;; 1386}; 1387 ; 1388////////////////////////////////////////////////////////////////////////////////; 1389 ; 1390void WriteStreamer(const ROOT::TMetaUtils::AnnotatedRecordDecl &cl,; 1391 const cling::Interpreter &interp,; 1392 const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt,; 1",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:51609,Availability,error,errorstring,51609,"; 1342 }; 1343 dictStream << std::endl;; 1344}; 1345 ; 1346////////////////////////////////////////////////////////////////////////////////; 1347/// GrabIndex returns a static string (so use it or copy it immediately, do not; 1348/// call GrabIndex twice in the same expression) containing the size of the; 1349/// array data member.; 1350/// In case of error, or if the size is not specified, GrabIndex returns 0.; 1351 ; 1352llvm::StringRef GrabIndex(const cling::Interpreter& interp, const clang::FieldDecl &member, int printError); 1353{; 1354 int error;; 1355 llvm::StringRef where;; 1356 ; 1357 llvm::StringRef index = ROOT::TMetaUtils::DataMemberInfo__ValidArrayIndex(interp, member, &error, &where);; 1358 if (index.size() == 0 && printError) {; 1359 const char *errorstring;; 1360 switch (error) {; 1361 case TMetaUtils::NOT_INT:; 1362 errorstring = ""is not an integer"";; 1363 break;; 1364 case TMetaUtils::NOT_DEF:; 1365 errorstring = ""has not been defined before the array"";; 1366 break;; 1367 case TMetaUtils::IS_PRIVATE:; 1368 errorstring = ""is a private member of a parent class"";; 1369 break;; 1370 case TMetaUtils::UNKNOWN:; 1371 errorstring = ""is not known"";; 1372 break;; 1373 default:; 1374 errorstring = ""UNKNOWN ERROR!!!!"";; 1375 }; 1376 ; 1377 if (where.size() == 0) {; 1378 ROOT::TMetaUtils::Error(nullptr, ""*** Datamember %s::%s: no size indication!\n"",; 1379 member.getParent()->getName().str().c_str(), member.getName().str().c_str());; 1380 } else {; 1381 ROOT::TMetaUtils::Error(nullptr, ""*** Datamember %s::%s: size of array (%s) %s!\n"",; 1382 member.getParent()->getName().str().c_str(), member.getName().str().c_str(), where.str().c_str(), errorstring);; 1383 }; 1384 }; 1385 return index;; 1386}; 1387 ; 1388////////////////////////////////////////////////////////////////////////////////; 1389 ; 1390void WriteStreamer(const ROOT::TMetaUtils::AnnotatedRecordDecl &cl,; 1391 const cling::Interpreter &interp,; 1392 const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt,; 1",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:51715,Availability,error,errorstring,51715,"; 1342 }; 1343 dictStream << std::endl;; 1344}; 1345 ; 1346////////////////////////////////////////////////////////////////////////////////; 1347/// GrabIndex returns a static string (so use it or copy it immediately, do not; 1348/// call GrabIndex twice in the same expression) containing the size of the; 1349/// array data member.; 1350/// In case of error, or if the size is not specified, GrabIndex returns 0.; 1351 ; 1352llvm::StringRef GrabIndex(const cling::Interpreter& interp, const clang::FieldDecl &member, int printError); 1353{; 1354 int error;; 1355 llvm::StringRef where;; 1356 ; 1357 llvm::StringRef index = ROOT::TMetaUtils::DataMemberInfo__ValidArrayIndex(interp, member, &error, &where);; 1358 if (index.size() == 0 && printError) {; 1359 const char *errorstring;; 1360 switch (error) {; 1361 case TMetaUtils::NOT_INT:; 1362 errorstring = ""is not an integer"";; 1363 break;; 1364 case TMetaUtils::NOT_DEF:; 1365 errorstring = ""has not been defined before the array"";; 1366 break;; 1367 case TMetaUtils::IS_PRIVATE:; 1368 errorstring = ""is a private member of a parent class"";; 1369 break;; 1370 case TMetaUtils::UNKNOWN:; 1371 errorstring = ""is not known"";; 1372 break;; 1373 default:; 1374 errorstring = ""UNKNOWN ERROR!!!!"";; 1375 }; 1376 ; 1377 if (where.size() == 0) {; 1378 ROOT::TMetaUtils::Error(nullptr, ""*** Datamember %s::%s: no size indication!\n"",; 1379 member.getParent()->getName().str().c_str(), member.getName().str().c_str());; 1380 } else {; 1381 ROOT::TMetaUtils::Error(nullptr, ""*** Datamember %s::%s: size of array (%s) %s!\n"",; 1382 member.getParent()->getName().str().c_str(), member.getName().str().c_str(), where.str().c_str(), errorstring);; 1383 }; 1384 }; 1385 return index;; 1386}; 1387 ; 1388////////////////////////////////////////////////////////////////////////////////; 1389 ; 1390void WriteStreamer(const ROOT::TMetaUtils::AnnotatedRecordDecl &cl,; 1391 const cling::Interpreter &interp,; 1392 const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt,; 1",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:51779,Availability,error,errorstring,51779,"; 1342 }; 1343 dictStream << std::endl;; 1344}; 1345 ; 1346////////////////////////////////////////////////////////////////////////////////; 1347/// GrabIndex returns a static string (so use it or copy it immediately, do not; 1348/// call GrabIndex twice in the same expression) containing the size of the; 1349/// array data member.; 1350/// In case of error, or if the size is not specified, GrabIndex returns 0.; 1351 ; 1352llvm::StringRef GrabIndex(const cling::Interpreter& interp, const clang::FieldDecl &member, int printError); 1353{; 1354 int error;; 1355 llvm::StringRef where;; 1356 ; 1357 llvm::StringRef index = ROOT::TMetaUtils::DataMemberInfo__ValidArrayIndex(interp, member, &error, &where);; 1358 if (index.size() == 0 && printError) {; 1359 const char *errorstring;; 1360 switch (error) {; 1361 case TMetaUtils::NOT_INT:; 1362 errorstring = ""is not an integer"";; 1363 break;; 1364 case TMetaUtils::NOT_DEF:; 1365 errorstring = ""has not been defined before the array"";; 1366 break;; 1367 case TMetaUtils::IS_PRIVATE:; 1368 errorstring = ""is a private member of a parent class"";; 1369 break;; 1370 case TMetaUtils::UNKNOWN:; 1371 errorstring = ""is not known"";; 1372 break;; 1373 default:; 1374 errorstring = ""UNKNOWN ERROR!!!!"";; 1375 }; 1376 ; 1377 if (where.size() == 0) {; 1378 ROOT::TMetaUtils::Error(nullptr, ""*** Datamember %s::%s: no size indication!\n"",; 1379 member.getParent()->getName().str().c_str(), member.getName().str().c_str());; 1380 } else {; 1381 ROOT::TMetaUtils::Error(nullptr, ""*** Datamember %s::%s: size of array (%s) %s!\n"",; 1382 member.getParent()->getName().str().c_str(), member.getName().str().c_str(), where.str().c_str(), errorstring);; 1383 }; 1384 }; 1385 return index;; 1386}; 1387 ; 1388////////////////////////////////////////////////////////////////////////////////; 1389 ; 1390void WriteStreamer(const ROOT::TMetaUtils::AnnotatedRecordDecl &cl,; 1391 const cling::Interpreter &interp,; 1392 const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt,; 1",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:52240,Availability,error,errorstring,52240,"k;; 1364 case TMetaUtils::NOT_DEF:; 1365 errorstring = ""has not been defined before the array"";; 1366 break;; 1367 case TMetaUtils::IS_PRIVATE:; 1368 errorstring = ""is a private member of a parent class"";; 1369 break;; 1370 case TMetaUtils::UNKNOWN:; 1371 errorstring = ""is not known"";; 1372 break;; 1373 default:; 1374 errorstring = ""UNKNOWN ERROR!!!!"";; 1375 }; 1376 ; 1377 if (where.size() == 0) {; 1378 ROOT::TMetaUtils::Error(nullptr, ""*** Datamember %s::%s: no size indication!\n"",; 1379 member.getParent()->getName().str().c_str(), member.getName().str().c_str());; 1380 } else {; 1381 ROOT::TMetaUtils::Error(nullptr, ""*** Datamember %s::%s: size of array (%s) %s!\n"",; 1382 member.getParent()->getName().str().c_str(), member.getName().str().c_str(), where.str().c_str(), errorstring);; 1383 }; 1384 }; 1385 return index;; 1386}; 1387 ; 1388////////////////////////////////////////////////////////////////////////////////; 1389 ; 1390void WriteStreamer(const ROOT::TMetaUtils::AnnotatedRecordDecl &cl,; 1391 const cling::Interpreter &interp,; 1392 const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt,; 1393 std::ostream &dictStream); 1394{; 1395 const clang::CXXRecordDecl *clxx = llvm::dyn_cast<clang::CXXRecordDecl>(cl.GetRecordDecl());; 1396 if (clxx == nullptr) return;; 1397 ; 1398 bool add_template_keyword = ROOT::TMetaUtils::NeedTemplateKeyword(clxx);; 1399 ; 1400 string fullname;; 1401 string clsname;; 1402 string nsname;; 1403 int enclSpaceNesting = 0;; 1404 ; 1405 if (ROOT::TMetaUtils::GetNameWithinNamespace(fullname, clsname, nsname, clxx)) {; 1406 enclSpaceNesting = ROOT::TMetaUtils::WriteNamespaceHeader(dictStream, cl);; 1407 }; 1408 ; 1409 dictStream << ""//_______________________________________""; 1410 << ""_______________________________________"" << std::endl;; 1411 if (add_template_keyword) dictStream << ""template <> "";; 1412 dictStream << ""void "" << clsname << ""::Streamer(TBuffer &R__b)"" << std::endl << ""{"" << std::endl; 1413 << "" // Stream an object of class "" <<",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:53663,Availability,error,error,53663," llvm::dyn_cast<clang::CXXRecordDecl>(cl.GetRecordDecl());; 1396 if (clxx == nullptr) return;; 1397 ; 1398 bool add_template_keyword = ROOT::TMetaUtils::NeedTemplateKeyword(clxx);; 1399 ; 1400 string fullname;; 1401 string clsname;; 1402 string nsname;; 1403 int enclSpaceNesting = 0;; 1404 ; 1405 if (ROOT::TMetaUtils::GetNameWithinNamespace(fullname, clsname, nsname, clxx)) {; 1406 enclSpaceNesting = ROOT::TMetaUtils::WriteNamespaceHeader(dictStream, cl);; 1407 }; 1408 ; 1409 dictStream << ""//_______________________________________""; 1410 << ""_______________________________________"" << std::endl;; 1411 if (add_template_keyword) dictStream << ""template <> "";; 1412 dictStream << ""void "" << clsname << ""::Streamer(TBuffer &R__b)"" << std::endl << ""{"" << std::endl; 1413 << "" // Stream an object of class "" << fullname << ""."" << std::endl << std::endl;; 1414 ; 1415 // In case of VersionID<=0 write dummy streamer only calling; 1416 // its base class Streamer(s). If no base class(es) let Streamer; 1417 // print error message, i.e. this Streamer should never have been called.; 1418 int version = ROOT::TMetaUtils::GetClassVersion(clxx, interp);; 1419 if (version <= 0) {; 1420 // We also need to look at the base classes.; 1421 int basestreamer = 0;; 1422 for (clang::CXXRecordDecl::base_class_const_iterator iter = clxx->bases_begin(), end = clxx->bases_end();; 1423 iter != end;; 1424 ++iter) {; 1425 if (ROOT::TMetaUtils::ClassInfo__HasMethod(iter->getType()->getAsCXXRecordDecl(), ""Streamer"", interp)) {; 1426 string base_fullname;; 1427 ROOT::TMetaUtils::GetQualifiedName(base_fullname, * iter->getType()->getAsCXXRecordDecl());; 1428 ; 1429 if (strstr(base_fullname.c_str(), ""::"")) {; 1430 // there is a namespace involved, trigger MS VC bug workaround; 1431 dictStream << "" //This works around a msvc bug and should be harmless on other platforms"" << std::endl; 1432 << "" typedef "" << base_fullname << "" baseClass"" << basestreamer << "";"" << std::endl; 1433 << "" baseClass"" << basestreamer",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:78546,Availability,failure,failure,78546,"/; 1960/// Copy the command line argument, stripping MODULE/inc if; 1961/// necessary.; 1962 ; 1963void StrcpyArg(string &dest, const char *original); 1964{; 1965 dest = CopyArg(original);; 1966}; 1967 ; 1968////////////////////////////////////////////////////////////////////////////////; 1969/// Write the extra header injected into the module:; 1970/// umbrella header if (umbrella) else content header.; 1971 ; 1972static bool InjectModuleUtilHeader(const char *argv0,; 1973 TModuleGenerator &modGen,; 1974 cling::Interpreter &interp,; 1975 bool umbrella); 1976{; 1977 std::ostringstream out;; 1978 if (umbrella) {; 1979 // This will duplicate the -D,-U from clingArgs - but as they are surrounded; 1980 // by #ifndef there is no problem here.; 1981 modGen.WriteUmbrellaHeader(out);; 1982 if (interp.declare(out.str()) != cling::Interpreter::kSuccess) {; 1983 const std::string &hdrName; 1984 = umbrella ? modGen.GetUmbrellaName() : modGen.GetContentName();; 1985 ROOT::TMetaUtils::Error(nullptr, ""%s: compilation failure (%s)\n"", argv0,; 1986 hdrName.c_str());; 1987 return false;; 1988 }; 1989 } else {; 1990 modGen.WriteContentHeader(out);; 1991 }; 1992 return true;; 1993}; 1994 ; 1995////////////////////////////////////////////////////////////////////////////////; 1996/// Write the AST of the given CompilerInstance to the given File while; 1997/// respecting the given isysroot.; 1998/// If module is not a null pointer, we only write the given module to the; 1999/// given file and not the whole AST.; 2000/// Returns true if the AST was successfully written.; 2001static bool WriteAST(llvm::StringRef fileName, clang::CompilerInstance *compilerInstance,; 2002 llvm::StringRef iSysRoot,; 2003 clang::Module *module = nullptr); 2004{; 2005 // From PCHGenerator and friends:; 2006 llvm::SmallVector<char, 128> buffer;; 2007 llvm::BitstreamWriter stream(buffer);; 2008 clang::ASTWriter writer(stream, buffer, compilerInstance->getModuleCache(), /*Extensions=*/{});; 2009 std::unique_ptr<llv",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:81131,Availability,error,error,81131,"4 out->write(&buffer.front(), buffer.size());; 2025 ; 2026 // Make sure it hits disk now.; 2027 out->flush();; 2028 ; 2029 return true;; 2030}; 2031 ; 2032////////////////////////////////////////////////////////////////////////////////; 2033/// Generates a PCH from the given ModuleGenerator and CompilerInstance.; 2034/// Returns true iff the PCH was successfully generated.; 2035static bool GenerateAllDict(TModuleGenerator &modGen, clang::CompilerInstance *compilerInstance,; 2036 const std::string &currentDirectory); 2037{; 2038 assert(modGen.IsPCH() && ""modGen must be in PCH mode"");; 2039 ; 2040 std::string iSysRoot(""/DUMMY_SYSROOT/include/"");; 2041 if (gBuildingROOT) iSysRoot = (currentDirectory + ""/"");; 2042 return WriteAST(modGen.GetModuleFileName(), compilerInstance, iSysRoot);; 2043}; 2044 ; 2045////////////////////////////////////////////////////////////////////////////////; 2046/// Includes all given headers in the interpreter. Returns true when we could; 2047/// include the headers and otherwise false on an error when including.; 2048static bool IncludeHeaders(const std::vector<std::string> &headers, cling::Interpreter &interpreter); 2049{; 2050 // If no headers are given, this is a no-op.; 2051 if (headers.empty()); 2052 return true;; 2053 ; 2054 // Turn every header name into an include and parse it in the interpreter.; 2055 std::stringstream includes;; 2056 for (const std::string &header : headers) {; 2057 includes << ""#include \"""" << header << ""\""\n"";; 2058 }; 2059 std::string includeListStr = includes.str();; 2060 auto result = interpreter.declare(includeListStr);; 2061 return result == cling::Interpreter::CompilationResult::kSuccess;; 2062}; 2063 ; 2064 ; 2065////////////////////////////////////////////////////////////////////////////////; 2066 ; 2067void AddPlatformDefines(std::vector<std::string> &clingArgs); 2068{; 2069 char platformDefines[64] = {0};; 2070#ifdef __INTEL_COMPILER; 2071 snprintf(platformDefines, 64, ""-DG__INTEL_COMPILER=%ld"", (long)_",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:96783,Availability,avail,availableFwdDecls,96783,"here; 2424 if (el_set.insert(tmp).second && !tmp.empty()) {; 2425 el_list.push_back(tmp);; 2426 added = true;; 2427 }; 2428 }; 2429 ; 2430 return added;; 2431}; 2432 ; 2433////////////////////////////////////////////////////////////////////////////////; 2434 ; 2435int ExtractClassesListAndDeclLines(RScanner &scan,; 2436 std::list<std::string> &classesList,; 2437 std::list<std::string> &classesListForRootmap,; 2438 std::list<std::string> &fwdDeclarationsList,; 2439 const cling::Interpreter &interpreter); 2440{; 2441 // Loop on selected classes. If they don't have the attribute ""rootmap""; 2442 // set to ""false"", store them in the list of classes for the rootmap; 2443 // Returns 0 in case of success and 1 in case of issues.; 2444 ; 2445 // An unordered_set to keep track of the existing classes.; 2446 // We want to avoid duplicates there as they may hint to a serious corruption; 2447 std::unordered_set<std::string> classesSet;; 2448 std::unordered_set<std::string> outerMostClassesSet;; 2449 ; 2450 std::string attrName, attrValue;; 2451 bool isClassSelected;; 2452 std::unordered_set<std::string> availableFwdDecls;; 2453 std::string fwdDeclaration;; 2454 for (auto const & selVar : scan.fSelectedVariables) {; 2455 fwdDeclaration = """";; 2456 int retCode = ROOT::TMetaUtils::AST2SourceTools::EncloseInNamespaces(*selVar, fwdDeclaration);; 2457 if (retCode == 0) ProcessAndAppendIfNotThere(fwdDeclaration, fwdDeclarationsList, availableFwdDecls);; 2458 }; 2459 ; 2460 for (auto const & selEnum : scan.fSelectedEnums) {; 2461 fwdDeclaration = """";; 2462 int retCode = ROOT::TMetaUtils::AST2SourceTools::EncloseInNamespaces(*selEnum, fwdDeclaration);; 2463 if (retCode == 0) ProcessAndAppendIfNotThere(fwdDeclaration, fwdDeclarationsList, availableFwdDecls);; 2464 }; 2465 ; 2466 // Loop on selected classes and put them in a list; 2467 for (auto const & selClass : scan.fSelectedClasses) {; 2468 isClassSelected = true;; 2469 const clang::RecordDecl *rDecl = selClass.GetRecordDecl();; 2470 st",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:97112,Availability,avail,availableFwdDecls,97112,"st,; 2437 std::list<std::string> &classesListForRootmap,; 2438 std::list<std::string> &fwdDeclarationsList,; 2439 const cling::Interpreter &interpreter); 2440{; 2441 // Loop on selected classes. If they don't have the attribute ""rootmap""; 2442 // set to ""false"", store them in the list of classes for the rootmap; 2443 // Returns 0 in case of success and 1 in case of issues.; 2444 ; 2445 // An unordered_set to keep track of the existing classes.; 2446 // We want to avoid duplicates there as they may hint to a serious corruption; 2447 std::unordered_set<std::string> classesSet;; 2448 std::unordered_set<std::string> outerMostClassesSet;; 2449 ; 2450 std::string attrName, attrValue;; 2451 bool isClassSelected;; 2452 std::unordered_set<std::string> availableFwdDecls;; 2453 std::string fwdDeclaration;; 2454 for (auto const & selVar : scan.fSelectedVariables) {; 2455 fwdDeclaration = """";; 2456 int retCode = ROOT::TMetaUtils::AST2SourceTools::EncloseInNamespaces(*selVar, fwdDeclaration);; 2457 if (retCode == 0) ProcessAndAppendIfNotThere(fwdDeclaration, fwdDeclarationsList, availableFwdDecls);; 2458 }; 2459 ; 2460 for (auto const & selEnum : scan.fSelectedEnums) {; 2461 fwdDeclaration = """";; 2462 int retCode = ROOT::TMetaUtils::AST2SourceTools::EncloseInNamespaces(*selEnum, fwdDeclaration);; 2463 if (retCode == 0) ProcessAndAppendIfNotThere(fwdDeclaration, fwdDeclarationsList, availableFwdDecls);; 2464 }; 2465 ; 2466 // Loop on selected classes and put them in a list; 2467 for (auto const & selClass : scan.fSelectedClasses) {; 2468 isClassSelected = true;; 2469 const clang::RecordDecl *rDecl = selClass.GetRecordDecl();; 2470 std::string normalizedName;; 2471 normalizedName = selClass.GetNormalizedName();; 2472 if (!normalizedName.empty() &&; 2473 !classesSet.insert(normalizedName).second &&; 2474 outerMostClassesSet.count(normalizedName) == 0) {; 2475 std::cerr << ""FATAL: A class with normalized name "" << normalizedName; 2476 << "" was already selected. This means that two di",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:97421,Availability,avail,availableFwdDecls,97421," of success and 1 in case of issues.; 2444 ; 2445 // An unordered_set to keep track of the existing classes.; 2446 // We want to avoid duplicates there as they may hint to a serious corruption; 2447 std::unordered_set<std::string> classesSet;; 2448 std::unordered_set<std::string> outerMostClassesSet;; 2449 ; 2450 std::string attrName, attrValue;; 2451 bool isClassSelected;; 2452 std::unordered_set<std::string> availableFwdDecls;; 2453 std::string fwdDeclaration;; 2454 for (auto const & selVar : scan.fSelectedVariables) {; 2455 fwdDeclaration = """";; 2456 int retCode = ROOT::TMetaUtils::AST2SourceTools::EncloseInNamespaces(*selVar, fwdDeclaration);; 2457 if (retCode == 0) ProcessAndAppendIfNotThere(fwdDeclaration, fwdDeclarationsList, availableFwdDecls);; 2458 }; 2459 ; 2460 for (auto const & selEnum : scan.fSelectedEnums) {; 2461 fwdDeclaration = """";; 2462 int retCode = ROOT::TMetaUtils::AST2SourceTools::EncloseInNamespaces(*selEnum, fwdDeclaration);; 2463 if (retCode == 0) ProcessAndAppendIfNotThere(fwdDeclaration, fwdDeclarationsList, availableFwdDecls);; 2464 }; 2465 ; 2466 // Loop on selected classes and put them in a list; 2467 for (auto const & selClass : scan.fSelectedClasses) {; 2468 isClassSelected = true;; 2469 const clang::RecordDecl *rDecl = selClass.GetRecordDecl();; 2470 std::string normalizedName;; 2471 normalizedName = selClass.GetNormalizedName();; 2472 if (!normalizedName.empty() &&; 2473 !classesSet.insert(normalizedName).second &&; 2474 outerMostClassesSet.count(normalizedName) == 0) {; 2475 std::cerr << ""FATAL: A class with normalized name "" << normalizedName; 2476 << "" was already selected. This means that two different instances of""; 2477 << "" clang::RecordDecl had the same name, which is not possible.""; 2478 << "" This can be a hint of a serious problem in the class selection.""; 2479 << "" In addition, the generated dictionary would not even compile.\n"";; 2480 return 1;; 2481 }; 2482 classesList.push_back(normalizedName);; 2483 // Allow to autolo",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:98817,Availability,avail,availableFwdDecls,98817,"ionary would not even compile.\n"";; 2480 return 1;; 2481 }; 2482 classesList.push_back(normalizedName);; 2483 // Allow to autoload with the name of the class as it was specified in the; 2484 // selection xml or linkdef; 2485 const char *reqName(selClass.GetRequestedName());; 2486 ; 2487 // Get always the containing namespace, put it in the list if not there; 2488 fwdDeclaration = """";; 2489 int retCode = ROOT::TMetaUtils::AST2SourceTools::EncloseInNamespaces(*rDecl, fwdDeclaration);; 2490 if (retCode == 0) ProcessAndAppendIfNotThere(fwdDeclaration, fwdDeclarationsList, availableFwdDecls);; 2491 ; 2492 // Get template definition and put it in if not there; 2493 if (llvm::isa<clang::ClassTemplateSpecializationDecl>(rDecl)) {; 2494 fwdDeclaration = """";; 2495 retCode = ROOT::TMetaUtils::AST2SourceTools::FwdDeclFromRcdDecl(*rDecl, interpreter, fwdDeclaration);; 2496 if (retCode == 0) {; 2497 std::string fwdDeclarationTemplateSpec;; 2498 retCode = ROOT::TMetaUtils::AST2SourceTools::FwdDeclIfTmplSpec(*rDecl, interpreter, fwdDeclarationTemplateSpec, normalizedName);; 2499 fwdDeclaration += '\n' + fwdDeclarationTemplateSpec;; 2500 }; 2501 if (retCode == 0); 2502 ProcessAndAppendIfNotThere(fwdDeclaration, fwdDeclarationsList, availableFwdDecls);; 2503 }; 2504 ; 2505 ; 2506 // Loop on attributes, if rootmap=false, don't put it in the list!; 2507 for (auto ait = rDecl->attr_begin(); ait != rDecl->attr_end(); ++ait) {; 2508 if (0 == ROOT::TMetaUtils::extractPropertyNameVal(*ait, attrName, attrValue) &&; 2509 attrName == ""rootmap"" &&; 2510 attrValue == ""false"") {; 2511 attrName = attrValue = """";; 2512 isClassSelected = false;; 2513 break;; 2514 }; 2515 }; 2516 if (isClassSelected) {; 2517 // Now, check if this is an internal class. If yes, we check the name of the outermost one; 2518 // This is because of ROOT-6517. On the other hand, we exclude from this treatment; 2519 // classes which are template instances which are nested in classes. For example:; 2520 // class A{; 2521 // cl",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:99477,Availability,avail,availableFwdDecls,99477,"ionary would not even compile.\n"";; 2480 return 1;; 2481 }; 2482 classesList.push_back(normalizedName);; 2483 // Allow to autoload with the name of the class as it was specified in the; 2484 // selection xml or linkdef; 2485 const char *reqName(selClass.GetRequestedName());; 2486 ; 2487 // Get always the containing namespace, put it in the list if not there; 2488 fwdDeclaration = """";; 2489 int retCode = ROOT::TMetaUtils::AST2SourceTools::EncloseInNamespaces(*rDecl, fwdDeclaration);; 2490 if (retCode == 0) ProcessAndAppendIfNotThere(fwdDeclaration, fwdDeclarationsList, availableFwdDecls);; 2491 ; 2492 // Get template definition and put it in if not there; 2493 if (llvm::isa<clang::ClassTemplateSpecializationDecl>(rDecl)) {; 2494 fwdDeclaration = """";; 2495 retCode = ROOT::TMetaUtils::AST2SourceTools::FwdDeclFromRcdDecl(*rDecl, interpreter, fwdDeclaration);; 2496 if (retCode == 0) {; 2497 std::string fwdDeclarationTemplateSpec;; 2498 retCode = ROOT::TMetaUtils::AST2SourceTools::FwdDeclIfTmplSpec(*rDecl, interpreter, fwdDeclarationTemplateSpec, normalizedName);; 2499 fwdDeclaration += '\n' + fwdDeclarationTemplateSpec;; 2500 }; 2501 if (retCode == 0); 2502 ProcessAndAppendIfNotThere(fwdDeclaration, fwdDeclarationsList, availableFwdDecls);; 2503 }; 2504 ; 2505 ; 2506 // Loop on attributes, if rootmap=false, don't put it in the list!; 2507 for (auto ait = rDecl->attr_begin(); ait != rDecl->attr_end(); ++ait) {; 2508 if (0 == ROOT::TMetaUtils::extractPropertyNameVal(*ait, attrName, attrValue) &&; 2509 attrName == ""rootmap"" &&; 2510 attrValue == ""false"") {; 2511 attrName = attrValue = """";; 2512 isClassSelected = false;; 2513 break;; 2514 }; 2515 }; 2516 if (isClassSelected) {; 2517 // Now, check if this is an internal class. If yes, we check the name of the outermost one; 2518 // This is because of ROOT-6517. On the other hand, we exclude from this treatment; 2519 // classes which are template instances which are nested in classes. For example:; 2520 // class A{; 2521 // cl",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:137821,Availability,avail,available,137821,"<std::string> uclNamePrfxes {; 3442 ""chrono:"",; 3443 ""ratio<"",; 3444 ""shared_ptr<""};; 3445 static const std::set<std::string> unsupportedClassesNormNames{; 3446 ""regex"",; 3447 ""thread""};; 3448 if ( unsupportedClassesNormNames.count(name) == 1) return false;; 3449 auto pos = find_if(uclNamePrfxes.begin(),; 3450 uclNamePrfxes.end(),; 3451 [&](const std::string& str){return ROOT::TMetaUtils::BeginsWith(name,str);});; 3452 return uclNamePrfxes.end() == pos;; 3453}; 3454 ; 3455////////////////////////////////////////////////////////////////////////////////; 3456/// Check if the list of selected classes contains any class which is not; 3457/// supported. Return the number of unsupported classes in the selection.; 3458 ; 3459int CheckForUnsupportedClasses(const RScanner::ClassColl_t &annotatedRcds); 3460{; 3461 int nerrors = 0;; 3462 for (auto&& aRcd : annotatedRcds){; 3463 auto clName = aRcd.GetNormalizedName();; 3464 if (!IsSupportedClassName(clName)){; 3465 std::cerr << ""Error: Class "" << clName << "" has been selected but ""; 3466 << ""currently the support for its I/O is not yet available. Note that ""; 3467 << clName << "", even if not selected, will be available for ""; 3468 << ""interpreted code.\n"";; 3469 nerrors++;; 3470 }; 3471 if (!NeedsSelection(clName)){; 3472 std::cerr << ""Error: It is not necessary to explicitly select class ""; 3473 << clName << "". I/O is supported for it transparently.\n"";; 3474 nerrors++;; 3475 }; 3476 }; 3477 return nerrors;; 3478}; 3479 ; 3480////////////////////////////////////////////////////////////////////////////////; 3481 ; 3482class TRootClingCallbacks : public cling::InterpreterCallbacks {; 3483private:; 3484 std::list<std::string>& fFilesIncludedByLinkdef;; 3485 bool isLocked = false;; 3486public:; 3487 TRootClingCallbacks(cling::Interpreter* interp, std::list<std::string>& filesIncludedByLinkdef):; 3488 InterpreterCallbacks(interp),; 3489 fFilesIncludedByLinkdef(filesIncludedByLinkdef){};; 3490 ; 3491 ~TRootClingCallbacks(){};; 3492 ",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:137896,Availability,avail,available,137896," 3446 ""regex"",; 3447 ""thread""};; 3448 if ( unsupportedClassesNormNames.count(name) == 1) return false;; 3449 auto pos = find_if(uclNamePrfxes.begin(),; 3450 uclNamePrfxes.end(),; 3451 [&](const std::string& str){return ROOT::TMetaUtils::BeginsWith(name,str);});; 3452 return uclNamePrfxes.end() == pos;; 3453}; 3454 ; 3455////////////////////////////////////////////////////////////////////////////////; 3456/// Check if the list of selected classes contains any class which is not; 3457/// supported. Return the number of unsupported classes in the selection.; 3458 ; 3459int CheckForUnsupportedClasses(const RScanner::ClassColl_t &annotatedRcds); 3460{; 3461 int nerrors = 0;; 3462 for (auto&& aRcd : annotatedRcds){; 3463 auto clName = aRcd.GetNormalizedName();; 3464 if (!IsSupportedClassName(clName)){; 3465 std::cerr << ""Error: Class "" << clName << "" has been selected but ""; 3466 << ""currently the support for its I/O is not yet available. Note that ""; 3467 << clName << "", even if not selected, will be available for ""; 3468 << ""interpreted code.\n"";; 3469 nerrors++;; 3470 }; 3471 if (!NeedsSelection(clName)){; 3472 std::cerr << ""Error: It is not necessary to explicitly select class ""; 3473 << clName << "". I/O is supported for it transparently.\n"";; 3474 nerrors++;; 3475 }; 3476 }; 3477 return nerrors;; 3478}; 3479 ; 3480////////////////////////////////////////////////////////////////////////////////; 3481 ; 3482class TRootClingCallbacks : public cling::InterpreterCallbacks {; 3483private:; 3484 std::list<std::string>& fFilesIncludedByLinkdef;; 3485 bool isLocked = false;; 3486public:; 3487 TRootClingCallbacks(cling::Interpreter* interp, std::list<std::string>& filesIncludedByLinkdef):; 3488 InterpreterCallbacks(interp),; 3489 fFilesIncludedByLinkdef(filesIncludedByLinkdef){};; 3490 ; 3491 ~TRootClingCallbacks(){};; 3492 ; 3493 void InclusionDirective(clang::SourceLocation /*HashLoc*/, const clang::Token & /*IncludeTok*/,; 3494 llvm::StringRef FileName, bool IsAngled, clang",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:140232,Availability,resilien,resilient,140232,"()->getPreprocessor();; 3502 auto curLexer = PP.getCurrentFileLexer();; 3503 if (!curLexer) return;; 3504 auto fileEntry = curLexer->getFileEntry();; 3505 if (!fileEntry) return;; 3506 auto thisFileName = fileEntry->getName();; 3507 auto fileNameAsString = FileName.str();; 3508 auto isThisLinkdef = ROOT::TMetaUtils::IsLinkdefFile(thisFileName.data());; 3509 if (isThisLinkdef) {; 3510 auto isTheIncludedLinkdef = ROOT::TMetaUtils::IsLinkdefFile(fileNameAsString.c_str());; 3511 if (isTheIncludedLinkdef) {; 3512 fFilesIncludedByLinkdef.clear();; 3513 isLocked = true;; 3514 } else {; 3515 fFilesIncludedByLinkdef.emplace_back(fileNameAsString.c_str());; 3516 }; 3517 }; 3518 }; 3519 ; 3520 // rootcling pre-includes things such as Rtypes.h. This means that ACLiC can; 3521 // call rootcling asking it to create a module for a file with no #includes; 3522 // but relying on things from Rtypes.h such as the ClassDef macro.; 3523 //; 3524 // When rootcling starts building a module, it becomes resilient to the; 3525 // outside environment and pre-included files have no effect. This hook; 3526 // informs rootcling when a new submodule is being built so that it can; 3527 // make Core.Rtypes.h visible.; 3528 void EnteredSubmodule(clang::Module* M,; 3529 clang::SourceLocation ImportLoc,; 3530 bool ForPragma) override {; 3531 assert(M);; 3532 using namespace clang;; 3533 if (llvm::StringRef(M->Name).endswith(""ACLiC_dict"")) {; 3534 Preprocessor& PP = m_Interpreter->getCI()->getPreprocessor();; 3535 HeaderSearch& HS = PP.getHeaderSearchInfo();; 3536 // FIXME: Reduce to Core.Rtypes.h.; 3537 Module* CoreModule = HS.lookupModule(""Core"", SourceLocation(),; 3538 /*AllowSearch*/false);; 3539 assert(M && ""Must have module Core"");; 3540 PP.makeModuleVisible(CoreModule, ImportLoc);; 3541 }; 3542 }; 3543};; 3544 ; 3545static llvm::cl::opt<bool> gOptSystemModuleByproducts(""mSystemByproducts"", llvm::cl::Hidden,; 3546 llvm::cl::desc(""Allow implicit build of system modules.""),; 3547 llvm::cl::cat(gRoot",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:142073,Availability,error,error,142073,"543};; 3544 ; 3545static llvm::cl::opt<bool> gOptSystemModuleByproducts(""mSystemByproducts"", llvm::cl::Hidden,; 3546 llvm::cl::desc(""Allow implicit build of system modules.""),; 3547 llvm::cl::cat(gRootclingOptions));; 3548static llvm::cl::list<std::string>; 3549gOptModuleByproducts(""mByproduct"", llvm::cl::ZeroOrMore,; 3550 llvm::cl::Hidden,; 3551 llvm::cl::desc(""The list of the expected implicit modules build as part of building the current module.""),; 3552 llvm::cl::cat(gRootclingOptions));; 3553// Really llvm::cl::Required, will be changed in RootClingMain below.; 3554static llvm::cl::opt<std::string>; 3555gOptDictionaryFileName(llvm::cl::Positional,; 3556 llvm::cl::desc(""<output dictionary file>""),; 3557 llvm::cl::cat(gRootclingOptions));; 3558 ; 3559////////////////////////////////////////////////////////////////////////////////; 3560/// Custom diag client for clang that verifies that each implicitly build module; 3561/// is a system module. If not, it will let the current rootcling invocation; 3562/// fail with an error. All other diags beside module build remarks will be; 3563/// forwarded to the passed child diag client.; 3564///; 3565/// The reason why we need this is that if we built implicitly a C++ module; 3566/// that belongs to a ROOT dictionary, then we will miss information generated; 3567/// by rootcling in this file (e.g. the source code comments to annotation; 3568/// attributes transformation will be missing in the module file).; 3569class CheckModuleBuildClient : public clang::DiagnosticConsumer {; 3570 clang::DiagnosticConsumer *fChild;; 3571 bool fOwnsChild;; 3572 clang::ModuleMap &fMap;; 3573 ; 3574public:; 3575 CheckModuleBuildClient(clang::DiagnosticConsumer *Child, bool OwnsChild, clang::ModuleMap &Map); 3576 : fChild(Child), fOwnsChild(OwnsChild), fMap(Map); 3577 {; 3578 }; 3579 ; 3580 ~CheckModuleBuildClient(); 3581 {; 3582 if (fOwnsChild); 3583 delete fChild;; 3584 }; 3585 ; 3586 virtual void HandleDiagnostic(clang::DiagnosticsEngine::Le",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:143994,Availability,avail,available,143994,"ild;; 3584 }; 3585 ; 3586 virtual void HandleDiagnostic(clang::DiagnosticsEngine::Level DiagLevel, const clang::Diagnostic &Info) override; 3587 {; 3588 using namespace clang::diag;; 3589 ; 3590 // This method catches the module_build remark from clang and checks if; 3591 // the implicitly built module is a system module or not. We only support; 3592 // building system modules implicitly.; 3593 ; 3594 std::string moduleName;; 3595 const clang::Module *module = nullptr;; 3596 ; 3597 // Extract the module from the diag argument with index 0.; 3598 const auto &ID = Info.getID();; 3599 if (ID == remark_module_build || ID == remark_module_build_done) {; 3600 moduleName = Info.getArgStdStr(0);; 3601 module = fMap.findModule(moduleName);; 3602 // We should never be able to build a module without having it in the; 3603 // modulemap. Still, let's print a warning that we at least tell the; 3604 // user that this could lead to problems.; 3605 if (!module) {; 3606 ROOT::TMetaUtils::Warning(nullptr,; 3607 ""Couldn't find module %s in the available modulemaps. This""; 3608 ""prevents us from correctly diagnosing wrongly built modules.\n"",; 3609 moduleName.c_str());; 3610 }; 3611 }; 3612 ; 3613 // A dictionary module could build implicitly a set of implicit modules.; 3614 // For example, the Core module builds libc.pcm and std.pcm implicitly.; 3615 // Those modules do not require I/O information and it is okay to build; 3616 // them as part of another module.; 3617 // However, we can build a module which requires I/O implictly which is; 3618 // an error because rootcling is not able to generate the corresponding; 3619 // dictionary.; 3620 // If we build a I/O requiring module implicitly we should display; 3621 // an error unless -mSystemByproducts or -mByproduct were specified.; 3622 bool isByproductModule = false;; 3623 if (module) {; 3624 // -mSystemByproducts allows implicit building of any system module.; 3625 if (module->IsSystem && gOptSystemModuleByproducts) {; 3626 isByproduc",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:144510,Availability,error,error,144510,"onst auto &ID = Info.getID();; 3599 if (ID == remark_module_build || ID == remark_module_build_done) {; 3600 moduleName = Info.getArgStdStr(0);; 3601 module = fMap.findModule(moduleName);; 3602 // We should never be able to build a module without having it in the; 3603 // modulemap. Still, let's print a warning that we at least tell the; 3604 // user that this could lead to problems.; 3605 if (!module) {; 3606 ROOT::TMetaUtils::Warning(nullptr,; 3607 ""Couldn't find module %s in the available modulemaps. This""; 3608 ""prevents us from correctly diagnosing wrongly built modules.\n"",; 3609 moduleName.c_str());; 3610 }; 3611 }; 3612 ; 3613 // A dictionary module could build implicitly a set of implicit modules.; 3614 // For example, the Core module builds libc.pcm and std.pcm implicitly.; 3615 // Those modules do not require I/O information and it is okay to build; 3616 // them as part of another module.; 3617 // However, we can build a module which requires I/O implictly which is; 3618 // an error because rootcling is not able to generate the corresponding; 3619 // dictionary.; 3620 // If we build a I/O requiring module implicitly we should display; 3621 // an error unless -mSystemByproducts or -mByproduct were specified.; 3622 bool isByproductModule = false;; 3623 if (module) {; 3624 // -mSystemByproducts allows implicit building of any system module.; 3625 if (module->IsSystem && gOptSystemModuleByproducts) {; 3626 isByproductModule = true;; 3627 }; 3628 // -mByproduct lists concrete module names that are allowed.; 3629 if (std::find(gOptModuleByproducts.begin(), gOptModuleByproducts.end(), moduleName) !=; 3630 gOptModuleByproducts.end()) {; 3631 isByproductModule = true;; 3632 }; 3633 }; 3634 if (!isByproductModule); 3635 fChild->HandleDiagnostic(DiagLevel, Info);; 3636 ; 3637 if (ID == remark_module_build && !isByproductModule) {; 3638 ROOT::TMetaUtils::Error(nullptr,; 3639 ""Building module '%s' implicitly. If '%s' requires a \n""; 3640 ""dictionary please specify buil",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:144682,Availability,error,error,144682,".findModule(moduleName);; 3602 // We should never be able to build a module without having it in the; 3603 // modulemap. Still, let's print a warning that we at least tell the; 3604 // user that this could lead to problems.; 3605 if (!module) {; 3606 ROOT::TMetaUtils::Warning(nullptr,; 3607 ""Couldn't find module %s in the available modulemaps. This""; 3608 ""prevents us from correctly diagnosing wrongly built modules.\n"",; 3609 moduleName.c_str());; 3610 }; 3611 }; 3612 ; 3613 // A dictionary module could build implicitly a set of implicit modules.; 3614 // For example, the Core module builds libc.pcm and std.pcm implicitly.; 3615 // Those modules do not require I/O information and it is okay to build; 3616 // them as part of another module.; 3617 // However, we can build a module which requires I/O implictly which is; 3618 // an error because rootcling is not able to generate the corresponding; 3619 // dictionary.; 3620 // If we build a I/O requiring module implicitly we should display; 3621 // an error unless -mSystemByproducts or -mByproduct were specified.; 3622 bool isByproductModule = false;; 3623 if (module) {; 3624 // -mSystemByproducts allows implicit building of any system module.; 3625 if (module->IsSystem && gOptSystemModuleByproducts) {; 3626 isByproductModule = true;; 3627 }; 3628 // -mByproduct lists concrete module names that are allowed.; 3629 if (std::find(gOptModuleByproducts.begin(), gOptModuleByproducts.end(), moduleName) !=; 3630 gOptModuleByproducts.end()) {; 3631 isByproductModule = true;; 3632 }; 3633 }; 3634 if (!isByproductModule); 3635 fChild->HandleDiagnostic(DiagLevel, Info);; 3636 ; 3637 if (ID == remark_module_build && !isByproductModule) {; 3638 ROOT::TMetaUtils::Error(nullptr,; 3639 ""Building module '%s' implicitly. If '%s' requires a \n""; 3640 ""dictionary please specify build dependency: '%s' depends on '%s'.\n""; 3641 ""Otherwise, specify '-mByproduct %s' to disable this diagnostic.\n"",; 3642 moduleName.c_str(), moduleName.c_str(), gO",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:146702,Availability,error,error,146702,"fo);; 3636 ; 3637 if (ID == remark_module_build && !isByproductModule) {; 3638 ROOT::TMetaUtils::Error(nullptr,; 3639 ""Building module '%s' implicitly. If '%s' requires a \n""; 3640 ""dictionary please specify build dependency: '%s' depends on '%s'.\n""; 3641 ""Otherwise, specify '-mByproduct %s' to disable this diagnostic.\n"",; 3642 moduleName.c_str(), moduleName.c_str(), gOptDictionaryFileName.c_str(),; 3643 moduleName.c_str(), moduleName.c_str());; 3644 }; 3645 }; 3646 ; 3647 // All methods below just forward to the child and the default method.; 3648 virtual void clear() override; 3649 {; 3650 fChild->clear();; 3651 DiagnosticConsumer::clear();; 3652 }; 3653 ; 3654 virtual void BeginSourceFile(const clang::LangOptions &LangOpts, const clang::Preprocessor *PP) override; 3655 {; 3656 fChild->BeginSourceFile(LangOpts, PP);; 3657 DiagnosticConsumer::BeginSourceFile(LangOpts, PP);; 3658 }; 3659 ; 3660 virtual void EndSourceFile() override; 3661 {; 3662 fChild->EndSourceFile();; 3663 DiagnosticConsumer::EndSourceFile();; 3664 }; 3665 ; 3666 virtual void finish() override; 3667 {; 3668 fChild->finish();; 3669 DiagnosticConsumer::finish();; 3670 }; 3671 ; 3672 virtual bool IncludeInDiagnosticCounts() const override { return fChild->IncludeInDiagnosticCounts(); }; 3673};; 3674 ; 3675static void MaybeSuppressWin32CrashDialogs() {; 3676#if defined(_WIN32) && defined(_MSC_VER); 3677 // Suppress error dialogs to avoid hangs on build nodes.; 3678 // One can use an environment variable (Cling_GuiOnAssert) to enable; 3679 // the error dialogs.; 3680 const char *EnablePopups = getenv(""Cling_GuiOnAssert"");; 3681 if (EnablePopups == nullptr || EnablePopups[0] == '0') {; 3682 ::_set_error_mode(_OUT_TO_STDERR);; 3683 _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3684 _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);; 3685 _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3686 _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);; 3687 _CrtSe",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:146835,Availability,error,error,146835,"just forward to the child and the default method.; 3648 virtual void clear() override; 3649 {; 3650 fChild->clear();; 3651 DiagnosticConsumer::clear();; 3652 }; 3653 ; 3654 virtual void BeginSourceFile(const clang::LangOptions &LangOpts, const clang::Preprocessor *PP) override; 3655 {; 3656 fChild->BeginSourceFile(LangOpts, PP);; 3657 DiagnosticConsumer::BeginSourceFile(LangOpts, PP);; 3658 }; 3659 ; 3660 virtual void EndSourceFile() override; 3661 {; 3662 fChild->EndSourceFile();; 3663 DiagnosticConsumer::EndSourceFile();; 3664 }; 3665 ; 3666 virtual void finish() override; 3667 {; 3668 fChild->finish();; 3669 DiagnosticConsumer::finish();; 3670 }; 3671 ; 3672 virtual bool IncludeInDiagnosticCounts() const override { return fChild->IncludeInDiagnosticCounts(); }; 3673};; 3674 ; 3675static void MaybeSuppressWin32CrashDialogs() {; 3676#if defined(_WIN32) && defined(_MSC_VER); 3677 // Suppress error dialogs to avoid hangs on build nodes.; 3678 // One can use an environment variable (Cling_GuiOnAssert) to enable; 3679 // the error dialogs.; 3680 const char *EnablePopups = getenv(""Cling_GuiOnAssert"");; 3681 if (EnablePopups == nullptr || EnablePopups[0] == '0') {; 3682 ::_set_error_mode(_OUT_TO_STDERR);; 3683 _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3684 _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);; 3685 _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3686 _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);; 3687 _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3688 _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);; 3689 }; 3690#endif; 3691}; 3692 ; 3693static llvm::cl::opt<bool> gOptForce(""f"", llvm::cl::desc(""Overwrite <file>s.""),; 3694 llvm::cl::cat(gRootclingOptions));; 3695static llvm::cl::opt<bool> gOptRootBuild(""rootbuild"", llvm::cl::desc(""If we are building ROOT.""),; 3696 llvm::cl::Hidden,; 3697 llvm::cl::cat(gRootclingOptions));; 3698enum VerboseLevel {; 3699 v = ROOT::TMetaUti",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:148126,Availability,error,errors,148126,"rt"");; 3681 if (EnablePopups == nullptr || EnablePopups[0] == '0') {; 3682 ::_set_error_mode(_OUT_TO_STDERR);; 3683 _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3684 _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);; 3685 _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3686 _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);; 3687 _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3688 _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);; 3689 }; 3690#endif; 3691}; 3692 ; 3693static llvm::cl::opt<bool> gOptForce(""f"", llvm::cl::desc(""Overwrite <file>s.""),; 3694 llvm::cl::cat(gRootclingOptions));; 3695static llvm::cl::opt<bool> gOptRootBuild(""rootbuild"", llvm::cl::desc(""If we are building ROOT.""),; 3696 llvm::cl::Hidden,; 3697 llvm::cl::cat(gRootclingOptions));; 3698enum VerboseLevel {; 3699 v = ROOT::TMetaUtils::kError,; 3700 v0 = ROOT::TMetaUtils::kFatal,; 3701 v1 = v,; 3702 v2 = ROOT::TMetaUtils::kWarning,; 3703 v3 = ROOT::TMetaUtils::kNote,; 3704 v4 = ROOT::TMetaUtils::kInfo; 3705};; 3706static llvm::cl::opt<VerboseLevel>; 3707gOptVerboseLevel(llvm::cl::desc(""Choose verbosity level:""),; 3708 llvm::cl::values(clEnumVal(v, ""Show errors.""),; 3709 clEnumVal(v0, ""Show only fatal errors.""),; 3710 clEnumVal(v1, ""Show errors (the same as -v).""),; 3711 clEnumVal(v2, ""Show warnings (default).""),; 3712 clEnumVal(v3, ""Show notes.""),; 3713 clEnumVal(v4, ""Show information."")),; 3714 llvm::cl::init(v2),; 3715 llvm::cl::cat(gRootclingOptions));; 3716 ; 3717static llvm::cl::opt<bool>; 3718gOptCint(""cint"", llvm::cl::desc(""Deprecated, legacy flag which is ignored.""),; 3719 llvm::cl::Hidden,; 3720 llvm::cl::cat(gRootclingOptions));; 3721static llvm::cl::opt<bool>; 3722gOptReflex(""reflex"", llvm::cl::desc(""Behave internally like genreflex.""),; 3723 llvm::cl::cat(gRootclingOptions));; 3724static llvm::cl::opt<bool>; 3725gOptGccXml(""gccxml"", llvm::cl::desc(""Deprecated, legacy flag which is ignored.""),; 3726 llvm::cl:",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:148174,Availability,error,errors,148174,"rtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3686 _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);; 3687 _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3688 _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);; 3689 }; 3690#endif; 3691}; 3692 ; 3693static llvm::cl::opt<bool> gOptForce(""f"", llvm::cl::desc(""Overwrite <file>s.""),; 3694 llvm::cl::cat(gRootclingOptions));; 3695static llvm::cl::opt<bool> gOptRootBuild(""rootbuild"", llvm::cl::desc(""If we are building ROOT.""),; 3696 llvm::cl::Hidden,; 3697 llvm::cl::cat(gRootclingOptions));; 3698enum VerboseLevel {; 3699 v = ROOT::TMetaUtils::kError,; 3700 v0 = ROOT::TMetaUtils::kFatal,; 3701 v1 = v,; 3702 v2 = ROOT::TMetaUtils::kWarning,; 3703 v3 = ROOT::TMetaUtils::kNote,; 3704 v4 = ROOT::TMetaUtils::kInfo; 3705};; 3706static llvm::cl::opt<VerboseLevel>; 3707gOptVerboseLevel(llvm::cl::desc(""Choose verbosity level:""),; 3708 llvm::cl::values(clEnumVal(v, ""Show errors.""),; 3709 clEnumVal(v0, ""Show only fatal errors.""),; 3710 clEnumVal(v1, ""Show errors (the same as -v).""),; 3711 clEnumVal(v2, ""Show warnings (default).""),; 3712 clEnumVal(v3, ""Show notes.""),; 3713 clEnumVal(v4, ""Show information."")),; 3714 llvm::cl::init(v2),; 3715 llvm::cl::cat(gRootclingOptions));; 3716 ; 3717static llvm::cl::opt<bool>; 3718gOptCint(""cint"", llvm::cl::desc(""Deprecated, legacy flag which is ignored.""),; 3719 llvm::cl::Hidden,; 3720 llvm::cl::cat(gRootclingOptions));; 3721static llvm::cl::opt<bool>; 3722gOptReflex(""reflex"", llvm::cl::desc(""Behave internally like genreflex.""),; 3723 llvm::cl::cat(gRootclingOptions));; 3724static llvm::cl::opt<bool>; 3725gOptGccXml(""gccxml"", llvm::cl::desc(""Deprecated, legacy flag which is ignored.""),; 3726 llvm::cl::Hidden,; 3727 llvm::cl::cat(gRootclingOptions));; 3728static llvm::cl::opt<std::string>; 3729gOptLibListPrefix(""lib-list-prefix"",; 3730 llvm::cl::desc(""An ACLiC feature which exports the list of dependent libraries.""),; 3731 llvm::cl::Hidden,; 3732 ",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:148211,Availability,error,errors,148211,"TDBG_MODE_DEBUG);; 3686 _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);; 3687 _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3688 _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);; 3689 }; 3690#endif; 3691}; 3692 ; 3693static llvm::cl::opt<bool> gOptForce(""f"", llvm::cl::desc(""Overwrite <file>s.""),; 3694 llvm::cl::cat(gRootclingOptions));; 3695static llvm::cl::opt<bool> gOptRootBuild(""rootbuild"", llvm::cl::desc(""If we are building ROOT.""),; 3696 llvm::cl::Hidden,; 3697 llvm::cl::cat(gRootclingOptions));; 3698enum VerboseLevel {; 3699 v = ROOT::TMetaUtils::kError,; 3700 v0 = ROOT::TMetaUtils::kFatal,; 3701 v1 = v,; 3702 v2 = ROOT::TMetaUtils::kWarning,; 3703 v3 = ROOT::TMetaUtils::kNote,; 3704 v4 = ROOT::TMetaUtils::kInfo; 3705};; 3706static llvm::cl::opt<VerboseLevel>; 3707gOptVerboseLevel(llvm::cl::desc(""Choose verbosity level:""),; 3708 llvm::cl::values(clEnumVal(v, ""Show errors.""),; 3709 clEnumVal(v0, ""Show only fatal errors.""),; 3710 clEnumVal(v1, ""Show errors (the same as -v).""),; 3711 clEnumVal(v2, ""Show warnings (default).""),; 3712 clEnumVal(v3, ""Show notes.""),; 3713 clEnumVal(v4, ""Show information."")),; 3714 llvm::cl::init(v2),; 3715 llvm::cl::cat(gRootclingOptions));; 3716 ; 3717static llvm::cl::opt<bool>; 3718gOptCint(""cint"", llvm::cl::desc(""Deprecated, legacy flag which is ignored.""),; 3719 llvm::cl::Hidden,; 3720 llvm::cl::cat(gRootclingOptions));; 3721static llvm::cl::opt<bool>; 3722gOptReflex(""reflex"", llvm::cl::desc(""Behave internally like genreflex.""),; 3723 llvm::cl::cat(gRootclingOptions));; 3724static llvm::cl::opt<bool>; 3725gOptGccXml(""gccxml"", llvm::cl::desc(""Deprecated, legacy flag which is ignored.""),; 3726 llvm::cl::Hidden,; 3727 llvm::cl::cat(gRootclingOptions));; 3728static llvm::cl::opt<std::string>; 3729gOptLibListPrefix(""lib-list-prefix"",; 3730 llvm::cl::desc(""An ACLiC feature which exports the list of dependent libraries.""),; 3731 llvm::cl::Hidden,; 3732 llvm::cl::cat(gRootclingOptions));; 3733static llvm",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:160654,Availability,error,error,160654,"efPath, const std::string &moduleName); 3948{; 3949 clang::CompilerInstance *CI = interpreter.getCI();; 3950 clang::HeaderSearch &headerSearch = CI->getPreprocessor().getHeaderSearchInfo();; 3951 headerSearch.loadTopLevelSystemModules();; 3952 ; 3953 // Actually lookup the module on the computed module name.; 3954 clang::Module *module = headerSearch.lookupModule(llvm::StringRef(moduleName));; 3955 ; 3956 // Inform the user and abort if we can't find a module with a given name.; 3957 if (!module) {; 3958 ROOT::TMetaUtils::Error(""CheckModuleValid"", ""Couldn't find module with name '%s' in modulemap!\n"",; 3959 moduleName.c_str());; 3960 return false;; 3961 }; 3962 ; 3963 // Check if the loaded module covers all headers that were specified; 3964 // by the user on the command line. This is an integrity check to; 3965 // ensure that our used module map is not containing extraneous headers.; 3966 std::vector<std::array<std::string, 2>> missingHdrMod;; 3967 if (!ModuleContainsHeaders(modGen, headerSearch, module, missingHdrMod)) {; 3968 // FIXME: Upgrade this to an error once modules are stable.; 3969 std::stringstream msgStream;; 3970 msgStream << ""after creating module \"""" << module->Name << ""\"" "";; 3971 if (!module->PresumedModuleMapFile.empty()); 3972 msgStream << ""using modulemap \"""" << module->PresumedModuleMapFile << ""\"" "";; 3973 msgStream << ""the following headers are not part of that module:\n"";; 3974 for (auto &H : missingHdrMod) {; 3975 msgStream << "" "" << H[0];; 3976 if (!H[1].empty()); 3977 msgStream << "" (already part of module \"""" << H[1] << ""\"")"";; 3978 msgStream << ""\n"";; 3979 }; 3980 std::string warningMessage = msgStream.str();; 3981 ; 3982 bool maybeUmbrella = modGen.GetHeaders().size() == 1;; 3983 // We may have an umbrella and forgot to add the flag. Downgrade the; 3984 // warning into an information message.; 3985 // FIXME: We should open the umbrella, extract the set of header files; 3986 // and check if they exist in the modulemap.; 3987 // FIXME: W",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:169147,Availability,failure,failure,169147,"e dictionary name; 4145 if (gOptDictionaryFileName.size() > (PATH_MAX - 1)) {; 4146 ROOT::TMetaUtils::Error(nullptr, ""rootcling: dictionary name too long (more than %d characters): %s\n"",; 4147 (PATH_MAX - 1), gOptDictionaryFileName.c_str());; 4148 return 1;; 4149 }; 4150 ; 4151 dictname = llvm::sys::path::filename(gOptDictionaryFileName).str();; 4152 }; 4153 ; 4154 if (gOptForce && dictname.empty()) {; 4155 ROOT::TMetaUtils::Error(nullptr, ""Inconsistent set of arguments detected: overwrite of dictionary file forced but no filename specified.\n"");; 4156 llvm::cl::PrintHelpMessage();; 4157 return 1;; 4158 }; 4159 ; 4160 std::vector<std::string> clingArgs;; 4161 clingArgs.push_back(executableFileName);; 4162 clingArgs.push_back(""-iquote."");; 4163 ; 4164 bool dictSelection = !gOptNoDictSelection;; 4165 ; 4166 // Collect the diagnostic pragmas linked to the usage of -W; 4167 // Workaround for ROOT-5656; 4168 std::list<std::string> diagnosticPragmas = {""#pragma clang diagnostic ignored \""-Wdeprecated-declarations\""""};; 4169 ; 4170 if (gOptFailOnWarnings) {; 4171 using namespace ROOT::TMetaUtils;; 4172 // If warnings are disabled with the current verbosity settings, lower; 4173 // it so that the user sees the warning that caused the failure.; 4174 if (GetErrorIgnoreLevel() > kWarning); 4175 GetErrorIgnoreLevel() = kWarning;; 4176 GetWarningsAreErrors() = true;; 4177 }; 4178 ; 4179 if (gOptISysRoot != ""-"") {; 4180 if (gOptISysRoot.empty()) {; 4181 ROOT::TMetaUtils::Error("""", ""isysroot specified without a value.\n"");; 4182 return 1;; 4183 }; 4184 clingArgs.push_back(gOptISysRoot.ArgStr.str());; 4185 clingArgs.push_back(gOptISysRoot.ValueStr.str());; 4186 }; 4187 ; 4188 // Check if we have a multi dict request but no target library; 4189 if (gOptMultiDict && gOptSharedLibFileName.empty()) {; 4190 ROOT::TMetaUtils::Error("""", ""Multidict requested but no target library. Please specify one with the -s argument.\n"");; 4191 return 1;; 4192 }; 4193 ; 4194 for (const std::string &PP",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:172684,Availability,error,error,172684,"f (isInclude) {; 4232 unsigned int offset = 2; // -I is two characters. Now account for spaces; 4233 char c = thisArg[offset];; 4234 while (c == ' ') c = thisArg[++offset];; 4235 auto excludePathsEnd = gOptExcludePaths.end();; 4236 auto excludePathPos = std::find_if(gOptExcludePaths.begin(),; 4237 excludePathsEnd,; 4238 [&](const std::string& path){; 4239 return ROOT::TMetaUtils::BeginsWith(&thisArg[offset], path);});; 4240 if (excludePathsEnd != excludePathPos) continue;; 4241 }; 4242 pcmArgs.push_back(thisArg);; 4243 }; 4244 ; 4245 // cling-only arguments; 4246 clingArgs.push_back(std::string(""-I"") + llvm::sys::path::convert_to_slash(gDriverConfig->fTROOT__GetEtcDir()));; 4247 // We do not want __ROOTCLING__ in the pch!; 4248 if (!gOptGeneratePCH) {; 4249 clingArgs.push_back(""-D__ROOTCLING__"");; 4250 }; 4251#ifdef R__MACOSX; 4252 clingArgs.push_back(""-DSYSTEM_TYPE_macosx"");; 4253#elif defined(R__WIN32); 4254 clingArgs.push_back(""-DSYSTEM_TYPE_winnt"");; 4255 ; 4256 // Prevent the following #error: The C++ Standard Library forbids macroizing keywords.; 4257 clingArgs.push_back(""-D_XKEYCHECK_H"");; 4258 // Tell windows.h not to #define min and max, it clashes with numerical_limits.; 4259 clingArgs.push_back(""-DNOMINMAX"");; 4260#else // assume UNIX; 4261 clingArgs.push_back(""-DSYSTEM_TYPE_unix"");; 4262#endif; 4263 ; 4264 clingArgs.push_back(""-fsyntax-only"");; 4265#ifndef R__WIN32; 4266 clingArgs.push_back(""-fPIC"");; 4267#endif; 4268 clingArgs.push_back(""-Xclang"");; 4269 clingArgs.push_back(""-fmodules-embed-all-files"");; 4270 clingArgs.push_back(""-Xclang"");; 4271 clingArgs.push_back(""-main-file-name"");; 4272 clingArgs.push_back(""-Xclang"");; 4273 clingArgs.push_back((dictname + "".h"").c_str());; 4274 ; 4275 ROOT::TMetaUtils::SetPathsForRelocatability(clingArgs);; 4276 ; 4277 // FIXME: This line is from TModuleGenerator, but we can't reuse this code; 4278 // at this point because TModuleGenerator needs a CompilerInstance (and we; 4279 // currently create the arguments for c",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:183701,Availability,error,error,183701,"terp.getOptions().ErrorOut = true;; 4451 interp.enableRawInput(true);; 4452 ; 4453 if (gOptCxxModule) {; 4454 for (llvm::StringRef DepMod : gOptModuleDependencies) {; 4455 if (DepMod.endswith(""_rdict.pcm"")) {; 4456 ROOT::TMetaUtils::Warning(nullptr, ""'%s' value is deprecated. Please use [<fullpath>]%s.pcm\n"",; 4457 DepMod.data(),; 4458 GetModuleNameFromRdictName(DepMod).str().data());; 4459 }; 4460 DepMod = GetModuleNameFromRdictName(DepMod);; 4461 // We might deserialize.; 4462 cling::Interpreter::PushTransactionRAII RAII(&interp);; 4463 if (!interp.loadModule(DepMod.str(), /*complain*/false)) {; 4464 ROOT::TMetaUtils::Error(nullptr, ""Module '%s' failed to load.\n"",; 4465 DepMod.data());; 4466 }; 4467 }; 4468 }; 4469 ; 4470 if (!isGenreflex) { // rootcling; 4471 // ROOTCINT uses to define a few header implicitly, we need to do it explicitly.; 4472 if (interp.declare(""#include <assert.h>\n""; 4473 ""#include \""Rtypes.h\""\n""; 4474 ""#include \""TObject.h\"""") != cling::Interpreter::kSuccess; 4475 ) {; 4476 // There was an error.; 4477 ROOT::TMetaUtils::Error(nullptr, ""Error loading the default rootcling header files.\n"");; 4478 return 1;; 4479 }; 4480 }; 4481 ; 4482 if (interp.declare(""#include <string>\n"" // For the list of 'opaque' typedef to also include string.; 4483 ""#include <RtypesCore.h>\n"" // For initializing TNormalizedCtxt.; 4484 ""namespace std {} using namespace std;"") != cling::Interpreter::kSuccess) {; 4485 ROOT::TMetaUtils::Error(nullptr, ""Error loading the default header files.\n"");; 4486 return 1;; 4487 }; 4488 ; 4489 // We are now ready (enough is loaded) to init the list of opaque typedefs.; 4490 ROOT::TMetaUtils::TNormalizedCtxt normCtxt(interp.getLookupHelper());; 4491 ROOT::TMetaUtils::TClingLookupHelper helper(interp, normCtxt, nullptr, nullptr, nullptr);; 4492 TClassEdit::Init(&helper);; 4493 ; 4494 // flags used only for the pragma parser:; 4495 clingArgs.push_back(""-D__CINT__"");; 4496 clingArgs.push_back(""-D__MAKECINT__"");; 4497 ; 4498 AddPlatfor",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:185308,Availability,error,error,185308,"are now ready (enough is loaded) to init the list of opaque typedefs.; 4490 ROOT::TMetaUtils::TNormalizedCtxt normCtxt(interp.getLookupHelper());; 4491 ROOT::TMetaUtils::TClingLookupHelper helper(interp, normCtxt, nullptr, nullptr, nullptr);; 4492 TClassEdit::Init(&helper);; 4493 ; 4494 // flags used only for the pragma parser:; 4495 clingArgs.push_back(""-D__CINT__"");; 4496 clingArgs.push_back(""-D__MAKECINT__"");; 4497 ; 4498 AddPlatformDefines(clingArgs);; 4499 ; 4500 std::string currentDirectory = ROOT::FoundationUtils::GetCurrentDir();; 4501 ; 4502 std::string interpPragmaSource;; 4503 std::string includeForSource;; 4504 std::string interpreterDeclarations;; 4505 std::string linkdef;; 4506 ; 4507 for (size_t i = 0, e = gOptDictionaryHeaderFiles.size(); i < e; ++i) {; 4508 const std::string& optHeaderFileName = gOptDictionaryHeaderFiles[i];; 4509 bool isSelectionFile = IsSelectionFile(optHeaderFileName.c_str());; 4510 ; 4511 if (isSelectionFile) {; 4512 if (i == e - 1) {; 4513 linkdef = optHeaderFileName;; 4514 } else { // if the linkdef was not last, issue an error.; 4515 ROOT::TMetaUtils::Error(nullptr, ""%s: %s must be last file on command line\n"",; 4516 executableFileName, optHeaderFileName.c_str());; 4517 return 1;; 4518 }; 4519 }; 4520 ; 4521 // coverity[tainted_data] The OS should already limit the argument size, so we are safe here; 4522 std::string fullheader(optHeaderFileName);; 4523 // Strip any trailing + which is only used by GeneratedLinkdef.h which currently; 4524 // use directly argv.; 4525 if (fullheader[fullheader.length() - 1] == '+') {; 4526 fullheader.erase(fullheader.length() - 1);; 4527 }; 4528 std::string header(; 4529 isSelectionFile ? fullheader : ROOT::FoundationUtils::MakePathRelative(fullheader, currentDirectory, gBuildingROOT));; 4530 ; 4531 interpPragmaSource += std::string(""#include \"""") + header + ""\""\n"";; 4532 if (!isSelectionFile) {; 4533 // In order to not have to add the equivalent to -I${PWD} to the; 4534 // command line, include",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:186313,Availability,down,down,186313,"ool isSelectionFile = IsSelectionFile(optHeaderFileName.c_str());; 4510 ; 4511 if (isSelectionFile) {; 4512 if (i == e - 1) {; 4513 linkdef = optHeaderFileName;; 4514 } else { // if the linkdef was not last, issue an error.; 4515 ROOT::TMetaUtils::Error(nullptr, ""%s: %s must be last file on command line\n"",; 4516 executableFileName, optHeaderFileName.c_str());; 4517 return 1;; 4518 }; 4519 }; 4520 ; 4521 // coverity[tainted_data] The OS should already limit the argument size, so we are safe here; 4522 std::string fullheader(optHeaderFileName);; 4523 // Strip any trailing + which is only used by GeneratedLinkdef.h which currently; 4524 // use directly argv.; 4525 if (fullheader[fullheader.length() - 1] == '+') {; 4526 fullheader.erase(fullheader.length() - 1);; 4527 }; 4528 std::string header(; 4529 isSelectionFile ? fullheader : ROOT::FoundationUtils::MakePathRelative(fullheader, currentDirectory, gBuildingROOT));; 4530 ; 4531 interpPragmaSource += std::string(""#include \"""") + header + ""\""\n"";; 4532 if (!isSelectionFile) {; 4533 // In order to not have to add the equivalent to -I${PWD} to the; 4534 // command line, include the complete file name, even if it is a; 4535 // full pathname, when we write it down in the dictionary.; 4536 // Note: have -I${PWD} means in that (at least in the case of; 4537 // ACLiC) we inadvertently pick local file that have the same; 4538 // name as system header (e.g. new or list) and -iquote has not; 4539 // equivalent on some platforms.; 4540 includeForSource += std::string(""#include \"""") + fullheader + ""\""\n"";; 4541 pcmArgs.push_back(header);; 4542 } else if (!IsSelectionXml(optHeaderFileName.c_str())) {; 4543 interpreterDeclarations += std::string(""#include \"""") + header + ""\""\n"";; 4544 }; 4545 }; 4546 ; 4547 if (gOptUmbrellaInput) {; 4548 bool hasSelectionFile = !linkdef.empty();; 4549 unsigned expectedHeaderFilesSize = 1 + hasSelectionFile;; 4550 if (gOptDictionaryHeaderFiles.size() > expectedHeaderFilesSize); 4551 ROOT::TMetaUtils:",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:189548,Availability,failure,failure,189548," -Wno-xyz flags as pragmas:\n%s"", res.str().c_str());; 4587 return 1;; 4588 }; 4589 }; 4590 ; 4591 class IgnoringPragmaHandler: public clang::PragmaNamespace {; 4592 public:; 4593 IgnoringPragmaHandler(const char* pragma):; 4594 clang::PragmaNamespace(pragma) {}; 4595 void HandlePragma(clang::Preprocessor &PP,; 4596 clang::PragmaIntroducer Introducer,; 4597 clang::Token &tok) override {; 4598 PP.DiscardUntilEndOfDirective();; 4599 }; 4600 };; 4601 ; 4602 // Ignore these #pragmas to suppress ""unknown pragma"" warnings.; 4603 // See LinkdefReader.cxx.; 4604 PP.AddPragmaHandler(new IgnoringPragmaHandler(""link""));; 4605 PP.AddPragmaHandler(new IgnoringPragmaHandler(""extra_include""));; 4606 PP.AddPragmaHandler(new IgnoringPragmaHandler(""read""));; 4607 PP.AddPragmaHandler(new IgnoringPragmaHandler(""create""));; 4608 ; 4609 if (!interpreterDeclarations.empty() &&; 4610 interp.declare(interpreterDeclarations) != cling::Interpreter::kSuccess) {; 4611 ROOT::TMetaUtils::Error(nullptr, ""%s: Linkdef compilation failure\n"", executableFileName);; 4612 return 1;; 4613 }; 4614 ; 4615 ; 4616 TModuleGenerator modGen(interp.getCI(),; 4617 gOptInlineInput,; 4618 gOptSharedLibFileName,; 4619 gOptWriteEmptyRootPCM);; 4620 ; 4621 if (!gDriverConfig->fBuildingROOTStage1 && !filesIncludedByLinkdef.empty()) {; 4622 pcmArgs.push_back(linkdef);; 4623 }; 4624 ; 4625 modGen.ParseArgs(pcmArgs);; 4626 ; 4627 if (!gDriverConfig->fBuildingROOTStage1) {; 4628 // Forward the -I, -D, -U; 4629 for (const std::string & inclPath : modGen.GetIncludePaths()) {; 4630 interp.AddIncludePath(inclPath);; 4631 }; 4632 std::stringstream definesUndefinesStr;; 4633 modGen.WritePPDefines(definesUndefinesStr);; 4634 modGen.WritePPUndefines(definesUndefinesStr);; 4635 if (!definesUndefinesStr.str().empty()) {; 4636 if (interp.declare(definesUndefinesStr.str()) != cling::Interpreter::kSuccess) {; 4637 ROOT::TMetaUtils::Error(nullptr, ""Failed to parse -D, -U flags as preprocessor directives:\n%s"", definesUndefinesStr.str().",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:196433,Availability,failure,failure,196433,"terpPragmaSource, clingArgs,; 4765 llvmResourceDir.c_str())) {; 4766 ROOT::TMetaUtils::Error(nullptr, ""Parsing #pragma failed %s\n"", linkdefFilename.c_str());; 4767 rootclingRetCode += 1;; 4768 } else {; 4769 ROOT::TMetaUtils::Info(nullptr, ""#pragma successfully parsed.\n"");; 4770 }; 4771 ; 4772 if (!ldefr.LoadIncludes(extraIncludes)) {; 4773 ROOT::TMetaUtils::Error(nullptr, ""Error loading the #pragma extra_include.\n"");; 4774 return 1;; 4775 }; 4776 ; 4777 } else if (isSelXML) {; 4778 ; 4779 selectionRules.SetSelectionFileType(SelectionRules::kSelectionXMLFile);; 4780 ; 4781 std::ifstream file(linkdefFilename.c_str());; 4782 if (file.is_open()) {; 4783 ROOT::TMetaUtils::Info(nullptr, ""Selection XML file\n"");; 4784 ; 4785 XMLReader xmlr(interp);; 4786 if (!xmlr.Parse(linkdefFilename.c_str(), selectionRules)) {; 4787 ROOT::TMetaUtils::Error(nullptr, ""Parsing XML file %s\n"", linkdefFilename.c_str());; 4788 return 1; // Return here to propagate the failure up to the build system; 4789 } else {; 4790 ROOT::TMetaUtils::Info(nullptr, ""XML file successfully parsed\n"");; 4791 }; 4792 file.close();; 4793 } else {; 4794 ROOT::TMetaUtils::Error(nullptr, ""XML file %s couldn't be opened!\n"", linkdefFilename.c_str());; 4795 }; 4796 ; 4797 } else {; 4798 ; 4799 ROOT::TMetaUtils::Error(nullptr, ""Unrecognized selection file: %s\n"", linkdefFilename.c_str());; 4800 ; 4801 }; 4802 ; 4803 // Speed up the operations with rules; 4804 selectionRules.FillCache();; 4805 selectionRules.Optimize();; 4806 ; 4807 if (isGenreflex){; 4808 if (0 != selectionRules.CheckDuplicates()){; 4809 return 1;; 4810 }; 4811 }; 4812 ; 4813 // If we want to validate the selection only, we just quit.; 4814 if (gOptCheckSelectionSyntax); 4815 return 0;; 4816 ; 4817 //---------------------------------------------------------------------------; 4818 // Write schema evolution related headers and declarations; 4819 /////////////////////////////////////////////////////////////////////////////; 4820 ; 4821 if ((!ROOT::g",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:199522,Availability,error,error,199522,"r::EScanType::kTwoPasses;; 4852 ; 4853 RScanner scan(selectionRules,; 4854 scanType,; 4855 interp,; 4856 normCtxt,; 4857 scannerVerbLevel);; 4858 ; 4859 // If needed initialize the autoloading hook; 4860 if (!gOptLibListPrefix.empty()) {; 4861 LoadLibraryMap(gOptLibListPrefix + "".in"", gAutoloads);; 4862 scan.SetRecordDeclCallback(RecordDeclCallback);; 4863 }; 4864 ; 4865 scan.Scan(CI->getASTContext());; 4866 ; 4867 bool has_input_error = false;; 4868 ; 4869 if (genreflex::verbose); 4870 selectionRules.PrintSelectionRules();; 4871 ; 4872 if (ROOT::TMetaUtils::GetErrorIgnoreLevel() != ROOT::TMetaUtils::kFatal &&; 4873 !gOptGeneratePCH &&; 4874 !dictSelRulesPresent &&; 4875 !selectionRules.AreAllSelectionRulesUsed()) {; 4876 ROOT::TMetaUtils::Warning(nullptr, ""Not all selection rules are used!\n"");; 4877 }; 4878 ; 4879 if (!gOptGeneratePCH){; 4880 rootclingRetCode += CheckForUnsupportedClasses(scan.fSelectedClasses);; 4881 if (rootclingRetCode) return rootclingRetCode;; 4882 }; 4883 ; 4884 // SELECTION LOOP; 4885 // Check for error in the class layout before doing anything else.; 4886 for (auto const & annRcd : scan.fSelectedClasses) {; 4887 if (ROOT::TMetaUtils::ClassInfo__HasMethod(annRcd, ""Streamer"", interp)) {; 4888 if (annRcd.RequestNoInputOperator()) {; 4889 int version = ROOT::TMetaUtils::GetClassVersion(annRcd, interp);; 4890 if (version != 0) {; 4891 // Only Check for input operator is the object is I/O has; 4892 // been requested.; 4893 has_input_error |= CheckInputOperator(annRcd, interp);; 4894 }; 4895 }; 4896 }; 4897 has_input_error |= !CheckClassDef(*annRcd, interp);; 4898 }; 4899 ; 4900 if (has_input_error) {; 4901 // Be a little bit makefile friendly and remove the dictionary in case of error.; 4902 // We could add an option -k to keep the file even in case of error.; 4903 exit(1);; 4904 }; 4905 ; 4906 //---------------------------------------------------------------------------; 4907 // Write all the necessary #include; 4908 ////////////////////////////",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:200212,Availability,error,error,200212,"etaUtils::kFatal &&; 4873 !gOptGeneratePCH &&; 4874 !dictSelRulesPresent &&; 4875 !selectionRules.AreAllSelectionRulesUsed()) {; 4876 ROOT::TMetaUtils::Warning(nullptr, ""Not all selection rules are used!\n"");; 4877 }; 4878 ; 4879 if (!gOptGeneratePCH){; 4880 rootclingRetCode += CheckForUnsupportedClasses(scan.fSelectedClasses);; 4881 if (rootclingRetCode) return rootclingRetCode;; 4882 }; 4883 ; 4884 // SELECTION LOOP; 4885 // Check for error in the class layout before doing anything else.; 4886 for (auto const & annRcd : scan.fSelectedClasses) {; 4887 if (ROOT::TMetaUtils::ClassInfo__HasMethod(annRcd, ""Streamer"", interp)) {; 4888 if (annRcd.RequestNoInputOperator()) {; 4889 int version = ROOT::TMetaUtils::GetClassVersion(annRcd, interp);; 4890 if (version != 0) {; 4891 // Only Check for input operator is the object is I/O has; 4892 // been requested.; 4893 has_input_error |= CheckInputOperator(annRcd, interp);; 4894 }; 4895 }; 4896 }; 4897 has_input_error |= !CheckClassDef(*annRcd, interp);; 4898 }; 4899 ; 4900 if (has_input_error) {; 4901 // Be a little bit makefile friendly and remove the dictionary in case of error.; 4902 // We could add an option -k to keep the file even in case of error.; 4903 exit(1);; 4904 }; 4905 ; 4906 //---------------------------------------------------------------------------; 4907 // Write all the necessary #include; 4908 /////////////////////////////////////////////////////////////////////////////; 4909 if (!gDriverConfig->fBuildingROOTStage1) {; 4910 for (auto &&includedFromLinkdef : filesIncludedByLinkdef) {; 4911 includeForSource += ""#include \"""" + includedFromLinkdef + ""\""\n"";; 4912 }; 4913 }; 4914 ; 4915 if (!gOptGeneratePCH) {; 4916 if (!gOptIgnoreExistingDict) {; 4917 GenerateNecessaryIncludes(dictStream, includeForSource, extraIncludes);; 4918 if (gOptSplit) {; 4919 GenerateNecessaryIncludes(*splitDictStream, includeForSource, extraIncludes);; 4920 }; 4921 }; 4922 if (!gOptNoGlobalUsingStd) {; 4923 // ACLiC'ed macros might hav",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:200287,Availability,error,error,200287,"all selection rules are used!\n"");; 4877 }; 4878 ; 4879 if (!gOptGeneratePCH){; 4880 rootclingRetCode += CheckForUnsupportedClasses(scan.fSelectedClasses);; 4881 if (rootclingRetCode) return rootclingRetCode;; 4882 }; 4883 ; 4884 // SELECTION LOOP; 4885 // Check for error in the class layout before doing anything else.; 4886 for (auto const & annRcd : scan.fSelectedClasses) {; 4887 if (ROOT::TMetaUtils::ClassInfo__HasMethod(annRcd, ""Streamer"", interp)) {; 4888 if (annRcd.RequestNoInputOperator()) {; 4889 int version = ROOT::TMetaUtils::GetClassVersion(annRcd, interp);; 4890 if (version != 0) {; 4891 // Only Check for input operator is the object is I/O has; 4892 // been requested.; 4893 has_input_error |= CheckInputOperator(annRcd, interp);; 4894 }; 4895 }; 4896 }; 4897 has_input_error |= !CheckClassDef(*annRcd, interp);; 4898 }; 4899 ; 4900 if (has_input_error) {; 4901 // Be a little bit makefile friendly and remove the dictionary in case of error.; 4902 // We could add an option -k to keep the file even in case of error.; 4903 exit(1);; 4904 }; 4905 ; 4906 //---------------------------------------------------------------------------; 4907 // Write all the necessary #include; 4908 /////////////////////////////////////////////////////////////////////////////; 4909 if (!gDriverConfig->fBuildingROOTStage1) {; 4910 for (auto &&includedFromLinkdef : filesIncludedByLinkdef) {; 4911 includeForSource += ""#include \"""" + includedFromLinkdef + ""\""\n"";; 4912 }; 4913 }; 4914 ; 4915 if (!gOptGeneratePCH) {; 4916 if (!gOptIgnoreExistingDict) {; 4917 GenerateNecessaryIncludes(dictStream, includeForSource, extraIncludes);; 4918 if (gOptSplit) {; 4919 GenerateNecessaryIncludes(*splitDictStream, includeForSource, extraIncludes);; 4920 }; 4921 }; 4922 if (!gOptNoGlobalUsingStd) {; 4923 // ACLiC'ed macros might have relied on `using namespace std` in front of user headers; 4924 if (!isACLiC) {; 4925 AddNamespaceSTDdeclaration(dictStream);; 4926 if (gOptSplit) {; 4927 AddNamespaceSTDdecl",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:205680,Availability,error,errors,205680,"ceDir, interp, linkdefFilename, moduleName.str())); 5026 return 1;; 5027 }; 5028 }; 5029 }; 5030 ; 5031 ; 5032 if (!gOptLibListPrefix.empty()) {; 5033 string liblist_filename = gOptLibListPrefix + "".out"";; 5034 ; 5035 ofstream outputfile(liblist_filename.c_str(), ios::out);; 5036 if (!outputfile) {; 5037 ROOT::TMetaUtils::Error(nullptr, ""%s: Unable to open output lib file %s\n"",; 5038 executableFileName, liblist_filename.c_str());; 5039 } else {; 5040 const size_t endStr = gLibsNeeded.find_last_not_of("" \t"");; 5041 outputfile << gLibsNeeded.substr(0, endStr + 1) << endl;; 5042 // Add explicit delimiter; 5043 outputfile << ""# Now the list of classes\n"";; 5044 // SELECTION LOOP; 5045 for (auto const & annRcd : scan.fSelectedClasses) {; 5046 // Shouldn't it be GetLong64_Name( cl_input.GetNormalizedName() ); 5047 // or maybe we should be normalizing to turn directly all long long into Long64_t; 5048 outputfile << annRcd.GetNormalizedName() << endl;; 5049 }; 5050 }; 5051 }; 5052 ; 5053 // Check for errors in module generation; 5054 rootclingRetCode += modGen.GetErrorCount();; 5055 if (0 != rootclingRetCode) return rootclingRetCode;; 5056 ; 5057 // Create the rootmap file; 5058 std::string rootmapLibName = std::accumulate(gOptRootmapLibNames.begin(),; 5059 gOptRootmapLibNames.end(),; 5060 std::string(),; 5061 [](const std::string & a, const std::string & b) -> std::string {; 5062 if (a.empty()) return b;; 5063 else return a + "" "" + b;; 5064 });; 5065 ; 5066 bool rootMapNeeded = !gOptRootMapFileName.empty() || !rootmapLibName.empty();; 5067 ; 5068 std::list<std::string> classesNames;; 5069 std::list<std::string> classesNamesForRootmap;; 5070 std::list<std::string> classesDefsList;; 5071 ; 5072 rootclingRetCode = ExtractClassesListAndDeclLines(scan,; 5073 classesNames,; 5074 classesNamesForRootmap,; 5075 classesDefsList,; 5076 interp);; 5077 ; 5078 std::list<std::string> enumNames;; 5079 rootclingRetCode += ExtractAutoloadKeys(enumNames,; 5080 scan.fSelectedEnums,; 5081 int",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:208760,Availability,error,errors,208760,"ptRootMapFileName,; 5116 rootmapLibName,; 5117 classesDefsList,; 5118 classesNamesForRootmap,; 5119 nsNames,; 5120 typedefsRootmapLines,; 5121 enumNames,; 5122 varNames,; 5123 headersClassesMap,; 5124 headersToIgnore);; 5125 ; 5126 if (0 != rootclingRetCode) return 1;; 5127 }; 5128 ; 5129 if (genreflex::verbose); 5130 tmpCatalog.dump();; 5131 ; 5132 // Manually call end of translation unit because we never call the; 5133 // appropriate deconstructors in the interpreter. This writes out the C++; 5134 // module file that we currently generate.; 5135 {; 5136 cling::Interpreter::PushTransactionRAII RAII(&interp);; 5137 CI->getSema().getASTConsumer().HandleTranslationUnit(CI->getSema().getASTContext());; 5138 }; 5139 ; 5140 // Add the warnings; 5141 rootclingRetCode += ROOT::TMetaUtils::GetNumberOfErrors();; 5142 ; 5143 // make sure the file is closed before committing; 5144 fileout.close();; 5145 ; 5146 // Before returning, rename the files if no errors occurred; 5147 // otherwise clean them to avoid remnants (see ROOT-10015); 5148 if(rootclingRetCode == 0) {; 5149 rootclingRetCode += tmpCatalog.commit();; 5150 } else {; 5151 tmpCatalog.clean();; 5152 }; 5153 ; 5154 return rootclingRetCode;; 5155 ; 5156}; 5157 ; 5158namespace genreflex {; 5159 ; 5160////////////////////////////////////////////////////////////////////////////////; 5161/// Loop on arguments: stop at the first which starts with -; 5162 ; 5163 unsigned int checkHeadersNames(std::vector<std::string> &headersNames); 5164 {; 5165 unsigned int numberOfHeaders = 0;; 5166 for (std::vector<std::string>::iterator it = headersNames.begin();; 5167 it != headersNames.end(); ++it) {; 5168 const std::string headername(*it);; 5169 if (ROOT::TMetaUtils::IsHeaderName(headername)) {; 5170 numberOfHeaders++;; 5171 } else {; 5172 ROOT::TMetaUtils::Warning(nullptr,; 5173 ""*** genreflex: %s is not a valid header name (.h and .hpp extensions expected)!\n"",; 5174 headername.c_str());; 5175 }; 5176 }; 5177 return numberOfHeaders;;",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:234178,Availability,error,errors,234178,"tion::Arg::None,; 5842 ""--interpreteronly\tDo not generate I/O related information.\n""; 5843 "" Generate minimal dictionary required for interactivity.\n""; 5844 },; 5845 ; 5846 {; 5847 SPLIT,; 5848 NOTYPE,; 5849 """" , ""split"",; 5850 ROOT::option::Arg::None,; 5851 ""--split\tSplit the dictionary\n""; 5852 "" Split in two the dictionary, isolating the part with\n""; 5853 "" ClassDef related functions in a separate file.\n""; 5854 },; 5855 ; 5856 {; 5857 PCMFILENAME,; 5858 STRING ,; 5859 ""m"" , """" ,; 5860 ROOT::option::FullArg::Required,; 5861 ""-m \tPcm file loaded before any header (option can be repeated).\n""; 5862 },; 5863 ; 5864 {; 5865 VERBOSE,; 5866 NOTYPE ,; 5867 ""-v"" , ""verbose"",; 5868 ROOT::option::Arg::None,; 5869 ""-v, --verbose\tPrint some debug information.\n""; 5870 },; 5871 ; 5872 {; 5873 DEBUG,; 5874 NOTYPE ,; 5875 """" , ""debug"",; 5876 ROOT::option::Arg::None,; 5877 ""--debug\tPrint all debug information.\n""; 5878 },; 5879 ; 5880 {; 5881 QUIET,; 5882 NOTYPE ,; 5883 """" , ""quiet"",; 5884 ROOT::option::Arg::None,; 5885 ""--quiet\tPrint only warnings and errors (default).\n""; 5886 },; 5887 ; 5888 {; 5889 SILENT,; 5890 NOTYPE ,; 5891 """" , ""silent"",; 5892 ROOT::option::Arg::None,; 5893 ""--silent\tPrint no information at all.\n""; 5894 },; 5895 ; 5896 {; 5897 WRITEEMPTYROOTPCM,; 5898 NOTYPE ,; 5899 """" , ""writeEmptyPCM"",; 5900 ROOT::option::Arg::None,; 5901 ""--writeEmptyPCM\tWrite an empty ROOT pcm.\n""; 5902 },; 5903 ; 5904 {; 5905 CXXMODULE,; 5906 NOTYPE ,; 5907 """" , ""cxxmodule"",; 5908 ROOT::option::Arg::None,; 5909 ""--cxxmodule\tGenerates a PCM for C++ Modules.\n""; 5910 },; 5911 ; 5912 ; 5913 {; 5914 HELP,; 5915 NOTYPE,; 5916 ""h"" , ""help"",; 5917 ROOT::option::Arg::None,; 5918 ""--help\tPrint usage and exit.\n""; 5919 },; 5920 ; 5921 {; 5922 FAILONWARNINGS,; 5923 NOTYPE,; 5924 """", ""fail_on_warnings"",; 5925 ROOT::option::Arg::None,; 5926 ""--fail_on_warnings\tFail on warnings and errors.\n""; 5927 },; 5928 ; 5929 {; 5930 SELSYNTAXONLY,; 5931 NOTYPE,; 5932 """", ""selSyntaxOnly"",; 593",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:235012,Availability,error,errors,235012,"TYPE ,; 5875 """" , ""debug"",; 5876 ROOT::option::Arg::None,; 5877 ""--debug\tPrint all debug information.\n""; 5878 },; 5879 ; 5880 {; 5881 QUIET,; 5882 NOTYPE ,; 5883 """" , ""quiet"",; 5884 ROOT::option::Arg::None,; 5885 ""--quiet\tPrint only warnings and errors (default).\n""; 5886 },; 5887 ; 5888 {; 5889 SILENT,; 5890 NOTYPE ,; 5891 """" , ""silent"",; 5892 ROOT::option::Arg::None,; 5893 ""--silent\tPrint no information at all.\n""; 5894 },; 5895 ; 5896 {; 5897 WRITEEMPTYROOTPCM,; 5898 NOTYPE ,; 5899 """" , ""writeEmptyPCM"",; 5900 ROOT::option::Arg::None,; 5901 ""--writeEmptyPCM\tWrite an empty ROOT pcm.\n""; 5902 },; 5903 ; 5904 {; 5905 CXXMODULE,; 5906 NOTYPE ,; 5907 """" , ""cxxmodule"",; 5908 ROOT::option::Arg::None,; 5909 ""--cxxmodule\tGenerates a PCM for C++ Modules.\n""; 5910 },; 5911 ; 5912 ; 5913 {; 5914 HELP,; 5915 NOTYPE,; 5916 ""h"" , ""help"",; 5917 ROOT::option::Arg::None,; 5918 ""--help\tPrint usage and exit.\n""; 5919 },; 5920 ; 5921 {; 5922 FAILONWARNINGS,; 5923 NOTYPE,; 5924 """", ""fail_on_warnings"",; 5925 ROOT::option::Arg::None,; 5926 ""--fail_on_warnings\tFail on warnings and errors.\n""; 5927 },; 5928 ; 5929 {; 5930 SELSYNTAXONLY,; 5931 NOTYPE,; 5932 """", ""selSyntaxOnly"",; 5933 ROOT::option::Arg::None,; 5934 ""--selSyntaxOnly\tValidate selection file w/o generating the dictionary.\n""; 5935 },; 5936 ; 5937 {; 5938 NOINCLUDEPATHS,; 5939 NOTYPE ,; 5940 """" , ""noIncludePaths"",; 5941 ROOT::option::Arg::None,; 5942 ""--noIncludePaths\tDo not store the headers' directories in the dictionary. Instead, rely on the environment variable $ROOT_INCLUDE_PATH at runtime.\n""; 5943 },; 5944 ; 5945 // Left intentionally empty not to be shown in the help, like in the first genreflex; 5946 {; 5947 INCLUDE,; 5948 STRING ,; 5949 ""I"" , """" ,; 5950 ROOT::option::FullArg::Required,; 5951 """"; 5952 },; 5953 ; 5954 {; 5955 PREPROCDEFINE,; 5956 STRING ,; 5957 ""D"" , """" ,; 5958 ROOT::option::FullArg::Required,; 5959 """"; 5960 },; 5961 ; 5962 {; 5963 PREPROCUNDEFINE,; 5964 STRING ,; 5965 ""U"" , """" ,; 5966 ROOT::op",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:237414,Availability,error,error,237414," 6002 const int offset = 1; // skip argv[0]; 6003 argc -= offset + extractedArgs;; 6004 argv += offset;; 6005 ; 6006 // Parse the options; 6007 ROOT::option::Stats stats(genreflexUsageDescriptor, argc, argv);; 6008 std::vector<ROOT::option::Option> options(stats.options_max);// non POD var size arrays are not C++!; 6009 std::vector<ROOT::option::Option> buffer(stats.buffer_max);; 6010 // The 4 is the minimum size of the abbreviation length.; 6011 // For example, --selection_file can be abbreviated with --sele at least.; 6012 ; 6013 ROOT::option::Parser parse(genreflexUsageDescriptor, argc, argv, &options[0], &buffer[0], 5);; 6014 ; 6015 if (parse.error()) {; 6016 ROOT::TMetaUtils::Error(nullptr, ""Argument parsing error!\n"");; 6017 return 1;; 6018 }; 6019 ; 6020 // Print help if needed; 6021 if (options[HELP] || originalArgc == 1) {; 6022 ROOT::option::printUsage(std::cout, genreflexUsageDescriptor);; 6023 return 0;; 6024 }; 6025 // See if no header was provided; 6026 int numberOfHeaders = checkHeadersNames(headersNames);; 6027 if (0 == numberOfHeaders) {; 6028 ROOT::TMetaUtils::Error(nullptr, ""No valid header was provided!\n"");; 6029 return 1;; 6030 }; 6031 ; 6032 ROOT::TMetaUtils::GetErrorIgnoreLevel() = ROOT::TMetaUtils::kNote;; 6033 ; 6034 if (options[DEEP]); 6035 ROOT::TMetaUtils::Warning(nullptr, ""--deep has no effect. Please remove the deprecated flag!\n"");; 6036 // The verbosity: debug wins over quiet; 6037 //std::string verbosityOption(""-v4""); // To be uncommented for the testing phase. It should be -v; 6038 std::string verbosityOption(""-v2"");; 6039 if (options[SILENT]) verbosityOption = ""-v0"";; 6040 if (options[VERBOSE] || getenv (""VERBOSE"")) verbosityOption = ""-v3"";; 6041 if (options[DEBUG]) verbosityOption = ""-v4"";; 6042 ; 6043 genreflex::verbose = verbosityOption == ""-v4"";; 6044 ; 6045 // The selection file; 6046 std::string selectionFileName;; 6047 if (options[SELECTIONFILENAME]) {; 6048 selectionFileName = options[SELECTIONFILENAME].arg;; 6049 if (!ROO",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:237482,Availability,error,error,237482," 6002 const int offset = 1; // skip argv[0]; 6003 argc -= offset + extractedArgs;; 6004 argv += offset;; 6005 ; 6006 // Parse the options; 6007 ROOT::option::Stats stats(genreflexUsageDescriptor, argc, argv);; 6008 std::vector<ROOT::option::Option> options(stats.options_max);// non POD var size arrays are not C++!; 6009 std::vector<ROOT::option::Option> buffer(stats.buffer_max);; 6010 // The 4 is the minimum size of the abbreviation length.; 6011 // For example, --selection_file can be abbreviated with --sele at least.; 6012 ; 6013 ROOT::option::Parser parse(genreflexUsageDescriptor, argc, argv, &options[0], &buffer[0], 5);; 6014 ; 6015 if (parse.error()) {; 6016 ROOT::TMetaUtils::Error(nullptr, ""Argument parsing error!\n"");; 6017 return 1;; 6018 }; 6019 ; 6020 // Print help if needed; 6021 if (options[HELP] || originalArgc == 1) {; 6022 ROOT::option::printUsage(std::cout, genreflexUsageDescriptor);; 6023 return 0;; 6024 }; 6025 // See if no header was provided; 6026 int numberOfHeaders = checkHeadersNames(headersNames);; 6027 if (0 == numberOfHeaders) {; 6028 ROOT::TMetaUtils::Error(nullptr, ""No valid header was provided!\n"");; 6029 return 1;; 6030 }; 6031 ; 6032 ROOT::TMetaUtils::GetErrorIgnoreLevel() = ROOT::TMetaUtils::kNote;; 6033 ; 6034 if (options[DEEP]); 6035 ROOT::TMetaUtils::Warning(nullptr, ""--deep has no effect. Please remove the deprecated flag!\n"");; 6036 // The verbosity: debug wins over quiet; 6037 //std::string verbosityOption(""-v4""); // To be uncommented for the testing phase. It should be -v; 6038 std::string verbosityOption(""-v2"");; 6039 if (options[SILENT]) verbosityOption = ""-v0"";; 6040 if (options[VERBOSE] || getenv (""VERBOSE"")) verbosityOption = ""-v3"";; 6041 if (options[DEBUG]) verbosityOption = ""-v4"";; 6042 ; 6043 genreflex::verbose = verbosityOption == ""-v4"";; 6044 ; 6045 // The selection file; 6046 std::string selectionFileName;; 6047 if (options[SELECTIONFILENAME]) {; 6048 selectionFileName = options[SELECTIONFILENAME].arg;; 6049 if (!ROO",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:257558,Availability,error,errorbool,257558,PCHbool IsPCH() constDefinition TModuleGenerator.h:52; ROOT::TModuleGenerator::ParseArgsvoid ParseArgs(const std::vector< std::string > &args)Parse -I -D -U headers.h SomethingLinkdef.h.Definition TModuleGenerator.cxx:180; ROOT::TModuleGenerator::GetContentNameconst std::string & GetContentName() constDefinition TModuleGenerator.h:79; ROOT::TModuleGenerator::WritePPDefinesstd::ostream & WritePPDefines(std::ostream &out) constWrite #ifndef FOO # define FOO=bar #endifDefinition TModuleGenerator.cxx:216; ROOT::option::OptionA parsed option from the command line together with its argument if it has one.Definition OptionParser.h:454; ROOT::option::Option::nextOption * next()Returns a pointer to the next element of the linked list or NULL if called on last().Definition OptionParser.h:682; ROOT::option::ParserChecks argument vectors for validity and parses them into data structures that are easier to work wit...Definition OptionParser.h:1062; ROOT::option::Parser::errorbool error()Returns true if an unrecoverable error occurred while parsing options.Definition OptionParser.h:1264; RScannerDefinition Scanner.h:51; RScanner::Scanvoid Scan(const clang::ASTContext &C)Definition Scanner.cxx:1052; RScanner::ClassColl_tstd::vector< ROOT::TMetaUtils::AnnotatedRecordDecl > ClassColl_tDefinition Scanner.h:72; RScanner::GetDeclsSelRulesMapconst DeclsSelRulesMap_t & GetDeclsSelRulesMap() constDefinition Scanner.h:125; RScanner::fSelectedFunctionsFunctionColl_t fSelectedFunctionsDefinition Scanner.h:131; RScanner::EScanType::kNormal@ kNormal; RScanner::EScanType::kOnePCM@ kOnePCM; RScanner::EScanType::kTwoPasses@ kTwoPasses; RScanner::FunctionColl_tstd::vector< const clang::FunctionDecl * > FunctionColl_tDefinition Scanner.h:74; RScanner::fSelectedNamespacesNamespaceColl_t fSelectedNamespacesDefinition Scanner.h:129; RScanner::fSelectedTypedefsTypedefColl_t fSelectedTypedefsDefinition Scanner.h:130; RScanner::SetRecordDeclCallbackDeclCallback SetRecordDeclCallback(DeclCallback callback),MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:257568,Availability,error,error,257568,PCHbool IsPCH() constDefinition TModuleGenerator.h:52; ROOT::TModuleGenerator::ParseArgsvoid ParseArgs(const std::vector< std::string > &args)Parse -I -D -U headers.h SomethingLinkdef.h.Definition TModuleGenerator.cxx:180; ROOT::TModuleGenerator::GetContentNameconst std::string & GetContentName() constDefinition TModuleGenerator.h:79; ROOT::TModuleGenerator::WritePPDefinesstd::ostream & WritePPDefines(std::ostream &out) constWrite #ifndef FOO # define FOO=bar #endifDefinition TModuleGenerator.cxx:216; ROOT::option::OptionA parsed option from the command line together with its argument if it has one.Definition OptionParser.h:454; ROOT::option::Option::nextOption * next()Returns a pointer to the next element of the linked list or NULL if called on last().Definition OptionParser.h:682; ROOT::option::ParserChecks argument vectors for validity and parses them into data structures that are easier to work wit...Definition OptionParser.h:1062; ROOT::option::Parser::errorbool error()Returns true if an unrecoverable error occurred while parsing options.Definition OptionParser.h:1264; RScannerDefinition Scanner.h:51; RScanner::Scanvoid Scan(const clang::ASTContext &C)Definition Scanner.cxx:1052; RScanner::ClassColl_tstd::vector< ROOT::TMetaUtils::AnnotatedRecordDecl > ClassColl_tDefinition Scanner.h:72; RScanner::GetDeclsSelRulesMapconst DeclsSelRulesMap_t & GetDeclsSelRulesMap() constDefinition Scanner.h:125; RScanner::fSelectedFunctionsFunctionColl_t fSelectedFunctionsDefinition Scanner.h:131; RScanner::EScanType::kNormal@ kNormal; RScanner::EScanType::kOnePCM@ kOnePCM; RScanner::EScanType::kTwoPasses@ kTwoPasses; RScanner::FunctionColl_tstd::vector< const clang::FunctionDecl * > FunctionColl_tDefinition Scanner.h:74; RScanner::fSelectedNamespacesNamespaceColl_t fSelectedNamespacesDefinition Scanner.h:129; RScanner::fSelectedTypedefsTypedefColl_t fSelectedTypedefsDefinition Scanner.h:130; RScanner::SetRecordDeclCallbackDeclCallback SetRecordDeclCallback(DeclCallback callback),MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:257608,Availability,error,error,257608,PCHbool IsPCH() constDefinition TModuleGenerator.h:52; ROOT::TModuleGenerator::ParseArgsvoid ParseArgs(const std::vector< std::string > &args)Parse -I -D -U headers.h SomethingLinkdef.h.Definition TModuleGenerator.cxx:180; ROOT::TModuleGenerator::GetContentNameconst std::string & GetContentName() constDefinition TModuleGenerator.h:79; ROOT::TModuleGenerator::WritePPDefinesstd::ostream & WritePPDefines(std::ostream &out) constWrite #ifndef FOO # define FOO=bar #endifDefinition TModuleGenerator.cxx:216; ROOT::option::OptionA parsed option from the command line together with its argument if it has one.Definition OptionParser.h:454; ROOT::option::Option::nextOption * next()Returns a pointer to the next element of the linked list or NULL if called on last().Definition OptionParser.h:682; ROOT::option::ParserChecks argument vectors for validity and parses them into data structures that are easier to work wit...Definition OptionParser.h:1062; ROOT::option::Parser::errorbool error()Returns true if an unrecoverable error occurred while parsing options.Definition OptionParser.h:1264; RScannerDefinition Scanner.h:51; RScanner::Scanvoid Scan(const clang::ASTContext &C)Definition Scanner.cxx:1052; RScanner::ClassColl_tstd::vector< ROOT::TMetaUtils::AnnotatedRecordDecl > ClassColl_tDefinition Scanner.h:72; RScanner::GetDeclsSelRulesMapconst DeclsSelRulesMap_t & GetDeclsSelRulesMap() constDefinition Scanner.h:125; RScanner::fSelectedFunctionsFunctionColl_t fSelectedFunctionsDefinition Scanner.h:131; RScanner::EScanType::kNormal@ kNormal; RScanner::EScanType::kOnePCM@ kOnePCM; RScanner::EScanType::kTwoPasses@ kTwoPasses; RScanner::FunctionColl_tstd::vector< const clang::FunctionDecl * > FunctionColl_tDefinition Scanner.h:74; RScanner::fSelectedNamespacesNamespaceColl_t fSelectedNamespacesDefinition Scanner.h:129; RScanner::fSelectedTypedefsTypedefColl_t fSelectedTypedefsDefinition Scanner.h:130; RScanner::SetRecordDeclCallbackDeclCallback SetRecordDeclCallback(DeclCallback callback),MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:296444,Availability,error,errors,296444,"TMetaUtils::AnnotatedRecordDecl &cl, const cling::Interpreter &interp, const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt, std::ostream &dictStream)Definition rootcling_impl.cxx:1780; ExtractSelectedNamespacesvoid ExtractSelectedNamespaces(RScanner &scan, std::list< std::string > &nsList)Loop on selected classes and put them in a list.Definition rootcling_impl.cxx:2572; IncludeHeadersstatic bool IncludeHeaders(const std::vector< std::string > &headers, cling::Interpreter &interpreter)Includes all given headers in the interpreter.Definition rootcling_impl.cxx:2048; GetPointeeTypeIfPossibleclang::QualType GetPointeeTypeIfPossible(const clang::QualType &qt)Get the pointee type if possible.Definition rootcling_impl.cxx:3071; AnnotateDeclvoid AnnotateDecl(clang::CXXRecordDecl &CXXRD, const RScanner::DeclsSelRulesMap_t &declSelRulesMap, cling::Interpreter &interpreter, bool isGenreflex)Definition rootcling_impl.cxx:327; gOptVerboseLevelstatic llvm::cl::opt< VerboseLevel > gOptVerboseLevel(llvm::cl::desc(""Choose verbosity level:""), llvm::cl::values(clEnumVal(v, ""Show errors.""), clEnumVal(v0, ""Show only fatal errors.""), clEnumVal(v1, ""Show errors (the same as -v).""), clEnumVal(v2, ""Show warnings (default).""), clEnumVal(v3, ""Show notes.""), clEnumVal(v4, ""Show information."")), llvm::cl::init(v2), llvm::cl::cat(gRootclingOptions)); GenerateLinkdefvoid GenerateLinkdef(llvm::cl::list< std::string > &InputFiles, std::string &code_for_parser)Definition rootcling_impl.cxx:1847; gOptRootMapFileNamestatic llvm::cl::opt< std::string > gOptRootMapFileName(""rmf"", llvm::cl::desc(""Generate a rootmap file with the specified name.""), llvm::cl::cat(gRootclingOptions)); gOptInlineInputstatic llvm::cl::opt< bool > gOptInlineInput(""inlineInputHeader"", llvm::cl::desc(""Does not generate #include <header> but expands the header content.""), llvm::cl::cat(gRootclingOptions)); isPointerToPointerbool isPointerToPointer(const clang::FieldDecl &m)Definition rootcling_impl.cxx:1152; CreateNewRootMapFileint",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:296486,Availability,error,errors,296486,"edCtxt &normCtxt, std::ostream &dictStream)Definition rootcling_impl.cxx:1780; ExtractSelectedNamespacesvoid ExtractSelectedNamespaces(RScanner &scan, std::list< std::string > &nsList)Loop on selected classes and put them in a list.Definition rootcling_impl.cxx:2572; IncludeHeadersstatic bool IncludeHeaders(const std::vector< std::string > &headers, cling::Interpreter &interpreter)Includes all given headers in the interpreter.Definition rootcling_impl.cxx:2048; GetPointeeTypeIfPossibleclang::QualType GetPointeeTypeIfPossible(const clang::QualType &qt)Get the pointee type if possible.Definition rootcling_impl.cxx:3071; AnnotateDeclvoid AnnotateDecl(clang::CXXRecordDecl &CXXRD, const RScanner::DeclsSelRulesMap_t &declSelRulesMap, cling::Interpreter &interpreter, bool isGenreflex)Definition rootcling_impl.cxx:327; gOptVerboseLevelstatic llvm::cl::opt< VerboseLevel > gOptVerboseLevel(llvm::cl::desc(""Choose verbosity level:""), llvm::cl::values(clEnumVal(v, ""Show errors.""), clEnumVal(v0, ""Show only fatal errors.""), clEnumVal(v1, ""Show errors (the same as -v).""), clEnumVal(v2, ""Show warnings (default).""), clEnumVal(v3, ""Show notes.""), clEnumVal(v4, ""Show information."")), llvm::cl::init(v2), llvm::cl::cat(gRootclingOptions)); GenerateLinkdefvoid GenerateLinkdef(llvm::cl::list< std::string > &InputFiles, std::string &code_for_parser)Definition rootcling_impl.cxx:1847; gOptRootMapFileNamestatic llvm::cl::opt< std::string > gOptRootMapFileName(""rmf"", llvm::cl::desc(""Generate a rootmap file with the specified name.""), llvm::cl::cat(gRootclingOptions)); gOptInlineInputstatic llvm::cl::opt< bool > gOptInlineInput(""inlineInputHeader"", llvm::cl::desc(""Does not generate #include <header> but expands the header content.""), llvm::cl::cat(gRootclingOptions)); isPointerToPointerbool isPointerToPointer(const clang::FieldDecl &m)Definition rootcling_impl.cxx:1152; CreateNewRootMapFileint CreateNewRootMapFile(const std::string &rootmapFileName, const std::string &rootmapLibName, const std:",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:296517,Availability,error,errors,296517,"finition rootcling_impl.cxx:1780; ExtractSelectedNamespacesvoid ExtractSelectedNamespaces(RScanner &scan, std::list< std::string > &nsList)Loop on selected classes and put them in a list.Definition rootcling_impl.cxx:2572; IncludeHeadersstatic bool IncludeHeaders(const std::vector< std::string > &headers, cling::Interpreter &interpreter)Includes all given headers in the interpreter.Definition rootcling_impl.cxx:2048; GetPointeeTypeIfPossibleclang::QualType GetPointeeTypeIfPossible(const clang::QualType &qt)Get the pointee type if possible.Definition rootcling_impl.cxx:3071; AnnotateDeclvoid AnnotateDecl(clang::CXXRecordDecl &CXXRD, const RScanner::DeclsSelRulesMap_t &declSelRulesMap, cling::Interpreter &interpreter, bool isGenreflex)Definition rootcling_impl.cxx:327; gOptVerboseLevelstatic llvm::cl::opt< VerboseLevel > gOptVerboseLevel(llvm::cl::desc(""Choose verbosity level:""), llvm::cl::values(clEnumVal(v, ""Show errors.""), clEnumVal(v0, ""Show only fatal errors.""), clEnumVal(v1, ""Show errors (the same as -v).""), clEnumVal(v2, ""Show warnings (default).""), clEnumVal(v3, ""Show notes.""), clEnumVal(v4, ""Show information."")), llvm::cl::init(v2), llvm::cl::cat(gRootclingOptions)); GenerateLinkdefvoid GenerateLinkdef(llvm::cl::list< std::string > &InputFiles, std::string &code_for_parser)Definition rootcling_impl.cxx:1847; gOptRootMapFileNamestatic llvm::cl::opt< std::string > gOptRootMapFileName(""rmf"", llvm::cl::desc(""Generate a rootmap file with the specified name.""), llvm::cl::cat(gRootclingOptions)); gOptInlineInputstatic llvm::cl::opt< bool > gOptInlineInput(""inlineInputHeader"", llvm::cl::desc(""Does not generate #include <header> but expands the header content.""), llvm::cl::cat(gRootclingOptions)); isPointerToPointerbool isPointerToPointer(const clang::FieldDecl &m)Definition rootcling_impl.cxx:1152; CreateNewRootMapFileint CreateNewRootMapFile(const std::string &rootmapFileName, const std::string &rootmapLibName, const std::list< std::string > &classesDefsList, const ",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:86944,Deployability,update,updates,86944,"bName); 2177{; 2178 // If the rootmap file name does not exist, create one following the libname; 2179 // I.E. put into the directory of the lib the rootmap and within the rootmap the normalised path to the lib; 2180 if (rootmapFileName.empty()) {; 2181 size_t libExtensionPos = rootmapLibName.find_last_of(gLibraryExtension) - gLibraryExtension.size() + 1;; 2182 rootmapFileName = rootmapLibName.substr(0, libExtensionPos) + "".rootmap"";; 2183 size_t libCleanNamePos = rootmapLibName.find_last_of(gPathSeparator) + 1;; 2184 rootmapLibName = rootmapLibName.substr(libCleanNamePos, std::string::npos);; 2185 ROOT::TMetaUtils::Info(nullptr, ""Rootmap file name %s built from rootmap lib name %s"",; 2186 rootmapLibName.c_str(),; 2187 rootmapFileName.c_str());; 2188 }; 2189}; 2190 ; 2191////////////////////////////////////////////////////////////////////////////////; 2192/// Extract the proper autoload key for nested classes; 2193/// The routine does not erase the name, just updates it; 2194 ; 2195void GetMostExternalEnclosingClassName(const clang::DeclContext &theContext,; 2196 std::string &ctxtName,; 2197 const cling::Interpreter &interpreter,; 2198 bool treatParent = true); 2199{; 2200 const clang::DeclContext *outerCtxt = treatParent ? theContext.getParent() : &theContext;; 2201 // If the context has no outer context, we are finished; 2202 if (!outerCtxt) return;; 2203 // If the context is a class, we update the name; 2204 if (const clang::RecordDecl *thisRcdDecl = llvm::dyn_cast<clang::RecordDecl>(outerCtxt)) {; 2205 ROOT::TMetaUtils::GetNormalizedName(ctxtName, thisRcdDecl, interpreter);; 2206 }; 2207 // We recurse; 2208 GetMostExternalEnclosingClassName(*outerCtxt, ctxtName, interpreter);; 2209}; 2210 ; 2211////////////////////////////////////////////////////////////////////////////////; 2212 ; 2213void GetMostExternalEnclosingClassNameFromDecl(const clang::Decl &theDecl,; 2214 std::string &ctxtName,; 2215 const cling::Interpreter &interpreter); 2216{; 2217 const clang::Decl",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:87383,Deployability,update,update,87383,"tmap file name %s built from rootmap lib name %s"",; 2186 rootmapLibName.c_str(),; 2187 rootmapFileName.c_str());; 2188 }; 2189}; 2190 ; 2191////////////////////////////////////////////////////////////////////////////////; 2192/// Extract the proper autoload key for nested classes; 2193/// The routine does not erase the name, just updates it; 2194 ; 2195void GetMostExternalEnclosingClassName(const clang::DeclContext &theContext,; 2196 std::string &ctxtName,; 2197 const cling::Interpreter &interpreter,; 2198 bool treatParent = true); 2199{; 2200 const clang::DeclContext *outerCtxt = treatParent ? theContext.getParent() : &theContext;; 2201 // If the context has no outer context, we are finished; 2202 if (!outerCtxt) return;; 2203 // If the context is a class, we update the name; 2204 if (const clang::RecordDecl *thisRcdDecl = llvm::dyn_cast<clang::RecordDecl>(outerCtxt)) {; 2205 ROOT::TMetaUtils::GetNormalizedName(ctxtName, thisRcdDecl, interpreter);; 2206 }; 2207 // We recurse; 2208 GetMostExternalEnclosingClassName(*outerCtxt, ctxtName, interpreter);; 2209}; 2210 ; 2211////////////////////////////////////////////////////////////////////////////////; 2212 ; 2213void GetMostExternalEnclosingClassNameFromDecl(const clang::Decl &theDecl,; 2214 std::string &ctxtName,; 2215 const cling::Interpreter &interpreter); 2216{; 2217 const clang::DeclContext *theContext = theDecl.getDeclContext();; 2218 GetMostExternalEnclosingClassName(*theContext, ctxtName, interpreter, false);; 2219}; 2220 ; 2221////////////////////////////////////////////////////////////////////////////////; 2222template<class COLL>; 2223int ExtractAutoloadKeys(std::list<std::string> &names,; 2224 const COLL &decls,; 2225 const cling::Interpreter &interp); 2226{; 2227 if (!decls.empty()) {; 2228 std::string autoLoadKey;; 2229 for (auto & d : decls) {; 2230 autoLoadKey = """";; 2231 GetMostExternalEnclosingClassNameFromDecl(*d, autoLoadKey, interp);; 2232 // If there is an outer class, it is already considered; 22",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:116269,Deployability,update,update,116269," tempFileNamesCatalog {; 2895public:; 2896 //______________________________________________; 2897 tempFileNamesCatalog(): m_size(0), m_emptyString("""") {};; 2898 ; 2899 std::string getTmpFileName(const std::string &filename) {; 2900 return filename + ""_tmp_"" + std::to_string(getpid());; 2901 }; 2902 /////////////////////////////////////////////////////////////////////////////; 2903 /// Adds the name and the associated temp name to the catalog.; 2904 /// Changes the name into the temp name; 2905 ; 2906 void addFileName(std::string &nameStr) {; 2907 if (nameStr.empty()) return;; 2908 ; 2909 std::string tmpNameStr(getTmpFileName(nameStr));; 2910 ; 2911 // For brevity; 2912 const char *name(nameStr.c_str());; 2913 const char *tmpName(tmpNameStr.c_str());; 2914 ; 2915 m_names.push_back(nameStr);; 2916 m_tempNames.push_back(tmpNameStr);; 2917 ROOT::TMetaUtils::Info(nullptr, ""File %s added to the tmp catalog.\n"", name);; 2918 ; 2919 // This is to allow update of existing files; 2920 if (0 == std::rename(name , tmpName)) {; 2921 ROOT::TMetaUtils::Info(nullptr, ""File %s existing. Preserved as %s.\n"", name, tmpName);; 2922 }; 2923 ; 2924 // To change the name to its tmp version; 2925 nameStr = tmpNameStr;; 2926 ; 2927 m_size++;; 2928 ; 2929 }; 2930 ; 2931 /////////////////////////////////////////////////////////////////////////////; 2932 ; 2933 int clean() {; 2934 int retval = 0;; 2935 // rename the temp files into the normal ones; 2936 for (unsigned int i = 0; i < m_size; ++i) {; 2937 const char *tmpName = m_tempNames[i].c_str();; 2938 // Check if the file exists; 2939 std::ifstream ifile(tmpName);; 2940 if (!ifile); 2941 ROOT::TMetaUtils::Error(nullptr, ""Cannot find %s!\n"", tmpName);; 2942 // Make sure the file is closed, mostly for Windows FS, also when; 2943 // accessing it from a Linux VM via a shared folder; 2944 if (ifile.is_open()); 2945 ifile.close();; 2946 if (0 != std::remove(tmpName)) {; 2947 ROOT::TMetaUtils::Error(nullptr, ""Removing %s!\n"", tmpName);; 2948 retval",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:118140,Deployability,release,released,118140," accessing it from a Linux VM via a shared folder; 2944 if (ifile.is_open()); 2945 ifile.close();; 2946 if (0 != std::remove(tmpName)) {; 2947 ROOT::TMetaUtils::Error(nullptr, ""Removing %s!\n"", tmpName);; 2948 retval++;; 2949 }; 2950 }; 2951 return retval;; 2952 }; 2953 ; 2954 /////////////////////////////////////////////////////////////////////////////; 2955 ; 2956 int commit() {; 2957 int retval = 0;; 2958 // rename the temp files into the normal ones; 2959 for (unsigned int i = 0; i < m_size; ++i) {; 2960 const char *tmpName = m_tempNames[i].c_str();; 2961 const char *name = m_names[i].c_str();; 2962 // Check if the file exists; 2963 std::ifstream ifile(tmpName);; 2964 if (!ifile); 2965 ROOT::TMetaUtils::Error(nullptr, ""Cannot find %s!\n"", tmpName);; 2966 // Make sure the file is closed, mostly for Windows FS, also when; 2967 // accessing it from a Linux VM via a shared folder; 2968 if (ifile.is_open()); 2969 ifile.close();; 2970#ifdef WIN32; 2971 // Sometimes files cannot be renamed on Windows if they don't have; 2972 // been released by the system. So just copy them and try to delete; 2973 // the old one afterwards.; 2974 if (0 != std::rename(tmpName , name)) {; 2975 if (llvm::sys::fs::copy_file(tmpName , name)) {; 2976 llvm::sys::fs::remove(tmpName);; 2977 }; 2978 }; 2979#else; 2980 if (0 != std::rename(tmpName , name)) {; 2981 ROOT::TMetaUtils::Error(nullptr, ""Renaming %s into %s!\n"", tmpName, name);; 2982 retval++;; 2983 }; 2984#endif; 2985 }; 2986 return retval;; 2987 }; 2988 ; 2989 /////////////////////////////////////////////////////////////////////////////; 2990 ; 2991 const std::string &getFileName(const std::string &tmpFileName) {; 2992 size_t i = std::distance(m_tempNames.begin(),; 2993 find(m_tempNames.begin(), m_tempNames.end(), tmpFileName));; 2994 if (i == m_tempNames.size()) return m_emptyString;; 2995 return m_names[i];; 2996 }; 2997 ; 2998 /////////////////////////////////////////////////////////////////////////////; 2999 ; 3000 void dump() {; 3",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:182620,Deployability,configurat,configuration,182620,"427 if (ROOT::TMetaUtils::GetErrorIgnoreLevel() == ROOT::TMetaUtils::kInfo) {; 4428 ROOT::TMetaUtils::Info(nullptr, ""\n"");; 4429 ROOT::TMetaUtils::Info(nullptr, ""==== INTERPRETER CONFIGURATION ====\n"");; 4430 ROOT::TMetaUtils::Info(nullptr, ""== Include paths\n"");; 4431 interp.DumpIncludePath();; 4432 printf(""\n\n"");; 4433 fflush(stdout);; 4434 ; 4435 ROOT::TMetaUtils::Info(nullptr, ""== Included files\n"");; 4436 interp.printIncludedFiles(llvm::outs());; 4437 llvm::outs() << ""\n\n"";; 4438 llvm::outs().flush();; 4439 ; 4440 ROOT::TMetaUtils::Info(nullptr, ""== Language Options\n"");; 4441 const clang::LangOptions& LangOpts; 4442 = interp.getCI()->getASTContext().getLangOpts();; 4443#define LANGOPT(Name, Bits, Default, Description) \; 4444 ROOT::TMetaUtils::Info(nullptr, ""%s = %d // %s\n"", #Name, (int)LangOpts.Name, Description);; 4445#define ENUM_LANGOPT(Name, Type, Bits, Default, Description); 4446#include ""clang/Basic/LangOptions.def""; 4447 ROOT::TMetaUtils::Info(nullptr, ""==== END interpreter configuration ====\n\n"");; 4448 }; 4449 ; 4450 interp.getOptions().ErrorOut = true;; 4451 interp.enableRawInput(true);; 4452 ; 4453 if (gOptCxxModule) {; 4454 for (llvm::StringRef DepMod : gOptModuleDependencies) {; 4455 if (DepMod.endswith(""_rdict.pcm"")) {; 4456 ROOT::TMetaUtils::Warning(nullptr, ""'%s' value is deprecated. Please use [<fullpath>]%s.pcm\n"",; 4457 DepMod.data(),; 4458 GetModuleNameFromRdictName(DepMod).str().data());; 4459 }; 4460 DepMod = GetModuleNameFromRdictName(DepMod);; 4461 // We might deserialize.; 4462 cling::Interpreter::PushTransactionRAII RAII(&interp);; 4463 if (!interp.loadModule(DepMod.str(), /*complain*/false)) {; 4464 ROOT::TMetaUtils::Error(nullptr, ""Module '%s' failed to load.\n"",; 4465 DepMod.data());; 4466 }; 4467 }; 4468 }; 4469 ; 4470 if (!isGenreflex) { // rootcling; 4471 // ROOTCINT uses to define a few header implicitly, we need to do it explicitly.; 4472 if (interp.declare(""#include <assert.h>\n""; 4473 ""#include \""Rtypes.h\""\n""; 4474 ""#in",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:244461,Deployability,configurat,configuration,244461,"n,; 6171 selectionFileName,; 6172 targetLibName,; 6173 multidict,; 6174 pcmsNames,; 6175 includes,; 6176 preprocDefines,; 6177 preprocUndefines,; 6178 warnings,; 6179 rootmapFileName,; 6180 rootmapLibName,; 6181 interpreteronly,; 6182 doSplit,; 6183 isCxxmodule,; 6184 writeEmptyRootPCM,; 6185 selSyntaxOnly,; 6186 noIncludePaths,; 6187 noGlobalUsingStd,; 6188 headersNames,; 6189 failOnWarnings,; 6190 printRootclingInvocation,; 6191 ofileName);; 6192 } else {; 6193 // Here ofilename is either """" or a directory: this is irrelevant.; 6194 returnValue = invokeManyRootCling(verbosityOption,; 6195 selectionFileName,; 6196 targetLibName,; 6197 multidict,; 6198 pcmsNames,; 6199 includes,; 6200 preprocDefines,; 6201 preprocUndefines,; 6202 warnings,; 6203 rootmapFileName,; 6204 rootmapLibName,; 6205 interpreteronly,; 6206 doSplit,; 6207 isCxxmodule,; 6208 writeEmptyRootPCM,; 6209 selSyntaxOnly,; 6210 noIncludePaths,; 6211 noGlobalUsingStd,; 6212 headersNames,; 6213 failOnWarnings,; 6214 printRootclingInvocation,; 6215 ofileName);; 6216 }; 6217 ; 6218 return returnValue;; 6219}; 6220 ; 6221 ; 6222////////////////////////////////////////////////////////////////////////////////; 6223 ; 6224extern ""C""; 6225int ROOT_rootcling_Driver(int argc, char **argv, const ROOT::Internal::RootCling::DriverConfig& config); 6226{; 6227 ; 6228 assert(!gDriverConfig && ""Driver configuration already set!"");; 6229 gDriverConfig = &config;; 6230 ; 6231 gBuildingROOT = config.fBuildingROOTStage1; // gets refined later; 6232 ; 6233 std::string exeName = ExtractFileName(GetExePath());; 6234#ifdef __APPLE__; 6235 // _dyld_get_image_name() on macOS11 and later sometimes returns ""rootcling"" for ""genreflex"".; 6236 // Fix that (while still initializing the binary path, needed for ROOTSYS) by updating the; 6237 // exeName to argv[0]:; 6238 exeName = ExtractFileName(argv[0]);; 6239#endif; 6240 ; 6241 // Select according to the name of the executable the procedure to follow:; 6242 // 1) RootCling; 6243 // 2) G",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:1435,Integrability,interface,interface,1435,"he licensing terms see $ROOTSYS/LICENSE. *; 8 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11#include ""rootcling_impl.h""; 12#include ""rootclingCommandLineOptionsHelp.h""; 13 ; 14#include ""RConfigure.h""; 15#include <ROOT/RConfig.hxx>; 16#include <ROOT/FoundationUtils.hxx>; 17#include ""snprintf.h""; 18 ; 19#include <iostream>; 20#include <iomanip>; 21#include <memory>; 22#include <vector>; 23#include <algorithm>; 24#include <cstdio>; 25 ; 26#include <errno.h>; 27#include <string>; 28#include <list>; 29#include <sstream>; 30#include <map>; 31#include <fstream>; 32#include <sys/stat.h>; 33#include <unordered_map>; 34#include <unordered_set>; 35#include <numeric>; 36 ; 37 ; 38#ifdef _WIN32; 39#ifdef system; 40#undef system; 41#endif; 42#undef UNICODE; 43#include <windows.h>; 44#include <Tlhelp32.h> // for MAX_MODULE_NAME32; 45#include <process.h>; 46#define PATH_MAX _MAX_PATH; 47#ifdef interface; 48// prevent error coming from clang/AST/Attrs.inc; 49#undef interface; 50#endif; 51#endif; 52 ; 53#ifdef __APPLE__; 54#include <mach-o/dyld.h>; 55#endif; 56 ; 57#ifdef R__FBSD; 58#include <sys/param.h>; 59#include <sys/user.h>; 60#include <sys/types.h>; 61#include <libutil.h>; 62#include <libprocstat.h>; 63#endif // R__FBSD; 64 ; 65#if !defined(R__WIN32); 66#include <limits.h>; 67#include <unistd.h>; 68#endif; 69 ; 70 ; 71#include ""cling/Interpreter/Interpreter.h""; 72#include ""cling/Interpreter/InterpreterCallbacks.h""; 73#include ""cling/Interpreter/LookupHelper.h""; 74#include ""cling/Interpreter/Value.h""; 75#include ""clang/AST/CXXInheritance.h""; 76#include ""clang/Basic/Diagnostic.h""; 77#include ""clang/Frontend/CompilerInstance.h""; 78#include ""clang/Frontend/FrontendActions.h""; 79#include ""clang/Frontend/FrontendDiagnostic.h""; 80#include ""clang/Lex/HeaderSearch.h""; 81#include ""clang/Lex/Preprocessor.h""; 82#include ""clang/Lex/ModuleMap.h""; 83#include ""clang/Lex/Pragma.h""; 84#include """,MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:1507,Integrability,interface,interface,1507,"REDITS. *; 9 *************************************************************************/; 10 ; 11#include ""rootcling_impl.h""; 12#include ""rootclingCommandLineOptionsHelp.h""; 13 ; 14#include ""RConfigure.h""; 15#include <ROOT/RConfig.hxx>; 16#include <ROOT/FoundationUtils.hxx>; 17#include ""snprintf.h""; 18 ; 19#include <iostream>; 20#include <iomanip>; 21#include <memory>; 22#include <vector>; 23#include <algorithm>; 24#include <cstdio>; 25 ; 26#include <errno.h>; 27#include <string>; 28#include <list>; 29#include <sstream>; 30#include <map>; 31#include <fstream>; 32#include <sys/stat.h>; 33#include <unordered_map>; 34#include <unordered_set>; 35#include <numeric>; 36 ; 37 ; 38#ifdef _WIN32; 39#ifdef system; 40#undef system; 41#endif; 42#undef UNICODE; 43#include <windows.h>; 44#include <Tlhelp32.h> // for MAX_MODULE_NAME32; 45#include <process.h>; 46#define PATH_MAX _MAX_PATH; 47#ifdef interface; 48// prevent error coming from clang/AST/Attrs.inc; 49#undef interface; 50#endif; 51#endif; 52 ; 53#ifdef __APPLE__; 54#include <mach-o/dyld.h>; 55#endif; 56 ; 57#ifdef R__FBSD; 58#include <sys/param.h>; 59#include <sys/user.h>; 60#include <sys/types.h>; 61#include <libutil.h>; 62#include <libprocstat.h>; 63#endif // R__FBSD; 64 ; 65#if !defined(R__WIN32); 66#include <limits.h>; 67#include <unistd.h>; 68#endif; 69 ; 70 ; 71#include ""cling/Interpreter/Interpreter.h""; 72#include ""cling/Interpreter/InterpreterCallbacks.h""; 73#include ""cling/Interpreter/LookupHelper.h""; 74#include ""cling/Interpreter/Value.h""; 75#include ""clang/AST/CXXInheritance.h""; 76#include ""clang/Basic/Diagnostic.h""; 77#include ""clang/Frontend/CompilerInstance.h""; 78#include ""clang/Frontend/FrontendActions.h""; 79#include ""clang/Frontend/FrontendDiagnostic.h""; 80#include ""clang/Lex/HeaderSearch.h""; 81#include ""clang/Lex/Preprocessor.h""; 82#include ""clang/Lex/ModuleMap.h""; 83#include ""clang/Lex/Pragma.h""; 84#include ""clang/Sema/Sema.h""; 85#include ""clang/Serialization/ASTWriter.h""; 86#include ""cling/Utils/AST.h"";",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:25971,Integrability,message,messages,25971,"aUtils::GetFuncWithProto(llvm::dyn_cast<clang::Decl>(cl->getDeclContext()), what, proto, interp,; 737 false /*diags*/);; 738 if (!method) {; 739 // This intended to find the global scope.; 740 clang::TranslationUnitDecl *TU =; 741 cl->getASTContext().getTranslationUnitDecl();; 742 method = ROOT::TMetaUtils::GetFuncWithProto(TU, what, proto, interp,; 743 false /*diags*/);; 744 }; 745 bool has_input_error = false;; 746 if (method != nullptr && (method->getAccess() == clang::AS_public || method->getAccess() == clang::AS_none)) {; 747 std::string filename = ROOT::TMetaUtils::GetFileName(*method, interp);; 748 if (strstr(filename.c_str(), ""TBuffer.h"") != nullptr ||; 749 strstr(filename.c_str(), ""Rtypes.h"") != nullptr) {; 750 ; 751 has_input_error = true;; 752 }; 753 } else {; 754 has_input_error = true;; 755 }; 756 if (has_input_error) {; 757 // We don't want to generate duplicated error messages in several dictionaries (when generating temporaries); 758 const char *maybeconst = """";; 759 const char *mayberef = ""&"";; 760 if (what[strlen(what) - 1] == '<') {; 761 maybeconst = ""const "";; 762 mayberef = """";; 763 }; 764 ROOT::TMetaUtils::Error(nullptr,; 765 ""in this version of ROOT, the option '!' used in a linkdef file\n""; 766 "" implies the actual existence of customized operators.\n""; 767 "" The following declaration is now required:\n""; 768 "" TBuffer &%s(TBuffer &,%s%s *%s);\n"", what, maybeconst, fullname.c_str(), mayberef);; 769 }; 770 return has_input_error;; 771 ; 772}; 773 ; 774////////////////////////////////////////////////////////////////////////////////; 775/// Check if the operator>> has been properly declared if the user has; 776/// requested a custom version.; 777 ; 778bool CheckInputOperator(const clang::RecordDecl *cl, cling::Interpreter &interp); 779{; 780 string fullname;; 781 ROOT::TMetaUtils::GetQualifiedName(fullname, *cl);; 782 int ncha = fullname.length() + 13;; 783 char *proto = new char[ncha];; 784 snprintf(proto, ncha, ""TBuffer&,%s*&"", fullname.c_str(",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:53669,Integrability,message,message,53669," llvm::dyn_cast<clang::CXXRecordDecl>(cl.GetRecordDecl());; 1396 if (clxx == nullptr) return;; 1397 ; 1398 bool add_template_keyword = ROOT::TMetaUtils::NeedTemplateKeyword(clxx);; 1399 ; 1400 string fullname;; 1401 string clsname;; 1402 string nsname;; 1403 int enclSpaceNesting = 0;; 1404 ; 1405 if (ROOT::TMetaUtils::GetNameWithinNamespace(fullname, clsname, nsname, clxx)) {; 1406 enclSpaceNesting = ROOT::TMetaUtils::WriteNamespaceHeader(dictStream, cl);; 1407 }; 1408 ; 1409 dictStream << ""//_______________________________________""; 1410 << ""_______________________________________"" << std::endl;; 1411 if (add_template_keyword) dictStream << ""template <> "";; 1412 dictStream << ""void "" << clsname << ""::Streamer(TBuffer &R__b)"" << std::endl << ""{"" << std::endl; 1413 << "" // Stream an object of class "" << fullname << ""."" << std::endl << std::endl;; 1414 ; 1415 // In case of VersionID<=0 write dummy streamer only calling; 1416 // its base class Streamer(s). If no base class(es) let Streamer; 1417 // print error message, i.e. this Streamer should never have been called.; 1418 int version = ROOT::TMetaUtils::GetClassVersion(clxx, interp);; 1419 if (version <= 0) {; 1420 // We also need to look at the base classes.; 1421 int basestreamer = 0;; 1422 for (clang::CXXRecordDecl::base_class_const_iterator iter = clxx->bases_begin(), end = clxx->bases_end();; 1423 iter != end;; 1424 ++iter) {; 1425 if (ROOT::TMetaUtils::ClassInfo__HasMethod(iter->getType()->getAsCXXRecordDecl(), ""Streamer"", interp)) {; 1426 string base_fullname;; 1427 ROOT::TMetaUtils::GetQualifiedName(base_fullname, * iter->getType()->getAsCXXRecordDecl());; 1428 ; 1429 if (strstr(base_fullname.c_str(), ""::"")) {; 1430 // there is a namespace involved, trigger MS VC bug workaround; 1431 dictStream << "" //This works around a msvc bug and should be harmless on other platforms"" << std::endl; 1432 << "" typedef "" << base_fullname << "" baseClass"" << basestreamer << "";"" << std::endl; 1433 << "" baseClass"" << basestreamer",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:77849,Integrability,inject,injected,77849,"932 return true;; 1933 }; 1934 }; 1935 pname = """";; 1936 return false;; 1937}; 1938 ; 1939////////////////////////////////////////////////////////////////////////////////; 1940/// If the argument starts with MODULE/inc, strip it; 1941/// to make it the name we can use in `#includes`.; 1942 ; 1943const char *CopyArg(const char *original); 1944{; 1945 if (!gBuildingROOT); 1946 return original;; 1947 ; 1948 if (IsSelectionFile(original)); 1949 return original;; 1950 ; 1951 const char *inc = strstr(original, ""\\inc\\"");; 1952 if (!inc); 1953 inc = strstr(original, ""/inc/"");; 1954 if (inc && strlen(inc) > 5); 1955 return inc + 5;; 1956 return original;; 1957}; 1958 ; 1959////////////////////////////////////////////////////////////////////////////////; 1960/// Copy the command line argument, stripping MODULE/inc if; 1961/// necessary.; 1962 ; 1963void StrcpyArg(string &dest, const char *original); 1964{; 1965 dest = CopyArg(original);; 1966}; 1967 ; 1968////////////////////////////////////////////////////////////////////////////////; 1969/// Write the extra header injected into the module:; 1970/// umbrella header if (umbrella) else content header.; 1971 ; 1972static bool InjectModuleUtilHeader(const char *argv0,; 1973 TModuleGenerator &modGen,; 1974 cling::Interpreter &interp,; 1975 bool umbrella); 1976{; 1977 std::ostringstream out;; 1978 if (umbrella) {; 1979 // This will duplicate the -D,-U from clingArgs - but as they are surrounded; 1980 // by #ifndef there is no problem here.; 1981 modGen.WriteUmbrellaHeader(out);; 1982 if (interp.declare(out.str()) != cling::Interpreter::kSuccess) {; 1983 const std::string &hdrName; 1984 = umbrella ? modGen.GetUmbrellaName() : modGen.GetContentName();; 1985 ROOT::TMetaUtils::Error(nullptr, ""%s: compilation failure (%s)\n"", argv0,; 1986 hdrName.c_str());; 1987 return false;; 1988 }; 1989 } else {; 1990 modGen.WriteContentHeader(out);; 1991 }; 1992 return true;; 1993}; 1994 ; 1995/////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:86906,Integrability,rout,routine,86906,"bName); 2177{; 2178 // If the rootmap file name does not exist, create one following the libname; 2179 // I.E. put into the directory of the lib the rootmap and within the rootmap the normalised path to the lib; 2180 if (rootmapFileName.empty()) {; 2181 size_t libExtensionPos = rootmapLibName.find_last_of(gLibraryExtension) - gLibraryExtension.size() + 1;; 2182 rootmapFileName = rootmapLibName.substr(0, libExtensionPos) + "".rootmap"";; 2183 size_t libCleanNamePos = rootmapLibName.find_last_of(gPathSeparator) + 1;; 2184 rootmapLibName = rootmapLibName.substr(libCleanNamePos, std::string::npos);; 2185 ROOT::TMetaUtils::Info(nullptr, ""Rootmap file name %s built from rootmap lib name %s"",; 2186 rootmapLibName.c_str(),; 2187 rootmapFileName.c_str());; 2188 }; 2189}; 2190 ; 2191////////////////////////////////////////////////////////////////////////////////; 2192/// Extract the proper autoload key for nested classes; 2193/// The routine does not erase the name, just updates it; 2194 ; 2195void GetMostExternalEnclosingClassName(const clang::DeclContext &theContext,; 2196 std::string &ctxtName,; 2197 const cling::Interpreter &interpreter,; 2198 bool treatParent = true); 2199{; 2200 const clang::DeclContext *outerCtxt = treatParent ? theContext.getParent() : &theContext;; 2201 // If the context has no outer context, we are finished; 2202 if (!outerCtxt) return;; 2203 // If the context is a class, we update the name; 2204 if (const clang::RecordDecl *thisRcdDecl = llvm::dyn_cast<clang::RecordDecl>(outerCtxt)) {; 2205 ROOT::TMetaUtils::GetNormalizedName(ctxtName, thisRcdDecl, interpreter);; 2206 }; 2207 // We recurse; 2208 GetMostExternalEnclosingClassName(*outerCtxt, ctxtName, interpreter);; 2209}; 2210 ; 2211////////////////////////////////////////////////////////////////////////////////; 2212 ; 2213void GetMostExternalEnclosingClassNameFromDecl(const clang::Decl &theDecl,; 2214 std::string &ctxtName,; 2215 const cling::Interpreter &interpreter); 2216{; 2217 const clang::Decl",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:145510,Integrability,depend,dependency,145510,"is; 3618 // an error because rootcling is not able to generate the corresponding; 3619 // dictionary.; 3620 // If we build a I/O requiring module implicitly we should display; 3621 // an error unless -mSystemByproducts or -mByproduct were specified.; 3622 bool isByproductModule = false;; 3623 if (module) {; 3624 // -mSystemByproducts allows implicit building of any system module.; 3625 if (module->IsSystem && gOptSystemModuleByproducts) {; 3626 isByproductModule = true;; 3627 }; 3628 // -mByproduct lists concrete module names that are allowed.; 3629 if (std::find(gOptModuleByproducts.begin(), gOptModuleByproducts.end(), moduleName) !=; 3630 gOptModuleByproducts.end()) {; 3631 isByproductModule = true;; 3632 }; 3633 }; 3634 if (!isByproductModule); 3635 fChild->HandleDiagnostic(DiagLevel, Info);; 3636 ; 3637 if (ID == remark_module_build && !isByproductModule) {; 3638 ROOT::TMetaUtils::Error(nullptr,; 3639 ""Building module '%s' implicitly. If '%s' requires a \n""; 3640 ""dictionary please specify build dependency: '%s' depends on '%s'.\n""; 3641 ""Otherwise, specify '-mByproduct %s' to disable this diagnostic.\n"",; 3642 moduleName.c_str(), moduleName.c_str(), gOptDictionaryFileName.c_str(),; 3643 moduleName.c_str(), moduleName.c_str());; 3644 }; 3645 }; 3646 ; 3647 // All methods below just forward to the child and the default method.; 3648 virtual void clear() override; 3649 {; 3650 fChild->clear();; 3651 DiagnosticConsumer::clear();; 3652 }; 3653 ; 3654 virtual void BeginSourceFile(const clang::LangOptions &LangOpts, const clang::Preprocessor *PP) override; 3655 {; 3656 fChild->BeginSourceFile(LangOpts, PP);; 3657 DiagnosticConsumer::BeginSourceFile(LangOpts, PP);; 3658 }; 3659 ; 3660 virtual void EndSourceFile() override; 3661 {; 3662 fChild->EndSourceFile();; 3663 DiagnosticConsumer::EndSourceFile();; 3664 }; 3665 ; 3666 virtual void finish() override; 3667 {; 3668 fChild->finish();; 3669 DiagnosticConsumer::finish();; 3670 }; 3671 ; 3672 virtual bool IncludeInDiagno",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:145527,Integrability,depend,depends,145527,"is; 3618 // an error because rootcling is not able to generate the corresponding; 3619 // dictionary.; 3620 // If we build a I/O requiring module implicitly we should display; 3621 // an error unless -mSystemByproducts or -mByproduct were specified.; 3622 bool isByproductModule = false;; 3623 if (module) {; 3624 // -mSystemByproducts allows implicit building of any system module.; 3625 if (module->IsSystem && gOptSystemModuleByproducts) {; 3626 isByproductModule = true;; 3627 }; 3628 // -mByproduct lists concrete module names that are allowed.; 3629 if (std::find(gOptModuleByproducts.begin(), gOptModuleByproducts.end(), moduleName) !=; 3630 gOptModuleByproducts.end()) {; 3631 isByproductModule = true;; 3632 }; 3633 }; 3634 if (!isByproductModule); 3635 fChild->HandleDiagnostic(DiagLevel, Info);; 3636 ; 3637 if (ID == remark_module_build && !isByproductModule) {; 3638 ROOT::TMetaUtils::Error(nullptr,; 3639 ""Building module '%s' implicitly. If '%s' requires a \n""; 3640 ""dictionary please specify build dependency: '%s' depends on '%s'.\n""; 3641 ""Otherwise, specify '-mByproduct %s' to disable this diagnostic.\n"",; 3642 moduleName.c_str(), moduleName.c_str(), gOptDictionaryFileName.c_str(),; 3643 moduleName.c_str(), moduleName.c_str());; 3644 }; 3645 }; 3646 ; 3647 // All methods below just forward to the child and the default method.; 3648 virtual void clear() override; 3649 {; 3650 fChild->clear();; 3651 DiagnosticConsumer::clear();; 3652 }; 3653 ; 3654 virtual void BeginSourceFile(const clang::LangOptions &LangOpts, const clang::Preprocessor *PP) override; 3655 {; 3656 fChild->BeginSourceFile(LangOpts, PP);; 3657 DiagnosticConsumer::BeginSourceFile(LangOpts, PP);; 3658 }; 3659 ; 3660 virtual void EndSourceFile() override; 3661 {; 3662 fChild->EndSourceFile();; 3663 DiagnosticConsumer::EndSourceFile();; 3664 }; 3665 ; 3666 virtual void finish() override; 3667 {; 3668 fChild->finish();; 3669 DiagnosticConsumer::finish();; 3670 }; 3671 ; 3672 virtual bool IncludeInDiagno",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:149103,Integrability,depend,dependent,149103,"VerboseLevel>; 3707gOptVerboseLevel(llvm::cl::desc(""Choose verbosity level:""),; 3708 llvm::cl::values(clEnumVal(v, ""Show errors.""),; 3709 clEnumVal(v0, ""Show only fatal errors.""),; 3710 clEnumVal(v1, ""Show errors (the same as -v).""),; 3711 clEnumVal(v2, ""Show warnings (default).""),; 3712 clEnumVal(v3, ""Show notes.""),; 3713 clEnumVal(v4, ""Show information."")),; 3714 llvm::cl::init(v2),; 3715 llvm::cl::cat(gRootclingOptions));; 3716 ; 3717static llvm::cl::opt<bool>; 3718gOptCint(""cint"", llvm::cl::desc(""Deprecated, legacy flag which is ignored.""),; 3719 llvm::cl::Hidden,; 3720 llvm::cl::cat(gRootclingOptions));; 3721static llvm::cl::opt<bool>; 3722gOptReflex(""reflex"", llvm::cl::desc(""Behave internally like genreflex.""),; 3723 llvm::cl::cat(gRootclingOptions));; 3724static llvm::cl::opt<bool>; 3725gOptGccXml(""gccxml"", llvm::cl::desc(""Deprecated, legacy flag which is ignored.""),; 3726 llvm::cl::Hidden,; 3727 llvm::cl::cat(gRootclingOptions));; 3728static llvm::cl::opt<std::string>; 3729gOptLibListPrefix(""lib-list-prefix"",; 3730 llvm::cl::desc(""An ACLiC feature which exports the list of dependent libraries.""),; 3731 llvm::cl::Hidden,; 3732 llvm::cl::cat(gRootclingOptions));; 3733static llvm::cl::opt<bool>; 3734gOptGeneratePCH(""generate-pch"",; 3735 llvm::cl::desc(""Generates a pch file from a predefined set of headers. See makepch.py.""),; 3736 llvm::cl::Hidden,; 3737 llvm::cl::cat(gRootclingOptions));; 3738static llvm::cl::opt<bool>; 3739gOptC(""c"", llvm::cl::desc(""Deprecated, legacy flag which is ignored.""),; 3740 llvm::cl::cat(gRootclingOptions));; 3741static llvm::cl::opt<bool>; 3742gOptP(""p"", llvm::cl::desc(""Deprecated, legacy flag which is ignored.""),; 3743 llvm::cl::cat(gRootclingOptions));; 3744static llvm::cl::list<std::string>; 3745gOptRootmapLibNames(""rml"", llvm::cl::ZeroOrMore,; 3746 llvm::cl::desc(""Generate rootmap file.""),; 3747 llvm::cl::cat(gRootclingOptions));; 3748static llvm::cl::opt<std::string>; 3749gOptRootMapFileName(""rmf"",; 3750 llvm::cl::desc(""Generate",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:152112,Integrability,depend,dependent,152112,"d} in dictionary global scope.""),; 3772 llvm::cl::cat(gRootclingOptions));; 3773static llvm::cl::opt<bool>; 3774gOptInterpreterOnly(""interpreteronly"",; 3775 llvm::cl::desc(""Generate minimal dictionary for interactivity (without IO information).""),; 3776 llvm::cl::cat(gRootclingOptions));; 3777static llvm::cl::opt<bool>; 3778gOptSplit(""split"",; 3779 llvm::cl::desc(""Split the dictionary into two parts: one containing the IO (ClassDef)\; 3780information and another the interactivity support.""),; 3781 llvm::cl::cat(gRootclingOptions));; 3782static llvm::cl::opt<bool>; 3783gOptNoDictSelection(""noDictSelection"",; 3784 llvm::cl::Hidden,; 3785 llvm::cl::desc(""Do not run the selection rules. Useful when in -onepcm mode.""),; 3786 llvm::cl::cat(gRootclingOptions));; 3787static llvm::cl::opt<std::string>; 3788gOptSharedLibFileName(""s"",; 3789 llvm::cl::desc(""The path to the library of the built dictionary.""),; 3790 llvm::cl::cat(gRootclingOptions));; 3791static llvm::cl::list<std::string>; 3792gOptModuleDependencies(""m"",; 3793 llvm::cl::desc(""The list of dependent modules of the dictionary.""),; 3794 llvm::cl::cat(gRootclingOptions));; 3795static llvm::cl::list<std::string>; 3796gOptExcludePaths(""excludePath"", llvm::cl::ZeroOrMore,; 3797 llvm::cl::desc(""Do not store the <path> in the dictionary.""),; 3798 llvm::cl::cat(gRootclingOptions));; 3799// FIXME: This does not seem to work. We have one use of -inlineInputHeader in; 3800// ROOT and it does not produce the expected result.; 3801static llvm::cl::opt<bool>; 3802gOptInlineInput(""inlineInputHeader"",; 3803 llvm::cl::desc(""Does not generate #include <header> but expands the header content.""),; 3804 llvm::cl::cat(gRootclingOptions));; 3805// FIXME: This is totally the wrong concept. We should not expose an interface; 3806// to be able to tell which component is in the pch and which needs extra; 3807// scaffolding for interactive use. Moreover, some of the ROOT components are; 3808// partially in the pch and this option makes it imp",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:152825,Integrability,interface,interface,152825,"ileName(""s"",; 3789 llvm::cl::desc(""The path to the library of the built dictionary.""),; 3790 llvm::cl::cat(gRootclingOptions));; 3791static llvm::cl::list<std::string>; 3792gOptModuleDependencies(""m"",; 3793 llvm::cl::desc(""The list of dependent modules of the dictionary.""),; 3794 llvm::cl::cat(gRootclingOptions));; 3795static llvm::cl::list<std::string>; 3796gOptExcludePaths(""excludePath"", llvm::cl::ZeroOrMore,; 3797 llvm::cl::desc(""Do not store the <path> in the dictionary.""),; 3798 llvm::cl::cat(gRootclingOptions));; 3799// FIXME: This does not seem to work. We have one use of -inlineInputHeader in; 3800// ROOT and it does not produce the expected result.; 3801static llvm::cl::opt<bool>; 3802gOptInlineInput(""inlineInputHeader"",; 3803 llvm::cl::desc(""Does not generate #include <header> but expands the header content.""),; 3804 llvm::cl::cat(gRootclingOptions));; 3805// FIXME: This is totally the wrong concept. We should not expose an interface; 3806// to be able to tell which component is in the pch and which needs extra; 3807// scaffolding for interactive use. Moreover, some of the ROOT components are; 3808// partially in the pch and this option makes it impossible to express that.; 3809// We should be able to get the list of headers in the pch early and scan; 3810// through them.; 3811static llvm::cl::opt<bool>; 3812gOptWriteEmptyRootPCM(""writeEmptyRootPCM"",; 3813 llvm::cl::Hidden,; 3814 llvm::cl::desc(""Does not include the header files as it assumes they exist in the pch.""),; 3815 llvm::cl::cat(gRootclingOptions));; 3816static llvm::cl::opt<bool>; 3817gOptCheckSelectionSyntax(""selSyntaxOnly"",; 3818 llvm::cl::desc(""Check the selection syntax only.""),; 3819 llvm::cl::cat(gRootclingOptions));; 3820static llvm::cl::opt<bool>; 3821gOptFailOnWarnings(""failOnWarnings"",; 3822 llvm::cl::desc(""Fail if there are warnings.""),; 3823 llvm::cl::cat(gRootclingOptions));; 3824static llvm::cl::opt<bool>; 3825gOptNoIncludePaths(""noIncludePaths"",; 3826 llvm::cl::desc(""Do not store i",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:161426,Integrability,message,message,161426,"// ensure that our used module map is not containing extraneous headers.; 3966 std::vector<std::array<std::string, 2>> missingHdrMod;; 3967 if (!ModuleContainsHeaders(modGen, headerSearch, module, missingHdrMod)) {; 3968 // FIXME: Upgrade this to an error once modules are stable.; 3969 std::stringstream msgStream;; 3970 msgStream << ""after creating module \"""" << module->Name << ""\"" "";; 3971 if (!module->PresumedModuleMapFile.empty()); 3972 msgStream << ""using modulemap \"""" << module->PresumedModuleMapFile << ""\"" "";; 3973 msgStream << ""the following headers are not part of that module:\n"";; 3974 for (auto &H : missingHdrMod) {; 3975 msgStream << "" "" << H[0];; 3976 if (!H[1].empty()); 3977 msgStream << "" (already part of module \"""" << H[1] << ""\"")"";; 3978 msgStream << ""\n"";; 3979 }; 3980 std::string warningMessage = msgStream.str();; 3981 ; 3982 bool maybeUmbrella = modGen.GetHeaders().size() == 1;; 3983 // We may have an umbrella and forgot to add the flag. Downgrade the; 3984 // warning into an information message.; 3985 // FIXME: We should open the umbrella, extract the set of header files; 3986 // and check if they exist in the modulemap.; 3987 // FIXME: We should also check if the header files are specified in the; 3988 // modulemap file as they appeared in the rootcling invocation, i.e.; 3989 // if we passed rootcling ... -I/some/path somedir/some/header, the; 3990 // modulemap should contain module M { header ""somedir/some/header"" }; 3991 // This way we will make sure the module is properly activated.; 3992 if (!gOptUmbrellaInput && maybeUmbrella) {; 3993 ROOT::TMetaUtils::Info(""CheckModuleValid, %s. You can silence this message by adding %s to the invocation."",; 3994 warningMessage.c_str(),; 3995 gOptUmbrellaInput.ArgStr.data());; 3996 return true;; 3997 }; 3998 ; 3999 ROOT::TMetaUtils::Warning(""CheckModuleValid"", warningMessage.c_str());; 4000 // We include the missing headers to fix the module for the user.; 4001 std::vector<std::string> missingHeaders;; 400",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:162058,Integrability,message,message,162058,"0];; 3976 if (!H[1].empty()); 3977 msgStream << "" (already part of module \"""" << H[1] << ""\"")"";; 3978 msgStream << ""\n"";; 3979 }; 3980 std::string warningMessage = msgStream.str();; 3981 ; 3982 bool maybeUmbrella = modGen.GetHeaders().size() == 1;; 3983 // We may have an umbrella and forgot to add the flag. Downgrade the; 3984 // warning into an information message.; 3985 // FIXME: We should open the umbrella, extract the set of header files; 3986 // and check if they exist in the modulemap.; 3987 // FIXME: We should also check if the header files are specified in the; 3988 // modulemap file as they appeared in the rootcling invocation, i.e.; 3989 // if we passed rootcling ... -I/some/path somedir/some/header, the; 3990 // modulemap should contain module M { header ""somedir/some/header"" }; 3991 // This way we will make sure the module is properly activated.; 3992 if (!gOptUmbrellaInput && maybeUmbrella) {; 3993 ROOT::TMetaUtils::Info(""CheckModuleValid, %s. You can silence this message by adding %s to the invocation."",; 3994 warningMessage.c_str(),; 3995 gOptUmbrellaInput.ArgStr.data());; 3996 return true;; 3997 }; 3998 ; 3999 ROOT::TMetaUtils::Warning(""CheckModuleValid"", warningMessage.c_str());; 4000 // We include the missing headers to fix the module for the user.; 4001 std::vector<std::string> missingHeaders;; 4002 std::transform(missingHdrMod.begin(), missingHdrMod.end(), missingHeaders.begin(),; 4003 [](const std::array<std::string, 2>& HdrMod) { return HdrMod[0];});; 4004 if (!IncludeHeaders(missingHeaders, interpreter)) {; 4005 ROOT::TMetaUtils::Error(""CheckModuleValid"", ""Couldn't include missing module headers for module '%s'!\n"",; 4006 module->Name.c_str());; 4007 }; 4008 }; 4009 ; 4010 return true;; 4011}; 4012 ; 4013static llvm::StringRef GetModuleNameFromRdictName(llvm::StringRef rdictName); 4014{; 4015 // Try to get the module name in the modulemap based on the filepath.; 4016 llvm::StringRef moduleName = llvm::sys::path::filename(rdictName);; 4017 modul",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:176112,Integrability,depend,dependencies,176112,"pecify the module name that we can lookup the module in the modulemap.; 4311 outputFile = llvm::sys::path::stem(gOptSharedLibFileName).str();; 4312 // Try to get the module name in the modulemap based on the filepath.; 4313 moduleName = GetModuleNameFromRdictName(outputFile);; 4314 ; 4315#ifdef _MSC_VER; 4316 clingArgsInterpreter.push_back(""-Xclang"");; 4317 clingArgsInterpreter.push_back(""-fmodule-feature"");; 4318 clingArgsInterpreter.push_back(""-Xclang"");; 4319 clingArgsInterpreter.push_back(""msvc"" + std::string(rootclingStringify(_MSC_VER)));; 4320#endif; 4321 clingArgsInterpreter.push_back(""-fmodule-name="" + moduleName.str());; 4322 ; 4323 std::string moduleCachePath = llvm::sys::path::parent_path(gOptSharedLibFileName).str();; 4324 // FIXME: This is a horrible workaround to fix the incremental builds.; 4325 // The enumerated modules are built by clang impicitly based on #include of; 4326 // a header which is contained within that module. The build system has; 4327 // no way to track dependencies on them and trigger a rebuild.; 4328 // A possible solution can be to disable completely the implicit build of; 4329 // modules and each module to be built by rootcling. We need to teach; 4330 // rootcling how to build modules with no IO support.; 4331 if (moduleName == ""Core"") {; 4332 assert(gDriverConfig->fBuildingROOTStage1);; 4333 remove((moduleCachePath + llvm::sys::path::get_separator() + ""_Builtin_intrinsics.pcm"").str().c_str());; 4334 remove((moduleCachePath + llvm::sys::path::get_separator() + ""_Builtin_stddef_max_align_t.pcm"").str().c_str());; 4335 remove((moduleCachePath + llvm::sys::path::get_separator() + ""Cling_Runtime.pcm"").str().c_str());; 4336 remove((moduleCachePath + llvm::sys::path::get_separator() + ""Cling_Runtime_Extra.pcm"").str().c_str());; 4337#ifdef R__WIN32; 4338 remove((moduleCachePath + llvm::sys::path::get_separator() + ""vcruntime.pcm"").str().c_str());; 4339 remove((moduleCachePath + llvm::sys::path::get_separator() + ""services.pcm"").str().c_",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:204462,Integrability,depend,depending,204462," & arg : pcmArgs) {; 4994 if (gOptInlineInput && !ROOT::TMetaUtils::IsLinkdefFile(arg.c_str()) && ROOT::TMetaUtils::IsHeaderName(arg)) {; 4995 detectedUmbrella = arg;; 4996 break;; 4997 }; 4998 }; 4999 ; 5000 if (gOptWriteEmptyRootPCM){; 5001 headersDeclsMap.clear();; 5002 }; 5003 ; 5004 ; 5005 std::string headersClassesMapString = ""\""\"""";; 5006 std::string fwdDeclsString = ""\""\"""";; 5007 if (!gOptCxxModule) {; 5008 headersClassesMapString = GenerateStringFromHeadersForClasses(headersDeclsMap,; 5009 detectedUmbrella,; 5010 true);; 5011 if (!gDriverConfig->fBuildingROOTStage1) {; 5012 if (!gOptWriteEmptyRootPCM); 5013 fwdDeclsString = GenerateFwdDeclString(scan, interp);; 5014 }; 5015 }; 5016 modGen.WriteRegistrationSource(dictStream, fwdDeclnArgsToKeepString, headersClassesMapString, fwdDeclsString,; 5017 extraIncludes, gOptCxxModule);; 5018 // If we just want to inline the input header, we don't need; 5019 // to generate any files.; 5020 if (!gOptInlineInput) {; 5021 // Write the module/PCH depending on what mode we are on; 5022 if (modGen.IsPCH()) {; 5023 if (!GenerateAllDict(modGen, CI, currentDirectory)) return 1;; 5024 } else if (gOptCxxModule) {; 5025 if (!CheckModuleValid(modGen, llvmResourceDir, interp, linkdefFilename, moduleName.str())); 5026 return 1;; 5027 }; 5028 }; 5029 }; 5030 ; 5031 ; 5032 if (!gOptLibListPrefix.empty()) {; 5033 string liblist_filename = gOptLibListPrefix + "".out"";; 5034 ; 5035 ofstream outputfile(liblist_filename.c_str(), ios::out);; 5036 if (!outputfile) {; 5037 ROOT::TMetaUtils::Error(nullptr, ""%s: Unable to open output lib file %s\n"",; 5038 executableFileName, liblist_filename.c_str());; 5039 } else {; 5040 const size_t endStr = gLibsNeeded.find_last_not_of("" \t"");; 5041 outputfile << gLibsNeeded.substr(0, endStr + 1) << endl;; 5042 // Add explicit delimiter; 5043 outputfile << ""# Now the list of classes\n"";; 5044 // SELECTION LOOP; 5045 for (auto const & annRcd : scan.fSelectedClasses) {; 5046 // Shouldn't it be GetLong64_Name( cl",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:246494,Integrability,message,messages,246494,"""Problems have been detected during the generation of the dictionary.\n"");; 6257 return 1;; 6258 }; 6259 return retVal;; 6260}; DictSelectionReader.hSelect classes and assign properties using C++ syntax.; FoundationUtils.hxxThe file contains utilities which are foundational and could be used across the core component of ROO...; LinkdefReader.h; OptionParser.hThis is the only file required to use The Lean Mean C++ Option Parser.; DEBUG#define DEBUGDefinition Polynomial.cxx:40; RConfig.hxx; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; RStl.h; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; RtypesCore.h; Scanner.h; SelectionRules.h; TClassEdit.h; X#define X(type, name); TClingUtils.h; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; kWarningconstexpr Int_t kWarningDefinition TError.h:46; kInfoconstexpr Int_t kInfoDefinition TError.h:45; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; destOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t destDefinition TGWin32VirtualXProxy.cxx:164; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetP",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:273271,Integrability,wrap,wrapping,273271,"& GetPathSeparator()Return the separator suitable for this platform.Definition TClingUtils.cxx:5117; ROOT::TMetaUtils::kNoteconst int kNoteDefinition TClingUtils.h:127; ROOT::TMetaUtils::ScopeSearchconst clang::CXXRecordDecl * ScopeSearch(const char *name, const cling::Interpreter &gInterp, bool diagnose, const clang::Type **resultType)Return the scope corresponding to 'name' or std::'name'.Definition TClingUtils.cxx:776; ROOT::TMetaUtils::GetErrorIgnoreLevelint & GetErrorIgnoreLevel()Definition TClingUtils.h:795; ROOT::TMetaUtils::DataMemberInfo__ValidArrayIndexllvm::StringRef DataMemberInfo__ValidArrayIndex(const cling::Interpreter &interp, const clang::DeclaratorDecl &m, int *errnum=nullptr, llvm::StringRef *errstr=nullptr)ValidArrayIndex return a static string (so use it or copy it immediatly, do not call GrabIndex twice ...Definition TClingUtils.cxx:3118; ROOT::option::printUsagevoid printUsage(OStream &prn, const Descriptor usage[], int width=80, int last_column_min_percent=50, int last_column_own_line_max_percent=75)Outputs a nicely formatted usage string with support for multi-column formatting and line-wrapping.Definition OptionParser.h:2798; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::ESTLTypeESTLTypeDefinition ESTLType.h:28; ROOT::kSTLmap@ kSTLmapDefinition ESTLType.h:33; ROOT::kSTLunorderedmultiset@ kSTLunorderedmultisetDefinition ESTLType.h:43; ROOT::kSTLset@ kSTLsetDefinition ESTLType.h:35; ROOT::kSTLmultiset@ kSTLmultisetDefinition ESTLType.h:36; ROOT::kSTLdeque@ kSTLdequeDefinition ESTLType.h:32; ROOT::kSTLvector@ kSTLvectorDefinition ESTLType.h:30; ROOT::kSTLunorderedmultimap@ kSTLunorderedmultimapDefinition ESTLType.h:45; ROOT::kSTLunorderedset@ kSTLunorderedsetDefinition ESTLType.h:42; ROOT::kSTLlist@ kSTLlistDefinition ESTLType.h:31; ROOT::kSTLforwardlist@ kSTLforwardlistDefinition ESTLType.h:41; ROOT::kSTLunorderedmap@ kSTLunorderedmapDefiniti",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:285418,Integrability,inject,injected,285418,"(const clang::FieldDecl &m, int rwmode, std::ostream &dictStream)Create Streamer code for a standard string object.Definition rootcling_impl.cxx:1089; CreateDictHeadervoid CreateDictHeader(std::ostream &dictStream, const std::string &main_dictname)Definition rootcling_impl.cxx:2812; GetExePathconst char * GetExePath()Returns the executable path name, used e.g. by SetRootSys().Definition rootcling_impl.cxx:196; gPathSeparatorconst std::string gPathSeparator(ROOT::TMetaUtils::GetPathSeparator()); gOptBareClingSinkstatic llvm::cl::list< std::string > gOptBareClingSink(llvm::cl::OneOrMore, llvm::cl::Sink, llvm::cl::desc(""Consumes options and sends them to cling.""), llvm::cl::cat(gRootclingOptions), llvm::cl::sub(gBareClingSubcommand)); InheritsFromTObjectbool InheritsFromTObject(const clang::RecordDecl *cl, const cling::Interpreter &interp)Definition rootcling_impl.cxx:431; InjectModuleUtilHeaderstatic bool InjectModuleUtilHeader(const char *argv0, TModuleGenerator &modGen, cling::Interpreter &interp, bool umbrella)Write the extra header injected into the module: umbrella header if (umbrella) else content header.Definition rootcling_impl.cxx:1972; gOptModuleMapFilesstatic llvm::cl::list< std::string > gOptModuleMapFiles(""moduleMapFile"", llvm::cl::desc(""Specify a C++ modulemap file.""), llvm::cl::cat(gRootclingOptions)); ExtractClassesListAndDeclLinesint ExtractClassesListAndDeclLines(RScanner &scan, std::list< std::string > &classesList, std::list< std::string > &classesListForRootmap, std::list< std::string > &fwdDeclarationsList, const cling::Interpreter &interpreter)Definition rootcling_impl.cxx:2435; ParseRootMapFileNewFormatvoid ParseRootMapFileNewFormat(ifstream &file, map< string, string > &autoloads)Parse the rootmap and add entries to the autoload map, using the new format.Definition rootcling_impl.cxx:658; gRootclingOptionsstatic llvm::cl::OptionCategory gRootclingOptions(""rootcling common options""); gOptSysIncludePathsstatic llvm::cl::list< std::string > gOptS",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:290323,Integrability,depend,dependent,290323,"efinition rootcling_impl.cxx:2583; GetFullArrayLengthsize_t GetFullArrayLength(const clang::ConstantArrayType *arrayType)Definition rootcling_impl.cxx:417; gOptSplitstatic llvm::cl::opt< bool > gOptSplit(""split"", llvm::cl::desc(""Split the dictionary into two parts: one containing the IO (ClassDef)\; information and another the interactivity support.""), llvm::cl::cat(gRootclingOptions)); ProcessAndAppendIfNotTherebool ProcessAndAppendIfNotThere(const std::string &el, std::list< std::string > &el_list, std::unordered_set< std::string > &el_set)Separate multiline strings.Definition rootcling_impl.cxx:2415; gOptNoGlobalUsingStdstatic llvm::cl::opt< bool > gOptNoGlobalUsingStd(""noGlobalUsingStd"", llvm::cl::desc(""Do not declare {using namespace std} in dictionary global scope.""), llvm::cl::cat(gRootclingOptions)); gDriverConfigconst ROOT::Internal::RootCling::DriverConfig * gDriverConfigDefinition rootcling_impl.cxx:129; gOptModuleDependenciesstatic llvm::cl::list< std::string > gOptModuleDependencies(""m"", llvm::cl::desc(""The list of dependent modules of the dictionary.""), llvm::cl::cat(gRootclingOptions)); gBareClingSubcommandstatic llvm::cl::SubCommand gBareClingSubcommand(""bare-cling"", ""Call directly cling and exit.""); gOptInterpreterOnlystatic llvm::cl::opt< bool > gOptInterpreterOnly(""interpreteronly"", llvm::cl::desc(""Generate minimal dictionary for interactivity (without IO information).""), llvm::cl::cat(gRootclingOptions)); WriteArrayDimensionsvoid WriteArrayDimensions(const clang::QualType &type, std::ostream &dictStream)Write ""[0]"" for all but the 1st dimension.Definition rootcling_impl.cxx:1165; gOptReflexstatic llvm::cl::opt< bool > gOptReflex(""reflex"", llvm::cl::desc(""Behave internally like genreflex.""), llvm::cl::cat(gRootclingOptions)); GetMostExternalEnclosingClassNamevoid GetMostExternalEnclosingClassName(const clang::DeclContext &theContext, std::string &ctxtName, const cling::Interpreter &interpreter, bool treatParent=true)Extract the proper autoload key",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:291303,Integrability,rout,routine,291303,"finition rootcling_impl.cxx:129; gOptModuleDependenciesstatic llvm::cl::list< std::string > gOptModuleDependencies(""m"", llvm::cl::desc(""The list of dependent modules of the dictionary.""), llvm::cl::cat(gRootclingOptions)); gBareClingSubcommandstatic llvm::cl::SubCommand gBareClingSubcommand(""bare-cling"", ""Call directly cling and exit.""); gOptInterpreterOnlystatic llvm::cl::opt< bool > gOptInterpreterOnly(""interpreteronly"", llvm::cl::desc(""Generate minimal dictionary for interactivity (without IO information).""), llvm::cl::cat(gRootclingOptions)); WriteArrayDimensionsvoid WriteArrayDimensions(const clang::QualType &type, std::ostream &dictStream)Write ""[0]"" for all but the 1st dimension.Definition rootcling_impl.cxx:1165; gOptReflexstatic llvm::cl::opt< bool > gOptReflex(""reflex"", llvm::cl::desc(""Behave internally like genreflex.""), llvm::cl::cat(gRootclingOptions)); GetMostExternalEnclosingClassNamevoid GetMostExternalEnclosingClassName(const clang::DeclContext &theContext, std::string &ctxtName, const cling::Interpreter &interpreter, bool treatParent=true)Extract the proper autoload key for nested classes The routine does not erase the name,...Definition rootcling_impl.cxx:2195; GetFwdDeclnArgsToKeepStringstd::string GetFwdDeclnArgsToKeepString(const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt, cling::Interpreter &interp)Definition rootcling_impl.cxx:3047; ExtractAutoloadKeysint ExtractAutoloadKeys(std::list< std::string > &names, const COLL &decls, const cling::Interpreter &interp)Definition rootcling_impl.cxx:2223; gOptSharedLibFileNamestatic llvm::cl::opt< std::string > gOptSharedLibFileName(""s"", llvm::cl::desc(""The path to the library of the built dictionary.""), llvm::cl::cat(gRootclingOptions)); WriteStreamervoid WriteStreamer(const ROOT::TMetaUtils::AnnotatedRecordDecl &cl, const cling::Interpreter &interp, const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt, std::ostream &dictStream)Definition rootcling_impl.cxx:1390; IsGoodForAutoParseMapbool IsGoodForAutoPars",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:302786,Integrability,depend,dependent,302786,"finition rootcling_impl.cxx:1180; gOptExcludePathsstatic llvm::cl::list< std::string > gOptExcludePaths(""excludePath"", llvm::cl::ZeroOrMore, llvm::cl::desc(""Do not store the <path> in the dictionary.""), llvm::cl::cat(gRootclingOptions)); RecordDecl2Headersstd::list< std::string > RecordDecl2Headers(const clang::CXXRecordDecl &rcd, const cling::Interpreter &interp, std::set< const clang::CXXRecordDecl * > &visitedDecls)Extract the list of headers necessary for the Decl.Definition rootcling_impl.cxx:3086; EmitStreamerInfovoid EmitStreamerInfo(const char *normName)Definition rootcling_impl.cxx:168; gOptNoIncludePathsstatic llvm::cl::opt< bool > gOptNoIncludePaths(""noIncludePaths"", llvm::cl::desc(""Do not store include paths but rely on the env variable ROOT_INCLUDE_PATH.""), llvm::cl::cat(gRootclingOptions)); HasPathbool HasPath(const std::string &name)Check if file has a path.Definition rootcling_impl.cxx:2166; gOptLibListPrefixstatic llvm::cl::opt< std::string > gOptLibListPrefix(""lib-list-prefix"", llvm::cl::desc(""An ACLiC feature which exports the list of dependent libraries.""), llvm::cl::Hidden, llvm::cl::cat(gRootclingOptions)); gOptNoDictSelectionstatic llvm::cl::opt< bool > gOptNoDictSelection(""noDictSelection"", llvm::cl::Hidden, llvm::cl::desc(""Do not run the selection rules. Useful when in -onepcm mode.""), llvm::cl::cat(gRootclingOptions)); gOptDictionaryHeaderFilesstatic llvm::cl::list< std::string > gOptDictionaryHeaderFiles(llvm::cl::Positional, llvm::cl::ZeroOrMore, llvm::cl::desc(""<list of dictionary header files> <LinkDef file | selection xml file>""), llvm::cl::cat(gRootclingOptions)); CheckForUnsupportedClassesint CheckForUnsupportedClasses(const RScanner::ClassColl_t &annotatedRcds)Check if the list of selected classes contains any class which is not supported.Definition rootcling_impl.cxx:3459; EmitEnumsstatic void EmitEnums(const std::vector< const clang::EnumDecl * > &enumvec)Definition rootcling_impl.cxx:180; GenerateFullDictint GenerateFullDict(std::",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:13215,Modifiability,inherit,inherit,13215," name of the attribute is not ""name"", add attr to the ast.; 356 BaseSelectionRule::AttributesMap_t::iterator iter;; 357 std::string userDefinedProperty;; 358 for (auto const & attr : thisClassBaseSelectionRule->GetAttributes()) {; 359 const std::string &name = attr.first;; 360 if (name == ROOT::TMetaUtils::propNames::name) continue;; 361 const std::string &value = attr.second;; 362 userDefinedProperty = name + ROOT::TMetaUtils::propNames::separator + value;; 363 if (genreflex::verbose) std::cout << "" * "" << userDefinedProperty << std::endl;; 364 CXXRD.addAttr(AnnotateAttr::CreateImplicit(C, userDefinedProperty, nullptr, 0));; 365 }; 366 }; 367 ; 368 // See if the rule is a class selection rule (FIX dynamic_cast); 369 const ClassSelectionRule *thisClassSelectionRule = reinterpret_cast<const ClassSelectionRule *>(thisClassBaseSelectionRule);; 370 ; 371 for (CXXRecordDecl::decl_iterator I = CXXRD.decls_begin(),; 372 E = CXXRD.decls_end(); I != E; ++I) {; 373 ; 374 // CXXMethodDecl,FieldDecl and VarDecl inherit from NamedDecl; 375 // See: http://clang.llvm.org/doxygen/classclang_1_1DeclaratorDecl.html; 376 if (!(*I)->isImplicit(); 377 && (isa<CXXMethodDecl>(*I) || isa<FieldDecl>(*I) || isa<VarDecl>(*I))) {; 378 ; 379 // For now we allow only a special macro (ClassDef) to have meaningful comments; 380 bool isClassDefMacro = TMetaUtils::HasClassDefMacro(*I, interpreter);; 381 if (isClassDefMacro) {; 382 while (isa<NamedDecl>(*I) && cast<NamedDecl>(*I)->getName() != ""DeclFileLine"") {; 383 ++I;; 384 }; 385 }; 386 ; 387 comment = ROOT::TMetaUtils::GetComment(**I, &commentSLoc);; 388 if (comment.size()) {; 389 // The ClassDef annotation is for the class itself; 390 if (isClassDefMacro) {; 391 CXXRD.addAttr(AnnotateAttr::CreateImplicit(C, comment.str(), nullptr, 0));; 392 } else if (!isGenreflex) {; 393 // Here we check if we are in presence of a selection file so that; 394 // the comment does not ends up as a decoration in the AST,; 395 // Nevertheless, w/o PCMS this has no ef",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:14787,Modifiability,variab,variable,14787,"Attr::CreateImplicit(C, comment.str(), nullptr, 0));; 392 } else if (!isGenreflex) {; 393 // Here we check if we are in presence of a selection file so that; 394 // the comment does not ends up as a decoration in the AST,; 395 // Nevertheless, w/o PCMS this has no effect, since the headers; 396 // are parsed at runtime and the information in the AST dumped by; 397 // rootcling is not relevant.; 398 (*I)->addAttr(AnnotateAttr::CreateImplicit(C, comment.str(), nullptr, 0));; 399 }; 400 }; 401 // Match decls with sel rules if we are in presence of a selection file; 402 // and the cast was successful; 403 if (isGenreflex && thisClassSelectionRule != nullptr) {; 404 const std::list<VariableSelectionRule> &fieldSelRules = thisClassSelectionRule->GetFieldSelectionRules();; 405 ; 406 // This check is here to avoid asserts in debug mode (LLVMDEV env variable set); 407 if (FieldDecl *fieldDecl = dyn_cast<FieldDecl>(*I)) {; 408 AnnotateFieldDecl(*fieldDecl, fieldSelRules);; 409 }; 410 } // End presence of XML selection file; 411 }; 412 }; 413}; 414 ; 415////////////////////////////////////////////////////////////////////////////////; 416 ; 417size_t GetFullArrayLength(const clang::ConstantArrayType *arrayType); 418{; 419 if (!arrayType); 420 return 0;; 421 llvm::APInt len = arrayType->getSize();; 422 while (const clang::ConstantArrayType *subArrayType = llvm::dyn_cast<clang::ConstantArrayType>(arrayType->getArrayElementTypeNoTypeQual())) {; 423 len *= subArrayType->getSize();; 424 arrayType = subArrayType;; 425 }; 426 return len.getLimitedValue();; 427}; 428 ; 429////////////////////////////////////////////////////////////////////////////////; 430 ; 431bool InheritsFromTObject(const clang::RecordDecl *cl,; 432 const cling::Interpreter &interp); 433{; 434 static const clang::CXXRecordDecl *TObject_decl; 435 = ROOT::TMetaUtils::ScopeSearch(""TObject"", interp, true /*diag*/, nullptr);; 436 ; 437 const clang::CXXRecordDecl *clxx = llvm::dyn_cast<clang::CXXRecordDecl>(cl);; 438 retu",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:28474,Modifiability,inherit,inherits,28474,"t_error;; 792 ; 793 delete [] proto;; 794 ; 795 return has_input_error;; 796}; 797 ; 798////////////////////////////////////////////////////////////////////////////////; 799/// Return false if the class does not have ClassDef even-though it should.; 800 ; 801bool CheckClassDef(const clang::RecordDecl &cl, const cling::Interpreter &interp); 802{; 803 ; 804 // Detect if the class has a ClassDef; 805 bool hasClassDef = ROOT::TMetaUtils::ClassInfo__HasMethod(&cl, ""Class_Version"", interp);; 806 ; 807 const clang::CXXRecordDecl *clxx = llvm::dyn_cast<clang::CXXRecordDecl>(&cl);; 808 if (!clxx) {; 809 return false;; 810 }; 811 bool isAbstract = clxx->isAbstract();; 812 ; 813 if (!isAbstract && InheritsFromTObject(clxx, interp) && !InheritsFromTSelector(clxx, interp) && !hasClassDef) {; 814 std::string qualName;; 815 ROOT::TMetaUtils::GetQualifiedName(qualName, cl);; 816 const char *qualName_c = qualName.c_str();; 817 ROOT::TMetaUtils::Warning(qualName_c, ""The data members of %s will not be stored, ""; 818 ""because it inherits from TObject but does not ""; 819 ""have its own ClassDef.\n"",; 820 qualName_c);; 821 }; 822 ; 823 return true;; 824}; 825 ; 826////////////////////////////////////////////////////////////////////////////////; 827/// Return the name of the data member so that it can be used; 828/// by non-const operation (so it includes a const_cast if necessary).; 829 ; 830string GetNonConstMemberName(const clang::FieldDecl &m, const string &prefix = """"); 831{; 832 if (m.getType().isConstQualified()) {; 833 string ret = ""const_cast< "";; 834 string type_name;; 835 ROOT::TMetaUtils::GetQualifiedName(type_name, m.getType(), m);; 836 if (type_name.substr(0,6)==""const "") {; 837 ret += type_name.c_str()+6;; 838 } else {; 839 ret += type_name;; 840 }; 841 ret += "" &>( "";; 842 ret += prefix;; 843 ret += m.getName().str();; 844 ret += "" )"";; 845 return ret;; 846 } else {; 847 return prefix + m.getName().str();; 848 }; 849}; 850 ; 851//////////////////////////////////////////////",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:49821,Modifiability,variab,variable,49821," = ROOT::TMetaUtils::GetFileName(*cl, interp);; 1308 for (unsigned int i = 0; i < filename.length(); i++) {; 1309 if (filename[i] == '\\') filename[i] = '/';; 1310 }; 1311 dictStream << ""\"""" << filename << ""\"", "" << ROOT::TMetaUtils::GetLineNumber(cl) << "","" << std::endl; 1312 << "" ::ROOT::Internal::DefineBehavior((void*)nullptr,(void*)nullptr),"" << std::endl; 1313 << "" "";; 1314 ; 1315 if (Namespace__HasMethod(cl, ""Dictionary"", interp)) {; 1316 dictStream << ""&::"" << classname.c_str() << ""::Dictionary, "";; 1317 } else {; 1318 dictStream << ""&"" << mappedname.c_str() << ""_Dictionary, "";; 1319 }; 1320 ; 1321 dictStream << 0 << "");"" << std::endl; 1322 ; 1323 << "" return &instance;"" << std::endl; 1324 << "" }"" << std::endl; 1325 << "" // Insure that the inline function is _not_ optimized away by the compiler\n""; 1326 << "" ::ROOT::TGenericClassInfo *(*_R__UNIQUE_DICT_(InitFunctionKeeper))() = &GenerateInitInstance; "" << std::endl; 1327 << "" // Static variable to force the class initialization"" << std::endl; 1328 // must be one long line otherwise R__UseDummy does not work; 1329 << "" static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstance();""; 1330 << "" R__UseDummy(_R__UNIQUE_DICT_(Init));"" << std::endl;; 1331 ; 1332 if (!Namespace__HasMethod(cl, ""Dictionary"", interp)) {; 1333 dictStream << std::endl << "" // Dictionary for non-ClassDef classes"" << std::endl; 1334 << "" static TClass *"" << mappedname.c_str() << ""_Dictionary() {"" << std::endl; 1335 << "" return GenerateInitInstance()->GetClass();"" << std::endl; 1336 << "" }"" << std::endl << std::endl;; 1337 }; 1338 ; 1339 dictStream << "" }"" << std::endl;; 1340 while (nesting--) {; 1341 dictStream << ""}"" << std::endl;; 1342 }; 1343 dictStream << std::endl;; 1344}; 1345 ; 1346////////////////////////////////////////////////////////////////////////////////; 1347/// GrabIndex returns a static string (so use it or copy it immediately, do not; 1348/// call GrabIndex twice in the same expression) containing the si",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:92588,Modifiability,variab,variables,92588,"12 }; 2313 ; 2314 // Same for namespaces; 2315 if (!nsNames.empty()) {; 2316 rootmapFile << ""# List of selected namespaces\n"";; 2317 for (auto & nsName : nsNames) {; 2318 rootmapFile << ""namespace "" << nsName << std::endl;; 2319 }; 2320 }; 2321 ; 2322 // And typedefs. These are used just to trigger the autoload mechanism; 2323 if (!tdNames.empty()) {; 2324 rootmapFile << ""# List of selected typedefs and outer classes\n"";; 2325 for (const auto & autoloadKey : tdNames); 2326 if (classesKeys.insert(autoloadKey).second); 2327 rootmapFile << ""typedef "" << autoloadKey << std::endl;; 2328 }; 2329 ; 2330 // And Enums. There is no incomplete type for an enum but we can nevertheless; 2331 // have the key for the cases where the root typesystem is interrogated.; 2332 if (!enNames.empty()){; 2333 rootmapFile << ""# List of selected enums and outer classes\n"";; 2334 for (const auto & autoloadKey : enNames); 2335 if (classesKeys.insert(autoloadKey).second); 2336 rootmapFile << ""enum "" << autoloadKey << std::endl;; 2337 }; 2338 ; 2339 // And variables.; 2340 if (!varNames.empty()){; 2341 rootmapFile << ""# List of selected vars\n"";; 2342 for (const auto & autoloadKey : varNames); 2343 if (classesKeys.insert(autoloadKey).second); 2344 rootmapFile << ""var "" << autoloadKey << std::endl;; 2345 }; 2346 ; 2347 }; 2348 ; 2349 return 0;; 2350 ; 2351}; 2352 ; 2353////////////////////////////////////////////////////////////////////////////////; 2354/// Performance is not critical here.; 2355 ; 2356std::pair<std::string,std::string> GetExternalNamespaceAndContainedEntities(const std::string line); 2357{; 2358 auto nsPattern = '{'; auto nsPatternLength = 1;; 2359 auto foundNsPos = line.find_last_of(nsPattern);; 2360 if (foundNsPos == std::string::npos) return {"""",""""};; 2361 foundNsPos+=nsPatternLength;; 2362 auto extNs = line.substr(0,foundNsPos);; 2363 ; 2364 auto nsEndPattern = '}';; 2365 auto foundEndNsPos = line.find(nsEndPattern);; 2366 auto contained = line.substr(foundNsPos, foundEndNsPo",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:130784,Modifiability,variab,variables,130784," 3269 // remove duplicates, also if not subsequent; 3270 buffer.clear();; 3271 headers.remove_if([&buffer](const std::string & s) {; 3272 return !buffer.insert(s).second;; 3273 });; 3274 GetMostExternalEnclosingClassNameFromDecl(*tDef, autoParseKey, interp);; 3275 if (autoParseKey.empty()) autoParseKey = tDef->getQualifiedNameAsString();; 3276 headersDeclsMap[autoParseKey] = headers;; 3277 }; 3278 }; 3279 ; 3280 // The same for the functions:; 3281 for (auto & func : funcDecls) {; 3282 std::list<std::string> headers = {ROOT::TMetaUtils::GetFileName(*func, interp)};; 3283 headersDeclsMap[ROOT::TMetaUtils::GetQualifiedName(*func)] = headers;; 3284 }; 3285 ; 3286 // The same for the variables:; 3287 for (auto & var : varDecls) {; 3288 std::list<std::string> headers = {ROOT::TMetaUtils::GetFileName(*var, interp)};; 3289 headersDeclsMap[ROOT::TMetaUtils::GetQualifiedName(*var)] = headers;; 3290 }; 3291 ; 3292 // The same for the enums:; 3293 for (auto & en : enumDecls) {; 3294 std::list<std::string> headers = {ROOT::TMetaUtils::GetFileName(*en, interp)};; 3295 headersDeclsMap[ROOT::TMetaUtils::GetQualifiedName(*en)] = headers;; 3296 }; 3297}; 3298 ; 3299////////////////////////////////////////////////////////////////////////////////; 3300/// Generate the fwd declarations of the selected entities; 3301 ; 3302static std::string GenerateFwdDeclString(const RScanner &scan,; 3303 const cling::Interpreter &interp); 3304{; 3305 std::string newFwdDeclString;; 3306 ; 3307 using namespace ROOT::TMetaUtils::AST2SourceTools;; 3308 ; 3309 std::string fwdDeclString;; 3310 std::string buffer;; 3311 std::unordered_set<std::string> fwdDecls;; 3312 ; 3313 // Classes; 3314/*; 3315 for (auto const & annRcd : scan.fSelectedClasses) {; 3316 const auto rcdDeclPtr = annRcd.GetRecordDecl();; 3317 ; 3318 int retCode = FwdDeclFromRcdDecl(*rcdDeclPtr, interp, buffer);; 3319 if (-1 == retCode) {; 3320 ROOT::TMetaUtils::Error(""GenerateFwdDeclString"",; 3321 ""Error generating fwd decl for class %s\n"",;",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:146783,Modifiability,variab,variable,146783,"just forward to the child and the default method.; 3648 virtual void clear() override; 3649 {; 3650 fChild->clear();; 3651 DiagnosticConsumer::clear();; 3652 }; 3653 ; 3654 virtual void BeginSourceFile(const clang::LangOptions &LangOpts, const clang::Preprocessor *PP) override; 3655 {; 3656 fChild->BeginSourceFile(LangOpts, PP);; 3657 DiagnosticConsumer::BeginSourceFile(LangOpts, PP);; 3658 }; 3659 ; 3660 virtual void EndSourceFile() override; 3661 {; 3662 fChild->EndSourceFile();; 3663 DiagnosticConsumer::EndSourceFile();; 3664 }; 3665 ; 3666 virtual void finish() override; 3667 {; 3668 fChild->finish();; 3669 DiagnosticConsumer::finish();; 3670 }; 3671 ; 3672 virtual bool IncludeInDiagnosticCounts() const override { return fChild->IncludeInDiagnosticCounts(); }; 3673};; 3674 ; 3675static void MaybeSuppressWin32CrashDialogs() {; 3676#if defined(_WIN32) && defined(_MSC_VER); 3677 // Suppress error dialogs to avoid hangs on build nodes.; 3678 // One can use an environment variable (Cling_GuiOnAssert) to enable; 3679 // the error dialogs.; 3680 const char *EnablePopups = getenv(""Cling_GuiOnAssert"");; 3681 if (EnablePopups == nullptr || EnablePopups[0] == '0') {; 3682 ::_set_error_mode(_OUT_TO_STDERR);; 3683 _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3684 _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);; 3685 _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3686 _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);; 3687 _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3688 _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);; 3689 }; 3690#endif; 3691}; 3692 ; 3693static llvm::cl::opt<bool> gOptForce(""f"", llvm::cl::desc(""Overwrite <file>s.""),; 3694 llvm::cl::cat(gRootclingOptions));; 3695static llvm::cl::opt<bool> gOptRootBuild(""rootbuild"", llvm::cl::desc(""If we are building ROOT.""),; 3696 llvm::cl::Hidden,; 3697 llvm::cl::cat(gRootclingOptions));; 3698enum VerboseLevel {; 3699 v = ROOT::TMetaUti",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:153910,Modifiability,variab,variable,153910,"rface; 3806// to be able to tell which component is in the pch and which needs extra; 3807// scaffolding for interactive use. Moreover, some of the ROOT components are; 3808// partially in the pch and this option makes it impossible to express that.; 3809// We should be able to get the list of headers in the pch early and scan; 3810// through them.; 3811static llvm::cl::opt<bool>; 3812gOptWriteEmptyRootPCM(""writeEmptyRootPCM"",; 3813 llvm::cl::Hidden,; 3814 llvm::cl::desc(""Does not include the header files as it assumes they exist in the pch.""),; 3815 llvm::cl::cat(gRootclingOptions));; 3816static llvm::cl::opt<bool>; 3817gOptCheckSelectionSyntax(""selSyntaxOnly"",; 3818 llvm::cl::desc(""Check the selection syntax only.""),; 3819 llvm::cl::cat(gRootclingOptions));; 3820static llvm::cl::opt<bool>; 3821gOptFailOnWarnings(""failOnWarnings"",; 3822 llvm::cl::desc(""Fail if there are warnings.""),; 3823 llvm::cl::cat(gRootclingOptions));; 3824static llvm::cl::opt<bool>; 3825gOptNoIncludePaths(""noIncludePaths"",; 3826 llvm::cl::desc(""Do not store include paths but rely on the env variable ROOT_INCLUDE_PATH.""),; 3827 llvm::cl::cat(gRootclingOptions));; 3828static llvm::cl::opt<std::string>; 3829gOptISysRoot(""isysroot"", llvm::cl::Prefix, llvm::cl::Hidden,; 3830 llvm::cl::desc(""Specify an isysroot.""),; 3831 llvm::cl::cat(gRootclingOptions),; 3832 llvm::cl::init(""-""));; 3833static llvm::cl::list<std::string>; 3834gOptIncludePaths(""I"", llvm::cl::Prefix, llvm::cl::ZeroOrMore,; 3835 llvm::cl::desc(""Specify an include path.""),; 3836 llvm::cl::cat(gRootclingOptions));; 3837static llvm::cl::list<std::string>; 3838gOptCompDefaultIncludePaths(""compilerI"", llvm::cl::Prefix, llvm::cl::ZeroOrMore,; 3839 llvm::cl::desc(""Specify a compiler default include path, to suppress unneeded `-isystem` arguments.""),; 3840 llvm::cl::cat(gRootclingOptions));; 3841static llvm::cl::list<std::string>; 3842gOptSysIncludePaths(""isystem"", llvm::cl::ZeroOrMore,; 3843 llvm::cl::desc(""Specify a system include path.""),; ",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:156724,Modifiability,variab,variable,156724," 3860 llvm::cl::desc(""<list of dictionary header files> <LinkDef file | selection xml file>""),; 3861 llvm::cl::cat(gRootclingOptions));; 3862static llvm::cl::list<std::string>; 3863gOptSink(llvm::cl::ZeroOrMore, llvm::cl::Sink,; 3864 llvm::cl::desc(""Consumes all unrecognized options.""),; 3865 llvm::cl::cat(gRootclingOptions));; 3866 ; 3867static llvm::cl::SubCommand; 3868gBareClingSubcommand(""bare-cling"", ""Call directly cling and exit."");; 3869 ; 3870static llvm::cl::list<std::string>; 3871gOptBareClingSink(llvm::cl::OneOrMore, llvm::cl::Sink,; 3872 llvm::cl::desc(""Consumes options and sends them to cling.""),; 3873 llvm::cl::cat(gRootclingOptions), llvm::cl::sub(gBareClingSubcommand));; 3874 ; 3875////////////////////////////////////////////////////////////////////////////////; 3876/// Returns true iff a given module (and its submodules) contains all headers; 3877/// needed by the given ModuleGenerator.; 3878/// The names of all header files that are needed by the ModuleGenerator but are; 3879/// not in the given module will be inserted into the MissingHeader variable.; 3880/// Returns true iff the PCH was successfully generated.; 3881static bool ModuleContainsHeaders(TModuleGenerator &modGen, clang::HeaderSearch &headerSearch,; 3882 clang::Module *module, std::vector<std::array<std::string, 2>> &missingHeaders); 3883{; 3884 // Now we collect all header files from the previously collected modules.; 3885 std::vector<clang::Module::Header> moduleHeaders;; 3886 ROOT::TMetaUtils::foreachHeaderInModule(*module,; 3887 [&moduleHeaders](const clang::Module::Header &h) { moduleHeaders.push_back(h); });; 3888 ; 3889 bool foundAllHeaders = true;; 3890 ; 3891 auto isHeaderInModule = [&moduleHeaders](const std::string &header) {; 3892 for (const clang::Module::Header &moduleHeader : moduleHeaders); 3893 if (header == moduleHeader.NameAsWritten); 3894 return true;; 3895 return false;; 3896 };; 3897 ; 3898 // Go through the list of headers that are required by the ModuleGenerator; ",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:174076,Modifiability,variab,variable,174076,"ndif; 4263 ; 4264 clingArgs.push_back(""-fsyntax-only"");; 4265#ifndef R__WIN32; 4266 clingArgs.push_back(""-fPIC"");; 4267#endif; 4268 clingArgs.push_back(""-Xclang"");; 4269 clingArgs.push_back(""-fmodules-embed-all-files"");; 4270 clingArgs.push_back(""-Xclang"");; 4271 clingArgs.push_back(""-main-file-name"");; 4272 clingArgs.push_back(""-Xclang"");; 4273 clingArgs.push_back((dictname + "".h"").c_str());; 4274 ; 4275 ROOT::TMetaUtils::SetPathsForRelocatability(clingArgs);; 4276 ; 4277 // FIXME: This line is from TModuleGenerator, but we can't reuse this code; 4278 // at this point because TModuleGenerator needs a CompilerInstance (and we; 4279 // currently create the arguments for creating said CompilerInstance).; 4280 bool isPCH = (gOptDictionaryFileName.getValue() == ""allDict.cxx"");; 4281 std::string outputFile;; 4282 // Data is in 'outputFile', therefore in the same scope.; 4283 llvm::StringRef moduleName;; 4284 std::string vfsArg;; 4285 // Adding -fmodules to the args will break lexing with __CINT__ defined,; 4286 // and we actually do lex with __CINT__ and reuse this variable later,; 4287 // we have to copy it now.; 4288 auto clingArgsInterpreter = clingArgs;; 4289 ; 4290 if (gOptSharedLibFileName.empty()) {; 4291 gOptSharedLibFileName = gOptDictionaryFileName.getValue();; 4292 }; 4293 ; 4294 if (!isPCH && gOptCxxModule) {; 4295 // We just pass -fmodules, the CIFactory will do the rest and configure; 4296 // clang correctly once it sees this flag.; 4297 clingArgsInterpreter.push_back(""-fmodules"");; 4298 clingArgsInterpreter.push_back(""-fno-implicit-module-maps"");; 4299 ; 4300 for (const std::string &modulemap : gOptModuleMapFiles); 4301 clingArgsInterpreter.push_back(""-fmodule-map-file="" + modulemap);; 4302 ; 4303 clingArgsInterpreter.push_back(""-fmodule-map-file="" +; 4304 std::string(gDriverConfig->fTROOT__GetIncludeDir()) +; 4305 ""/ROOT.modulemap"");; 4306 std::string ModuleMapCWD = ROOT::FoundationUtils::GetCurrentDir() + ""/module.modulemap"";; 4307 if (llvm::sys::fs::exis",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:174405,Modifiability,config,configure,174405,"dictname + "".h"").c_str());; 4274 ; 4275 ROOT::TMetaUtils::SetPathsForRelocatability(clingArgs);; 4276 ; 4277 // FIXME: This line is from TModuleGenerator, but we can't reuse this code; 4278 // at this point because TModuleGenerator needs a CompilerInstance (and we; 4279 // currently create the arguments for creating said CompilerInstance).; 4280 bool isPCH = (gOptDictionaryFileName.getValue() == ""allDict.cxx"");; 4281 std::string outputFile;; 4282 // Data is in 'outputFile', therefore in the same scope.; 4283 llvm::StringRef moduleName;; 4284 std::string vfsArg;; 4285 // Adding -fmodules to the args will break lexing with __CINT__ defined,; 4286 // and we actually do lex with __CINT__ and reuse this variable later,; 4287 // we have to copy it now.; 4288 auto clingArgsInterpreter = clingArgs;; 4289 ; 4290 if (gOptSharedLibFileName.empty()) {; 4291 gOptSharedLibFileName = gOptDictionaryFileName.getValue();; 4292 }; 4293 ; 4294 if (!isPCH && gOptCxxModule) {; 4295 // We just pass -fmodules, the CIFactory will do the rest and configure; 4296 // clang correctly once it sees this flag.; 4297 clingArgsInterpreter.push_back(""-fmodules"");; 4298 clingArgsInterpreter.push_back(""-fno-implicit-module-maps"");; 4299 ; 4300 for (const std::string &modulemap : gOptModuleMapFiles); 4301 clingArgsInterpreter.push_back(""-fmodule-map-file="" + modulemap);; 4302 ; 4303 clingArgsInterpreter.push_back(""-fmodule-map-file="" +; 4304 std::string(gDriverConfig->fTROOT__GetIncludeDir()) +; 4305 ""/ROOT.modulemap"");; 4306 std::string ModuleMapCWD = ROOT::FoundationUtils::GetCurrentDir() + ""/module.modulemap"";; 4307 if (llvm::sys::fs::exists(ModuleMapCWD)); 4308 clingArgsInterpreter.push_back(""-fmodule-map-file="" + ModuleMapCWD);; 4309 ; 4310 // Specify the module name that we can lookup the module in the modulemap.; 4311 outputFile = llvm::sys::path::stem(gOptSharedLibFileName).str();; 4312 // Try to get the module name in the modulemap based on the filepath.; 4313 moduleName = GetModuleNameFromRdic",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:182620,Modifiability,config,configuration,182620,"427 if (ROOT::TMetaUtils::GetErrorIgnoreLevel() == ROOT::TMetaUtils::kInfo) {; 4428 ROOT::TMetaUtils::Info(nullptr, ""\n"");; 4429 ROOT::TMetaUtils::Info(nullptr, ""==== INTERPRETER CONFIGURATION ====\n"");; 4430 ROOT::TMetaUtils::Info(nullptr, ""== Include paths\n"");; 4431 interp.DumpIncludePath();; 4432 printf(""\n\n"");; 4433 fflush(stdout);; 4434 ; 4435 ROOT::TMetaUtils::Info(nullptr, ""== Included files\n"");; 4436 interp.printIncludedFiles(llvm::outs());; 4437 llvm::outs() << ""\n\n"";; 4438 llvm::outs().flush();; 4439 ; 4440 ROOT::TMetaUtils::Info(nullptr, ""== Language Options\n"");; 4441 const clang::LangOptions& LangOpts; 4442 = interp.getCI()->getASTContext().getLangOpts();; 4443#define LANGOPT(Name, Bits, Default, Description) \; 4444 ROOT::TMetaUtils::Info(nullptr, ""%s = %d // %s\n"", #Name, (int)LangOpts.Name, Description);; 4445#define ENUM_LANGOPT(Name, Type, Bits, Default, Description); 4446#include ""clang/Basic/LangOptions.def""; 4447 ROOT::TMetaUtils::Info(nullptr, ""==== END interpreter configuration ====\n\n"");; 4448 }; 4449 ; 4450 interp.getOptions().ErrorOut = true;; 4451 interp.enableRawInput(true);; 4452 ; 4453 if (gOptCxxModule) {; 4454 for (llvm::StringRef DepMod : gOptModuleDependencies) {; 4455 if (DepMod.endswith(""_rdict.pcm"")) {; 4456 ROOT::TMetaUtils::Warning(nullptr, ""'%s' value is deprecated. Please use [<fullpath>]%s.pcm\n"",; 4457 DepMod.data(),; 4458 GetModuleNameFromRdictName(DepMod).str().data());; 4459 }; 4460 DepMod = GetModuleNameFromRdictName(DepMod);; 4461 // We might deserialize.; 4462 cling::Interpreter::PushTransactionRAII RAII(&interp);; 4463 if (!interp.loadModule(DepMod.str(), /*complain*/false)) {; 4464 ROOT::TMetaUtils::Error(nullptr, ""Module '%s' failed to load.\n"",; 4465 DepMod.data());; 4466 }; 4467 }; 4468 }; 4469 ; 4470 if (!isGenreflex) { // rootcling; 4471 // ROOTCINT uses to define a few header implicitly, we need to do it explicitly.; 4472 if (interp.declare(""#include <assert.h>\n""; 4473 ""#include \""Rtypes.h\""\n""; 4474 ""#in",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:228560,Modifiability,variab,variable,228560,"t \""//\"". For example comment=\""!\"" or \""||\"".\n""; 5679 "" - noStreamer [true/false]: turns off streamer generation if set to 'true.'\n""; 5680 "" Default value is 'false'\n""; 5681 "" - rntupleStreamerMode [true/false]: enforce streamed or native writing for RNTuple.\n""; 5682 "" If unset, RNTuple stores classes in split mode or fails if the class cannot be split.\n""; 5683 "" - noInputOperator [true/false]: turns off input operator generation if set\n""; 5684 "" to 'true'. Default value is 'false'\n""; 5685 "" Example XML:\n""; 5686 "" <lcgdict>\n""; 5687 "" [<selection>]\n""; 5688 "" <class [name=\""classname\""] [pattern=\""wildname\""]\n""; 5689 "" [file_name=\""filename\""] [file_pattern=\""wildname\""]\n""; 5690 "" [id=\""xxxx\""] [noStreamer=\""true/false\""]\n""; 5691 "" [noInputOperator=\""true/false\""]\n""; 5692 "" [rntupleStreamerMode=\""true/false\""] />\n""; 5693 "" <class name=\""classname\"" >\n""; 5694 "" <field name=\""m_transient\"" transient=\""true\""/>\n""; 5695 "" <field name=\""m_anothertransient\"" persistent=\""false\""/>\n""; 5696 "" <field name=\""m_anothertransient\"" comment=\""||\""/>\n""; 5697 "" <properties prop1=\""value1\"" [prop2=\""value2\""]/>\n""; 5698 "" </class>\n""; 5699 "" <function [name=\""funcname\""] [pattern=\""wildname\""] />\n""; 5700 "" <enum [name=\""enumname\""] [pattern=\""wildname\""] />\n""; 5701 "" <variable [name=\""varname\""] [pattern=\""wildname\""] />\n""; 5702 "" [</selection>]\n""; 5703 "" <exclusion>\n""; 5704 "" <class [name=\""classname\""] [pattern=\""wildname\""] />\n""; 5705 "" <method name=\""unwanted\"" />\n""; 5706 "" </class>\n""; 5707 "" ...\n""; 5708 "" </lcgdict>\n""; 5709 ""\n""; 5710 "" If no selection file is specified, the class with the filename without\n""; 5711 "" extension will be selected, i.e. myClass.h as argument without any\n""; 5712 "" selection xml comes with an implicit selection rule for class \""myClass\"".\n"";; 5713 ; 5714 const char *outputFilenameUsage =; 5715 ""-o, --output\tOutput filename\n""; 5716 "" Output file name. If an existing directory is specified instead of a file,\n""; 5717 "" t",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:235458,Modifiability,variab,variable,235458,"ion::Arg::None,; 5901 ""--writeEmptyPCM\tWrite an empty ROOT pcm.\n""; 5902 },; 5903 ; 5904 {; 5905 CXXMODULE,; 5906 NOTYPE ,; 5907 """" , ""cxxmodule"",; 5908 ROOT::option::Arg::None,; 5909 ""--cxxmodule\tGenerates a PCM for C++ Modules.\n""; 5910 },; 5911 ; 5912 ; 5913 {; 5914 HELP,; 5915 NOTYPE,; 5916 ""h"" , ""help"",; 5917 ROOT::option::Arg::None,; 5918 ""--help\tPrint usage and exit.\n""; 5919 },; 5920 ; 5921 {; 5922 FAILONWARNINGS,; 5923 NOTYPE,; 5924 """", ""fail_on_warnings"",; 5925 ROOT::option::Arg::None,; 5926 ""--fail_on_warnings\tFail on warnings and errors.\n""; 5927 },; 5928 ; 5929 {; 5930 SELSYNTAXONLY,; 5931 NOTYPE,; 5932 """", ""selSyntaxOnly"",; 5933 ROOT::option::Arg::None,; 5934 ""--selSyntaxOnly\tValidate selection file w/o generating the dictionary.\n""; 5935 },; 5936 ; 5937 {; 5938 NOINCLUDEPATHS,; 5939 NOTYPE ,; 5940 """" , ""noIncludePaths"",; 5941 ROOT::option::Arg::None,; 5942 ""--noIncludePaths\tDo not store the headers' directories in the dictionary. Instead, rely on the environment variable $ROOT_INCLUDE_PATH at runtime.\n""; 5943 },; 5944 ; 5945 // Left intentionally empty not to be shown in the help, like in the first genreflex; 5946 {; 5947 INCLUDE,; 5948 STRING ,; 5949 ""I"" , """" ,; 5950 ROOT::option::FullArg::Required,; 5951 """"; 5952 },; 5953 ; 5954 {; 5955 PREPROCDEFINE,; 5956 STRING ,; 5957 ""D"" , """" ,; 5958 ROOT::option::FullArg::Required,; 5959 """"; 5960 },; 5961 ; 5962 {; 5963 PREPROCUNDEFINE,; 5964 STRING ,; 5965 ""U"" , """" ,; 5966 ROOT::option::FullArg::Required,; 5967 """"; 5968 },; 5969 ; 5970 {; 5971 WARNING,; 5972 STRING ,; 5973 ""W"" , """" ,; 5974 ROOT::option::FullArg::Required,; 5975 """"; 5976 },; 5977 ; 5978 {; 5979 NOMEMBERTYPEDEFS, // Option which is not meant for the user: deprecated; 5980 STRING ,; 5981 """" , ""no_membertypedefs"" ,; 5982 ROOT::option::FullArg::None,; 5983 """"; 5984 },; 5985 ; 5986 {; 5987 NOTEMPLATETYPEDEFS, // Option which is not meant for the user: deprecated; 5988 STRING ,; 5989 """" , ""no_templatetypedefs"" ,; 5990 ROOT::option::FullArg::No",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:244400,Modifiability,config,config,244400,"n,; 6171 selectionFileName,; 6172 targetLibName,; 6173 multidict,; 6174 pcmsNames,; 6175 includes,; 6176 preprocDefines,; 6177 preprocUndefines,; 6178 warnings,; 6179 rootmapFileName,; 6180 rootmapLibName,; 6181 interpreteronly,; 6182 doSplit,; 6183 isCxxmodule,; 6184 writeEmptyRootPCM,; 6185 selSyntaxOnly,; 6186 noIncludePaths,; 6187 noGlobalUsingStd,; 6188 headersNames,; 6189 failOnWarnings,; 6190 printRootclingInvocation,; 6191 ofileName);; 6192 } else {; 6193 // Here ofilename is either """" or a directory: this is irrelevant.; 6194 returnValue = invokeManyRootCling(verbosityOption,; 6195 selectionFileName,; 6196 targetLibName,; 6197 multidict,; 6198 pcmsNames,; 6199 includes,; 6200 preprocDefines,; 6201 preprocUndefines,; 6202 warnings,; 6203 rootmapFileName,; 6204 rootmapLibName,; 6205 interpreteronly,; 6206 doSplit,; 6207 isCxxmodule,; 6208 writeEmptyRootPCM,; 6209 selSyntaxOnly,; 6210 noIncludePaths,; 6211 noGlobalUsingStd,; 6212 headersNames,; 6213 failOnWarnings,; 6214 printRootclingInvocation,; 6215 ofileName);; 6216 }; 6217 ; 6218 return returnValue;; 6219}; 6220 ; 6221 ; 6222////////////////////////////////////////////////////////////////////////////////; 6223 ; 6224extern ""C""; 6225int ROOT_rootcling_Driver(int argc, char **argv, const ROOT::Internal::RootCling::DriverConfig& config); 6226{; 6227 ; 6228 assert(!gDriverConfig && ""Driver configuration already set!"");; 6229 gDriverConfig = &config;; 6230 ; 6231 gBuildingROOT = config.fBuildingROOTStage1; // gets refined later; 6232 ; 6233 std::string exeName = ExtractFileName(GetExePath());; 6234#ifdef __APPLE__; 6235 // _dyld_get_image_name() on macOS11 and later sometimes returns ""rootcling"" for ""genreflex"".; 6236 // Fix that (while still initializing the binary path, needed for ROOTSYS) by updating the; 6237 // exeName to argv[0]:; 6238 exeName = ExtractFileName(argv[0]);; 6239#endif; 6240 ; 6241 // Select according to the name of the executable the procedure to follow:; 6242 // 1) RootCling; 6243 // 2) G",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:244461,Modifiability,config,configuration,244461,"n,; 6171 selectionFileName,; 6172 targetLibName,; 6173 multidict,; 6174 pcmsNames,; 6175 includes,; 6176 preprocDefines,; 6177 preprocUndefines,; 6178 warnings,; 6179 rootmapFileName,; 6180 rootmapLibName,; 6181 interpreteronly,; 6182 doSplit,; 6183 isCxxmodule,; 6184 writeEmptyRootPCM,; 6185 selSyntaxOnly,; 6186 noIncludePaths,; 6187 noGlobalUsingStd,; 6188 headersNames,; 6189 failOnWarnings,; 6190 printRootclingInvocation,; 6191 ofileName);; 6192 } else {; 6193 // Here ofilename is either """" or a directory: this is irrelevant.; 6194 returnValue = invokeManyRootCling(verbosityOption,; 6195 selectionFileName,; 6196 targetLibName,; 6197 multidict,; 6198 pcmsNames,; 6199 includes,; 6200 preprocDefines,; 6201 preprocUndefines,; 6202 warnings,; 6203 rootmapFileName,; 6204 rootmapLibName,; 6205 interpreteronly,; 6206 doSplit,; 6207 isCxxmodule,; 6208 writeEmptyRootPCM,; 6209 selSyntaxOnly,; 6210 noIncludePaths,; 6211 noGlobalUsingStd,; 6212 headersNames,; 6213 failOnWarnings,; 6214 printRootclingInvocation,; 6215 ofileName);; 6216 }; 6217 ; 6218 return returnValue;; 6219}; 6220 ; 6221 ; 6222////////////////////////////////////////////////////////////////////////////////; 6223 ; 6224extern ""C""; 6225int ROOT_rootcling_Driver(int argc, char **argv, const ROOT::Internal::RootCling::DriverConfig& config); 6226{; 6227 ; 6228 assert(!gDriverConfig && ""Driver configuration already set!"");; 6229 gDriverConfig = &config;; 6230 ; 6231 gBuildingROOT = config.fBuildingROOTStage1; // gets refined later; 6232 ; 6233 std::string exeName = ExtractFileName(GetExePath());; 6234#ifdef __APPLE__; 6235 // _dyld_get_image_name() on macOS11 and later sometimes returns ""rootcling"" for ""genreflex"".; 6236 // Fix that (while still initializing the binary path, needed for ROOTSYS) by updating the; 6237 // exeName to argv[0]:; 6238 exeName = ExtractFileName(argv[0]);; 6239#endif; 6240 ; 6241 // Select according to the name of the executable the procedure to follow:; 6242 // 1) RootCling; 6243 // 2) G",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:244514,Modifiability,config,config,244514,"n,; 6171 selectionFileName,; 6172 targetLibName,; 6173 multidict,; 6174 pcmsNames,; 6175 includes,; 6176 preprocDefines,; 6177 preprocUndefines,; 6178 warnings,; 6179 rootmapFileName,; 6180 rootmapLibName,; 6181 interpreteronly,; 6182 doSplit,; 6183 isCxxmodule,; 6184 writeEmptyRootPCM,; 6185 selSyntaxOnly,; 6186 noIncludePaths,; 6187 noGlobalUsingStd,; 6188 headersNames,; 6189 failOnWarnings,; 6190 printRootclingInvocation,; 6191 ofileName);; 6192 } else {; 6193 // Here ofilename is either """" or a directory: this is irrelevant.; 6194 returnValue = invokeManyRootCling(verbosityOption,; 6195 selectionFileName,; 6196 targetLibName,; 6197 multidict,; 6198 pcmsNames,; 6199 includes,; 6200 preprocDefines,; 6201 preprocUndefines,; 6202 warnings,; 6203 rootmapFileName,; 6204 rootmapLibName,; 6205 interpreteronly,; 6206 doSplit,; 6207 isCxxmodule,; 6208 writeEmptyRootPCM,; 6209 selSyntaxOnly,; 6210 noIncludePaths,; 6211 noGlobalUsingStd,; 6212 headersNames,; 6213 failOnWarnings,; 6214 printRootclingInvocation,; 6215 ofileName);; 6216 }; 6217 ; 6218 return returnValue;; 6219}; 6220 ; 6221 ; 6222////////////////////////////////////////////////////////////////////////////////; 6223 ; 6224extern ""C""; 6225int ROOT_rootcling_Driver(int argc, char **argv, const ROOT::Internal::RootCling::DriverConfig& config); 6226{; 6227 ; 6228 assert(!gDriverConfig && ""Driver configuration already set!"");; 6229 gDriverConfig = &config;; 6230 ; 6231 gBuildingROOT = config.fBuildingROOTStage1; // gets refined later; 6232 ; 6233 std::string exeName = ExtractFileName(GetExePath());; 6234#ifdef __APPLE__; 6235 // _dyld_get_image_name() on macOS11 and later sometimes returns ""rootcling"" for ""genreflex"".; 6236 // Fix that (while still initializing the binary path, needed for ROOTSYS) by updating the; 6237 // exeName to argv[0]:; 6238 exeName = ExtractFileName(argv[0]);; 6239#endif; 6240 ; 6241 // Select according to the name of the executable the procedure to follow:; 6242 // 1) RootCling; 6243 // 2) G",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:244551,Modifiability,config,config,244551,"n,; 6171 selectionFileName,; 6172 targetLibName,; 6173 multidict,; 6174 pcmsNames,; 6175 includes,; 6176 preprocDefines,; 6177 preprocUndefines,; 6178 warnings,; 6179 rootmapFileName,; 6180 rootmapLibName,; 6181 interpreteronly,; 6182 doSplit,; 6183 isCxxmodule,; 6184 writeEmptyRootPCM,; 6185 selSyntaxOnly,; 6186 noIncludePaths,; 6187 noGlobalUsingStd,; 6188 headersNames,; 6189 failOnWarnings,; 6190 printRootclingInvocation,; 6191 ofileName);; 6192 } else {; 6193 // Here ofilename is either """" or a directory: this is irrelevant.; 6194 returnValue = invokeManyRootCling(verbosityOption,; 6195 selectionFileName,; 6196 targetLibName,; 6197 multidict,; 6198 pcmsNames,; 6199 includes,; 6200 preprocDefines,; 6201 preprocUndefines,; 6202 warnings,; 6203 rootmapFileName,; 6204 rootmapLibName,; 6205 interpreteronly,; 6206 doSplit,; 6207 isCxxmodule,; 6208 writeEmptyRootPCM,; 6209 selSyntaxOnly,; 6210 noIncludePaths,; 6211 noGlobalUsingStd,; 6212 headersNames,; 6213 failOnWarnings,; 6214 printRootclingInvocation,; 6215 ofileName);; 6216 }; 6217 ; 6218 return returnValue;; 6219}; 6220 ; 6221 ; 6222////////////////////////////////////////////////////////////////////////////////; 6223 ; 6224extern ""C""; 6225int ROOT_rootcling_Driver(int argc, char **argv, const ROOT::Internal::RootCling::DriverConfig& config); 6226{; 6227 ; 6228 assert(!gDriverConfig && ""Driver configuration already set!"");; 6229 gDriverConfig = &config;; 6230 ; 6231 gBuildingROOT = config.fBuildingROOTStage1; // gets refined later; 6232 ; 6233 std::string exeName = ExtractFileName(GetExePath());; 6234#ifdef __APPLE__; 6235 // _dyld_get_image_name() on macOS11 and later sometimes returns ""rootcling"" for ""genreflex"".; 6236 // Fix that (while still initializing the binary path, needed for ROOTSYS) by updating the; 6237 // exeName to argv[0]:; 6238 exeName = ExtractFileName(argv[0]);; 6239#endif; 6240 ; 6241 // Select according to the name of the executable the procedure to follow:; 6242 // 1) RootCling; 6243 // 2) G",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:256113,Modifiability,variab,variables,256113,"h:36; ROOT::TModuleGenerator::WriteUmbrellaHeadervoid WriteUmbrellaHeader(std::ostream &out) constWrite a header file pulling in the content of this module through a series of #defined,...Definition TModuleGenerator.cxx:603; ROOT::TModuleGenerator::GetUmbrellaNameconst std::string & GetUmbrellaName() constDefinition TModuleGenerator.h:76; ROOT::TModuleGenerator::GetIncludePathsconst std::vector< std::string > & GetIncludePaths() constDefinition TModuleGenerator.h:87; ROOT::TModuleGenerator::WriteRegistrationSourcevoid WriteRegistrationSource(std::ostream &out, const std::string &fwdDeclnArgsToKeepString, const std::string &headersClassesMapString, const std::string &fwdDeclsString, const std::string &extraIncludes, bool hasCxxModule) constDefinition TModuleGenerator.cxx:399; ROOT::TModuleGenerator::GetHeadersconst std::vector< std::string > & GetHeaders() constDefinition TModuleGenerator.h:83; ROOT::TModuleGenerator::WriteContentHeadervoid WriteContentHeader(std::ostream &out) constWrite a header file describing the content of this module through a series of variables inside the na...Definition TModuleGenerator.cxx:543; ROOT::TModuleGenerator::GetErrorCountint GetErrorCount() constDefinition TModuleGenerator.h:72; ROOT::TModuleGenerator::GetModuleFileNameconst std::string & GetModuleFileName() constDefinition TModuleGenerator.h:65; ROOT::TModuleGenerator::WritePPUndefinesstd::ostream & WritePPUndefines(std::ostream &out) constWrite #ifdef FOO # undef FOO #endifDefinition TModuleGenerator.cxx:238; ROOT::TModuleGenerator::IsPCHbool IsPCH() constDefinition TModuleGenerator.h:52; ROOT::TModuleGenerator::ParseArgsvoid ParseArgs(const std::vector< std::string > &args)Parse -I -D -U headers.h SomethingLinkdef.h.Definition TModuleGenerator.cxx:180; ROOT::TModuleGenerator::GetContentNameconst std::string & GetContentName() constDefinition TModuleGenerator.h:79; ROOT::TModuleGenerator::WritePPDefinesstd::ostream & WritePPDefines(std::ostream &out) constWrite #ifndef FOO # def",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:302466,Modifiability,variab,variable,302466," rootcling_impl.cxx:3419; IsLinkdefFilebool IsLinkdefFile(const clang::PresumedLoc &PLoc)Definition rootcling_impl.cxx:467; WriteClassFunctionsvoid WriteClassFunctions(const clang::CXXRecordDecl *cl, std::ostream &dictStream, bool autoLoad=false)Write the code to set the class name and the initialization object.Definition rootcling_impl.cxx:1180; gOptExcludePathsstatic llvm::cl::list< std::string > gOptExcludePaths(""excludePath"", llvm::cl::ZeroOrMore, llvm::cl::desc(""Do not store the <path> in the dictionary.""), llvm::cl::cat(gRootclingOptions)); RecordDecl2Headersstd::list< std::string > RecordDecl2Headers(const clang::CXXRecordDecl &rcd, const cling::Interpreter &interp, std::set< const clang::CXXRecordDecl * > &visitedDecls)Extract the list of headers necessary for the Decl.Definition rootcling_impl.cxx:3086; EmitStreamerInfovoid EmitStreamerInfo(const char *normName)Definition rootcling_impl.cxx:168; gOptNoIncludePathsstatic llvm::cl::opt< bool > gOptNoIncludePaths(""noIncludePaths"", llvm::cl::desc(""Do not store include paths but rely on the env variable ROOT_INCLUDE_PATH.""), llvm::cl::cat(gRootclingOptions)); HasPathbool HasPath(const std::string &name)Check if file has a path.Definition rootcling_impl.cxx:2166; gOptLibListPrefixstatic llvm::cl::opt< std::string > gOptLibListPrefix(""lib-list-prefix"", llvm::cl::desc(""An ACLiC feature which exports the list of dependent libraries.""), llvm::cl::Hidden, llvm::cl::cat(gRootclingOptions)); gOptNoDictSelectionstatic llvm::cl::opt< bool > gOptNoDictSelection(""noDictSelection"", llvm::cl::Hidden, llvm::cl::desc(""Do not run the selection rules. Useful when in -onepcm mode.""), llvm::cl::cat(gRootclingOptions)); gOptDictionaryHeaderFilesstatic llvm::cl::list< std::string > gOptDictionaryHeaderFiles(llvm::cl::Positional, llvm::cl::ZeroOrMore, llvm::cl::desc(""<list of dictionary header files> <LinkDef file | selection xml file>""), llvm::cl::cat(gRootclingOptions)); CheckForUnsupportedClassesint CheckForUnsupportedClasses(const ",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:304815,Modifiability,config,config,304815,"ner &scan, const ROOT::TMetaUtils::RConstructorTypes &ctorTypes, bool isSplit, bool isGenreflex, bool isSelXML, bool writeEmptyRootPCM)Definition rootcling_impl.cxx:2652; gOptSystemModuleByproductsstatic llvm::cl::opt< bool > gOptSystemModuleByproducts(""mSystemByproducts"", llvm::cl::Hidden, llvm::cl::desc(""Allow implicit build of system modules.""), llvm::cl::cat(gRootclingOptions)); CheckClassDefbool CheckClassDef(const clang::RecordDecl &cl, const cling::Interpreter &interp)Return false if the class does not have ClassDef even-though it should.Definition rootcling_impl.cxx:801; NeedsSelectionbool NeedsSelection(const char *name)Definition rootcling_impl.cxx:3426; extractMultipleOptionsint extractMultipleOptions(std::vector< ROOT::option::Option > &options, int oIndex, std::vector< std::string > &values)Extract from options multiple values with the same option.Definition rootcling_impl.cxx:5527; rootcling_impl.h; ROOT_rootcling_Driverint ROOT_rootcling_Driver(int argc, char **argv, const ROOT::Internal::RootCling::DriverConfig &config)Definition rootcling_impl.cxx:6225; whatstatic const char * whatDefinition stlLoader.cc:5; ROOT::Internal::RootCling::DriverConfigDefinition rootcling_impl.h:18; ROOT::Internal::RootCling::DriverConfig::fTCling__GetInterpretercling::Interpreter *(* fTCling__GetInterpreter)()Definition rootcling_impl.h:26; ROOT::Internal::RootCling::DriverConfig::fBuildingROOTStage1bool fBuildingROOTStage1Definition rootcling_impl.h:19; ROOT::Internal::RootCling::DriverConfig::fCloseStreamerInfoROOTFilebool(* fCloseStreamerInfoROOTFile)(bool writeEmptyRootPCM)Definition rootcling_impl.h:31; ROOT::Internal::RootCling::DriverConfig::fAddEnumToROOTFilevoid(* fAddEnumToROOTFile)(const char *tdname)Definition rootcling_impl.h:30; ROOT::Internal::RootCling::DriverConfig::fInitializeStreamerInfoROOTFilevoid(* fInitializeStreamerInfoROOTFile)(const char *filename)Definition rootcling_impl.h:27; ROOT::Internal::RootCling::DriverConfig::fTROOT__GetIncludeDirconst ",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:3837,Performance,perform,performs,3837,"""; 93#include ""llvm/Support/Signals.h""; 94 ; 95#include ""RtypesCore.h""; 96#include ""TModuleGenerator.h""; 97#include ""TClassEdit.h""; 98#include ""TClingUtils.h""; 99#include ""RStl.h""; 100#include ""XMLReader.h""; 101#include ""LinkdefReader.h""; 102#include ""DictSelectionReader.h""; 103#include ""SelectionRules.h""; 104#include ""Scanner.h""; 105#include ""strlcpy.h""; 106 ; 107#include ""OptionParser.h""; 108 ; 109#ifdef WIN32; 110const std::string gLibraryExtension("".dll"");; 111#else; 112const std::string gLibraryExtension("".so""); // no dylib for the moment; 113#endif; 114const std::string gPathSeparator(ROOT::TMetaUtils::GetPathSeparator());; 115 ; 116#ifdef __APPLE__; 117#include <mach-o/dyld.h>; 118#endif; 119 ; 120#if defined(R__WIN32); 121#include ""cygpath.h""; 122#define strcasecmp _stricmp; 123#define strncasecmp _strnicmp; 124#else; 125#include <unistd.h>; 126#endif; 127 ; 128bool gBuildingROOT = false;; 129const ROOT::Internal::RootCling::DriverConfig* gDriverConfig = nullptr;; 130 ; 131#define rootclingStringify(s) rootclingStringifyx(s); 132#define rootclingStringifyx(s) #s; 133 ; 134// Maybe too ugly? let's see how it performs.; 135using HeadersDeclsMap_t = std::map<std::string, std::list<std::string>>;; 136 ; 137using namespace ROOT;; 138 ; 139using std::string, std::map, std::ifstream, std::ofstream, std::endl, std::ios, std::vector;; 140 ; 141namespace genreflex {; 142 bool verbose = false;; 143}; 144 ; 145////////////////////////////////////////////////////////////////////////////////; 146 ; 147static llvm::cl::OptionCategory gRootclingOptions(""rootcling common options"");; 148 ; 149 // FIXME: We should remove after removal of r flag.; 150static llvm::cl::opt<bool>; 151gOptIgnoreExistingDict(""r"",; 152 llvm::cl::desc(""Deprecated. Similar to -f but it ignores the dictionary generation. \; 153When -r is present rootcling becomes a tool to generate rootmaps (and capability files).""),; 154 llvm::cl::Hidden,; 155 llvm::cl::cat(gRootclingOptions));; 156 ; 157//////////////",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:10549,Performance,load,load,10549,"0 ""which are not pointers or arrays.\n"";; 291 ROOT::TMetaUtils::Error(""AnnotateFieldDecl"",; 292 msg, varName.c_str(), value.c_str());; 293 continue;; 294 }; 295 ; 296 ; 297 // These lines are here to use the root pcms. Indeed we need to annotate the AST; 298 // before persisting the ProtoClasses in the root pcms.; 299 // BEGIN ROOT PCMS; 300 if (name == propNames::comment) {; 301 decl.addAttr(clang::AnnotateAttr::CreateImplicit(C, value, nullptr, 0));; 302 }; 303 // END ROOT PCMS; 304 ; 305 if ((name == propNames::transient && value == ""true"") ||; 306 (name == propNames::persistent && value == ""false"")) { // special case; 307 userDefinedProperty = propNames::comment + propNames::separator + ""!"";; 308 // This next line is here to use the root pcms. Indeed we need to annotate the AST; 309 // before persisting the ProtoClasses in the root pcms.; 310 // BEGIN ROOT PCMS; 311 decl.addAttr(clang::AnnotateAttr::CreateImplicit(C, ""!"", nullptr, 0));; 312 // END ROOT PCMS; 313 // The rest of the lines are not changed to leave in place the system which; 314 // works with bulk header parsing on library load.; 315 } else {; 316 userDefinedProperty = name + propNames::separator + value;; 317 }; 318 ROOT::TMetaUtils::Info(nullptr, ""%s %s\n"", varName.c_str(), userDefinedProperty.c_str());; 319 decl.addAttr(clang::AnnotateAttr::CreateImplicit(C, userDefinedProperty, nullptr, 0));; 320 }; 321 }; 322 }; 323}; 324 ; 325////////////////////////////////////////////////////////////////////////////////; 326 ; 327void AnnotateDecl(clang::CXXRecordDecl &CXXRD,; 328 const RScanner::DeclsSelRulesMap_t &declSelRulesMap,; 329 cling::Interpreter &interpreter,; 330 bool isGenreflex); 331{; 332 // In order to store the meaningful for the IO comments we have to transform; 333 // the comment into annotation of the given decl.; 334 // This works only with comments in the headers, so no selection rules in an; 335 // xml file.; 336 ; 337 using namespace clang;; 338 SourceLocation commentSLoc;; 339 llvm::",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:21357,Performance,load,load,21357,"tTopLevelModule();; 580 need = ""lib"" + M->Name + gLibraryExtension;; 581 } else {; 582 std::string qual_name;; 583 RScanner::GetDeclQualName(recordDecl, qual_name);; 584 ; 585 need = gAutoloads[qual_name];; 586 }; 587 ; 588 if (need.length() && gLibsNeeded.find(need) == string::npos) {; 589 gLibsNeeded += "" "" + need;; 590 }; 591}; 592 ; 593////////////////////////////////////////////////////////////////////////////////; 594 ; 595void CheckClassNameForRootMap(const std::string &classname, map<string, string> &autoloads); 596{; 597 if (classname.find(':') == std::string::npos) return;; 598 ; 599 // We have a namespace and we have to check it first; 600 int slen = classname.size();; 601 for (int k = 0; k < slen; ++k) {; 602 if (classname[k] == ':') {; 603 if (k + 1 >= slen || classname[k + 1] != ':') {; 604 // we expected another ':'; 605 break;; 606 }; 607 if (k) {; 608 string base = classname.substr(0, k);; 609 if (base == ""std"") {; 610 // std is not declared but is also ignored by CINT!; 611 break;; 612 } else {; 613 autoloads[base] = """"; // We never load namespaces on their own.; 614 }; 615 ++k;; 616 }; 617 } else if (classname[k] == '<') {; 618 // We do not want to look at the namespace inside the template parameters!; 619 break;; 620 }; 621 }; 622}; 623 ; 624////////////////////////////////////////////////////////////////////////////////; 625/// Parse the rootmap and add entries to the autoload map; 626 ; 627void ParseRootMapFile(ifstream &file, map<string, string> &autoloads); 628{; 629 std::string classname;; 630 std::string line;; 631 while (file >> line) {; 632 ; 633 if (line.find(""Library."") != 0) continue;; 634 ; 635 int pos = line.find("":"", 8);; 636 classname = line.substr(8, pos - 8);; 637 ; 638 ROOT::TMetaUtils::ReplaceAll(classname, ""@@"", ""::"");; 639 ROOT::TMetaUtils::ReplaceAll(classname, ""-"", "" "");; 640 ; 641 getline(file, line, '\n');; 642 while (line[0] == ' ') line.replace(0, 1, """");; 643 ; 644 CheckClassNameForRootMap(classname, autoloads);; 645 ; ",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:23747,Performance,load,loaded,23747,"> &autoloads); 659{; 660 std::string keyname;; 661 std::string libs;; 662 std::string line;; 663 ; 664 // For ""class "", ""namespace "" and ""typedef "" respectively; 665 const std::unordered_map<char, unsigned int> keyLenMap = {{'c', 6}, {'n', 10}, {'t', 8}};; 666 ; 667 while (getline(file, line, '\n')) {; 668 if (line == ""{ decls }"") {; 669 while (getline(file, line, '\n')) {; 670 if (line[0] == '[') break;; 671 }; 672 }; 673 const char firstChar = line[0];; 674 if (firstChar == '[') {; 675 // new section; 676 libs = line.substr(1, line.find(']') - 1);; 677 while (libs[0] == ' ') libs.replace(0, 1, """");; 678 } else if (0 != keyLenMap.count(firstChar)) {; 679 unsigned int keyLen = keyLenMap.at(firstChar);; 680 keyname = line.substr(keyLen, line.length() - keyLen);; 681 CheckClassNameForRootMap(keyname, autoloads);; 682 autoloads[keyname] = libs;; 683 }; 684 }; 685 ; 686}; 687 ; 688////////////////////////////////////////////////////////////////////////////////; 689/// Fill the map of libraries to be loaded in presence of a class; 690/// Transparently support the old and new rootmap file format; 691 ; 692void LoadLibraryMap(const std::string &fileListName, map<string, string> &autoloads); 693{; 694 std::ifstream filelist(fileListName.c_str());; 695 ; 696 std::string filename;; 697 std::string line;; 698 ; 699 while (filelist >> filename) {; 700 ; 701 if (llvm::sys::fs::is_directory(filename)) continue;; 702 ; 703 ifstream file(filename.c_str());; 704 ; 705 // Check which format is this; 706 file >> line;; 707 bool new_format = (line[0] == '[' || line[0] == '{') ;; 708 file.clear();; 709 file.seekg(0, std::ios::beg);; 710 ; 711 // Now act; 712 if (new_format) {; 713 ParseRootMapFileNewFormat(file, autoloads);; 714 } else {; 715 ParseRootMapFile(file, autoloads);; 716 }; 717 ; 718 file.close();; 719 ; 720 } // end loop on files; 721 filelist.close();; 722}; 723 ; 724////////////////////////////////////////////////////////////////////////////////; 725/// Check if the specif",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:46440,Performance,load,load,46440,"dictionary is split; 1228 if (autoLoad); 1229 dictStream << "" gInterpreter->AutoLoad(\"""" << fullname << ""\"");\n"";; 1230 dictStream << "" fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::"" << fullname; 1231 << ""*)nullptr)->GetClass();"" << std::endl; 1232 << "" return fgIsA;\n""; 1233 << ""}"" << std::endl << std::endl; 1234 ; 1235 << ""//_______________________________________""; 1236 << ""_______________________________________"" << std::endl;; 1237 if (add_template_keyword) dictStream << ""template <> "";; 1238 dictStream << ""TClass *"" << clsname << ""::Class()"" << std::endl << ""{"" << std::endl;; 1239 if (autoLoad) {; 1240 dictStream << "" Dictionary();\n"";; 1241 } else {; 1242 dictStream << "" if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::"";; 1243 dictStream << fullname << ""*)nullptr)->GetClass(); }"" << std::endl;; 1244 }; 1245 dictStream << "" return fgIsA;"" << std::endl; 1246 << ""}"" << std::endl << std::endl;; 1247 ; 1248 while (enclSpaceNesting) {; 1249 dictStream << ""} // namespace "" << nsname << std::endl;; 1250 --enclSpaceNesting;; 1251 }; 1252}; 1253 ; 1254////////////////////////////////////////////////////////////////////////////////; 1255/// Write the code to initialize the namespace name and the initialization object.; 1256 ; 1257void WriteNamespaceInit(const clang::NamespaceDecl *cl,; 1258 cling::Interpreter &interp,; 1259 std::ostream &dictStream); 1260{; 1261 if (cl->isAnonymousNamespace()) {; 1262 // Don't write a GenerateInitInstance for the anonymous namespaces.; 1263 return;; 1264 }; 1265 ; 1266 // coverity[fun_call_w_exception] - that's just fine.; 1267 string classname = ROOT::TMetaUtils::GetQualifiedName(*cl).c_str();; 1268 string mappedname;; 1269 TMetaUtils::GetCppName(mappedname, classname.c_str());; 1270 ; 1271 int nesting = 0;; 1272 // We should probably unwind the namespace to properly nest it.; 1273 if (classname != ""ROOT"") {; 1274 nesting = ROOT::TMetaUtils::WriteNamespaceHeader(dictStream,",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:49646,Performance,optimiz,optimized,49646," = ROOT::TMetaUtils::GetFileName(*cl, interp);; 1308 for (unsigned int i = 0; i < filename.length(); i++) {; 1309 if (filename[i] == '\\') filename[i] = '/';; 1310 }; 1311 dictStream << ""\"""" << filename << ""\"", "" << ROOT::TMetaUtils::GetLineNumber(cl) << "","" << std::endl; 1312 << "" ::ROOT::Internal::DefineBehavior((void*)nullptr,(void*)nullptr),"" << std::endl; 1313 << "" "";; 1314 ; 1315 if (Namespace__HasMethod(cl, ""Dictionary"", interp)) {; 1316 dictStream << ""&::"" << classname.c_str() << ""::Dictionary, "";; 1317 } else {; 1318 dictStream << ""&"" << mappedname.c_str() << ""_Dictionary, "";; 1319 }; 1320 ; 1321 dictStream << 0 << "");"" << std::endl; 1322 ; 1323 << "" return &instance;"" << std::endl; 1324 << "" }"" << std::endl; 1325 << "" // Insure that the inline function is _not_ optimized away by the compiler\n""; 1326 << "" ::ROOT::TGenericClassInfo *(*_R__UNIQUE_DICT_(InitFunctionKeeper))() = &GenerateInitInstance; "" << std::endl; 1327 << "" // Static variable to force the class initialization"" << std::endl; 1328 // must be one long line otherwise R__UseDummy does not work; 1329 << "" static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstance();""; 1330 << "" R__UseDummy(_R__UNIQUE_DICT_(Init));"" << std::endl;; 1331 ; 1332 if (!Namespace__HasMethod(cl, ""Dictionary"", interp)) {; 1333 dictStream << std::endl << "" // Dictionary for non-ClassDef classes"" << std::endl; 1334 << "" static TClass *"" << mappedname.c_str() << ""_Dictionary() {"" << std::endl; 1335 << "" return GenerateInitInstance()->GetClass();"" << std::endl; 1336 << "" }"" << std::endl << std::endl;; 1337 }; 1338 ; 1339 dictStream << "" }"" << std::endl;; 1340 while (nesting--) {; 1341 dictStream << ""}"" << std::endl;; 1342 }; 1343 dictStream << std::endl;; 1344}; 1345 ; 1346////////////////////////////////////////////////////////////////////////////////; 1347/// GrabIndex returns a static string (so use it or copy it immediately, do not; 1348/// call GrabIndex twice in the same expression) containing the si",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:111063,Performance,perform,performed,111063,"ontinue;; 2762 }; 2763 ; 2764 const clang::CXXRecordDecl *CRD = llvm::dyn_cast<clang::CXXRecordDecl>(selClass.GetRecordDecl());; 2765 ; 2766 if (!ROOT::TMetaUtils::IsSTLContainer(selClass)) {; 2767 if (!gOptIgnoreExistingDict) {; 2768 ROOT::TMetaUtils::WriteClassInit(dictStream, selClass, CRD, interp, normCtxt, ctorTypes,; 2769 needsCollectionProxy);; 2770 }; 2771 EmitStreamerInfo(selClass.GetNormalizedName());; 2772 }; 2773 }; 2774 // Loop to write all the ClassCode; 2775 if (!gOptIgnoreExistingDict) {; 2776 for (auto const &selClass : scan.fSelectedClasses) {; 2777 // The ""isGenreflex"" parameter allows the distinction between; 2778 // genreflex and rootcling only for the treatment of collections which; 2779 // are data members. To preserve the behaviour of the original; 2780 // genreflex and rootcling tools, if the selection is performed with; 2781 // genreflex, data members with collection type do not trigger the; 2782 // selection of the collection type; 2783 ROOT::TMetaUtils::WriteClassCode(&CallWriteStreamer,; 2784 selClass,; 2785 interp,; 2786 normCtxt,; 2787 dictStream,; 2788 ctorTypes,; 2789 isGenreflex);; 2790 }; 2791 ; 2792 // Loop on the registered collections internally; 2793 // coverity[fun_call_w_exception] - that's just fine.; 2794 ROOT::Internal::RStl::Instance().WriteClassInit(dictStream, interp, normCtxt, ctorTypes, needsCollectionProxy,; 2795 EmitStreamerInfo);; 2796 }; 2797 ; 2798 if (!gDriverConfig->fBuildingROOTStage1) {; 2799 EmitTypedefs(scan.fSelectedTypedefs);; 2800 EmitEnums(scan.fSelectedEnums);; 2801 // Make up for skipping RegisterModule, now that dictionary parsing; 2802 // is done and these headers cannot be selected anymore.; 2803 int finRetCode = FinalizeStreamerInfoWriting(interp, writeEmptyRootPCM);; 2804 if (finRetCode != 0) return finRetCode;; 2805 }; 2806 ; 2807 return 0;; 2808}; 2809 ; 2810////////////////////////////////////////////////////////////////////////////////; 2811 ; 2812void CreateDictHeader(std::ostream &dictStrea",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:157716,Performance,load,loaded,157716,"re needed by the ModuleGenerator but are; 3879/// not in the given module will be inserted into the MissingHeader variable.; 3880/// Returns true iff the PCH was successfully generated.; 3881static bool ModuleContainsHeaders(TModuleGenerator &modGen, clang::HeaderSearch &headerSearch,; 3882 clang::Module *module, std::vector<std::array<std::string, 2>> &missingHeaders); 3883{; 3884 // Now we collect all header files from the previously collected modules.; 3885 std::vector<clang::Module::Header> moduleHeaders;; 3886 ROOT::TMetaUtils::foreachHeaderInModule(*module,; 3887 [&moduleHeaders](const clang::Module::Header &h) { moduleHeaders.push_back(h); });; 3888 ; 3889 bool foundAllHeaders = true;; 3890 ; 3891 auto isHeaderInModule = [&moduleHeaders](const std::string &header) {; 3892 for (const clang::Module::Header &moduleHeader : moduleHeaders); 3893 if (header == moduleHeader.NameAsWritten); 3894 return true;; 3895 return false;; 3896 };; 3897 ; 3898 // Go through the list of headers that are required by the ModuleGenerator; 3899 // and check for each header if it's in one of the modules we loaded.; 3900 // If not, make sure we fail at the end and mark the header as missing.; 3901 for (const std::string &header : modGen.GetHeaders()) {; 3902 if (isHeaderInModule(header)); 3903 continue;; 3904 ; 3905 clang::ModuleMap::KnownHeader SuggestedModule;; 3906 clang::ConstSearchDirIterator *CurDir = nullptr;; 3907 if (auto FE = headerSearch.LookupFile(; 3908 header, clang::SourceLocation(),; 3909 /*isAngled*/ false,; 3910 /*FromDir*/ 0, CurDir,; 3911 clang::ArrayRef<std::pair<clang::OptionalFileEntryRef, clang::DirectoryEntryRef>>(),; 3912 /*SearchPath*/ 0,; 3913 /*RelativePath*/ 0,; 3914 /*RequestingModule*/ 0, &SuggestedModule,; 3915 /*IsMapped*/ 0,; 3916 /*IsFrameworkFound*/ nullptr,; 3917 /*SkipCache*/ false,; 3918 /*BuildSystemModule*/ false,; 3919 /*OpenFile*/ false,; 3920 /*CacheFail*/ false)) {; 3921 if (auto OtherModule = SuggestedModule.getModule()) {; 3922 std::stri",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:159789,Performance,load,loadTopLevelSystemModules,159789,"ers that are actually in by-products:; 3930 if (std::find(gOptModuleByproducts.begin(), gOptModuleByproducts.end(), OtherModuleName); 3931 != gOptModuleByproducts.end()); 3932 continue;; 3933 ; 3934 missingHeaders.push_back({header, OtherModuleName});; 3935 }; 3936 } else {; 3937 missingHeaders.push_back({header, {}});; 3938 }; 3939 foundAllHeaders = false;; 3940 }; 3941 return foundAllHeaders;; 3942}; 3943 ; 3944////////////////////////////////////////////////////////////////////////////////; 3945/// Check moduleName validity from modulemap. Check if this module is defined or not.; 3946static bool CheckModuleValid(TModuleGenerator &modGen, const std::string &resourceDir, cling::Interpreter &interpreter,; 3947 llvm::StringRef LinkdefPath, const std::string &moduleName); 3948{; 3949 clang::CompilerInstance *CI = interpreter.getCI();; 3950 clang::HeaderSearch &headerSearch = CI->getPreprocessor().getHeaderSearchInfo();; 3951 headerSearch.loadTopLevelSystemModules();; 3952 ; 3953 // Actually lookup the module on the computed module name.; 3954 clang::Module *module = headerSearch.lookupModule(llvm::StringRef(moduleName));; 3955 ; 3956 // Inform the user and abort if we can't find a module with a given name.; 3957 if (!module) {; 3958 ROOT::TMetaUtils::Error(""CheckModuleValid"", ""Couldn't find module with name '%s' in modulemap!\n"",; 3959 moduleName.c_str());; 3960 return false;; 3961 }; 3962 ; 3963 // Check if the loaded module covers all headers that were specified; 3964 // by the user on the command line. This is an integrity check to; 3965 // ensure that our used module map is not containing extraneous headers.; 3966 std::vector<std::array<std::string, 2>> missingHdrMod;; 3967 if (!ModuleContainsHeaders(modGen, headerSearch, module, missingHdrMod)) {; 3968 // FIXME: Upgrade this to an error once modules are stable.; 3969 std::stringstream msgStream;; 3970 msgStream << ""after creating module \"""" << module->Name << ""\"" "";; 3971 if (!module->PresumedModuleMapFile.empty(",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:160273,Performance,load,loaded,160273,"//////////////////////////////////////////////////; 3945/// Check moduleName validity from modulemap. Check if this module is defined or not.; 3946static bool CheckModuleValid(TModuleGenerator &modGen, const std::string &resourceDir, cling::Interpreter &interpreter,; 3947 llvm::StringRef LinkdefPath, const std::string &moduleName); 3948{; 3949 clang::CompilerInstance *CI = interpreter.getCI();; 3950 clang::HeaderSearch &headerSearch = CI->getPreprocessor().getHeaderSearchInfo();; 3951 headerSearch.loadTopLevelSystemModules();; 3952 ; 3953 // Actually lookup the module on the computed module name.; 3954 clang::Module *module = headerSearch.lookupModule(llvm::StringRef(moduleName));; 3955 ; 3956 // Inform the user and abort if we can't find a module with a given name.; 3957 if (!module) {; 3958 ROOT::TMetaUtils::Error(""CheckModuleValid"", ""Couldn't find module with name '%s' in modulemap!\n"",; 3959 moduleName.c_str());; 3960 return false;; 3961 }; 3962 ; 3963 // Check if the loaded module covers all headers that were specified; 3964 // by the user on the command line. This is an integrity check to; 3965 // ensure that our used module map is not containing extraneous headers.; 3966 std::vector<std::array<std::string, 2>> missingHdrMod;; 3967 if (!ModuleContainsHeaders(modGen, headerSearch, module, missingHdrMod)) {; 3968 // FIXME: Upgrade this to an error once modules are stable.; 3969 std::stringstream msgStream;; 3970 msgStream << ""after creating module \"""" << module->Name << ""\"" "";; 3971 if (!module->PresumedModuleMapFile.empty()); 3972 msgStream << ""using modulemap \"""" << module->PresumedModuleMapFile << ""\"" "";; 3973 msgStream << ""the following headers are not part of that module:\n"";; 3974 for (auto &H : missingHdrMod) {; 3975 msgStream << "" "" << H[0];; 3976 if (!H[1].empty()); 3977 msgStream << "" (already part of module \"""" << H[1] << ""\"")"";; 3978 msgStream << ""\n"";; 3979 }; 3980 std::string warningMessage = msgStream.str();; 3981 ; 3982 bool maybeUmbrella = modGen",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:178406,Performance,cache,cache-path,178406,").str().c_str());; 4348 remove((moduleCachePath + llvm::sys::path::get_separator() + ""boost.pcm"").str().c_str());; 4349 remove((moduleCachePath + llvm::sys::path::get_separator() + ""tinyxml2.pcm"").str().c_str());; 4350 remove((moduleCachePath + llvm::sys::path::get_separator() + ""ROOT_Config.pcm"").str().c_str());; 4351 remove((moduleCachePath + llvm::sys::path::get_separator() + ""ROOT_Rtypes.pcm"").str().c_str());; 4352 remove((moduleCachePath + llvm::sys::path::get_separator() + ""ROOT_Foundation_C.pcm"").str().c_str());; 4353 remove((moduleCachePath + llvm::sys::path::get_separator() + ""ROOT_Foundation_Stage1_NoRTTI.pcm"").str().c_str());; 4354 } else if (moduleName == ""MathCore"") {; 4355 remove((moduleCachePath + llvm::sys::path::get_separator() + ""Vc.pcm"").str().c_str());; 4356 }; 4357 ; 4358 // Set the C++ modules output directory to the directory where we generate; 4359 // the shared library.; 4360 clingArgsInterpreter.push_back(""-fmodules-cache-path="" + moduleCachePath);; 4361 }; 4362 ; 4363 if (gOptVerboseLevel == v4); 4364 clingArgsInterpreter.push_back(""-v"");; 4365 ; 4366 // Convert arguments to a C array and check if they are sane; 4367 std::vector<const char *> clingArgsC;; 4368 for (auto const &clingArg : clingArgsInterpreter) {; 4369 if (!IsCorrectClingArgument(clingArg)){; 4370 std::cerr << ""Argument \""""<< clingArg << ""\"" is not a supported cling argument. ""; 4371 << ""This could be mistyped rootcling argument. Please check the commandline.\n"";; 4372 return 1;; 4373 }; 4374 clingArgsC.push_back(clingArg.c_str());; 4375 }; 4376 ; 4377 ; 4378 std::unique_ptr<cling::Interpreter> owningInterpPtr;; 4379 cling::Interpreter* interpPtr = nullptr;; 4380 ; 4381 std::list<std::string> filesIncludedByLinkdef;; 4382 if (gDriverConfig->fBuildingROOTStage1) {; 4383#ifdef R__FAST_MATH; 4384 // Same setting as in TCling.cxx.; 4385 clingArgsC.push_back(""-ffast-math"");; 4386#endif; 4387 ; 4388 owningInterpPtr.reset(new cling::Interpreter(clingArgsC.size(), &clingArgsC[0],; 4",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:183226,Performance,load,loadModule,183226,"Opts; 4442 = interp.getCI()->getASTContext().getLangOpts();; 4443#define LANGOPT(Name, Bits, Default, Description) \; 4444 ROOT::TMetaUtils::Info(nullptr, ""%s = %d // %s\n"", #Name, (int)LangOpts.Name, Description);; 4445#define ENUM_LANGOPT(Name, Type, Bits, Default, Description); 4446#include ""clang/Basic/LangOptions.def""; 4447 ROOT::TMetaUtils::Info(nullptr, ""==== END interpreter configuration ====\n\n"");; 4448 }; 4449 ; 4450 interp.getOptions().ErrorOut = true;; 4451 interp.enableRawInput(true);; 4452 ; 4453 if (gOptCxxModule) {; 4454 for (llvm::StringRef DepMod : gOptModuleDependencies) {; 4455 if (DepMod.endswith(""_rdict.pcm"")) {; 4456 ROOT::TMetaUtils::Warning(nullptr, ""'%s' value is deprecated. Please use [<fullpath>]%s.pcm\n"",; 4457 DepMod.data(),; 4458 GetModuleNameFromRdictName(DepMod).str().data());; 4459 }; 4460 DepMod = GetModuleNameFromRdictName(DepMod);; 4461 // We might deserialize.; 4462 cling::Interpreter::PushTransactionRAII RAII(&interp);; 4463 if (!interp.loadModule(DepMod.str(), /*complain*/false)) {; 4464 ROOT::TMetaUtils::Error(nullptr, ""Module '%s' failed to load.\n"",; 4465 DepMod.data());; 4466 }; 4467 }; 4468 }; 4469 ; 4470 if (!isGenreflex) { // rootcling; 4471 // ROOTCINT uses to define a few header implicitly, we need to do it explicitly.; 4472 if (interp.declare(""#include <assert.h>\n""; 4473 ""#include \""Rtypes.h\""\n""; 4474 ""#include \""TObject.h\"""") != cling::Interpreter::kSuccess; 4475 ) {; 4476 // There was an error.; 4477 ROOT::TMetaUtils::Error(nullptr, ""Error loading the default rootcling header files.\n"");; 4478 return 1;; 4479 }; 4480 }; 4481 ; 4482 if (interp.declare(""#include <string>\n"" // For the list of 'opaque' typedef to also include string.; 4483 ""#include <RtypesCore.h>\n"" // For initializing TNormalizedCtxt.; 4484 ""namespace std {} using namespace std;"") != cling::Interpreter::kSuccess) {; 4485 ROOT::TMetaUtils::Error(nullptr, ""Error loading the default header files.\n"");; 4486 return 1;; 4487 }; 4488 ; 4489 // We are n",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:183335,Performance,load,load,183335,");; 4443#define LANGOPT(Name, Bits, Default, Description) \; 4444 ROOT::TMetaUtils::Info(nullptr, ""%s = %d // %s\n"", #Name, (int)LangOpts.Name, Description);; 4445#define ENUM_LANGOPT(Name, Type, Bits, Default, Description); 4446#include ""clang/Basic/LangOptions.def""; 4447 ROOT::TMetaUtils::Info(nullptr, ""==== END interpreter configuration ====\n\n"");; 4448 }; 4449 ; 4450 interp.getOptions().ErrorOut = true;; 4451 interp.enableRawInput(true);; 4452 ; 4453 if (gOptCxxModule) {; 4454 for (llvm::StringRef DepMod : gOptModuleDependencies) {; 4455 if (DepMod.endswith(""_rdict.pcm"")) {; 4456 ROOT::TMetaUtils::Warning(nullptr, ""'%s' value is deprecated. Please use [<fullpath>]%s.pcm\n"",; 4457 DepMod.data(),; 4458 GetModuleNameFromRdictName(DepMod).str().data());; 4459 }; 4460 DepMod = GetModuleNameFromRdictName(DepMod);; 4461 // We might deserialize.; 4462 cling::Interpreter::PushTransactionRAII RAII(&interp);; 4463 if (!interp.loadModule(DepMod.str(), /*complain*/false)) {; 4464 ROOT::TMetaUtils::Error(nullptr, ""Module '%s' failed to load.\n"",; 4465 DepMod.data());; 4466 }; 4467 }; 4468 }; 4469 ; 4470 if (!isGenreflex) { // rootcling; 4471 // ROOTCINT uses to define a few header implicitly, we need to do it explicitly.; 4472 if (interp.declare(""#include <assert.h>\n""; 4473 ""#include \""Rtypes.h\""\n""; 4474 ""#include \""TObject.h\"""") != cling::Interpreter::kSuccess; 4475 ) {; 4476 // There was an error.; 4477 ROOT::TMetaUtils::Error(nullptr, ""Error loading the default rootcling header files.\n"");; 4478 return 1;; 4479 }; 4480 }; 4481 ; 4482 if (interp.declare(""#include <string>\n"" // For the list of 'opaque' typedef to also include string.; 4483 ""#include <RtypesCore.h>\n"" // For initializing TNormalizedCtxt.; 4484 ""namespace std {} using namespace std;"") != cling::Interpreter::kSuccess) {; 4485 ROOT::TMetaUtils::Error(nullptr, ""Error loading the default header files.\n"");; 4486 return 1;; 4487 }; 4488 ; 4489 // We are now ready (enough is loaded) to init the list of opaque ty",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:183754,Performance,load,loading,183754,"if (gOptCxxModule) {; 4454 for (llvm::StringRef DepMod : gOptModuleDependencies) {; 4455 if (DepMod.endswith(""_rdict.pcm"")) {; 4456 ROOT::TMetaUtils::Warning(nullptr, ""'%s' value is deprecated. Please use [<fullpath>]%s.pcm\n"",; 4457 DepMod.data(),; 4458 GetModuleNameFromRdictName(DepMod).str().data());; 4459 }; 4460 DepMod = GetModuleNameFromRdictName(DepMod);; 4461 // We might deserialize.; 4462 cling::Interpreter::PushTransactionRAII RAII(&interp);; 4463 if (!interp.loadModule(DepMod.str(), /*complain*/false)) {; 4464 ROOT::TMetaUtils::Error(nullptr, ""Module '%s' failed to load.\n"",; 4465 DepMod.data());; 4466 }; 4467 }; 4468 }; 4469 ; 4470 if (!isGenreflex) { // rootcling; 4471 // ROOTCINT uses to define a few header implicitly, we need to do it explicitly.; 4472 if (interp.declare(""#include <assert.h>\n""; 4473 ""#include \""Rtypes.h\""\n""; 4474 ""#include \""TObject.h\"""") != cling::Interpreter::kSuccess; 4475 ) {; 4476 // There was an error.; 4477 ROOT::TMetaUtils::Error(nullptr, ""Error loading the default rootcling header files.\n"");; 4478 return 1;; 4479 }; 4480 }; 4481 ; 4482 if (interp.declare(""#include <string>\n"" // For the list of 'opaque' typedef to also include string.; 4483 ""#include <RtypesCore.h>\n"" // For initializing TNormalizedCtxt.; 4484 ""namespace std {} using namespace std;"") != cling::Interpreter::kSuccess) {; 4485 ROOT::TMetaUtils::Error(nullptr, ""Error loading the default header files.\n"");; 4486 return 1;; 4487 }; 4488 ; 4489 // We are now ready (enough is loaded) to init the list of opaque typedefs.; 4490 ROOT::TMetaUtils::TNormalizedCtxt normCtxt(interp.getLookupHelper());; 4491 ROOT::TMetaUtils::TClingLookupHelper helper(interp, normCtxt, nullptr, nullptr, nullptr);; 4492 TClassEdit::Init(&helper);; 4493 ; 4494 // flags used only for the pragma parser:; 4495 clingArgs.push_back(""-D__CINT__"");; 4496 clingArgs.push_back(""-D__MAKECINT__"");; 4497 ; 4498 AddPlatformDefines(clingArgs);; 4499 ; 4500 std::string currentDirectory = ROOT::FoundationUt",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:184148,Performance,load,loading,184148,"ctName(DepMod);; 4461 // We might deserialize.; 4462 cling::Interpreter::PushTransactionRAII RAII(&interp);; 4463 if (!interp.loadModule(DepMod.str(), /*complain*/false)) {; 4464 ROOT::TMetaUtils::Error(nullptr, ""Module '%s' failed to load.\n"",; 4465 DepMod.data());; 4466 }; 4467 }; 4468 }; 4469 ; 4470 if (!isGenreflex) { // rootcling; 4471 // ROOTCINT uses to define a few header implicitly, we need to do it explicitly.; 4472 if (interp.declare(""#include <assert.h>\n""; 4473 ""#include \""Rtypes.h\""\n""; 4474 ""#include \""TObject.h\"""") != cling::Interpreter::kSuccess; 4475 ) {; 4476 // There was an error.; 4477 ROOT::TMetaUtils::Error(nullptr, ""Error loading the default rootcling header files.\n"");; 4478 return 1;; 4479 }; 4480 }; 4481 ; 4482 if (interp.declare(""#include <string>\n"" // For the list of 'opaque' typedef to also include string.; 4483 ""#include <RtypesCore.h>\n"" // For initializing TNormalizedCtxt.; 4484 ""namespace std {} using namespace std;"") != cling::Interpreter::kSuccess) {; 4485 ROOT::TMetaUtils::Error(nullptr, ""Error loading the default header files.\n"");; 4486 return 1;; 4487 }; 4488 ; 4489 // We are now ready (enough is loaded) to init the list of opaque typedefs.; 4490 ROOT::TMetaUtils::TNormalizedCtxt normCtxt(interp.getLookupHelper());; 4491 ROOT::TMetaUtils::TClingLookupHelper helper(interp, normCtxt, nullptr, nullptr, nullptr);; 4492 TClassEdit::Init(&helper);; 4493 ; 4494 // flags used only for the pragma parser:; 4495 clingArgs.push_back(""-D__CINT__"");; 4496 clingArgs.push_back(""-D__MAKECINT__"");; 4497 ; 4498 AddPlatformDefines(clingArgs);; 4499 ; 4500 std::string currentDirectory = ROOT::FoundationUtils::GetCurrentDir();; 4501 ; 4502 std::string interpPragmaSource;; 4503 std::string includeForSource;; 4504 std::string interpreterDeclarations;; 4505 std::string linkdef;; 4506 ; 4507 for (size_t i = 0, e = gOptDictionaryHeaderFiles.size(); i < e; ++i) {; 4508 const std::string& optHeaderFileName = gOptDictionaryHeaderFiles[i];; 4509 bool isSel",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:184255,Performance,load,loaded,184255,"Mod.str(), /*complain*/false)) {; 4464 ROOT::TMetaUtils::Error(nullptr, ""Module '%s' failed to load.\n"",; 4465 DepMod.data());; 4466 }; 4467 }; 4468 }; 4469 ; 4470 if (!isGenreflex) { // rootcling; 4471 // ROOTCINT uses to define a few header implicitly, we need to do it explicitly.; 4472 if (interp.declare(""#include <assert.h>\n""; 4473 ""#include \""Rtypes.h\""\n""; 4474 ""#include \""TObject.h\"""") != cling::Interpreter::kSuccess; 4475 ) {; 4476 // There was an error.; 4477 ROOT::TMetaUtils::Error(nullptr, ""Error loading the default rootcling header files.\n"");; 4478 return 1;; 4479 }; 4480 }; 4481 ; 4482 if (interp.declare(""#include <string>\n"" // For the list of 'opaque' typedef to also include string.; 4483 ""#include <RtypesCore.h>\n"" // For initializing TNormalizedCtxt.; 4484 ""namespace std {} using namespace std;"") != cling::Interpreter::kSuccess) {; 4485 ROOT::TMetaUtils::Error(nullptr, ""Error loading the default header files.\n"");; 4486 return 1;; 4487 }; 4488 ; 4489 // We are now ready (enough is loaded) to init the list of opaque typedefs.; 4490 ROOT::TMetaUtils::TNormalizedCtxt normCtxt(interp.getLookupHelper());; 4491 ROOT::TMetaUtils::TClingLookupHelper helper(interp, normCtxt, nullptr, nullptr, nullptr);; 4492 TClassEdit::Init(&helper);; 4493 ; 4494 // flags used only for the pragma parser:; 4495 clingArgs.push_back(""-D__CINT__"");; 4496 clingArgs.push_back(""-D__MAKECINT__"");; 4497 ; 4498 AddPlatformDefines(clingArgs);; 4499 ; 4500 std::string currentDirectory = ROOT::FoundationUtils::GetCurrentDir();; 4501 ; 4502 std::string interpPragmaSource;; 4503 std::string includeForSource;; 4504 std::string interpreterDeclarations;; 4505 std::string linkdef;; 4506 ; 4507 for (size_t i = 0, e = gOptDictionaryHeaderFiles.size(); i < e; ++i) {; 4508 const std::string& optHeaderFileName = gOptDictionaryHeaderFiles[i];; 4509 bool isSelectionFile = IsSelectionFile(optHeaderFileName.c_str());; 4510 ; 4511 if (isSelectionFile) {; 4512 if (i == e - 1) {; 4513 linkdef = optHead",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:195858,Performance,load,loading,195858,"T::TMetaUtils::Info(nullptr, ""Using linkdef file: %s\n"", linkdefFilename.c_str());; 4751 file.close();; 4752 } else {; 4753 ROOT::TMetaUtils::Error(nullptr, ""Linkdef file %s couldn't be opened!\n"", linkdefFilename.c_str());; 4754 }; 4755 ; 4756 selectionRules.SetSelectionFileType(SelectionRules::kLinkdefFile);; 4757 }; 4758 // If there is no linkdef file, we added the 'default' #pragma to; 4759 // interpPragmaSource and we still need to process it.; 4760 ; 4761 LinkdefReader ldefr(interp, constructorTypes);; 4762 clingArgs.push_back(""-Ietc/cling/cint""); // For multiset and multimap; 4763 ; 4764 if (!ldefr.Parse(selectionRules, interpPragmaSource, clingArgs,; 4765 llvmResourceDir.c_str())) {; 4766 ROOT::TMetaUtils::Error(nullptr, ""Parsing #pragma failed %s\n"", linkdefFilename.c_str());; 4767 rootclingRetCode += 1;; 4768 } else {; 4769 ROOT::TMetaUtils::Info(nullptr, ""#pragma successfully parsed.\n"");; 4770 }; 4771 ; 4772 if (!ldefr.LoadIncludes(extraIncludes)) {; 4773 ROOT::TMetaUtils::Error(nullptr, ""Error loading the #pragma extra_include.\n"");; 4774 return 1;; 4775 }; 4776 ; 4777 } else if (isSelXML) {; 4778 ; 4779 selectionRules.SetSelectionFileType(SelectionRules::kSelectionXMLFile);; 4780 ; 4781 std::ifstream file(linkdefFilename.c_str());; 4782 if (file.is_open()) {; 4783 ROOT::TMetaUtils::Info(nullptr, ""Selection XML file\n"");; 4784 ; 4785 XMLReader xmlr(interp);; 4786 if (!xmlr.Parse(linkdefFilename.c_str(), selectionRules)) {; 4787 ROOT::TMetaUtils::Error(nullptr, ""Parsing XML file %s\n"", linkdefFilename.c_str());; 4788 return 1; // Return here to propagate the failure up to the build system; 4789 } else {; 4790 ROOT::TMetaUtils::Info(nullptr, ""XML file successfully parsed\n"");; 4791 }; 4792 file.close();; 4793 } else {; 4794 ROOT::TMetaUtils::Error(nullptr, ""XML file %s couldn't be opened!\n"", linkdefFilename.c_str());; 4795 }; 4796 ; 4797 } else {; 4798 ; 4799 ROOT::TMetaUtils::Error(nullptr, ""Unrecognized selection file: %s\n"", linkdefFilename.c_str());; ",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:233666,Performance,load,loaded,233666,"TRING ,; 5816 ""s"" , ""selection_file"" ,; 5817 ROOT::option::FullArg::Required,; 5818 selectionFilenameUsage; 5819 },; 5820 ; 5821 {; 5822 ROOTMAP,; 5823 STRING ,; 5824 """" , ""rootmap"" ,; 5825 ROOT::option::FullArg::Required,; 5826 rootmapUsage; 5827 },; 5828 ; 5829 {; 5830 ROOTMAPLIB,; 5831 STRING ,; 5832 """" , ""rootmap-lib"" ,; 5833 ROOT::option::FullArg::Required,; 5834 rootmapLibUsage; 5835 },; 5836 ; 5837 {; 5838 INTERPRETERONLY,; 5839 NOTYPE,; 5840 """" , ""interpreteronly"",; 5841 ROOT::option::Arg::None,; 5842 ""--interpreteronly\tDo not generate I/O related information.\n""; 5843 "" Generate minimal dictionary required for interactivity.\n""; 5844 },; 5845 ; 5846 {; 5847 SPLIT,; 5848 NOTYPE,; 5849 """" , ""split"",; 5850 ROOT::option::Arg::None,; 5851 ""--split\tSplit the dictionary\n""; 5852 "" Split in two the dictionary, isolating the part with\n""; 5853 "" ClassDef related functions in a separate file.\n""; 5854 },; 5855 ; 5856 {; 5857 PCMFILENAME,; 5858 STRING ,; 5859 ""m"" , """" ,; 5860 ROOT::option::FullArg::Required,; 5861 ""-m \tPcm file loaded before any header (option can be repeated).\n""; 5862 },; 5863 ; 5864 {; 5865 VERBOSE,; 5866 NOTYPE ,; 5867 ""-v"" , ""verbose"",; 5868 ROOT::option::Arg::None,; 5869 ""-v, --verbose\tPrint some debug information.\n""; 5870 },; 5871 ; 5872 {; 5873 DEBUG,; 5874 NOTYPE ,; 5875 """" , ""debug"",; 5876 ROOT::option::Arg::None,; 5877 ""--debug\tPrint all debug information.\n""; 5878 },; 5879 ; 5880 {; 5881 QUIET,; 5882 NOTYPE ,; 5883 """" , ""quiet"",; 5884 ROOT::option::Arg::None,; 5885 ""--quiet\tPrint only warnings and errors (default).\n""; 5886 },; 5887 ; 5888 {; 5889 SILENT,; 5890 NOTYPE ,; 5891 """" , ""silent"",; 5892 ROOT::option::Arg::None,; 5893 ""--silent\tPrint no information at all.\n""; 5894 },; 5895 ; 5896 {; 5897 WRITEEMPTYROOTPCM,; 5898 NOTYPE ,; 5899 """" , ""writeEmptyPCM"",; 5900 ROOT::option::Arg::None,; 5901 ""--writeEmptyPCM\tWrite an empty ROOT pcm.\n""; 5902 },; 5903 ; 5904 {; 5905 CXXMODULE,; 5906 NOTYPE ,; 5907 """" , ""cxxmodule"",; 5908 ROOT::op",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:288300,Performance,load,loaded,288300,"e the header files as it assumes they exist in the pch.""), llvm::cl::cat(gRootclingOptions)); gOptGeneratePCHstatic llvm::cl::opt< bool > gOptGeneratePCH(""generate-pch"", llvm::cl::desc(""Generates a pch file from a predefined set of headers. See makepch.py.""), llvm::cl::Hidden, llvm::cl::cat(gRootclingOptions)); ModuleContainsHeadersstatic bool ModuleContainsHeaders(TModuleGenerator &modGen, clang::HeaderSearch &headerSearch, clang::Module *module, std::vector< std::array< std::string, 2 > > &missingHeaders)Returns true iff a given module (and its submodules) contains all headers needed by the given ModuleG...Definition rootcling_impl.cxx:3881; GenerateAllDictstatic bool GenerateAllDict(TModuleGenerator &modGen, clang::CompilerInstance *compilerInstance, const std::string &currentDirectory)Generates a PCH from the given ModuleGenerator and CompilerInstance.Definition rootcling_impl.cxx:2035; LoadLibraryMapvoid LoadLibraryMap(const std::string &fileListName, map< string, string > &autoloads)Fill the map of libraries to be loaded in presence of a class Transparently support the old and new r...Definition rootcling_impl.cxx:692; CreateStreamPtrForSplitDictstd::ostream * CreateStreamPtrForSplitDict(const std::string &dictpathname, tempFileNamesCatalog &tmpCatalog)Transform name of dictionary.Definition rootcling_impl.cxx:3017; WriteNamespaceInitvoid WriteNamespaceInit(const clang::NamespaceDecl *cl, cling::Interpreter &interp, std::ostream &dictStream)Write the code to initialize the namespace name and the initialization object.Definition rootcling_impl.cxx:1257; gOptCompDefaultIncludePathsstatic llvm::cl::list< std::string > gOptCompDefaultIncludePaths(""compilerI"", llvm::cl::Prefix, llvm::cl::ZeroOrMore, llvm::cl::desc(""Specify a compiler default include path, to suppress unneeded `-isystem` arguments.""), llvm::cl::cat(gRootclingOptions)); AnnotateAllDeclsForPCHvoid AnnotateAllDeclsForPCH(cling::Interpreter &interp, RScanner &scan)We need annotations even in the PCH: //",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:14746,Safety,avoid,avoid,14746,"Attr::CreateImplicit(C, comment.str(), nullptr, 0));; 392 } else if (!isGenreflex) {; 393 // Here we check if we are in presence of a selection file so that; 394 // the comment does not ends up as a decoration in the AST,; 395 // Nevertheless, w/o PCMS this has no effect, since the headers; 396 // are parsed at runtime and the information in the AST dumped by; 397 // rootcling is not relevant.; 398 (*I)->addAttr(AnnotateAttr::CreateImplicit(C, comment.str(), nullptr, 0));; 399 }; 400 }; 401 // Match decls with sel rules if we are in presence of a selection file; 402 // and the cast was successful; 403 if (isGenreflex && thisClassSelectionRule != nullptr) {; 404 const std::list<VariableSelectionRule> &fieldSelRules = thisClassSelectionRule->GetFieldSelectionRules();; 405 ; 406 // This check is here to avoid asserts in debug mode (LLVMDEV env variable set); 407 if (FieldDecl *fieldDecl = dyn_cast<FieldDecl>(*I)) {; 408 AnnotateFieldDecl(*fieldDecl, fieldSelRules);; 409 }; 410 } // End presence of XML selection file; 411 }; 412 }; 413}; 414 ; 415////////////////////////////////////////////////////////////////////////////////; 416 ; 417size_t GetFullArrayLength(const clang::ConstantArrayType *arrayType); 418{; 419 if (!arrayType); 420 return 0;; 421 llvm::APInt len = arrayType->getSize();; 422 while (const clang::ConstantArrayType *subArrayType = llvm::dyn_cast<clang::ConstantArrayType>(arrayType->getArrayElementTypeNoTypeQual())) {; 423 len *= subArrayType->getSize();; 424 arrayType = subArrayType;; 425 }; 426 return len.getLimitedValue();; 427}; 428 ; 429////////////////////////////////////////////////////////////////////////////////; 430 ; 431bool InheritsFromTObject(const clang::RecordDecl *cl,; 432 const cling::Interpreter &interp); 433{; 434 static const clang::CXXRecordDecl *TObject_decl; 435 = ROOT::TMetaUtils::ScopeSearch(""TObject"", interp, true /*diag*/, nullptr);; 436 ; 437 const clang::CXXRecordDecl *clxx = llvm::dyn_cast<clang::CXXRecordDecl>(cl);; 438 retu",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:90040,Safety,avoid,avoid,90040,"lass TAttCanvas; 2247/// class TButton; 2248/// (header1.h header2.h .. headerN.h); 2249/// class TMyClass; 2250 ; 2251int CreateNewRootMapFile(const std::string &rootmapFileName,; 2252 const std::string &rootmapLibName,; 2253 const std::list<std::string> &classesDefsList,; 2254 const std::list<std::string> &classesNames,; 2255 const std::list<std::string> &nsNames,; 2256 const std::list<std::string> &tdNames,; 2257 const std::list<std::string> &enNames,; 2258 const std::list<std::string> &varNames,; 2259 const HeadersDeclsMap_t &headersClassesMap,; 2260 const std::unordered_set<std::string> headersToIgnore); 2261{; 2262 // Create the rootmap file from the selected classes and namespaces; 2263 std::ofstream rootmapFile(rootmapFileName.c_str());; 2264 if (!rootmapFile) {; 2265 ROOT::TMetaUtils::Error(nullptr, ""Opening new rootmap file %s\n"", rootmapFileName.c_str());; 2266 return 1;; 2267 }; 2268 ; 2269 // Keep track of the classes keys; 2270 // This is done to avoid duplications of keys with typedefs; 2271 std::unordered_set<std::string> classesKeys;; 2272 ; 2273 ; 2274 // Add the ""section""; 2275 if (!classesNames.empty() || !nsNames.empty() || !tdNames.empty() ||; 2276 !enNames.empty() || !varNames.empty()) {; 2277 ; 2278 // Add the template definitions; 2279 if (!classesDefsList.empty()) {; 2280 rootmapFile << ""{ decls }\n"";; 2281 for (auto & classDef : classesDefsList) {; 2282 rootmapFile << classDef << std::endl;; 2283 }; 2284 rootmapFile << ""\n"";; 2285 }; 2286 rootmapFile << ""[ "" << rootmapLibName << "" ]\n"";; 2287 ; 2288 // Loop on selected classes and insert them in the rootmap; 2289 if (!classesNames.empty()) {; 2290 rootmapFile << ""# List of selected classes\n"";; 2291 for (auto & className : classesNames) {; 2292 rootmapFile << ""class "" << className << std::endl;; 2293 classesKeys.insert(className);; 2294 }; 2295 // And headers; 2296 std::unordered_set<std::string> treatedHeaders;; 2297 for (auto & className : classesNames) {; 2298 // Don't treat templates; 2",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:96498,Safety,avoid,avoid,96498,"here; 2424 if (el_set.insert(tmp).second && !tmp.empty()) {; 2425 el_list.push_back(tmp);; 2426 added = true;; 2427 }; 2428 }; 2429 ; 2430 return added;; 2431}; 2432 ; 2433////////////////////////////////////////////////////////////////////////////////; 2434 ; 2435int ExtractClassesListAndDeclLines(RScanner &scan,; 2436 std::list<std::string> &classesList,; 2437 std::list<std::string> &classesListForRootmap,; 2438 std::list<std::string> &fwdDeclarationsList,; 2439 const cling::Interpreter &interpreter); 2440{; 2441 // Loop on selected classes. If they don't have the attribute ""rootmap""; 2442 // set to ""false"", store them in the list of classes for the rootmap; 2443 // Returns 0 in case of success and 1 in case of issues.; 2444 ; 2445 // An unordered_set to keep track of the existing classes.; 2446 // We want to avoid duplicates there as they may hint to a serious corruption; 2447 std::unordered_set<std::string> classesSet;; 2448 std::unordered_set<std::string> outerMostClassesSet;; 2449 ; 2450 std::string attrName, attrValue;; 2451 bool isClassSelected;; 2452 std::unordered_set<std::string> availableFwdDecls;; 2453 std::string fwdDeclaration;; 2454 for (auto const & selVar : scan.fSelectedVariables) {; 2455 fwdDeclaration = """";; 2456 int retCode = ROOT::TMetaUtils::AST2SourceTools::EncloseInNamespaces(*selVar, fwdDeclaration);; 2457 if (retCode == 0) ProcessAndAppendIfNotThere(fwdDeclaration, fwdDeclarationsList, availableFwdDecls);; 2458 }; 2459 ; 2460 for (auto const & selEnum : scan.fSelectedEnums) {; 2461 fwdDeclaration = """";; 2462 int retCode = ROOT::TMetaUtils::AST2SourceTools::EncloseInNamespaces(*selEnum, fwdDeclaration);; 2463 if (retCode == 0) ProcessAndAppendIfNotThere(fwdDeclaration, fwdDeclarationsList, availableFwdDecls);; 2464 }; 2465 ; 2466 // Loop on selected classes and put them in a list; 2467 for (auto const & selClass : scan.fSelectedClasses) {; 2468 isClassSelected = true;; 2469 const clang::RecordDecl *rDecl = selClass.GetRecordDecl();; 2470 st",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:129416,Safety,avoid,avoid,129416,"XXRecordDecl *cxxRcd =; 3235 llvm::dyn_cast_or_null<clang::CXXRecordDecl>(annotatedRcd.GetRecordDecl())) {; 3236 autoParseKey = """";; 3237 visitedDecls.clear();; 3238 std::list<std::string> headers(RecordDecl2Headers(*cxxRcd, interp, visitedDecls));; 3239 // remove duplicates, also if not subsequent; 3240 buffer.clear();; 3241 headers.remove_if([&buffer](const std::string & s) {; 3242 return !buffer.insert(s).second;; 3243 });; 3244 GetMostExternalEnclosingClassName(*cxxRcd, autoParseKey, interp);; 3245 if (autoParseKey.empty()) autoParseKey = annotatedRcd.GetNormalizedName();; 3246 if (IsGoodForAutoParseMap(*cxxRcd)){; 3247 headersDeclsMap[autoParseKey] = headers;; 3248 headersDeclsMap[annotatedRcd.GetRequestedName()] = headers;; 3249 } else {; 3250 ROOT::TMetaUtils::Info(nullptr, ""Class %s is not included in the set of autoparse keys.\n"", autoParseKey.c_str());; 3251 }; 3252 ; 3253 // Propagate to the classes map only if this is not a template.; 3254 // The header is then used as autoload key and we want to avoid duplicates.; 3255 if (!llvm::isa<clang::ClassTemplateSpecializationDecl>(cxxRcd)){; 3256 headersClassesMap[autoParseKey] = headersDeclsMap[autoParseKey];; 3257 headersClassesMap[annotatedRcd.GetRequestedName()] = headersDeclsMap[annotatedRcd.GetRequestedName()];; 3258 }; 3259 }; 3260 }; 3261 ; 3262 // The same for the typedefs:; 3263 for (auto & tDef : tDefDecls) {; 3264 if (clang::CXXRecordDecl *cxxRcd = tDef->getUnderlyingType()->getAsCXXRecordDecl()) {; 3265 autoParseKey = """";; 3266 visitedDecls.clear();; 3267 std::list<std::string> headers(RecordDecl2Headers(*cxxRcd, interp, visitedDecls));; 3268 headers.push_back(ROOT::TMetaUtils::GetFileName(*tDef, interp));; 3269 // remove duplicates, also if not subsequent; 3270 buffer.clear();; 3271 headers.remove_if([&buffer](const std::string & s) {; 3272 return !buffer.insert(s).second;; 3273 });; 3274 GetMostExternalEnclosingClassNameFromDecl(*tDef, autoParseKey, interp);; 3275 if (autoParseKey.empty()) autoPa",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:134405,Safety,detect,detectedUmbrella,134405,".fSelectedFunctions){; 3359// int retCode = FwdDeclFromFcnDecl(*fcnDeclPtr, interp, buffer);; 3360// newFwdDeclString += Decl2FwdDecl(*fcnDeclPtr,interp);; 3361// if (-1 == retCode){; 3362// ROOT::TMetaUtils::Error(""GenerateFwdDeclString"",; 3363// ""Error generating fwd decl for function %s\n"",; 3364// fcnDeclPtr->getNameAsString().c_str());; 3365// return emptyString;; 3366// }; 3367// if (retCode == 0 && fwdDecls.insert(buffer).second); 3368// fwdDeclString+=""\""""+buffer+""\""\n"";; 3369// }; 3370 ; 3371 if (fwdDeclString.empty()) fwdDeclString = """";; 3372 return fwdDeclString;; 3373}; 3374 ; 3375////////////////////////////////////////////////////////////////////////////////; 3376/// Generate a string for the dictionary from the headers-classes map.; 3377 ; 3378const std::string GenerateStringFromHeadersForClasses(const HeadersDeclsMap_t &headersClassesMap,; 3379 const std::string &detectedUmbrella,; 3380 bool payLoadOnly = false); 3381{; 3382 std::string headerName;; 3383 ; 3384 if (genreflex::verbose); 3385 std::cout << ""Class-headers Mapping:\n"";; 3386 std::string headersClassesMapString = """";; 3387 for (auto const & classHeaders : headersClassesMap) {; 3388 if (genreflex::verbose); 3389 std::cout << "" o "" << classHeaders.first << "" --> "";; 3390 headersClassesMapString += ""\"""";; 3391 headersClassesMapString += classHeaders.first + ""\"""";; 3392 for (auto const & header : classHeaders.second) {; 3393 headerName = (detectedUmbrella == header || payLoadOnly) ? ""payloadCode"" : ""\"""" + header + ""\"""";; 3394 headersClassesMapString += "", "" + headerName;; 3395 if (genreflex::verbose); 3396 std::cout << "", "" << headerName;; 3397 if (payLoadOnly); 3398 break;; 3399 }; 3400 if (genreflex::verbose); 3401 std::cout << std::endl;; 3402 headersClassesMapString += "", \""@\"",\n"";; 3403 }; 3404 headersClassesMapString += ""nullptr"";; 3405 return headersClassesMapString;; 3406}; 3407 ; 3408////////////////////////////////////////////////////////////////////////////////; 3409 ; 3410bool Is",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:134948,Safety,detect,detectedUmbrella,134948,"sDeclsMap_t &headersClassesMap,; 3379 const std::string &detectedUmbrella,; 3380 bool payLoadOnly = false); 3381{; 3382 std::string headerName;; 3383 ; 3384 if (genreflex::verbose); 3385 std::cout << ""Class-headers Mapping:\n"";; 3386 std::string headersClassesMapString = """";; 3387 for (auto const & classHeaders : headersClassesMap) {; 3388 if (genreflex::verbose); 3389 std::cout << "" o "" << classHeaders.first << "" --> "";; 3390 headersClassesMapString += ""\"""";; 3391 headersClassesMapString += classHeaders.first + ""\"""";; 3392 for (auto const & header : classHeaders.second) {; 3393 headerName = (detectedUmbrella == header || payLoadOnly) ? ""payloadCode"" : ""\"""" + header + ""\"""";; 3394 headersClassesMapString += "", "" + headerName;; 3395 if (genreflex::verbose); 3396 std::cout << "", "" << headerName;; 3397 if (payLoadOnly); 3398 break;; 3399 }; 3400 if (genreflex::verbose); 3401 std::cout << std::endl;; 3402 headersClassesMapString += "", \""@\"",\n"";; 3403 }; 3404 headersClassesMapString += ""nullptr"";; 3405 return headersClassesMapString;; 3406}; 3407 ; 3408////////////////////////////////////////////////////////////////////////////////; 3409 ; 3410bool IsImplementationName(const std::string &filename); 3411{; 3412 return !ROOT::TMetaUtils::IsHeaderName(filename);; 3413}; 3414 ; 3415////////////////////////////////////////////////////////////////////////////////; 3416/// Check if the argument is a sane cling argument. Performing the following checks:; 3417/// 1) It does not start with ""--"" and is not the --param option.; 3418 ; 3419bool IsCorrectClingArgument(const std::string& argument); 3420{; 3421 if (ROOT::TMetaUtils::BeginsWith(argument,""--"") && !ROOT::TMetaUtils::BeginsWith(argument,""--param"")) return false;; 3422 return true;; 3423}; 3424 ; 3425////////////////////////////////////////////////////////////////////////////////; 3426bool NeedsSelection(const char* name); 3427{; 3428 static const std::vector<std::string> namePrfxes {; 3429 ""array<"",; 3430 ""unique_ptr<""};; 34",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:146719,Safety,avoid,avoid,146719,"fo);; 3636 ; 3637 if (ID == remark_module_build && !isByproductModule) {; 3638 ROOT::TMetaUtils::Error(nullptr,; 3639 ""Building module '%s' implicitly. If '%s' requires a \n""; 3640 ""dictionary please specify build dependency: '%s' depends on '%s'.\n""; 3641 ""Otherwise, specify '-mByproduct %s' to disable this diagnostic.\n"",; 3642 moduleName.c_str(), moduleName.c_str(), gOptDictionaryFileName.c_str(),; 3643 moduleName.c_str(), moduleName.c_str());; 3644 }; 3645 }; 3646 ; 3647 // All methods below just forward to the child and the default method.; 3648 virtual void clear() override; 3649 {; 3650 fChild->clear();; 3651 DiagnosticConsumer::clear();; 3652 }; 3653 ; 3654 virtual void BeginSourceFile(const clang::LangOptions &LangOpts, const clang::Preprocessor *PP) override; 3655 {; 3656 fChild->BeginSourceFile(LangOpts, PP);; 3657 DiagnosticConsumer::BeginSourceFile(LangOpts, PP);; 3658 }; 3659 ; 3660 virtual void EndSourceFile() override; 3661 {; 3662 fChild->EndSourceFile();; 3663 DiagnosticConsumer::EndSourceFile();; 3664 }; 3665 ; 3666 virtual void finish() override; 3667 {; 3668 fChild->finish();; 3669 DiagnosticConsumer::finish();; 3670 }; 3671 ; 3672 virtual bool IncludeInDiagnosticCounts() const override { return fChild->IncludeInDiagnosticCounts(); }; 3673};; 3674 ; 3675static void MaybeSuppressWin32CrashDialogs() {; 3676#if defined(_WIN32) && defined(_MSC_VER); 3677 // Suppress error dialogs to avoid hangs on build nodes.; 3678 // One can use an environment variable (Cling_GuiOnAssert) to enable; 3679 // the error dialogs.; 3680 const char *EnablePopups = getenv(""Cling_GuiOnAssert"");; 3681 if (EnablePopups == nullptr || EnablePopups[0] == '0') {; 3682 ::_set_error_mode(_OUT_TO_STDERR);; 3683 _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3684 _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);; 3685 _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3686 _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);; 3687 _CrtSe",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:160012,Safety,abort,abort,160012,"ucts.end()); 3932 continue;; 3933 ; 3934 missingHeaders.push_back({header, OtherModuleName});; 3935 }; 3936 } else {; 3937 missingHeaders.push_back({header, {}});; 3938 }; 3939 foundAllHeaders = false;; 3940 }; 3941 return foundAllHeaders;; 3942}; 3943 ; 3944////////////////////////////////////////////////////////////////////////////////; 3945/// Check moduleName validity from modulemap. Check if this module is defined or not.; 3946static bool CheckModuleValid(TModuleGenerator &modGen, const std::string &resourceDir, cling::Interpreter &interpreter,; 3947 llvm::StringRef LinkdefPath, const std::string &moduleName); 3948{; 3949 clang::CompilerInstance *CI = interpreter.getCI();; 3950 clang::HeaderSearch &headerSearch = CI->getPreprocessor().getHeaderSearchInfo();; 3951 headerSearch.loadTopLevelSystemModules();; 3952 ; 3953 // Actually lookup the module on the computed module name.; 3954 clang::Module *module = headerSearch.lookupModule(llvm::StringRef(moduleName));; 3955 ; 3956 // Inform the user and abort if we can't find a module with a given name.; 3957 if (!module) {; 3958 ROOT::TMetaUtils::Error(""CheckModuleValid"", ""Couldn't find module with name '%s' in modulemap!\n"",; 3959 moduleName.c_str());; 3960 return false;; 3961 }; 3962 ; 3963 // Check if the loaded module covers all headers that were specified; 3964 // by the user on the command line. This is an integrity check to; 3965 // ensure that our used module map is not containing extraneous headers.; 3966 std::vector<std::array<std::string, 2>> missingHdrMod;; 3967 if (!ModuleContainsHeaders(modGen, headerSearch, module, missingHdrMod)) {; 3968 // FIXME: Upgrade this to an error once modules are stable.; 3969 std::stringstream msgStream;; 3970 msgStream << ""after creating module \"""" << module->Name << ""\"" "";; 3971 if (!module->PresumedModuleMapFile.empty()); 3972 msgStream << ""using modulemap \"""" << module->PresumedModuleMapFile << ""\"" "";; 3973 msgStream << ""the following headers are not part of that module:\n""",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:168376,Safety,detect,detected,168376,"\n"", executableFileName, filein.c_str());; 4129 return 1;; 4130 }; 4131 fclose(fp);; 4132 }; 4133 ; 4134 if (IsImplementationName(gOptDictionaryFileName)) {; 4135 FILE *fp;; 4136 if (!gOptIgnoreExistingDict && (fp = fopen(gOptDictionaryFileName.c_str(), ""r"")) != nullptr) {; 4137 fclose(fp);; 4138 if (!gOptForce) {; 4139 ROOT::TMetaUtils::Error(nullptr, ""%s: output file %s already exists\n"", executableFileName, gOptDictionaryFileName.c_str());; 4140 return 1;; 4141 }; 4142 }; 4143 ; 4144 // remove possible pathname to get the dictionary name; 4145 if (gOptDictionaryFileName.size() > (PATH_MAX - 1)) {; 4146 ROOT::TMetaUtils::Error(nullptr, ""rootcling: dictionary name too long (more than %d characters): %s\n"",; 4147 (PATH_MAX - 1), gOptDictionaryFileName.c_str());; 4148 return 1;; 4149 }; 4150 ; 4151 dictname = llvm::sys::path::filename(gOptDictionaryFileName).str();; 4152 }; 4153 ; 4154 if (gOptForce && dictname.empty()) {; 4155 ROOT::TMetaUtils::Error(nullptr, ""Inconsistent set of arguments detected: overwrite of dictionary file forced but no filename specified.\n"");; 4156 llvm::cl::PrintHelpMessage();; 4157 return 1;; 4158 }; 4159 ; 4160 std::vector<std::string> clingArgs;; 4161 clingArgs.push_back(executableFileName);; 4162 clingArgs.push_back(""-iquote."");; 4163 ; 4164 bool dictSelection = !gOptNoDictSelection;; 4165 ; 4166 // Collect the diagnostic pragmas linked to the usage of -W; 4167 // Workaround for ROOT-5656; 4168 std::list<std::string> diagnosticPragmas = {""#pragma clang diagnostic ignored \""-Wdeprecated-declarations\""""};; 4169 ; 4170 if (gOptFailOnWarnings) {; 4171 using namespace ROOT::TMetaUtils;; 4172 // If warnings are disabled with the current verbosity settings, lower; 4173 // it so that the user sees the warning that caused the failure.; 4174 if (GetErrorIgnoreLevel() > kWarning); 4175 GetErrorIgnoreLevel() = kWarning;; 4176 GetWarningsAreErrors() = true;; 4177 }; 4178 ; 4179 if (gOptISysRoot != ""-"") {; 4180 if (gOptISysRoot.empty()) {; 4181 ROOT::T",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:185582,Safety,safe,safe,185582,"ush_back(""-D__CINT__"");; 4496 clingArgs.push_back(""-D__MAKECINT__"");; 4497 ; 4498 AddPlatformDefines(clingArgs);; 4499 ; 4500 std::string currentDirectory = ROOT::FoundationUtils::GetCurrentDir();; 4501 ; 4502 std::string interpPragmaSource;; 4503 std::string includeForSource;; 4504 std::string interpreterDeclarations;; 4505 std::string linkdef;; 4506 ; 4507 for (size_t i = 0, e = gOptDictionaryHeaderFiles.size(); i < e; ++i) {; 4508 const std::string& optHeaderFileName = gOptDictionaryHeaderFiles[i];; 4509 bool isSelectionFile = IsSelectionFile(optHeaderFileName.c_str());; 4510 ; 4511 if (isSelectionFile) {; 4512 if (i == e - 1) {; 4513 linkdef = optHeaderFileName;; 4514 } else { // if the linkdef was not last, issue an error.; 4515 ROOT::TMetaUtils::Error(nullptr, ""%s: %s must be last file on command line\n"",; 4516 executableFileName, optHeaderFileName.c_str());; 4517 return 1;; 4518 }; 4519 }; 4520 ; 4521 // coverity[tainted_data] The OS should already limit the argument size, so we are safe here; 4522 std::string fullheader(optHeaderFileName);; 4523 // Strip any trailing + which is only used by GeneratedLinkdef.h which currently; 4524 // use directly argv.; 4525 if (fullheader[fullheader.length() - 1] == '+') {; 4526 fullheader.erase(fullheader.length() - 1);; 4527 }; 4528 std::string header(; 4529 isSelectionFile ? fullheader : ROOT::FoundationUtils::MakePathRelative(fullheader, currentDirectory, gBuildingROOT));; 4530 ; 4531 interpPragmaSource += std::string(""#include \"""") + header + ""\""\n"";; 4532 if (!isSelectionFile) {; 4533 // In order to not have to add the equivalent to -I${PWD} to the; 4534 // command line, include the complete file name, even if it is a; 4535 // full pathname, when we write it down in the dictionary.; 4536 // Note: have -I${PWD} means in that (at least in the case of; 4537 // ACLiC) we inadvertently pick local file that have the same; 4538 // name as system header (e.g. new or list) and -iquote has not; 4539 // equivalent on some platfo",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:203423,Safety,detect,detectedUmbrella,203423,"fBuildingROOTStage1) {; 4959 rootclingRetCode += FinalizeStreamerInfoWriting(interp);; 4960 }; 4961 } else {; 4962 rootclingRetCode += GenerateFullDict(*splitDictStream,; 4963 interp,; 4964 scan,; 4965 constructorTypes,; 4966 gOptSplit,; 4967 isGenreflex,; 4968 isSelXML,; 4969 gOptWriteEmptyRootPCM);; 4970 }; 4971 ; 4972 if (rootclingRetCode != 0) {; 4973 return rootclingRetCode;; 4974 }; 4975 ; 4976 // Now we have done all our looping and thus all the possible; 4977 // annotation, let's write the pcms.; 4978 HeadersDeclsMap_t headersClassesMap;; 4979 HeadersDeclsMap_t headersDeclsMap;; 4980 if (!gOptIgnoreExistingDict) {; 4981 const std::string fwdDeclnArgsToKeepString(GetFwdDeclnArgsToKeepString(normCtxt, interp));; 4982 ; 4983 ExtractHeadersForDecls(scan.fSelectedClasses,; 4984 scan.fSelectedTypedefs,; 4985 scan.fSelectedFunctions,; 4986 scan.fSelectedVariables,; 4987 scan.fSelectedEnums,; 4988 headersClassesMap,; 4989 headersDeclsMap,; 4990 interp);; 4991 ; 4992 std::string detectedUmbrella;; 4993 for (auto & arg : pcmArgs) {; 4994 if (gOptInlineInput && !ROOT::TMetaUtils::IsLinkdefFile(arg.c_str()) && ROOT::TMetaUtils::IsHeaderName(arg)) {; 4995 detectedUmbrella = arg;; 4996 break;; 4997 }; 4998 }; 4999 ; 5000 if (gOptWriteEmptyRootPCM){; 5001 headersDeclsMap.clear();; 5002 }; 5003 ; 5004 ; 5005 std::string headersClassesMapString = ""\""\"""";; 5006 std::string fwdDeclsString = ""\""\"""";; 5007 if (!gOptCxxModule) {; 5008 headersClassesMapString = GenerateStringFromHeadersForClasses(headersDeclsMap,; 5009 detectedUmbrella,; 5010 true);; 5011 if (!gDriverConfig->fBuildingROOTStage1) {; 5012 if (!gOptWriteEmptyRootPCM); 5013 fwdDeclsString = GenerateFwdDeclString(scan, interp);; 5014 }; 5015 }; 5016 modGen.WriteRegistrationSource(dictStream, fwdDeclnArgsToKeepString, headersClassesMapString, fwdDeclsString,; 5017 extraIncludes, gOptCxxModule);; 5018 // If we just want to inline the input header, we don't need; 5019 // to generate any files.; 5020 if (!gOptInlineInput) {",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:203599,Safety,detect,detectedUmbrella,203599,"965 constructorTypes,; 4966 gOptSplit,; 4967 isGenreflex,; 4968 isSelXML,; 4969 gOptWriteEmptyRootPCM);; 4970 }; 4971 ; 4972 if (rootclingRetCode != 0) {; 4973 return rootclingRetCode;; 4974 }; 4975 ; 4976 // Now we have done all our looping and thus all the possible; 4977 // annotation, let's write the pcms.; 4978 HeadersDeclsMap_t headersClassesMap;; 4979 HeadersDeclsMap_t headersDeclsMap;; 4980 if (!gOptIgnoreExistingDict) {; 4981 const std::string fwdDeclnArgsToKeepString(GetFwdDeclnArgsToKeepString(normCtxt, interp));; 4982 ; 4983 ExtractHeadersForDecls(scan.fSelectedClasses,; 4984 scan.fSelectedTypedefs,; 4985 scan.fSelectedFunctions,; 4986 scan.fSelectedVariables,; 4987 scan.fSelectedEnums,; 4988 headersClassesMap,; 4989 headersDeclsMap,; 4990 interp);; 4991 ; 4992 std::string detectedUmbrella;; 4993 for (auto & arg : pcmArgs) {; 4994 if (gOptInlineInput && !ROOT::TMetaUtils::IsLinkdefFile(arg.c_str()) && ROOT::TMetaUtils::IsHeaderName(arg)) {; 4995 detectedUmbrella = arg;; 4996 break;; 4997 }; 4998 }; 4999 ; 5000 if (gOptWriteEmptyRootPCM){; 5001 headersDeclsMap.clear();; 5002 }; 5003 ; 5004 ; 5005 std::string headersClassesMapString = ""\""\"""";; 5006 std::string fwdDeclsString = ""\""\"""";; 5007 if (!gOptCxxModule) {; 5008 headersClassesMapString = GenerateStringFromHeadersForClasses(headersDeclsMap,; 5009 detectedUmbrella,; 5010 true);; 5011 if (!gDriverConfig->fBuildingROOTStage1) {; 5012 if (!gOptWriteEmptyRootPCM); 5013 fwdDeclsString = GenerateFwdDeclString(scan, interp);; 5014 }; 5015 }; 5016 modGen.WriteRegistrationSource(dictStream, fwdDeclnArgsToKeepString, headersClassesMapString, fwdDeclsString,; 5017 extraIncludes, gOptCxxModule);; 5018 // If we just want to inline the input header, we don't need; 5019 // to generate any files.; 5020 if (!gOptInlineInput) {; 5021 // Write the module/PCH depending on what mode we are on; 5022 if (modGen.IsPCH()) {; 5023 if (!GenerateAllDict(modGen, CI, currentDirectory)) return 1;; 5024 } else if (gOptCxxModule) {; 502",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:203960,Safety,detect,detectedUmbrella,203960," 4978 HeadersDeclsMap_t headersClassesMap;; 4979 HeadersDeclsMap_t headersDeclsMap;; 4980 if (!gOptIgnoreExistingDict) {; 4981 const std::string fwdDeclnArgsToKeepString(GetFwdDeclnArgsToKeepString(normCtxt, interp));; 4982 ; 4983 ExtractHeadersForDecls(scan.fSelectedClasses,; 4984 scan.fSelectedTypedefs,; 4985 scan.fSelectedFunctions,; 4986 scan.fSelectedVariables,; 4987 scan.fSelectedEnums,; 4988 headersClassesMap,; 4989 headersDeclsMap,; 4990 interp);; 4991 ; 4992 std::string detectedUmbrella;; 4993 for (auto & arg : pcmArgs) {; 4994 if (gOptInlineInput && !ROOT::TMetaUtils::IsLinkdefFile(arg.c_str()) && ROOT::TMetaUtils::IsHeaderName(arg)) {; 4995 detectedUmbrella = arg;; 4996 break;; 4997 }; 4998 }; 4999 ; 5000 if (gOptWriteEmptyRootPCM){; 5001 headersDeclsMap.clear();; 5002 }; 5003 ; 5004 ; 5005 std::string headersClassesMapString = ""\""\"""";; 5006 std::string fwdDeclsString = ""\""\"""";; 5007 if (!gOptCxxModule) {; 5008 headersClassesMapString = GenerateStringFromHeadersForClasses(headersDeclsMap,; 5009 detectedUmbrella,; 5010 true);; 5011 if (!gDriverConfig->fBuildingROOTStage1) {; 5012 if (!gOptWriteEmptyRootPCM); 5013 fwdDeclsString = GenerateFwdDeclString(scan, interp);; 5014 }; 5015 }; 5016 modGen.WriteRegistrationSource(dictStream, fwdDeclnArgsToKeepString, headersClassesMapString, fwdDeclsString,; 5017 extraIncludes, gOptCxxModule);; 5018 // If we just want to inline the input header, we don't need; 5019 // to generate any files.; 5020 if (!gOptInlineInput) {; 5021 // Write the module/PCH depending on what mode we are on; 5022 if (modGen.IsPCH()) {; 5023 if (!GenerateAllDict(modGen, CI, currentDirectory)) return 1;; 5024 } else if (gOptCxxModule) {; 5025 if (!CheckModuleValid(modGen, llvmResourceDir, interp, linkdefFilename, moduleName.str())); 5026 return 1;; 5027 }; 5028 }; 5029 }; 5030 ; 5031 ; 5032 if (!gOptLibListPrefix.empty()) {; 5033 string liblist_filename = gOptLibListPrefix + "".out"";; 5034 ; 5035 ofstream outputfile(liblist_filename.c_str(), ios:",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:208809,Safety,avoid,avoid,208809,"ptRootMapFileName,; 5116 rootmapLibName,; 5117 classesDefsList,; 5118 classesNamesForRootmap,; 5119 nsNames,; 5120 typedefsRootmapLines,; 5121 enumNames,; 5122 varNames,; 5123 headersClassesMap,; 5124 headersToIgnore);; 5125 ; 5126 if (0 != rootclingRetCode) return 1;; 5127 }; 5128 ; 5129 if (genreflex::verbose); 5130 tmpCatalog.dump();; 5131 ; 5132 // Manually call end of translation unit because we never call the; 5133 // appropriate deconstructors in the interpreter. This writes out the C++; 5134 // module file that we currently generate.; 5135 {; 5136 cling::Interpreter::PushTransactionRAII RAII(&interp);; 5137 CI->getSema().getASTConsumer().HandleTranslationUnit(CI->getSema().getASTContext());; 5138 }; 5139 ; 5140 // Add the warnings; 5141 rootclingRetCode += ROOT::TMetaUtils::GetNumberOfErrors();; 5142 ; 5143 // make sure the file is closed before committing; 5144 fileout.close();; 5145 ; 5146 // Before returning, rename the files if no errors occurred; 5147 // otherwise clean them to avoid remnants (see ROOT-10015); 5148 if(rootclingRetCode == 0) {; 5149 rootclingRetCode += tmpCatalog.commit();; 5150 } else {; 5151 tmpCatalog.clean();; 5152 }; 5153 ; 5154 return rootclingRetCode;; 5155 ; 5156}; 5157 ; 5158namespace genreflex {; 5159 ; 5160////////////////////////////////////////////////////////////////////////////////; 5161/// Loop on arguments: stop at the first which starts with -; 5162 ; 5163 unsigned int checkHeadersNames(std::vector<std::string> &headersNames); 5164 {; 5165 unsigned int numberOfHeaders = 0;; 5166 for (std::vector<std::string>::iterator it = headersNames.begin();; 5167 it != headersNames.end(); ++it) {; 5168 const std::string headername(*it);; 5169 if (ROOT::TMetaUtils::IsHeaderName(headername)) {; 5170 numberOfHeaders++;; 5171 } else {; 5172 ROOT::TMetaUtils::Warning(nullptr,; 5173 ""*** genreflex: %s is not a valid header name (.h and .hpp extensions expected)!\n"",; 5174 headername.c_str());; 5175 }; 5176 }; 5177 return numberOfHeaders;;",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:245500,Safety,detect,detected,245500,"Cling::DriverConfig& config); 6226{; 6227 ; 6228 assert(!gDriverConfig && ""Driver configuration already set!"");; 6229 gDriverConfig = &config;; 6230 ; 6231 gBuildingROOT = config.fBuildingROOTStage1; // gets refined later; 6232 ; 6233 std::string exeName = ExtractFileName(GetExePath());; 6234#ifdef __APPLE__; 6235 // _dyld_get_image_name() on macOS11 and later sometimes returns ""rootcling"" for ""genreflex"".; 6236 // Fix that (while still initializing the binary path, needed for ROOTSYS) by updating the; 6237 // exeName to argv[0]:; 6238 exeName = ExtractFileName(argv[0]);; 6239#endif; 6240 ; 6241 // Select according to the name of the executable the procedure to follow:; 6242 // 1) RootCling; 6243 // 2) GenReflex; 6244 // The default is rootcling; 6245 ; 6246 int retVal = 0;; 6247 ; 6248 if (std::string::npos != exeName.find(""genreflex"")); 6249 retVal = GenReflexMain(argc, argv);; 6250 else // rootcling or default; 6251 retVal = RootClingMain(argc, argv);; 6252 ; 6253 gDriverConfig = nullptr;; 6254 ; 6255 if (ROOT::TMetaUtils::GetNumberOfErrors()){; 6256 ROOT::TMetaUtils::Info(nullptr,""Problems have been detected during the generation of the dictionary.\n"");; 6257 return 1;; 6258 }; 6259 return retVal;; 6260}; DictSelectionReader.hSelect classes and assign properties using C++ syntax.; FoundationUtils.hxxThe file contains utilities which are foundational and could be used across the core component of ROO...; LinkdefReader.h; OptionParser.hThis is the only file required to use The Lean Mean C++ Option Parser.; DEBUG#define DEBUGDefinition Polynomial.cxx:40; RConfig.hxx; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; RStl.h; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; RtypesCore.h; Scanner.h; SelectionRules.h; TClassEdit.h; X#define X(type, nam",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:299010,Safety,detect,detectedUmbrella,299010,"estatic llvm::cl::opt< std::string > gOptDictionaryFileName(llvm::cl::Positional, llvm::cl::desc(""<output dictionary file>""), llvm::cl::cat(gRootclingOptions)); IsSelectionXmlbool IsSelectionXml(const char *filename)Definition rootcling_impl.cxx:454; IsGoodLibraryNamebool IsGoodLibraryName(const std::string &name)Definition rootcling_impl.cxx:5563; GrabIndexllvm::StringRef GrabIndex(const cling::Interpreter &interp, const clang::FieldDecl &member, int printError)GrabIndex returns a static string (so use it or copy it immediately, do not call GrabIndex twice in t...Definition rootcling_impl.cxx:1352; gOptMultiDictstatic llvm::cl::opt< bool > gOptMultiDict(""multiDict"", llvm::cl::desc(""If this library has multiple separate LinkDef files.""), llvm::cl::cat(gRootclingOptions)); IsSelectionFilebool IsSelectionFile(const char *filename)Definition rootcling_impl.cxx:474; GenerateStringFromHeadersForClassesconst std::string GenerateStringFromHeadersForClasses(const HeadersDeclsMap_t &headersClassesMap, const std::string &detectedUmbrella, bool payLoadOnly=false)Generate a string for the dictionary from the headers-classes map.Definition rootcling_impl.cxx:3378; IsSupportedClassNamebool IsSupportedClassName(const char *name)Definition rootcling_impl.cxx:3439; gOptIgnoreExistingDictstatic llvm::cl::opt< bool > gOptIgnoreExistingDict(""r"", llvm::cl::desc(""Deprecated. Similar to -f but it ignores the dictionary generation. \; When -r is present rootcling becomes a tool to generate rootmaps (and capability files).""), llvm::cl::Hidden, llvm::cl::cat(gRootclingOptions)); gOptForcestatic llvm::cl::opt< bool > gOptForce(""f"", llvm::cl::desc(""Overwrite <file>s.""), llvm::cl::cat(gRootclingOptions)); AnnotateFieldDeclstatic void AnnotateFieldDecl(clang::FieldDecl &decl, const std::list< VariableSelectionRule > &fieldSelRules)Definition rootcling_impl.cxx:253; CallWriteStreamervoid CallWriteStreamer(const ROOT::TMetaUtils::AnnotatedRecordDecl &cl, const cling::Interpreter &interp, const ROO",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:77849,Security,inject,injected,77849,"932 return true;; 1933 }; 1934 }; 1935 pname = """";; 1936 return false;; 1937}; 1938 ; 1939////////////////////////////////////////////////////////////////////////////////; 1940/// If the argument starts with MODULE/inc, strip it; 1941/// to make it the name we can use in `#includes`.; 1942 ; 1943const char *CopyArg(const char *original); 1944{; 1945 if (!gBuildingROOT); 1946 return original;; 1947 ; 1948 if (IsSelectionFile(original)); 1949 return original;; 1950 ; 1951 const char *inc = strstr(original, ""\\inc\\"");; 1952 if (!inc); 1953 inc = strstr(original, ""/inc/"");; 1954 if (inc && strlen(inc) > 5); 1955 return inc + 5;; 1956 return original;; 1957}; 1958 ; 1959////////////////////////////////////////////////////////////////////////////////; 1960/// Copy the command line argument, stripping MODULE/inc if; 1961/// necessary.; 1962 ; 1963void StrcpyArg(string &dest, const char *original); 1964{; 1965 dest = CopyArg(original);; 1966}; 1967 ; 1968////////////////////////////////////////////////////////////////////////////////; 1969/// Write the extra header injected into the module:; 1970/// umbrella header if (umbrella) else content header.; 1971 ; 1972static bool InjectModuleUtilHeader(const char *argv0,; 1973 TModuleGenerator &modGen,; 1974 cling::Interpreter &interp,; 1975 bool umbrella); 1976{; 1977 std::ostringstream out;; 1978 if (umbrella) {; 1979 // This will duplicate the -D,-U from clingArgs - but as they are surrounded; 1980 // by #ifndef there is no problem here.; 1981 modGen.WriteUmbrellaHeader(out);; 1982 if (interp.declare(out.str()) != cling::Interpreter::kSuccess) {; 1983 const std::string &hdrName; 1984 = umbrella ? modGen.GetUmbrellaName() : modGen.GetContentName();; 1985 ROOT::TMetaUtils::Error(nullptr, ""%s: compilation failure (%s)\n"", argv0,; 1986 hdrName.c_str());; 1987 return false;; 1988 }; 1989 } else {; 1990 modGen.WriteContentHeader(out);; 1991 }; 1992 return true;; 1993}; 1994 ; 1995/////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:117095,Security,access,accessing,117095,"e(nameStr.c_str());; 2913 const char *tmpName(tmpNameStr.c_str());; 2914 ; 2915 m_names.push_back(nameStr);; 2916 m_tempNames.push_back(tmpNameStr);; 2917 ROOT::TMetaUtils::Info(nullptr, ""File %s added to the tmp catalog.\n"", name);; 2918 ; 2919 // This is to allow update of existing files; 2920 if (0 == std::rename(name , tmpName)) {; 2921 ROOT::TMetaUtils::Info(nullptr, ""File %s existing. Preserved as %s.\n"", name, tmpName);; 2922 }; 2923 ; 2924 // To change the name to its tmp version; 2925 nameStr = tmpNameStr;; 2926 ; 2927 m_size++;; 2928 ; 2929 }; 2930 ; 2931 /////////////////////////////////////////////////////////////////////////////; 2932 ; 2933 int clean() {; 2934 int retval = 0;; 2935 // rename the temp files into the normal ones; 2936 for (unsigned int i = 0; i < m_size; ++i) {; 2937 const char *tmpName = m_tempNames[i].c_str();; 2938 // Check if the file exists; 2939 std::ifstream ifile(tmpName);; 2940 if (!ifile); 2941 ROOT::TMetaUtils::Error(nullptr, ""Cannot find %s!\n"", tmpName);; 2942 // Make sure the file is closed, mostly for Windows FS, also when; 2943 // accessing it from a Linux VM via a shared folder; 2944 if (ifile.is_open()); 2945 ifile.close();; 2946 if (0 != std::remove(tmpName)) {; 2947 ROOT::TMetaUtils::Error(nullptr, ""Removing %s!\n"", tmpName);; 2948 retval++;; 2949 }; 2950 }; 2951 return retval;; 2952 }; 2953 ; 2954 /////////////////////////////////////////////////////////////////////////////; 2955 ; 2956 int commit() {; 2957 int retval = 0;; 2958 // rename the temp files into the normal ones; 2959 for (unsigned int i = 0; i < m_size; ++i) {; 2960 const char *tmpName = m_tempNames[i].c_str();; 2961 const char *name = m_names[i].c_str();; 2962 // Check if the file exists; 2963 std::ifstream ifile(tmpName);; 2964 if (!ifile); 2965 ROOT::TMetaUtils::Error(nullptr, ""Cannot find %s!\n"", tmpName);; 2966 // Make sure the file is closed, mostly for Windows FS, also when; 2967 // accessing it from a Linux VM via a shared folder; 2968 if (ifile.i",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:117938,Security,access,accessing,117938,".c_str();; 2938 // Check if the file exists; 2939 std::ifstream ifile(tmpName);; 2940 if (!ifile); 2941 ROOT::TMetaUtils::Error(nullptr, ""Cannot find %s!\n"", tmpName);; 2942 // Make sure the file is closed, mostly for Windows FS, also when; 2943 // accessing it from a Linux VM via a shared folder; 2944 if (ifile.is_open()); 2945 ifile.close();; 2946 if (0 != std::remove(tmpName)) {; 2947 ROOT::TMetaUtils::Error(nullptr, ""Removing %s!\n"", tmpName);; 2948 retval++;; 2949 }; 2950 }; 2951 return retval;; 2952 }; 2953 ; 2954 /////////////////////////////////////////////////////////////////////////////; 2955 ; 2956 int commit() {; 2957 int retval = 0;; 2958 // rename the temp files into the normal ones; 2959 for (unsigned int i = 0; i < m_size; ++i) {; 2960 const char *tmpName = m_tempNames[i].c_str();; 2961 const char *name = m_names[i].c_str();; 2962 // Check if the file exists; 2963 std::ifstream ifile(tmpName);; 2964 if (!ifile); 2965 ROOT::TMetaUtils::Error(nullptr, ""Cannot find %s!\n"", tmpName);; 2966 // Make sure the file is closed, mostly for Windows FS, also when; 2967 // accessing it from a Linux VM via a shared folder; 2968 if (ifile.is_open()); 2969 ifile.close();; 2970#ifdef WIN32; 2971 // Sometimes files cannot be renamed on Windows if they don't have; 2972 // been released by the system. So just copy them and try to delete; 2973 // the old one afterwards.; 2974 if (0 != std::rename(tmpName , name)) {; 2975 if (llvm::sys::fs::copy_file(tmpName , name)) {; 2976 llvm::sys::fs::remove(tmpName);; 2977 }; 2978 }; 2979#else; 2980 if (0 != std::rename(tmpName , name)) {; 2981 ROOT::TMetaUtils::Error(nullptr, ""Renaming %s into %s!\n"", tmpName, name);; 2982 retval++;; 2983 }; 2984#endif; 2985 }; 2986 return retval;; 2987 }; 2988 ; 2989 /////////////////////////////////////////////////////////////////////////////; 2990 ; 2991 const std::string &getFileName(const std::string &tmpFileName) {; 2992 size_t i = std::distance(m_tempNames.begin(),; 2993 find(m_tempNames.begin",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:152815,Security,expose,expose,152815,"ileName(""s"",; 3789 llvm::cl::desc(""The path to the library of the built dictionary.""),; 3790 llvm::cl::cat(gRootclingOptions));; 3791static llvm::cl::list<std::string>; 3792gOptModuleDependencies(""m"",; 3793 llvm::cl::desc(""The list of dependent modules of the dictionary.""),; 3794 llvm::cl::cat(gRootclingOptions));; 3795static llvm::cl::list<std::string>; 3796gOptExcludePaths(""excludePath"", llvm::cl::ZeroOrMore,; 3797 llvm::cl::desc(""Do not store the <path> in the dictionary.""),; 3798 llvm::cl::cat(gRootclingOptions));; 3799// FIXME: This does not seem to work. We have one use of -inlineInputHeader in; 3800// ROOT and it does not produce the expected result.; 3801static llvm::cl::opt<bool>; 3802gOptInlineInput(""inlineInputHeader"",; 3803 llvm::cl::desc(""Does not generate #include <header> but expands the header content.""),; 3804 llvm::cl::cat(gRootclingOptions));; 3805// FIXME: This is totally the wrong concept. We should not expose an interface; 3806// to be able to tell which component is in the pch and which needs extra; 3807// scaffolding for interactive use. Moreover, some of the ROOT components are; 3808// partially in the pch and this option makes it impossible to express that.; 3809// We should be able to get the list of headers in the pch early and scan; 3810// through them.; 3811static llvm::cl::opt<bool>; 3812gOptWriteEmptyRootPCM(""writeEmptyRootPCM"",; 3813 llvm::cl::Hidden,; 3814 llvm::cl::desc(""Does not include the header files as it assumes they exist in the pch.""),; 3815 llvm::cl::cat(gRootclingOptions));; 3816static llvm::cl::opt<bool>; 3817gOptCheckSelectionSyntax(""selSyntaxOnly"",; 3818 llvm::cl::desc(""Check the selection syntax only.""),; 3819 llvm::cl::cat(gRootclingOptions));; 3820static llvm::cl::opt<bool>; 3821gOptFailOnWarnings(""failOnWarnings"",; 3822 llvm::cl::desc(""Fail if there are warnings.""),; 3823 llvm::cl::cat(gRootclingOptions));; 3824static llvm::cl::opt<bool>; 3825gOptNoIncludePaths(""noIncludePaths"",; 3826 llvm::cl::desc(""Do not store i",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:160379,Security,integrity,integrity,160379,"r not.; 3946static bool CheckModuleValid(TModuleGenerator &modGen, const std::string &resourceDir, cling::Interpreter &interpreter,; 3947 llvm::StringRef LinkdefPath, const std::string &moduleName); 3948{; 3949 clang::CompilerInstance *CI = interpreter.getCI();; 3950 clang::HeaderSearch &headerSearch = CI->getPreprocessor().getHeaderSearchInfo();; 3951 headerSearch.loadTopLevelSystemModules();; 3952 ; 3953 // Actually lookup the module on the computed module name.; 3954 clang::Module *module = headerSearch.lookupModule(llvm::StringRef(moduleName));; 3955 ; 3956 // Inform the user and abort if we can't find a module with a given name.; 3957 if (!module) {; 3958 ROOT::TMetaUtils::Error(""CheckModuleValid"", ""Couldn't find module with name '%s' in modulemap!\n"",; 3959 moduleName.c_str());; 3960 return false;; 3961 }; 3962 ; 3963 // Check if the loaded module covers all headers that were specified; 3964 // by the user on the command line. This is an integrity check to; 3965 // ensure that our used module map is not containing extraneous headers.; 3966 std::vector<std::array<std::string, 2>> missingHdrMod;; 3967 if (!ModuleContainsHeaders(modGen, headerSearch, module, missingHdrMod)) {; 3968 // FIXME: Upgrade this to an error once modules are stable.; 3969 std::stringstream msgStream;; 3970 msgStream << ""after creating module \"""" << module->Name << ""\"" "";; 3971 if (!module->PresumedModuleMapFile.empty()); 3972 msgStream << ""using modulemap \"""" << module->PresumedModuleMapFile << ""\"" "";; 3973 msgStream << ""the following headers are not part of that module:\n"";; 3974 for (auto &H : missingHdrMod) {; 3975 msgStream << "" "" << H[0];; 3976 if (!H[1].empty()); 3977 msgStream << "" (already part of module \"""" << H[1] << ""\"")"";; 3978 msgStream << ""\n"";; 3979 }; 3980 std::string warningMessage = msgStream.str();; 3981 ; 3982 bool maybeUmbrella = modGen.GetHeaders().size() == 1;; 3983 // We may have an umbrella and forgot to add the flag. Downgrade the; 3984 // warning into an informat",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:197112,Security,validat,validate,197112,"_str());; 4782 if (file.is_open()) {; 4783 ROOT::TMetaUtils::Info(nullptr, ""Selection XML file\n"");; 4784 ; 4785 XMLReader xmlr(interp);; 4786 if (!xmlr.Parse(linkdefFilename.c_str(), selectionRules)) {; 4787 ROOT::TMetaUtils::Error(nullptr, ""Parsing XML file %s\n"", linkdefFilename.c_str());; 4788 return 1; // Return here to propagate the failure up to the build system; 4789 } else {; 4790 ROOT::TMetaUtils::Info(nullptr, ""XML file successfully parsed\n"");; 4791 }; 4792 file.close();; 4793 } else {; 4794 ROOT::TMetaUtils::Error(nullptr, ""XML file %s couldn't be opened!\n"", linkdefFilename.c_str());; 4795 }; 4796 ; 4797 } else {; 4798 ; 4799 ROOT::TMetaUtils::Error(nullptr, ""Unrecognized selection file: %s\n"", linkdefFilename.c_str());; 4800 ; 4801 }; 4802 ; 4803 // Speed up the operations with rules; 4804 selectionRules.FillCache();; 4805 selectionRules.Optimize();; 4806 ; 4807 if (isGenreflex){; 4808 if (0 != selectionRules.CheckDuplicates()){; 4809 return 1;; 4810 }; 4811 }; 4812 ; 4813 // If we want to validate the selection only, we just quit.; 4814 if (gOptCheckSelectionSyntax); 4815 return 0;; 4816 ; 4817 //---------------------------------------------------------------------------; 4818 // Write schema evolution related headers and declarations; 4819 /////////////////////////////////////////////////////////////////////////////; 4820 ; 4821 if ((!ROOT::gReadRules.empty() || !ROOT::gReadRawRules.empty()) && !gOptIgnoreExistingDict) {; 4822 dictStream << ""#include \""TBuffer.h\""\n""; 4823 << ""#include \""TVirtualObject.h\""\n""; 4824 << ""#include <vector>\n""; 4825 << ""#include \""TSchemaHelper.h\""\n\n"";; 4826 ; 4827 std::list<std::string> includes;; 4828 GetRuleIncludes(includes);; 4829 for (auto & incFile : includes) {; 4830 dictStream << ""#include <"" << incFile << "">"" << std::endl;; 4831 }; 4832 dictStream << std::endl;; 4833 }; 4834 ; 4835 selectionRules.SearchNames(interp);; 4836 ; 4837 int scannerVerbLevel = 0;; 4838 {; 4839 using namespace ROOT::TMetaUtils;; 4840",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:285418,Security,inject,injected,285418,"(const clang::FieldDecl &m, int rwmode, std::ostream &dictStream)Create Streamer code for a standard string object.Definition rootcling_impl.cxx:1089; CreateDictHeadervoid CreateDictHeader(std::ostream &dictStream, const std::string &main_dictname)Definition rootcling_impl.cxx:2812; GetExePathconst char * GetExePath()Returns the executable path name, used e.g. by SetRootSys().Definition rootcling_impl.cxx:196; gPathSeparatorconst std::string gPathSeparator(ROOT::TMetaUtils::GetPathSeparator()); gOptBareClingSinkstatic llvm::cl::list< std::string > gOptBareClingSink(llvm::cl::OneOrMore, llvm::cl::Sink, llvm::cl::desc(""Consumes options and sends them to cling.""), llvm::cl::cat(gRootclingOptions), llvm::cl::sub(gBareClingSubcommand)); InheritsFromTObjectbool InheritsFromTObject(const clang::RecordDecl *cl, const cling::Interpreter &interp)Definition rootcling_impl.cxx:431; InjectModuleUtilHeaderstatic bool InjectModuleUtilHeader(const char *argv0, TModuleGenerator &modGen, cling::Interpreter &interp, bool umbrella)Write the extra header injected into the module: umbrella header if (umbrella) else content header.Definition rootcling_impl.cxx:1972; gOptModuleMapFilesstatic llvm::cl::list< std::string > gOptModuleMapFiles(""moduleMapFile"", llvm::cl::desc(""Specify a C++ modulemap file.""), llvm::cl::cat(gRootclingOptions)); ExtractClassesListAndDeclLinesint ExtractClassesListAndDeclLines(RScanner &scan, std::list< std::string > &classesList, std::list< std::string > &classesListForRootmap, std::list< std::string > &fwdDeclarationsList, const cling::Interpreter &interpreter)Definition rootcling_impl.cxx:2435; ParseRootMapFileNewFormatvoid ParseRootMapFileNewFormat(ifstream &file, map< string, string > &autoloads)Parse the rootmap and add entries to the autoload map, using the new format.Definition rootcling_impl.cxx:658; gRootclingOptionsstatic llvm::cl::OptionCategory gRootclingOptions(""rootcling common options""); gOptSysIncludePathsstatic llvm::cl::list< std::string > gOptS",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:9035,Testability,test,test,9035,"ules there are attributes and names with; 258 // which we can annotate.; 259 // We may look for a smarter algorithm.; 260 ; 261 // Nothing to do then ...; 262 if (fieldSelRules.empty()) return;; 263 ; 264 clang::ASTContext &C = decl.getASTContext();; 265 ; 266 const std::string declName(decl.getNameAsString());; 267 std::string varName;; 268 for (std::list<VariableSelectionRule>::const_iterator it = fieldSelRules.begin();; 269 it != fieldSelRules.end(); ++it) {; 270 if (! it->GetAttributeValue(propNames::name, varName)) continue;; 271 if (declName == varName) { // we have the rule!; 272 // Let's extract the attributes; 273 BaseSelectionRule::AttributesMap_t attrMap(it->GetAttributes());; 274 BaseSelectionRule::AttributesMap_t::iterator iter;; 275 std::string userDefinedProperty;; 276 for (iter = attrMap.begin(); iter != attrMap.end(); ++iter) {; 277 const std::string &name = iter->first;; 278 const std::string &value = iter->second;; 279 ; 280 if (name == propNames::name) continue;; 281 ; 282 /* This test is here since in ROOT5, when using genreflex,; 283 * for pods, iotype is ignored */; 284 ; 285 if (name == propNames::iotype &&; 286 (decl.getType()->isArrayType() || decl.getType()->isPointerType())) {; 287 const char *msg = ""Data member \""%s\"" is an array or a pointer. ""; 288 ""It is not possible to assign to it the iotype \""%s\"". ""; 289 ""This transformation is possible only with data members ""; 290 ""which are not pointers or arrays.\n"";; 291 ROOT::TMetaUtils::Error(""AnnotateFieldDecl"",; 292 msg, varName.c_str(), value.c_str());; 293 continue;; 294 }; 295 ; 296 ; 297 // These lines are here to use the root pcms. Indeed we need to annotate the AST; 298 // before persisting the ProtoClasses in the root pcms.; 299 // BEGIN ROOT PCMS; 300 if (name == propNames::comment) {; 301 decl.addAttr(clang::AnnotateAttr::CreateImplicit(C, value, nullptr, 0));; 302 }; 303 // END ROOT PCMS; 304 ; 305 if ((name == propNames::transient && value == ""true"") ||; 306 (name == propNames:",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:14752,Testability,assert,asserts,14752,"Attr::CreateImplicit(C, comment.str(), nullptr, 0));; 392 } else if (!isGenreflex) {; 393 // Here we check if we are in presence of a selection file so that; 394 // the comment does not ends up as a decoration in the AST,; 395 // Nevertheless, w/o PCMS this has no effect, since the headers; 396 // are parsed at runtime and the information in the AST dumped by; 397 // rootcling is not relevant.; 398 (*I)->addAttr(AnnotateAttr::CreateImplicit(C, comment.str(), nullptr, 0));; 399 }; 400 }; 401 // Match decls with sel rules if we are in presence of a selection file; 402 // and the cast was successful; 403 if (isGenreflex && thisClassSelectionRule != nullptr) {; 404 const std::list<VariableSelectionRule> &fieldSelRules = thisClassSelectionRule->GetFieldSelectionRules();; 405 ; 406 // This check is here to avoid asserts in debug mode (LLVMDEV env variable set); 407 if (FieldDecl *fieldDecl = dyn_cast<FieldDecl>(*I)) {; 408 AnnotateFieldDecl(*fieldDecl, fieldSelRules);; 409 }; 410 } // End presence of XML selection file; 411 }; 412 }; 413}; 414 ; 415////////////////////////////////////////////////////////////////////////////////; 416 ; 417size_t GetFullArrayLength(const clang::ConstantArrayType *arrayType); 418{; 419 if (!arrayType); 420 return 0;; 421 llvm::APInt len = arrayType->getSize();; 422 while (const clang::ConstantArrayType *subArrayType = llvm::dyn_cast<clang::ConstantArrayType>(arrayType->getArrayElementTypeNoTypeQual())) {; 423 len *= subArrayType->getSize();; 424 arrayType = subArrayType;; 425 }; 426 return len.getLimitedValue();; 427}; 428 ; 429////////////////////////////////////////////////////////////////////////////////; 430 ; 431bool InheritsFromTObject(const clang::RecordDecl *cl,; 432 const cling::Interpreter &interp); 433{; 434 static const clang::CXXRecordDecl *TObject_decl; 435 = ROOT::TMetaUtils::ScopeSearch(""TObject"", interp, true /*diag*/, nullptr);; 436 ; 437 const clang::CXXRecordDecl *clxx = llvm::dyn_cast<clang::CXXRecordDecl>(cl);; 438 retu",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:36133,Testability,assert,assert,36133,"ictStream << "" typedef "" << keyName << "" Value_t;"" << std::endl; 997 << "" std::pair<Value_t const, "" << tmplt_specialization->getTemplateArgs().get(1).getAsType().getAsString() << "" > R__t3(R__t,R__t2);"" << std::endl; 998 << "" R__stl.insert(R__t3);"" << std::endl;; 999 //fprintf(fp, "" R__stl.insert(%s::value_type(R__t,R__t2));\n"",stlType.c_str());; 1000 break;; 1001 }; 1002 case kSTLset:; 1003 case kSTLunorderedset:; 1004 case kSTLunorderedmultiset:; 1005 case kSTLmultiset:; 1006 dictStream << "" R__stl.insert(R__t);"" << std::endl;; 1007 break;; 1008 case kSTLvector:; 1009 case kSTLlist:; 1010 case kSTLdeque:; 1011 dictStream << "" R__stl.push_back(R__t);"" << std::endl;; 1012 break;; 1013 case kSTLforwardlist:; 1014 dictStream << "" R__stl.push_front(R__t);"" << std::endl;; 1015 break;; 1016 default:; 1017 assert(0);; 1018 }; 1019 dictStream << "" }"" << std::endl; 1020 << "" }"" << std::endl;; 1021 if (isArr) dictStream << "" }"" << std::endl;; 1022 ; 1023 } else {; 1024 ; 1025 // create write code; 1026 if (isArr) {; 1027 dictStream << "" for (Int_t R__l = 0; R__l < "" << len << ""; R__l++) {"" << std::endl;; 1028 }; 1029 dictStream << "" {"" << std::endl;; 1030 switch (pa) {; 1031 case 0: //No pointer && No array; 1032 dictStream << "" "" << stlType.c_str() << "" &R__stl = "" << stlName.c_str() << "";"" << std::endl;; 1033 break;; 1034 case 1: //No pointer && array; 1035 dictStream << "" "" << stlType.c_str() << "" &R__stl = "" << stlName.c_str() << ""[R__l];"" << std::endl;; 1036 break;; 1037 case 2: //pointer && No array; 1038 dictStream << "" "" << stlType.c_str() << "" &R__stl = **"" << stlName.c_str() << "";"" << std::endl;; 1039 break;; 1040 case 3: //pointer && array; 1041 dictStream << "" "" << stlType.c_str() << "" &R__stl = *"" << stlName.c_str() << ""[R__l];"" << std::endl;; 1042 break;; 1043 }; 1044 ; 1045 dictStream << "" int R__n=int(R__stl.size());"" << std::endl; 1046 << "" R__b << R__n;"" << std::endl; 1047 << "" if(R__n) {"" << std::endl;; 1048 ; 1049 if (tcl1) {; 1050 dictStream << "" TClass",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:58240,Testability,test,test,58240,";"" << std::endl;; 1491 }; 1492 }; 1493 }; 1494 // Stream data members; 1495 // Loop over the non static data member.; 1496 for (clang::RecordDecl::field_iterator field_iter = clxx->field_begin(), end = clxx->field_end();; 1497 field_iter != end;; 1498 ++field_iter) {; 1499 const char *comment = ROOT::TMetaUtils::GetComment(**field_iter).data();; 1500 ; 1501 clang::QualType type = field_iter->getType();; 1502 std::string type_name = type.getAsString(clxx->getASTContext().getPrintingPolicy());; 1503 ; 1504 const clang::Type *underling_type = ROOT::TMetaUtils::GetUnderlyingType(type);; 1505 ; 1506 // we skip:; 1507 // - static members; 1508 // - members with an ! as first character in the title (comment) field; 1509 ; 1510 //special case for Float16_t; 1511 int isFloat16 = 0;; 1512 if (strstr(type_name.c_str(), ""Float16_t"")) isFloat16 = 1;; 1513 ; 1514 //special case for Double32_t; 1515 int isDouble32 = 0;; 1516 if (strstr(type_name.c_str(), ""Double32_t"")) isDouble32 = 1;; 1517 ; 1518 // No need to test for static, there are not in this list.; 1519 if (strncmp(comment, ""!"", 1)) {; 1520 ; 1521 // fundamental type: short, int, long, etc....; 1522 if (underling_type->isFundamentalType() || underling_type->isEnumeralType()) {; 1523 if (type.getTypePtr()->isConstantArrayType() &&; 1524 type.getTypePtr()->getArrayElementTypeNoTypeQual()->isPointerType()) {; 1525 const clang::ConstantArrayType *arrayType = llvm::dyn_cast<clang::ConstantArrayType>(type.getTypePtr());; 1526 int s = GetFullArrayLength(arrayType);; 1527 ; 1528 if (!decli) {; 1529 dictStream << "" int R__i;"" << std::endl;; 1530 decli = 1;; 1531 }; 1532 dictStream << "" for (R__i = 0; R__i < "" << s << ""; R__i++)"" << std::endl;; 1533 if (i == 0) {; 1534 ROOT::TMetaUtils::Error(nullptr, ""*** Datamember %s::%s: array of pointers to fundamental type (need manual intervention)\n"", fullname.c_str(), field_iter->getName().str().c_str());; 1535 dictStream << "" ;//R__b.ReadArray("" << field_iter->getName().str() << "");"" << std",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:80634,Testability,assert,assert,80634,"lerInstance->createOutputFile(fileName, /*Binary=*/true,; 2011 /*RemoveFileOnSignal=*/false,; 2012 /*useTemporary=*/false,; 2013 /*CreateMissingDirectories*/ false);; 2014 if (!out) {; 2015 ROOT::TMetaUtils::Error(""WriteAST"", ""Couldn't open output stream to '%s'!\n"", fileName.data());; 2016 return false;; 2017 }; 2018 ; 2019 compilerInstance->getFrontendOpts().RelocatablePCH = true;; 2020 ; 2021 writer.WriteAST(compilerInstance->getSema(), fileName.str(), module, iSysRoot);; 2022 ; 2023 // Write the generated bitstream to ""Out"".; 2024 out->write(&buffer.front(), buffer.size());; 2025 ; 2026 // Make sure it hits disk now.; 2027 out->flush();; 2028 ; 2029 return true;; 2030}; 2031 ; 2032////////////////////////////////////////////////////////////////////////////////; 2033/// Generates a PCH from the given ModuleGenerator and CompilerInstance.; 2034/// Returns true iff the PCH was successfully generated.; 2035static bool GenerateAllDict(TModuleGenerator &modGen, clang::CompilerInstance *compilerInstance,; 2036 const std::string &currentDirectory); 2037{; 2038 assert(modGen.IsPCH() && ""modGen must be in PCH mode"");; 2039 ; 2040 std::string iSysRoot(""/DUMMY_SYSROOT/include/"");; 2041 if (gBuildingROOT) iSysRoot = (currentDirectory + ""/"");; 2042 return WriteAST(modGen.GetModuleFileName(), compilerInstance, iSysRoot);; 2043}; 2044 ; 2045////////////////////////////////////////////////////////////////////////////////; 2046/// Includes all given headers in the interpreter. Returns true when we could; 2047/// include the headers and otherwise false on an error when including.; 2048static bool IncludeHeaders(const std::vector<std::string> &headers, cling::Interpreter &interpreter); 2049{; 2050 // If no headers are given, this is a no-op.; 2051 if (headers.empty()); 2052 return true;; 2053 ; 2054 // Turn every header name into an include and parse it in the interpreter.; 2055 std::stringstream includes;; 2056 for (const std::string &header : headers) {; 2057 includes << ""#include",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:112959,Testability,assert,assert,112959,"foWriting(interp, writeEmptyRootPCM);; 2804 if (finRetCode != 0) return finRetCode;; 2805 }; 2806 ; 2807 return 0;; 2808}; 2809 ; 2810////////////////////////////////////////////////////////////////////////////////; 2811 ; 2812void CreateDictHeader(std::ostream &dictStream, const std::string &main_dictname); 2813{; 2814 dictStream << ""// Do NOT change. Changes will be lost next time file is generated\n\n""; 2815 << ""#define R__DICTIONARY_FILENAME "" << main_dictname << std::endl; 2816 ; 2817 // We do not want deprecation warnings to fire in dictionaries; 2818 << ""#define R__NO_DEPRECATION"" << std::endl; 2819 ; 2820 // Now that CINT is not longer there to write the header file,; 2821 // write one and include in there a few things for backward; 2822 // compatibility.; 2823 << ""\n/*******************************************************************/\n""; 2824 << ""#include <stddef.h>\n""; 2825 << ""#include <stdio.h>\n""; 2826 << ""#include <stdlib.h>\n""; 2827 << ""#include <string.h>\n""; 2828 << ""#include <assert.h>\n""; 2829 << ""#define G__DICTIONARY\n""; 2830 << ""#include \""ROOT/RConfig.hxx\""\n""; 2831 << ""#include \""TClass.h\""\n""; 2832 << ""#include \""TDictAttributeMap.h\""\n""; 2833 << ""#include \""TInterpreter.h\""\n""; 2834 << ""#include \""TROOT.h\""\n""; 2835 << ""#include \""TBuffer.h\""\n""; 2836 << ""#include \""TMemberInspector.h\""\n""; 2837 << ""#include \""TInterpreter.h\""\n""; 2838 << ""#include \""TVirtualMutex.h\""\n""; 2839 << ""#include \""TError.h\""\n\n""; 2840 << ""#ifndef G__ROOT\n""; 2841 << ""#define G__ROOT\n""; 2842 << ""#endif\n\n""; 2843 << ""#include \""RtypesImp.h\""\n""; 2844 << ""#include \""TIsAProxy.h\""\n""; 2845 << ""#include \""TFileMergeInfo.h\""\n""; 2846 << ""#include <algorithm>\n""; 2847 << ""#include \""TCollectionProxyInfo.h\""\n""; 2848 << ""/*******************************************************************/\n\n""; 2849 << ""#include \""TDataMember.h\""\n\n""; // To set their transiency; 2850}; 2851 ; 2852////////////////////////////////////////////////////////////////////////////////; 2853 ",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:140566,Testability,assert,assert,140566,"T::TMetaUtils::IsLinkdefFile(thisFileName.data());; 3509 if (isThisLinkdef) {; 3510 auto isTheIncludedLinkdef = ROOT::TMetaUtils::IsLinkdefFile(fileNameAsString.c_str());; 3511 if (isTheIncludedLinkdef) {; 3512 fFilesIncludedByLinkdef.clear();; 3513 isLocked = true;; 3514 } else {; 3515 fFilesIncludedByLinkdef.emplace_back(fileNameAsString.c_str());; 3516 }; 3517 }; 3518 }; 3519 ; 3520 // rootcling pre-includes things such as Rtypes.h. This means that ACLiC can; 3521 // call rootcling asking it to create a module for a file with no #includes; 3522 // but relying on things from Rtypes.h such as the ClassDef macro.; 3523 //; 3524 // When rootcling starts building a module, it becomes resilient to the; 3525 // outside environment and pre-included files have no effect. This hook; 3526 // informs rootcling when a new submodule is being built so that it can; 3527 // make Core.Rtypes.h visible.; 3528 void EnteredSubmodule(clang::Module* M,; 3529 clang::SourceLocation ImportLoc,; 3530 bool ForPragma) override {; 3531 assert(M);; 3532 using namespace clang;; 3533 if (llvm::StringRef(M->Name).endswith(""ACLiC_dict"")) {; 3534 Preprocessor& PP = m_Interpreter->getCI()->getPreprocessor();; 3535 HeaderSearch& HS = PP.getHeaderSearchInfo();; 3536 // FIXME: Reduce to Core.Rtypes.h.; 3537 Module* CoreModule = HS.lookupModule(""Core"", SourceLocation(),; 3538 /*AllowSearch*/false);; 3539 assert(M && ""Must have module Core"");; 3540 PP.makeModuleVisible(CoreModule, ImportLoc);; 3541 }; 3542 }; 3543};; 3544 ; 3545static llvm::cl::opt<bool> gOptSystemModuleByproducts(""mSystemByproducts"", llvm::cl::Hidden,; 3546 llvm::cl::desc(""Allow implicit build of system modules.""),; 3547 llvm::cl::cat(gRootclingOptions));; 3548static llvm::cl::list<std::string>; 3549gOptModuleByproducts(""mByproduct"", llvm::cl::ZeroOrMore,; 3550 llvm::cl::Hidden,; 3551 llvm::cl::desc(""The list of the expected implicit modules build as part of building the current module.""),; 3552 llvm::cl::cat(gRootclingOptions));; 3553/",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:140931,Testability,assert,assert,140931," 3519 ; 3520 // rootcling pre-includes things such as Rtypes.h. This means that ACLiC can; 3521 // call rootcling asking it to create a module for a file with no #includes; 3522 // but relying on things from Rtypes.h such as the ClassDef macro.; 3523 //; 3524 // When rootcling starts building a module, it becomes resilient to the; 3525 // outside environment and pre-included files have no effect. This hook; 3526 // informs rootcling when a new submodule is being built so that it can; 3527 // make Core.Rtypes.h visible.; 3528 void EnteredSubmodule(clang::Module* M,; 3529 clang::SourceLocation ImportLoc,; 3530 bool ForPragma) override {; 3531 assert(M);; 3532 using namespace clang;; 3533 if (llvm::StringRef(M->Name).endswith(""ACLiC_dict"")) {; 3534 Preprocessor& PP = m_Interpreter->getCI()->getPreprocessor();; 3535 HeaderSearch& HS = PP.getHeaderSearchInfo();; 3536 // FIXME: Reduce to Core.Rtypes.h.; 3537 Module* CoreModule = HS.lookupModule(""Core"", SourceLocation(),; 3538 /*AllowSearch*/false);; 3539 assert(M && ""Must have module Core"");; 3540 PP.makeModuleVisible(CoreModule, ImportLoc);; 3541 }; 3542 }; 3543};; 3544 ; 3545static llvm::cl::opt<bool> gOptSystemModuleByproducts(""mSystemByproducts"", llvm::cl::Hidden,; 3546 llvm::cl::desc(""Allow implicit build of system modules.""),; 3547 llvm::cl::cat(gRootclingOptions));; 3548static llvm::cl::list<std::string>; 3549gOptModuleByproducts(""mByproduct"", llvm::cl::ZeroOrMore,; 3550 llvm::cl::Hidden,; 3551 llvm::cl::desc(""The list of the expected implicit modules build as part of building the current module.""),; 3552 llvm::cl::cat(gRootclingOptions));; 3553// Really llvm::cl::Required, will be changed in RootClingMain below.; 3554static llvm::cl::opt<std::string>; 3555gOptDictionaryFileName(llvm::cl::Positional,; 3556 llvm::cl::desc(""<output dictionary file>""),; 3557 llvm::cl::cat(gRootclingOptions));; 3558 ; 3559////////////////////////////////////////////////////////////////////////////////; 3560/// Custom diag client for cla",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:176412,Testability,assert,assert,176412,"ang"");; 4317 clingArgsInterpreter.push_back(""-fmodule-feature"");; 4318 clingArgsInterpreter.push_back(""-Xclang"");; 4319 clingArgsInterpreter.push_back(""msvc"" + std::string(rootclingStringify(_MSC_VER)));; 4320#endif; 4321 clingArgsInterpreter.push_back(""-fmodule-name="" + moduleName.str());; 4322 ; 4323 std::string moduleCachePath = llvm::sys::path::parent_path(gOptSharedLibFileName).str();; 4324 // FIXME: This is a horrible workaround to fix the incremental builds.; 4325 // The enumerated modules are built by clang impicitly based on #include of; 4326 // a header which is contained within that module. The build system has; 4327 // no way to track dependencies on them and trigger a rebuild.; 4328 // A possible solution can be to disable completely the implicit build of; 4329 // modules and each module to be built by rootcling. We need to teach; 4330 // rootcling how to build modules with no IO support.; 4331 if (moduleName == ""Core"") {; 4332 assert(gDriverConfig->fBuildingROOTStage1);; 4333 remove((moduleCachePath + llvm::sys::path::get_separator() + ""_Builtin_intrinsics.pcm"").str().c_str());; 4334 remove((moduleCachePath + llvm::sys::path::get_separator() + ""_Builtin_stddef_max_align_t.pcm"").str().c_str());; 4335 remove((moduleCachePath + llvm::sys::path::get_separator() + ""Cling_Runtime.pcm"").str().c_str());; 4336 remove((moduleCachePath + llvm::sys::path::get_separator() + ""Cling_Runtime_Extra.pcm"").str().c_str());; 4337#ifdef R__WIN32; 4338 remove((moduleCachePath + llvm::sys::path::get_separator() + ""vcruntime.pcm"").str().c_str());; 4339 remove((moduleCachePath + llvm::sys::path::get_separator() + ""services.pcm"").str().c_str());; 4340#endif; 4341 ; 4342#ifdef R__MACOSX; 4343 remove((moduleCachePath + llvm::sys::path::get_separator() + ""Darwin.pcm"").str().c_str());; 4344#else; 4345 remove((moduleCachePath + llvm::sys::path::get_separator() + ""libc.pcm"").str().c_str());; 4346#endif; 4347 remove((moduleCachePath + llvm::sys::path::get_separator() + ""std.pcm"").str().",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:183560,Testability,assert,assert,183560,".def""; 4447 ROOT::TMetaUtils::Info(nullptr, ""==== END interpreter configuration ====\n\n"");; 4448 }; 4449 ; 4450 interp.getOptions().ErrorOut = true;; 4451 interp.enableRawInput(true);; 4452 ; 4453 if (gOptCxxModule) {; 4454 for (llvm::StringRef DepMod : gOptModuleDependencies) {; 4455 if (DepMod.endswith(""_rdict.pcm"")) {; 4456 ROOT::TMetaUtils::Warning(nullptr, ""'%s' value is deprecated. Please use [<fullpath>]%s.pcm\n"",; 4457 DepMod.data(),; 4458 GetModuleNameFromRdictName(DepMod).str().data());; 4459 }; 4460 DepMod = GetModuleNameFromRdictName(DepMod);; 4461 // We might deserialize.; 4462 cling::Interpreter::PushTransactionRAII RAII(&interp);; 4463 if (!interp.loadModule(DepMod.str(), /*complain*/false)) {; 4464 ROOT::TMetaUtils::Error(nullptr, ""Module '%s' failed to load.\n"",; 4465 DepMod.data());; 4466 }; 4467 }; 4468 }; 4469 ; 4470 if (!isGenreflex) { // rootcling; 4471 // ROOTCINT uses to define a few header implicitly, we need to do it explicitly.; 4472 if (interp.declare(""#include <assert.h>\n""; 4473 ""#include \""Rtypes.h\""\n""; 4474 ""#include \""TObject.h\"""") != cling::Interpreter::kSuccess; 4475 ) {; 4476 // There was an error.; 4477 ROOT::TMetaUtils::Error(nullptr, ""Error loading the default rootcling header files.\n"");; 4478 return 1;; 4479 }; 4480 }; 4481 ; 4482 if (interp.declare(""#include <string>\n"" // For the list of 'opaque' typedef to also include string.; 4483 ""#include <RtypesCore.h>\n"" // For initializing TNormalizedCtxt.; 4484 ""namespace std {} using namespace std;"") != cling::Interpreter::kSuccess) {; 4485 ROOT::TMetaUtils::Error(nullptr, ""Error loading the default header files.\n"");; 4486 return 1;; 4487 }; 4488 ; 4489 // We are now ready (enough is loaded) to init the list of opaque typedefs.; 4490 ROOT::TMetaUtils::TNormalizedCtxt normCtxt(interp.getLookupHelper());; 4491 ROOT::TMetaUtils::TClingLookupHelper helper(interp, normCtxt, nullptr, nullptr, nullptr);; 4492 TClassEdit::Init(&helper);; 4493 ; 4494 // flags used only for the pragma pa",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:217493,Testability,test,test,217493,"nterpreter only dictionaries; 5368 if (interpreteronly); 5369 argvVector.push_back(string2charptr(""-interpreteronly""));; 5370 ; 5371 // Split dictionaries; 5372 if (doSplit); 5373 argvVector.push_back(string2charptr(""-split""));; 5374 ; 5375 // Targetlib; 5376 if (!targetLibName.empty()) {; 5377 argvVector.push_back(string2charptr(""-s""));; 5378 argvVector.push_back(string2charptr(targetLibName));; 5379 }; 5380 ; 5381 // Multidict support; 5382 if (multiDict); 5383 argvVector.push_back(string2charptr(""-multiDict""));; 5384 ; 5385 // Don't declare ""using namespace std""; 5386 if (noGlobalUsingStd); 5387 argvVector.push_back(string2charptr(""-noGlobalUsingStd""));; 5388 ; 5389 ; 5390 AddToArgVectorSplit(argvVector, pcmsNames, ""-m"");; 5391 ; 5392 // Inline the input header; 5393 argvVector.push_back(string2charptr(""-inlineInputHeader""));; 5394 ; 5395 // Write empty root pcms; 5396 if (writeEmptyRootPCM); 5397 argvVector.push_back(string2charptr(""-writeEmptyRootPCM""));; 5398 ; 5399 // Just test the syntax of the selection file; 5400 if (selSyntaxOnly); 5401 argvVector.push_back(string2charptr(""-selSyntaxOnly""));; 5402 ; 5403 // No include paths; 5404 if (noIncludePaths); 5405 argvVector.push_back(string2charptr(""-noIncludePaths""));; 5406 ; 5407 // Fail on warnings; 5408 if (failOnWarnings); 5409 argvVector.push_back(string2charptr(""-failOnWarnings""));; 5410 ; 5411 // Clingargs; 5412 AddToArgVector(argvVector, includes, ""-I"");; 5413 AddToArgVector(argvVector, preprocDefines, ""-D"");; 5414 AddToArgVector(argvVector, preprocUndefines, ""-U"");; 5415 AddToArgVector(argvVector, warnings, ""-W"");; 5416 ; 5417 AddToArgVector(argvVector, headersNames);; 5418 ; 5419 if (!selectionFileName.empty()) {; 5420 argvVector.push_back(string2charptr(selectionFileName));; 5421 }; 5422 ; 5423 const int argc = argvVector.size();; 5424 ; 5425 // Output commandline for rootcling; 5426 if (genreflex::verbose || printRootclingInvocation) {; 5427 std::string cmd;; 5428 for (int i = 0; i < argc; i++) {; 54",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:238264,Testability,test,testing,238264,"tion length.; 6011 // For example, --selection_file can be abbreviated with --sele at least.; 6012 ; 6013 ROOT::option::Parser parse(genreflexUsageDescriptor, argc, argv, &options[0], &buffer[0], 5);; 6014 ; 6015 if (parse.error()) {; 6016 ROOT::TMetaUtils::Error(nullptr, ""Argument parsing error!\n"");; 6017 return 1;; 6018 }; 6019 ; 6020 // Print help if needed; 6021 if (options[HELP] || originalArgc == 1) {; 6022 ROOT::option::printUsage(std::cout, genreflexUsageDescriptor);; 6023 return 0;; 6024 }; 6025 // See if no header was provided; 6026 int numberOfHeaders = checkHeadersNames(headersNames);; 6027 if (0 == numberOfHeaders) {; 6028 ROOT::TMetaUtils::Error(nullptr, ""No valid header was provided!\n"");; 6029 return 1;; 6030 }; 6031 ; 6032 ROOT::TMetaUtils::GetErrorIgnoreLevel() = ROOT::TMetaUtils::kNote;; 6033 ; 6034 if (options[DEEP]); 6035 ROOT::TMetaUtils::Warning(nullptr, ""--deep has no effect. Please remove the deprecated flag!\n"");; 6036 // The verbosity: debug wins over quiet; 6037 //std::string verbosityOption(""-v4""); // To be uncommented for the testing phase. It should be -v; 6038 std::string verbosityOption(""-v2"");; 6039 if (options[SILENT]) verbosityOption = ""-v0"";; 6040 if (options[VERBOSE] || getenv (""VERBOSE"")) verbosityOption = ""-v3"";; 6041 if (options[DEBUG]) verbosityOption = ""-v4"";; 6042 ; 6043 genreflex::verbose = verbosityOption == ""-v4"";; 6044 ; 6045 // The selection file; 6046 std::string selectionFileName;; 6047 if (options[SELECTIONFILENAME]) {; 6048 selectionFileName = options[SELECTIONFILENAME].arg;; 6049 if (!ROOT::TMetaUtils::EndsWith(selectionFileName, "".xml"")) {; 6050 ROOT::TMetaUtils::Error(nullptr,; 6051 ""Invalid selection file extension: filename is %s and extension .xml is expected!\n"",; 6052 selectionFileName.c_str());; 6053 return 1;; 6054 }; 6055 }; 6056 ; 6057// // Warn if a selection file is not present and exit; 6058// if (NULL==options[SELECTIONFILENAME].arg){; 6059// ROOT::TMetaUtils::Warning(0,""The usage of genreflex wit",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:244428,Testability,assert,assert,244428,"n,; 6171 selectionFileName,; 6172 targetLibName,; 6173 multidict,; 6174 pcmsNames,; 6175 includes,; 6176 preprocDefines,; 6177 preprocUndefines,; 6178 warnings,; 6179 rootmapFileName,; 6180 rootmapLibName,; 6181 interpreteronly,; 6182 doSplit,; 6183 isCxxmodule,; 6184 writeEmptyRootPCM,; 6185 selSyntaxOnly,; 6186 noIncludePaths,; 6187 noGlobalUsingStd,; 6188 headersNames,; 6189 failOnWarnings,; 6190 printRootclingInvocation,; 6191 ofileName);; 6192 } else {; 6193 // Here ofilename is either """" or a directory: this is irrelevant.; 6194 returnValue = invokeManyRootCling(verbosityOption,; 6195 selectionFileName,; 6196 targetLibName,; 6197 multidict,; 6198 pcmsNames,; 6199 includes,; 6200 preprocDefines,; 6201 preprocUndefines,; 6202 warnings,; 6203 rootmapFileName,; 6204 rootmapLibName,; 6205 interpreteronly,; 6206 doSplit,; 6207 isCxxmodule,; 6208 writeEmptyRootPCM,; 6209 selSyntaxOnly,; 6210 noIncludePaths,; 6211 noGlobalUsingStd,; 6212 headersNames,; 6213 failOnWarnings,; 6214 printRootclingInvocation,; 6215 ofileName);; 6216 }; 6217 ; 6218 return returnValue;; 6219}; 6220 ; 6221 ; 6222////////////////////////////////////////////////////////////////////////////////; 6223 ; 6224extern ""C""; 6225int ROOT_rootcling_Driver(int argc, char **argv, const ROOT::Internal::RootCling::DriverConfig& config); 6226{; 6227 ; 6228 assert(!gDriverConfig && ""Driver configuration already set!"");; 6229 gDriverConfig = &config;; 6230 ; 6231 gBuildingROOT = config.fBuildingROOTStage1; // gets refined later; 6232 ; 6233 std::string exeName = ExtractFileName(GetExePath());; 6234#ifdef __APPLE__; 6235 // _dyld_get_image_name() on macOS11 and later sometimes returns ""rootcling"" for ""genreflex"".; 6236 // Fix that (while still initializing the binary path, needed for ROOTSYS) by updating the; 6237 // exeName to argv[0]:; 6238 exeName = ExtractFileName(argv[0]);; 6239#endif; 6240 ; 6241 // Select according to the name of the executable the procedure to follow:; 6242 // 1) RootCling; 6243 // 2) G",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:24331,Usability,clear,clear,24331,""");; 678 } else if (0 != keyLenMap.count(firstChar)) {; 679 unsigned int keyLen = keyLenMap.at(firstChar);; 680 keyname = line.substr(keyLen, line.length() - keyLen);; 681 CheckClassNameForRootMap(keyname, autoloads);; 682 autoloads[keyname] = libs;; 683 }; 684 }; 685 ; 686}; 687 ; 688////////////////////////////////////////////////////////////////////////////////; 689/// Fill the map of libraries to be loaded in presence of a class; 690/// Transparently support the old and new rootmap file format; 691 ; 692void LoadLibraryMap(const std::string &fileListName, map<string, string> &autoloads); 693{; 694 std::ifstream filelist(fileListName.c_str());; 695 ; 696 std::string filename;; 697 std::string line;; 698 ; 699 while (filelist >> filename) {; 700 ; 701 if (llvm::sys::fs::is_directory(filename)) continue;; 702 ; 703 ifstream file(filename.c_str());; 704 ; 705 // Check which format is this; 706 file >> line;; 707 bool new_format = (line[0] == '[' || line[0] == '{') ;; 708 file.clear();; 709 file.seekg(0, std::ios::beg);; 710 ; 711 // Now act; 712 if (new_format) {; 713 ParseRootMapFileNewFormat(file, autoloads);; 714 } else {; 715 ParseRootMapFile(file, autoloads);; 716 }; 717 ; 718 file.close();; 719 ; 720 } // end loop on files; 721 filelist.close();; 722}; 723 ; 724////////////////////////////////////////////////////////////////////////////////; 725/// Check if the specified operator (what) has been properly declared if the user has; 726/// requested a custom version.; 727 ; 728bool CheckInputOperator(const char *what,; 729 const char *proto,; 730 const string &fullname,; 731 const clang::RecordDecl *cl,; 732 cling::Interpreter &interp); 733{; 734 ; 735 const clang::FunctionDecl *method; 736 = ROOT::TMetaUtils::GetFuncWithProto(llvm::dyn_cast<clang::Decl>(cl->getDeclContext()), what, proto, interp,; 737 false /*diags*/);; 738 if (!method) {; 739 // This intended to find the global scope.; 740 clang::TranslationUnitDecl *TU =; 741 cl->getASTContext().getTranslationU",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:33516,Usability,clear,clear,33516,"{; 928 case 0: //No pointer && No array; 929 dictStream << "" "" << stlType.c_str() << "" &R__stl = "" << stlName.c_str() << "";"" << std::endl;; 930 break;; 931 case 1: //No pointer && array; 932 dictStream << "" "" << stlType.c_str() << "" &R__stl = "" << stlName.c_str() << ""[R__l];"" << std::endl;; 933 break;; 934 case 2: //pointer && No array; 935 dictStream << "" delete *"" << stlName.c_str() << "";"" << std::endl; 936 << "" *"" << stlName.c_str() << "" = new "" << stlType.c_str() << "";"" << std::endl; 937 << "" "" << stlType.c_str() << "" &R__stl = **"" << stlName.c_str() << "";"" << std::endl;; 938 break;; 939 case 3: //pointer && array; 940 dictStream << "" delete "" << stlName.c_str() << ""[R__l];"" << std::endl; 941 << "" "" << stlName.c_str() << ""[R__l] = new "" << stlType.c_str() << "";"" << std::endl; 942 << "" "" << stlType.c_str() << "" &R__stl = *"" << stlName.c_str() << ""[R__l];"" << std::endl;; 943 break;; 944 }; 945 ; 946 dictStream << "" R__stl.clear();"" << std::endl;; 947 ; 948 if (tcl1) {; 949 dictStream << "" TClass *R__tcl1 = TBuffer::GetClass(typeid("" << fulName1.c_str() << ""));"" << std::endl; 950 << "" if (R__tcl1==0) {"" << std::endl; 951 << "" Error(\"""" << stlName.c_str() << "" streamer\"",\""Missing the TClass object for ""; 952 << fulName1.c_str() << ""!\"");"" << std::endl; 953 << "" return;"" << std::endl; 954 << "" }"" << std::endl;; 955 }; 956 if (tcl2) {; 957 dictStream << "" TClass *R__tcl2 = TBuffer::GetClass(typeid("" << fulName2.c_str() << ""));"" << std::endl; 958 << "" if (R__tcl2==0) {"" << std::endl; 959 << "" Error(\"""" << stlName.c_str() << "" streamer\"",\""Missing the TClass object for ""; 960 << fulName2.c_str() << ""!\"");"" << std::endl; 961 << "" return;"" << std::endl; 962 << "" }"" << std::endl;; 963 }; 964 ; 965 dictStream << "" int R__i, R__n;"" << std::endl; 966 << "" R__b >> R__n;"" << std::endl;; 967 ; 968 if (stltype == kSTLvector) {; 969 dictStream << "" R__stl.reserve(R__n);"" << std::endl;; 970 }; 971 dictStream << "" for (R__i = 0; R__i < R__n; R__i++) {"" << std::endl;; 972 ; 973 ROOT:",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:128543,Usability,clear,clear,128543,"turn false;; 3215}; 3216 ; 3217////////////////////////////////////////////////////////////////////////////////; 3218 ; 3219void ExtractHeadersForDecls(const RScanner::ClassColl_t &annotatedRcds,; 3220 const RScanner::TypedefColl_t tDefDecls,; 3221 const RScanner::FunctionColl_t funcDecls,; 3222 const RScanner::VariableColl_t varDecls,; 3223 const RScanner::EnumColl_t enumDecls,; 3224 HeadersDeclsMap_t &headersClassesMap,; 3225 HeadersDeclsMap_t &headersDeclsMap,; 3226 const cling::Interpreter &interp); 3227{; 3228 std::set<const clang::CXXRecordDecl *> visitedDecls;; 3229 std::unordered_set<std::string> buffer;; 3230 std::string autoParseKey;; 3231 ; 3232 // Add some manip of headers; 3233 for (auto & annotatedRcd : annotatedRcds) {; 3234 if (const clang::CXXRecordDecl *cxxRcd =; 3235 llvm::dyn_cast_or_null<clang::CXXRecordDecl>(annotatedRcd.GetRecordDecl())) {; 3236 autoParseKey = """";; 3237 visitedDecls.clear();; 3238 std::list<std::string> headers(RecordDecl2Headers(*cxxRcd, interp, visitedDecls));; 3239 // remove duplicates, also if not subsequent; 3240 buffer.clear();; 3241 headers.remove_if([&buffer](const std::string & s) {; 3242 return !buffer.insert(s).second;; 3243 });; 3244 GetMostExternalEnclosingClassName(*cxxRcd, autoParseKey, interp);; 3245 if (autoParseKey.empty()) autoParseKey = annotatedRcd.GetNormalizedName();; 3246 if (IsGoodForAutoParseMap(*cxxRcd)){; 3247 headersDeclsMap[autoParseKey] = headers;; 3248 headersDeclsMap[annotatedRcd.GetRequestedName()] = headers;; 3249 } else {; 3250 ROOT::TMetaUtils::Info(nullptr, ""Class %s is not included in the set of autoparse keys.\n"", autoParseKey.c_str());; 3251 }; 3252 ; 3253 // Propagate to the classes map only if this is not a template.; 3254 // The header is then used as autoload key and we want to avoid duplicates.; 3255 if (!llvm::isa<clang::ClassTemplateSpecializationDecl>(cxxRcd)){; 3256 headersClassesMap[autoParseKey] = headersDeclsMap[autoParseKey];; 3257 headersClassesMap[annotatedRcd.GetRequeste",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:128705,Usability,clear,clear,128705,"///////////////////; 3218 ; 3219void ExtractHeadersForDecls(const RScanner::ClassColl_t &annotatedRcds,; 3220 const RScanner::TypedefColl_t tDefDecls,; 3221 const RScanner::FunctionColl_t funcDecls,; 3222 const RScanner::VariableColl_t varDecls,; 3223 const RScanner::EnumColl_t enumDecls,; 3224 HeadersDeclsMap_t &headersClassesMap,; 3225 HeadersDeclsMap_t &headersDeclsMap,; 3226 const cling::Interpreter &interp); 3227{; 3228 std::set<const clang::CXXRecordDecl *> visitedDecls;; 3229 std::unordered_set<std::string> buffer;; 3230 std::string autoParseKey;; 3231 ; 3232 // Add some manip of headers; 3233 for (auto & annotatedRcd : annotatedRcds) {; 3234 if (const clang::CXXRecordDecl *cxxRcd =; 3235 llvm::dyn_cast_or_null<clang::CXXRecordDecl>(annotatedRcd.GetRecordDecl())) {; 3236 autoParseKey = """";; 3237 visitedDecls.clear();; 3238 std::list<std::string> headers(RecordDecl2Headers(*cxxRcd, interp, visitedDecls));; 3239 // remove duplicates, also if not subsequent; 3240 buffer.clear();; 3241 headers.remove_if([&buffer](const std::string & s) {; 3242 return !buffer.insert(s).second;; 3243 });; 3244 GetMostExternalEnclosingClassName(*cxxRcd, autoParseKey, interp);; 3245 if (autoParseKey.empty()) autoParseKey = annotatedRcd.GetNormalizedName();; 3246 if (IsGoodForAutoParseMap(*cxxRcd)){; 3247 headersDeclsMap[autoParseKey] = headers;; 3248 headersDeclsMap[annotatedRcd.GetRequestedName()] = headers;; 3249 } else {; 3250 ROOT::TMetaUtils::Info(nullptr, ""Class %s is not included in the set of autoparse keys.\n"", autoParseKey.c_str());; 3251 }; 3252 ; 3253 // Propagate to the classes map only if this is not a template.; 3254 // The header is then used as autoload key and we want to avoid duplicates.; 3255 if (!llvm::isa<clang::ClassTemplateSpecializationDecl>(cxxRcd)){; 3256 headersClassesMap[autoParseKey] = headersDeclsMap[autoParseKey];; 3257 headersClassesMap[annotatedRcd.GetRequestedName()] = headersDeclsMap[annotatedRcd.GetRequestedName()];; 3258 }; 3259 }; 3260 }; 3261 ; ",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:129926,Usability,clear,clear,129926,"f (IsGoodForAutoParseMap(*cxxRcd)){; 3247 headersDeclsMap[autoParseKey] = headers;; 3248 headersDeclsMap[annotatedRcd.GetRequestedName()] = headers;; 3249 } else {; 3250 ROOT::TMetaUtils::Info(nullptr, ""Class %s is not included in the set of autoparse keys.\n"", autoParseKey.c_str());; 3251 }; 3252 ; 3253 // Propagate to the classes map only if this is not a template.; 3254 // The header is then used as autoload key and we want to avoid duplicates.; 3255 if (!llvm::isa<clang::ClassTemplateSpecializationDecl>(cxxRcd)){; 3256 headersClassesMap[autoParseKey] = headersDeclsMap[autoParseKey];; 3257 headersClassesMap[annotatedRcd.GetRequestedName()] = headersDeclsMap[annotatedRcd.GetRequestedName()];; 3258 }; 3259 }; 3260 }; 3261 ; 3262 // The same for the typedefs:; 3263 for (auto & tDef : tDefDecls) {; 3264 if (clang::CXXRecordDecl *cxxRcd = tDef->getUnderlyingType()->getAsCXXRecordDecl()) {; 3265 autoParseKey = """";; 3266 visitedDecls.clear();; 3267 std::list<std::string> headers(RecordDecl2Headers(*cxxRcd, interp, visitedDecls));; 3268 headers.push_back(ROOT::TMetaUtils::GetFileName(*tDef, interp));; 3269 // remove duplicates, also if not subsequent; 3270 buffer.clear();; 3271 headers.remove_if([&buffer](const std::string & s) {; 3272 return !buffer.insert(s).second;; 3273 });; 3274 GetMostExternalEnclosingClassNameFromDecl(*tDef, autoParseKey, interp);; 3275 if (autoParseKey.empty()) autoParseKey = tDef->getQualifiedNameAsString();; 3276 headersDeclsMap[autoParseKey] = headers;; 3277 }; 3278 }; 3279 ; 3280 // The same for the functions:; 3281 for (auto & func : funcDecls) {; 3282 std::list<std::string> headers = {ROOT::TMetaUtils::GetFileName(*func, interp)};; 3283 headersDeclsMap[ROOT::TMetaUtils::GetQualifiedName(*func)] = headers;; 3284 }; 3285 ; 3286 // The same for the variables:; 3287 for (auto & var : varDecls) {; 3288 std::list<std::string> headers = {ROOT::TMetaUtils::GetFileName(*var, interp)};; 3289 headersDeclsMap[ROOT::TMetaUtils::GetQualifiedName(*var)] =",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:130159,Usability,clear,clear,130159,"Info(nullptr, ""Class %s is not included in the set of autoparse keys.\n"", autoParseKey.c_str());; 3251 }; 3252 ; 3253 // Propagate to the classes map only if this is not a template.; 3254 // The header is then used as autoload key and we want to avoid duplicates.; 3255 if (!llvm::isa<clang::ClassTemplateSpecializationDecl>(cxxRcd)){; 3256 headersClassesMap[autoParseKey] = headersDeclsMap[autoParseKey];; 3257 headersClassesMap[annotatedRcd.GetRequestedName()] = headersDeclsMap[annotatedRcd.GetRequestedName()];; 3258 }; 3259 }; 3260 }; 3261 ; 3262 // The same for the typedefs:; 3263 for (auto & tDef : tDefDecls) {; 3264 if (clang::CXXRecordDecl *cxxRcd = tDef->getUnderlyingType()->getAsCXXRecordDecl()) {; 3265 autoParseKey = """";; 3266 visitedDecls.clear();; 3267 std::list<std::string> headers(RecordDecl2Headers(*cxxRcd, interp, visitedDecls));; 3268 headers.push_back(ROOT::TMetaUtils::GetFileName(*tDef, interp));; 3269 // remove duplicates, also if not subsequent; 3270 buffer.clear();; 3271 headers.remove_if([&buffer](const std::string & s) {; 3272 return !buffer.insert(s).second;; 3273 });; 3274 GetMostExternalEnclosingClassNameFromDecl(*tDef, autoParseKey, interp);; 3275 if (autoParseKey.empty()) autoParseKey = tDef->getQualifiedNameAsString();; 3276 headersDeclsMap[autoParseKey] = headers;; 3277 }; 3278 }; 3279 ; 3280 // The same for the functions:; 3281 for (auto & func : funcDecls) {; 3282 std::list<std::string> headers = {ROOT::TMetaUtils::GetFileName(*func, interp)};; 3283 headersDeclsMap[ROOT::TMetaUtils::GetQualifiedName(*func)] = headers;; 3284 }; 3285 ; 3286 // The same for the variables:; 3287 for (auto & var : varDecls) {; 3288 std::list<std::string> headers = {ROOT::TMetaUtils::GetFileName(*var, interp)};; 3289 headersDeclsMap[ROOT::TMetaUtils::GetQualifiedName(*var)] = headers;; 3290 }; 3291 ; 3292 // The same for the enums:; 3293 for (auto & en : enumDecls) {; 3294 std::list<std::string> headers = {ROOT::TMetaUtils::GetFileName(*en, interp)};; 3295 head",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:139776,Usability,clear,clear,139776," & /*IncludeTok*/,; 3494 llvm::StringRef FileName, bool IsAngled, clang::CharSourceRange /*FilenameRange*/,; 3495 clang::OptionalFileEntryRef /*File*/, llvm::StringRef /*SearchPath*/,; 3496 llvm::StringRef /*RelativePath*/, const clang::Module * /*Imported*/,; 3497 clang::SrcMgr::CharacteristicKind /*FileType*/) override; 3498 {; 3499 if (isLocked) return;; 3500 if (IsAngled) return;; 3501 auto& PP = m_Interpreter->getCI()->getPreprocessor();; 3502 auto curLexer = PP.getCurrentFileLexer();; 3503 if (!curLexer) return;; 3504 auto fileEntry = curLexer->getFileEntry();; 3505 if (!fileEntry) return;; 3506 auto thisFileName = fileEntry->getName();; 3507 auto fileNameAsString = FileName.str();; 3508 auto isThisLinkdef = ROOT::TMetaUtils::IsLinkdefFile(thisFileName.data());; 3509 if (isThisLinkdef) {; 3510 auto isTheIncludedLinkdef = ROOT::TMetaUtils::IsLinkdefFile(fileNameAsString.c_str());; 3511 if (isTheIncludedLinkdef) {; 3512 fFilesIncludedByLinkdef.clear();; 3513 isLocked = true;; 3514 } else {; 3515 fFilesIncludedByLinkdef.emplace_back(fileNameAsString.c_str());; 3516 }; 3517 }; 3518 }; 3519 ; 3520 // rootcling pre-includes things such as Rtypes.h. This means that ACLiC can; 3521 // call rootcling asking it to create a module for a file with no #includes; 3522 // but relying on things from Rtypes.h such as the ClassDef macro.; 3523 //; 3524 // When rootcling starts building a module, it becomes resilient to the; 3525 // outside environment and pre-included files have no effect. This hook; 3526 // informs rootcling when a new submodule is being built so that it can; 3527 // make Core.Rtypes.h visible.; 3528 void EnteredSubmodule(clang::Module* M,; 3529 clang::SourceLocation ImportLoc,; 3530 bool ForPragma) override {; 3531 assert(M);; 3532 using namespace clang;; 3533 if (llvm::StringRef(M->Name).endswith(""ACLiC_dict"")) {; 3534 Preprocessor& PP = m_Interpreter->getCI()->getPreprocessor();; 3535 HeaderSearch& HS = PP.getHeaderSearchInfo();; 3536 // FIXME: Reduce to Cor",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:145866,Usability,clear,clear,145866,"fo);; 3636 ; 3637 if (ID == remark_module_build && !isByproductModule) {; 3638 ROOT::TMetaUtils::Error(nullptr,; 3639 ""Building module '%s' implicitly. If '%s' requires a \n""; 3640 ""dictionary please specify build dependency: '%s' depends on '%s'.\n""; 3641 ""Otherwise, specify '-mByproduct %s' to disable this diagnostic.\n"",; 3642 moduleName.c_str(), moduleName.c_str(), gOptDictionaryFileName.c_str(),; 3643 moduleName.c_str(), moduleName.c_str());; 3644 }; 3645 }; 3646 ; 3647 // All methods below just forward to the child and the default method.; 3648 virtual void clear() override; 3649 {; 3650 fChild->clear();; 3651 DiagnosticConsumer::clear();; 3652 }; 3653 ; 3654 virtual void BeginSourceFile(const clang::LangOptions &LangOpts, const clang::Preprocessor *PP) override; 3655 {; 3656 fChild->BeginSourceFile(LangOpts, PP);; 3657 DiagnosticConsumer::BeginSourceFile(LangOpts, PP);; 3658 }; 3659 ; 3660 virtual void EndSourceFile() override; 3661 {; 3662 fChild->EndSourceFile();; 3663 DiagnosticConsumer::EndSourceFile();; 3664 }; 3665 ; 3666 virtual void finish() override; 3667 {; 3668 fChild->finish();; 3669 DiagnosticConsumer::finish();; 3670 }; 3671 ; 3672 virtual bool IncludeInDiagnosticCounts() const override { return fChild->IncludeInDiagnosticCounts(); }; 3673};; 3674 ; 3675static void MaybeSuppressWin32CrashDialogs() {; 3676#if defined(_WIN32) && defined(_MSC_VER); 3677 // Suppress error dialogs to avoid hangs on build nodes.; 3678 // One can use an environment variable (Cling_GuiOnAssert) to enable; 3679 // the error dialogs.; 3680 const char *EnablePopups = getenv(""Cling_GuiOnAssert"");; 3681 if (EnablePopups == nullptr || EnablePopups[0] == '0') {; 3682 ::_set_error_mode(_OUT_TO_STDERR);; 3683 _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3684 _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);; 3685 _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3686 _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);; 3687 _CrtSe",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:145905,Usability,clear,clear,145905,"fo);; 3636 ; 3637 if (ID == remark_module_build && !isByproductModule) {; 3638 ROOT::TMetaUtils::Error(nullptr,; 3639 ""Building module '%s' implicitly. If '%s' requires a \n""; 3640 ""dictionary please specify build dependency: '%s' depends on '%s'.\n""; 3641 ""Otherwise, specify '-mByproduct %s' to disable this diagnostic.\n"",; 3642 moduleName.c_str(), moduleName.c_str(), gOptDictionaryFileName.c_str(),; 3643 moduleName.c_str(), moduleName.c_str());; 3644 }; 3645 }; 3646 ; 3647 // All methods below just forward to the child and the default method.; 3648 virtual void clear() override; 3649 {; 3650 fChild->clear();; 3651 DiagnosticConsumer::clear();; 3652 }; 3653 ; 3654 virtual void BeginSourceFile(const clang::LangOptions &LangOpts, const clang::Preprocessor *PP) override; 3655 {; 3656 fChild->BeginSourceFile(LangOpts, PP);; 3657 DiagnosticConsumer::BeginSourceFile(LangOpts, PP);; 3658 }; 3659 ; 3660 virtual void EndSourceFile() override; 3661 {; 3662 fChild->EndSourceFile();; 3663 DiagnosticConsumer::EndSourceFile();; 3664 }; 3665 ; 3666 virtual void finish() override; 3667 {; 3668 fChild->finish();; 3669 DiagnosticConsumer::finish();; 3670 }; 3671 ; 3672 virtual bool IncludeInDiagnosticCounts() const override { return fChild->IncludeInDiagnosticCounts(); }; 3673};; 3674 ; 3675static void MaybeSuppressWin32CrashDialogs() {; 3676#if defined(_WIN32) && defined(_MSC_VER); 3677 // Suppress error dialogs to avoid hangs on build nodes.; 3678 // One can use an environment variable (Cling_GuiOnAssert) to enable; 3679 // the error dialogs.; 3680 const char *EnablePopups = getenv(""Cling_GuiOnAssert"");; 3681 if (EnablePopups == nullptr || EnablePopups[0] == '0') {; 3682 ::_set_error_mode(_OUT_TO_STDERR);; 3683 _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3684 _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);; 3685 _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3686 _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);; 3687 _CrtSe",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:145940,Usability,clear,clear,145940,"fo);; 3636 ; 3637 if (ID == remark_module_build && !isByproductModule) {; 3638 ROOT::TMetaUtils::Error(nullptr,; 3639 ""Building module '%s' implicitly. If '%s' requires a \n""; 3640 ""dictionary please specify build dependency: '%s' depends on '%s'.\n""; 3641 ""Otherwise, specify '-mByproduct %s' to disable this diagnostic.\n"",; 3642 moduleName.c_str(), moduleName.c_str(), gOptDictionaryFileName.c_str(),; 3643 moduleName.c_str(), moduleName.c_str());; 3644 }; 3645 }; 3646 ; 3647 // All methods below just forward to the child and the default method.; 3648 virtual void clear() override; 3649 {; 3650 fChild->clear();; 3651 DiagnosticConsumer::clear();; 3652 }; 3653 ; 3654 virtual void BeginSourceFile(const clang::LangOptions &LangOpts, const clang::Preprocessor *PP) override; 3655 {; 3656 fChild->BeginSourceFile(LangOpts, PP);; 3657 DiagnosticConsumer::BeginSourceFile(LangOpts, PP);; 3658 }; 3659 ; 3660 virtual void EndSourceFile() override; 3661 {; 3662 fChild->EndSourceFile();; 3663 DiagnosticConsumer::EndSourceFile();; 3664 }; 3665 ; 3666 virtual void finish() override; 3667 {; 3668 fChild->finish();; 3669 DiagnosticConsumer::finish();; 3670 }; 3671 ; 3672 virtual bool IncludeInDiagnosticCounts() const override { return fChild->IncludeInDiagnosticCounts(); }; 3673};; 3674 ; 3675static void MaybeSuppressWin32CrashDialogs() {; 3676#if defined(_WIN32) && defined(_MSC_VER); 3677 // Suppress error dialogs to avoid hangs on build nodes.; 3678 // One can use an environment variable (Cling_GuiOnAssert) to enable; 3679 // the error dialogs.; 3680 const char *EnablePopups = getenv(""Cling_GuiOnAssert"");; 3681 if (EnablePopups == nullptr || EnablePopups[0] == '0') {; 3682 ::_set_error_mode(_OUT_TO_STDERR);; 3683 _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3684 _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);; 3685 _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3686 _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);; 3687 _CrtSe",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:203715,Usability,clear,clear,203715," 4978 HeadersDeclsMap_t headersClassesMap;; 4979 HeadersDeclsMap_t headersDeclsMap;; 4980 if (!gOptIgnoreExistingDict) {; 4981 const std::string fwdDeclnArgsToKeepString(GetFwdDeclnArgsToKeepString(normCtxt, interp));; 4982 ; 4983 ExtractHeadersForDecls(scan.fSelectedClasses,; 4984 scan.fSelectedTypedefs,; 4985 scan.fSelectedFunctions,; 4986 scan.fSelectedVariables,; 4987 scan.fSelectedEnums,; 4988 headersClassesMap,; 4989 headersDeclsMap,; 4990 interp);; 4991 ; 4992 std::string detectedUmbrella;; 4993 for (auto & arg : pcmArgs) {; 4994 if (gOptInlineInput && !ROOT::TMetaUtils::IsLinkdefFile(arg.c_str()) && ROOT::TMetaUtils::IsHeaderName(arg)) {; 4995 detectedUmbrella = arg;; 4996 break;; 4997 }; 4998 }; 4999 ; 5000 if (gOptWriteEmptyRootPCM){; 5001 headersDeclsMap.clear();; 5002 }; 5003 ; 5004 ; 5005 std::string headersClassesMapString = ""\""\"""";; 5006 std::string fwdDeclsString = ""\""\"""";; 5007 if (!gOptCxxModule) {; 5008 headersClassesMapString = GenerateStringFromHeadersForClasses(headersDeclsMap,; 5009 detectedUmbrella,; 5010 true);; 5011 if (!gDriverConfig->fBuildingROOTStage1) {; 5012 if (!gOptWriteEmptyRootPCM); 5013 fwdDeclsString = GenerateFwdDeclString(scan, interp);; 5014 }; 5015 }; 5016 modGen.WriteRegistrationSource(dictStream, fwdDeclnArgsToKeepString, headersClassesMapString, fwdDeclsString,; 5017 extraIncludes, gOptCxxModule);; 5018 // If we just want to inline the input header, we don't need; 5019 // to generate any files.; 5020 if (!gOptInlineInput) {; 5021 // Write the module/PCH depending on what mode we are on; 5022 if (modGen.IsPCH()) {; 5023 if (!GenerateAllDict(modGen, CI, currentDirectory)) return 1;; 5024 } else if (gOptCxxModule) {; 5025 if (!CheckModuleValid(modGen, llvmResourceDir, interp, linkdefFilename, moduleName.str())); 5026 return 1;; 5027 }; 5028 }; 5029 }; 5030 ; 5031 ; 5032 if (!gOptLibListPrefix.empty()) {; 5033 string liblist_filename = gOptLibListPrefix + "".out"";; 5034 ; 5035 ofstream outputfile(liblist_filename.c_str(), ios:",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:224098,Usability,feedback,feedback,224098,"///////////////////////////; 5575/// Translate the arguments of genreflex into rootcling ones and forward them; 5576/// to the RootCling function.; 5577/// These are two typical genreflex and rootcling commandlines; 5578/// 1) genreflex header1.h [header2.h ...] [options] [preprocessor options]; 5579/// 2) rootcling [-v] [-v0-4] [-f] [out.cxx] [-s sharedlib.so] [-m pcmfilename]; 5580/// header1.h[{+,-}][!] ..headerN.h[{+,-}][!] [{LinkDef.h,selectionRules.xml}]; 5581/// The rules with which the arguments are translated are (1st column genreflex):; 5582/// --debug -v4; 5583/// --quiet -v0; 5584/// -o ofile positional arg after -f; 5585/// -s selection file Last argument of the call; 5586/// --fail_on_warning Wrap ROOT::TMetaUtils::Warning and throw if selected; 5587///; 5588/// New arguments:; 5589/// -l --library targetLib name (new) -s targetLib name; 5590/// -m pcmname (can be many -m) (new) -m pcmname (can be many -m); 5591/// --rootmap -rmf (new); 5592/// --rootmap-lib -rml (new); 5593///; 5594/// genreflex options which rise warnings (feedback is desirable); 5595/// --no_membertypedefs (it should be irrelevant); 5596/// --no_templatetypedefs (it should be irrelevant); 5597///; 5598/// genreflex options which are ignored (know for sure they are not needed); 5599/// --pool, --dataonly; 5600/// --interpreteronly; 5601/// --gccxml{path,opt,post}; 5602///; 5603///; 5604/// Exceptions; 5605/// The --deep option of genreflex is passed as function parameter to rootcling; 5606/// since it's not needed at the moment there.; 5607 ; 5608int GenReflexMain(int argc, char **argv); 5609{; 5610 using namespace genreflex;; 5611 ; 5612 // Setup the options parser; 5613 enum optionIndex { UNKNOWN,; 5614 PRINTROOTCLINGINVOCATION,; 5615 OFILENAME,; 5616 TARGETLIB,; 5617 MULTIDICT,; 5618 NOGLOBALUSINGSTD,; 5619 SELECTIONFILENAME,; 5620 ROOTMAP,; 5621 ROOTMAPLIB,; 5622 PCMFILENAME,; 5623 DEEP,; 5624 DEBUG,; 5625 VERBOSE,; 5626 QUIET,; 5627 SILENT,; 5628 CXXMODULE,; 5629 WRITEEMPTYROOTPC",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:252816,Usability,clear,clearvirtual,252816,"t for clang that verifies that each implicitly build module is a system module.Definition rootcling_impl.cxx:3569; CheckModuleBuildClient::CheckModuleBuildClientCheckModuleBuildClient(clang::DiagnosticConsumer *Child, bool OwnsChild, clang::ModuleMap &Map)Definition rootcling_impl.cxx:3575; CheckModuleBuildClient::fChildclang::DiagnosticConsumer * fChildDefinition rootcling_impl.cxx:3570; CheckModuleBuildClient::~CheckModuleBuildClient~CheckModuleBuildClient()Definition rootcling_impl.cxx:3580; CheckModuleBuildClient::BeginSourceFilevirtual void BeginSourceFile(const clang::LangOptions &LangOpts, const clang::Preprocessor *PP) overrideDefinition rootcling_impl.cxx:3654; CheckModuleBuildClient::finishvirtual void finish() overrideDefinition rootcling_impl.cxx:3666; CheckModuleBuildClient::HandleDiagnosticvirtual void HandleDiagnostic(clang::DiagnosticsEngine::Level DiagLevel, const clang::Diagnostic &Info) overrideDefinition rootcling_impl.cxx:3586; CheckModuleBuildClient::clearvirtual void clear() overrideDefinition rootcling_impl.cxx:3648; CheckModuleBuildClient::IncludeInDiagnosticCountsvirtual bool IncludeInDiagnosticCounts() const overrideDefinition rootcling_impl.cxx:3672; CheckModuleBuildClient::fMapclang::ModuleMap & fMapDefinition rootcling_impl.cxx:3572; CheckModuleBuildClient::EndSourceFilevirtual void EndSourceFile() overrideDefinition rootcling_impl.cxx:3660; CheckModuleBuildClient::fOwnsChildbool fOwnsChildDefinition rootcling_impl.cxx:3571; ClassSelectionRuleDefinition ClassSelectionRule.h:34; ClassSelectionRule::GetFieldSelectionRulesconst std::list< VariableSelectionRule > & GetFieldSelectionRules() constDefinition ClassSelectionRule.cxx:32; LinkdefReaderDefinition LinkdefReader.h:41; LinkdefReader::LoadIncludesbool LoadIncludes(std::string &extraInclude)Definition LinkdefReader.cxx:511; LinkdefReader::Parsebool Parse(SelectionRules &sr, llvm::StringRef code, const std::vector< std::string > &parserArgs, const char *llvmdir)Definition LinkdefReader.c",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootcling__impl_8cxx_source.html:252834,Usability,clear,clear,252834,"t for clang that verifies that each implicitly build module is a system module.Definition rootcling_impl.cxx:3569; CheckModuleBuildClient::CheckModuleBuildClientCheckModuleBuildClient(clang::DiagnosticConsumer *Child, bool OwnsChild, clang::ModuleMap &Map)Definition rootcling_impl.cxx:3575; CheckModuleBuildClient::fChildclang::DiagnosticConsumer * fChildDefinition rootcling_impl.cxx:3570; CheckModuleBuildClient::~CheckModuleBuildClient~CheckModuleBuildClient()Definition rootcling_impl.cxx:3580; CheckModuleBuildClient::BeginSourceFilevirtual void BeginSourceFile(const clang::LangOptions &LangOpts, const clang::Preprocessor *PP) overrideDefinition rootcling_impl.cxx:3654; CheckModuleBuildClient::finishvirtual void finish() overrideDefinition rootcling_impl.cxx:3666; CheckModuleBuildClient::HandleDiagnosticvirtual void HandleDiagnostic(clang::DiagnosticsEngine::Level DiagLevel, const clang::Diagnostic &Info) overrideDefinition rootcling_impl.cxx:3586; CheckModuleBuildClient::clearvirtual void clear() overrideDefinition rootcling_impl.cxx:3648; CheckModuleBuildClient::IncludeInDiagnosticCountsvirtual bool IncludeInDiagnosticCounts() const overrideDefinition rootcling_impl.cxx:3672; CheckModuleBuildClient::fMapclang::ModuleMap & fMapDefinition rootcling_impl.cxx:3572; CheckModuleBuildClient::EndSourceFilevirtual void EndSourceFile() overrideDefinition rootcling_impl.cxx:3660; CheckModuleBuildClient::fOwnsChildbool fOwnsChildDefinition rootcling_impl.cxx:3571; ClassSelectionRuleDefinition ClassSelectionRule.h:34; ClassSelectionRule::GetFieldSelectionRulesconst std::list< VariableSelectionRule > & GetFieldSelectionRules() constDefinition ClassSelectionRule.cxx:32; LinkdefReaderDefinition LinkdefReader.h:41; LinkdefReader::LoadIncludesbool LoadIncludes(std::string &extraInclude)Definition LinkdefReader.cxx:511; LinkdefReader::Parsebool Parse(SelectionRules &sr, llvm::StringRef code, const std::vector< std::string > &parserArgs, const char *llvmdir)Definition LinkdefReader.c",MatchSource.WIKI,doc/master/rootcling__impl_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html
https://root.cern/doc/master/rootgeom_8C.html:6059,Availability,down,down,6059," have activated the following line in system.rootrc,; //it will appear in the GL viewer; //#Viewer3D.DefaultDrawOption: ogl; ; geom->SetVisLevel(4);; if (vis) top->Draw(""ogle"");; }; ; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; kYellow@ kYellowDefinition Rtypes.h:66; gGeoIdentityR__EXTERN TGeoIdentity * gGeoIdentityDefinition TGeoMatrix.h:537; R; TGeoArb8Definition TGeoArb8.h:17; TGeoArb8::SetVertexvirtual void SetVertex(Int_t vnum, Double_t x, Double_t y); TGeoCombiTransClass describing rotation + translation.Definition TGeoMatrix.h:317; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::MakeArb8TGeoVolume * MakeArb8(const char *name, TGeoMedium *medium, Double_t dz, Double_t *vertices=nullptr)Make an TGeoArb8 volume.Definition TGeoManager.cxx:3161; TGeoManager::SetVisLevelvoid SetVisLevel(Int_t level=3)set default level down to which visualization is performedDefinition TGeoManager.cxx:2459; TGeoManager::CloseGeometryvoid CloseGeometry(Option_t *option=""d"")Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoManager.cxx:3169; TGeoManager::SetTopVolumevoid SetTopVolume(TGeoVolume *vol)Set the top volume and corresponding node as starting point of the geometry.Definition TGeoManager.cxx:3655; TGeoManager::MakeTubsTGeoVolume * MakeTubs(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2)Make in one step a volume pointing to a tube segment shape with given medium.Definition TGeoManager.cxx:3213; TGeoMaterialBase class describing materials.Definition TGeoMateri",MatchSource.WIKI,doc/master/rootgeom_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootgeom_8C.html
https://root.cern/doc/master/rootgeom_8C.html:6090,Performance,perform,performedDefinition,6090," have activated the following line in system.rootrc,; //it will appear in the GL viewer; //#Viewer3D.DefaultDrawOption: ogl; ; geom->SetVisLevel(4);; if (vis) top->Draw(""ogle"");; }; ; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; kYellow@ kYellowDefinition Rtypes.h:66; gGeoIdentityR__EXTERN TGeoIdentity * gGeoIdentityDefinition TGeoMatrix.h:537; R; TGeoArb8Definition TGeoArb8.h:17; TGeoArb8::SetVertexvirtual void SetVertex(Int_t vnum, Double_t x, Double_t y); TGeoCombiTransClass describing rotation + translation.Definition TGeoMatrix.h:317; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::MakeArb8TGeoVolume * MakeArb8(const char *name, TGeoMedium *medium, Double_t dz, Double_t *vertices=nullptr)Make an TGeoArb8 volume.Definition TGeoManager.cxx:3161; TGeoManager::SetVisLevelvoid SetVisLevel(Int_t level=3)set default level down to which visualization is performedDefinition TGeoManager.cxx:2459; TGeoManager::CloseGeometryvoid CloseGeometry(Option_t *option=""d"")Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoManager.cxx:3169; TGeoManager::SetTopVolumevoid SetTopVolume(TGeoVolume *vol)Set the top volume and corresponding node as starting point of the geometry.Definition TGeoManager.cxx:3655; TGeoManager::MakeTubsTGeoVolume * MakeTubs(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2)Make in one step a volume pointing to a tube segment shape with given medium.Definition TGeoManager.cxx:3213; TGeoMaterialBase class describing materials.Definition TGeoMateri",MatchSource.WIKI,doc/master/rootgeom_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootgeom_8C.html
https://root.cern/doc/master/rootgeom_8C.html:226,Usability,simpl,simple,226,". ROOT: tutorials/geom/rootgeom.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rootgeom.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Definition of a simple geometry (the 4 ROOT characters) ; �␆2�␏V ; void rootgeom(bool vis = true); {; // gStyle->SetCanvasPreferGL(true);; ; TGeoManager *geom = new TGeoManager(""simple1"", ""Simple geometry"");; ; //--- define some materials; TGeoMaterial *matVacuum = new TGeoMaterial(""Vacuum"", 0,0,0);; TGeoMaterial *matAl = new TGeoMaterial(""Al"", 26.98,13,2.7);; // //--- define some media; TGeoMedium *Vacuum = new TGeoMedium(""Vacuum"",1, matVacuum);; TGeoMedium *Al = new TGeoMedium(""Root Material"",2, matAl);; ; //--- define the transformations; TGeoTranslation *tr1 = new TGeoTranslation(20., 0, 0.);; TGeoTranslation *tr2 = new TGeoTranslation(10., 0., 0.);; TGeoTranslation *tr3 = new TGeoTranslation(10., 20., 0.);; TGeoTranslation *tr4 = new TGeoTranslation(5., 10., 0.);; TGeoTranslation *tr5 = new TGeoTranslation(20., 0., 0.);; TGeoTranslation *tr6 = new TGeoTranslation(-5., 0., 0.);; TGeoTranslation *tr7 = new TGeoTranslation(7.5, 7.5, 0.);; TGeoRotation *rot1 = new TGeoRotation(""rot1"", 90., 0., 90., 270., 0., 0.);; TGeoCombiTrans *combi1 = new TGeoCombiTrans(7.5, -7.5, 0., rot1);; TGeoTranslation *tr8 = new TGeoTranslation(7.5, -5., 0.);; TGeoTranslation *tr9 = new TGeoTranslation(7.5, 20., 0.);; TGeoTranslation *tr10 = new TGeoTranslation(85., 0., 0.);; TGeoTranslation *tr11 = new TGeoTranslation(35., 0., 0.);; TGeoTranslation *tr12 = new TGeoTranslation(-15., 0., 0.);; TGeoTranslation *tr13 = new TGeoTranslation(-65., 0., 0.);; ; TGeoTranslation *tr14 = new TGeoTranslation(0,0,-100);; TGeoCombiTrans *combi2 = new TGeoCombiTrans(0,0,100,; new TGeoRotation(""rot2"",90,180,90,90,180,0));; TGeoCombiTrans *combi3 = new TGeoCombiTrans(100,0,0,; new TGeoRotation(""rot3"",90,270,0,0,90,180));; TGeoCombiTrans *combi4 = new TGeoCombiTrans(-100,0,0,; new TGeoRotation(""rot4""",MatchSource.WIKI,doc/master/rootgeom_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootgeom_8C.html
https://root.cern/doc/master/rootio.html:939,Availability,avail,available,939,". ROOT: ROOT files layout. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ROOT files layout. Table of Contents; ROOTIO files; Data record types""core"" record types; ""streamer"" layer record types; ""pointer to persistent object"" object types; ""application"" layer record types. Data compression; StreamerInfo; Pointers to persistent objects; Some useful container classesTObjArray and TClonesArray; TTree. Related pages. ROOTIO files; A ROOTIO file consists of one ""file header"", one or more ""data; records,"" and zero or more ""free segments"". The file header is always at the beginning of the file, while the data records and free segments may in principle appear in any order.; The file header is fixed length (64 bytes in the current release.) It's detailed format is given in File header format.; A free segment is of variable length. One free segment is a set of contiguous bytes that are unused, and are available for ROOTIO to use for new or resized data records. The first four bytes of a a free segment contain the negative of the number of bytes in the segment. The contents of the remainder of the free segment are irrelevant.; A data record represents either user data or data used internally by ROOTIO. All data records have two portions, a ""key"" portion and a ""data"" portion. The key portion precedes the data portion. The format of the key portion is the same for all data. (The key portion corresponds to a class TKey object). The object name and they key cycle are together sufficient to uniquely determine the record within the file. The Format of a class object in DATA page describes the format of the data portion of a record for an object that uses the default streamer. Data record types. ""core"" record types; There are several types of data records used internally by ROOTIO to support the storage of byte sequences. These record types are TFile, TDirectory, ""KeysList"", and ""FreeSegments"". These types can be considered to be in the ""core"" layer o",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/rootio.html:766,Deployability,release,release,766,". ROOT: ROOT files layout. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ROOT files layout. Table of Contents; ROOTIO files; Data record types""core"" record types; ""streamer"" layer record types; ""pointer to persistent object"" object types; ""application"" layer record types. Data compression; StreamerInfo; Pointers to persistent objects; Some useful container classesTObjArray and TClonesArray; TTree. Related pages. ROOTIO files; A ROOTIO file consists of one ""file header"", one or more ""data; records,"" and zero or more ""free segments"". The file header is always at the beginning of the file, while the data records and free segments may in principle appear in any order.; The file header is fixed length (64 bytes in the current release.) It's detailed format is given in File header format.; A free segment is of variable length. One free segment is a set of contiguous bytes that are unused, and are available for ROOTIO to use for new or resized data records. The first four bytes of a a free segment contain the negative of the number of bytes in the segment. The contents of the remainder of the free segment are irrelevant.; A data record represents either user data or data used internally by ROOTIO. All data records have two portions, a ""key"" portion and a ""data"" portion. The key portion precedes the data portion. The format of the key portion is the same for all data. (The key portion corresponds to a class TKey object). The object name and they key cycle are together sufficient to uniquely determine the record within the file. The Format of a class object in DATA page describes the format of the data portion of a record for an object that uses the default streamer. Data record types. ""core"" record types; There are several types of data records used internally by ROOTIO to support the storage of byte sequences. These record types are TFile, TDirectory, ""KeysList"", and ""FreeSegments"". These types can be considered to be in the ""core"" layer o",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/rootio.html:5210,Deployability,update,update,5210,"and Format of the DATA for a TRefArray object respectively. Of these three objects, only TProcessID objects necessarily comprise a complete data record (a ""TProcessID"" record). TRef and TRefArray objects typically are data members of larger objects, and therefore are only a part of the data portion of a record. In addition, objects that are referenced by such a pointer have an additional field in the base TObject. See Format of the DATA for a TObject object. A description of how these pointers work is given under the Pointers to persistent objects heading below. ""application"" layer record types; These are either user defined record types, or record types supplied by ROOT that are not needed by ROOTIO. The format of such an object that uses the default streamer is shown in Format of a class object in DATA. Data compression; The user can set the data compression level for new or modified data records when creating or opening a file. When an existing file is opened for update, the compression level selected need not match that used previously. The compression level of existing records is not modified unless the record itself is modified.; There are ten compression levels, 0-9, ranging from 0 (no compression) to 9 (maximum compression), with level 1 being the default. The level chosen is a tradeoff between disk space and compression performance. The decompression speed is independent of level. Currently, in release 3.2.6, level 2 is not used. If level 2 is selected, level 1 is used with no notification to the user.; The chosen compression level is not applied to the entire file. The following portions of the file are not compressed, regardless of the compression level selected:. the file header; the KeysList data record; the FreeSegments data record; any data record (outside of a TTree) where the uncompressed size of the data portion is 256 bytes or less.; the key portion of any data record. Furthermore, the data portion of the StreamerInfo data record is always compres",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/rootio.html:5656,Deployability,release,release,5656,"rmat of the DATA for a TObject object. A description of how these pointers work is given under the Pointers to persistent objects heading below. ""application"" layer record types; These are either user defined record types, or record types supplied by ROOT that are not needed by ROOTIO. The format of such an object that uses the default streamer is shown in Format of a class object in DATA. Data compression; The user can set the data compression level for new or modified data records when creating or opening a file. When an existing file is opened for update, the compression level selected need not match that used previously. The compression level of existing records is not modified unless the record itself is modified.; There are ten compression levels, 0-9, ranging from 0 (no compression) to 9 (maximum compression), with level 1 being the default. The level chosen is a tradeoff between disk space and compression performance. The decompression speed is independent of level. Currently, in release 3.2.6, level 2 is not used. If level 2 is selected, level 1 is used with no notification to the user.; The chosen compression level is not applied to the entire file. The following portions of the file are not compressed, regardless of the compression level selected:. the file header; the KeysList data record; the FreeSegments data record; any data record (outside of a TTree) where the uncompressed size of the data portion is 256 bytes or less.; the key portion of any data record. Furthermore, the data portion of the StreamerInfo data record is always compressed at level 1 (if over 256 bytes uncompressed), regardless of the compression level selected (even if no compression is selected).; The compression algorithm used is an in memory ZIP compression written for the DELPHI collaboration at CERN. Its author is E. Chernyaev (IHEP/Protvino). The source code is internal to ROOTIO. StreamerInfo; The ""StreamerInfo"" data record is used by ROOTIO to support the storage of self-identi",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/rootio.html:11176,Deployability,release,release,11176,"ly code the decomposition and composition of the object to its members. In this case, the StreamerInfo for that class might not be used. In any case, if the composition/decomposition of the class is explicitly coded, the user should include the byte count, class information, and version number of the class before the data on disk as shown in Format of a class object in DATA.; The special method used for streaming a TClonesArray is described in the TClonesArray section below.; More information on the StreamerInfo record and its use is found in the Input/Output chapter of the Root Manual; NOTE: Some of the classes used internally in ROOTIO (e.g. TObject, TRef, TRefArray) have explicitly coded (de)compositions, and do not use the information in the StreamerInfo record to do the (de)composition. In this case, the StreamerInfo for the class may still be present in the StreamerInfo record, but may not match what is actually written to disk for those objects. Pointers to persistent objects; These were introduced in release 3.02, so there is not yet a description in the current Root Users Guide, which is for a version release 3.1. Here we discuss only the information on disk.; A ROOT file contains zero or more TProcessID records. Each such record contains a globally unique ID defining a given ROOT job that wrote a referenced object (see Format of TProcessID record). Each referenced object contains a ""pidf"" field referencing the corresponding TProcessID record and an ""fUniqueID"" field uniquely identifying the referenced object among those written by that process (see Format of the DATA for a TObject object). Similarly, every persistent reference to that object (a TRef Object, see Format of the DATA for a TRef object) also contains ""pidf"" and ""fUniqueID"" fields with the same value, thereby uniquely determining the referenced object (which need not even be in the same file). In the case of an array of references (a TRefArray object, see Format of the DATA for a TRefArray objec",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/rootio.html:11280,Deployability,release,release,11280,"the StreamerInfo for that class might not be used. In any case, if the composition/decomposition of the class is explicitly coded, the user should include the byte count, class information, and version number of the class before the data on disk as shown in Format of a class object in DATA.; The special method used for streaming a TClonesArray is described in the TClonesArray section below.; More information on the StreamerInfo record and its use is found in the Input/Output chapter of the Root Manual; NOTE: Some of the classes used internally in ROOTIO (e.g. TObject, TRef, TRefArray) have explicitly coded (de)compositions, and do not use the information in the StreamerInfo record to do the (de)composition. In this case, the StreamerInfo for the class may still be present in the StreamerInfo record, but may not match what is actually written to disk for those objects. Pointers to persistent objects; These were introduced in release 3.02, so there is not yet a description in the current Root Users Guide, which is for a version release 3.1. Here we discuss only the information on disk.; A ROOT file contains zero or more TProcessID records. Each such record contains a globally unique ID defining a given ROOT job that wrote a referenced object (see Format of TProcessID record). Each referenced object contains a ""pidf"" field referencing the corresponding TProcessID record and an ""fUniqueID"" field uniquely identifying the referenced object among those written by that process (see Format of the DATA for a TObject object). Similarly, every persistent reference to that object (a TRef Object, see Format of the DATA for a TRef object) also contains ""pidf"" and ""fUniqueID"" fields with the same value, thereby uniquely determining the referenced object (which need not even be in the same file). In the case of an array of references (a TRefArray object, see Format of the DATA for a TRefArray object), there is one ""pidf"" value for the entire array, and a separate ""fUniqueID"" value f",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/rootio.html:13167,Energy Efficiency,allocate,allocated,13167,"rray, and a separate ""fUniqueID"" value for each reference. For further information, see the above URL. Some useful container classes. TObjArray and TClonesArray; The TObjArray class can be used to support an array of objects. The objects need not be of the same type, but each object must be of a class type that inherits from TObject. We have already seen a specific example of the use of TObjArray, in the StreamerInfo record, where it is used to hold an array of TStreamerElement objects, each of which is of a class inheriting from TStreamerElement, which in turn inherits from TObject.; The TClonesArray class is a specialization of the TObjArray class for holding an array of objects that are all of the same type. The format of a TClonesArray object is given in Format of the DATA for a TClonesArray object.; There are two great advantages in the use of TClonesArray over TObjArray when the objects all will be of the same class:. Memory for the objects will be allocated only once for the entire array, rather than the per-object allocation for TObjArray. This can be done because all the objects are the same size.; In the case of TObjArray, the stored objects are written sequentially. However, in a TClonesArray, by default, each object is split one level deep into its base class(es) and data members, and each of these members is written sequentially for all objects in the array before the next member is written. This has two advantages:; Greater compression can be achieved when similar data is consecutive.; The object's data members can easily be split into different TTree branches (TTrees are discussed below). TTree; A TTree is a highly specialized container class for efficient storage and retrieval of user data. The use of TTrees is discussed in detail in the Trees chapter of the Root Manual; Here we discuss in particular how a TTree is stored in a ROOTIO file.; A TTree object is split into one or more branches (class TBranch), each of which may have its own (sub)branches",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/rootio.html:13888,Energy Efficiency,efficient,efficient,13888,"objects that are all of the same type. The format of a TClonesArray object is given in Format of the DATA for a TClonesArray object.; There are two great advantages in the use of TClonesArray over TObjArray when the objects all will be of the same class:. Memory for the objects will be allocated only once for the entire array, rather than the per-object allocation for TObjArray. This can be done because all the objects are the same size.; In the case of TObjArray, the stored objects are written sequentially. However, in a TClonesArray, by default, each object is split one level deep into its base class(es) and data members, and each of these members is written sequentially for all objects in the array before the next member is written. This has two advantages:; Greater compression can be achieved when similar data is consecutive.; The object's data members can easily be split into different TTree branches (TTrees are discussed below). TTree; A TTree is a highly specialized container class for efficient storage and retrieval of user data. The use of TTrees is discussed in detail in the Trees chapter of the Root Manual; Here we discuss in particular how a TTree is stored in a ROOTIO file.; A TTree object is split into one or more branches (class TBranch), each of which may have its own (sub)branches, recursively to any depth. Each TBranch contains an array of zero or more leaves (class TLeaf), each corresponding to a basic variable type or a class object that has not been split. The TLeaf object does not actually contain variable values, only information about the variables. The actual data on each branch is physically stored in basket objects (class TBasket). The user can set the basket size on a per TBranch basis. The default basket size is 32000 bytes. This should be viewed as an approximate number.; There is one TTree data record per file for each tree in the file, corresponding to a TTree class object. The TTree class object recursively contains TBranch objects, e",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/rootio.html:851,Modifiability,variab,variable,851,". ROOT: ROOT files layout. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ROOT files layout. Table of Contents; ROOTIO files; Data record types""core"" record types; ""streamer"" layer record types; ""pointer to persistent object"" object types; ""application"" layer record types. Data compression; StreamerInfo; Pointers to persistent objects; Some useful container classesTObjArray and TClonesArray; TTree. Related pages. ROOTIO files; A ROOTIO file consists of one ""file header"", one or more ""data; records,"" and zero or more ""free segments"". The file header is always at the beginning of the file, while the data records and free segments may in principle appear in any order.; The file header is fixed length (64 bytes in the current release.) It's detailed format is given in File header format.; A free segment is of variable length. One free segment is a set of contiguous bytes that are unused, and are available for ROOTIO to use for new or resized data records. The first four bytes of a a free segment contain the negative of the number of bytes in the segment. The contents of the remainder of the free segment are irrelevant.; A data record represents either user data or data used internally by ROOTIO. All data records have two portions, a ""key"" portion and a ""data"" portion. The key portion precedes the data portion. The format of the key portion is the same for all data. (The key portion corresponds to a class TKey object). The object name and they key cycle are together sufficient to uniquely determine the record within the file. The Format of a class object in DATA page describes the format of the data portion of a record for an object that uses the default streamer. Data record types. ""core"" record types; There are several types of data records used internally by ROOTIO to support the storage of byte sequences. These record types are TFile, TDirectory, ""KeysList"", and ""FreeSegments"". These types can be considered to be in the ""core"" layer o",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/rootio.html:9158,Modifiability,variab,variable,9158,"en to disk, nor is there any streamerinfo for such a member.; A data member that is a C++ pointer (not to be confused with ""pointers to persistent; objects"" described below) is never written to disk as a pointer value. If it is a pointer to an object, the object itself (or 0 (4 bytes) if the pointer value is NULL) is written. If the declaration line has a comment beginning with ""//->"", this indicates that the pointer value will never be null, which allows a performance optimization. Another optimization is that if two or more pointers pointing to the same object are streamed in the same I/O operation, the object is written only once. The remaining pointers reference the object through a unique object identifier. This saves space and avoids the infinite loop that might otherwise arise if the directed graph of object instance pointer references contains a cycle.; If a data member is a pointer to a simple type, the Streamer presumes it is an array, with the dimension defined in a comment of the form ""//[<length>]"", where length is either an integer constant or a variable that is an integer data member of the class. If a variable is used, it must be defined ahead of its use or in a base class.; The above describes the function of the StreamerInfo record in decomposing a self-identifying object if the user uses the streamer generated by ""rootcint"". There are two reasons why a user may need to write a specialized streamer for a class. One reason is that it may be necessary to execute some code before or after data is read or written, for example, to initialize some non-persistent data members after the persistent data is read. In this case, the custom streamer can use the StreamerInfo record to decompose a self-identifying object in the exact same manner as the generated streamer would have done. An example is given (for the Event class) in the Root User's Guide (URL below) (Input/Output chapter, Streamers subchapter). On the other hand, if the user needs to write a stream",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/rootio.html:9217,Modifiability,variab,variable,9217,"elow) is never written to disk as a pointer value. If it is a pointer to an object, the object itself (or 0 (4 bytes) if the pointer value is NULL) is written. If the declaration line has a comment beginning with ""//->"", this indicates that the pointer value will never be null, which allows a performance optimization. Another optimization is that if two or more pointers pointing to the same object are streamed in the same I/O operation, the object is written only once. The remaining pointers reference the object through a unique object identifier. This saves space and avoids the infinite loop that might otherwise arise if the directed graph of object instance pointer references contains a cycle.; If a data member is a pointer to a simple type, the Streamer presumes it is an array, with the dimension defined in a comment of the form ""//[<length>]"", where length is either an integer constant or a variable that is an integer data member of the class. If a variable is used, it must be defined ahead of its use or in a base class.; The above describes the function of the StreamerInfo record in decomposing a self-identifying object if the user uses the streamer generated by ""rootcint"". There are two reasons why a user may need to write a specialized streamer for a class. One reason is that it may be necessary to execute some code before or after data is read or written, for example, to initialize some non-persistent data members after the persistent data is read. In this case, the custom streamer can use the StreamerInfo record to decompose a self-identifying object in the exact same manner as the generated streamer would have done. An example is given (for the Event class) in the Root User's Guide (URL below) (Input/Output chapter, Streamers subchapter). On the other hand, if the user needs to write a streamer for a class that ROOT cannot handle, the user may need to explicitly code the decomposition and composition of the object to its members. In this case, the StreamerI",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/rootio.html:12511,Modifiability,inherit,inherits,12511,"a referenced object (see Format of TProcessID record). Each referenced object contains a ""pidf"" field referencing the corresponding TProcessID record and an ""fUniqueID"" field uniquely identifying the referenced object among those written by that process (see Format of the DATA for a TObject object). Similarly, every persistent reference to that object (a TRef Object, see Format of the DATA for a TRef object) also contains ""pidf"" and ""fUniqueID"" fields with the same value, thereby uniquely determining the referenced object (which need not even be in the same file). In the case of an array of references (a TRefArray object, see Format of the DATA for a TRefArray object), there is one ""pidf"" value for the entire array, and a separate ""fUniqueID"" value for each reference. For further information, see the above URL. Some useful container classes. TObjArray and TClonesArray; The TObjArray class can be used to support an array of objects. The objects need not be of the same type, but each object must be of a class type that inherits from TObject. We have already seen a specific example of the use of TObjArray, in the StreamerInfo record, where it is used to hold an array of TStreamerElement objects, each of which is of a class inheriting from TStreamerElement, which in turn inherits from TObject.; The TClonesArray class is a specialization of the TObjArray class for holding an array of objects that are all of the same type. The format of a TClonesArray object is given in Format of the DATA for a TClonesArray object.; There are two great advantages in the use of TClonesArray over TObjArray when the objects all will be of the same class:. Memory for the objects will be allocated only once for the entire array, rather than the per-object allocation for TObjArray. This can be done because all the objects are the same size.; In the case of TObjArray, the stored objects are written sequentially. However, in a TClonesArray, by default, each object is split one level deep into its",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/rootio.html:12718,Modifiability,inherit,inheriting,12718,"y identifying the referenced object among those written by that process (see Format of the DATA for a TObject object). Similarly, every persistent reference to that object (a TRef Object, see Format of the DATA for a TRef object) also contains ""pidf"" and ""fUniqueID"" fields with the same value, thereby uniquely determining the referenced object (which need not even be in the same file). In the case of an array of references (a TRefArray object, see Format of the DATA for a TRefArray object), there is one ""pidf"" value for the entire array, and a separate ""fUniqueID"" value for each reference. For further information, see the above URL. Some useful container classes. TObjArray and TClonesArray; The TObjArray class can be used to support an array of objects. The objects need not be of the same type, but each object must be of a class type that inherits from TObject. We have already seen a specific example of the use of TObjArray, in the StreamerInfo record, where it is used to hold an array of TStreamerElement objects, each of which is of a class inheriting from TStreamerElement, which in turn inherits from TObject.; The TClonesArray class is a specialization of the TObjArray class for holding an array of objects that are all of the same type. The format of a TClonesArray object is given in Format of the DATA for a TClonesArray object.; There are two great advantages in the use of TClonesArray over TObjArray when the objects all will be of the same class:. Memory for the objects will be allocated only once for the entire array, rather than the per-object allocation for TObjArray. This can be done because all the objects are the same size.; In the case of TObjArray, the stored objects are written sequentially. However, in a TClonesArray, by default, each object is split one level deep into its base class(es) and data members, and each of these members is written sequentially for all objects in the array before the next member is written. This has two advantages:; Greater c",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/rootio.html:12766,Modifiability,inherit,inherits,12766,"y identifying the referenced object among those written by that process (see Format of the DATA for a TObject object). Similarly, every persistent reference to that object (a TRef Object, see Format of the DATA for a TRef object) also contains ""pidf"" and ""fUniqueID"" fields with the same value, thereby uniquely determining the referenced object (which need not even be in the same file). In the case of an array of references (a TRefArray object, see Format of the DATA for a TRefArray object), there is one ""pidf"" value for the entire array, and a separate ""fUniqueID"" value for each reference. For further information, see the above URL. Some useful container classes. TObjArray and TClonesArray; The TObjArray class can be used to support an array of objects. The objects need not be of the same type, but each object must be of a class type that inherits from TObject. We have already seen a specific example of the use of TObjArray, in the StreamerInfo record, where it is used to hold an array of TStreamerElement objects, each of which is of a class inheriting from TStreamerElement, which in turn inherits from TObject.; The TClonesArray class is a specialization of the TObjArray class for holding an array of objects that are all of the same type. The format of a TClonesArray object is given in Format of the DATA for a TClonesArray object.; There are two great advantages in the use of TClonesArray over TObjArray when the objects all will be of the same class:. Memory for the objects will be allocated only once for the entire array, rather than the per-object allocation for TObjArray. This can be done because all the objects are the same size.; In the case of TObjArray, the stored objects are written sequentially. However, in a TClonesArray, by default, each object is split one level deep into its base class(es) and data members, and each of these members is written sequentially for all objects in the array before the next member is written. This has two advantages:; Greater c",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/rootio.html:14325,Modifiability,variab,variable,14325,"are the same size.; In the case of TObjArray, the stored objects are written sequentially. However, in a TClonesArray, by default, each object is split one level deep into its base class(es) and data members, and each of these members is written sequentially for all objects in the array before the next member is written. This has two advantages:; Greater compression can be achieved when similar data is consecutive.; The object's data members can easily be split into different TTree branches (TTrees are discussed below). TTree; A TTree is a highly specialized container class for efficient storage and retrieval of user data. The use of TTrees is discussed in detail in the Trees chapter of the Root Manual; Here we discuss in particular how a TTree is stored in a ROOTIO file.; A TTree object is split into one or more branches (class TBranch), each of which may have its own (sub)branches, recursively to any depth. Each TBranch contains an array of zero or more leaves (class TLeaf), each corresponding to a basic variable type or a class object that has not been split. The TLeaf object does not actually contain variable values, only information about the variables. The actual data on each branch is physically stored in basket objects (class TBasket). The user can set the basket size on a per TBranch basis. The default basket size is 32000 bytes. This should be viewed as an approximate number.; There is one TTree data record per file for each tree in the file, corresponding to a TTree class object. The TTree class object recursively contains TBranch objects, each of which contains an array of TBasket objects to hold its data.; However, the TTree data record does not necessarily contain the entire TTree object. For each branch, exactly one TBasket object is contained in the TTree data record. If the data on a given branch fits in one basket, then all the data for that branch will be in the TTree record itself. Otherwise, there will be a separate TBasket data record for each ",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/rootio.html:14425,Modifiability,variab,variable,14425,"lt, each object is split one level deep into its base class(es) and data members, and each of these members is written sequentially for all objects in the array before the next member is written. This has two advantages:; Greater compression can be achieved when similar data is consecutive.; The object's data members can easily be split into different TTree branches (TTrees are discussed below). TTree; A TTree is a highly specialized container class for efficient storage and retrieval of user data. The use of TTrees is discussed in detail in the Trees chapter of the Root Manual; Here we discuss in particular how a TTree is stored in a ROOTIO file.; A TTree object is split into one or more branches (class TBranch), each of which may have its own (sub)branches, recursively to any depth. Each TBranch contains an array of zero or more leaves (class TLeaf), each corresponding to a basic variable type or a class object that has not been split. The TLeaf object does not actually contain variable values, only information about the variables. The actual data on each branch is physically stored in basket objects (class TBasket). The user can set the basket size on a per TBranch basis. The default basket size is 32000 bytes. This should be viewed as an approximate number.; There is one TTree data record per file for each tree in the file, corresponding to a TTree class object. The TTree class object recursively contains TBranch objects, each of which contains an array of TBasket objects to hold its data.; However, the TTree data record does not necessarily contain the entire TTree object. For each branch, exactly one TBasket object is contained in the TTree data record. If the data on a given branch fits in one basket, then all the data for that branch will be in the TTree record itself. Otherwise, there will be a separate TBasket data record for each additional basket used on the branch, each containing a TBasket object containing user data.; By default, the additional TBaske",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/rootio.html:14469,Modifiability,variab,variables,14469,"lt, each object is split one level deep into its base class(es) and data members, and each of these members is written sequentially for all objects in the array before the next member is written. This has two advantages:; Greater compression can be achieved when similar data is consecutive.; The object's data members can easily be split into different TTree branches (TTrees are discussed below). TTree; A TTree is a highly specialized container class for efficient storage and retrieval of user data. The use of TTrees is discussed in detail in the Trees chapter of the Root Manual; Here we discuss in particular how a TTree is stored in a ROOTIO file.; A TTree object is split into one or more branches (class TBranch), each of which may have its own (sub)branches, recursively to any depth. Each TBranch contains an array of zero or more leaves (class TLeaf), each corresponding to a basic variable type or a class object that has not been split. The TLeaf object does not actually contain variable values, only information about the variables. The actual data on each branch is physically stored in basket objects (class TBasket). The user can set the basket size on a per TBranch basis. The default basket size is 32000 bytes. This should be viewed as an approximate number.; There is one TTree data record per file for each tree in the file, corresponding to a TTree class object. The TTree class object recursively contains TBranch objects, each of which contains an array of TBasket objects to hold its data.; However, the TTree data record does not necessarily contain the entire TTree object. For each branch, exactly one TBasket object is contained in the TTree data record. If the data on a given branch fits in one basket, then all the data for that branch will be in the TTree record itself. Otherwise, there will be a separate TBasket data record for each additional basket used on the branch, each containing a TBasket object containing user data.; By default, the additional TBaske",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/rootio.html:5580,Performance,perform,performance,5580,"n, objects that are referenced by such a pointer have an additional field in the base TObject. See Format of the DATA for a TObject object. A description of how these pointers work is given under the Pointers to persistent objects heading below. ""application"" layer record types; These are either user defined record types, or record types supplied by ROOT that are not needed by ROOTIO. The format of such an object that uses the default streamer is shown in Format of a class object in DATA. Data compression; The user can set the data compression level for new or modified data records when creating or opening a file. When an existing file is opened for update, the compression level selected need not match that used previously. The compression level of existing records is not modified unless the record itself is modified.; There are ten compression levels, 0-9, ranging from 0 (no compression) to 9 (maximum compression), with level 1 being the default. The level chosen is a tradeoff between disk space and compression performance. The decompression speed is independent of level. Currently, in release 3.2.6, level 2 is not used. If level 2 is selected, level 1 is used with no notification to the user.; The chosen compression level is not applied to the entire file. The following portions of the file are not compressed, regardless of the compression level selected:. the file header; the KeysList data record; the FreeSegments data record; any data record (outside of a TTree) where the uncompressed size of the data portion is 256 bytes or less.; the key portion of any data record. Furthermore, the data portion of the StreamerInfo data record is always compressed at level 1 (if over 256 bytes uncompressed), regardless of the compression level selected (even if no compression is selected).; The compression algorithm used is an in memory ZIP compression written for the DELPHI collaboration at CERN. Its author is E. Chernyaev (IHEP/Protvino). The source code is internal to ROOTIO.",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/rootio.html:8544,Performance,perform,performance,8544,"se class of the object or a (non-static and non-transient) data member of the object. If the base class or data member is itself a class, then there will also be a streamerinfo object in the record for that class. In this way, each class is recursively decomposed into its atomic elements, each of which is a simple type (e.g. ""int""). A ""long"" or ""unsigned long"" member is always written as an 8 byte quantity, even if it occupies only 4 bytes in memory.; A data member of a class is marked transient on the line of its declaration by a comment beginning with ""//!"". Such members are not written to disk, nor is there any streamerinfo for such a member.; A data member that is a C++ pointer (not to be confused with ""pointers to persistent; objects"" described below) is never written to disk as a pointer value. If it is a pointer to an object, the object itself (or 0 (4 bytes) if the pointer value is NULL) is written. If the declaration line has a comment beginning with ""//->"", this indicates that the pointer value will never be null, which allows a performance optimization. Another optimization is that if two or more pointers pointing to the same object are streamed in the same I/O operation, the object is written only once. The remaining pointers reference the object through a unique object identifier. This saves space and avoids the infinite loop that might otherwise arise if the directed graph of object instance pointer references contains a cycle.; If a data member is a pointer to a simple type, the Streamer presumes it is an array, with the dimension defined in a comment of the form ""//[<length>]"", where length is either an integer constant or a variable that is an integer data member of the class. If a variable is used, it must be defined ahead of its use or in a base class.; The above describes the function of the StreamerInfo record in decomposing a self-identifying object if the user uses the streamer generated by ""rootcint"". There are two reasons why a user may need",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/rootio.html:8556,Performance,optimiz,optimization,8556,"se class of the object or a (non-static and non-transient) data member of the object. If the base class or data member is itself a class, then there will also be a streamerinfo object in the record for that class. In this way, each class is recursively decomposed into its atomic elements, each of which is a simple type (e.g. ""int""). A ""long"" or ""unsigned long"" member is always written as an 8 byte quantity, even if it occupies only 4 bytes in memory.; A data member of a class is marked transient on the line of its declaration by a comment beginning with ""//!"". Such members are not written to disk, nor is there any streamerinfo for such a member.; A data member that is a C++ pointer (not to be confused with ""pointers to persistent; objects"" described below) is never written to disk as a pointer value. If it is a pointer to an object, the object itself (or 0 (4 bytes) if the pointer value is NULL) is written. If the declaration line has a comment beginning with ""//->"", this indicates that the pointer value will never be null, which allows a performance optimization. Another optimization is that if two or more pointers pointing to the same object are streamed in the same I/O operation, the object is written only once. The remaining pointers reference the object through a unique object identifier. This saves space and avoids the infinite loop that might otherwise arise if the directed graph of object instance pointer references contains a cycle.; If a data member is a pointer to a simple type, the Streamer presumes it is an array, with the dimension defined in a comment of the form ""//[<length>]"", where length is either an integer constant or a variable that is an integer data member of the class. If a variable is used, it must be defined ahead of its use or in a base class.; The above describes the function of the StreamerInfo record in decomposing a self-identifying object if the user uses the streamer generated by ""rootcint"". There are two reasons why a user may need",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/rootio.html:8578,Performance,optimiz,optimization,8578,"o be a streamerinfo object in the record for that class. In this way, each class is recursively decomposed into its atomic elements, each of which is a simple type (e.g. ""int""). A ""long"" or ""unsigned long"" member is always written as an 8 byte quantity, even if it occupies only 4 bytes in memory.; A data member of a class is marked transient on the line of its declaration by a comment beginning with ""//!"". Such members are not written to disk, nor is there any streamerinfo for such a member.; A data member that is a C++ pointer (not to be confused with ""pointers to persistent; objects"" described below) is never written to disk as a pointer value. If it is a pointer to an object, the object itself (or 0 (4 bytes) if the pointer value is NULL) is written. If the declaration line has a comment beginning with ""//->"", this indicates that the pointer value will never be null, which allows a performance optimization. Another optimization is that if two or more pointers pointing to the same object are streamed in the same I/O operation, the object is written only once. The remaining pointers reference the object through a unique object identifier. This saves space and avoids the infinite loop that might otherwise arise if the directed graph of object instance pointer references contains a cycle.; If a data member is a pointer to a simple type, the Streamer presumes it is an array, with the dimension defined in a comment of the form ""//[<length>]"", where length is either an integer constant or a variable that is an integer data member of the class. If a variable is used, it must be defined ahead of its use or in a base class.; The above describes the function of the StreamerInfo record in decomposing a self-identifying object if the user uses the streamer generated by ""rootcint"". There are two reasons why a user may need to write a specialized streamer for a class. One reason is that it may be necessary to execute some code before or after data is read or written, for exampl",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/rootio.html:8825,Safety,avoid,avoids,8825,"s an 8 byte quantity, even if it occupies only 4 bytes in memory.; A data member of a class is marked transient on the line of its declaration by a comment beginning with ""//!"". Such members are not written to disk, nor is there any streamerinfo for such a member.; A data member that is a C++ pointer (not to be confused with ""pointers to persistent; objects"" described below) is never written to disk as a pointer value. If it is a pointer to an object, the object itself (or 0 (4 bytes) if the pointer value is NULL) is written. If the declaration line has a comment beginning with ""//->"", this indicates that the pointer value will never be null, which allows a performance optimization. Another optimization is that if two or more pointers pointing to the same object are streamed in the same I/O operation, the object is written only once. The remaining pointers reference the object through a unique object identifier. This saves space and avoids the infinite loop that might otherwise arise if the directed graph of object instance pointer references contains a cycle.; If a data member is a pointer to a simple type, the Streamer presumes it is an array, with the dimension defined in a comment of the form ""//[<length>]"", where length is either an integer constant or a variable that is an integer data member of the class. If a variable is used, it must be defined ahead of its use or in a base class.; The above describes the function of the StreamerInfo record in decomposing a self-identifying object if the user uses the streamer generated by ""rootcint"". There are two reasons why a user may need to write a specialized streamer for a class. One reason is that it may be necessary to execute some code before or after data is read or written, for example, to initialize some non-persistent data members after the persistent data is read. In this case, the custom streamer can use the StreamerInfo record to decompose a self-identifying object in the exact same manner as the generated s",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/rootio.html:7371,Usability,simpl,simple,7371," selected (even if no compression is selected).; The compression algorithm used is an in memory ZIP compression written for the DELPHI collaboration at CERN. Its author is E. Chernyaev (IHEP/Protvino). The source code is internal to ROOTIO. StreamerInfo; The ""StreamerInfo"" data record is used by ROOTIO to support the storage of self-identifying objects. Its detailed format is given in Format of StreamerInfo record. A ROOTIO file contains exactly one StreamerInfo record, which is written to disk automatically when a new or modified file is closed.; The StreamerInfo record is a list (ROOTIO class TList) of ""StreamerInfo"" objects (ROOTIO class TStreamerInfo). There is one StreamerInfo object in the list for every class used in the file in a data record, other than a core layer record. There is no streamerinfo object for a class used in a core layer record unless the class is also used elsewhere in a data record. When reading a self-identifying object from a file, the system uses the StreamerInfo list to decompose the object recursively into its simple data members.; Each streamerinfo object is an array of ""streamer element"" objects, each of which describes a base class of the object or a (non-static and non-transient) data member of the object. If the base class or data member is itself a class, then there will also be a streamerinfo object in the record for that class. In this way, each class is recursively decomposed into its atomic elements, each of which is a simple type (e.g. ""int""). A ""long"" or ""unsigned long"" member is always written as an 8 byte quantity, even if it occupies only 4 bytes in memory.; A data member of a class is marked transient on the line of its declaration by a comment beginning with ""//!"". Such members are not written to disk, nor is there any streamerinfo for such a member.; A data member that is a C++ pointer (not to be confused with ""pointers to persistent; objects"" described below) is never written to disk as a pointer value. If it is a p",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/rootio.html:7798,Usability,simpl,simple,7798,"actly one StreamerInfo record, which is written to disk automatically when a new or modified file is closed.; The StreamerInfo record is a list (ROOTIO class TList) of ""StreamerInfo"" objects (ROOTIO class TStreamerInfo). There is one StreamerInfo object in the list for every class used in the file in a data record, other than a core layer record. There is no streamerinfo object for a class used in a core layer record unless the class is also used elsewhere in a data record. When reading a self-identifying object from a file, the system uses the StreamerInfo list to decompose the object recursively into its simple data members.; Each streamerinfo object is an array of ""streamer element"" objects, each of which describes a base class of the object or a (non-static and non-transient) data member of the object. If the base class or data member is itself a class, then there will also be a streamerinfo object in the record for that class. In this way, each class is recursively decomposed into its atomic elements, each of which is a simple type (e.g. ""int""). A ""long"" or ""unsigned long"" member is always written as an 8 byte quantity, even if it occupies only 4 bytes in memory.; A data member of a class is marked transient on the line of its declaration by a comment beginning with ""//!"". Such members are not written to disk, nor is there any streamerinfo for such a member.; A data member that is a C++ pointer (not to be confused with ""pointers to persistent; objects"" described below) is never written to disk as a pointer value. If it is a pointer to an object, the object itself (or 0 (4 bytes) if the pointer value is NULL) is written. If the declaration line has a comment beginning with ""//->"", this indicates that the pointer value will never be null, which allows a performance optimization. Another optimization is that if two or more pointers pointing to the same object are streamed in the same I/O operation, the object is written only once. The remaining pointers reference t",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/rootio.html:8991,Usability,simpl,simple,8991,"en to disk, nor is there any streamerinfo for such a member.; A data member that is a C++ pointer (not to be confused with ""pointers to persistent; objects"" described below) is never written to disk as a pointer value. If it is a pointer to an object, the object itself (or 0 (4 bytes) if the pointer value is NULL) is written. If the declaration line has a comment beginning with ""//->"", this indicates that the pointer value will never be null, which allows a performance optimization. Another optimization is that if two or more pointers pointing to the same object are streamed in the same I/O operation, the object is written only once. The remaining pointers reference the object through a unique object identifier. This saves space and avoids the infinite loop that might otherwise arise if the directed graph of object instance pointer references contains a cycle.; If a data member is a pointer to a simple type, the Streamer presumes it is an array, with the dimension defined in a comment of the form ""//[<length>]"", where length is either an integer constant or a variable that is an integer data member of the class. If a variable is used, it must be defined ahead of its use or in a base class.; The above describes the function of the StreamerInfo record in decomposing a self-identifying object if the user uses the streamer generated by ""rootcint"". There are two reasons why a user may need to write a specialized streamer for a class. One reason is that it may be necessary to execute some code before or after data is read or written, for example, to initialize some non-persistent data members after the persistent data is read. In this case, the custom streamer can use the StreamerInfo record to decompose a self-identifying object in the exact same manner as the generated streamer would have done. An example is given (for the Event class) in the Root User's Guide (URL below) (Input/Output chapter, Streamers subchapter). On the other hand, if the user needs to write a stream",MatchSource.WIKI,doc/master/rootio.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rootio.html
https://root.cern/doc/master/ROOTR_8C.html:200,Integrability,depend,dependency,200,". ROOT: bindings/r/tests/ROOTR.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions ; ROOTR.C File Reference. #include <TRInterface.h>. Include dependency graph for ROOTR.C:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Functions; Double_t myFunc (Double_t x);  ; void ROOTR ();  . Function Documentation. ◆ myFunc(). Double_t myFunc ; (; Double_t ; x). Definition at line 4 of file ROOTR.C. ◆ ROOTR(). void ROOTR ; (; ). Definition at line 9 of file ROOTR.C. bindingsrtestsROOTR.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:12 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/ROOTR_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ROOTR_8C.html
https://root.cern/doc/master/ROOTR_8C.html:19,Testability,test,tests,19,". ROOT: bindings/r/tests/ROOTR.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions ; ROOTR.C File Reference. #include <TRInterface.h>. Include dependency graph for ROOTR.C:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Functions; Double_t myFunc (Double_t x);  ; void ROOTR ();  . Function Documentation. ◆ myFunc(). Double_t myFunc ; (; Double_t ; x). Definition at line 4 of file ROOTR.C. ◆ ROOTR(). void ROOTR ; (; ). Definition at line 9 of file ROOTR.C. bindingsrtestsROOTR.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:12 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/ROOTR_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ROOTR_8C.html
https://root.cern/doc/master/ROOTR_8C_source.html:19,Testability,test,tests,19,". ROOT: bindings/r/tests/ROOTR.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ROOTR.C. Go to the documentation of this file. 1//script to test Modules; 2#include<TRInterface.h>; 3 ; 4Double_t myFunc(Double_t x); 5{; 6 return cos(x);; 7}; 8 ; 9void ROOTR(); 10{; 11 ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; 12 r.SetVerbose(kFALSE);; 13 r.LoadModule(""Gpad"");; 14 r.LoadModule(""Hist"");; 15 r.LoadModule(""Rint"");; 16 ; 17 r<<""x<-seq(0,2*pi,by=.1)"";; 18 r<<""c1<-new(TCanvas,'c1','dlnorm')"";; 19 r<<""u <-new(TGraph,length(x),x,dlnorm(x))"" ;//TGraph(int,double*,double*); 20 r<<""u$Draw()"";; 21 ; 22 r<<""c2<-new(TCanvas,'c2','DiLog from TMath')"";; 23 r<<""o<- new(TF1,'dilog','TMath::DiLog(x)',0,2*pi)"";; 24 r<<""o$Draw()"";; 25// ; 26 r<<""c3<-new(TCanvas,'c3','Custom')"";; 27 r<<""i <- new(TF1,'f2','[0]*myFunc([1]*x)',0,2*pi)""; ; 28 r<<""i$SetRange(0,2*pi)"";; 29 r<<""i$SetParameter(0,4)"";; 30 r<<""i$SetParameter(1,pi/2)"";; 31 r<<""print(i$Eval(0))"";; 32 r<<""print(i$Eval(c(0,pi)))"";; 33 r<<""i$Draw('')"";; 34 ; 35// r<<""gApp<-new(TRint,'ROOTR')"";; 36// r<<""gApp$ProcessLine('cout<<\""Calling cout from TRint\""<<endl;')"";; 37 ; 38}; ROOTRvoid ROOTR()Definition ROOTR.C:9; myFuncDouble_t myFunc(Double_t x)Definition ROOTR.C:4; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TRInterface.h; ROOT::R::TRInterfaceROOT R was implemented using the R Project library and the modules Rcpp and RInsideDefinition TRInterface.h:136; ROOT::R::TRInterface::Instancestatic TRInterface & Instance()static method to get an TRInterface instance referenceDefinition TRInterface.cxx:187; xDouble_t x[n]Definition legend1.C:17. bindingsrtestsROOTR.C. ROOT ",MatchSource.WIKI,doc/master/ROOTR_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ROOTR_8C_source.html
https://root.cern/doc/master/ROOTR_8C_source.html:187,Testability,test,test,187,". ROOT: bindings/r/tests/ROOTR.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ROOTR.C. Go to the documentation of this file. 1//script to test Modules; 2#include<TRInterface.h>; 3 ; 4Double_t myFunc(Double_t x); 5{; 6 return cos(x);; 7}; 8 ; 9void ROOTR(); 10{; 11 ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; 12 r.SetVerbose(kFALSE);; 13 r.LoadModule(""Gpad"");; 14 r.LoadModule(""Hist"");; 15 r.LoadModule(""Rint"");; 16 ; 17 r<<""x<-seq(0,2*pi,by=.1)"";; 18 r<<""c1<-new(TCanvas,'c1','dlnorm')"";; 19 r<<""u <-new(TGraph,length(x),x,dlnorm(x))"" ;//TGraph(int,double*,double*); 20 r<<""u$Draw()"";; 21 ; 22 r<<""c2<-new(TCanvas,'c2','DiLog from TMath')"";; 23 r<<""o<- new(TF1,'dilog','TMath::DiLog(x)',0,2*pi)"";; 24 r<<""o$Draw()"";; 25// ; 26 r<<""c3<-new(TCanvas,'c3','Custom')"";; 27 r<<""i <- new(TF1,'f2','[0]*myFunc([1]*x)',0,2*pi)""; ; 28 r<<""i$SetRange(0,2*pi)"";; 29 r<<""i$SetParameter(0,4)"";; 30 r<<""i$SetParameter(1,pi/2)"";; 31 r<<""print(i$Eval(0))"";; 32 r<<""print(i$Eval(c(0,pi)))"";; 33 r<<""i$Draw('')"";; 34 ; 35// r<<""gApp<-new(TRint,'ROOTR')"";; 36// r<<""gApp$ProcessLine('cout<<\""Calling cout from TRint\""<<endl;')"";; 37 ; 38}; ROOTRvoid ROOTR()Definition ROOTR.C:9; myFuncDouble_t myFunc(Double_t x)Definition ROOTR.C:4; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TRInterface.h; ROOT::R::TRInterfaceROOT R was implemented using the R Project library and the modules Rcpp and RInsideDefinition TRInterface.h:136; ROOT::R::TRInterface::Instancestatic TRInterface & Instance()static method to get an TRInterface instance referenceDefinition TRInterface.cxx:187; xDouble_t x[n]Definition legend1.C:17. bindingsrtestsROOTR.C. ROOT ",MatchSource.WIKI,doc/master/ROOTR_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ROOTR_8C_source.html
https://root.cern/doc/master/RotationZYX_8cxx_source.html:658,Deployability,update,update,658,". ROOT: math/genvector/src/RotationZYX.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. RotationZYX.cxx. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: W. Brown, M. Fischler, L. Moneta 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT FNAL MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for rotation in 3 dimensions, represented by RotationZYX; 12//; 13// Created by: Lorenzo Moneta, May 23 2007; 14//; 15// Last update: $Id$; 16//; 17#include ""Math/GenVector/RotationZYX.h""; 18 ; 19#include <cmath>; 20 ; 21#include ""Math/GenVector/Cartesian3D.h""; 22#include ""Math/GenVector/DisplacementVector3D.h""; 23#include ""Math/GenVector/Rotation3D.h""; 24#include ""Math/GenVector/Quaternion.h""; 25#include ""Math/GenVector/RotationX.h""; 26#include ""Math/GenVector/RotationY.h""; 27#include ""Math/GenVector/RotationZ.h""; 28 ; 29#include ""Math/GenVector/AxisAnglefwd.h""; 30 ; 31namespace ROOT {; 32 ; 33namespace Math {; 34 ; 35// ========== Constructors and Assignment =====================; 36 ; 37 ; 38 ; 39// ========== Operations =====================; 40 ; 41// DisplacementVector3D< Cartesian3D<double> >; 42// RotationZYX::; 43// operator() (const DisplacementVector3D< Cartesian3D<double> > & v) const; 44// {; 45// return Rotation3D(*this)(v);; 46// }; 47 ; 48 ; 49RotationZYX RotationZYX::operator * (const Rotation3D & r) const {; 50 // combine with a Rotation3D; 51 return RotationZYX ( Rotation3D(*this) * r );; 52}; 53 ; 54RotationZYX RotationZYX::operator * (const AxisAngle & a) const {; 55 // combine with a AxisAngle; 56 return RotationZYX ( Quaternion(*this) * Quaternion(a) );; 57}; 58 ; 59RotationZYX RotationZYX::operator * (const EulerAngles & e) const {; 60 // combine with EulerAngles; 61 return RotationZYX ( Quaternion(*this) * Quaternion(e) ",MatchSource.WIKI,doc/master/RotationZYX_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RotationZYX_8cxx_source.html
https://root.cern/doc/master/RotationZYX_8cxx_source.html:3273,Performance,perform,performance,3273,"return RotationZYX ( Quaternion(*this) * q );; 72}; 73 ; 74RotationZYX RotationZYX::operator * (const RotationX & r) const {; 75 // combine with a RotationX; 76 return RotationZYX ( Quaternion(*this) * r );; 77}; 78 ; 79RotationZYX RotationZYX::operator * (const RotationY & r) const {; 80 // combine with a RotationY; 81 return RotationZYX ( Quaternion(*this) * r );; 82}; 83 ; 84RotationZYX RotationZYX::operator * (const RotationZ & r) const {; 85 // combine with a RotationZ; 86 // TODO -- this can be made much faster because it merely adds; 87 // the r.Angle() to phi.; 88 Scalar newPhi = fPhi + r.Angle();; 89 if ( newPhi <= -Pi()|| newPhi > Pi() ) {; 90 newPhi = newPhi - std::floor( newPhi/(2*Pi()) +.5 ) * 2*Pi();; 91 }; 92 return RotationZYX ( newPhi, fTheta, fPsi );; 93}; 94 ; 95RotationZYX operator * ( RotationX const & r, RotationZYX const & e ) {; 96 return RotationZYX(r) * e; // TODO: improve performance; 97}; 98 ; 99RotationZYX operator * ( RotationY const & r, RotationZYX const & e ) {; 100 return RotationZYX(r) * e; // TODO: improve performance; 101}; 102 ; 103RotationZYX; 104operator * ( RotationZ const & r, RotationZYX const & e ) {; 105 return RotationZYX(r) * e; // TODO: improve performance; 106}; 107 ; 108void RotationZYX::Rectify(); 109{; 110 // rectify . The angle theta must be defined between [-PI/2,PI.2]; 111 // same as Euler- Angles, just here Theta is shifted by PI/2 with respect to; 112 // the theta of the EulerAngles class; 113 ; 114 Scalar theta2 = fTheta + M_PI_2;; 115 if ( theta2 < 0 || theta2 > Pi() ) {; 116 Scalar t = theta2 - std::floor( theta2/(2*Pi() ) ) * 2*Pi();; 117 if ( t <= Pi() ) {; 118 theta2 = t;; 119 } else {; 120 theta2 = 2*Pi() - t;; 121 fPhi = fPhi + Pi();; 122 fPsi = fPsi + Pi();; 123 }; 124 // ftheta is shifted of PI/2 w.r.t theta2; 125 fTheta = theta2 - M_PI_2;; 126 }; 127 ; 128 if ( fPhi <= -Pi()|| fPhi > Pi() ) {; 129 fPhi = fPhi - std::floor( fPhi/(2*Pi()) +.5 ) * 2*Pi();; 130 }; 131 ; 132 if ( fPsi <= -Pi()|| fPsi > P",MatchSource.WIKI,doc/master/RotationZYX_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RotationZYX_8cxx_source.html
https://root.cern/doc/master/RotationZYX_8cxx_source.html:3419,Performance,perform,performance,3419,"return RotationZYX ( Quaternion(*this) * q );; 72}; 73 ; 74RotationZYX RotationZYX::operator * (const RotationX & r) const {; 75 // combine with a RotationX; 76 return RotationZYX ( Quaternion(*this) * r );; 77}; 78 ; 79RotationZYX RotationZYX::operator * (const RotationY & r) const {; 80 // combine with a RotationY; 81 return RotationZYX ( Quaternion(*this) * r );; 82}; 83 ; 84RotationZYX RotationZYX::operator * (const RotationZ & r) const {; 85 // combine with a RotationZ; 86 // TODO -- this can be made much faster because it merely adds; 87 // the r.Angle() to phi.; 88 Scalar newPhi = fPhi + r.Angle();; 89 if ( newPhi <= -Pi()|| newPhi > Pi() ) {; 90 newPhi = newPhi - std::floor( newPhi/(2*Pi()) +.5 ) * 2*Pi();; 91 }; 92 return RotationZYX ( newPhi, fTheta, fPsi );; 93}; 94 ; 95RotationZYX operator * ( RotationX const & r, RotationZYX const & e ) {; 96 return RotationZYX(r) * e; // TODO: improve performance; 97}; 98 ; 99RotationZYX operator * ( RotationY const & r, RotationZYX const & e ) {; 100 return RotationZYX(r) * e; // TODO: improve performance; 101}; 102 ; 103RotationZYX; 104operator * ( RotationZ const & r, RotationZYX const & e ) {; 105 return RotationZYX(r) * e; // TODO: improve performance; 106}; 107 ; 108void RotationZYX::Rectify(); 109{; 110 // rectify . The angle theta must be defined between [-PI/2,PI.2]; 111 // same as Euler- Angles, just here Theta is shifted by PI/2 with respect to; 112 // the theta of the EulerAngles class; 113 ; 114 Scalar theta2 = fTheta + M_PI_2;; 115 if ( theta2 < 0 || theta2 > Pi() ) {; 116 Scalar t = theta2 - std::floor( theta2/(2*Pi() ) ) * 2*Pi();; 117 if ( t <= Pi() ) {; 118 theta2 = t;; 119 } else {; 120 theta2 = 2*Pi() - t;; 121 fPhi = fPhi + Pi();; 122 fPsi = fPsi + Pi();; 123 }; 124 // ftheta is shifted of PI/2 w.r.t theta2; 125 fTheta = theta2 - M_PI_2;; 126 }; 127 ; 128 if ( fPhi <= -Pi()|| fPhi > Pi() ) {; 129 fPhi = fPhi - std::floor( fPhi/(2*Pi()) +.5 ) * 2*Pi();; 130 }; 131 ; 132 if ( fPsi <= -Pi()|| fPsi > P",MatchSource.WIKI,doc/master/RotationZYX_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RotationZYX_8cxx_source.html
https://root.cern/doc/master/RotationZYX_8cxx_source.html:3572,Performance,perform,performance,3572,"return RotationZYX ( Quaternion(*this) * q );; 72}; 73 ; 74RotationZYX RotationZYX::operator * (const RotationX & r) const {; 75 // combine with a RotationX; 76 return RotationZYX ( Quaternion(*this) * r );; 77}; 78 ; 79RotationZYX RotationZYX::operator * (const RotationY & r) const {; 80 // combine with a RotationY; 81 return RotationZYX ( Quaternion(*this) * r );; 82}; 83 ; 84RotationZYX RotationZYX::operator * (const RotationZ & r) const {; 85 // combine with a RotationZ; 86 // TODO -- this can be made much faster because it merely adds; 87 // the r.Angle() to phi.; 88 Scalar newPhi = fPhi + r.Angle();; 89 if ( newPhi <= -Pi()|| newPhi > Pi() ) {; 90 newPhi = newPhi - std::floor( newPhi/(2*Pi()) +.5 ) * 2*Pi();; 91 }; 92 return RotationZYX ( newPhi, fTheta, fPsi );; 93}; 94 ; 95RotationZYX operator * ( RotationX const & r, RotationZYX const & e ) {; 96 return RotationZYX(r) * e; // TODO: improve performance; 97}; 98 ; 99RotationZYX operator * ( RotationY const & r, RotationZYX const & e ) {; 100 return RotationZYX(r) * e; // TODO: improve performance; 101}; 102 ; 103RotationZYX; 104operator * ( RotationZ const & r, RotationZYX const & e ) {; 105 return RotationZYX(r) * e; // TODO: improve performance; 106}; 107 ; 108void RotationZYX::Rectify(); 109{; 110 // rectify . The angle theta must be defined between [-PI/2,PI.2]; 111 // same as Euler- Angles, just here Theta is shifted by PI/2 with respect to; 112 // the theta of the EulerAngles class; 113 ; 114 Scalar theta2 = fTheta + M_PI_2;; 115 if ( theta2 < 0 || theta2 > Pi() ) {; 116 Scalar t = theta2 - std::floor( theta2/(2*Pi() ) ) * 2*Pi();; 117 if ( t <= Pi() ) {; 118 theta2 = t;; 119 } else {; 120 theta2 = 2*Pi() - t;; 121 fPhi = fPhi + Pi();; 122 fPsi = fPsi + Pi();; 123 }; 124 // ftheta is shifted of PI/2 w.r.t theta2; 125 fTheta = theta2 - M_PI_2;; 126 }; 127 ; 128 if ( fPhi <= -Pi()|| fPhi > Pi() ) {; 129 fPhi = fPhi - std::floor( fPhi/(2*Pi()) +.5 ) * 2*Pi();; 130 }; 131 ; 132 if ( fPsi <= -Pi()|| fPsi > P",MatchSource.WIKI,doc/master/RotationZYX_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RotationZYX_8cxx_source.html
https://root.cern/doc/master/RPageStorageFile_8hxx.html:591,Integrability,depend,dependency,591,". ROOT: tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces ; RPageStorageFile.hxx File ReferenceNTuple-related classes | ROOT7 classes. #include <ROOT/RMiniFile.hxx>; #include <ROOT/RNTuple.hxx>; #include <ROOT/RNTupleSerialize.hxx>; #include <ROOT/RNTupleZip.hxx>; #include <ROOT/RPageStorage.hxx>; #include <ROOT/RRawFile.hxx>; #include <string_view>; #include <array>; #include <cstdio>; #include <memory>; #include <optional>; #include <string>; #include <utility>. Include dependency graph for RPageStorageFile.hxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  ROOT::Experimental::Internal::RPageSinkFile::CommitBatch;  ; class  ROOT::Experimental::Internal::RPageSinkFile;  Storage provider that write ntuple pages into a file. More...;  ; class  ROOT::Experimental::Internal::RPageSourceFile;  Storage provider that reads ntuple pages from a file. More...;  ; struct  ROOT::Experimental::Internal::RPageSourceFile::RStructureBuffer;  Holds the uncompressed header and footer. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Experimental;  ; namespace  ROOT::Experimental::Internal;  ; namespace  ROOT::Internal;  . Detailed Description; AuthorJakob Blomer jblom.nosp@m.er@c.nosp@m.ern.c.nosp@m.h ; Date2019-11-21 ; WarningThis is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome! ; Definition in file RPageStorageFile.hxx. treentuplev7incROOTRPageStorageFile.hxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:26 ",MatchSource.WIKI,doc/master/RPageStorageFile_8hxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RPageStorageFile_8hxx.html
https://root.cern/doc/master/RQ__OBJECT_8h.html:221,Integrability,depend,dependency,221,". ROOT: core/base/inc/RQ_OBJECT.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Macros ; RQ_OBJECT.h File Reference. #include <TQObject.h>; #include <Varargs.h>. Include dependency graph for RQ_OBJECT.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Macros; #define RQ_OBJECT(sender_class);  ; #define RQ_OBJECT1(sender_class);  ; #define RQ_OBJECT2(sender_class);  . Macro Definition Documentation. ◆ RQ_OBJECT. #define RQ_OBJECT; (;  ; sender_class). Value: RQ_OBJECT1(sender_class)\; RQ_OBJECT2(sender_class); RQ_OBJECT1#define RQ_OBJECT1(sender_class)Definition RQ_OBJECT.h:66. Definition at line 87 of file RQ_OBJECT.h. ◆ RQ_OBJECT1. #define RQ_OBJECT1; (;  ; sender_class). Value:private:\; TQObjSender fQObject;\; public:\; TList *GetListOfSignals() const {return fQObject.GetListOfSignals();}\; Bool_t Connect(const char *sig,const char *cl,void *rcvr,const char *slt)\; {fQObject.SetSender(this);fQObject.SetSenderClassName(sender_class);return fQObject.Connect(sig,cl,rcvr,slt);}\; Bool_t Disconnect(const char *sig=nullptr,void *rcvr=nullptr,const char *slt=nullptr){return fQObject.Disconnect(sig,rcvr,slt);}\; void HighPriority(const char *signal_name,const char *slot_name=nullptr){fQObject.HighPriority(signal_name,slot_name);}\; void LowPriority(const char *signal_name,const char *slot_name=nullptr){fQObject.LowPriority(signal_name,slot_name);}\; template <typename... T> void EmitVA(const char *signal_name, Int_t nargs, const T&... params) \; { fQObject.EmitVA(signal_name,nargs,params...); } \; void Emit(const char *signal){EmitVA(signal, /*nargs*/0);} \; template <typename T> void Emit(const char *signal, const T& arg) { EmitVA(signal, /*nargs*/ 1, arg); } \; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinitio",MatchSource.WIKI,doc/master/RQ__OBJECT_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RQ__OBJECT_8h.html
https://root.cern/doc/master/RRangeCast_8hxx_source.html:2816,Availability,error,error,2816," methods.; 65template <typename T>; 66constexpr auto hasBeginEnd(int) -> decltype(std::begin(std::declval<T>()), std::end(std::declval<T>()), true); 67{; 68 return true;; 69}; 70 ; 71template <typename>; 72constexpr bool hasBeginEnd(...); 73{; 74 return false;; 75}; 76 ; 77template <typename T, typename WrappedIterator_t, bool isDynamic>; 78class TypedIter {; 79 ; 80public:; 81 TypedIter(WrappedIterator_t const &iter) : fIter{iter} {}; 82 ; 83 TypedIter &operator++(); 84 {; 85 ++fIter;; 86 return *this;; 87 }; 88 TypedIter operator++(int); 89 {; 90 TypedIter tmp(*this);; 91 operator++();; 92 return tmp;; 93 }; 94 bool operator==(const TypedIter &rhs) const { return fIter == rhs.fIter; }; 95 bool operator!=(const TypedIter &rhs) const { return fIter != rhs.fIter; }; 96 ; 97 void swap(TypedIter &other) { fIter.swap(other.fIter); }; 98 ; 99 // We want to know at compile time whether dynamic_cast or static_cast is; 100 // used. First of all to avoid overhead, but also to avoid a compiler; 101 // error when using dynamic_cast on a non-polymorphic class. In C++17,; 102 // this can be done easily with `if constexpr`, but for the older; 103 // standards we have to use a more verbose alternative. Both ways are; 104 // explicitely implemented for different standards, so that when the; 105 // minimum C++ standard for ROOT is raised to C++17 it's easy to remember; 106 // that we can avoid much boilerplate code in this file.; 107#if (__cplusplus < 201700L); 108 T operator*() { return ROOT::Internal::RCast<T, isDynamic>::cast(*fIter); }; 109#else; 110 T operator*(); 111 {; 112 if constexpr (isDynamic) {; 113 return dynamic_cast<T>(*fIter);; 114 } else {; 115 if constexpr (std::is_polymorphic<RBaseType<T>>::value) {; 116 assert(dynamic_cast<T>(*fIter));; 117 }; 118 return static_cast<T>(*fIter);; 119 }; 120 }; 121#endif; 122 ; 123private:; 124 WrappedIterator_t fIter;; 125};; 126 ; 127} // namespace Internal; 128 ; 129/// Wraps any collection that can be used in range-based loops a",MatchSource.WIKI,doc/master/RRangeCast_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RRangeCast_8hxx_source.html
https://root.cern/doc/master/RRangeCast_8hxx_source.html:6083,Integrability,depend,depending,6083,"in range-based loops and applies; 157/// static_cast<T> to each element. This function can be used for example to; 158/// cast all objects in a RooAbsCollection when iterating over them.; 159/// Example:; 160/// ~~~{.cpp}; 161/// class ClassA {; 162/// public:; 163/// virtual ~ClassA() {}; 164/// };; 165/// class ClassB : public ClassA {; 166/// };; 167///; 168/// B b1, b2, b3;; 169/// std::vector<A const*> vec{&b1, &b2, &b3};; 170///; 171/// for(auto *b : ROOT::RangeStaticCast<B const*>(vec)) {; 172/// // do something with b; 173/// }; 174/// ~~~; 175/// Make sure to not use `auto const&` in the range-based loop, as this will; 176/// cause a range-loop-bind-reference warning with the clang compiler.; 177template <typename T, typename Range_t>; 178RRangeCast<T, false, Range_t> RangeStaticCast(Range_t &&coll); 179{; 180 return std::forward<Range_t>(coll);; 181}; 182// Overload for C-style arrays. It's not possible to make an overload of the; 183// RRangeCast constructor itself, because when the C-style array is forwarded; 184// it might decay depending on the compiler version.; 185template <typename T, typename U, std::size_t N>; 186RRangeCast<T, false, std::span<U>> RangeStaticCast(U (&arr)[N]); 187{; 188 return std::span<U>(arr, arr + N);; 189}; 190 ; 191/// Takes any collection that can be used in range-based loops and applies; 192/// dynamic_cast<T> to each element. This function can be used for example to; 193/// cast all objects in a RooAbsCollection when iterating over them.; 194/// Example:; 195/// ~~~{.cpp}; 196///; 197/// class ClassA {; 198/// public:; 199/// virtual ~ClassA() {}; 200/// };; 201/// class ClassB : public ClassA {; 202/// };; 203///; 204/// A a1, a2;; 205/// B b1, b2, b3;; 206/// std::vector<A const*> vec{&b1, &a1, &b2, &a2, &b3};; 207///; 208/// for(auto *b : ROOT::RangeDynCast<B const*>(vec)) {; 209/// if(b) {; 210/// // do something with b; 211/// }; 212/// }; 213/// ~~~; 214/// Make sure to not use `auto const&` in the range-based loop, ",MatchSource.WIKI,doc/master/RRangeCast_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RRangeCast_8hxx_source.html
https://root.cern/doc/master/RRangeCast_8hxx_source.html:7457,Integrability,depend,depending,7457," to each element. This function can be used for example to; 193/// cast all objects in a RooAbsCollection when iterating over them.; 194/// Example:; 195/// ~~~{.cpp}; 196///; 197/// class ClassA {; 198/// public:; 199/// virtual ~ClassA() {}; 200/// };; 201/// class ClassB : public ClassA {; 202/// };; 203///; 204/// A a1, a2;; 205/// B b1, b2, b3;; 206/// std::vector<A const*> vec{&b1, &a1, &b2, &a2, &b3};; 207///; 208/// for(auto *b : ROOT::RangeDynCast<B const*>(vec)) {; 209/// if(b) {; 210/// // do something with b; 211/// }; 212/// }; 213/// ~~~; 214/// Make sure to not use `auto const&` in the range-based loop, as this will; 215/// cause a range-loop-bind-reference warning with the clang compiler.; 216template <typename T, typename Range_t>; 217RRangeCast<T, true, Range_t> RangeDynCast(Range_t &&coll); 218{; 219 return std::forward<Range_t>(coll);; 220}; 221// Overload for C-style arrays. It's not possible to make an overload of the; 222// RRangeCast constructor itself, because when the C-style array is forwarded; 223// it might decay depending on the compiler version.; 224template <typename T, typename U, std::size_t N>; 225RRangeCast<T, true, std::span<U>> RangeDynCast(U (&arr)[N]); 226{; 227 return std::span<U>(arr, arr + N);; 228}; 229 ; 230} // namespace ROOT; 231 ; 232#endif; RSpan.hxx; N#define N; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; ROOT::Internal::TypedIterDefinition RRangeCast.hxx:78; ROOT::Internal::TypedIter::operator*T operator*()Definition RRangeCast.hxx:108; ROOT::Internal::TypedIter::operator!=bool operator!=(const TypedIter &rhs) constDefinition RRangeCast.hxx:95; ROOT::Internal::TypedIter::TypedIterTypedIter(WrappedIterator_t const &iter)Definition RRangeCast.hxx:81; ROOT::Internal::TypedIter::operator==bool operator==(const TypedIter &rhs) constDefinition RRangeCast.hxx:94",MatchSource.WIKI,doc/master/RRangeCast_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RRangeCast_8hxx_source.html
https://root.cern/doc/master/RRangeCast_8hxx_source.html:2855,Modifiability,polymorphi,polymorphic,2855," methods.; 65template <typename T>; 66constexpr auto hasBeginEnd(int) -> decltype(std::begin(std::declval<T>()), std::end(std::declval<T>()), true); 67{; 68 return true;; 69}; 70 ; 71template <typename>; 72constexpr bool hasBeginEnd(...); 73{; 74 return false;; 75}; 76 ; 77template <typename T, typename WrappedIterator_t, bool isDynamic>; 78class TypedIter {; 79 ; 80public:; 81 TypedIter(WrappedIterator_t const &iter) : fIter{iter} {}; 82 ; 83 TypedIter &operator++(); 84 {; 85 ++fIter;; 86 return *this;; 87 }; 88 TypedIter operator++(int); 89 {; 90 TypedIter tmp(*this);; 91 operator++();; 92 return tmp;; 93 }; 94 bool operator==(const TypedIter &rhs) const { return fIter == rhs.fIter; }; 95 bool operator!=(const TypedIter &rhs) const { return fIter != rhs.fIter; }; 96 ; 97 void swap(TypedIter &other) { fIter.swap(other.fIter); }; 98 ; 99 // We want to know at compile time whether dynamic_cast or static_cast is; 100 // used. First of all to avoid overhead, but also to avoid a compiler; 101 // error when using dynamic_cast on a non-polymorphic class. In C++17,; 102 // this can be done easily with `if constexpr`, but for the older; 103 // standards we have to use a more verbose alternative. Both ways are; 104 // explicitely implemented for different standards, so that when the; 105 // minimum C++ standard for ROOT is raised to C++17 it's easy to remember; 106 // that we can avoid much boilerplate code in this file.; 107#if (__cplusplus < 201700L); 108 T operator*() { return ROOT::Internal::RCast<T, isDynamic>::cast(*fIter); }; 109#else; 110 T operator*(); 111 {; 112 if constexpr (isDynamic) {; 113 return dynamic_cast<T>(*fIter);; 114 } else {; 115 if constexpr (std::is_polymorphic<RBaseType<T>>::value) {; 116 assert(dynamic_cast<T>(*fIter));; 117 }; 118 return static_cast<T>(*fIter);; 119 }; 120 }; 121#endif; 122 ; 123private:; 124 WrappedIterator_t fIter;; 125};; 126 ; 127} // namespace Internal; 128 ; 129/// Wraps any collection that can be used in range-based loops a",MatchSource.WIKI,doc/master/RRangeCast_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RRangeCast_8hxx_source.html
https://root.cern/doc/master/RRangeCast_8hxx_source.html:2763,Safety,avoid,avoid,2763," methods.; 65template <typename T>; 66constexpr auto hasBeginEnd(int) -> decltype(std::begin(std::declval<T>()), std::end(std::declval<T>()), true); 67{; 68 return true;; 69}; 70 ; 71template <typename>; 72constexpr bool hasBeginEnd(...); 73{; 74 return false;; 75}; 76 ; 77template <typename T, typename WrappedIterator_t, bool isDynamic>; 78class TypedIter {; 79 ; 80public:; 81 TypedIter(WrappedIterator_t const &iter) : fIter{iter} {}; 82 ; 83 TypedIter &operator++(); 84 {; 85 ++fIter;; 86 return *this;; 87 }; 88 TypedIter operator++(int); 89 {; 90 TypedIter tmp(*this);; 91 operator++();; 92 return tmp;; 93 }; 94 bool operator==(const TypedIter &rhs) const { return fIter == rhs.fIter; }; 95 bool operator!=(const TypedIter &rhs) const { return fIter != rhs.fIter; }; 96 ; 97 void swap(TypedIter &other) { fIter.swap(other.fIter); }; 98 ; 99 // We want to know at compile time whether dynamic_cast or static_cast is; 100 // used. First of all to avoid overhead, but also to avoid a compiler; 101 // error when using dynamic_cast on a non-polymorphic class. In C++17,; 102 // this can be done easily with `if constexpr`, but for the older; 103 // standards we have to use a more verbose alternative. Both ways are; 104 // explicitely implemented for different standards, so that when the; 105 // minimum C++ standard for ROOT is raised to C++17 it's easy to remember; 106 // that we can avoid much boilerplate code in this file.; 107#if (__cplusplus < 201700L); 108 T operator*() { return ROOT::Internal::RCast<T, isDynamic>::cast(*fIter); }; 109#else; 110 T operator*(); 111 {; 112 if constexpr (isDynamic) {; 113 return dynamic_cast<T>(*fIter);; 114 } else {; 115 if constexpr (std::is_polymorphic<RBaseType<T>>::value) {; 116 assert(dynamic_cast<T>(*fIter));; 117 }; 118 return static_cast<T>(*fIter);; 119 }; 120 }; 121#endif; 122 ; 123private:; 124 WrappedIterator_t fIter;; 125};; 126 ; 127} // namespace Internal; 128 ; 129/// Wraps any collection that can be used in range-based loops a",MatchSource.WIKI,doc/master/RRangeCast_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RRangeCast_8hxx_source.html
https://root.cern/doc/master/RRangeCast_8hxx_source.html:2791,Safety,avoid,avoid,2791," methods.; 65template <typename T>; 66constexpr auto hasBeginEnd(int) -> decltype(std::begin(std::declval<T>()), std::end(std::declval<T>()), true); 67{; 68 return true;; 69}; 70 ; 71template <typename>; 72constexpr bool hasBeginEnd(...); 73{; 74 return false;; 75}; 76 ; 77template <typename T, typename WrappedIterator_t, bool isDynamic>; 78class TypedIter {; 79 ; 80public:; 81 TypedIter(WrappedIterator_t const &iter) : fIter{iter} {}; 82 ; 83 TypedIter &operator++(); 84 {; 85 ++fIter;; 86 return *this;; 87 }; 88 TypedIter operator++(int); 89 {; 90 TypedIter tmp(*this);; 91 operator++();; 92 return tmp;; 93 }; 94 bool operator==(const TypedIter &rhs) const { return fIter == rhs.fIter; }; 95 bool operator!=(const TypedIter &rhs) const { return fIter != rhs.fIter; }; 96 ; 97 void swap(TypedIter &other) { fIter.swap(other.fIter); }; 98 ; 99 // We want to know at compile time whether dynamic_cast or static_cast is; 100 // used. First of all to avoid overhead, but also to avoid a compiler; 101 // error when using dynamic_cast on a non-polymorphic class. In C++17,; 102 // this can be done easily with `if constexpr`, but for the older; 103 // standards we have to use a more verbose alternative. Both ways are; 104 // explicitely implemented for different standards, so that when the; 105 // minimum C++ standard for ROOT is raised to C++17 it's easy to remember; 106 // that we can avoid much boilerplate code in this file.; 107#if (__cplusplus < 201700L); 108 T operator*() { return ROOT::Internal::RCast<T, isDynamic>::cast(*fIter); }; 109#else; 110 T operator*(); 111 {; 112 if constexpr (isDynamic) {; 113 return dynamic_cast<T>(*fIter);; 114 } else {; 115 if constexpr (std::is_polymorphic<RBaseType<T>>::value) {; 116 assert(dynamic_cast<T>(*fIter));; 117 }; 118 return static_cast<T>(*fIter);; 119 }; 120 }; 121#endif; 122 ; 123private:; 124 WrappedIterator_t fIter;; 125};; 126 ; 127} // namespace Internal; 128 ; 129/// Wraps any collection that can be used in range-based loops a",MatchSource.WIKI,doc/master/RRangeCast_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RRangeCast_8hxx_source.html
https://root.cern/doc/master/RRangeCast_8hxx_source.html:3203,Safety,avoid,avoid,3203,"_t, bool isDynamic>; 78class TypedIter {; 79 ; 80public:; 81 TypedIter(WrappedIterator_t const &iter) : fIter{iter} {}; 82 ; 83 TypedIter &operator++(); 84 {; 85 ++fIter;; 86 return *this;; 87 }; 88 TypedIter operator++(int); 89 {; 90 TypedIter tmp(*this);; 91 operator++();; 92 return tmp;; 93 }; 94 bool operator==(const TypedIter &rhs) const { return fIter == rhs.fIter; }; 95 bool operator!=(const TypedIter &rhs) const { return fIter != rhs.fIter; }; 96 ; 97 void swap(TypedIter &other) { fIter.swap(other.fIter); }; 98 ; 99 // We want to know at compile time whether dynamic_cast or static_cast is; 100 // used. First of all to avoid overhead, but also to avoid a compiler; 101 // error when using dynamic_cast on a non-polymorphic class. In C++17,; 102 // this can be done easily with `if constexpr`, but for the older; 103 // standards we have to use a more verbose alternative. Both ways are; 104 // explicitely implemented for different standards, so that when the; 105 // minimum C++ standard for ROOT is raised to C++17 it's easy to remember; 106 // that we can avoid much boilerplate code in this file.; 107#if (__cplusplus < 201700L); 108 T operator*() { return ROOT::Internal::RCast<T, isDynamic>::cast(*fIter); }; 109#else; 110 T operator*(); 111 {; 112 if constexpr (isDynamic) {; 113 return dynamic_cast<T>(*fIter);; 114 } else {; 115 if constexpr (std::is_polymorphic<RBaseType<T>>::value) {; 116 assert(dynamic_cast<T>(*fIter));; 117 }; 118 return static_cast<T>(*fIter);; 119 }; 120 }; 121#endif; 122 ; 123private:; 124 WrappedIterator_t fIter;; 125};; 126 ; 127} // namespace Internal; 128 ; 129/// Wraps any collection that can be used in range-based loops and applies; 130/// `static_cast<T>` or `dynamic_cast<T>` to each element.; 131/// \tparam T The new type to convert to.; 132/// \tparam isDynamic If `true`, `dynamic_cast` is used, otherwise `static_cast` is used.; 133/// \tparam Range_t The type of the input range, which should be usually a reference type to avoid cop",MatchSource.WIKI,doc/master/RRangeCast_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RRangeCast_8hxx_source.html
https://root.cern/doc/master/RRangeCast_8hxx_source.html:4121,Safety,avoid,avoid,4121,"ndards, so that when the; 105 // minimum C++ standard for ROOT is raised to C++17 it's easy to remember; 106 // that we can avoid much boilerplate code in this file.; 107#if (__cplusplus < 201700L); 108 T operator*() { return ROOT::Internal::RCast<T, isDynamic>::cast(*fIter); }; 109#else; 110 T operator*(); 111 {; 112 if constexpr (isDynamic) {; 113 return dynamic_cast<T>(*fIter);; 114 } else {; 115 if constexpr (std::is_polymorphic<RBaseType<T>>::value) {; 116 assert(dynamic_cast<T>(*fIter));; 117 }; 118 return static_cast<T>(*fIter);; 119 }; 120 }; 121#endif; 122 ; 123private:; 124 WrappedIterator_t fIter;; 125};; 126 ; 127} // namespace Internal; 128 ; 129/// Wraps any collection that can be used in range-based loops and applies; 130/// `static_cast<T>` or `dynamic_cast<T>` to each element.; 131/// \tparam T The new type to convert to.; 132/// \tparam isDynamic If `true`, `dynamic_cast` is used, otherwise `static_cast` is used.; 133/// \tparam Range_t The type of the input range, which should be usually a reference type to avoid copying.; 134template <typename T, bool isDynamic, typename Range_t>; 135class RRangeCast {; 136 ; 137public:; 138 RRangeCast(Range_t &&inputRange) : fInputRange{inputRange}; 139 {; 140 static_assert(ROOT::Internal::hasBeginEnd<Range_t>(0),; 141 ""Type with no `begin` or `end` method passed to `RRangeCast`"");; 142 }; 143 ; 144 using const_iterator = Internal::TypedIter<T, decltype(std::cbegin(std::declval<Range_t>())), isDynamic>;; 145 const_iterator begin() const { return std::cbegin(fInputRange); }; 146 const_iterator end() const { return std::cend(fInputRange); }; 147 ; 148 using iterator = Internal::TypedIter<T, decltype(std::begin(std::declval<Range_t>())), isDynamic>;; 149 iterator begin() { return std::begin(fInputRange); }; 150 iterator end() { return std::end(fInputRange); }; 151 ; 152private:; 153 Range_t fInputRange;; 154};; 155 ; 156/// Takes any collection that can be used in range-based loops and applies; 157/// static_cast<T",MatchSource.WIKI,doc/master/RRangeCast_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RRangeCast_8hxx_source.html
https://root.cern/doc/master/RRangeCast_8hxx_source.html:1647,Testability,assert,assert,1647," 4/// \date 2021-08-04; 5 ; 6/*************************************************************************; 7 * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; 8 * All rights reserved. *; 9 * *; 10 * For the licensing terms see $ROOTSYS/LICENSE. *; 11 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 12 *************************************************************************/; 13 ; 14#ifndef ROOT_RRangeCast; 15#define ROOT_RRangeCast; 16 ; 17#include ""ROOT/RSpan.hxx""; 18 ; 19#include <cassert>; 20#include <iterator>; 21#include <type_traits>; 22#include <utility>; 23 ; 24namespace ROOT {; 25namespace Internal {; 26 ; 27template <typename T>; 28struct RBaseType {; 29 using type = typename std::remove_pointer<typename std::decay<T>::type>::type;; 30};; 31 ; 32#if (__cplusplus < 201700L); 33 ; 34template <typename T, bool isDynamic = true, bool isPolymorphic = std::is_polymorphic<RBaseType<T>>::value>; 35struct RCast {; 36 template <typename U>; 37 static T cast(U &&u); 38 {; 39 return dynamic_cast<T>(u);; 40 }; 41};; 42 ; 43template <typename T>; 44struct RCast<T, false, false> {; 45 template <typename U>; 46 static T cast(U &&u); 47 {; 48 return static_cast<T>(u);; 49 }; 50};; 51 ; 52template <typename T>; 53struct RCast<T, false, true> {; 54 template <typename U>; 55 static T cast(U &&u); 56 {; 57 assert(dynamic_cast<T>(u));; 58 return static_cast<T>(u);; 59 }; 60};; 61 ; 62#endif; 63 ; 64// For SFINAE-based checks for the existence of the `begin` and `end` methods.; 65template <typename T>; 66constexpr auto hasBeginEnd(int) -> decltype(std::begin(std::declval<T>()), std::end(std::declval<T>()), true); 67{; 68 return true;; 69}; 70 ; 71template <typename>; 72constexpr bool hasBeginEnd(...); 73{; 74 return false;; 75}; 76 ; 77template <typename T, typename WrappedIterator_t, bool isDynamic>; 78class TypedIter {; 79 ; 80public:; 81 TypedIter(WrappedIterator_t const &iter) : fIter{iter} {}; 82 ; 83 TypedIter &operator++(); 84 {; 85 ++fIter;; 86 ret",MatchSource.WIKI,doc/master/RRangeCast_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RRangeCast_8hxx_source.html
https://root.cern/doc/master/RRangeCast_8hxx_source.html:3545,Testability,assert,assert,3545,"Iter != rhs.fIter; }; 96 ; 97 void swap(TypedIter &other) { fIter.swap(other.fIter); }; 98 ; 99 // We want to know at compile time whether dynamic_cast or static_cast is; 100 // used. First of all to avoid overhead, but also to avoid a compiler; 101 // error when using dynamic_cast on a non-polymorphic class. In C++17,; 102 // this can be done easily with `if constexpr`, but for the older; 103 // standards we have to use a more verbose alternative. Both ways are; 104 // explicitely implemented for different standards, so that when the; 105 // minimum C++ standard for ROOT is raised to C++17 it's easy to remember; 106 // that we can avoid much boilerplate code in this file.; 107#if (__cplusplus < 201700L); 108 T operator*() { return ROOT::Internal::RCast<T, isDynamic>::cast(*fIter); }; 109#else; 110 T operator*(); 111 {; 112 if constexpr (isDynamic) {; 113 return dynamic_cast<T>(*fIter);; 114 } else {; 115 if constexpr (std::is_polymorphic<RBaseType<T>>::value) {; 116 assert(dynamic_cast<T>(*fIter));; 117 }; 118 return static_cast<T>(*fIter);; 119 }; 120 }; 121#endif; 122 ; 123private:; 124 WrappedIterator_t fIter;; 125};; 126 ; 127} // namespace Internal; 128 ; 129/// Wraps any collection that can be used in range-based loops and applies; 130/// `static_cast<T>` or `dynamic_cast<T>` to each element.; 131/// \tparam T The new type to convert to.; 132/// \tparam isDynamic If `true`, `dynamic_cast` is used, otherwise `static_cast` is used.; 133/// \tparam Range_t The type of the input range, which should be usually a reference type to avoid copying.; 134template <typename T, bool isDynamic, typename Range_t>; 135class RRangeCast {; 136 ; 137public:; 138 RRangeCast(Range_t &&inputRange) : fInputRange{inputRange}; 139 {; 140 static_assert(ROOT::Internal::hasBeginEnd<Range_t>(0),; 141 ""Type with no `begin` or `end` method passed to `RRangeCast`"");; 142 }; 143 ; 144 using const_iterator = Internal::TypedIter<T, decltype(std::cbegin(std::declval<Range_t>())), isDynamic>;; 14",MatchSource.WIKI,doc/master/RRangeCast_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RRangeCast_8hxx_source.html
https://root.cern/doc/master/RResultMap_8hxx_source.html:3695,Availability,avail,available,3695," 81 std::vector<std::string> variationNames{inmap.fKeys};; 82 Erase<std::string>(""nominal"", variationNames);; 83 ; 84 return ROOT::RDF::Experimental::RResultMap<T>(std::move(nominalResult), std::move(variedResults),; 85 std::move(variationNames), *(inmap.fLoopManager),; 86 std::move(nominalAction), std::move(variedAction));; 87}; 88} // namespace RDF; 89} // namespace Internal; 90 ; 91namespace RDF {; 92 ; 93class RResultHandle;; 94 ; 95namespace Experimental {; 96 ; 97template <typename T>; 98class RResultMap {; 99 ; 100 std::vector<std::string> fKeys; // values are the keys available in fMap; 101 std::unordered_map<std::string, std::shared_ptr<T>> fMap; // shared_ptrs are never null; 102 ROOT::Detail::RDF::RLoopManager *fLoopManager; // never null; 103 std::shared_ptr<ROOT::Internal::RDF::RActionBase> fNominalAction; // never null; 104 std::shared_ptr<ROOT::Internal::RDF::RActionBase> fVariedAction; // might be null if there are no variations; 105 ; 106 friend RResultMap; 107 ROOT::Internal::RDF::MakeResultMap<T>(std::shared_ptr<T> nominalResult,; 108 std::vector<std::shared_ptr<T>> &&variedResults,; 109 std::vector<std::string> &&keys, ROOT::Detail::RDF::RLoopManager &lm,; 110 std::shared_ptr<ROOT::Internal::RDF::RActionBase> nominalAction,; 111 std::shared_ptr<ROOT::Internal::RDF::RActionBase> variedAction);; 112 ; 113 friend RResultMap ROOT::Internal::RDF::CloneResultAndAction<T>(const RResultMap<T> &inmap);; 114 friend std::unique_ptr<ROOT::Detail::RDF::RMergeableVariations<T>>; 115 ROOT::Detail::RDF::GetMergeableValue<T>(RResultMap<T> &rmap);; 116 friend class ::ROOT::RDF::RResultHandle;; 117 ; 118 // The preconditions are that results and keys have the same size, are ordered the same way, and keys are unique.; 119 RResultMap(std::shared_ptr<T> &&nominalResult, std::vector<std::shared_ptr<T>> &&variedResults,; 120 std::vector<std::string> &&keys, ROOT::Detail::RDF::RLoopManager &lm,; 121 std::shared_ptr<ROOT::Internal::RDF::RActionBase> nominalAction,; 122 std",MatchSource.WIKI,doc/master/RResultMap_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultMap_8hxx_source.html
https://root.cern/doc/master/RResultMap_8hxx_source.html:8790,Availability,down,downcast,8790,"/// is not destroyed in the process and will still retain (shared) ownership of; 201/// the original results.; 202///; 203/// Example usage:; 204/// ~~~{.cpp}; 205/// auto df = ROOT::RDataFrame(10).Define(""x"", [] { return 1; });; 206/// auto h = df.Vary(""x"", [](){return ROOT::RVecI{-1, 2};}, {}, 2).Histo1D<int>(""x"");; 207/// auto hs = ROOT::RDF::Experimental::VariationsFor(h);; 208/// std::unique_ptr<RMergeableVariations<T>> m = ROOT::Detail::RDF::GetMergeableValue(hs);; 209/// ~~~; 210template <typename T>; 211std::unique_ptr<RMergeableVariations<T>> GetMergeableValue(ROOT::RDF::Experimental::RResultMap<T> &rmap); 212{; 213 rmap.RunEventLoopIfNeeded();; 214 ; 215 std::unique_ptr<RMergeableVariationsBase> mVariationsBase;; 216 if (rmap.fVariedAction != nullptr) {; 217 auto mValueBase = rmap.fVariedAction->GetMergeableValue();; 218 mVariationsBase.reset(static_cast<RMergeableVariationsBase *>(mValueBase.release())); // downcast unique_ptr; 219 } else {; 220 mVariationsBase = std::unique_ptr<RMergeableVariationsBase>({}, {});; 221 }; 222 mVariationsBase->AddNominal(rmap.fNominalAction->GetMergeableValue());; 223 ; 224 return std::make_unique<RMergeableVariations<T>>(std::move(*mVariationsBase));; 225}; 226} // namespace RDF; 227} // namespace Detail; 228} // namespace ROOT; 229 ; 230#endif; RActionBase.hxx; RLoopManager.hxx; RMergeableValue.hxx; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Utils.hxx; ROOT::Detail::RDF::RLoopManagerThe head node of a RDF computation graph.Definition RLoopManager.hxx:114; ROOT::Detail::RDF::RMergeableVariationsBaseA container for variation names and variation results.Definition RMergeableValue.hxx:569; ROOT::RDF::Experimental::RResultMapDefinition RResultMap.hxx:98; ROOT::RDF::Experimental::RResultMap::const_iteratortypename decltype(fMap)::const_iterator const_iteratorDefinition RResultMap.hxx:144; ROOT::RDF::Experimental::RResultMap::operator[]T & operator[](const std:",MatchSource.WIKI,doc/master/RResultMap_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultMap_8hxx_source.html
https://root.cern/doc/master/RResultMap_8hxx_source.html:9292,Availability,error,error,9292,"rgeableVariations<T>> m = ROOT::Detail::RDF::GetMergeableValue(hs);; 209/// ~~~; 210template <typename T>; 211std::unique_ptr<RMergeableVariations<T>> GetMergeableValue(ROOT::RDF::Experimental::RResultMap<T> &rmap); 212{; 213 rmap.RunEventLoopIfNeeded();; 214 ; 215 std::unique_ptr<RMergeableVariationsBase> mVariationsBase;; 216 if (rmap.fVariedAction != nullptr) {; 217 auto mValueBase = rmap.fVariedAction->GetMergeableValue();; 218 mVariationsBase.reset(static_cast<RMergeableVariationsBase *>(mValueBase.release())); // downcast unique_ptr; 219 } else {; 220 mVariationsBase = std::unique_ptr<RMergeableVariationsBase>({}, {});; 221 }; 222 mVariationsBase->AddNominal(rmap.fNominalAction->GetMergeableValue());; 223 ; 224 return std::make_unique<RMergeableVariations<T>>(std::move(*mVariationsBase));; 225}; 226} // namespace RDF; 227} // namespace Detail; 228} // namespace ROOT; 229 ; 230#endif; RActionBase.hxx; RLoopManager.hxx; RMergeableValue.hxx; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Utils.hxx; ROOT::Detail::RDF::RLoopManagerThe head node of a RDF computation graph.Definition RLoopManager.hxx:114; ROOT::Detail::RDF::RMergeableVariationsBaseA container for variation names and variation results.Definition RMergeableValue.hxx:569; ROOT::RDF::Experimental::RResultMapDefinition RResultMap.hxx:98; ROOT::RDF::Experimental::RResultMap::const_iteratortypename decltype(fMap)::const_iterator const_iteratorDefinition RResultMap.hxx:144; ROOT::RDF::Experimental::RResultMap::operator[]T & operator[](const std::string &key)Definition RResultMap.hxx:147; ROOT::RDF::Experimental::RResultMap::fLoopManagerROOT::Detail::RDF::RLoopManager * fLoopManagerDefinition RResultMap.hxx:102; ROOT::RDF::Experimental::RResultMap::RResultMapRResultMap(std::shared_ptr< T > &&nominalResult, std::vector< std::shared_ptr< T > > &&variedResults, std::vector< std::string > &&keys, ROOT::Detail::RDF::RLoopManager &lm, std::shared_ptr<",MatchSource.WIKI,doc/master/RResultMap_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultMap_8hxx_source.html
https://root.cern/doc/master/RResultMap_8hxx_source.html:8774,Deployability,release,release,8774,"/// is not destroyed in the process and will still retain (shared) ownership of; 201/// the original results.; 202///; 203/// Example usage:; 204/// ~~~{.cpp}; 205/// auto df = ROOT::RDataFrame(10).Define(""x"", [] { return 1; });; 206/// auto h = df.Vary(""x"", [](){return ROOT::RVecI{-1, 2};}, {}, 2).Histo1D<int>(""x"");; 207/// auto hs = ROOT::RDF::Experimental::VariationsFor(h);; 208/// std::unique_ptr<RMergeableVariations<T>> m = ROOT::Detail::RDF::GetMergeableValue(hs);; 209/// ~~~; 210template <typename T>; 211std::unique_ptr<RMergeableVariations<T>> GetMergeableValue(ROOT::RDF::Experimental::RResultMap<T> &rmap); 212{; 213 rmap.RunEventLoopIfNeeded();; 214 ; 215 std::unique_ptr<RMergeableVariationsBase> mVariationsBase;; 216 if (rmap.fVariedAction != nullptr) {; 217 auto mValueBase = rmap.fVariedAction->GetMergeableValue();; 218 mVariationsBase.reset(static_cast<RMergeableVariationsBase *>(mValueBase.release())); // downcast unique_ptr; 219 } else {; 220 mVariationsBase = std::unique_ptr<RMergeableVariationsBase>({}, {});; 221 }; 222 mVariationsBase->AddNominal(rmap.fNominalAction->GetMergeableValue());; 223 ; 224 return std::make_unique<RMergeableVariations<T>>(std::move(*mVariationsBase));; 225}; 226} // namespace RDF; 227} // namespace Detail; 228} // namespace ROOT; 229 ; 230#endif; RActionBase.hxx; RLoopManager.hxx; RMergeableValue.hxx; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Utils.hxx; ROOT::Detail::RDF::RLoopManagerThe head node of a RDF computation graph.Definition RLoopManager.hxx:114; ROOT::Detail::RDF::RMergeableVariationsBaseA container for variation names and variation results.Definition RMergeableValue.hxx:569; ROOT::RDF::Experimental::RResultMapDefinition RResultMap.hxx:98; ROOT::RDF::Experimental::RResultMap::const_iteratortypename decltype(fMap)::const_iterator const_iteratorDefinition RResultMap.hxx:144; ROOT::RDF::Experimental::RResultMap::operator[]T & operator[](const std:",MatchSource.WIKI,doc/master/RResultMap_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultMap_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:4408,Availability,error,error,4408,";; 92} // namespace RDF; 93} // namespace Detail; 94namespace RDF {; 95namespace RDFInternal = ROOT::Internal::RDF;; 96namespace RDFDetail = ROOT::Detail::RDF;; 97namespace TTraits = ROOT::TypeTraits;; 98 ; 99/// Smart pointer for the return type of actions; 100/**; 101\class ROOT::RDF::RResultPtr; 102\ingroup dataframe; 103\brief A wrapper around the result of RDataFrame actions able to trigger calculations lazily.; 104\tparam T Type of the action result; 105 ; 106A smart pointer which allows to access the result of a RDataFrame action. The; 107methods of the encapsulated object can be accessed via the arrow operator.; 108Upon invocation of the arrow operator or dereferencing (`operator*`), the; 109loop on the events and calculations of all scheduled actions are executed; 110if needed.; 111It is possible to iterate on the result proxy if the proxied object is a collection.; 112~~~{.cpp}; 113for (auto& myItem : myResultProxy) { ... };; 114~~~; 115If iteration is not supported by the type of the proxied object, a compilation error is thrown.; 116 ; 117*/; 118template <typename T>; 119class RResultPtr {; 120 // private using declarations; 121 using SPT_t = std::shared_ptr<T>;; 122 ; 123 // friend declarations; 124 template <typename T1>; 125 friend class RResultPtr;; 126 ; 127 template <typename T1>; 128 friend RResultPtr<T1> RDFDetail::MakeResultPtr(const std::shared_ptr<T1> &, ::ROOT::Detail::RDF::RLoopManager &,; 129 std::shared_ptr<RDFInternal::RActionBase>);; 130 ; 131 template <typename T1>; 132 friend ROOT::RDF::Experimental::RResultMap<T1> ROOT::RDF::Experimental::VariationsFor(RResultPtr<T1> resPtr);; 133 ; 134 template <class T1, class T2>; 135 friend bool operator==(const RResultPtr<T1> &lhs, const RResultPtr<T2> &rhs);; 136 template <class T1, class T2>; 137 friend bool operator!=(const RResultPtr<T1> &lhs, const RResultPtr<T2> &rhs);; 138 template <class T1>; 139 friend bool operator==(const RResultPtr<T1> &lhs, std::nullptr_t rhs);; 140 template <class T1",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:10365,Availability,error,error,10365,"bject.; 235 /// Triggers event loop and execution of all actions booked in the associated RLoopManager.; 236 T *GetPtr() { return Get(); }; 237 ; 238 /// Get a pointer to the encapsulated object.; 239 /// Triggers event loop and execution of all actions booked in the associated RLoopManager.; 240 T &operator*(); 241 {; 242 ThrowIfNull();; 243 return *Get();; 244 }; 245 ; 246 /// Get a pointer to the encapsulated object.; 247 /// Ownership is not transferred to the caller.; 248 /// Triggers event loop and execution of all actions booked in the associated RLoopManager.; 249 T *operator->(); 250 {; 251 ThrowIfNull();; 252 return Get();; 253 }; 254 ; 255 /// Return an iterator to the beginning of the contained object if this makes; 256 /// sense, throw a compilation error otherwise; 257 typename RIterationHelper<T>::Iterator_t begin(); 258 {; 259 ThrowIfNull();; 260 if (!fActionPtr->HasRun()); 261 TriggerRun();; 262 return RIterationHelper<T>::GetBegin(*fObjPtr);; 263 }; 264 ; 265 /// Return an iterator to the end of the contained object if this makes; 266 /// sense, throw a compilation error otherwise; 267 typename RIterationHelper<T>::Iterator_t end(); 268 {; 269 ThrowIfNull();; 270 if (!fActionPtr->HasRun()); 271 TriggerRun();; 272 return RIterationHelper<T>::GetEnd(*fObjPtr);; 273 }; 274 ; 275 // clang-format off; 276 /// Register a callback that RDataFrame will execute ""everyNEvents"" on a partial result.; 277 ///; 278 /// \param[in] everyNEvents Frequency at which the callback will be called, as a number of events processed; 279 /// \param[in] callback a callable with signature `void(Value_t&)` where Value_t is the type of the value contained in this RResultPtr; 280 /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; 281 ///; 282 /// The callback must be a callable (lambda, function, functor class...) that takes a reference to the result type as; 283 /// argument and returns nothing. RDataFrame will invoke registered callbacks pas",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:10692,Availability,error,error,10692,"bject.; 235 /// Triggers event loop and execution of all actions booked in the associated RLoopManager.; 236 T *GetPtr() { return Get(); }; 237 ; 238 /// Get a pointer to the encapsulated object.; 239 /// Triggers event loop and execution of all actions booked in the associated RLoopManager.; 240 T &operator*(); 241 {; 242 ThrowIfNull();; 243 return *Get();; 244 }; 245 ; 246 /// Get a pointer to the encapsulated object.; 247 /// Ownership is not transferred to the caller.; 248 /// Triggers event loop and execution of all actions booked in the associated RLoopManager.; 249 T *operator->(); 250 {; 251 ThrowIfNull();; 252 return Get();; 253 }; 254 ; 255 /// Return an iterator to the beginning of the contained object if this makes; 256 /// sense, throw a compilation error otherwise; 257 typename RIterationHelper<T>::Iterator_t begin(); 258 {; 259 ThrowIfNull();; 260 if (!fActionPtr->HasRun()); 261 TriggerRun();; 262 return RIterationHelper<T>::GetBegin(*fObjPtr);; 263 }; 264 ; 265 /// Return an iterator to the end of the contained object if this makes; 266 /// sense, throw a compilation error otherwise; 267 typename RIterationHelper<T>::Iterator_t end(); 268 {; 269 ThrowIfNull();; 270 if (!fActionPtr->HasRun()); 271 TriggerRun();; 272 return RIterationHelper<T>::GetEnd(*fObjPtr);; 273 }; 274 ; 275 // clang-format off; 276 /// Register a callback that RDataFrame will execute ""everyNEvents"" on a partial result.; 277 ///; 278 /// \param[in] everyNEvents Frequency at which the callback will be called, as a number of events processed; 279 /// \param[in] callback a callable with signature `void(Value_t&)` where Value_t is the type of the value contained in this RResultPtr; 280 /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; 281 ///; 282 /// The callback must be a callable (lambda, function, functor class...) that takes a reference to the result type as; 283 /// argument and returns nothing. RDataFrame will invoke registered callbacks pas",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:12870,Availability,avail,available,12870,"used e.g. to inspect partial results of the analysis while the event loop is running. For; 288 /// example one can draw an up-to-date version of a result histogram every 100 entries like this:; 289 /// \code{.cpp}; 290 /// auto h = tdf.Histo1D(""x"");; 291 /// TCanvas c(""c"",""x hist"");; 292 /// h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; 293 /// h->Draw(); // event loop runs here, this `Draw` is executed after the event loop is finished; 294 /// \endcode; 295 ///; 296 /// A value of 0 for everyNEvents indicates the callback must be executed only once, before running the event loop.; 297 /// A conveniece definition `kOnce` is provided to make this fact more expressive in user code (see snippet below).; 298 /// Multiple callbacks can be registered with the same RResultPtr (i.e. results of RDataFrame actions) and will; 299 /// be executed sequentially. Callbacks are executed in the order they were registered.; 300 /// The type of the value contained in a RResultPtr is also available as RResultPtr<T>::Value_t, e.g.; 301 /// \code{.cpp}; 302 /// auto h = tdf.Histo1D(""x"");; 303 /// // h.kOnce is 0; 304 /// // decltype(h)::Value_t is TH1D; 305 /// \endcode; 306 ///; 307 /// When implicit multi-threading is enabled, the callback:; 308 /// - will never be executed by multiple threads concurrently: it needs not be thread-safe. For example the snippet; 309 /// above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; 310 /// - will always be executed ""everyNEvents"": partial results will ""contain"" that number of events more from; 311 /// one call to the next; 312 /// - might be executed by a different worker thread at different times: the value of `std::this_thread::get_id()`; 313 /// might change between calls; 314 ///; 315 /// To register a callback that is called by _each_ worker thread (concurrently) every N events one can use; 316 /// OnPartialResultSlot().; 317 // clang-format on; 318 RResultPtr<T> &OnPar",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:26032,Availability,error,error,26032,"ert a RResultPtr<T2> to a RResultPtr<T>.Definition RResultPtr.hxx:222; ROOT::RDF::RResultPtr::fActionPtrstd::shared_ptr< RDFInternal::RActionBase > fActionPtrOwning pointer to the action that will produce this result.Definition RResultPtr.hxx:178; ROOT::RDF::RResultPtr::SPT_tstd::shared_ptr< T > SPT_tDefinition RResultPtr.hxx:121; ROOT::RDF::RResultPtr::operator->T * operator->()Get a pointer to the encapsulated object.Definition RResultPtr.hxx:249; ROOT::RDF::RResultPtr::fObjPtrSPT_t fObjPtrShared pointer encapsulating the wrapped result.Definition RResultPtr.hxx:175; ROOT::RDF::RResultPtr::kOncestatic constexpr ULong64_t kOnceConvenience definition to express a callback must be executed once.Definition RResultPtr.hxx:207; ROOT::RDF::RResultPtr::RResultPtrRResultPtr(std::shared_ptr< T > objPtr, RDFDetail::RLoopManager *lm, std::shared_ptr< RDFInternal::RActionBase > actionPtr)Definition RResultPtr.hxx:199; ROOT::RDF::RResultPtr::endRIterationHelper< T >::Iterator_t end()Return an iterator to the end of the contained object if this makes sense, throw a compilation error ...Definition RResultPtr.hxx:267; bool; T2#define T2Definition md5.inl:147; ROOT::Detail::RDFDefinition RooAbsDataHelper.h:80; ROOT::Detail::RDF::GetMergeableValuestd::unique_ptr< RMergeableVariations< T > > GetMergeableValue(ROOT::RDF::Experimental::RResultMap< T > &rmap)Retrieve mergeable values after calling ROOT::RDF::VariationsFor .Definition RResultMap.hxx:211; ROOT::Detail::RDF::MakeResultPtrRResultPtr< T > MakeResultPtr(const std::shared_ptr< T > &r, RLoopManager &df, std::shared_ptr< ROOT::Internal::RDF::RActionBase > actionPtr)Create a RResultPtr and set its pointer to the corresponding RAction This overload is invoked by non-...Definition RResultPtr.hxx:444; ROOT::Internal::RDFDefinition RArrowDS.hxx:23; ROOT::Internal::RDF::CloneResultAndActionROOT::RDF::Experimental::RResultMap< T > CloneResultAndAction(const ROOT::RDF::Experimental::RResultMap< T > &inmap)Clones an RResultMap and its co",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:20348,Deployability,release,release,20348,"reated with the result wrapped by; 457/// the RResultPtr argument. The user obtains ownership of the mergeable, which; 458/// in turn holds a copy of the result of the action. The RResultPtr is not; 459/// destroyed in the process and will still retain (shared) ownership of the; 460/// original result.; 461///; 462/// Example usage:; 463/// ~~~{.cpp}; 464/// using namespace ROOT::Detail::RDF;; 465/// ROOT::RDataFrame d(""myTree"", ""file_*.root"");; 466/// auto h = d.Histo1D(""Branch_A"");; 467/// auto mergeablehisto = GetMergeableValue(h);; 468/// ~~~; 469template <typename T>; 470std::unique_ptr<RMergeableValue<T>> GetMergeableValue(RResultPtr<T> &rptr); 471{; 472 rptr.ThrowIfNull();; 473 if (!rptr.fActionPtr->HasRun()); 474 rptr.TriggerRun(); // Prevents from using `const` specifier in parameter; 475 return std::unique_ptr<RMergeableValue<T>>{; 476 static_cast<RMergeableValue<T> *>(rptr.fActionPtr->GetMergeableValue().release())};; 477}; 478} // namespace RDF; 479} // namespace Detail; 480} // namespace ROOT; 481 ; 482#endif // ROOT_TRESULTPROXY; RActionBase.hxx; RLoopManager.hxx; c#define c(i)Definition RSha256.hxx:101; RtypesCore.h; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; operator!=Bool_t operator!=(const TDatime &d1, const TDatime &d2)Definition TDatime.h:104; TError.h; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; TypeTraits.hxx; ROOT::Detail::RDF::RLoopManagerThe head node of a RDF computation graph.Definition RLoopManager.hxx:114; ROOT::Detail::RDF::RLoopManager::Runvoid Run(bool jit=true)Start the event loop with a different mechani",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:4120,Energy Efficiency,schedul,scheduled,4120," &r, RLoopManager &df,; 84 std::shared_ptr<ROOT::Internal::RDF::RActionBase> actionPtr);; 85 ; 86// Fwd decl for GetMergeableValue; 87template <typename T>; 88class RMergeableValue;; 89 ; 90template <typename T>; 91std::unique_ptr<RMergeableValue<T>> GetMergeableValue(RResultPtr<T> &rptr);; 92} // namespace RDF; 93} // namespace Detail; 94namespace RDF {; 95namespace RDFInternal = ROOT::Internal::RDF;; 96namespace RDFDetail = ROOT::Detail::RDF;; 97namespace TTraits = ROOT::TypeTraits;; 98 ; 99/// Smart pointer for the return type of actions; 100/**; 101\class ROOT::RDF::RResultPtr; 102\ingroup dataframe; 103\brief A wrapper around the result of RDataFrame actions able to trigger calculations lazily.; 104\tparam T Type of the action result; 105 ; 106A smart pointer which allows to access the result of a RDataFrame action. The; 107methods of the encapsulated object can be accessed via the arrow operator.; 108Upon invocation of the arrow operator or dereferencing (`operator*`), the; 109loop on the events and calculations of all scheduled actions are executed; 110if needed.; 111It is possible to iterate on the result proxy if the proxied object is a collection.; 112~~~{.cpp}; 113for (auto& myItem : myResultProxy) { ... };; 114~~~; 115If iteration is not supported by the type of the proxied object, a compilation error is thrown.; 116 ; 117*/; 118template <typename T>; 119class RResultPtr {; 120 // private using declarations; 121 using SPT_t = std::shared_ptr<T>;; 122 ; 123 // friend declarations; 124 template <typename T1>; 125 friend class RResultPtr;; 126 ; 127 template <typename T1>; 128 friend RResultPtr<T1> RDFDetail::MakeResultPtr(const std::shared_ptr<T1> &, ::ROOT::Detail::RDF::RLoopManager &,; 129 std::shared_ptr<RDFInternal::RActionBase>);; 130 ; 131 template <typename T1>; 132 friend ROOT::RDF::Experimental::RResultMap<T1> ROOT::RDF::Experimental::VariationsFor(RResultPtr<T1> resPtr);; 133 ; 134 template <class T1, class T2>; 135 friend bool operator==(const RR",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:3703,Integrability,wrap,wrapper,3703,"l::RDF::RLoopManager, void>>;; 63/**; 64 * \brief Creates a new RResultPtr with a cloned Snapshot action.; 65 *; 66 * \param inptr The pointer.; 67 * \param outputFileName A new name for the output file of the cloned action.; 68 * \return A new pointer with a cloned action.; 69 *; 70 * This overload is needed since cloning a Snapshot node usually also involves; 71 * changing the name of the output file, otherwise the cloned Snapshot would; 72 * overwrite the same file.; 73 */; 74SnapshotPtr_t CloneResultAndAction(const SnapshotPtr_t &inptr, const std::string &outputFileName);; 75} // namespace RDF; 76} // namespace Internal; 77 ; 78namespace Detail {; 79namespace RDF {; 80using ROOT::RDF::RResultPtr;; 81// Fwd decl for RResultPtr; 82template <typename T>; 83RResultPtr<T> MakeResultPtr(const std::shared_ptr<T> &r, RLoopManager &df,; 84 std::shared_ptr<ROOT::Internal::RDF::RActionBase> actionPtr);; 85 ; 86// Fwd decl for GetMergeableValue; 87template <typename T>; 88class RMergeableValue;; 89 ; 90template <typename T>; 91std::unique_ptr<RMergeableValue<T>> GetMergeableValue(RResultPtr<T> &rptr);; 92} // namespace RDF; 93} // namespace Detail; 94namespace RDF {; 95namespace RDFInternal = ROOT::Internal::RDF;; 96namespace RDFDetail = ROOT::Detail::RDF;; 97namespace TTraits = ROOT::TypeTraits;; 98 ; 99/// Smart pointer for the return type of actions; 100/**; 101\class ROOT::RDF::RResultPtr; 102\ingroup dataframe; 103\brief A wrapper around the result of RDataFrame actions able to trigger calculations lazily.; 104\tparam T Type of the action result; 105 ; 106A smart pointer which allows to access the result of a RDataFrame action. The; 107methods of the encapsulated object can be accessed via the arrow operator.; 108Upon invocation of the arrow operator or dereferencing (`operator*`), the; 109loop on the events and calculations of all scheduled actions are executed; 110if needed.; 111It is possible to iterate on the result proxy if the proxied object is a collection.; 112~",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:7189,Integrability,wrap,wrapped,7189," /// \cond HIDDEN_SYMBOLS; 157 template <typename V, bool hasBeginEnd = TTraits::HasBeginAndEnd<V>::value>; 158 struct RIterationHelper {; 159 using Iterator_t = void;; 160 void GetBegin(const V &) { static_assert(sizeof(V) == 0, ""It does not make sense to ask begin for this class.""); }; 161 void GetEnd(const V &) { static_assert(sizeof(V) == 0, ""It does not make sense to ask end for this class.""); }; 162 };; 163 ; 164 template <typename V>; 165 struct RIterationHelper<V, true> {; 166 using Iterator_t = decltype(std::begin(std::declval<V>()));; 167 static Iterator_t GetBegin(const V &v) { return std::begin(v); };; 168 static Iterator_t GetEnd(const V &v) { return std::end(v); };; 169 };; 170 /// \endcond; 171 ; 172 /// Non-owning pointer to the RLoopManager at the root of this computation graph.; 173 /// The RLoopManager is guaranteed to be always in scope if fLoopManager is not a nullptr.; 174 RDFDetail::RLoopManager *fLoopManager = nullptr;; 175 SPT_t fObjPtr; ///< Shared pointer encapsulating the wrapped result; 176 /// Owning pointer to the action that will produce this result.; 177 /// Ownership is shared with other copies of this ResultPtr.; 178 std::shared_ptr<RDFInternal::RActionBase> fActionPtr;; 179 ; 180 /// Triggers the event loop in the RLoopManager; 181 void TriggerRun();; 182 ; 183 /// Get the pointer to the encapsulated result.; 184 /// Ownership is not transferred to the caller.; 185 /// Triggers event loop and execution of all actions booked in the associated RLoopManager.; 186 T *Get(); 187 {; 188 if (fActionPtr != nullptr && !fActionPtr->HasRun()); 189 TriggerRun();; 190 return fObjPtr.get();; 191 }; 192 ; 193 void ThrowIfNull(); 194 {; 195 if (fObjPtr == nullptr); 196 throw std::runtime_error(""Trying to access the contents of a null RResultPtr."");; 197 }; 198 ; 199 RResultPtr(std::shared_ptr<T> objPtr, RDFDetail::RLoopManager *lm,; 200 std::shared_ptr<RDFInternal::RActionBase> actionPtr); 201 : fLoopManager(lm), fObjPtr(std::move(objPtr)), fActi",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:19238,Integrability,wrap,wrapped,19238,"T1> &lhs, std::nullptr_t rhs); 426{; 427 return lhs.fObjPtr != rhs;; 428}; 429 ; 430template <class T1>; 431bool operator!=(std::nullptr_t lhs, const RResultPtr<T1> &rhs); 432{; 433 return lhs != rhs.fObjPtr;; 434}; 435 ; 436} // namespace RDF; 437 ; 438namespace Detail {; 439namespace RDF {; 440/// Create a RResultPtr and set its pointer to the corresponding RAction; 441/// This overload is invoked by non-jitted actions, as they have access to RAction before constructing RResultPtr.; 442template <typename T>; 443RResultPtr<T>; 444MakeResultPtr(const std::shared_ptr<T> &r, RLoopManager &lm, std::shared_ptr<RDFInternal::RActionBase> actionPtr); 445{; 446 return RResultPtr<T>(r, &lm, std::move(actionPtr));; 447}; 448 ; 449////////////////////////////////////////////////////////////////////////////////; 450/// \brief Retrieve a mergeable value from an RDataFrame action.; 451/// \param[in] rptr lvalue reference of an RResultPtr object.; 452/// \returns An RMergeableValue holding the result of the action, wrapped in an; 453/// `std::unique_ptr`.; 454///; 455/// This function triggers the execution of the RDataFrame computation graph.; 456/// Then retrieves an RMergeableValue object created with the result wrapped by; 457/// the RResultPtr argument. The user obtains ownership of the mergeable, which; 458/// in turn holds a copy of the result of the action. The RResultPtr is not; 459/// destroyed in the process and will still retain (shared) ownership of the; 460/// original result.; 461///; 462/// Example usage:; 463/// ~~~{.cpp}; 464/// using namespace ROOT::Detail::RDF;; 465/// ROOT::RDataFrame d(""myTree"", ""file_*.root"");; 466/// auto h = d.Histo1D(""Branch_A"");; 467/// auto mergeablehisto = GetMergeableValue(h);; 468/// ~~~; 469template <typename T>; 470std::unique_ptr<RMergeableValue<T>> GetMergeableValue(RResultPtr<T> &rptr); 471{; 472 rptr.ThrowIfNull();; 473 if (!rptr.fActionPtr->HasRun()); 474 rptr.TriggerRun(); // Prevents from using `const` specifier in parameter;",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:19442,Integrability,wrap,wrapped,19442,"Ptr;; 434}; 435 ; 436} // namespace RDF; 437 ; 438namespace Detail {; 439namespace RDF {; 440/// Create a RResultPtr and set its pointer to the corresponding RAction; 441/// This overload is invoked by non-jitted actions, as they have access to RAction before constructing RResultPtr.; 442template <typename T>; 443RResultPtr<T>; 444MakeResultPtr(const std::shared_ptr<T> &r, RLoopManager &lm, std::shared_ptr<RDFInternal::RActionBase> actionPtr); 445{; 446 return RResultPtr<T>(r, &lm, std::move(actionPtr));; 447}; 448 ; 449////////////////////////////////////////////////////////////////////////////////; 450/// \brief Retrieve a mergeable value from an RDataFrame action.; 451/// \param[in] rptr lvalue reference of an RResultPtr object.; 452/// \returns An RMergeableValue holding the result of the action, wrapped in an; 453/// `std::unique_ptr`.; 454///; 455/// This function triggers the execution of the RDataFrame computation graph.; 456/// Then retrieves an RMergeableValue object created with the result wrapped by; 457/// the RResultPtr argument. The user obtains ownership of the mergeable, which; 458/// in turn holds a copy of the result of the action. The RResultPtr is not; 459/// destroyed in the process and will still retain (shared) ownership of the; 460/// original result.; 461///; 462/// Example usage:; 463/// ~~~{.cpp}; 464/// using namespace ROOT::Detail::RDF;; 465/// ROOT::RDataFrame d(""myTree"", ""file_*.root"");; 466/// auto h = d.Histo1D(""Branch_A"");; 467/// auto mergeablehisto = GetMergeableValue(h);; 468/// ~~~; 469template <typename T>; 470std::unique_ptr<RMergeableValue<T>> GetMergeableValue(RResultPtr<T> &rptr); 471{; 472 rptr.ThrowIfNull();; 473 if (!rptr.fActionPtr->HasRun()); 474 rptr.TriggerRun(); // Prevents from using `const` specifier in parameter; 475 return std::unique_ptr<RMergeableValue<T>>{; 476 static_cast<RMergeableValue<T> *>(rptr.fActionPtr->GetMergeableValue().release())};; 477}; 478} // namespace RDF; 479} // namespace Detail; 480} // na",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:21423,Integrability,depend,depending,21423,"479} // namespace Detail; 480} // namespace ROOT; 481 ; 482#endif // ROOT_TRESULTPROXY; RActionBase.hxx; RLoopManager.hxx; c#define c(i)Definition RSha256.hxx:101; RtypesCore.h; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; operator!=Bool_t operator!=(const TDatime &d1, const TDatime &d2)Definition TDatime.h:104; TError.h; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; TypeTraits.hxx; ROOT::Detail::RDF::RLoopManagerThe head node of a RDF computation graph.Definition RLoopManager.hxx:114; ROOT::Detail::RDF::RLoopManager::Runvoid Run(bool jit=true)Start the event loop with a different mechanism depending on IMT/no IMT, data source/no data source.Definition RLoopManager.cxx:889; ROOT::Detail::RDF::RLoopManager::GetNSlotsunsigned int GetNSlots() constDefinition RLoopManager.hxx:230; ROOT::Detail::RDF::RLoopManager::RegisterCallbackvoid RegisterCallback(ULong64_t everyNEvents, std::function< void(unsigned int)> &&f)Definition RLoopManager.cxx:1033; ROOT::Detail::RDF::RMergeableValueA result of an RDataFrame execution, that knows how to merge with other results of the same type.Definition RMergeableValue.hxx:143; GraphCreatorHelperHelper class that provides the operation graph nodes.; ROOT::Internal::RDF::GraphDrawing::GraphCreatorHelperDefinition GraphUtils.hxx:57; ROOT::RDF::Experimental::RResultMapDefinition RResultMap.hxx:98; ROOT::RDF::RResultHandleA type-erased version of RResultPtr and RResultMap.Definition RResultHandle.hxx:33; ROOT::RDF::RResultPtrSmart pointer for the return type of actions.Definition RResultPtr.hxx:119; ROOT::RDF::RResul",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:25481,Integrability,wrap,wrapped,25481,"ULong64_t everyNEvents, std::function< void(unsigned int, T &)> callback)Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's ...Definition RResultPtr.hxx:364; ROOT::RDF::RResultPtr::operator=RResultPtr & operator=(RResultPtr &&)=default; ROOT::RDF::RResultPtr::operator==friend bool operator==(const RResultPtr< T1 > &lhs, const RResultPtr< T2 > &rhs)Definition RResultPtr.hxx:401; ROOT::RDF::RResultPtr::RResultPtrRResultPtr(const RResultPtr< T2 > &r)Convert a RResultPtr<T2> to a RResultPtr<T>.Definition RResultPtr.hxx:222; ROOT::RDF::RResultPtr::fActionPtrstd::shared_ptr< RDFInternal::RActionBase > fActionPtrOwning pointer to the action that will produce this result.Definition RResultPtr.hxx:178; ROOT::RDF::RResultPtr::SPT_tstd::shared_ptr< T > SPT_tDefinition RResultPtr.hxx:121; ROOT::RDF::RResultPtr::operator->T * operator->()Get a pointer to the encapsulated object.Definition RResultPtr.hxx:249; ROOT::RDF::RResultPtr::fObjPtrSPT_t fObjPtrShared pointer encapsulating the wrapped result.Definition RResultPtr.hxx:175; ROOT::RDF::RResultPtr::kOncestatic constexpr ULong64_t kOnceConvenience definition to express a callback must be executed once.Definition RResultPtr.hxx:207; ROOT::RDF::RResultPtr::RResultPtrRResultPtr(std::shared_ptr< T > objPtr, RDFDetail::RLoopManager *lm, std::shared_ptr< RDFInternal::RActionBase > actionPtr)Definition RResultPtr.hxx:199; ROOT::RDF::RResultPtr::endRIterationHelper< T >::Iterator_t end()Return an iterator to the end of the contained object if this makes sense, throw a compilation error ...Definition RResultPtr.hxx:267; bool; T2#define T2Definition md5.inl:147; ROOT::Detail::RDFDefinition RooAbsDataHelper.h:80; ROOT::Detail::RDF::GetMergeableValuestd::unique_ptr< RMergeableVariations< T > > GetMergeableValue(ROOT::RDF::Experimental::RResultMap< T > &rmap)Retrieve mergeable values after calling ROOT::RDF::VariationsFor .Definition RResultMap.hxx:211; ROOT::Detail::RDF::MakeResultPtrRResul",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:13085,Performance,multi-thread,multi-threading,13085,");; 291 /// TCanvas c(""c"",""x hist"");; 292 /// h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; 293 /// h->Draw(); // event loop runs here, this `Draw` is executed after the event loop is finished; 294 /// \endcode; 295 ///; 296 /// A value of 0 for everyNEvents indicates the callback must be executed only once, before running the event loop.; 297 /// A conveniece definition `kOnce` is provided to make this fact more expressive in user code (see snippet below).; 298 /// Multiple callbacks can be registered with the same RResultPtr (i.e. results of RDataFrame actions) and will; 299 /// be executed sequentially. Callbacks are executed in the order they were registered.; 300 /// The type of the value contained in a RResultPtr is also available as RResultPtr<T>::Value_t, e.g.; 301 /// \code{.cpp}; 302 /// auto h = tdf.Histo1D(""x"");; 303 /// // h.kOnce is 0; 304 /// // decltype(h)::Value_t is TH1D; 305 /// \endcode; 306 ///; 307 /// When implicit multi-threading is enabled, the callback:; 308 /// - will never be executed by multiple threads concurrently: it needs not be thread-safe. For example the snippet; 309 /// above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; 310 /// - will always be executed ""everyNEvents"": partial results will ""contain"" that number of events more from; 311 /// one call to the next; 312 /// - might be executed by a different worker thread at different times: the value of `std::this_thread::get_id()`; 313 /// might change between calls; 314 ///; 315 /// To register a callback that is called by _each_ worker thread (concurrently) every N events one can use; 316 /// OnPartialResultSlot().; 317 // clang-format on; 318 RResultPtr<T> &OnPartialResult(ULong64_t everyNEvents, std::function<void(T &)> callback); 319 {; 320 ThrowIfNull();; 321 const auto nSlots = fLoopManager->GetNSlots();; 322 auto actionPtr = fActionPtr;; 323 auto c = [nSlots, actionPtr, callback](unsigned int slot) ",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:13181,Performance,concurren,concurrently,13181,");; 291 /// TCanvas c(""c"",""x hist"");; 292 /// h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; 293 /// h->Draw(); // event loop runs here, this `Draw` is executed after the event loop is finished; 294 /// \endcode; 295 ///; 296 /// A value of 0 for everyNEvents indicates the callback must be executed only once, before running the event loop.; 297 /// A conveniece definition `kOnce` is provided to make this fact more expressive in user code (see snippet below).; 298 /// Multiple callbacks can be registered with the same RResultPtr (i.e. results of RDataFrame actions) and will; 299 /// be executed sequentially. Callbacks are executed in the order they were registered.; 300 /// The type of the value contained in a RResultPtr is also available as RResultPtr<T>::Value_t, e.g.; 301 /// \code{.cpp}; 302 /// auto h = tdf.Histo1D(""x"");; 303 /// // h.kOnce is 0; 304 /// // decltype(h)::Value_t is TH1D; 305 /// \endcode; 306 ///; 307 /// When implicit multi-threading is enabled, the callback:; 308 /// - will never be executed by multiple threads concurrently: it needs not be thread-safe. For example the snippet; 309 /// above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; 310 /// - will always be executed ""everyNEvents"": partial results will ""contain"" that number of events more from; 311 /// one call to the next; 312 /// - might be executed by a different worker thread at different times: the value of `std::this_thread::get_id()`; 313 /// might change between calls; 314 ///; 315 /// To register a callback that is called by _each_ worker thread (concurrently) every N events one can use; 316 /// OnPartialResultSlot().; 317 // clang-format on; 318 RResultPtr<T> &OnPartialResult(ULong64_t everyNEvents, std::function<void(T &)> callback); 319 {; 320 ThrowIfNull();; 321 const auto nSlots = fLoopManager->GetNSlots();; 322 auto actionPtr = fActionPtr;; 323 auto c = [nSlots, actionPtr, callback](unsigned int slot) ",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:13328,Performance,multi-thread,multi-thread,13328,"uted after the event loop is finished; 294 /// \endcode; 295 ///; 296 /// A value of 0 for everyNEvents indicates the callback must be executed only once, before running the event loop.; 297 /// A conveniece definition `kOnce` is provided to make this fact more expressive in user code (see snippet below).; 298 /// Multiple callbacks can be registered with the same RResultPtr (i.e. results of RDataFrame actions) and will; 299 /// be executed sequentially. Callbacks are executed in the order they were registered.; 300 /// The type of the value contained in a RResultPtr is also available as RResultPtr<T>::Value_t, e.g.; 301 /// \code{.cpp}; 302 /// auto h = tdf.Histo1D(""x"");; 303 /// // h.kOnce is 0; 304 /// // decltype(h)::Value_t is TH1D; 305 /// \endcode; 306 ///; 307 /// When implicit multi-threading is enabled, the callback:; 308 /// - will never be executed by multiple threads concurrently: it needs not be thread-safe. For example the snippet; 309 /// above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; 310 /// - will always be executed ""everyNEvents"": partial results will ""contain"" that number of events more from; 311 /// one call to the next; 312 /// - might be executed by a different worker thread at different times: the value of `std::this_thread::get_id()`; 313 /// might change between calls; 314 ///; 315 /// To register a callback that is called by _each_ worker thread (concurrently) every N events one can use; 316 /// OnPartialResultSlot().; 317 // clang-format on; 318 RResultPtr<T> &OnPartialResult(ULong64_t everyNEvents, std::function<void(T &)> callback); 319 {; 320 ThrowIfNull();; 321 const auto nSlots = fLoopManager->GetNSlots();; 322 auto actionPtr = fActionPtr;; 323 auto c = [nSlots, actionPtr, callback](unsigned int slot) {; 324 if (slot != nSlots - 1); 325 return;; 326 auto partialResult = static_cast<Value_t *>(actionPtr->PartialUpdate(slot));; 327 callback(*partialResult);; 328 };; 329 fLoopManager->R",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:13735,Performance,concurren,concurrently,13735,"nippet below).; 298 /// Multiple callbacks can be registered with the same RResultPtr (i.e. results of RDataFrame actions) and will; 299 /// be executed sequentially. Callbacks are executed in the order they were registered.; 300 /// The type of the value contained in a RResultPtr is also available as RResultPtr<T>::Value_t, e.g.; 301 /// \code{.cpp}; 302 /// auto h = tdf.Histo1D(""x"");; 303 /// // h.kOnce is 0; 304 /// // decltype(h)::Value_t is TH1D; 305 /// \endcode; 306 ///; 307 /// When implicit multi-threading is enabled, the callback:; 308 /// - will never be executed by multiple threads concurrently: it needs not be thread-safe. For example the snippet; 309 /// above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; 310 /// - will always be executed ""everyNEvents"": partial results will ""contain"" that number of events more from; 311 /// one call to the next; 312 /// - might be executed by a different worker thread at different times: the value of `std::this_thread::get_id()`; 313 /// might change between calls; 314 ///; 315 /// To register a callback that is called by _each_ worker thread (concurrently) every N events one can use; 316 /// OnPartialResultSlot().; 317 // clang-format on; 318 RResultPtr<T> &OnPartialResult(ULong64_t everyNEvents, std::function<void(T &)> callback); 319 {; 320 ThrowIfNull();; 321 const auto nSlots = fLoopManager->GetNSlots();; 322 auto actionPtr = fActionPtr;; 323 auto c = [nSlots, actionPtr, callback](unsigned int slot) {; 324 if (slot != nSlots - 1); 325 return;; 326 auto partialResult = static_cast<Value_t *>(actionPtr->PartialUpdate(slot));; 327 callback(*partialResult);; 328 };; 329 fLoopManager->RegisterCallback(everyNEvents, std::move(c));; 330 return *this;; 331 }; 332 ; 333 // clang-format off; 334 /// Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's partial result.; 335 ///; 336 /// \param[in] everyNEvents Frequency at which the",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:14470,Performance,concurren,concurrently,14470,"by multiple threads concurrently: it needs not be thread-safe. For example the snippet; 309 /// above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; 310 /// - will always be executed ""everyNEvents"": partial results will ""contain"" that number of events more from; 311 /// one call to the next; 312 /// - might be executed by a different worker thread at different times: the value of `std::this_thread::get_id()`; 313 /// might change between calls; 314 ///; 315 /// To register a callback that is called by _each_ worker thread (concurrently) every N events one can use; 316 /// OnPartialResultSlot().; 317 // clang-format on; 318 RResultPtr<T> &OnPartialResult(ULong64_t everyNEvents, std::function<void(T &)> callback); 319 {; 320 ThrowIfNull();; 321 const auto nSlots = fLoopManager->GetNSlots();; 322 auto actionPtr = fActionPtr;; 323 auto c = [nSlots, actionPtr, callback](unsigned int slot) {; 324 if (slot != nSlots - 1); 325 return;; 326 auto partialResult = static_cast<Value_t *>(actionPtr->PartialUpdate(slot));; 327 callback(*partialResult);; 328 };; 329 fLoopManager->RegisterCallback(everyNEvents, std::move(c));; 330 return *this;; 331 }; 332 ; 333 // clang-format off; 334 /// Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's partial result.; 335 ///; 336 /// \param[in] everyNEvents Frequency at which the callback will be called by each thread, as a number of events processed; 337 /// \param[in] callback A callable with signature `void(unsigned int, Value_t&)` where Value_t is the type of the value contained in this RResultPtr; 338 /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; 339 ///; 340 /// See `OnPartialResult` for a generic explanation of the callback mechanism.; 341 /// Compared to `OnPartialResult`, this method has two major differences:; 342 /// - all worker threads invoke the callback once every specified number of events. T",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:15237,Performance,concurren,concurrently,15237,">PartialUpdate(slot));; 327 callback(*partialResult);; 328 };; 329 fLoopManager->RegisterCallback(everyNEvents, std::move(c));; 330 return *this;; 331 }; 332 ; 333 // clang-format off; 334 /// Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's partial result.; 335 ///; 336 /// \param[in] everyNEvents Frequency at which the callback will be called by each thread, as a number of events processed; 337 /// \param[in] callback A callable with signature `void(unsigned int, Value_t&)` where Value_t is the type of the value contained in this RResultPtr; 338 /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; 339 ///; 340 /// See `OnPartialResult` for a generic explanation of the callback mechanism.; 341 /// Compared to `OnPartialResult`, this method has two major differences:; 342 /// - all worker threads invoke the callback once every specified number of events. The event count is per-thread,; 343 /// and callback invocation might happen concurrently (i.e. the callback must be thread-safe); 344 /// - the callable must take an extra `unsigned int` parameter corresponding to a multi-thread ""processing slot"":; 345 /// this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the; 346 /// callback concurrently but always with different `slot` numbers.; 347 /// - a value of 0 for everyNEvents indicates the callback must be executed once _per slot_.; 348 ///; 349 /// For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame; 350 /// \code; 351 /// auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; 352 /// std::string progress;; 353 /// std::mutex bar_mutex;; 354 /// c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; 355 /// std::lock_guard<std::mutex> lg(bar_mutex);; 356 /// progress.push_back('#');; 357 /// std::cout << ""\r",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:15377,Performance,multi-thread,multi-thread,15377,"taFrame will execute in each worker thread concurrently on that thread's partial result.; 335 ///; 336 /// \param[in] everyNEvents Frequency at which the callback will be called by each thread, as a number of events processed; 337 /// \param[in] callback A callable with signature `void(unsigned int, Value_t&)` where Value_t is the type of the value contained in this RResultPtr; 338 /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; 339 ///; 340 /// See `OnPartialResult` for a generic explanation of the callback mechanism.; 341 /// Compared to `OnPartialResult`, this method has two major differences:; 342 /// - all worker threads invoke the callback once every specified number of events. The event count is per-thread,; 343 /// and callback invocation might happen concurrently (i.e. the callback must be thread-safe); 344 /// - the callable must take an extra `unsigned int` parameter corresponding to a multi-thread ""processing slot"":; 345 /// this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the; 346 /// callback concurrently but always with different `slot` numbers.; 347 /// - a value of 0 for everyNEvents indicates the callback must be executed once _per slot_.; 348 ///; 349 /// For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame; 350 /// \code; 351 /// auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; 352 /// std::string progress;; 353 /// std::mutex bar_mutex;; 354 /// c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; 355 /// std::lock_guard<std::mutex> lg(bar_mutex);; 356 /// progress.push_back('#');; 357 /// std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; 358 /// });; 359 /// std::cout << ""Analysis running..."" << std::endl;; 360 /// *c; // trigger the event loop by accessing an action's result; 361 /// std",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:15546,Performance,concurren,concurrently,15546,"taFrame will execute in each worker thread concurrently on that thread's partial result.; 335 ///; 336 /// \param[in] everyNEvents Frequency at which the callback will be called by each thread, as a number of events processed; 337 /// \param[in] callback A callable with signature `void(unsigned int, Value_t&)` where Value_t is the type of the value contained in this RResultPtr; 338 /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; 339 ///; 340 /// See `OnPartialResult` for a generic explanation of the callback mechanism.; 341 /// Compared to `OnPartialResult`, this method has two major differences:; 342 /// - all worker threads invoke the callback once every specified number of events. The event count is per-thread,; 343 /// and callback invocation might happen concurrently (i.e. the callback must be thread-safe); 344 /// - the callable must take an extra `unsigned int` parameter corresponding to a multi-thread ""processing slot"":; 345 /// this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the; 346 /// callback concurrently but always with different `slot` numbers.; 347 /// - a value of 0 for everyNEvents indicates the callback must be executed once _per slot_.; 348 ///; 349 /// For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame; 350 /// \code; 351 /// auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; 352 /// std::string progress;; 353 /// std::mutex bar_mutex;; 354 /// c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; 355 /// std::lock_guard<std::mutex> lg(bar_mutex);; 356 /// progress.push_back('#');; 357 /// std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; 358 /// });; 359 /// std::cout << ""Analysis running..."" << std::endl;; 360 /// *c; // trigger the event loop by accessing an action's result; 361 /// std",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:24590,Performance,concurren,concurrently,24590,"tPtr< T1 > &lhs, const RResultPtr< T2 > &rhs)Definition RResultPtr.hxx:407; ROOT::RDF::RResultPtr::beginRIterationHelper< T >::Iterator_t begin()Return an iterator to the beginning of the contained object if this makes sense, throw a compilation ...Definition RResultPtr.hxx:257; ROOT::RDF::RResultPtr::Value_tT Value_tConvenience alias to simplify access to proxied type.Definition RResultPtr.hxx:206; ROOT::RDF::RResultPtr::GetT * Get()Get the pointer to the encapsulated result.Definition RResultPtr.hxx:186; ROOT::RDF::RResultPtr::GetValueconst T & GetValue()Get a const reference to the encapsulated object.Definition RResultPtr.hxx:228; ROOT::RDF::RResultPtr::RResultPtrRResultPtr(const RResultPtr &)=default; ROOT::RDF::RResultPtr::operator*T & operator*()Get a pointer to the encapsulated object.Definition RResultPtr.hxx:240; ROOT::RDF::RResultPtr::operator=RResultPtr & operator=(const RResultPtr &)=default; ROOT::RDF::RResultPtr::OnPartialResultSlotRResultPtr< T > & OnPartialResultSlot(ULong64_t everyNEvents, std::function< void(unsigned int, T &)> callback)Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's ...Definition RResultPtr.hxx:364; ROOT::RDF::RResultPtr::operator=RResultPtr & operator=(RResultPtr &&)=default; ROOT::RDF::RResultPtr::operator==friend bool operator==(const RResultPtr< T1 > &lhs, const RResultPtr< T2 > &rhs)Definition RResultPtr.hxx:401; ROOT::RDF::RResultPtr::RResultPtrRResultPtr(const RResultPtr< T2 > &r)Convert a RResultPtr<T2> to a RResultPtr<T>.Definition RResultPtr.hxx:222; ROOT::RDF::RResultPtr::fActionPtrstd::shared_ptr< RDFInternal::RActionBase > fActionPtrOwning pointer to the action that will produce this result.Definition RResultPtr.hxx:178; ROOT::RDF::RResultPtr::SPT_tstd::shared_ptr< T > SPT_tDefinition RResultPtr.hxx:121; ROOT::RDF::RResultPtr::operator->T * operator->()Get a pointer to the encapsulated object.Definition RResultPtr.hxx:249; ROOT::RDF::RResultPtr::fObjPtrSPT_t fObjPt",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:13218,Safety,safe,safe,13218,");; 291 /// TCanvas c(""c"",""x hist"");; 292 /// h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; 293 /// h->Draw(); // event loop runs here, this `Draw` is executed after the event loop is finished; 294 /// \endcode; 295 ///; 296 /// A value of 0 for everyNEvents indicates the callback must be executed only once, before running the event loop.; 297 /// A conveniece definition `kOnce` is provided to make this fact more expressive in user code (see snippet below).; 298 /// Multiple callbacks can be registered with the same RResultPtr (i.e. results of RDataFrame actions) and will; 299 /// be executed sequentially. Callbacks are executed in the order they were registered.; 300 /// The type of the value contained in a RResultPtr is also available as RResultPtr<T>::Value_t, e.g.; 301 /// \code{.cpp}; 302 /// auto h = tdf.Histo1D(""x"");; 303 /// // h.kOnce is 0; 304 /// // decltype(h)::Value_t is TH1D; 305 /// \endcode; 306 ///; 307 /// When implicit multi-threading is enabled, the callback:; 308 /// - will never be executed by multiple threads concurrently: it needs not be thread-safe. For example the snippet; 309 /// above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; 310 /// - will always be executed ""everyNEvents"": partial results will ""contain"" that number of events more from; 311 /// one call to the next; 312 /// - might be executed by a different worker thread at different times: the value of `std::this_thread::get_id()`; 313 /// might change between calls; 314 ///; 315 /// To register a callback that is called by _each_ worker thread (concurrently) every N events one can use; 316 /// OnPartialResultSlot().; 317 // clang-format on; 318 RResultPtr<T> &OnPartialResult(ULong64_t everyNEvents, std::function<void(T &)> callback); 319 {; 320 ThrowIfNull();; 321 const auto nSlots = fLoopManager->GetNSlots();; 322 auto actionPtr = fActionPtr;; 323 auto c = [nSlots, actionPtr, callback](unsigned int slot) ",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:15284,Safety,safe,safe,15284,"taFrame will execute in each worker thread concurrently on that thread's partial result.; 335 ///; 336 /// \param[in] everyNEvents Frequency at which the callback will be called by each thread, as a number of events processed; 337 /// \param[in] callback A callable with signature `void(unsigned int, Value_t&)` where Value_t is the type of the value contained in this RResultPtr; 338 /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; 339 ///; 340 /// See `OnPartialResult` for a generic explanation of the callback mechanism.; 341 /// Compared to `OnPartialResult`, this method has two major differences:; 342 /// - all worker threads invoke the callback once every specified number of events. The event count is per-thread,; 343 /// and callback invocation might happen concurrently (i.e. the callback must be thread-safe); 344 /// - the callable must take an extra `unsigned int` parameter corresponding to a multi-thread ""processing slot"":; 345 /// this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the; 346 /// callback concurrently but always with different `slot` numbers.; 347 /// - a value of 0 for everyNEvents indicates the callback must be executed once _per slot_.; 348 ///; 349 /// For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame; 350 /// \code; 351 /// auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; 352 /// std::string progress;; 353 /// std::mutex bar_mutex;; 354 /// c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; 355 /// std::lock_guard<std::mutex> lg(bar_mutex);; 356 /// progress.push_back('#');; 357 /// std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; 358 /// });; 359 /// std::cout << ""Analysis running..."" << std::endl;; 360 /// *c; // trigger the event loop by accessing an action's result; 361 /// std",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:15470,Safety,safe,safe,15470,"taFrame will execute in each worker thread concurrently on that thread's partial result.; 335 ///; 336 /// \param[in] everyNEvents Frequency at which the callback will be called by each thread, as a number of events processed; 337 /// \param[in] callback A callable with signature `void(unsigned int, Value_t&)` where Value_t is the type of the value contained in this RResultPtr; 338 /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; 339 ///; 340 /// See `OnPartialResult` for a generic explanation of the callback mechanism.; 341 /// Compared to `OnPartialResult`, this method has two major differences:; 342 /// - all worker threads invoke the callback once every specified number of events. The event count is per-thread,; 343 /// and callback invocation might happen concurrently (i.e. the callback must be thread-safe); 344 /// - the callable must take an extra `unsigned int` parameter corresponding to a multi-thread ""processing slot"":; 345 /// this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the; 346 /// callback concurrently but always with different `slot` numbers.; 347 /// - a value of 0 for everyNEvents indicates the callback must be executed once _per slot_.; 348 ///; 349 /// For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame; 350 /// \code; 351 /// auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; 352 /// std::string progress;; 353 /// std::mutex bar_mutex;; 354 /// c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; 355 /// std::lock_guard<std::mutex> lg(bar_mutex);; 356 /// progress.push_back('#');; 357 /// std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; 358 /// });; 359 /// std::cout << ""Analysis running..."" << std::endl;; 360 /// *c; // trigger the event loop by accessing an action's result; 361 /// std",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:15772,Safety,safe,safe,15772,"tained in this RResultPtr; 338 /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; 339 ///; 340 /// See `OnPartialResult` for a generic explanation of the callback mechanism.; 341 /// Compared to `OnPartialResult`, this method has two major differences:; 342 /// - all worker threads invoke the callback once every specified number of events. The event count is per-thread,; 343 /// and callback invocation might happen concurrently (i.e. the callback must be thread-safe); 344 /// - the callable must take an extra `unsigned int` parameter corresponding to a multi-thread ""processing slot"":; 345 /// this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the; 346 /// callback concurrently but always with different `slot` numbers.; 347 /// - a value of 0 for everyNEvents indicates the callback must be executed once _per slot_.; 348 ///; 349 /// For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame; 350 /// \code; 351 /// auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; 352 /// std::string progress;; 353 /// std::mutex bar_mutex;; 354 /// c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; 355 /// std::lock_guard<std::mutex> lg(bar_mutex);; 356 /// progress.push_back('#');; 357 /// std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; 358 /// });; 359 /// std::cout << ""Analysis running..."" << std::endl;; 360 /// *c; // trigger the event loop by accessing an action's result; 361 /// std::cout << ""\nDone!"" << std::endl;; 362 /// \endcode; 363 // clang-format on; 364 RResultPtr<T> &OnPartialResultSlot(ULong64_t everyNEvents, std::function<void(unsigned int, T &)> callback); 365 {; 366 ThrowIfNull();; 367 auto actionPtr = fActionPtr;; 368 auto c = [actionPtr, callback](unsigned int slot) {; 369 auto partialResult = static_cast<Value_t *",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:3870,Security,access,access,3870," namespace RDF; 76} // namespace Internal; 77 ; 78namespace Detail {; 79namespace RDF {; 80using ROOT::RDF::RResultPtr;; 81// Fwd decl for RResultPtr; 82template <typename T>; 83RResultPtr<T> MakeResultPtr(const std::shared_ptr<T> &r, RLoopManager &df,; 84 std::shared_ptr<ROOT::Internal::RDF::RActionBase> actionPtr);; 85 ; 86// Fwd decl for GetMergeableValue; 87template <typename T>; 88class RMergeableValue;; 89 ; 90template <typename T>; 91std::unique_ptr<RMergeableValue<T>> GetMergeableValue(RResultPtr<T> &rptr);; 92} // namespace RDF; 93} // namespace Detail; 94namespace RDF {; 95namespace RDFInternal = ROOT::Internal::RDF;; 96namespace RDFDetail = ROOT::Detail::RDF;; 97namespace TTraits = ROOT::TypeTraits;; 98 ; 99/// Smart pointer for the return type of actions; 100/**; 101\class ROOT::RDF::RResultPtr; 102\ingroup dataframe; 103\brief A wrapper around the result of RDataFrame actions able to trigger calculations lazily.; 104\tparam T Type of the action result; 105 ; 106A smart pointer which allows to access the result of a RDataFrame action. The; 107methods of the encapsulated object can be accessed via the arrow operator.; 108Upon invocation of the arrow operator or dereferencing (`operator*`), the; 109loop on the events and calculations of all scheduled actions are executed; 110if needed.; 111It is possible to iterate on the result proxy if the proxied object is a collection.; 112~~~{.cpp}; 113for (auto& myItem : myResultProxy) { ... };; 114~~~; 115If iteration is not supported by the type of the proxied object, a compilation error is thrown.; 116 ; 117*/; 118template <typename T>; 119class RResultPtr {; 120 // private using declarations; 121 using SPT_t = std::shared_ptr<T>;; 122 ; 123 // friend declarations; 124 template <typename T1>; 125 friend class RResultPtr;; 126 ; 127 template <typename T1>; 128 friend RResultPtr<T1> RDFDetail::MakeResultPtr(const std::shared_ptr<T1> &, ::ROOT::Detail::RDF::RLoopManager &,; 129 std::shared_ptr<RDFInternal::RActionBas",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:3962,Security,access,accessed,3962,"RDF::RResultPtr;; 81// Fwd decl for RResultPtr; 82template <typename T>; 83RResultPtr<T> MakeResultPtr(const std::shared_ptr<T> &r, RLoopManager &df,; 84 std::shared_ptr<ROOT::Internal::RDF::RActionBase> actionPtr);; 85 ; 86// Fwd decl for GetMergeableValue; 87template <typename T>; 88class RMergeableValue;; 89 ; 90template <typename T>; 91std::unique_ptr<RMergeableValue<T>> GetMergeableValue(RResultPtr<T> &rptr);; 92} // namespace RDF; 93} // namespace Detail; 94namespace RDF {; 95namespace RDFInternal = ROOT::Internal::RDF;; 96namespace RDFDetail = ROOT::Detail::RDF;; 97namespace TTraits = ROOT::TypeTraits;; 98 ; 99/// Smart pointer for the return type of actions; 100/**; 101\class ROOT::RDF::RResultPtr; 102\ingroup dataframe; 103\brief A wrapper around the result of RDataFrame actions able to trigger calculations lazily.; 104\tparam T Type of the action result; 105 ; 106A smart pointer which allows to access the result of a RDataFrame action. The; 107methods of the encapsulated object can be accessed via the arrow operator.; 108Upon invocation of the arrow operator or dereferencing (`operator*`), the; 109loop on the events and calculations of all scheduled actions are executed; 110if needed.; 111It is possible to iterate on the result proxy if the proxied object is a collection.; 112~~~{.cpp}; 113for (auto& myItem : myResultProxy) { ... };; 114~~~; 115If iteration is not supported by the type of the proxied object, a compilation error is thrown.; 116 ; 117*/; 118template <typename T>; 119class RResultPtr {; 120 // private using declarations; 121 using SPT_t = std::shared_ptr<T>;; 122 ; 123 // friend declarations; 124 template <typename T1>; 125 friend class RResultPtr;; 126 ; 127 template <typename T1>; 128 friend RResultPtr<T1> RDFDetail::MakeResultPtr(const std::shared_ptr<T1> &, ::ROOT::Detail::RDF::RLoopManager &,; 129 std::shared_ptr<RDFInternal::RActionBase>);; 130 ; 131 template <typename T1>; 132 friend ROOT::RDF::Experimental::RResultMap<T1> ROOT::RDF::Ex",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:7928,Security,access,access,7928," 171 ; 172 /// Non-owning pointer to the RLoopManager at the root of this computation graph.; 173 /// The RLoopManager is guaranteed to be always in scope if fLoopManager is not a nullptr.; 174 RDFDetail::RLoopManager *fLoopManager = nullptr;; 175 SPT_t fObjPtr; ///< Shared pointer encapsulating the wrapped result; 176 /// Owning pointer to the action that will produce this result.; 177 /// Ownership is shared with other copies of this ResultPtr.; 178 std::shared_ptr<RDFInternal::RActionBase> fActionPtr;; 179 ; 180 /// Triggers the event loop in the RLoopManager; 181 void TriggerRun();; 182 ; 183 /// Get the pointer to the encapsulated result.; 184 /// Ownership is not transferred to the caller.; 185 /// Triggers event loop and execution of all actions booked in the associated RLoopManager.; 186 T *Get(); 187 {; 188 if (fActionPtr != nullptr && !fActionPtr->HasRun()); 189 TriggerRun();; 190 return fObjPtr.get();; 191 }; 192 ; 193 void ThrowIfNull(); 194 {; 195 if (fObjPtr == nullptr); 196 throw std::runtime_error(""Trying to access the contents of a null RResultPtr."");; 197 }; 198 ; 199 RResultPtr(std::shared_ptr<T> objPtr, RDFDetail::RLoopManager *lm,; 200 std::shared_ptr<RDFInternal::RActionBase> actionPtr); 201 : fLoopManager(lm), fObjPtr(std::move(objPtr)), fActionPtr(std::move(actionPtr)); 202 {; 203 }; 204 ; 205public:; 206 using Value_t = T; ///< Convenience alias to simplify access to proxied type; 207 static constexpr ULong64_t kOnce = 0ull; ///< Convenience definition to express a callback must be executed once; 208 ; 209 RResultPtr() = default;; 210 RResultPtr(const RResultPtr &) = default;; 211 RResultPtr(RResultPtr &&) = default;; 212 RResultPtr &operator=(const RResultPtr &) = default;; 213 RResultPtr &operator=(RResultPtr &&) = default;; 214 explicit operator bool() const { return bool(fObjPtr); }; 215 ; 216 /// Convert a RResultPtr<T2> to a RResultPtr<T>.; 217 ///; 218 /// Useful e.g. to store a number of RResultPtr<TH1D> and RResultPtr<TH2D> in a std",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:8293,Security,access,access,8293,"nBase> fActionPtr;; 179 ; 180 /// Triggers the event loop in the RLoopManager; 181 void TriggerRun();; 182 ; 183 /// Get the pointer to the encapsulated result.; 184 /// Ownership is not transferred to the caller.; 185 /// Triggers event loop and execution of all actions booked in the associated RLoopManager.; 186 T *Get(); 187 {; 188 if (fActionPtr != nullptr && !fActionPtr->HasRun()); 189 TriggerRun();; 190 return fObjPtr.get();; 191 }; 192 ; 193 void ThrowIfNull(); 194 {; 195 if (fObjPtr == nullptr); 196 throw std::runtime_error(""Trying to access the contents of a null RResultPtr."");; 197 }; 198 ; 199 RResultPtr(std::shared_ptr<T> objPtr, RDFDetail::RLoopManager *lm,; 200 std::shared_ptr<RDFInternal::RActionBase> actionPtr); 201 : fLoopManager(lm), fObjPtr(std::move(objPtr)), fActionPtr(std::move(actionPtr)); 202 {; 203 }; 204 ; 205public:; 206 using Value_t = T; ///< Convenience alias to simplify access to proxied type; 207 static constexpr ULong64_t kOnce = 0ull; ///< Convenience definition to express a callback must be executed once; 208 ; 209 RResultPtr() = default;; 210 RResultPtr(const RResultPtr &) = default;; 211 RResultPtr(RResultPtr &&) = default;; 212 RResultPtr &operator=(const RResultPtr &) = default;; 213 RResultPtr &operator=(RResultPtr &&) = default;; 214 explicit operator bool() const { return bool(fObjPtr); }; 215 ; 216 /// Convert a RResultPtr<T2> to a RResultPtr<T>.; 217 ///; 218 /// Useful e.g. to store a number of RResultPtr<TH1D> and RResultPtr<TH2D> in a std::vector<RResultPtr<TH1>>.; 219 /// The requirements on T2 and T are the same as for conversion between std::shared_ptr<T2> and std::shared_ptr<T>.; 220 template <typename T2,; 221 std::enable_if_t<std::is_constructible<std::shared_ptr<T>, std::shared_ptr<T2>>::value, int> = 0>; 222 RResultPtr(const RResultPtr<T2> &r) : fLoopManager(r.fLoopManager), fObjPtr(r.fObjPtr), fActionPtr(r.fActionPtr); 223 {; 224 }; 225 ; 226 /// Get a const reference to the encapsulated object.; 227 /// Trigger",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:16387,Security,access,accessing,16387,"; 348 ///; 349 /// For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame; 350 /// \code; 351 /// auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; 352 /// std::string progress;; 353 /// std::mutex bar_mutex;; 354 /// c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; 355 /// std::lock_guard<std::mutex> lg(bar_mutex);; 356 /// progress.push_back('#');; 357 /// std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; 358 /// });; 359 /// std::cout << ""Analysis running..."" << std::endl;; 360 /// *c; // trigger the event loop by accessing an action's result; 361 /// std::cout << ""\nDone!"" << std::endl;; 362 /// \endcode; 363 // clang-format on; 364 RResultPtr<T> &OnPartialResultSlot(ULong64_t everyNEvents, std::function<void(unsigned int, T &)> callback); 365 {; 366 ThrowIfNull();; 367 auto actionPtr = fActionPtr;; 368 auto c = [actionPtr, callback](unsigned int slot) {; 369 auto partialResult = static_cast<Value_t *>(actionPtr->PartialUpdate(slot));; 370 callback(slot, *partialResult);; 371 };; 372 fLoopManager->RegisterCallback(everyNEvents, std::move(c));; 373 return *this;; 374 }; 375 ; 376 // clang-format off; 377 /// Check whether the result has already been computed; 378 ///; 379 /// ~~~{.cpp}; 380 /// auto res = df.Count();; 381 /// res.IsReady(); // false, access will trigger event loop; 382 /// std::cout << *res << std::endl; // triggers event loop; 383 /// res.IsReady(); // true; 384 /// ~~~; 385 // clang-format on; 386 bool IsReady() const; 387 {; 388 if (fActionPtr == nullptr); 389 return false;; 390 return fActionPtr->HasRun();; 391 }; 392};; 393 ; 394template <typename T>; 395void RResultPtr<T>::TriggerRun(); 396{; 397 fLoopManager->Run();; 398}; 399 ; 400template <class T1, class T2>; 401bool operator==(const RResultPtr<T1> &lhs, const RResultPtr<T2> &rhs); 402{; 403 return lhs.fObjPtr == rhs.fObjPt",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:17138,Security,access,access,17138," 357 /// std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; 358 /// });; 359 /// std::cout << ""Analysis running..."" << std::endl;; 360 /// *c; // trigger the event loop by accessing an action's result; 361 /// std::cout << ""\nDone!"" << std::endl;; 362 /// \endcode; 363 // clang-format on; 364 RResultPtr<T> &OnPartialResultSlot(ULong64_t everyNEvents, std::function<void(unsigned int, T &)> callback); 365 {; 366 ThrowIfNull();; 367 auto actionPtr = fActionPtr;; 368 auto c = [actionPtr, callback](unsigned int slot) {; 369 auto partialResult = static_cast<Value_t *>(actionPtr->PartialUpdate(slot));; 370 callback(slot, *partialResult);; 371 };; 372 fLoopManager->RegisterCallback(everyNEvents, std::move(c));; 373 return *this;; 374 }; 375 ; 376 // clang-format off; 377 /// Check whether the result has already been computed; 378 ///; 379 /// ~~~{.cpp}; 380 /// auto res = df.Count();; 381 /// res.IsReady(); // false, access will trigger event loop; 382 /// std::cout << *res << std::endl; // triggers event loop; 383 /// res.IsReady(); // true; 384 /// ~~~; 385 // clang-format on; 386 bool IsReady() const; 387 {; 388 if (fActionPtr == nullptr); 389 return false;; 390 return fActionPtr->HasRun();; 391 }; 392};; 393 ; 394template <typename T>; 395void RResultPtr<T>::TriggerRun(); 396{; 397 fLoopManager->Run();; 398}; 399 ; 400template <class T1, class T2>; 401bool operator==(const RResultPtr<T1> &lhs, const RResultPtr<T2> &rhs); 402{; 403 return lhs.fObjPtr == rhs.fObjPtr;; 404}; 405 ; 406template <class T1, class T2>; 407bool operator!=(const RResultPtr<T1> &lhs, const RResultPtr<T2> &rhs); 408{; 409 return lhs.fObjPtr != rhs.fObjPtr;; 410}; 411 ; 412template <class T1>; 413bool operator==(const RResultPtr<T1> &lhs, std::nullptr_t rhs); 414{; 415 return lhs.fObjPtr == rhs;; 416}; 417 ; 418template <class T1>; 419bool operator==(std::nullptr_t lhs, const RResultPtr<T1> &rhs); 420{; 421 return lhs == rhs.fObjPtr;; 422}; 423 ; 424template <class T",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:18661,Security,access,access,18661," T1, class T2>; 401bool operator==(const RResultPtr<T1> &lhs, const RResultPtr<T2> &rhs); 402{; 403 return lhs.fObjPtr == rhs.fObjPtr;; 404}; 405 ; 406template <class T1, class T2>; 407bool operator!=(const RResultPtr<T1> &lhs, const RResultPtr<T2> &rhs); 408{; 409 return lhs.fObjPtr != rhs.fObjPtr;; 410}; 411 ; 412template <class T1>; 413bool operator==(const RResultPtr<T1> &lhs, std::nullptr_t rhs); 414{; 415 return lhs.fObjPtr == rhs;; 416}; 417 ; 418template <class T1>; 419bool operator==(std::nullptr_t lhs, const RResultPtr<T1> &rhs); 420{; 421 return lhs == rhs.fObjPtr;; 422}; 423 ; 424template <class T1>; 425bool operator!=(const RResultPtr<T1> &lhs, std::nullptr_t rhs); 426{; 427 return lhs.fObjPtr != rhs;; 428}; 429 ; 430template <class T1>; 431bool operator!=(std::nullptr_t lhs, const RResultPtr<T1> &rhs); 432{; 433 return lhs != rhs.fObjPtr;; 434}; 435 ; 436} // namespace RDF; 437 ; 438namespace Detail {; 439namespace RDF {; 440/// Create a RResultPtr and set its pointer to the corresponding RAction; 441/// This overload is invoked by non-jitted actions, as they have access to RAction before constructing RResultPtr.; 442template <typename T>; 443RResultPtr<T>; 444MakeResultPtr(const std::shared_ptr<T> &r, RLoopManager &lm, std::shared_ptr<RDFInternal::RActionBase> actionPtr); 445{; 446 return RResultPtr<T>(r, &lm, std::move(actionPtr));; 447}; 448 ; 449////////////////////////////////////////////////////////////////////////////////; 450/// \brief Retrieve a mergeable value from an RDataFrame action.; 451/// \param[in] rptr lvalue reference of an RResultPtr object.; 452/// \returns An RMergeableValue holding the result of the action, wrapped in an; 453/// `std::unique_ptr`.; 454///; 455/// This function triggers the execution of the RDataFrame computation graph.; 456/// Then retrieves an RMergeableValue object created with the result wrapped by; 457/// the RResultPtr argument. The user obtains ownership of the mergeable, which; 458/// in turn holds a copy ",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:23796,Security,access,access,23796,"sultPtr::GetPtrT * GetPtr()Get the pointer to the encapsulated object.Definition RResultPtr.hxx:236; ROOT::RDF::RResultPtr::ThrowIfNullvoid ThrowIfNull()Definition RResultPtr.hxx:193; ROOT::RDF::RResultPtr::OnPartialResultRResultPtr< T > & OnPartialResult(ULong64_t everyNEvents, std::function< void(T &)> callback)Register a callback that RDataFrame will execute ""everyNEvents"" on a partial result.Definition RResultPtr.hxx:318; ROOT::RDF::RResultPtr::fLoopManagerRDFDetail::RLoopManager * fLoopManagerNon-owning pointer to the RLoopManager at the root of this computation graph.Definition RResultPtr.hxx:174; ROOT::RDF::RResultPtr::operator!=friend bool operator!=(const RResultPtr< T1 > &lhs, const RResultPtr< T2 > &rhs)Definition RResultPtr.hxx:407; ROOT::RDF::RResultPtr::beginRIterationHelper< T >::Iterator_t begin()Return an iterator to the beginning of the contained object if this makes sense, throw a compilation ...Definition RResultPtr.hxx:257; ROOT::RDF::RResultPtr::Value_tT Value_tConvenience alias to simplify access to proxied type.Definition RResultPtr.hxx:206; ROOT::RDF::RResultPtr::GetT * Get()Get the pointer to the encapsulated result.Definition RResultPtr.hxx:186; ROOT::RDF::RResultPtr::GetValueconst T & GetValue()Get a const reference to the encapsulated object.Definition RResultPtr.hxx:228; ROOT::RDF::RResultPtr::RResultPtrRResultPtr(const RResultPtr &)=default; ROOT::RDF::RResultPtr::operator*T & operator*()Get a pointer to the encapsulated object.Definition RResultPtr.hxx:240; ROOT::RDF::RResultPtr::operator=RResultPtr & operator=(const RResultPtr &)=default; ROOT::RDF::RResultPtr::OnPartialResultSlotRResultPtr< T > & OnPartialResultSlot(ULong64_t everyNEvents, std::function< void(unsigned int, T &)> callback)Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's ...Definition RResultPtr.hxx:364; ROOT::RDF::RResultPtr::operator=RResultPtr & operator=(RResultPtr &&)=default; ROOT::RDF::RResultPtr::operator==fri",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:8284,Usability,simpl,simplify,8284,"nBase> fActionPtr;; 179 ; 180 /// Triggers the event loop in the RLoopManager; 181 void TriggerRun();; 182 ; 183 /// Get the pointer to the encapsulated result.; 184 /// Ownership is not transferred to the caller.; 185 /// Triggers event loop and execution of all actions booked in the associated RLoopManager.; 186 T *Get(); 187 {; 188 if (fActionPtr != nullptr && !fActionPtr->HasRun()); 189 TriggerRun();; 190 return fObjPtr.get();; 191 }; 192 ; 193 void ThrowIfNull(); 194 {; 195 if (fObjPtr == nullptr); 196 throw std::runtime_error(""Trying to access the contents of a null RResultPtr."");; 197 }; 198 ; 199 RResultPtr(std::shared_ptr<T> objPtr, RDFDetail::RLoopManager *lm,; 200 std::shared_ptr<RDFInternal::RActionBase> actionPtr); 201 : fLoopManager(lm), fObjPtr(std::move(objPtr)), fActionPtr(std::move(actionPtr)); 202 {; 203 }; 204 ; 205public:; 206 using Value_t = T; ///< Convenience alias to simplify access to proxied type; 207 static constexpr ULong64_t kOnce = 0ull; ///< Convenience definition to express a callback must be executed once; 208 ; 209 RResultPtr() = default;; 210 RResultPtr(const RResultPtr &) = default;; 211 RResultPtr(RResultPtr &&) = default;; 212 RResultPtr &operator=(const RResultPtr &) = default;; 213 RResultPtr &operator=(RResultPtr &&) = default;; 214 explicit operator bool() const { return bool(fObjPtr); }; 215 ; 216 /// Convert a RResultPtr<T2> to a RResultPtr<T>.; 217 ///; 218 /// Useful e.g. to store a number of RResultPtr<TH1D> and RResultPtr<TH2D> in a std::vector<RResultPtr<TH1>>.; 219 /// The requirements on T2 and T are the same as for conversion between std::shared_ptr<T2> and std::shared_ptr<T>.; 220 template <typename T2,; 221 std::enable_if_t<std::is_constructible<std::shared_ptr<T>, std::shared_ptr<T2>>::value, int> = 0>; 222 RResultPtr(const RResultPtr<T2> &r) : fLoopManager(r.fLoopManager), fObjPtr(r.fObjPtr), fActionPtr(r.fActionPtr); 223 {; 224 }; 225 ; 226 /// Get a const reference to the encapsulated object.; 227 /// Trigger",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:15446,Usability,simpl,simplify,15446,"taFrame will execute in each worker thread concurrently on that thread's partial result.; 335 ///; 336 /// \param[in] everyNEvents Frequency at which the callback will be called by each thread, as a number of events processed; 337 /// \param[in] callback A callable with signature `void(unsigned int, Value_t&)` where Value_t is the type of the value contained in this RResultPtr; 338 /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; 339 ///; 340 /// See `OnPartialResult` for a generic explanation of the callback mechanism.; 341 /// Compared to `OnPartialResult`, this method has two major differences:; 342 /// - all worker threads invoke the callback once every specified number of events. The event count is per-thread,; 343 /// and callback invocation might happen concurrently (i.e. the callback must be thread-safe); 344 /// - the callable must take an extra `unsigned int` parameter corresponding to a multi-thread ""processing slot"":; 345 /// this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the; 346 /// callback concurrently but always with different `slot` numbers.; 347 /// - a value of 0 for everyNEvents indicates the callback must be executed once _per slot_.; 348 ///; 349 /// For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame; 350 /// \code; 351 /// auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; 352 /// std::string progress;; 353 /// std::mutex bar_mutex;; 354 /// c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; 355 /// std::lock_guard<std::mutex> lg(bar_mutex);; 356 /// progress.push_back('#');; 357 /// std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; 358 /// });; 359 /// std::cout << ""Analysis running..."" << std::endl;; 360 /// *c; // trigger the event loop by accessing an action's result; 361 /// std",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:15777,Usability,progress bar,progress bar,15777,"tained in this RResultPtr; 338 /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; 339 ///; 340 /// See `OnPartialResult` for a generic explanation of the callback mechanism.; 341 /// Compared to `OnPartialResult`, this method has two major differences:; 342 /// - all worker threads invoke the callback once every specified number of events. The event count is per-thread,; 343 /// and callback invocation might happen concurrently (i.e. the callback must be thread-safe); 344 /// - the callable must take an extra `unsigned int` parameter corresponding to a multi-thread ""processing slot"":; 345 /// this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the; 346 /// callback concurrently but always with different `slot` numbers.; 347 /// - a value of 0 for everyNEvents indicates the callback must be executed once _per slot_.; 348 ///; 349 /// For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame; 350 /// \code; 351 /// auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; 352 /// std::string progress;; 353 /// std::mutex bar_mutex;; 354 /// c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; 355 /// std::lock_guard<std::mutex> lg(bar_mutex);; 356 /// progress.push_back('#');; 357 /// std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; 358 /// });; 359 /// std::cout << ""Analysis running..."" << std::endl;; 360 /// *c; // trigger the event loop by accessing an action's result; 361 /// std::cout << ""\nDone!"" << std::endl;; 362 /// \endcode; 363 // clang-format on; 364 RResultPtr<T> &OnPartialResultSlot(ULong64_t everyNEvents, std::function<void(unsigned int, T &)> callback); 365 {; 366 ThrowIfNull();; 367 auto actionPtr = fActionPtr;; 368 auto c = [actionPtr, callback](unsigned int slot) {; 369 auto partialResult = static_cast<Value_t *",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/RResultPtr_8hxx_source.html:23787,Usability,simpl,simplify,23787,"sultPtr::GetPtrT * GetPtr()Get the pointer to the encapsulated object.Definition RResultPtr.hxx:236; ROOT::RDF::RResultPtr::ThrowIfNullvoid ThrowIfNull()Definition RResultPtr.hxx:193; ROOT::RDF::RResultPtr::OnPartialResultRResultPtr< T > & OnPartialResult(ULong64_t everyNEvents, std::function< void(T &)> callback)Register a callback that RDataFrame will execute ""everyNEvents"" on a partial result.Definition RResultPtr.hxx:318; ROOT::RDF::RResultPtr::fLoopManagerRDFDetail::RLoopManager * fLoopManagerNon-owning pointer to the RLoopManager at the root of this computation graph.Definition RResultPtr.hxx:174; ROOT::RDF::RResultPtr::operator!=friend bool operator!=(const RResultPtr< T1 > &lhs, const RResultPtr< T2 > &rhs)Definition RResultPtr.hxx:407; ROOT::RDF::RResultPtr::beginRIterationHelper< T >::Iterator_t begin()Return an iterator to the beginning of the contained object if this makes sense, throw a compilation ...Definition RResultPtr.hxx:257; ROOT::RDF::RResultPtr::Value_tT Value_tConvenience alias to simplify access to proxied type.Definition RResultPtr.hxx:206; ROOT::RDF::RResultPtr::GetT * Get()Get the pointer to the encapsulated result.Definition RResultPtr.hxx:186; ROOT::RDF::RResultPtr::GetValueconst T & GetValue()Get a const reference to the encapsulated object.Definition RResultPtr.hxx:228; ROOT::RDF::RResultPtr::RResultPtrRResultPtr(const RResultPtr &)=default; ROOT::RDF::RResultPtr::operator*T & operator*()Get a pointer to the encapsulated object.Definition RResultPtr.hxx:240; ROOT::RDF::RResultPtr::operator=RResultPtr & operator=(const RResultPtr &)=default; ROOT::RDF::RResultPtr::OnPartialResultSlotRResultPtr< T > & OnPartialResultSlot(ULong64_t everyNEvents, std::function< void(unsigned int, T &)> callback)Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's ...Definition RResultPtr.hxx:364; ROOT::RDF::RResultPtr::operator=RResultPtr & operator=(RResultPtr &&)=default; ROOT::RDF::RResultPtr::operator==fri",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
https://root.cern/doc/master/rsalib_8cxx.html:333,Integrability,depend,dependency,333,". ROOT: net/auth/src/rsalib.cxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions |; Variables ; rsalib.cxx File Reference. #include <stdio.h>; #include <string.h>; #include <ctype.h>; #include <stdlib.h>; #include <errno.h>; #include ""rsaaux.h""; #include ""rsalib.h"". Include dependency graph for rsalib.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Functions; void num_init ();  ; void rsa_assign (rsa_NUMBER *d, rsa_NUMBER *s);  ; int rsa_cmp (rsa_NUMBER *c1, rsa_NUMBER *c2);  ; int rsa_decode (char *bufin, int lin, rsa_NUMBER n, rsa_NUMBER e);  ; int rsa_encode (char *bufin, int lin, rsa_NUMBER n, rsa_NUMBER e);  ; int rsa_encode_size (rsa_NUMBER n);  ; rsa_NUMBER rsa_genprim (int len, int prob);  ; int rsa_genrsa (rsa_NUMBER p1, rsa_NUMBER p2, rsa_NUMBER *n, rsa_NUMBER *e, rsa_NUMBER *d);  ; int rsa_num_fget (rsa_NUMBER *n, FILE *f);  ; int rsa_num_fput (rsa_NUMBER *n, FILE *f);  ; int rsa_num_sget (rsa_NUMBER *n, char *s);  ; int rsa_num_sput (rsa_NUMBER *n, char *s, int l);  . Variables; static int g_clear_siz;  ; static int g_enc_siz;  ; static rsa_NUMBER gbits [9];  ; static const char * gHEX =""0123456789ABCDEF"";  ; static const char * ghex =""0123456789abcdef"";  ; static int ginit = 0;  ; static rsa_NUMBER gint16 [16];  ; int gLog = 0;  ; int kMAXT = 100;  . Function Documentation. ◆ num_init(). void num_init ; (; ). Definition at line 258 of file rsalib.cxx. ◆ rsa_assign(). void rsa_assign ; (; rsa_NUMBER * ; d, . rsa_NUMBER * ; s . ). Definition at line 487 of file rsalib.cxx. ◆ rsa_cmp(). int rsa_cmp ; (; rsa_NUMBER * ; c1, . rsa_NUMBER * ; c2 . ). Definition at line 476 of file rsalib.cxx. ◆ rsa_decode(). int rsa_decode ; (; char * ; bufin, . int ; lin, . rsa_NUMBER ; n, . rsa_NUMBER ; e . ). Definition at line 177 of file rsalib.cxx. ◆ rsa_encode(). int rsa_encode ; (; char * ; bufin, . int ; lin, . rsa_NUMBER ; n, . rsa_NUMBER ; e . ). Definition at line 13",MatchSource.WIKI,doc/master/rsalib_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rsalib_8cxx.html
https://root.cern/doc/master/rsalib_8cxx_source.html:7485,Safety,abort,abort,7485,"_NUMBER io; 222 */; 223 ; 224/*; 225 * Funktionen; 226 *; 227 * int num_sput( n, s, l); 228 * rsa_NUMBER *n;; 229 * char s[l];; 230 * schreibt *n als Hex-Zahl in s; 231 *; 232 * int num_fput( n, f ); 233 * rsa_NUMBER *n;; 234 * FILE *f;; 235 * schreibt *n als Hex-Zahl in File f; 236 *; 237 * int num_sget( n, s ); 238 * rsa_NUMBER *n;; 239 * char *s;; 240 * liest Hex-Zahl s in *n ein; 241 *; 242 * int num_fget( n, f ); 243 * rsa_NUMBER *n;; 244 * FILE *f;; 245 * liest eine Hex-Zahl von f in *n ein; 246 *; 247 */; 248 ; 249 ; 250static const char *gHEX=""0123456789ABCDEF"";; 251static const char *ghex=""0123456789abcdef"";; 252 ; 253static rsa_NUMBER gbits[9];; 254static rsa_NUMBER gint16[16];; 255 ; 256static int ginit = 0;; 257 ; 258void num_init(); 259{; 260 int i;; 261 ; 262 if (ginit) return;; 263 ; 264 a_assign( &gbits[0], &a_one );; 265 for ( i=1; i<9; i++); 266 a_add( &gbits[i-1], &gbits[i-1], &gbits[i] );; 267 ; 268 a_assign( &gint16[0], &a_one );; 269 for ( i=1; i<16; i++); 270 a_add( &gint16[i-1], &a_one, &gint16[i] );; 271 ; 272 ginit = 1;; 273}; 274 ; 275 ; 276int rsa_num_sput(rsa_NUMBER *n, char *s, int l); 277{; 278#if rsa_MAXINT == ( (1 << rsa_MAXBIT) - 1 ); 279 rsa_INT *p;; 280 int bi,ab,i;; 281 long b;; 282 int first = 1;; 283 ; 284 bi = rsa_MAXBIT * n->n_len;; 285 ab = 4 - (bi + 3) % 4 -1;; 286 p = &n->n_part[n->n_len -1];; 287 ; 288 if ( (bi+3) / 4 >= l ); 289 return(EOF);; 290 ; 291 b = 0;; 292 while (bi) {; 293 b <<= (rsa_MAXBIT);; 294 b |= (unsigned long)*p--;; 295 bi -= rsa_MAXBIT;; 296 ab += rsa_MAXBIT;; 297 while (ab >= 4) {; 298 i = (b >> (ab - 4));; 299 b &= ( 1L << (ab - 4)) -1L;; 300 ab -= 4;; 301 ; 302 if (first && !i); 303 continue;; 304 first = 0;; 305 *s++ = gHEX[ i ];; 306 }; 307 }; 308 if (b); 309 abort();; 310 *s = '\0';; 311 ; 312 return (0);; 313#else; 314 rsa_NUMBER r,q;; 315 int i,b,p,len,low,high;; 316 char *np;; 317 ; 318 if (! ginit); 319 num_init();; 320 ; 321 a_assign( &q, n);; 322 len = l;; 323 np = s + l;; 324 ; 325 for (; q.",MatchSource.WIKI,doc/master/rsalib_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rsalib_8cxx_source.html
https://root.cern/doc/master/rsalib_8cxx_source.html:9542,Safety,abort,abort,9542," return(0);; 371}; 372 ; 373 ; 374int rsa_num_sget(rsa_NUMBER *n, char *s); 375{; 376#if rsa_MAXINT == ( (1 << rsa_MAXBIT) - 1 ); 377 rsa_INT *p;; 378 const char *hp;; 379 int bi,ab,i;; 380 long b;; 381 int first = 1;; 382 ; 383 bi = 4 * strlen(s);; 384 ab = rsa_MAXBIT - (bi + rsa_MAXBIT -1) % rsa_MAXBIT -1;; 385 i = (bi + rsa_MAXBIT-1) / rsa_MAXBIT;; 386 p = &n->n_part[ i -1 ];; 387 n->n_len = i;; 388 ; 389 if ( i > rsa_MAXLEN ); 390 return(EOF);; 391 ; 392 b = 0;; 393 while (bi > 0) {; 394 if ( (hp = strchr( gHEX, *s )) ); 395 i = hp - gHEX;; 396 else if ((hp = strchr( ghex, *s )) ); 397 i = hp - ghex;; 398 else; 399 return(EOF);; 400 s++;; 401 ; 402 b <<= 4;; 403 b |= (unsigned long)i;; 404 bi -= 4;; 405 ab += 4;; 406 while (ab >= rsa_MAXBIT) {; 407 i = (b >> (ab - rsa_MAXBIT));; 408 b &= ( 1L << (ab - rsa_MAXBIT)) -1L;; 409 ab -= rsa_MAXBIT;; 410 if (first && !i) {; 411 p--;; 412 n->n_len--;; 413 }; 414 else {; 415 first = 0;; 416 *p-- = i;; 417 }; 418 }; 419 }; 420 if (b); 421 abort();; 422 *s = '\0';; 423 ; 424 return (0);; 425#else; 426 char *p;; 427 int i,c;; 428 ; 429 if (! ginit); 430 num_init();; 431 ; 432 n->n_len = 0;; 433 while ( (c = *s++ & 0xFF)) {; 434 if ( p= strchr( gHEX, c) ); 435 i = p - gHEX;; 436 else if ( p= strchr( ghex, c) ); 437 i = p - ghex;; 438 else; 439 return(EOF);; 440 ; 441 a_mult( n, &gbits[4], n );; 442 if (i); 443 a_add( n, &gint16[i-1], n );; 444 }; 445 ; 446 return(0);; 447#endif; 448}; 449 ; 450int rsa_num_fget(rsa_NUMBER *n, FILE *f); 451{; 452 int j,c;; 453 char *np;; 454 char n_print[ rsa_STRLEN + 1 ];; 455 ; 456 np = n_print;; 457 j = sizeof(n_print);; 458 while ( (c=getc(f)) != EOF && ( isxdigit(c) || isspace(c)) ) {; 459 if (isspace(c)); 460 continue;; 461 if (! --j); 462 return(EOF);; 463 *np++ = (char)c;; 464 }; 465 *np = '\0';; 466 ; 467 if (c != EOF); 468 ungetc(c,f);; 469 ; 470 if ( rsa_num_sget( n, n_print) == EOF ); 471 return( EOF );; 472 ; 473 return(0);; 474}; 475 ; 476int rsa_cmp(rsa_NUMBER *c1, rsa_NUMBER *c2",MatchSource.WIKI,doc/master/rsalib_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rsalib_8cxx_source.html
https://root.cern/doc/master/rsalib_8cxx_source.html:1735,Usability,clear,clear-text,1735,"License along with this library; if not, write to the Free; 20Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,; 21MA 02110-1301 USA; 22******************************************************************************/; 23 ; 24/*******************************************************************************; 25* *; 26* Simple RSA public key code. *; 27* Adaptation in library for ROOT by G. Ganis, July 2003 *; 28* (gerardo.ganis@cern.ch) *; 29* *; 30*******************************************************************************/; 31 ; 32#include <stdio.h>; 33#include <string.h>; 34#include <ctype.h>; 35#include <stdlib.h>; 36#include <errno.h>; 37 ; 38#include ""rsaaux.h""; 39#include ""rsalib.h""; 40 ; 41static int g_clear_siz; /* clear-text blocksize */; 42static int g_enc_siz; /* encoded blocksize */; 43 /* g_clear_siz < g_enc_siz */; 44 ; 45int gLog = 0;; 46int kMAXT = 100;; 47 ; 48rsa_NUMBER rsa_genprim(int len, int prob); 49{; 50 rsa_NUMBER a_three,a_four;; 51 rsa_NUMBER prim;; 52 int i;; 53 ; 54 a_add( &a_one, &a_two, &a_three );; 55 a_add( &a_two, &a_two, &a_four );; 56 ; 57 /* This is done elsewhere to allow different initialization of; 58 rand seed (GGa - Sep 15, 2003) */; 59 /* init_rnd(); */; 60 ; 61 do {; 62 gen_number( len, &prim );; 63 } while ( !prim.n_len );; 64 ; 65 a_mult( &prim, &a_two, &prim );; 66 a_mult( &prim, &a_three, &prim );; 67 a_add( &prim, &a_one, &prim );; 68 ; 69 for (i=1 ;; i++) {; 70 ; 71 if (p_prim( &prim, prob )); 72 break;; 73 if (i % 2); 74 a_add( &prim, &a_four, &prim );; 75 else; 76 a_add( &prim, &a_two, &prim );; 77 }; 78 ; 79 return prim;; 80}; 81 ; 82int rsa_genrsa(rsa_NUMBER p1, rsa_NUMBER p2, rsa_NUMBER *n, rsa_NUMBER *e, rsa_NUMBER *d); 83{; 84 rsa_NUMBER phi, *max_p;; 85 int len;; 86 int ii, jj;; 87 ; 88 if ( !a_cmp( &p1, &p2) ) return 1;; 89 ; 90 if (a_cmp( &p1, &p2) > 0); 91 max_p = &p1;; 92 else; 93 max_p = &p2;; 94 ; 95 ; 96 a_mult( &p1, &p2, n );; 97 a_sub( &p1, &a_one, &phi );; 98 a_sub( &p2, &a_one, e );; 99",MatchSource.WIKI,doc/master/rsalib_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rsalib_8cxx_source.html
https://root.cern/doc/master/RSampleInfo_8hxx_source.html:1910,Availability,avail,available,1910,"clude <Rtypes.h>; 17 ; 18#include <functional>; 19#include <stdexcept>; 20#include <string>; 21 ; 22#include <tuple>; 23 ; 24namespace ROOT {; 25namespace RDF {; 26 ; 27/// This type represents a sample identifier, to be used in conjunction with RDataFrame features such as; 28/// \ref ROOT::RDF::RInterface< Proxied, DS_t >::DefinePerSample ""DefinePerSample()"" and per-sample callbacks.; 29///; 30/// When the input data comes from a TTree, the string representation of RSampleInfo (which is returned by AsString(); 31/// and that can be queried e.g. with Contains()) is of the form ""<filename>/<treename>"".; 32///; 33/// In multi-thread runs, different tasks might process different entry ranges of the same sample,; 34/// so RSampleInfo also provides methods to inspect which part of a sample is being taken into consideration.; 35class RSampleInfo {; 36 std::string fID;; 37 std::pair<ULong64_t, ULong64_t> fEntryRange;; 38 ; 39 const ROOT::RDF::Experimental::RSample *fSample = nullptr; // non-owning; 40 ; 41 void ThrowIfNoSample() const; 42 {; 43 if (fSample == nullptr) {; 44 const auto msg = ""RSampleInfo: sample data was requested but no samples are available."";; 45 throw std::logic_error(msg);; 46 }; 47 }; 48 ; 49public:; 50 RSampleInfo(std::string_view id, std::pair<ULong64_t, ULong64_t> entryRange,; 51 const ROOT::RDF::Experimental::RSample *sample = nullptr); 52 : fID(id), fEntryRange(entryRange), fSample(sample); 53 {; 54 }; 55 RSampleInfo() = default;; 56 RSampleInfo(const RSampleInfo &) = default;; 57 RSampleInfo &operator=(const RSampleInfo &) = default;; 58 RSampleInfo(RSampleInfo &&) = default;; 59 RSampleInfo &operator=(RSampleInfo &&) = default;; 60 ~RSampleInfo() = default;; 61 ; 62 /// @brief Get the name of the sample as a string.; 63 const std::string &GetSampleName() const; 64 {; 65 ThrowIfNoSample();; 66 return fSample->GetSampleName();; 67 }; 68 ; 69 /// @brief Get the sample id as an int.; 70 unsigned int GetSampleId() const; 71 {; 72 ThrowIfNoSample();;",MatchSource.WIKI,doc/master/RSampleInfo_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSampleInfo_8hxx_source.html
https://root.cern/doc/master/RSampleInfo_8hxx_source.html:5742,Availability,error,error,5742,"or==(const RSampleInfo &other) const { return fID == other.fID; }; 128 bool operator!=(const RSampleInfo &other) const { return !(*this == other); }; 129};; 130 ; 131/// The type of a data-block callback, registered with an RDataFrame computation graph via e.g. \ref; 132/// ROOT::RDF::RInterface< Proxied, DS_t >::DefinePerSample ""DefinePerSample()"" or by certain actions (e.g. \ref; 133/// ROOT::RDF::RInterface<Proxied,DataSource>::Snapshot ""Snapshot()"").; 134using SampleCallback_t = std::function<void(unsigned int, const ROOT::RDF::RSampleInfo &)>;; 135 ; 136} // namespace RDF; 137} // namespace ROOT; 138 ; 139#endif; RSample.hxx; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; Rtypes.h; idOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize idDefinition TGWin32VirtualXProxy.cxx:94; ROOT::RDF::Experimental::RMetaData::GetSstd::string GetS(const std::string &key) constReturn the metadata value of type string given the key, or an error if the metadata value is of a non...Definition RMetaData.cxx:96; ROOT::RDF::Experimental::RMetaData::GetDdouble GetD(const std::string &key) constReturn the metadata value of type double given the key, or an error if the metadata value is of a non...Definition RMetaData.cxx:84; ROOT::RDF::Experimental::RMetaData::GetIint GetI(const std::string &key) constReturn the metadata value of type int given the key, or an error if the metadata value is of a non-in...Definition RMetaData.cxx:73; ROOT::RDF::Experimental::RSampleClass representing a sample which is a grouping of trees and their fileglobs, and,...Definition RSample.hxx:39; ROOT::RDF::Experimental::RSample::GetSampleNameconst std::string & GetSampleName() constGet the name of the sample (RSample object).Definition RSample.cxx:75; ROOT::RDF::Experimental::RSample::GetMetaDataconst RMetaData & GetMetaData() constGet an instance of the RMetaData class.Definition RSample.cxx",MatchSource.WIKI,doc/master/RSampleInfo_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSampleInfo_8hxx_source.html
https://root.cern/doc/master/RSampleInfo_8hxx_source.html:5956,Availability,error,error,5956,"with an RDataFrame computation graph via e.g. \ref; 132/// ROOT::RDF::RInterface< Proxied, DS_t >::DefinePerSample ""DefinePerSample()"" or by certain actions (e.g. \ref; 133/// ROOT::RDF::RInterface<Proxied,DataSource>::Snapshot ""Snapshot()"").; 134using SampleCallback_t = std::function<void(unsigned int, const ROOT::RDF::RSampleInfo &)>;; 135 ; 136} // namespace RDF; 137} // namespace ROOT; 138 ; 139#endif; RSample.hxx; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; Rtypes.h; idOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize idDefinition TGWin32VirtualXProxy.cxx:94; ROOT::RDF::Experimental::RMetaData::GetSstd::string GetS(const std::string &key) constReturn the metadata value of type string given the key, or an error if the metadata value is of a non...Definition RMetaData.cxx:96; ROOT::RDF::Experimental::RMetaData::GetDdouble GetD(const std::string &key) constReturn the metadata value of type double given the key, or an error if the metadata value is of a non...Definition RMetaData.cxx:84; ROOT::RDF::Experimental::RMetaData::GetIint GetI(const std::string &key) constReturn the metadata value of type int given the key, or an error if the metadata value is of a non-in...Definition RMetaData.cxx:73; ROOT::RDF::Experimental::RSampleClass representing a sample which is a grouping of trees and their fileglobs, and,...Definition RSample.hxx:39; ROOT::RDF::Experimental::RSample::GetSampleNameconst std::string & GetSampleName() constGet the name of the sample (RSample object).Definition RSample.cxx:75; ROOT::RDF::Experimental::RSample::GetMetaDataconst RMetaData & GetMetaData() constGet an instance of the RMetaData class.Definition RSample.cxx:99; ROOT::RDF::RSampleInfoThis type represents a sample identifier, to be used in conjunction with RDataFrame features such as ...Definition RSampleInfo.hxx:35; ROOT::RDF::RSampleInfo::GetSampleIdunsigned int GetSamp",MatchSource.WIKI,doc/master/RSampleInfo_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSampleInfo_8hxx_source.html
https://root.cern/doc/master/RSampleInfo_8hxx_source.html:6164,Availability,error,error,6164,"rce>::Snapshot ""Snapshot()"").; 134using SampleCallback_t = std::function<void(unsigned int, const ROOT::RDF::RSampleInfo &)>;; 135 ; 136} // namespace RDF; 137} // namespace ROOT; 138 ; 139#endif; RSample.hxx; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; Rtypes.h; idOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize idDefinition TGWin32VirtualXProxy.cxx:94; ROOT::RDF::Experimental::RMetaData::GetSstd::string GetS(const std::string &key) constReturn the metadata value of type string given the key, or an error if the metadata value is of a non...Definition RMetaData.cxx:96; ROOT::RDF::Experimental::RMetaData::GetDdouble GetD(const std::string &key) constReturn the metadata value of type double given the key, or an error if the metadata value is of a non...Definition RMetaData.cxx:84; ROOT::RDF::Experimental::RMetaData::GetIint GetI(const std::string &key) constReturn the metadata value of type int given the key, or an error if the metadata value is of a non-in...Definition RMetaData.cxx:73; ROOT::RDF::Experimental::RSampleClass representing a sample which is a grouping of trees and their fileglobs, and,...Definition RSample.hxx:39; ROOT::RDF::Experimental::RSample::GetSampleNameconst std::string & GetSampleName() constGet the name of the sample (RSample object).Definition RSample.cxx:75; ROOT::RDF::Experimental::RSample::GetMetaDataconst RMetaData & GetMetaData() constGet an instance of the RMetaData class.Definition RSample.cxx:99; ROOT::RDF::RSampleInfoThis type represents a sample identifier, to be used in conjunction with RDataFrame features such as ...Definition RSampleInfo.hxx:35; ROOT::RDF::RSampleInfo::GetSampleIdunsigned int GetSampleId() constGet the sample id as an int.Definition RSampleInfo.hxx:70; ROOT::RDF::RSampleInfo::RSampleInfoRSampleInfo(RSampleInfo &&)=default; ROOT::RDF::RSampleInfo::ThrowIfNoSamplevoid ThrowIfNoSample() constDe",MatchSource.WIKI,doc/master/RSampleInfo_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSampleInfo_8hxx_source.html
https://root.cern/doc/master/RSampleInfo_8hxx_source.html:1376,Performance,multi-thread,multi-thread,1376,"* For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11#ifndef ROOT_RDF_RSAMPLEINFO; 12#define ROOT_RDF_RSAMPLEINFO; 13 ; 14#include <ROOT/RDF/RSample.hxx>; 15#include <string_view>; 16#include <Rtypes.h>; 17 ; 18#include <functional>; 19#include <stdexcept>; 20#include <string>; 21 ; 22#include <tuple>; 23 ; 24namespace ROOT {; 25namespace RDF {; 26 ; 27/// This type represents a sample identifier, to be used in conjunction with RDataFrame features such as; 28/// \ref ROOT::RDF::RInterface< Proxied, DS_t >::DefinePerSample ""DefinePerSample()"" and per-sample callbacks.; 29///; 30/// When the input data comes from a TTree, the string representation of RSampleInfo (which is returned by AsString(); 31/// and that can be queried e.g. with Contains()) is of the form ""<filename>/<treename>"".; 32///; 33/// In multi-thread runs, different tasks might process different entry ranges of the same sample,; 34/// so RSampleInfo also provides methods to inspect which part of a sample is being taken into consideration.; 35class RSampleInfo {; 36 std::string fID;; 37 std::pair<ULong64_t, ULong64_t> fEntryRange;; 38 ; 39 const ROOT::RDF::Experimental::RSample *fSample = nullptr; // non-owning; 40 ; 41 void ThrowIfNoSample() const; 42 {; 43 if (fSample == nullptr) {; 44 const auto msg = ""RSampleInfo: sample data was requested but no samples are available."";; 45 throw std::logic_error(msg);; 46 }; 47 }; 48 ; 49public:; 50 RSampleInfo(std::string_view id, std::pair<ULong64_t, ULong64_t> entryRange,; 51 const ROOT::RDF::Experimental::RSample *sample = nullptr); 52 : fID(id), fEntryRange(entryRange), fSample(sample); 53 {; 54 }; 55 RSampleInfo() = default;; 56 RSampleInfo(const RSampleInfo &) = default;; 57 RSampleInfo &operator=(const RSampleInfo &) = default;; 58 RSampleInfo(RSampleInfo &&) = default;; 59 RSampleInfo &operator=(RSampleInfo &&) = default;; 60 ~RSampleInfo() = default;; 61 ; 62 //",MatchSource.WIKI,doc/master/RSampleInfo_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSampleInfo_8hxx_source.html
https://root.cern/doc/master/RSampleInfo_8hxx_source.html:4314,Performance,multi-thread,multi-threading,4314,"le();; 94 return fSample->GetMetaData().GetS(key);; 95 }; 96 ; 97 /// @brief Check whether the sample name contains the given substring.; 98 bool Contains(std::string_view substr) const; 99 {; 100 // C++14 needs the conversion from std::string_view to std::string; 101 return fID.find(std::string(substr)) != std::string::npos;; 102 }; 103 ; 104 /// @brief Check whether the sample name is empty.; 105 ///; 106 /// This is the case e.g. when using a RDataFrame with no input data, constructed as `RDataFrame(nEntries)`.; 107 bool Empty() const {; 108 return fID.empty();; 109 }; 110 ; 111 /// @brief Return a string representation of the sample name.; 112 ///; 113 /// The representation is of the form ""<filename>/<treename>"" if the input data comes from a TTree or a TChain.; 114 const std::string &AsString() const; 115 {; 116 return fID;; 117 }; 118 ; 119 /// @brief Return the entry range in the sample that is being taken into consideration.; 120 ///; 121 /// Multiple multi-threading tasks might process different entry ranges of the same sample.; 122 std::pair<ULong64_t, ULong64_t> EntryRange() const { return fEntryRange; }; 123 ; 124 /// @brief Return the number of entries of this sample that is being taken into consideration.; 125 ULong64_t NEntries() const { return fEntryRange.second - fEntryRange.first; }; 126 ; 127 bool operator==(const RSampleInfo &other) const { return fID == other.fID; }; 128 bool operator!=(const RSampleInfo &other) const { return !(*this == other); }; 129};; 130 ; 131/// The type of a data-block callback, registered with an RDataFrame computation graph via e.g. \ref; 132/// ROOT::RDF::RInterface< Proxied, DS_t >::DefinePerSample ""DefinePerSample()"" or by certain actions (e.g. \ref; 133/// ROOT::RDF::RInterface<Proxied,DataSource>::Snapshot ""Snapshot()"").; 134using SampleCallback_t = std::function<void(unsigned int, const ROOT::RDF::RSampleInfo &)>;; 135 ; 136} // namespace RDF; 137} // namespace ROOT; 138 ; 139#endif; RSample.hxx; ULong64_tunsigne",MatchSource.WIKI,doc/master/RSampleInfo_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSampleInfo_8hxx_source.html
https://root.cern/doc/master/RSha256_8hxx.html:334,Integrability,depend,dependency,334,". ROOT: core/foundation/res/ROOT/RSha256.hxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Macros |; Typedefs |; Functions |; Variables ; RSha256.hxx File Reference. #include ""Rtypes.h""; #include <iostream>; #include <stdlib.h>; #include <stdint.h>. Include dependency graph for RSha256.hxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  ROOT::Internal::SHA256::sha256_t;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  ; namespace  ROOT::Internal::SHA256;  . Macros; #define _SHA256_UNROLL;  ; #define _SHA256_UNROLL2;  ; #define a(i)   T[(0 - (i)) & 7];  ; #define b(i)   T[(1 - (i)) & 7];  ; #define blk0(i)   (W[i] = data[i]);  ; #define blk2(i)   (W[i & 15] += s1(W[(i - 2) & 15]) + W[(i - 7) & 15] + s0(W[(i - 15) & 15]));  ; #define c(i)   T[(2 - (i)) & 7];  ; #define Ch(x, y, z)   (z ^ (x & (y ^ z)));  ; #define d(i)   T[(3 - (i)) & 7];  ; #define e(i)   T[(4 - (i)) & 7];  ; #define f(i)   T[(5 - (i)) & 7];  ; #define g(i)   T[(6 - (i)) & 7];  ; #define h(i)   T[(7 - (i)) & 7];  ; #define Maj(x, y, z)   ((x & y) | (z & (x | y)));  ; #define R(a, b, c, d, e, f, g, h, i);  ; #define ROTL16(v, n)   (U16V((uint16_t)(v) << (n)) | ((uint16_t)(v) >> (16 - (n))));  ; #define ROTL32(v, n)   (U32V((uint32_t)(v) << (n)) | ((uint32_t)(v) >> (32 - (n))));  ; #define ROTL64(v, n)   (U64V((uint64_t)(v) << (n)) | ((uint64_t)(v) >> (64 - (n))));  ; #define ROTL8(v, n)   (U8V((uint8_t)(v) << (n)) | ((uint8_t)(v) >> (8 - (n))));  ; #define ROTR16(v, n)   ROTL16(v, 16 - (n));  ; #define ROTR32(v, n)   ROTL32(v, 32 - (n));  ; #define",MatchSource.WIKI,doc/master/RSha256_8hxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSha256_8hxx.html
https://root.cern/doc/master/RSha256_8hxx_source.html:8192,Integrability,interface,interface,8192,"; 199#else; 200 for (j = 0; j < 8; j++); 201 state[j] += T[j];; 202#endif; 203 ; 204 /* Wipe variables */; 205 /* memset(W, 0, sizeof(W)); */; 206 /* memset(T, 0, sizeof(T)); */; 207}; 208 ; 209#undef S0; 210#undef S1; 211#undef s0; 212#undef s1; 213 ; 214static void sha256_write_byte_block(sha256_t *p); 215{; 216 uint32_t data32[16];; 217 unsigned i;; 218 for (i = 0; i < 16; i++); 219 data32[i] = ((uint32_t)(p->buffer[i * 4]) << 24) + ((uint32_t)(p->buffer[i * 4 + 1]) << 16) +; 220 ((uint32_t)(p->buffer[i * 4 + 2]) << 8) + ((uint32_t)(p->buffer[i * 4 + 3]));; 221 sha256_transform(p->state, data32);; 222}; 223 ; 224void sha256_update(sha256_t *p, const unsigned char *data, size_t size); 225{; 226 uint32_t curBufferPos = (uint32_t)p->count & 0x3F;; 227 while (size > 0) {; 228 p->buffer[curBufferPos++] = *data++;; 229 p->count++;; 230 size--;; 231 if (curBufferPos == 64) {; 232 curBufferPos = 0;; 233 sha256_write_byte_block(p);; 234 }; 235 }; 236}; 237 ; 238void sha256_final(sha256_t *p, unsigned char *digest); 239{; 240 uint64_t lenInBits = (p->count << 3);; 241 uint32_t curBufferPos = (uint32_t)p->count & 0x3F;; 242 unsigned i;; 243 p->buffer[curBufferPos++] = 0x80;; 244 while (curBufferPos != (64 - 8)) {; 245 curBufferPos &= 0x3F;; 246 if (curBufferPos == 0); 247 sha256_write_byte_block(p);; 248 p->buffer[curBufferPos++] = 0;; 249 }; 250 for (i = 0; i < 8; i++) {; 251 p->buffer[curBufferPos++] = (unsigned char)(lenInBits >> 56);; 252 lenInBits <<= 8;; 253 }; 254 sha256_write_byte_block(p);; 255 ; 256 for (i = 0; i < 8; i++) {; 257 *digest++ = (unsigned char)(p->state[i] >> 24);; 258 *digest++ = (unsigned char)(p->state[i] >> 16);; 259 *digest++ = (unsigned char)(p->state[i] >> 8);; 260 *digest++ = (unsigned char)(p->state[i]);; 261 }; 262 sha256_init(p);; 263}; 264 ; 265} // End NS SHA256; 266 ; 267void Sha256(const unsigned char *data, int len, ULong64_t *fDigest); 268{; 269 // Here the final cast is to match the interface of the C code and; 270 // the data member.",MatchSource.WIKI,doc/master/RSha256_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSha256_8hxx_source.html
https://root.cern/doc/master/RSha256_8hxx_source.html:6336,Modifiability,variab,variables,6336,"tic void sha256_transform(uint32_t *state, const uint32_t *data); 159{; 160 uint32_t W[16] = {0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U};; 161 unsigned j;; 162#ifdef _SHA256_UNROLL2; 163 uint32_t a, b, c, d, e, f, g, h;; 164 a = state[0];; 165 b = state[1];; 166 c = state[2];; 167 d = state[3];; 168 e = state[4];; 169 f = state[5];; 170 g = state[6];; 171 h = state[7];; 172#else; 173 uint32_t T[8];; 174 for (j = 0; j < 8; j++); 175 T[j] = state[j];; 176#endif; 177 ; 178 for (j = 0; j < 64; j += 16) {; 179#if defined(_SHA256_UNROLL) || defined(_SHA256_UNROLL2); 180 RX_8(0);; 181 RX_8(8);; 182#else; 183 unsigned i;; 184 for (i = 0; i < 16; i++) {; 185 R(i);; 186 }; 187#endif; 188 }; 189 ; 190#ifdef _SHA256_UNROLL2; 191 state[0] += a;; 192 state[1] += b;; 193 state[2] += c;; 194 state[3] += d;; 195 state[4] += e;; 196 state[5] += f;; 197 state[6] += g;; 198 state[7] += h;; 199#else; 200 for (j = 0; j < 8; j++); 201 state[j] += T[j];; 202#endif; 203 ; 204 /* Wipe variables */; 205 /* memset(W, 0, sizeof(W)); */; 206 /* memset(T, 0, sizeof(T)); */; 207}; 208 ; 209#undef S0; 210#undef S1; 211#undef s0; 212#undef s1; 213 ; 214static void sha256_write_byte_block(sha256_t *p); 215{; 216 uint32_t data32[16];; 217 unsigned i;; 218 for (i = 0; i < 16; i++); 219 data32[i] = ((uint32_t)(p->buffer[i * 4]) << 24) + ((uint32_t)(p->buffer[i * 4 + 1]) << 16) +; 220 ((uint32_t)(p->buffer[i * 4 + 2]) << 8) + ((uint32_t)(p->buffer[i * 4 + 3]));; 221 sha256_transform(p->state, data32);; 222}; 223 ; 224void sha256_update(sha256_t *p, const unsigned char *data, size_t size); 225{; 226 uint32_t curBufferPos = (uint32_t)p->count & 0x3F;; 227 while (size > 0) {; 228 p->buffer[curBufferPos++] = *data++;; 229 p->count++;; 230 size--;; 231 if (curBufferPos == 64) {; 232 curBufferPos = 0;; 233 sha256_write_byte_block(p);; 234 }; 235 }; 236}; 237 ; 238void sha256_final(sha256_t *p, unsigned char *digest); 239{; 240 uint64_t lenInBits = (p->count << 3);; 241 uint32_t curBufferPo",MatchSource.WIKI,doc/master/RSha256_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSha256_8hxx_source.html
https://root.cern/doc/master/RSha256_8hxx_source.html:2357,Performance,optimiz,optimization,2357,"; 44#define ROTL64(v, n) (U64V((uint64_t)(v) << (n)) | ((uint64_t)(v) >> (64 - (n)))); 45 ; 46#define ROTR32(v, n) ROTL32(v, 32 - (n)); 47#define ROTR64(v, n) ROTL64(v, 64 - (n)); 48 ; 49#endif; 50 ; 51#define ROTL8(v, n) (U8V((uint8_t)(v) << (n)) | ((uint8_t)(v) >> (8 - (n)))); 52 ; 53#define ROTL16(v, n) (U16V((uint16_t)(v) << (n)) | ((uint16_t)(v) >> (16 - (n)))); 54 ; 55#define ROTR8(v, n) ROTL8(v, 8 - (n)); 56#define ROTR16(v, n) ROTL16(v, 16 - (n)); 57 ; 58#define SHA256_DIGEST_SIZE 32; 59 ; 60typedef struct sha256_t {; 61 uint32_t stat",MatchSource.WIKI,doc/master/RSha256_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSha256_8hxx_source.html
https://root.cern/doc/master/RSha256_8hxx_source.html:8291,Security,hash,hash,8291,"[curBufferPos++] = 0x80;; 244 while (curBufferPos != (64 - 8)) {; 245 curBufferPos &= 0x3F;; 246 if (curBufferPos == 0); 247 sha256_write_byte_block(p);; 248 p->buffer[curBufferPos++] = 0;; 249 }; 250 for (i = 0; i < 8; i++) {; 251 p->buffer[curBufferPos++] = (unsigned char)(lenInBits >> 56);; 252 lenInBits <<= 8;; 253 }; 254 sha256_write_byte_block(p);; 255 ; 256 for (i = 0; i < 8; i++) {; 257 *digest++ = (unsigned char)(p->state[i] >> 24);; 258 *digest++ = (unsigned char)(p->state[i] >> 16);; 259 *digest++ = (unsigned char)(p->state[i] >> 8);; 260 *digest++ = (unsigned char)(p->state[i]);; 261 }; 262 sha256_init(p);; 263}; 264 ; 265} // End NS SHA256; 266 ; 267void Sha256(const unsigned char *data, int len, ULong64_t *fDigest); 268{; 269 // Here the final cast is to match the interface of the C code and; 270 // the data member. The length is the same!; 271 SHA256::sha256_t hash;; 272 SHA256::sha256_init(&hash);; 273 SHA256::sha256_update(&hash, data, len);; 274 SHA256::sha256_final(&hash, reinterpret_cast<unsigned char *>(fDigest));; 275}; 276 ; 277} // End NS Internal; 278} // End NS ROOT; 279 ; 280#endif; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; RX_8#define RX_8(i)Definition RSha256.hxx:115; g#define g(i)Definition RSha256.hxx:105; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; Rtypes.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; lenOption_t Option_t TPoint TPoint const char GetTextMag",MatchSource.WIKI,doc/master/RSha256_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSha256_8hxx_source.html
https://root.cern/doc/master/RSha256_8hxx_source.html:8323,Security,hash,hash,8323,"[curBufferPos++] = 0x80;; 244 while (curBufferPos != (64 - 8)) {; 245 curBufferPos &= 0x3F;; 246 if (curBufferPos == 0); 247 sha256_write_byte_block(p);; 248 p->buffer[curBufferPos++] = 0;; 249 }; 250 for (i = 0; i < 8; i++) {; 251 p->buffer[curBufferPos++] = (unsigned char)(lenInBits >> 56);; 252 lenInBits <<= 8;; 253 }; 254 sha256_write_byte_block(p);; 255 ; 256 for (i = 0; i < 8; i++) {; 257 *digest++ = (unsigned char)(p->state[i] >> 24);; 258 *digest++ = (unsigned char)(p->state[i] >> 16);; 259 *digest++ = (unsigned char)(p->state[i] >> 8);; 260 *digest++ = (unsigned char)(p->state[i]);; 261 }; 262 sha256_init(p);; 263}; 264 ; 265} // End NS SHA256; 266 ; 267void Sha256(const unsigned char *data, int len, ULong64_t *fDigest); 268{; 269 // Here the final cast is to match the interface of the C code and; 270 // the data member. The length is the same!; 271 SHA256::sha256_t hash;; 272 SHA256::sha256_init(&hash);; 273 SHA256::sha256_update(&hash, data, len);; 274 SHA256::sha256_final(&hash, reinterpret_cast<unsigned char *>(fDigest));; 275}; 276 ; 277} // End NS Internal; 278} // End NS ROOT; 279 ; 280#endif; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; RX_8#define RX_8(i)Definition RSha256.hxx:115; g#define g(i)Definition RSha256.hxx:105; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; Rtypes.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; lenOption_t Option_t TPoint TPoint const char GetTextMag",MatchSource.WIKI,doc/master/RSha256_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSha256_8hxx_source.html
https://root.cern/doc/master/RSha256_8hxx_source.html:8358,Security,hash,hash,8358,"[curBufferPos++] = 0x80;; 244 while (curBufferPos != (64 - 8)) {; 245 curBufferPos &= 0x3F;; 246 if (curBufferPos == 0); 247 sha256_write_byte_block(p);; 248 p->buffer[curBufferPos++] = 0;; 249 }; 250 for (i = 0; i < 8; i++) {; 251 p->buffer[curBufferPos++] = (unsigned char)(lenInBits >> 56);; 252 lenInBits <<= 8;; 253 }; 254 sha256_write_byte_block(p);; 255 ; 256 for (i = 0; i < 8; i++) {; 257 *digest++ = (unsigned char)(p->state[i] >> 24);; 258 *digest++ = (unsigned char)(p->state[i] >> 16);; 259 *digest++ = (unsigned char)(p->state[i] >> 8);; 260 *digest++ = (unsigned char)(p->state[i]);; 261 }; 262 sha256_init(p);; 263}; 264 ; 265} // End NS SHA256; 266 ; 267void Sha256(const unsigned char *data, int len, ULong64_t *fDigest); 268{; 269 // Here the final cast is to match the interface of the C code and; 270 // the data member. The length is the same!; 271 SHA256::sha256_t hash;; 272 SHA256::sha256_init(&hash);; 273 SHA256::sha256_update(&hash, data, len);; 274 SHA256::sha256_final(&hash, reinterpret_cast<unsigned char *>(fDigest));; 275}; 276 ; 277} // End NS Internal; 278} // End NS ROOT; 279 ; 280#endif; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; RX_8#define RX_8(i)Definition RSha256.hxx:115; g#define g(i)Definition RSha256.hxx:105; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; Rtypes.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; lenOption_t Option_t TPoint TPoint const char GetTextMag",MatchSource.WIKI,doc/master/RSha256_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSha256_8hxx_source.html
https://root.cern/doc/master/RSha256_8hxx_source.html:8403,Security,hash,hash,8403,"[curBufferPos++] = 0x80;; 244 while (curBufferPos != (64 - 8)) {; 245 curBufferPos &= 0x3F;; 246 if (curBufferPos == 0); 247 sha256_write_byte_block(p);; 248 p->buffer[curBufferPos++] = 0;; 249 }; 250 for (i = 0; i < 8; i++) {; 251 p->buffer[curBufferPos++] = (unsigned char)(lenInBits >> 56);; 252 lenInBits <<= 8;; 253 }; 254 sha256_write_byte_block(p);; 255 ; 256 for (i = 0; i < 8; i++) {; 257 *digest++ = (unsigned char)(p->state[i] >> 24);; 258 *digest++ = (unsigned char)(p->state[i] >> 16);; 259 *digest++ = (unsigned char)(p->state[i] >> 8);; 260 *digest++ = (unsigned char)(p->state[i]);; 261 }; 262 sha256_init(p);; 263}; 264 ; 265} // End NS SHA256; 266 ; 267void Sha256(const unsigned char *data, int len, ULong64_t *fDigest); 268{; 269 // Here the final cast is to match the interface of the C code and; 270 // the data member. The length is the same!; 271 SHA256::sha256_t hash;; 272 SHA256::sha256_init(&hash);; 273 SHA256::sha256_update(&hash, data, len);; 274 SHA256::sha256_final(&hash, reinterpret_cast<unsigned char *>(fDigest));; 275}; 276 ; 277} // End NS Internal; 278} // End NS ROOT; 279 ; 280#endif; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; RX_8#define RX_8(i)Definition RSha256.hxx:115; g#define g(i)Definition RSha256.hxx:105; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; Rtypes.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; lenOption_t Option_t TPoint TPoint const char GetTextMag",MatchSource.WIKI,doc/master/RSha256_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSha256_8hxx_source.html
https://root.cern/doc/master/RSha256_8hxx_source.html:1413,Testability,test,tests,1413,"ha256.hxx. Go to the documentation of this file. 1// Author: Danilo Piparo May 2018; 2// Inspired by public domain code of Igor Pavlov: https://github.com/jb55/sha256.c; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2018, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_RSHA; 13#define ROOT_RSHA; 14 ; 15#include ""Rtypes.h""; 16 ; 17#include <iostream>; 18#include <stdlib.h>; 19#include <stdint.h>; 20 ; 21 ; 22namespace ROOT {; 23namespace Internal {; 24namespace SHA256 {; 25 ; 26#ifdef _MSC_VER; 27 ; 28#define ROTL32(v, n) _rotl((v), (n)); 29#define ROTL64(v, n) _rotl64((v), (n)); 30 ; 31#define ROTR32(v, n) _rotr((v), (n)); 32#define ROTR64(v, n) _rotr64((v), (n)); 33 ; 34#else; 35 ; 36#define U8V(v) ((uint8_t)(v)&0xFFU); 37#define U16V(v) ((uint16_t)(v)&0xFFFFU); 38#define U32V(v) ((uint32_t)(v)&0xFFFFFFFFU); 39#define U64V(v) ((uint64_t)(v)&0xFFFFFFFFFFFFFFFFU); 40 ; 41#define ROTL32(v, n) (U32V((uint32_t)(v) << (n)) | ((uint32_t)(v) >> (32 - (n)))); 42 ; 43// tests fail if we don't have this cast...; 44#define ROTL64(v, n) (U64V((uint64_t)(v) << (n)) | ((uint64_t)(v) >> (64 - (n)))); 45 ; 46#define ROTR32(v, n) ROTL32(v, 32 - (n)); 47#define ROTR64(v, n) ROTL64(v, 64 - (n)); 48 ; 49#endif; 50 ; 51#define ROTL8(v, n) (U8V((uint8_t)(v) << (n)) | ((uint8_t)(v) >> (8 - (n)))); 52 ; 53#define ROTL16(v, n) (U16V((uint16_t)(v) << (n)) | ((uint16_t)(v) >> (16 - (n)))); 54 ; 55#define ROTR8(v, n) ROTL8(v, 8 - (n)); 56#define ROTR16(v, n) ROTL16(v, 16 - (n)); 57 ; 58#define SHA256_DIGEST_SIZE 32; 59 ; 60typedef struct sha256_t {; 61 uint32_t state[8];; 62 uint64_t count;; 63 unsigned char buffer[64];; 64} sha256_t;; 65 ; 66void sha256_init(sha256_t *p);; 67void sha256_update(sha256_t ",MatchSource.WIKI,doc/master/RSha256_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSha256_8hxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:1520,Availability,avail,available,1520," *************************************************************************/; 10 ; 11#include <ROOT/RSqliteDS.hxx>; 12#include <ROOT/RRawFile.hxx>; 13 ; 14#include ""TError.h""; 15#include ""TRandom.h""; 16#include ""TSystem.h""; 17 ; 18#include <algorithm>; 19#include <cctype>; 20#include <cerrno>; 21#include <cstring> // for memcpy; 22#include <ctime>; 23#include <memory> // for placement new; 24#include <stdexcept>; 25#include <utility>; 26 ; 27#include <sqlite3.h>; 28 ; 29namespace {; 30 ; 31// In order to provide direct access to remote sqlite files through HTTP and HTTPS, this datasource provides a custom; 32// ""SQlite VFS module"" that uses Davix for data access. The SQlite VFS modules are roughly what TSystem is; 33// for ROOT -- an abstraction of the operating system interface.; 34//; 35// SQlite allows for registering custom VFS modules, which are a set of C callback functions that SQlite invokes when; 36// it needs to read from a file, write to a file, etc. More information is available under https://sqlite.org/vfs.html; 37//; 38// In the context of a data source, SQlite will only ever call reading functions from the VFS module, the sqlite; 39// files are not modified. Therefore, only a subset of the callback functions provide a non-trivial implementation.; 40// The custom VFS module uses a RRawFile for the byte access, thereby it can access local and remote files.; 41 ; 42////////////////////////////////////////////////////////////////////////////; 43/// SQlite VFS modules are identified by string names. The name has to be unique for the entire application.; 44constexpr char const *gSQliteVfsName = ""ROOT-Davix-readonly"";; 45 ; 46////////////////////////////////////////////////////////////////////////////; 47/// Holds the state of an open sqlite database. Objects of this struct are created in VfsRdOnlyOpen(); 48/// and then passed by sqlite to the file I/O callbacks (read, close, etc.). This uses C style inheritance; 49/// where the struct starts with a sqlite3_f",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:3970,Availability,error,error,3970,"/////////////////////////////////////////////////////////////////////; 62/// Releases the resources associated to a file opened with davix; 63int VfsRdOnlyClose(sqlite3_file *pFile); 64{; 65 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 66 // We can't use delete because the storage for p is managed by sqlite; 67 p->~VfsRootFile();; 68 return SQLITE_OK;; 69}; 70 ; 71////////////////////////////////////////////////////////////////////////////; 72/// Issues a byte range request for a chunk to the raw file; 73int VfsRdOnlyRead(sqlite3_file *pFile, void *zBuf, int count, sqlite_int64 offset); 74{; 75 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 76 auto nbytes = p->fRawFile->ReadAt(zBuf, count, offset);; 77 return (nbytes != static_cast<unsigned int>(count)) ? SQLITE_IOERR : SQLITE_OK;; 78}; 79 ; 80////////////////////////////////////////////////////////////////////////////; 81/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 82int VfsRdOnlyWrite(sqlite3_file * /*pFile*/, const void * /*zBuf*/, int /*iAmt*/, sqlite_int64 /*iOfst*/); 83{; 84 return SQLITE_OPEN_READONLY;; 85}; 86 ; 87////////////////////////////////////////////////////////////////////////////; 88/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 89int VfsRdOnlyTruncate(sqlite3_file * /*pFile*/, sqlite_int64 /*size*/); 90{; 91 return SQLITE_OPEN_READONLY;; 92}; 93 ; 94////////////////////////////////////////////////////////////////////////////; 95/// As the database is read-only, syncing data to disc is a no-op and always succeeds; 96int VfsRdOnlySync(sqlite3_file * /*pFile*/, int /*flags*/); 97{; 98 return SQLITE_OK;; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////; 102/// Returns the cached file size; 103int VfsRdOnlyFileSize(sqlite3_file *pFile, sqlite_int64 *pSize); 104{; 105 VfsRootFile *p = reinterpret_cast<VfsRo",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:4322,Availability,error,error,4322,"urn SQLITE_OK;; 69}; 70 ; 71////////////////////////////////////////////////////////////////////////////; 72/// Issues a byte range request for a chunk to the raw file; 73int VfsRdOnlyRead(sqlite3_file *pFile, void *zBuf, int count, sqlite_int64 offset); 74{; 75 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 76 auto nbytes = p->fRawFile->ReadAt(zBuf, count, offset);; 77 return (nbytes != static_cast<unsigned int>(count)) ? SQLITE_IOERR : SQLITE_OK;; 78}; 79 ; 80////////////////////////////////////////////////////////////////////////////; 81/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 82int VfsRdOnlyWrite(sqlite3_file * /*pFile*/, const void * /*zBuf*/, int /*iAmt*/, sqlite_int64 /*iOfst*/); 83{; 84 return SQLITE_OPEN_READONLY;; 85}; 86 ; 87////////////////////////////////////////////////////////////////////////////; 88/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 89int VfsRdOnlyTruncate(sqlite3_file * /*pFile*/, sqlite_int64 /*size*/); 90{; 91 return SQLITE_OPEN_READONLY;; 92}; 93 ; 94////////////////////////////////////////////////////////////////////////////; 95/// As the database is read-only, syncing data to disc is a no-op and always succeeds; 96int VfsRdOnlySync(sqlite3_file * /*pFile*/, int /*flags*/); 97{; 98 return SQLITE_OK;; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////; 102/// Returns the cached file size; 103int VfsRdOnlyFileSize(sqlite3_file *pFile, sqlite_int64 *pSize); 104{; 105 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 106 *pSize = p->fRawFile->GetSize();; 107 return SQLITE_OK;; 108}; 109 ; 110////////////////////////////////////////////////////////////////////////////; 111/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 112int VfsRdOnlyLock(sqlite3_file * /*pFile*/, int /*level*/); 113{; 114 return SQ",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:14429,Availability,error,error,14429,"tval = sqlite3_vfs_register(&kSqlite3Vfs, false);; 313 return (retval == SQLITE_OK);; 314}; 315 ; 316} // anonymous namespace; 317 ; 318namespace ROOT {; 319 ; 320namespace RDF {; 321 ; 322namespace Internal {; 323////////////////////////////////////////////////////////////////////////////; 324/// The state of an open dataset in terms of the sqlite3 C library.; 325struct RSqliteDSDataSet {; 326 sqlite3 *fDb = nullptr;; 327 sqlite3_stmt *fQuery = nullptr;; 328};; 329}; 330 ; 331RSqliteDS::Value_t::Value_t(RSqliteDS::ETypes type); 332 : fType(type), fIsActive(false), fInteger(0), fReal(0.0), fText(), fBlob(), fNull(nullptr); 333{; 334 switch (type) {; 335 case ETypes::kInteger: fPtr = &fInteger; break;; 336 case ETypes::kReal: fPtr = &fReal; break;; 337 case ETypes::kText: fPtr = &fText; break;; 338 case ETypes::kBlob: fPtr = &fBlob; break;; 339 case ETypes::kNull: fPtr = &fNull; break;; 340 default: throw std::runtime_error(""Internal error"");; 341 }; 342}; 343 ; 344constexpr char const *RSqliteDS::fgTypeNames[];; 345 ; 346////////////////////////////////////////////////////////////////////////////; 347/// \brief Build the dataframe; 348/// \param[in] fileName The path to an sqlite3 file, will be opened read-only; 349/// \param[in] query A valid sqlite3 SELECT query; 350///; 351/// The constructor opens the sqlite file, prepares the query engine and determines the column names and types.; 352RSqliteDS::RSqliteDS(const std::string &fileName, const std::string &query); 353 : fDataSet(std::make_unique<Internal::RSqliteDSDataSet>()), fNSlots(0), fNRow(0); 354{; 355 static bool hasSqliteVfs = RegisterSqliteVfs();; 356 if (!hasSqliteVfs); 357 throw std::runtime_error(""Cannot register SQlite VFS in RSqliteDS"");; 358 ; 359 int retval;; 360 ; 361 retval = sqlite3_open_v2(fileName.c_str(), &fDataSet->fDb, SQLITE_OPEN_READONLY | SQLITE_OPEN_NOMUTEX,; 362 gSQliteVfsName);; 363 if (retval != SQLITE_OK); 364 SqliteError(retval);; 365 ; 366 // Certain complex queries trigger creation",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:18344,Availability,error,error,18344,""");; 407 }; 408 ; 409 switch (type) {; 410 case SQLITE_INTEGER:; 411 fColumnTypes.push_back(ETypes::kInteger);; 412 fValues.emplace_back(ETypes::kInteger);; 413 break;; 414 case SQLITE_FLOAT:; 415 fColumnTypes.push_back(ETypes::kReal);; 416 fValues.emplace_back(ETypes::kReal);; 417 break;; 418 case SQLITE_TEXT:; 419 fColumnTypes.push_back(ETypes::kText);; 420 fValues.emplace_back(ETypes::kText);; 421 break;; 422 case SQLITE_BLOB:; 423 fColumnTypes.push_back(ETypes::kBlob);; 424 fValues.emplace_back(ETypes::kBlob);; 425 break;; 426 case SQLITE_NULL:; 427 // TODO: Null values in first rows are not well handled; 428 fColumnTypes.push_back(ETypes::kNull);; 429 fValues.emplace_back(ETypes::kNull);; 430 break;; 431 default: throw std::runtime_error(""Unhandled data type"");; 432 }; 433 }; 434}; 435 ; 436////////////////////////////////////////////////////////////////////////////; 437/// Frees the sqlite resources and closes the file.; 438RSqliteDS::~RSqliteDS(); 439{; 440 // sqlite3_finalize returns the error code of the most recent operation on fQuery.; 441 sqlite3_finalize(fDataSet->fQuery);; 442 // Closing can possibly fail with SQLITE_BUSY, in which case resources are leaked. This should not happen; 443 // the way it is used in this class because we cleanup the prepared statement before.; 444 sqlite3_close(fDataSet->fDb);; 445}; 446 ; 447////////////////////////////////////////////////////////////////////////////; 448/// Returns the SELECT queries names. The column names have been cached in the constructor.; 449/// For expressions, the column name is the string of the expression unless the query defines a column name with as; 450/// like in ""SELECT 1 + 1 as mycolumn FROM table""; 451const std::vector<std::string> &RSqliteDS::GetColumnNames() const; 452{; 453 return fColumnNames;; 454}; 455 ; 456////////////////////////////////////////////////////////////////////////////; 457/// Activates the given column's result value.; 458RDataSource::Record_t RSqliteDS::GetColumnReade",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:20363,Availability,avail,available,20363,"Record_t RSqliteDS::GetColumnReadersImpl(std::string_view name, const std::type_info &ti); 459{; 460 const auto index = std::distance(fColumnNames.begin(), std::find(fColumnNames.begin(), fColumnNames.end(), name));; 461 const auto type = fColumnTypes[index];; 462 ; 463 if ((type == ETypes::kInteger && typeid(Long64_t) != ti) || (type == ETypes::kReal && typeid(double) != ti) ||; 464 (type == ETypes::kText && typeid(std::string) != ti) ||; 465 (type == ETypes::kBlob && typeid(std::vector<unsigned char>) != ti) ||; 466 (type == ETypes::kNull && typeid(void *) != ti)) {; 467 std::string errmsg = ""The type selected for column \"""";; 468 errmsg += name;; 469 errmsg += ""\"" does not correspond to column type, which is "";; 470 errmsg += GetTypeName(name);; 471 throw std::runtime_error(errmsg);; 472 }; 473 ; 474 fValues[index].fIsActive = true;; 475 return std::vector<void *>{fNSlots, &fValues[index].fPtr};; 476}; 477 ; 478////////////////////////////////////////////////////////////////////////////; 479/// Returns a range of size 1 as long as more rows are available in the SQL result set.; 480/// This inherently serialized the RDF independent of the number of slots.; 481std::vector<std::pair<ULong64_t, ULong64_t>> RSqliteDS::GetEntryRanges(); 482{; 483 std::vector<std::pair<ULong64_t, ULong64_t>> entryRanges;; 484 int retval = sqlite3_step(fDataSet->fQuery);; 485 switch (retval) {; 486 case SQLITE_DONE: return entryRanges;; 487 case SQLITE_ROW:; 488 entryRanges.emplace_back(fNRow, fNRow + 1);; 489 fNRow++;; 490 return entryRanges;; 491 default:; 492 SqliteError(retval);; 493 // Never here; 494 abort();; 495 }; 496}; 497 ; 498////////////////////////////////////////////////////////////////////////////; 499/// Returns the C++ type for a given column name, implemented as a linear search through all the columns.; 500std::string RSqliteDS::GetTypeName(std::string_view colName) const; 501{; 502 unsigned N = fColumnNames.size();; 503 ; 504 for (unsigned i = 0; i < N; ++i) {; 505 if ",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:22141,Availability,error,error,22141,"lName) const; 501{; 502 unsigned N = fColumnNames.size();; 503 ; 504 for (unsigned i = 0; i < N; ++i) {; 505 if (colName == fColumnNames[i]) {; 506 return fgTypeNames[static_cast<int>(fColumnTypes[i])];; 507 }; 508 }; 509 throw std::runtime_error(""Unknown column: "" + std::string(colName));; 510}; 511 ; 512////////////////////////////////////////////////////////////////////////////; 513/// A linear search through the columns for the given name; 514bool RSqliteDS::HasColumn(std::string_view colName) const; 515{; 516 return std::find(fColumnNames.begin(), fColumnNames.end(), colName) != fColumnNames.end();; 517}; 518 ; 519////////////////////////////////////////////////////////////////////////////; 520/// Resets the SQlite query engine at the beginning of the event loop.; 521void RSqliteDS::Initialize(); 522{; 523 fNRow = 0;; 524 int retval = sqlite3_reset(fDataSet->fQuery);; 525 if (retval != SQLITE_OK); 526 throw std::runtime_error(""SQlite error, reset"");; 527}; 528 ; 529std::string RSqliteDS::GetLabel(); 530{; 531 return ""RSqliteDS"";; 532}; 533 ; 534////////////////////////////////////////////////////////////////////////////////////////////////; 535/// \brief Factory method to create a SQlite RDataFrame.; 536/// \param[in] fileName Path of the sqlite file.; 537/// \param[in] query SQL query that defines the data set.; 538RDataFrame FromSqlite(std::string_view fileName, std::string_view query); 539{; 540 ROOT::RDataFrame rdf(std::make_unique<RSqliteDS>(std::string(fileName), std::string(query)));; 541 return rdf;; 542}; 543 ; 544////////////////////////////////////////////////////////////////////////////; 545/// Stores the result of the current active sqlite query row as a C++ value.; 546bool RSqliteDS::SetEntry(unsigned int /* slot */, ULong64_t entry); 547{; 548 assert(entry + 1 == fNRow);; 549 (void)entry;; 550 unsigned N = fValues.size();; 551 for (unsigned i = 0; i < N; ++i) {; 552 if (!fValues[i].fIsActive); 553 continue;; 554 ; 555 int nbytes;; 556 switch (fVal",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:24712,Availability,error,error,24712,"ite3_column_text(fDataSet->fQuery, i));; 565 }; 566 break;; 567 case ETypes::kBlob:; 568 nbytes = sqlite3_column_bytes(fDataSet->fQuery, i);; 569 fValues[i].fBlob.resize(nbytes);; 570 if (nbytes > 0) {; 571 std::memcpy(fValues[i].fBlob.data(), sqlite3_column_blob(fDataSet->fQuery, i), nbytes);; 572 }; 573 break;; 574 case ETypes::kNull: break;; 575 default: throw std::runtime_error(""Unhandled column type"");; 576 }; 577 }; 578 return true;; 579}; 580 ; 581////////////////////////////////////////////////////////////////////////////////////////////////; 582/// Almost a no-op, many slots can in fact reduce the performance due to thread synchronization.; 583void RSqliteDS::SetNSlots(unsigned int nSlots); 584{; 585 if (nSlots > 1) {; 586 ::Warning(""SetNSlots"", ""Currently the SQlite data source faces performance degradation in multi-threaded mode. ""; 587 ""Consider turning off IMT."");; 588 }; 589 fNSlots = nSlots;; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////////////////////; 593/// Helper function to throw an exception if there is a fatal sqlite error, e.g. an I/O error.; 594void RSqliteDS::SqliteError(int errcode); 595{; 596 std::string errmsg = ""SQlite error: "";; 597#if SQLITE_VERSION_NUMBER < 3007015; 598 errmsg += std::to_string(errcode);; 599#else; 600 errmsg += sqlite3_errstr(errcode);; 601#endif; 602 throw std::runtime_error(errmsg);; 603}; 604 ; 605} // namespace RDF; 606 ; 607} // namespace ROOT; RRawFile.hxx; RSqliteDS.hxx; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; N#define N; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; offsetOp",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:24731,Availability,error,error,24731,"Set->fQuery, i);; 569 fValues[i].fBlob.resize(nbytes);; 570 if (nbytes > 0) {; 571 std::memcpy(fValues[i].fBlob.data(), sqlite3_column_blob(fDataSet->fQuery, i), nbytes);; 572 }; 573 break;; 574 case ETypes::kNull: break;; 575 default: throw std::runtime_error(""Unhandled column type"");; 576 }; 577 }; 578 return true;; 579}; 580 ; 581////////////////////////////////////////////////////////////////////////////////////////////////; 582/// Almost a no-op, many slots can in fact reduce the performance due to thread synchronization.; 583void RSqliteDS::SetNSlots(unsigned int nSlots); 584{; 585 if (nSlots > 1) {; 586 ::Warning(""SetNSlots"", ""Currently the SQlite data source faces performance degradation in multi-threaded mode. ""; 587 ""Consider turning off IMT."");; 588 }; 589 fNSlots = nSlots;; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////////////////////; 593/// Helper function to throw an exception if there is a fatal sqlite error, e.g. an I/O error.; 594void RSqliteDS::SqliteError(int errcode); 595{; 596 std::string errmsg = ""SQlite error: "";; 597#if SQLITE_VERSION_NUMBER < 3007015; 598 errmsg += std::to_string(errcode);; 599#else; 600 errmsg += sqlite3_errstr(errcode);; 601#endif; 602 throw std::runtime_error(errmsg);; 603}; 604 ; 605} // namespace RDF; 606 ; 607} // namespace ROOT; RRawFile.hxx; RSqliteDS.hxx; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; N#define N; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; offsetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlig",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:24823,Availability,error,error,24823," break;; 574 case ETypes::kNull: break;; 575 default: throw std::runtime_error(""Unhandled column type"");; 576 }; 577 }; 578 return true;; 579}; 580 ; 581////////////////////////////////////////////////////////////////////////////////////////////////; 582/// Almost a no-op, many slots can in fact reduce the performance due to thread synchronization.; 583void RSqliteDS::SetNSlots(unsigned int nSlots); 584{; 585 if (nSlots > 1) {; 586 ::Warning(""SetNSlots"", ""Currently the SQlite data source faces performance degradation in multi-threaded mode. ""; 587 ""Consider turning off IMT."");; 588 }; 589 fNSlots = nSlots;; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////////////////////; 593/// Helper function to throw an exception if there is a fatal sqlite error, e.g. an I/O error.; 594void RSqliteDS::SqliteError(int errcode); 595{; 596 std::string errmsg = ""SQlite error: "";; 597#if SQLITE_VERSION_NUMBER < 3007015; 598 errmsg += std::to_string(errcode);; 599#else; 600 errmsg += sqlite3_errstr(errcode);; 601#endif; 602 throw std::runtime_error(errmsg);; 603}; 604 ; 605} // namespace RDF; 606 ; 607} // namespace ROOT; RRawFile.hxx; RSqliteDS.hxx; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; N#define N; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; offsetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:25327,Availability,error,error,25327,"; 585 if (nSlots > 1) {; 586 ::Warning(""SetNSlots"", ""Currently the SQlite data source faces performance degradation in multi-threaded mode. ""; 587 ""Consider turning off IMT."");; 588 }; 589 fNSlots = nSlots;; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////////////////////; 593/// Helper function to throw an exception if there is a fatal sqlite error, e.g. an I/O error.; 594void RSqliteDS::SqliteError(int errcode); 595{; 596 std::string errmsg = ""SQlite error: "";; 597#if SQLITE_VERSION_NUMBER < 3007015; 598 errmsg += std::to_string(errcode);; 599#else; 600 errmsg += sqlite3_errstr(errcode);; 601#endif; 602 throw std::runtime_error(errmsg);; 603}; 604 ; 605} // namespace RDF; 606 ; 607} // namespace ROOT; RRawFile.hxx; RSqliteDS.hxx; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; N#define N; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; offsetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h offsetDefinitio",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:29433,Availability,error,error,29433,"n RSqliteDS.hxx:84; ROOT::RDF::RSqliteDS::GetTypeNamestd::string GetTypeName(std::string_view colName) const finalReturns the C++ type for a given column name, implemented as a linear search through all the columns.Definition RSqliteDS.cxx:500; ROOT::RDF::RSqliteDS::ETypesETypesAll the types known to SQlite. Changes require changing fgTypeNames, too.Definition RSqliteDS.hxx:55; ROOT::RDF::RSqliteDS::ETypes::kText@ kText; ROOT::RDF::RSqliteDS::ETypes::kBlob@ kBlob; ROOT::RDF::RSqliteDS::ETypes::kReal@ kReal; ROOT::RDF::RSqliteDS::ETypes::kInteger@ kInteger; ROOT::RDF::RSqliteDS::ETypes::kNull@ kNull; ROOT::RDF::RSqliteDS::RSqliteDSRSqliteDS(const std::string &fileName, const std::string &query)Build the dataframe.Definition RSqliteDS.cxx:352; ROOT::RDF::RSqliteDS::fNRowULong64_t fNRowDefinition RSqliteDS.hxx:82; ROOT::RDF::RSqliteDS::fDataSetstd::unique_ptr< Internal::RSqliteDSDataSet > fDataSetDefinition RSqliteDS.hxx:80; ROOT::RDF::RSqliteDS::SqliteErrorvoid SqliteError(int errcode)Helper function to throw an exception if there is a fatal sqlite error, e.g. an I/O error.Definition RSqliteDS.cxx:594; ROOT::RDF::RSqliteDS::fValuesstd::vector< Value_t > fValuesThe data source is inherently single-threaded and returns only one row at a time. This vector holds t...Definition RSqliteDS.hxx:86; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TRandom::Integervirtual UInt_t Integer(UInt_t imax)Returns a random integer uniformly distributed on the interval [ 0, imax-1 ].Definition TRandom.cxx:361; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOT::RDF::FromSqliteRDataFrame FromSqlite(std::string_view fileName, std::string_view query)Factory method to create a SQlite RDataFrame.Definition RSqliteDS.cxx:538; ROOTtbb::task_arena is an alias of tbb::interface7::task_a",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:29452,Availability,error,error,29452,":string_view colName) const finalReturns the C++ type for a given column name, implemented as a linear search through all the columns.Definition RSqliteDS.cxx:500; ROOT::RDF::RSqliteDS::ETypesETypesAll the types known to SQlite. Changes require changing fgTypeNames, too.Definition RSqliteDS.hxx:55; ROOT::RDF::RSqliteDS::ETypes::kText@ kText; ROOT::RDF::RSqliteDS::ETypes::kBlob@ kBlob; ROOT::RDF::RSqliteDS::ETypes::kReal@ kReal; ROOT::RDF::RSqliteDS::ETypes::kInteger@ kInteger; ROOT::RDF::RSqliteDS::ETypes::kNull@ kNull; ROOT::RDF::RSqliteDS::RSqliteDSRSqliteDS(const std::string &fileName, const std::string &query)Build the dataframe.Definition RSqliteDS.cxx:352; ROOT::RDF::RSqliteDS::fNRowULong64_t fNRowDefinition RSqliteDS.hxx:82; ROOT::RDF::RSqliteDS::fDataSetstd::unique_ptr< Internal::RSqliteDSDataSet > fDataSetDefinition RSqliteDS.hxx:80; ROOT::RDF::RSqliteDS::SqliteErrorvoid SqliteError(int errcode)Helper function to throw an exception if there is a fatal sqlite error, e.g. an I/O error.Definition RSqliteDS.cxx:594; ROOT::RDF::RSqliteDS::fValuesstd::vector< Value_t > fValuesThe data source is inherently single-threaded and returns only one row at a time. This vector holds t...Definition RSqliteDS.hxx:86; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TRandom::Integervirtual UInt_t Integer(UInt_t imax)Returns a random integer uniformly distributed on the interval [ 0, imax-1 ].Definition TRandom.cxx:361; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOT::RDF::FromSqliteRDataFrame FromSqlite(std::string_view fileName, std::string_view query)Factory method to create a SQlite RDataFrame.Definition RSqliteDS.cxx:538; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:8284,Energy Efficiency,allocate,allocated,8284,"ersion 1 was introduced with sqlite 3.6, version 2 with sqlite 3.7.8, version 3 with sqlite 3.7.17; 160 sqlite3_io_methods io_methods;; 161 memset(&io_methods, 0, sizeof(io_methods));; 162 io_methods.iVersion = 1;; 163 io_methods.xClose = VfsRdOnlyClose;; 164 io_methods.xRead = VfsRdOnlyRead;; 165 io_methods.xWrite = VfsRdOnlyWrite;; 166 io_methods.xTruncate = VfsRdOnlyTruncate;; 167 io_methods.xSync = VfsRdOnlySync;; 168 io_methods.xFileSize = VfsRdOnlyFileSize;; 169 io_methods.xLock = VfsRdOnlyLock;; 170 io_methods.xUnlock = VfsRdOnlyUnlock;; 171 io_methods.xCheckReservedLock = VfsRdOnlyCheckReservedLock;; 172 io_methods.xFileControl = VfsRdOnlyFileControl;; 173 io_methods.xSectorSize = VfsRdOnlySectorSize;; 174 io_methods.xDeviceCharacteristics = VfsRdOnlyDeviceCharacteristics;; 175 return io_methods;; 176}; 177 ; 178////////////////////////////////////////////////////////////////////////////; 179/// Fills a new VfsRootFile struct enclosing a Davix file; 180int VfsRdOnlyOpen(sqlite3_vfs * /*vfs*/, const char *zName, sqlite3_file *pFile, int flags, int * /*pOutFlags*/); 181{; 182 // Storage for the VfsRootFile structure has been already allocated by sqlite, so we use placement new; 183 VfsRootFile *p = new (pFile) VfsRootFile();; 184 p->pFile.pMethods = nullptr;; 185 ; 186 // This global struct contains the function pointers to all the callback operations that act on an open database.; 187 // It is passed via the pFile struct back to sqlite so that it can call back to the functions provided above.; 188 static const sqlite3_io_methods io_methods = GetSqlite3IoMethods();; 189 ; 190 if (flags & (SQLITE_OPEN_READWRITE | SQLITE_OPEN_DELETEONCLOSE | SQLITE_OPEN_EXCLUSIVE)); 191 return SQLITE_IOERR;; 192 ; 193 p->fRawFile = ROOT::Internal::RRawFile::Create(zName);; 194 if (!p->fRawFile) {; 195 ::Error(""VfsRdOnlyOpen"", ""Cannot open %s\n"", zName);; 196 return SQLITE_IOERR;; 197 }; 198 ; 199 p->pFile.pMethods = &io_methods;; 200 return SQLITE_OK;; 201}; 202 ; 203// The foll",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:24209,Energy Efficiency,reduce,reduce,24209,"s.size();; 551 for (unsigned i = 0; i < N; ++i) {; 552 if (!fValues[i].fIsActive); 553 continue;; 554 ; 555 int nbytes;; 556 switch (fValues[i].fType) {; 557 case ETypes::kInteger: fValues[i].fInteger = sqlite3_column_int64(fDataSet->fQuery, i); break;; 558 case ETypes::kReal: fValues[i].fReal = sqlite3_column_double(fDataSet->fQuery, i); break;; 559 case ETypes::kText:; 560 nbytes = sqlite3_column_bytes(fDataSet->fQuery, i);; 561 if (nbytes == 0) {; 562 fValues[i].fText = """";; 563 } else {; 564 fValues[i].fText = reinterpret_cast<const char *>(sqlite3_column_text(fDataSet->fQuery, i));; 565 }; 566 break;; 567 case ETypes::kBlob:; 568 nbytes = sqlite3_column_bytes(fDataSet->fQuery, i);; 569 fValues[i].fBlob.resize(nbytes);; 570 if (nbytes > 0) {; 571 std::memcpy(fValues[i].fBlob.data(), sqlite3_column_blob(fDataSet->fQuery, i), nbytes);; 572 }; 573 break;; 574 case ETypes::kNull: break;; 575 default: throw std::runtime_error(""Unhandled column type"");; 576 }; 577 }; 578 return true;; 579}; 580 ; 581////////////////////////////////////////////////////////////////////////////////////////////////; 582/// Almost a no-op, many slots can in fact reduce the performance due to thread synchronization.; 583void RSqliteDS::SetNSlots(unsigned int nSlots); 584{; 585 if (nSlots > 1) {; 586 ::Warning(""SetNSlots"", ""Currently the SQlite data source faces performance degradation in multi-threaded mode. ""; 587 ""Consider turning off IMT."");; 588 }; 589 fNSlots = nSlots;; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////////////////////; 593/// Helper function to throw an exception if there is a fatal sqlite error, e.g. an I/O error.; 594void RSqliteDS::SqliteError(int errcode); 595{; 596 std::string errmsg = ""SQlite error: "";; 597#if SQLITE_VERSION_NUMBER < 3007015; 598 errmsg += std::to_string(errcode);; 599#else; 600 errmsg += sqlite3_errstr(errcode);; 601#endif; 602 throw std::runtime_error(errmsg);; 603}; 604 ; 605} // namespace RDF; 606",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:1304,Integrability,interface,interface,1304,"****************************************************; 4 * Copyright (C) 1995-2017, Rene Brun and Fons Rademakers. *; 5 * All rights reserved. *; 6 * *; 7 * For the licensing terms see $ROOTSYS/LICENSE. *; 8 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11#include <ROOT/RSqliteDS.hxx>; 12#include <ROOT/RRawFile.hxx>; 13 ; 14#include ""TError.h""; 15#include ""TRandom.h""; 16#include ""TSystem.h""; 17 ; 18#include <algorithm>; 19#include <cctype>; 20#include <cerrno>; 21#include <cstring> // for memcpy; 22#include <ctime>; 23#include <memory> // for placement new; 24#include <stdexcept>; 25#include <utility>; 26 ; 27#include <sqlite3.h>; 28 ; 29namespace {; 30 ; 31// In order to provide direct access to remote sqlite files through HTTP and HTTPS, this datasource provides a custom; 32// ""SQlite VFS module"" that uses Davix for data access. The SQlite VFS modules are roughly what TSystem is; 33// for ROOT -- an abstraction of the operating system interface.; 34//; 35// SQlite allows for registering custom VFS modules, which are a set of C callback functions that SQlite invokes when; 36// it needs to read from a file, write to a file, etc. More information is available under https://sqlite.org/vfs.html; 37//; 38// In the context of a data source, SQlite will only ever call reading functions from the VFS module, the sqlite; 39// files are not modified. Therefore, only a subset of the callback functions provide a non-trivial implementation.; 40// The custom VFS module uses a RRawFile for the byte access, thereby it can access local and remote files.; 41 ; 42////////////////////////////////////////////////////////////////////////////; 43/// SQlite VFS modules are identified by string names. The name has to be unique for the entire application.; 44constexpr char const *gSQliteVfsName = ""ROOT-Davix-readonly"";; 45 ; 46/////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:10916,Integrability,wrap,wrapper,10916,"Out); 217{; 218 *pResOut = 0;; 219 if (flags == SQLITE_ACCESS_READWRITE) {; 220 return SQLITE_OPEN_READONLY;; 221 }; 222 return SQLITE_OK;; 223}; 224 ; 225////////////////////////////////////////////////////////////////////////////; 226/// No distinction between relative and full paths for URLs, returns the input path name; 227int VfsRdOnlyFullPathname(sqlite3_vfs * /*vfs*/, const char *zPath, int nOut, char *zOut); 228{; 229 zOut[nOut - 1] = '\0';; 230 sqlite3_snprintf(nOut, zOut, ""%s"", zPath);; 231 return SQLITE_OK;; 232}; 233 ; 234////////////////////////////////////////////////////////////////////////////; 235/// Let TRandom fill the buffer with random bytes; 236int VfsRdOnlyRandomness(sqlite3_vfs * /*vfs*/, int nBuf, char *zBuf); 237{; 238 for (int i = 0; i < nBuf; ++i) {; 239 zBuf[i] = (char)gRandom->Integer(256);; 240 }; 241 return nBuf;; 242}; 243 ; 244////////////////////////////////////////////////////////////////////////////; 245/// Use ROOT's platform independent sleep wrapper; 246int VfsRdOnlySleep(sqlite3_vfs * /*vfs*/, int microseconds); 247{; 248 // Millisecond precision but sleep at least number of given microseconds as requested; 249 gSystem->Sleep((microseconds + 1000 - 1) / 1000);; 250 return microseconds;; 251}; 252 ; 253////////////////////////////////////////////////////////////////////////////; 254/// Use sqlite default implementation; 255int VfsRdOnlyGetLastError(sqlite3_vfs * /*vfs*/, int /*not_used1*/, char * /*not_used2*/); 256{; 257 return errno;; 258}; 259 ; 260////////////////////////////////////////////////////////////////////////////; 261/// Return UTC as being done in the sqlite unix VFS without gettimeofday(); 262int VfsRdOnlyCurrentTimeInt64(sqlite3_vfs * /*vfs*/, sqlite3_int64 *piNow); 263{; 264 static constexpr sqlite3_int64 unixEpoch = 24405875 * (sqlite3_int64)8640000;; 265 time_t t;; 266 time(&t);; 267 *piNow = ((sqlite3_int64)t) * 1000 + unixEpoch;; 268 return SQLITE_OK;; 269}; 270 ; 271//////////////////////////////////////",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:24246,Integrability,synchroniz,synchronization,24246,"s.size();; 551 for (unsigned i = 0; i < N; ++i) {; 552 if (!fValues[i].fIsActive); 553 continue;; 554 ; 555 int nbytes;; 556 switch (fValues[i].fType) {; 557 case ETypes::kInteger: fValues[i].fInteger = sqlite3_column_int64(fDataSet->fQuery, i); break;; 558 case ETypes::kReal: fValues[i].fReal = sqlite3_column_double(fDataSet->fQuery, i); break;; 559 case ETypes::kText:; 560 nbytes = sqlite3_column_bytes(fDataSet->fQuery, i);; 561 if (nbytes == 0) {; 562 fValues[i].fText = """";; 563 } else {; 564 fValues[i].fText = reinterpret_cast<const char *>(sqlite3_column_text(fDataSet->fQuery, i));; 565 }; 566 break;; 567 case ETypes::kBlob:; 568 nbytes = sqlite3_column_bytes(fDataSet->fQuery, i);; 569 fValues[i].fBlob.resize(nbytes);; 570 if (nbytes > 0) {; 571 std::memcpy(fValues[i].fBlob.data(), sqlite3_column_blob(fDataSet->fQuery, i), nbytes);; 572 }; 573 break;; 574 case ETypes::kNull: break;; 575 default: throw std::runtime_error(""Unhandled column type"");; 576 }; 577 }; 578 return true;; 579}; 580 ; 581////////////////////////////////////////////////////////////////////////////////////////////////; 582/// Almost a no-op, many slots can in fact reduce the performance due to thread synchronization.; 583void RSqliteDS::SetNSlots(unsigned int nSlots); 584{; 585 if (nSlots > 1) {; 586 ::Warning(""SetNSlots"", ""Currently the SQlite data source faces performance degradation in multi-threaded mode. ""; 587 ""Consider turning off IMT."");; 588 }; 589 fNSlots = nSlots;; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////////////////////; 593/// Helper function to throw an exception if there is a fatal sqlite error, e.g. an I/O error.; 594void RSqliteDS::SqliteError(int errcode); 595{; 596 std::string errmsg = ""SQlite error: "";; 597#if SQLITE_VERSION_NUMBER < 3007015; 598 errmsg += std::to_string(errcode);; 599#else; 600 errmsg += sqlite3_errstr(errcode);; 601#endif; 602 throw std::runtime_error(errmsg);; 603}; 604 ; 605} // namespace RDF; 606",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:29742,Integrability,interface,interface,29742,"n RSqliteDS.hxx:55; ROOT::RDF::RSqliteDS::ETypes::kText@ kText; ROOT::RDF::RSqliteDS::ETypes::kBlob@ kBlob; ROOT::RDF::RSqliteDS::ETypes::kReal@ kReal; ROOT::RDF::RSqliteDS::ETypes::kInteger@ kInteger; ROOT::RDF::RSqliteDS::ETypes::kNull@ kNull; ROOT::RDF::RSqliteDS::RSqliteDSRSqliteDS(const std::string &fileName, const std::string &query)Build the dataframe.Definition RSqliteDS.cxx:352; ROOT::RDF::RSqliteDS::fNRowULong64_t fNRowDefinition RSqliteDS.hxx:82; ROOT::RDF::RSqliteDS::fDataSetstd::unique_ptr< Internal::RSqliteDSDataSet > fDataSetDefinition RSqliteDS.hxx:80; ROOT::RDF::RSqliteDS::SqliteErrorvoid SqliteError(int errcode)Helper function to throw an exception if there is a fatal sqlite error, e.g. an I/O error.Definition RSqliteDS.cxx:594; ROOT::RDF::RSqliteDS::fValuesstd::vector< Value_t > fValuesThe data source is inherently single-threaded and returns only one row at a time. This vector holds t...Definition RSqliteDS.hxx:86; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TRandom::Integervirtual UInt_t Integer(UInt_t imax)Returns a random integer uniformly distributed on the interval [ 0, imax-1 ].Definition TRandom.cxx:361; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOT::RDF::FromSqliteRDataFrame FromSqlite(std::string_view fileName, std::string_view query)Factory method to create a SQlite RDataFrame.Definition RSqliteDS.cxx:538; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::RDF::Internal::RSqliteDSDataSetThe state of an open dataset in terms of the sqlite3 C library.Definition RSqliteDS.cxx:325; ROOT::RDF::Internal::RSqliteDSDataSet::fQuerysqlite3_stmt * fQueryDefinition RSqliteDS.cxx:327; ROOT::RDF::Internal::RSqliteDSDataSet::fDbsqlite3 *",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:2466,Modifiability,inherit,inheritance,2466," https://sqlite.org/vfs.html; 37//; 38// In the context of a data source, SQlite will only ever call reading functions from the VFS module, the sqlite; 39// files are not modified. Therefore, only a subset of the callback functions provide a non-trivial implementation.; 40// The custom VFS module uses a RRawFile for the byte access, thereby it can access local and remote files.; 41 ; 42////////////////////////////////////////////////////////////////////////////; 43/// SQlite VFS modules are identified by string names. The name has to be unique for the entire application.; 44constexpr char const *gSQliteVfsName = ""ROOT-Davix-readonly"";; 45 ; 46////////////////////////////////////////////////////////////////////////////; 47/// Holds the state of an open sqlite database. Objects of this struct are created in VfsRdOnlyOpen(); 48/// and then passed by sqlite to the file I/O callbacks (read, close, etc.). This uses C style inheritance; 49/// where the struct starts with a sqlite3_file member (base class) which is extended by members related to; 50/// this particular VFS module. Every callback here thus casts the sqlite3_file input parameter to its ""derived""; 51/// type VfsRootFile.; 52struct VfsRootFile {; 53 VfsRootFile() = default;; 54 ; 55 sqlite3_file pFile;; 56 std::unique_ptr<ROOT::Internal::RRawFile> fRawFile;; 57};; 58 ; 59// The following callbacks implement the I/O operations of an open database; 60 ; 61////////////////////////////////////////////////////////////////////////////; 62/// Releases the resources associated to a file opened with davix; 63int VfsRdOnlyClose(sqlite3_file *pFile); 64{; 65 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 66 // We can't use delete because the storage for p is managed by sqlite; 67 p->~VfsRootFile();; 68 return SQLITE_OK;; 69}; 70 ; 71////////////////////////////////////////////////////////////////////////////; 72/// Issues a byte range request for a chunk to the raw file; 73int VfsRdOnlyRead(sqlite3_file *pFile, ",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:2558,Modifiability,extend,extended,2558," https://sqlite.org/vfs.html; 37//; 38// In the context of a data source, SQlite will only ever call reading functions from the VFS module, the sqlite; 39// files are not modified. Therefore, only a subset of the callback functions provide a non-trivial implementation.; 40// The custom VFS module uses a RRawFile for the byte access, thereby it can access local and remote files.; 41 ; 42////////////////////////////////////////////////////////////////////////////; 43/// SQlite VFS modules are identified by string names. The name has to be unique for the entire application.; 44constexpr char const *gSQliteVfsName = ""ROOT-Davix-readonly"";; 45 ; 46////////////////////////////////////////////////////////////////////////////; 47/// Holds the state of an open sqlite database. Objects of this struct are created in VfsRdOnlyOpen(); 48/// and then passed by sqlite to the file I/O callbacks (read, close, etc.). This uses C style inheritance; 49/// where the struct starts with a sqlite3_file member (base class) which is extended by members related to; 50/// this particular VFS module. Every callback here thus casts the sqlite3_file input parameter to its ""derived""; 51/// type VfsRootFile.; 52struct VfsRootFile {; 53 VfsRootFile() = default;; 54 ; 55 sqlite3_file pFile;; 56 std::unique_ptr<ROOT::Internal::RRawFile> fRawFile;; 57};; 58 ; 59// The following callbacks implement the I/O operations of an open database; 60 ; 61////////////////////////////////////////////////////////////////////////////; 62/// Releases the resources associated to a file opened with davix; 63int VfsRdOnlyClose(sqlite3_file *pFile); 64{; 65 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 66 // We can't use delete because the storage for p is managed by sqlite; 67 p->~VfsRootFile();; 68 return SQLITE_OK;; 69}; 70 ; 71////////////////////////////////////////////////////////////////////////////; 72/// Issues a byte range request for a chunk to the raw file; 73int VfsRdOnlyRead(sqlite3_file *pFile, ",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:4838,Performance,cache,cached,4838,"/////////////////////////////////////; 81/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 82int VfsRdOnlyWrite(sqlite3_file * /*pFile*/, const void * /*zBuf*/, int /*iAmt*/, sqlite_int64 /*iOfst*/); 83{; 84 return SQLITE_OPEN_READONLY;; 85}; 86 ; 87////////////////////////////////////////////////////////////////////////////; 88/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 89int VfsRdOnlyTruncate(sqlite3_file * /*pFile*/, sqlite_int64 /*size*/); 90{; 91 return SQLITE_OPEN_READONLY;; 92}; 93 ; 94////////////////////////////////////////////////////////////////////////////; 95/// As the database is read-only, syncing data to disc is a no-op and always succeeds; 96int VfsRdOnlySync(sqlite3_file * /*pFile*/, int /*flags*/); 97{; 98 return SQLITE_OK;; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////; 102/// Returns the cached file size; 103int VfsRdOnlyFileSize(sqlite3_file *pFile, sqlite_int64 *pSize); 104{; 105 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 106 *pSize = p->fRawFile->GetSize();; 107 return SQLITE_OK;; 108}; 109 ; 110////////////////////////////////////////////////////////////////////////////; 111/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 112int VfsRdOnlyLock(sqlite3_file * /*pFile*/, int /*level*/); 113{; 114 return SQLITE_OK;; 115}; 116 ; 117////////////////////////////////////////////////////////////////////////////; 118/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 119int VfsRdOnlyUnlock(sqlite3_file * /*pFile*/, int /*level*/); 120{; 121 return SQLITE_OK;; 122}; 123 ; 124////////////////////////////////////////////////////////////////////////////; 125/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 126int VfsRdOnlyCheckReservedLock",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:5193,Performance,concurren,concurrent,5193,"////////////////////////////////; 88/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 89int VfsRdOnlyTruncate(sqlite3_file * /*pFile*/, sqlite_int64 /*size*/); 90{; 91 return SQLITE_OPEN_READONLY;; 92}; 93 ; 94////////////////////////////////////////////////////////////////////////////; 95/// As the database is read-only, syncing data to disc is a no-op and always succeeds; 96int VfsRdOnlySync(sqlite3_file * /*pFile*/, int /*flags*/); 97{; 98 return SQLITE_OK;; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////; 102/// Returns the cached file size; 103int VfsRdOnlyFileSize(sqlite3_file *pFile, sqlite_int64 *pSize); 104{; 105 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 106 *pSize = p->fRawFile->GetSize();; 107 return SQLITE_OK;; 108}; 109 ; 110////////////////////////////////////////////////////////////////////////////; 111/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 112int VfsRdOnlyLock(sqlite3_file * /*pFile*/, int /*level*/); 113{; 114 return SQLITE_OK;; 115}; 116 ; 117////////////////////////////////////////////////////////////////////////////; 118/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 119int VfsRdOnlyUnlock(sqlite3_file * /*pFile*/, int /*level*/); 120{; 121 return SQLITE_OK;; 122}; 123 ; 124////////////////////////////////////////////////////////////////////////////; 125/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 126int VfsRdOnlyCheckReservedLock(sqlite3_file * /*pFile*/, int *pResOut); 127{; 128 *pResOut = 0;; 129 return SQLITE_OK;; 130}; 131 ; 132////////////////////////////////////////////////////////////////////////////; 133/// As the database is read-only, we know there are no additional control files such as a database journal; 134int VfsRdOnlyFileControl(sqlite3_file * /*p*/, int /*op*/, v",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:5475,Performance,concurren,concurrent,5475,"///////////////////////////////////////////////////////////////////; 95/// As the database is read-only, syncing data to disc is a no-op and always succeeds; 96int VfsRdOnlySync(sqlite3_file * /*pFile*/, int /*flags*/); 97{; 98 return SQLITE_OK;; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////; 102/// Returns the cached file size; 103int VfsRdOnlyFileSize(sqlite3_file *pFile, sqlite_int64 *pSize); 104{; 105 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 106 *pSize = p->fRawFile->GetSize();; 107 return SQLITE_OK;; 108}; 109 ; 110////////////////////////////////////////////////////////////////////////////; 111/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 112int VfsRdOnlyLock(sqlite3_file * /*pFile*/, int /*level*/); 113{; 114 return SQLITE_OK;; 115}; 116 ; 117////////////////////////////////////////////////////////////////////////////; 118/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 119int VfsRdOnlyUnlock(sqlite3_file * /*pFile*/, int /*level*/); 120{; 121 return SQLITE_OK;; 122}; 123 ; 124////////////////////////////////////////////////////////////////////////////; 125/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 126int VfsRdOnlyCheckReservedLock(sqlite3_file * /*pFile*/, int *pResOut); 127{; 128 *pResOut = 0;; 129 return SQLITE_OK;; 130}; 131 ; 132////////////////////////////////////////////////////////////////////////////; 133/// As the database is read-only, we know there are no additional control files such as a database journal; 134int VfsRdOnlyFileControl(sqlite3_file * /*p*/, int /*op*/, void * /*pArg*/); 135{; 136 return SQLITE_NOTFOUND;; 137}; 138 ; 139////////////////////////////////////////////////////////////////////////////; 140/// The database device's sector size is only needed for writing; 141int VfsRdOnlySectorSize(sqlite3_file * /*pFile*/); 142{; 143 retu",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:5759,Performance,concurren,concurrent,5759,"/////////////////////////////////////////////////////; 102/// Returns the cached file size; 103int VfsRdOnlyFileSize(sqlite3_file *pFile, sqlite_int64 *pSize); 104{; 105 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 106 *pSize = p->fRawFile->GetSize();; 107 return SQLITE_OK;; 108}; 109 ; 110////////////////////////////////////////////////////////////////////////////; 111/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 112int VfsRdOnlyLock(sqlite3_file * /*pFile*/, int /*level*/); 113{; 114 return SQLITE_OK;; 115}; 116 ; 117////////////////////////////////////////////////////////////////////////////; 118/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 119int VfsRdOnlyUnlock(sqlite3_file * /*pFile*/, int /*level*/); 120{; 121 return SQLITE_OK;; 122}; 123 ; 124////////////////////////////////////////////////////////////////////////////; 125/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 126int VfsRdOnlyCheckReservedLock(sqlite3_file * /*pFile*/, int *pResOut); 127{; 128 *pResOut = 0;; 129 return SQLITE_OK;; 130}; 131 ; 132////////////////////////////////////////////////////////////////////////////; 133/// As the database is read-only, we know there are no additional control files such as a database journal; 134int VfsRdOnlyFileControl(sqlite3_file * /*p*/, int /*op*/, void * /*pArg*/); 135{; 136 return SQLITE_NOTFOUND;; 137}; 138 ; 139////////////////////////////////////////////////////////////////////////////; 140/// The database device's sector size is only needed for writing; 141int VfsRdOnlySectorSize(sqlite3_file * /*pFile*/); 142{; 143 return SQLITE_OPEN_READONLY;; 144}; 145 ; 146////////////////////////////////////////////////////////////////////////////; 147/// The database device's properties are only needed for writing; 148int VfsRdOnlyDeviceCharacteristics(sqlite3_file * /*pFile*/); 149{; 150 return SQLITE_OPEN_RE",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:18835,Performance,cache,cached,18835,"ck(ETypes::kBlob);; 425 break;; 426 case SQLITE_NULL:; 427 // TODO: Null values in first rows are not well handled; 428 fColumnTypes.push_back(ETypes::kNull);; 429 fValues.emplace_back(ETypes::kNull);; 430 break;; 431 default: throw std::runtime_error(""Unhandled data type"");; 432 }; 433 }; 434}; 435 ; 436////////////////////////////////////////////////////////////////////////////; 437/// Frees the sqlite resources and closes the file.; 438RSqliteDS::~RSqliteDS(); 439{; 440 // sqlite3_finalize returns the error code of the most recent operation on fQuery.; 441 sqlite3_finalize(fDataSet->fQuery);; 442 // Closing can possibly fail with SQLITE_BUSY, in which case resources are leaked. This should not happen; 443 // the way it is used in this class because we cleanup the prepared statement before.; 444 sqlite3_close(fDataSet->fDb);; 445}; 446 ; 447////////////////////////////////////////////////////////////////////////////; 448/// Returns the SELECT queries names. The column names have been cached in the constructor.; 449/// For expressions, the column name is the string of the expression unless the query defines a column name with as; 450/// like in ""SELECT 1 + 1 as mycolumn FROM table""; 451const std::vector<std::string> &RSqliteDS::GetColumnNames() const; 452{; 453 return fColumnNames;; 454}; 455 ; 456////////////////////////////////////////////////////////////////////////////; 457/// Activates the given column's result value.; 458RDataSource::Record_t RSqliteDS::GetColumnReadersImpl(std::string_view name, const std::type_info &ti); 459{; 460 const auto index = std::distance(fColumnNames.begin(), std::find(fColumnNames.begin(), fColumnNames.end(), name));; 461 const auto type = fColumnTypes[index];; 462 ; 463 if ((type == ETypes::kInteger && typeid(Long64_t) != ti) || (type == ETypes::kReal && typeid(double) != ti) ||; 464 (type == ETypes::kText && typeid(std::string) != ti) ||; 465 (type == ETypes::kBlob && typeid(std::vector<unsigned char>) != ti) ||; 466 (type == ET",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:24220,Performance,perform,performance,24220,"s.size();; 551 for (unsigned i = 0; i < N; ++i) {; 552 if (!fValues[i].fIsActive); 553 continue;; 554 ; 555 int nbytes;; 556 switch (fValues[i].fType) {; 557 case ETypes::kInteger: fValues[i].fInteger = sqlite3_column_int64(fDataSet->fQuery, i); break;; 558 case ETypes::kReal: fValues[i].fReal = sqlite3_column_double(fDataSet->fQuery, i); break;; 559 case ETypes::kText:; 560 nbytes = sqlite3_column_bytes(fDataSet->fQuery, i);; 561 if (nbytes == 0) {; 562 fValues[i].fText = """";; 563 } else {; 564 fValues[i].fText = reinterpret_cast<const char *>(sqlite3_column_text(fDataSet->fQuery, i));; 565 }; 566 break;; 567 case ETypes::kBlob:; 568 nbytes = sqlite3_column_bytes(fDataSet->fQuery, i);; 569 fValues[i].fBlob.resize(nbytes);; 570 if (nbytes > 0) {; 571 std::memcpy(fValues[i].fBlob.data(), sqlite3_column_blob(fDataSet->fQuery, i), nbytes);; 572 }; 573 break;; 574 case ETypes::kNull: break;; 575 default: throw std::runtime_error(""Unhandled column type"");; 576 }; 577 }; 578 return true;; 579}; 580 ; 581////////////////////////////////////////////////////////////////////////////////////////////////; 582/// Almost a no-op, many slots can in fact reduce the performance due to thread synchronization.; 583void RSqliteDS::SetNSlots(unsigned int nSlots); 584{; 585 if (nSlots > 1) {; 586 ::Warning(""SetNSlots"", ""Currently the SQlite data source faces performance degradation in multi-threaded mode. ""; 587 ""Consider turning off IMT."");; 588 }; 589 fNSlots = nSlots;; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////////////////////; 593/// Helper function to throw an exception if there is a fatal sqlite error, e.g. an I/O error.; 594void RSqliteDS::SqliteError(int errcode); 595{; 596 std::string errmsg = ""SQlite error: "";; 597#if SQLITE_VERSION_NUMBER < 3007015; 598 errmsg += std::to_string(errcode);; 599#else; 600 errmsg += sqlite3_errstr(errcode);; 601#endif; 602 throw std::runtime_error(errmsg);; 603}; 604 ; 605} // namespace RDF; 606",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:24411,Performance,perform,performance,24411,"umn_double(fDataSet->fQuery, i); break;; 559 case ETypes::kText:; 560 nbytes = sqlite3_column_bytes(fDataSet->fQuery, i);; 561 if (nbytes == 0) {; 562 fValues[i].fText = """";; 563 } else {; 564 fValues[i].fText = reinterpret_cast<const char *>(sqlite3_column_text(fDataSet->fQuery, i));; 565 }; 566 break;; 567 case ETypes::kBlob:; 568 nbytes = sqlite3_column_bytes(fDataSet->fQuery, i);; 569 fValues[i].fBlob.resize(nbytes);; 570 if (nbytes > 0) {; 571 std::memcpy(fValues[i].fBlob.data(), sqlite3_column_blob(fDataSet->fQuery, i), nbytes);; 572 }; 573 break;; 574 case ETypes::kNull: break;; 575 default: throw std::runtime_error(""Unhandled column type"");; 576 }; 577 }; 578 return true;; 579}; 580 ; 581////////////////////////////////////////////////////////////////////////////////////////////////; 582/// Almost a no-op, many slots can in fact reduce the performance due to thread synchronization.; 583void RSqliteDS::SetNSlots(unsigned int nSlots); 584{; 585 if (nSlots > 1) {; 586 ::Warning(""SetNSlots"", ""Currently the SQlite data source faces performance degradation in multi-threaded mode. ""; 587 ""Consider turning off IMT."");; 588 }; 589 fNSlots = nSlots;; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////////////////////; 593/// Helper function to throw an exception if there is a fatal sqlite error, e.g. an I/O error.; 594void RSqliteDS::SqliteError(int errcode); 595{; 596 std::string errmsg = ""SQlite error: "";; 597#if SQLITE_VERSION_NUMBER < 3007015; 598 errmsg += std::to_string(errcode);; 599#else; 600 errmsg += sqlite3_errstr(errcode);; 601#endif; 602 throw std::runtime_error(errmsg);; 603}; 604 ; 605} // namespace RDF; 606 ; 607} // namespace ROOT; RRawFile.hxx; RSqliteDS.hxx; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:24438,Performance,multi-thread,multi-threaded,24438,"umn_double(fDataSet->fQuery, i); break;; 559 case ETypes::kText:; 560 nbytes = sqlite3_column_bytes(fDataSet->fQuery, i);; 561 if (nbytes == 0) {; 562 fValues[i].fText = """";; 563 } else {; 564 fValues[i].fText = reinterpret_cast<const char *>(sqlite3_column_text(fDataSet->fQuery, i));; 565 }; 566 break;; 567 case ETypes::kBlob:; 568 nbytes = sqlite3_column_bytes(fDataSet->fQuery, i);; 569 fValues[i].fBlob.resize(nbytes);; 570 if (nbytes > 0) {; 571 std::memcpy(fValues[i].fBlob.data(), sqlite3_column_blob(fDataSet->fQuery, i), nbytes);; 572 }; 573 break;; 574 case ETypes::kNull: break;; 575 default: throw std::runtime_error(""Unhandled column type"");; 576 }; 577 }; 578 return true;; 579}; 580 ; 581////////////////////////////////////////////////////////////////////////////////////////////////; 582/// Almost a no-op, many slots can in fact reduce the performance due to thread synchronization.; 583void RSqliteDS::SetNSlots(unsigned int nSlots); 584{; 585 if (nSlots > 1) {; 586 ::Warning(""SetNSlots"", ""Currently the SQlite data source faces performance degradation in multi-threaded mode. ""; 587 ""Consider turning off IMT."");; 588 }; 589 fNSlots = nSlots;; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////////////////////; 593/// Helper function to throw an exception if there is a fatal sqlite error, e.g. an I/O error.; 594void RSqliteDS::SqliteError(int errcode); 595{; 596 std::string errmsg = ""SQlite error: "";; 597#if SQLITE_VERSION_NUMBER < 3007015; 598 errmsg += std::to_string(errcode);; 599#else; 600 errmsg += sqlite3_errstr(errcode);; 601#endif; 602 throw std::runtime_error(errmsg);; 603}; 604 ; 605} // namespace RDF; 606 ; 607} // namespace ROOT; RRawFile.hxx; RSqliteDS.hxx; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:20911,Safety,abort,abort,20911,"me;; 469 errmsg += ""\"" does not correspond to column type, which is "";; 470 errmsg += GetTypeName(name);; 471 throw std::runtime_error(errmsg);; 472 }; 473 ; 474 fValues[index].fIsActive = true;; 475 return std::vector<void *>{fNSlots, &fValues[index].fPtr};; 476}; 477 ; 478////////////////////////////////////////////////////////////////////////////; 479/// Returns a range of size 1 as long as more rows are available in the SQL result set.; 480/// This inherently serialized the RDF independent of the number of slots.; 481std::vector<std::pair<ULong64_t, ULong64_t>> RSqliteDS::GetEntryRanges(); 482{; 483 std::vector<std::pair<ULong64_t, ULong64_t>> entryRanges;; 484 int retval = sqlite3_step(fDataSet->fQuery);; 485 switch (retval) {; 486 case SQLITE_DONE: return entryRanges;; 487 case SQLITE_ROW:; 488 entryRanges.emplace_back(fNRow, fNRow + 1);; 489 fNRow++;; 490 return entryRanges;; 491 default:; 492 SqliteError(retval);; 493 // Never here; 494 abort();; 495 }; 496}; 497 ; 498////////////////////////////////////////////////////////////////////////////; 499/// Returns the C++ type for a given column name, implemented as a linear search through all the columns.; 500std::string RSqliteDS::GetTypeName(std::string_view colName) const; 501{; 502 unsigned N = fColumnNames.size();; 503 ; 504 for (unsigned i = 0; i < N; ++i) {; 505 if (colName == fColumnNames[i]) {; 506 return fgTypeNames[static_cast<int>(fColumnTypes[i])];; 507 }; 508 }; 509 throw std::runtime_error(""Unknown column: "" + std::string(colName));; 510}; 511 ; 512////////////////////////////////////////////////////////////////////////////; 513/// A linear search through the columns for the given name; 514bool RSqliteDS::HasColumn(std::string_view colName) const; 515{; 516 return std::find(fColumnNames.begin(), fColumnNames.end(), colName) != fColumnNames.end();; 517}; 518 ; 519////////////////////////////////////////////////////////////////////////////; 520/// Resets the SQlite query engine at the beginning of th",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:1049,Security,access,access,1049," .  . Loading...; Searching...; No Matches. RSqliteDS.cxx. Go to the documentation of this file. 1// Author: Jakob Blomer CERN 07/2018; 2 ; 3/*************************************************************************; 4 * Copyright (C) 1995-2017, Rene Brun and Fons Rademakers. *; 5 * All rights reserved. *; 6 * *; 7 * For the licensing terms see $ROOTSYS/LICENSE. *; 8 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11#include <ROOT/RSqliteDS.hxx>; 12#include <ROOT/RRawFile.hxx>; 13 ; 14#include ""TError.h""; 15#include ""TRandom.h""; 16#include ""TSystem.h""; 17 ; 18#include <algorithm>; 19#include <cctype>; 20#include <cerrno>; 21#include <cstring> // for memcpy; 22#include <ctime>; 23#include <memory> // for placement new; 24#include <stdexcept>; 25#include <utility>; 26 ; 27#include <sqlite3.h>; 28 ; 29namespace {; 30 ; 31// In order to provide direct access to remote sqlite files through HTTP and HTTPS, this datasource provides a custom; 32// ""SQlite VFS module"" that uses Davix for data access. The SQlite VFS modules are roughly what TSystem is; 33// for ROOT -- an abstraction of the operating system interface.; 34//; 35// SQlite allows for registering custom VFS modules, which are a set of C callback functions that SQlite invokes when; 36// it needs to read from a file, write to a file, etc. More information is available under https://sqlite.org/vfs.html; 37//; 38// In the context of a data source, SQlite will only ever call reading functions from the VFS module, the sqlite; 39// files are not modified. Therefore, only a subset of the callback functions provide a non-trivial implementation.; 40// The custom VFS module uses a RRawFile for the byte access, thereby it can access local and remote files.; 41 ; 42////////////////////////////////////////////////////////////////////////////; 43/// SQlite VFS modules are identified by string names. The name has to be unique for the",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:1188,Security,access,access,1188," .  . Loading...; Searching...; No Matches. RSqliteDS.cxx. Go to the documentation of this file. 1// Author: Jakob Blomer CERN 07/2018; 2 ; 3/*************************************************************************; 4 * Copyright (C) 1995-2017, Rene Brun and Fons Rademakers. *; 5 * All rights reserved. *; 6 * *; 7 * For the licensing terms see $ROOTSYS/LICENSE. *; 8 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11#include <ROOT/RSqliteDS.hxx>; 12#include <ROOT/RRawFile.hxx>; 13 ; 14#include ""TError.h""; 15#include ""TRandom.h""; 16#include ""TSystem.h""; 17 ; 18#include <algorithm>; 19#include <cctype>; 20#include <cerrno>; 21#include <cstring> // for memcpy; 22#include <ctime>; 23#include <memory> // for placement new; 24#include <stdexcept>; 25#include <utility>; 26 ; 27#include <sqlite3.h>; 28 ; 29namespace {; 30 ; 31// In order to provide direct access to remote sqlite files through HTTP and HTTPS, this datasource provides a custom; 32// ""SQlite VFS module"" that uses Davix for data access. The SQlite VFS modules are roughly what TSystem is; 33// for ROOT -- an abstraction of the operating system interface.; 34//; 35// SQlite allows for registering custom VFS modules, which are a set of C callback functions that SQlite invokes when; 36// it needs to read from a file, write to a file, etc. More information is available under https://sqlite.org/vfs.html; 37//; 38// In the context of a data source, SQlite will only ever call reading functions from the VFS module, the sqlite; 39// files are not modified. Therefore, only a subset of the callback functions provide a non-trivial implementation.; 40// The custom VFS module uses a RRawFile for the byte access, thereby it can access local and remote files.; 41 ; 42////////////////////////////////////////////////////////////////////////////; 43/// SQlite VFS modules are identified by string names. The name has to be unique for the",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:1862,Security,access,access,1862,"nclude <ctime>; 23#include <memory> // for placement new; 24#include <stdexcept>; 25#include <utility>; 26 ; 27#include <sqlite3.h>; 28 ; 29namespace {; 30 ; 31// In order to provide direct access to remote sqlite files through HTTP and HTTPS, this datasource provides a custom; 32// ""SQlite VFS module"" that uses Davix for data access. The SQlite VFS modules are roughly what TSystem is; 33// for ROOT -- an abstraction of the operating system interface.; 34//; 35// SQlite allows for registering custom VFS modules, which are a set of C callback functions that SQlite invokes when; 36// it needs to read from a file, write to a file, etc. More information is available under https://sqlite.org/vfs.html; 37//; 38// In the context of a data source, SQlite will only ever call reading functions from the VFS module, the sqlite; 39// files are not modified. Therefore, only a subset of the callback functions provide a non-trivial implementation.; 40// The custom VFS module uses a RRawFile for the byte access, thereby it can access local and remote files.; 41 ; 42////////////////////////////////////////////////////////////////////////////; 43/// SQlite VFS modules are identified by string names. The name has to be unique for the entire application.; 44constexpr char const *gSQliteVfsName = ""ROOT-Davix-readonly"";; 45 ; 46////////////////////////////////////////////////////////////////////////////; 47/// Holds the state of an open sqlite database. Objects of this struct are created in VfsRdOnlyOpen(); 48/// and then passed by sqlite to the file I/O callbacks (read, close, etc.). This uses C style inheritance; 49/// where the struct starts with a sqlite3_file member (base class) which is extended by members related to; 50/// this particular VFS module. Every callback here thus casts the sqlite3_file input parameter to its ""derived""; 51/// type VfsRootFile.; 52struct VfsRootFile {; 53 VfsRootFile() = default;; 54 ; 55 sqlite3_file pFile;; 56 std::unique_ptr<ROOT::Internal::RRawFile> fR",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:1885,Security,access,access,1885,"nclude <ctime>; 23#include <memory> // for placement new; 24#include <stdexcept>; 25#include <utility>; 26 ; 27#include <sqlite3.h>; 28 ; 29namespace {; 30 ; 31// In order to provide direct access to remote sqlite files through HTTP and HTTPS, this datasource provides a custom; 32// ""SQlite VFS module"" that uses Davix for data access. The SQlite VFS modules are roughly what TSystem is; 33// for ROOT -- an abstraction of the operating system interface.; 34//; 35// SQlite allows for registering custom VFS modules, which are a set of C callback functions that SQlite invokes when; 36// it needs to read from a file, write to a file, etc. More information is available under https://sqlite.org/vfs.html; 37//; 38// In the context of a data source, SQlite will only ever call reading functions from the VFS module, the sqlite; 39// files are not modified. Therefore, only a subset of the callback functions provide a non-trivial implementation.; 40// The custom VFS module uses a RRawFile for the byte access, thereby it can access local and remote files.; 41 ; 42////////////////////////////////////////////////////////////////////////////; 43/// SQlite VFS modules are identified by string names. The name has to be unique for the entire application.; 44constexpr char const *gSQliteVfsName = ""ROOT-Davix-readonly"";; 45 ; 46////////////////////////////////////////////////////////////////////////////; 47/// Holds the state of an open sqlite database. Objects of this struct are created in VfsRdOnlyOpen(); 48/// and then passed by sqlite to the file I/O callbacks (read, close, etc.). This uses C style inheritance; 49/// where the struct starts with a sqlite3_file member (base class) which is extended by members related to; 50/// this particular VFS module. Every callback here thus casts the sqlite3_file input parameter to its ""derived""; 51/// type VfsRootFile.; 52struct VfsRootFile {; 53 VfsRootFile() = default;; 54 ; 55 sqlite3_file pFile;; 56 std::unique_ptr<ROOT::Internal::RRawFile> fR",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:5204,Security,access,access,5204,"///////////////////////; 88/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 89int VfsRdOnlyTruncate(sqlite3_file * /*pFile*/, sqlite_int64 /*size*/); 90{; 91 return SQLITE_OPEN_READONLY;; 92}; 93 ; 94////////////////////////////////////////////////////////////////////////////; 95/// As the database is read-only, syncing data to disc is a no-op and always succeeds; 96int VfsRdOnlySync(sqlite3_file * /*pFile*/, int /*flags*/); 97{; 98 return SQLITE_OK;; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////; 102/// Returns the cached file size; 103int VfsRdOnlyFileSize(sqlite3_file *pFile, sqlite_int64 *pSize); 104{; 105 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 106 *pSize = p->fRawFile->GetSize();; 107 return SQLITE_OK;; 108}; 109 ; 110////////////////////////////////////////////////////////////////////////////; 111/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 112int VfsRdOnlyLock(sqlite3_file * /*pFile*/, int /*level*/); 113{; 114 return SQLITE_OK;; 115}; 116 ; 117////////////////////////////////////////////////////////////////////////////; 118/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 119int VfsRdOnlyUnlock(sqlite3_file * /*pFile*/, int /*level*/); 120{; 121 return SQLITE_OK;; 122}; 123 ; 124////////////////////////////////////////////////////////////////////////////; 125/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 126int VfsRdOnlyCheckReservedLock(sqlite3_file * /*pFile*/, int *pResOut); 127{; 128 *pResOut = 0;; 129 return SQLITE_OK;; 130}; 131 ; 132////////////////////////////////////////////////////////////////////////////; 133/// As the database is read-only, we know there are no additional control files such as a database journal; 134int VfsRdOnlyFileControl(sqlite3_file * /*p*/, int /*op*/, void * /*p",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:5486,Security,access,access,5486,"//////////////////////////////////////////////////////////; 95/// As the database is read-only, syncing data to disc is a no-op and always succeeds; 96int VfsRdOnlySync(sqlite3_file * /*pFile*/, int /*flags*/); 97{; 98 return SQLITE_OK;; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////; 102/// Returns the cached file size; 103int VfsRdOnlyFileSize(sqlite3_file *pFile, sqlite_int64 *pSize); 104{; 105 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 106 *pSize = p->fRawFile->GetSize();; 107 return SQLITE_OK;; 108}; 109 ; 110////////////////////////////////////////////////////////////////////////////; 111/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 112int VfsRdOnlyLock(sqlite3_file * /*pFile*/, int /*level*/); 113{; 114 return SQLITE_OK;; 115}; 116 ; 117////////////////////////////////////////////////////////////////////////////; 118/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 119int VfsRdOnlyUnlock(sqlite3_file * /*pFile*/, int /*level*/); 120{; 121 return SQLITE_OK;; 122}; 123 ; 124////////////////////////////////////////////////////////////////////////////; 125/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 126int VfsRdOnlyCheckReservedLock(sqlite3_file * /*pFile*/, int *pResOut); 127{; 128 *pResOut = 0;; 129 return SQLITE_OK;; 130}; 131 ; 132////////////////////////////////////////////////////////////////////////////; 133/// As the database is read-only, we know there are no additional control files such as a database journal; 134int VfsRdOnlyFileControl(sqlite3_file * /*p*/, int /*op*/, void * /*pArg*/); 135{; 136 return SQLITE_NOTFOUND;; 137}; 138 ; 139////////////////////////////////////////////////////////////////////////////; 140/// The database device's sector size is only needed for writing; 141int VfsRdOnlySectorSize(sqlite3_file * /*pFile*/); 142{; 143 return SQLITE",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:5770,Security,access,access,5770,"////////////////////////////////////////////; 102/// Returns the cached file size; 103int VfsRdOnlyFileSize(sqlite3_file *pFile, sqlite_int64 *pSize); 104{; 105 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 106 *pSize = p->fRawFile->GetSize();; 107 return SQLITE_OK;; 108}; 109 ; 110////////////////////////////////////////////////////////////////////////////; 111/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 112int VfsRdOnlyLock(sqlite3_file * /*pFile*/, int /*level*/); 113{; 114 return SQLITE_OK;; 115}; 116 ; 117////////////////////////////////////////////////////////////////////////////; 118/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 119int VfsRdOnlyUnlock(sqlite3_file * /*pFile*/, int /*level*/); 120{; 121 return SQLITE_OK;; 122}; 123 ; 124////////////////////////////////////////////////////////////////////////////; 125/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 126int VfsRdOnlyCheckReservedLock(sqlite3_file * /*pFile*/, int *pResOut); 127{; 128 *pResOut = 0;; 129 return SQLITE_OK;; 130}; 131 ; 132////////////////////////////////////////////////////////////////////////////; 133/// As the database is read-only, we know there are no additional control files such as a database journal; 134int VfsRdOnlyFileControl(sqlite3_file * /*p*/, int /*op*/, void * /*pArg*/); 135{; 136 return SQLITE_NOTFOUND;; 137}; 138 ; 139////////////////////////////////////////////////////////////////////////////; 140/// The database device's sector size is only needed for writing; 141int VfsRdOnlySectorSize(sqlite3_file * /*pFile*/); 142{; 143 return SQLITE_OPEN_READONLY;; 144}; 145 ; 146////////////////////////////////////////////////////////////////////////////; 147/// The database device's properties are only needed for writing; 148int VfsRdOnlyDeviceCharacteristics(sqlite3_file * /*pFile*/); 149{; 150 return SQLITE_OPEN_READONLY;; ",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:9809,Security,access,access,9809,,MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:9285,Testability,log,logic,9285,"ile structure has been already allocated by sqlite, so we use placement new; 183 VfsRootFile *p = new (pFile) VfsRootFile();; 184 p->pFile.pMethods = nullptr;; 185 ; 186 // This global struct contains the function pointers to all the callback operations that act on an open database.; 187 // It is passed via the pFile struct back to sqlite so that it can call back to the functions provided above.; 188 static const sqlite3_io_methods io_methods = GetSqlite3IoMethods();; 189 ; 190 if (flags & (SQLITE_OPEN_READWRITE | SQLITE_OPEN_DELETEONCLOSE | SQLITE_OPEN_EXCLUSIVE)); 191 return SQLITE_IOERR;; 192 ; 193 p->fRawFile = ROOT::Internal::RRawFile::Create(zName);; 194 if (!p->fRawFile) {; 195 ::Error(""VfsRdOnlyOpen"", ""Cannot open %s\n"", zName);; 196 return SQLITE_IOERR;; 197 }; 198 ; 199 p->pFile.pMethods = &io_methods;; 200 return SQLITE_OK;; 201}; 202 ; 203// The following callbacks implement operating system specific functionality. In contrast to the previous callbacks,; 204// there is no need to implement any customized logic for the following ones. An implementation has to be; 205// provided nevertheless to have a fully functional VFS module.; 206 ; 207////////////////////////////////////////////////////////////////////////////; 208/// This VFS module cannot remove files; 209int VfsRdOnlyDelete(sqlite3_vfs * /*vfs*/, const char * /*zName*/, int /*syncDir*/); 210{; 211 return SQLITE_IOERR_DELETE;; 212}; 213 ; 214////////////////////////////////////////////////////////////////////////////; 215/// Access control always allows read-only access to databases; 216int VfsRdOnlyAccess(sqlite3_vfs * /*vfs*/, const char * /*zPath*/, int flags, int *pResOut); 217{; 218 *pResOut = 0;; 219 if (flags == SQLITE_ACCESS_READWRITE) {; 220 return SQLITE_OPEN_READONLY;; 221 }; 222 return SQLITE_OK;; 223}; 224 ; 225////////////////////////////////////////////////////////////////////////////; 226/// No distinction between relative and full paths for URLs, returns the input path name; 227int V",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:22982,Testability,assert,assert,22982,"RSqliteDS::Initialize(); 522{; 523 fNRow = 0;; 524 int retval = sqlite3_reset(fDataSet->fQuery);; 525 if (retval != SQLITE_OK); 526 throw std::runtime_error(""SQlite error, reset"");; 527}; 528 ; 529std::string RSqliteDS::GetLabel(); 530{; 531 return ""RSqliteDS"";; 532}; 533 ; 534////////////////////////////////////////////////////////////////////////////////////////////////; 535/// \brief Factory method to create a SQlite RDataFrame.; 536/// \param[in] fileName Path of the sqlite file.; 537/// \param[in] query SQL query that defines the data set.; 538RDataFrame FromSqlite(std::string_view fileName, std::string_view query); 539{; 540 ROOT::RDataFrame rdf(std::make_unique<RSqliteDS>(std::string(fileName), std::string(query)));; 541 return rdf;; 542}; 543 ; 544////////////////////////////////////////////////////////////////////////////; 545/// Stores the result of the current active sqlite query row as a C++ value.; 546bool RSqliteDS::SetEntry(unsigned int /* slot */, ULong64_t entry); 547{; 548 assert(entry + 1 == fNRow);; 549 (void)entry;; 550 unsigned N = fValues.size();; 551 for (unsigned i = 0; i < N; ++i) {; 552 if (!fValues[i].fIsActive); 553 continue;; 554 ; 555 int nbytes;; 556 switch (fValues[i].fType) {; 557 case ETypes::kInteger: fValues[i].fInteger = sqlite3_column_int64(fDataSet->fQuery, i); break;; 558 case ETypes::kReal: fValues[i].fReal = sqlite3_column_double(fDataSet->fQuery, i); break;; 559 case ETypes::kText:; 560 nbytes = sqlite3_column_bytes(fDataSet->fQuery, i);; 561 if (nbytes == 0) {; 562 fValues[i].fText = """";; 563 } else {; 564 fValues[i].fText = reinterpret_cast<const char *>(sqlite3_column_text(fDataSet->fQuery, i));; 565 }; 566 break;; 567 case ETypes::kBlob:; 568 nbytes = sqlite3_column_bytes(fDataSet->fQuery, i);; 569 fValues[i].fBlob.resize(nbytes);; 570 if (nbytes > 0) {; 571 std::memcpy(fValues[i].fBlob.data(), sqlite3_column_blob(fDataSet->fQuery, i), nbytes);; 572 }; 573 break;; 574 case ETypes::kNull: break;; 575 default: throw std::",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:3953,Usability,simpl,simply,3953,"e; 60 ; 61////////////////////////////////////////////////////////////////////////////; 62/// Releases the resources associated to a file opened with davix; 63int VfsRdOnlyClose(sqlite3_file *pFile); 64{; 65 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 66 // We can't use delete because the storage for p is managed by sqlite; 67 p->~VfsRootFile();; 68 return SQLITE_OK;; 69}; 70 ; 71////////////////////////////////////////////////////////////////////////////; 72/// Issues a byte range request for a chunk to the raw file; 73int VfsRdOnlyRead(sqlite3_file *pFile, void *zBuf, int count, sqlite_int64 offset); 74{; 75 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 76 auto nbytes = p->fRawFile->ReadAt(zBuf, count, offset);; 77 return (nbytes != static_cast<unsigned int>(count)) ? SQLITE_IOERR : SQLITE_OK;; 78}; 79 ; 80////////////////////////////////////////////////////////////////////////////; 81/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 82int VfsRdOnlyWrite(sqlite3_file * /*pFile*/, const void * /*zBuf*/, int /*iAmt*/, sqlite_int64 /*iOfst*/); 83{; 84 return SQLITE_OPEN_READONLY;; 85}; 86 ; 87////////////////////////////////////////////////////////////////////////////; 88/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 89int VfsRdOnlyTruncate(sqlite3_file * /*pFile*/, sqlite_int64 /*size*/); 90{; 91 return SQLITE_OPEN_READONLY;; 92}; 93 ; 94////////////////////////////////////////////////////////////////////////////; 95/// As the database is read-only, syncing data to disc is a no-op and always succeeds; 96int VfsRdOnlySync(sqlite3_file * /*pFile*/, int /*flags*/); 97{; 98 return SQLITE_OK;; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////; 102/// Returns the cached file size; 103int VfsRdOnlyFileSize(sqlite3_file *pFile, sqlite_int64 *pSize); 104{; 105 VfsRootFile *p = reinte",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RSqliteDS_8cxx_source.html:4305,Usability,simpl,simply,4305,"otFile();; 68 return SQLITE_OK;; 69}; 70 ; 71////////////////////////////////////////////////////////////////////////////; 72/// Issues a byte range request for a chunk to the raw file; 73int VfsRdOnlyRead(sqlite3_file *pFile, void *zBuf, int count, sqlite_int64 offset); 74{; 75 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 76 auto nbytes = p->fRawFile->ReadAt(zBuf, count, offset);; 77 return (nbytes != static_cast<unsigned int>(count)) ? SQLITE_IOERR : SQLITE_OK;; 78}; 79 ; 80////////////////////////////////////////////////////////////////////////////; 81/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 82int VfsRdOnlyWrite(sqlite3_file * /*pFile*/, const void * /*zBuf*/, int /*iAmt*/, sqlite_int64 /*iOfst*/); 83{; 84 return SQLITE_OPEN_READONLY;; 85}; 86 ; 87////////////////////////////////////////////////////////////////////////////; 88/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 89int VfsRdOnlyTruncate(sqlite3_file * /*pFile*/, sqlite_int64 /*size*/); 90{; 91 return SQLITE_OPEN_READONLY;; 92}; 93 ; 94////////////////////////////////////////////////////////////////////////////; 95/// As the database is read-only, syncing data to disc is a no-op and always succeeds; 96int VfsRdOnlySync(sqlite3_file * /*pFile*/, int /*flags*/); 97{; 98 return SQLITE_OK;; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////; 102/// Returns the cached file size; 103int VfsRdOnlyFileSize(sqlite3_file *pFile, sqlite_int64 *pSize); 104{; 105 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 106 *pSize = p->fRawFile->GetSize();; 107 return SQLITE_OK;; 108}; 109 ; 110////////////////////////////////////////////////////////////////////////////; 111/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 112int VfsRdOnlyLock(sqlite3_file * /*pFile*/, int /*level*/); 113",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
https://root.cern/doc/master/RtypesCore_8h.html:272,Integrability,depend,dependency,272,". ROOT: core/foundation/inc/RtypesCore.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Typedefs |; Variables ; RtypesCore.h File Reference. #include <ROOT/RConfig.hxx>; #include ""DllImport.h""; #include <cstddef>. Include dependency graph for RtypesCore.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Typedefs; typedef float Angle_t;  ; typedef double Axis_t;  ; typedef bool Bool_t;  ; typedef unsigned char Byte_t;  ; typedef char Char_t;  ; typedef short Color_t;  ; typedef double Coord_t;  ; typedef double Double32_t;  ; typedef double Double_t;  ; typedef float Float16_t;  ; typedef float Float_t;  ; typedef short Font_t;  ; typedef int Int_t;  ; typedef long long Long64_t;  ; typedef long Long_t;  ; typedef long double LongDouble_t;  ; typedef long Longptr_t;  ; typedef short Marker_t;  ; typedef const char Option_t;  ; typedef float Real_t;  ; typedef short SCoord_t;  ; typedef int Seek_t;  ; typedef short Short_t;  ; typedef float Size_t;  ; typedef int Ssiz_t;  ; typedef double Stat_t;  ; typedef short Style_t;  ; typedef char Text_t;  ; typedef unsigned char UChar_t;  ; typedef unsigned int UInt_t;  ; typedef unsigned long long ULong64_t;  ; typedef unsigned long ULong_t;  ; typedef unsigned long ULongptr_t;  ; typedef unsigned short UShort_t;  ; typedef short Version_t;  ; typedef short Width_t;  . Variables; Int_t gDebug;  ; constexpr ULong_t kBitsPerByte = 8;  ; constexpr Bool_t kFALSE = false;  ; constexpr Int_t kMaxChar = kMaxUChar >> 1;  ; constexpr Int_t kMaxInt = Int_t(kMaxUInt >> 1);  ; constexpr Long_t kMaxLong = Long_t(kMaxULong >> 1);  ; constexpr Long64_t kMaxLong64 = Long64_t(kMaxULong64 >> 1);  ; constexpr Int_t kMaxShort = kMaxUShort >> 1;  ; constexpr Int_t kMaxUChar = 256;  ; constexpr UInt_t kMaxUI",MatchSource.WIKI,doc/master/RtypesCore_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RtypesCore_8h.html
https://root.cern/doc/master/RtypesCore_8h_source.html:1897,Modifiability,portab,portable,1897,; 32 ; 33class TRootIOCtor;; 34 ; 35//---- types -------------------------------------------------------------------; 36 ; 37typedef char Char_t; //Signed Character 1 byte (char); 38typedef unsigned char UChar_t; //Unsigned Character 1 byte (unsigned char); 39typedef short Short_t; //Signed Short integer 2 bytes (short); 40typedef unsigned short UShort_t; //Unsigned Short integer 2 bytes (unsigned short); 41#ifdef R__INT16; 42typedef long Int_t; //Signed integer 4 bytes; 43typedef unsigned long UInt_t; //Unsigned integer 4 bytes; 44#else; 45typedef int Int_t; //Signed integer 4 bytes (int); 46typedef unsigned int UInt_t; //Unsigned integer 4 bytes (unsigned int); 47#endif; 48#ifdef R__B64 // Note: Long_t and ULong_t are currently not portable types; 49typedef int Seek_t; //File pointer (int); 50typedef long Long_t; //Signed long integer,MatchSource.WIKI,doc/master/RtypesCore_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RtypesCore_8h_source.html
https://root.cern/doc/master/Rtypes_8h.html:1778,Availability,redundant,redundant,1778," not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  ROOT::Internal::ClassDefGenerateInitInstanceLocalInjector< T >;  ; class  ROOT::Internal::TCDGIILIBase;  ; class  ROOT::Internal::TDefaultInitBehavior;  ; struct  ROOT::Internal::THashConsistencyHolder< T >;  ; class  ROOT::Internal::TInitBehavior;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define _ClassDefBase_(name, id, virtual_keyword, overrd);  Common part being called both by _ClassDefOutline_ and _ClassDefInline_. ;  ; #define _ClassDefInline_(name, id, virtual_keyword, overrd);  ; #define _ClassDefOutline_(name, id, virtual_keyword, overrd);  ; #define BIT(n)   (1ULL << (n));  ; #define ClassDef(name, id);  ; #define ClassDef2T2(name, Tmpl1, Tmpl2);  ; #define ClassDef3T2(name, Tmpl1, Tmpl2, Tmpl3);  ; #define ClassDefInline(name, id);  ; #define ClassDefInlineNV(name, id);  ; #define ClassDefInlineOverride(name, id);  ; #define ClassDefNV(name, id);  ; #define ClassDefOverride(name, id);  ; #define ClassDefT(name, id);  This ClassDefT is strictly redundant and is kept only for backward compatibility. ;  ; #define ClassDefT2(name, Tmpl);  ; #define ClassDefTNV(name, id);  ; #define ClassImp(name)   ClassImpUnique(name,default);  ; #define ClassImp2T(name, Tmpl1, Tmpl2)   templateClassImp(name);  ; #define ClassImp3T(name, Tmpl1, Tmpl2, Tmpl3)   templateClassImp(name);  ; #define ClassImpT(name, Tmpl)   templateClassImp(name);  ; #define ClassImpUnique(name, key);  ; #define CLRBIT(n, i)   ((n) &= ~BIT(i));  ; #define NamespaceImp(name)   NamespaceImpUnique(name,default);  ; #define NamespaceImpUnique(name, key);  Macro for Namespace. ;  ; #define R__ADD_INCLUDE_PATH(PATH);  ; #define R__ADD_LIBRARY_PATH(PATH);  ; #define R__CLING_PTRCHECK(ONOFF);  ; #define R__LOAD_LIBRARY(LIBRARY);  ; #",MatchSource.WIKI,doc/master/Rtypes_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h.html
https://root.cern/doc/master/Rtypes_8h.html:14747,Availability,redundant,redundant,14747,"62 of file Rtypes.h. ◆ ClassDefInlineOverride. #define ClassDefInlineOverride; (;  ; name, .  ; id . ). Value: _ClassDefInline_(name,id,,override) \; /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */. Definition at line 358 of file Rtypes.h. ◆ ClassDefNV. #define ClassDefNV; (;  ; name, .  ; id . ). Value: _ClassDefOutline_(name,id,,) \; /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */. Definition at line 350 of file Rtypes.h. ◆ ClassDefOverride. #define ClassDefOverride; (;  ; name, .  ; id . ). Value: _ClassDefOutline_(name,id,,override) \; /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */. Definition at line 346 of file Rtypes.h. ◆ ClassDefT. #define ClassDefT; (;  ; name, .  ; id . ). Value: _ClassDefOutline_(name,id,virtual,) \; /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */. This ClassDefT is strictly redundant and is kept only for backward compatibility. ; Deprecated:; Definition at line 409 of file Rtypes.h. ◆ ClassDefT2. #define ClassDefT2; (;  ; name, .  ; Tmpl . ). Definition at line 418 of file Rtypes.h. ◆ ClassDefTNV. #define ClassDefTNV; (;  ; name, .  ; id . ). Value: _ClassDefOutline_(name,id,virtual,) \; /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */. Definition at line 413 of file Rtypes.h. ◆ ClassImp. #define ClassImp; (;  ; name);    ClassImpUnique(name,default). Deprecated:; Definition at line 382 of file Rtypes.h. ◆ ClassImp2T. #define ClassImp2T; (;  ; name, .  ; Tmpl1, .  ; Tmpl2 . );    templateClassImp(name). Definition at line 437 of file Rtypes.h. ◆ ClassImp3T. #define ClassImp3T; (;  ; name, .  ; Tmpl1, .  ; Tmpl2, .  ; Tmpl3 . );    templateClassImp(name). Definition at line 446 of file Rtypes.h. ◆ ClassImpT. #define ClassImpT; (;  ; name, .  ; Tmpl . );    templateClassImp(name). Definition at line 429 of file Rtypes.h. ◆ Class",MatchSource.WIKI,doc/master/Rtypes_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h.html
https://root.cern/doc/master/Rtypes_8h.html:6827,Deployability,update,update,6827,"mplementation used by ClassDefInline to avoid requirement to include TBuffer.h. ;  ; const TInitBehavior * ROOT::Internal::DefineBehavior (void *, void *);  ; Bool_t ROOT::Internal::HasConsistentHashMember (const char *clName);  Return true is the Hash/RecursiveRemove setup is consistent, i.e. ;  ; Bool_t ROOT::Internal::HasConsistentHashMember (TClass &clRef);  Return true is the Hash/RecursiveRemove setup is consistent, i.e. ;  ; template<class Tmpl > ; TBuffer & operator<< (TBuffer &buf, const Tmpl *obj);  ; template<class Tmpl > ; TBuffer & operator>> (TBuffer &buf, Tmpl *&obj);  ; TNamed * ROOT::RegisterClassTemplate (const char *name, const char *file, Int_t line);  Global function to register the implementation file and line of a class template (i.e. ;  ; void ROOT::RemoveClass (const char *cname, TClass *cl);  Global function called by the dtor of a class's init class (see the ClassImp macro). ;  ; void ROOT::RemoveClassAlternate (ROOT::TClassAlt *);  ; void ROOT::ResetClassVersion (TClass *, const char *, Short_t);  Global function to update the version number. ;  ; template<class RootClass > ; Short_t ROOT::SetClassVersion (RootClass *);  . Macro Definition Documentation. ◆ _ClassDefBase_. #define _ClassDefBase_; (;  ; name, .  ; id, .  ; virtual_keyword, .  ; overrd . ). Value:private: \; static_assert(std::is_integral<decltype(id)>::value, \; ""ClassDef(Inline) macro: the specified class version number is not an integer.""); \; /** \cond HIDDEN_SYMBOLS */ virtual_keyword Bool_t CheckTObjectHashConsistency() const overrd \; { \; static std::atomic<UChar_t> recurseBlocker(0); \; if (R__likely(recurseBlocker >= 2)) { \; return ::ROOT::Internal::THashConsistencyHolder<decltype(*this)>::fgHashConsistency; \; } else if (recurseBlocker == 1) { \; return false; \; } else if (recurseBlocker++ == 0) { \; ::ROOT::Internal::THashConsistencyHolder<decltype(*this)>::fgHashConsistency = \; ::ROOT::Internal::HasConsistentHashMember(_QUOTE_(name)) || \; ::ROOT::Internal::H",MatchSource.WIKI,doc/master/Rtypes_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h.html
https://root.cern/doc/master/Rtypes_8h.html:485,Integrability,depend,dependency,485,". ROOT: core/base/inc/Rtypes.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Macros |; Typedefs |; Enumerations |; Functions ; Rtypes.h File Reference. #include ""RtypesCore.h""; #include <cstdio>; #include ""strtok.h""; #include ""strlcpy.h""; #include ""snprintf.h""; #include <type_traits>; #include <typeinfo>; #include <atomic>; #include ""TGenericClassInfo.h""; #include ""TIsAProxy.h""; #include <string>. Include dependency graph for Rtypes.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  ROOT::Internal::ClassDefGenerateInitInstanceLocalInjector< T >;  ; class  ROOT::Internal::TCDGIILIBase;  ; class  ROOT::Internal::TDefaultInitBehavior;  ; struct  ROOT::Internal::THashConsistencyHolder< T >;  ; class  ROOT::Internal::TInitBehavior;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define _ClassDefBase_(name, id, virtual_keyword, overrd);  Common part being called both by _ClassDefOutline_ and _ClassDefInline_. ;  ; #define _ClassDefInline_(name, id, virtual_keyword, overrd);  ; #define _ClassDefOutline_(name, id, virtual_keyword, overrd);  ; #define BIT(n)   (1ULL << (n));  ; #define ClassDef(name, id);  ; #define ClassDef2T2(name, Tmpl1, Tmpl2);  ; #define ClassDef3T2(name, Tmpl1, Tmpl2, Tmpl3);  ; #define ClassDefInline(name, id);  ; #define ClassDefInlineNV(name, id);  ; #define ClassDefInlineOverride(name, id);  ; #define ClassDefNV(name, id);  ; #define ClassDefOverride(name, id);  ; #define ClassDefT(name, id);  This ClassDefT is strictly redundant and is kept only for backward compatibility. ;  ; #define ClassDefT2(name, Tmpl);  ; #define ClassDefTNV(name, id);  ; #define ClassImp(name)   ClassImpUnique(name,default);  ; #define ClassImp2T(name, Tmpl1, Tmpl",MatchSource.WIKI,doc/master/Rtypes_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h.html
https://root.cern/doc/master/Rtypes_8h.html:1778,Safety,redund,redundant,1778," not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  ROOT::Internal::ClassDefGenerateInitInstanceLocalInjector< T >;  ; class  ROOT::Internal::TCDGIILIBase;  ; class  ROOT::Internal::TDefaultInitBehavior;  ; struct  ROOT::Internal::THashConsistencyHolder< T >;  ; class  ROOT::Internal::TInitBehavior;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define _ClassDefBase_(name, id, virtual_keyword, overrd);  Common part being called both by _ClassDefOutline_ and _ClassDefInline_. ;  ; #define _ClassDefInline_(name, id, virtual_keyword, overrd);  ; #define _ClassDefOutline_(name, id, virtual_keyword, overrd);  ; #define BIT(n)   (1ULL << (n));  ; #define ClassDef(name, id);  ; #define ClassDef2T2(name, Tmpl1, Tmpl2);  ; #define ClassDef3T2(name, Tmpl1, Tmpl2, Tmpl3);  ; #define ClassDefInline(name, id);  ; #define ClassDefInlineNV(name, id);  ; #define ClassDefInlineOverride(name, id);  ; #define ClassDefNV(name, id);  ; #define ClassDefOverride(name, id);  ; #define ClassDefT(name, id);  This ClassDefT is strictly redundant and is kept only for backward compatibility. ;  ; #define ClassDefT2(name, Tmpl);  ; #define ClassDefTNV(name, id);  ; #define ClassImp(name)   ClassImpUnique(name,default);  ; #define ClassImp2T(name, Tmpl1, Tmpl2)   templateClassImp(name);  ; #define ClassImp3T(name, Tmpl1, Tmpl2, Tmpl3)   templateClassImp(name);  ; #define ClassImpT(name, Tmpl)   templateClassImp(name);  ; #define ClassImpUnique(name, key);  ; #define CLRBIT(n, i)   ((n) &= ~BIT(i));  ; #define NamespaceImp(name)   NamespaceImpUnique(name,default);  ; #define NamespaceImpUnique(name, key);  Macro for Namespace. ;  ; #define R__ADD_INCLUDE_PATH(PATH);  ; #define R__ADD_LIBRARY_PATH(PATH);  ; #define R__CLING_PTRCHECK(ONOFF);  ; #define R__LOAD_LIBRARY(LIBRARY);  ; #",MatchSource.WIKI,doc/master/Rtypes_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h.html
https://root.cern/doc/master/Rtypes_8h.html:5807,Safety,avoid,avoid,5807,"LEN = 8192; , kBUFFERSIZE = 8192; , kItimerResolution = 10; };  . Functions; void ROOT::AddClass (const char *cname, Version_t id, const std::type_info &info, DictFuncPtr_t dict, Int_t pragmabits);  Global function called by the ctor of a class's init class (see the ClassImp macro). ;  ; ROOT::TClassAlt * ROOT::AddClassAlternate (const char *normName, const char *alternate);  Global function called by GenerateInitInstance. ;  ; void ROOT::Class_ShowMembers (TClass *cl, const void *obj, TMemberInspector &);  Indirect call to the implementation of ShowMember allowing [forward] declaration with out a full definition of the TClass class. ;  ; TClass * ROOT::CreateClass (const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; void ROOT::Internal::DefaultStreamer (TBuffer &R__b, const TClass *cl, void *objpointer);  Default streamer implementation used by ClassDefInline to avoid requirement to include TBuffer.h. ;  ; const TInitBehavior * ROOT::Internal::DefineBehavior (void *, void *);  ; Bool_t ROOT::Internal::HasConsistentHashMember (const char *clName);  Return true is the Hash/RecursiveRemove setup is consistent, i.e. ;  ; Bool_t ROOT::Internal::HasConsistentHashMember (TClass &clRef);  Return true is the Hash/RecursiveRemove setup is consistent, i.e. ;  ; template<class Tmpl > ; TBuffer & operator<< (TBuffer &buf, const Tmpl *obj);  ; template<class Tmpl > ; TBuffer & operator>> (TBuffer &buf, Tmpl *&obj);  ; TNamed * ROOT::RegisterClassTemplate (const char *name, const char *file, Int_t line);  Global function to register the implementation file and line of a class template (i.e. ;  ; void ROOT::RemoveClass (const char *cname, TClass *cl);  Global function called by the dtor of a class's init class (see the ClassImp macro). ;  ; void ROOT::RemoveClassAlternate (ROOT::TClassAlt *);  ; void ",MatchSource.WIKI,doc/master/Rtypes_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h.html
https://root.cern/doc/master/Rtypes_8h.html:14747,Safety,redund,redundant,14747,"62 of file Rtypes.h. ◆ ClassDefInlineOverride. #define ClassDefInlineOverride; (;  ; name, .  ; id . ). Value: _ClassDefInline_(name,id,,override) \; /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */. Definition at line 358 of file Rtypes.h. ◆ ClassDefNV. #define ClassDefNV; (;  ; name, .  ; id . ). Value: _ClassDefOutline_(name,id,,) \; /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */. Definition at line 350 of file Rtypes.h. ◆ ClassDefOverride. #define ClassDefOverride; (;  ; name, .  ; id . ). Value: _ClassDefOutline_(name,id,,override) \; /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */. Definition at line 346 of file Rtypes.h. ◆ ClassDefT. #define ClassDefT; (;  ; name, .  ; id . ). Value: _ClassDefOutline_(name,id,virtual,) \; /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */. This ClassDefT is strictly redundant and is kept only for backward compatibility. ; Deprecated:; Definition at line 409 of file Rtypes.h. ◆ ClassDefT2. #define ClassDefT2; (;  ; name, .  ; Tmpl . ). Definition at line 418 of file Rtypes.h. ◆ ClassDefTNV. #define ClassDefTNV; (;  ; name, .  ; id . ). Value: _ClassDefOutline_(name,id,virtual,) \; /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */. Definition at line 413 of file Rtypes.h. ◆ ClassImp. #define ClassImp; (;  ; name);    ClassImpUnique(name,default). Deprecated:; Definition at line 382 of file Rtypes.h. ◆ ClassImp2T. #define ClassImp2T; (;  ; name, .  ; Tmpl1, .  ; Tmpl2 . );    templateClassImp(name). Definition at line 437 of file Rtypes.h. ◆ ClassImp3T. #define ClassImp3T; (;  ; name, .  ; Tmpl1, .  ; Tmpl2, .  ; Tmpl3 . );    templateClassImp(name). Definition at line 446 of file Rtypes.h. ◆ ClassImpT. #define ClassImpT; (;  ; name, .  ; Tmpl . );    templateClassImp(name). Definition at line 429 of file Rtypes.h. ◆ Class",MatchSource.WIKI,doc/master/Rtypes_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h.html
https://root.cern/doc/master/Rtypes_8h.html:9840,Security,access,accessing,9840," idOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize idDefinition TGWin32VirtualXProxy.cxx:94; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; StreamerNVirtualvoid StreamerNVirtual(TBuffer &ClassDef_StreamerNVirtual_b)Definition TStringLong.h:20; Class_Versionstatic constexpr Version_t Class_Version()Definition TStringLong.h:20; IsATClass * IsA() const overrideDefinition TStringLong.h:20; DeclFileNamestatic const char * DeclFileName()Definition TStringLong.h:20; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; ROOT::Internal::THashConsistencyHolderDefinition Rtypes.h:260. Common part being called both by _ClassDefOutline_ and _ClassDefInline_. ; NoteDeclFileLine() is not part of it, since Cling uses that as trigger for associating as class title the comment string found right after the macro. ; Definition at line 276 of file Rtypes.h. ◆ _ClassDefInline_. #define _ClassDefInline_; (;  ; name, .  ; id, .  ; virtual_keyword, .  ; overrd . ). Value: _ClassDefBase_(name, id, virtual_keyword, overrd) public : \; /** \cond HIDDEN_SYMBOLS \deprecated */ static int ImplFileLine() { return -1; } /** \endcond */ \; /** \cond HIDDEN_SYMBOLS \deprecated */ static const char *ImplFileName() { return nullptr; } /** \endcond */\; /** \return Name of this class */ static const char *Class_Name() \; { \; return ::ROOT::Internal::ClassDefGenerateInitInstanceLocalInjector<name>::Name(); \; } \; /** \cond HIDDEN_SYMBOLS */ static TClass ",MatchSource.WIKI,doc/master/Rtypes_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h.html
https://root.cern/doc/master/Rtypes_8h_source.html:17598,Availability,redundant,redundant,17598," __LINE__; } /** \endcond */; 357 ; 358#define ClassDefInlineOverride(name,id) \; 359 _ClassDefInline_(name,id,,override) \; 360 /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */; 361 ; 362#define ClassDefInlineNV(name,id) \; 363 _ClassDefInline_(name,id,,) \; 364 /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */; 365 ; 366//#define _ClassDefInterp_(name,id) ClassDefInline(name,id); 367 ; 368#define R__UseDummy(name) \; 369 class _NAME2_(name,_c) { public: _NAME2_(name,_c)() { if (name) { } } }; 370 ; 371#define ClassImpUnique(name,key) \; 372 namespace ROOT { \; 373 /** \cond HIDDEN_SYMBOLS */ TGenericClassInfo *GenerateInitInstance(const name*); /** \endcond */ \; 374 namespace { \; 375 static int _R__UNIQUE_(_NAME2_(R__dummyint,key)) __attribute__((unused)) = \; 376 GenerateInitInstance((name*)0x0)->SetImplFile(__FILE__, __LINE__); \; 377 R__UseDummy(_R__UNIQUE_(_NAME2_(R__dummyint,key))); \; 378 } \; 379 }; 380 ; 381/// \deprecated; 382#define ClassImp(name) ClassImpUnique(name,default); 383 ; 384/// Macro for Namespace; 385#define NamespaceImpUnique(name,key) \; 386 namespace name { \; 387 namespace ROOTDict { \; 388 /** \cond HIDDEN_SYMBOLS */ \; 389 ::ROOT::TGenericClassInfo *GenerateInitInstance(); /** \endcond */ \; 390 namespace { \; 391 static int _R__UNIQUE_(_NAME2_(R__dummyint,key)) = \; 392 GenerateInitInstance()->SetImplFile(__FILE__, __LINE__); \; 393 R__UseDummy(_R__UNIQUE_(_NAME2_(R__dummyint,key))); \; 394 } \; 395 } \; 396 }; 397 ; 398#define NamespaceImp(name) NamespaceImpUnique(name,default); 399 ; 400//---- ClassDefT macros for templates with one template argument ---------------; 401// ClassDefT corresponds to ClassDef; 402// ClassDefT2 goes in the same header as ClassDefT but must be; 403// outside the class scope; 404// ClassImpT corresponds to ClassImp; 405 ; 406 ; 407/// This ClassDefT is strictly redundant and is kept only for; 408/// backward compatibility.",MatchSource.WIKI,doc/master/Rtypes_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html
https://root.cern/doc/master/Rtypes_8h_source.html:20411,Availability,error,errors,20411," 430 ; 431//---- ClassDefT macros for templates with two template arguments --------------; 432// ClassDef2T2 goes in the same header as ClassDefT but must be; 433// outside the class scope; 434// ClassImp2T corresponds to ClassImpT; 435 ; 436#define ClassDef2T2(name,Tmpl1,Tmpl2); 437#define ClassImp2T(name,Tmpl1,Tmpl2) templateClassImp(name); 438 ; 439 ; 440//---- ClassDefT macros for templates with three template arguments ------------; 441// ClassDef3T2 goes in the same header as ClassDefT but must be; 442// outside the class scope; 443// ClassImp3T corresponds to ClassImpT; 444 ; 445#define ClassDef3T2(name,Tmpl1,Tmpl2,Tmpl3); 446#define ClassImp3T(name,Tmpl1,Tmpl2,Tmpl3) templateClassImp(name); 447 ; 448 ; 449//---- Macro to set the class version of non instrumented classes --------------; 450 ; 451#define RootClassVersion(name,VersionNumber) \; 452namespace ROOT { /** \cond HIDDEN_SYMBOLS */ \; 453 TGenericClassInfo *GenerateInitInstance(const name*); /** \endcond */ \; 454 /** \cond HIDDEN_SYMBOLS */ \; 455 static Short_t _R__UNIQUE_(R__dummyVersionNumber) = \; 456 GenerateInitInstance((name*)0x0)->SetVersion(VersionNumber); \; 457 /** \endcond */ \; 458 R__UseDummy(_R__UNIQUE_(R__dummyVersionNumber)); \; 459}; 460 ; 461#define RootStreamer(name,STREAMER) \; 462namespace ROOT { \; 463 /** \cond HIDDEN_SYMBOLS */ \; 464 TGenericClassInfo *GenerateInitInstance(const name*); /** \endcond */ \; 465 /** \cond HIDDEN_SYMBOLS */ \; 466 static Short_t _R__UNIQUE_(R__dummyStreamer) = \; 467 GenerateInitInstance((name*)0x0)->SetStreamer(STREAMER); \; 468 /** \endcond */ \; 469 R__UseDummy(_R__UNIQUE_(R__dummyStreamer)); \; 470}; 471 ; 472//---- Macro to load a library into the interpreter --------------; 473// Call as R__LOAD_LIBRARY(libEvent); 474// This macro intentionally does not take string as argument, to; 475// prevent compilation errors with complex diagnostics due to; 476// TString BAD_DO_NOT_TRY = ""lib"";; 477// R__LOAD_LIBRARY(BAD_DO_NOT_TRY + ""BAD_DO_NOT_TRY.",MatchSource.WIKI,doc/master/Rtypes_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html
https://root.cern/doc/master/Rtypes_8h_source.html:33041,Deployability,update,update,33041,"OOT::CreateClassTClass * CreateClass(const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il)Global function called by a class' static Dictionary() method (see the ClassDef macro).Definition TClass.cxx:5936; ROOT::DelFunc_tvoid(* DelFunc_t)(void *)Definition Rtypes.h:116; ROOT::AddClassvoid AddClass(const char *cname, Version_t id, const std::type_info &info, DictFuncPtr_t dict, Int_t pragmabits)Global function called by the ctor of a class's init class (see the ClassImp macro).Definition TClassTable.cxx:896; ROOT::RegisterClassTemplateTNamed * RegisterClassTemplate(const char *name, const char *file, Int_t line)Global function to register the implementation file and line of a class template (i....Definition TClassTable.cxx:1005; ROOT::NewArrFunc_tvoid *(* NewArrFunc_t)(Long_t size, void *arena)Definition Rtypes.h:115; ROOT::Class_ShowMembersvoid Class_ShowMembers(TClass *cl, const void *obj, TMemberInspector &)Indirect call to the implementation of ShowMember allowing [forward] declaration with out a full defi...Definition TClass.cxx:613; ROOT::ResetClassVersionvoid ResetClassVersion(TClass *, const char *, Short_t)Global function to update the version number.Definition TClassTable.cxx:951; ROOT::SetClassVersionShort_t SetClassVersion(RootClass *); ROOT::DelArrFunc_tvoid(* DelArrFunc_t)(void *)Definition Rtypes.h:117; ROOT::NewFunc_tvoid *(* NewFunc_t)(void *)Definition Rtypes.h:114; ROOT::MergeFunc_tLong64_t(* MergeFunc_t)(void *, TCollection *, TFileMergeInfo *)Definition Rtypes.h:120; ROOT::RemoveClassAlternatevoid RemoveClassAlternate(ROOT::TClassAlt *)Definition TClassTable.cxx:931; ROOT::Internal::THashConsistencyHolderDefinition Rtypes.h:260; ROOT::Internal::THashConsistencyHolder::fgHashConsistencystatic Bool_t fgHashConsistencyDefinition Rtypes.h:261. corebaseincRtypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:02 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/Rtypes_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html
https://root.cern/doc/master/Rtypes_8h_source.html:6306,Integrability,interface,interface,6306,"onst char *ifil,; 128 Int_t dl, Int_t il);; 129 extern void AddClass(const char *cname, Version_t id, const std::type_info &info,; 130 DictFuncPtr_t dict, Int_t pragmabits);; 131 extern void RemoveClass(const char *cname, TClass *cl);; 132 extern void ResetClassVersion(TClass*, const char*, Short_t);; 133 extern ROOT::TClassAlt* AddClassAlternate(const char *normName, const char *alternate);; 134 extern void RemoveClassAlternate(ROOT::TClassAlt*);; 135 ; 136 extern TNamed *RegisterClassTemplate(const char *name,; 137 const char *file, Int_t line);; 138 ; 139 extern void Class_ShowMembers(TClass *cl, const void *obj, TMemberInspector&);; 140 ; 141#if 0; 142 // This function is only implemented in the dictionary file.; 143 // The parameter is 'only' for overloading resolution.; 144 // Used to be a template <class T> TGenericClassInfo *GenerateInitInstance(const T*);; 145 template <class T> TGenericClassInfo *GetClassInfo(const T* t) {; 146 TGenericClassInfo *GenerateInitInstance(const T*);; 147 return CreateInitInstance(t);; 148 };; 149#endif; 150 ; 151 namespace Internal {; 152 class TInitBehavior {; 153 // This class defines the interface for the class registration and; 154 // the TClass creation. To modify the default behavior, one would; 155 // inherit from this class and overload ROOT::DefineBehavior().; 156 // See TQObject.h and table/inc/Ttypes.h for examples.; 157 public:; 158 virtual ~TInitBehavior() { }; 159 ; 160 virtual void Register(const char *cname, Version_t id,; 161 const std::type_info &info,; 162 DictFuncPtr_t dict, Int_t pragmabits) const = 0;; 163 virtual void Unregister(const char *classname, TClass *cl) const = 0;; 164 virtual TClass *CreateClass(const char *cname, Version_t id,; 165 const std::type_info &info, TVirtualIsAProxy *isa,; 166 const char *dfil, const char *ifil,; 167 Int_t dl, Int_t il) const = 0;; 168 };; 169 ; 170 class TDefaultInitBehavior: public TInitBehavior {; 171 public:; 172 void Register(const char *cname, Version_t id,; 173",MatchSource.WIKI,doc/master/Rtypes_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html
https://root.cern/doc/master/Rtypes_8h_source.html:21331,Integrability,message,message,21331," \cond HIDDEN_SYMBOLS */ \; 466 static Short_t _R__UNIQUE_(R__dummyStreamer) = \; 467 GenerateInitInstance((name*)0x0)->SetStreamer(STREAMER); \; 468 /** \endcond */ \; 469 R__UseDummy(_R__UNIQUE_(R__dummyStreamer)); \; 470}; 471 ; 472//---- Macro to load a library into the interpreter --------------; 473// Call as R__LOAD_LIBRARY(libEvent); 474// This macro intentionally does not take string as argument, to; 475// prevent compilation errors with complex diagnostics due to; 476// TString BAD_DO_NOT_TRY = ""lib"";; 477// R__LOAD_LIBRARY(BAD_DO_NOT_TRY + ""BAD_DO_NOT_TRY.so"") // ERROR!; 478#ifdef __CLING__; 479# define _R_PragmaStr(x) _Pragma(#x); 480# define R__LOAD_LIBRARY(LIBRARY) _R_PragmaStr(cling load ( #LIBRARY )); 481# define R__ADD_INCLUDE_PATH(PATH) _R_PragmaStr(cling add_include_path ( #PATH )); 482# define R__ADD_LIBRARY_PATH(PATH) _R_PragmaStr(cling add_library_path ( #PATH )); 483#elif defined(R__WIN32); 484# define _R_PragmaStr(x) __pragma(#x); 485# define R__LOAD_LIBRARY(LIBRARY) _R_PragmaStr(comment(lib, #LIBRARY)); 486# define R__ADD_INCLUDE_PATH(PATH) _R_PragmaStr(comment(path, #PATH)); 487# define R__ADD_LIBRARY_PATH(PATH) _R_PragmaStr(comment(path, #PATH)); 488#else; 489// No way to inform linker though preprocessor :-(; 490// We could even inform the user:; 491/*; 492# define R__LOAD_LIBRARY(LIBRARY) \; 493 _R_PragmaStr(message ""Compiler cannot handle linking against "" #LIBRARY \; 494 "". Use -L and -l instead.""); 495*/; 496# define R__LOAD_LIBRARY(LIBRARY); 497# define R__ADD_INCLUDE_PATH(PATH); 498# define R__ADD_LIBRARY_PATH(PATH); 499#endif; 500 ; 501// Convenience macros to disable cling pointer check.; 502#ifdef __CLING__; 503# define R__CLING_PTRCHECK(ONOFF) __attribute__((annotate(""__cling__ptrcheck("" #ONOFF "")""))); 504#else; 505# define R__CLING_PTRCHECK(ONOFF); 506#endif; 507 ; 508#endif; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; RtypesCore.h; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefin",MatchSource.WIKI,doc/master/Rtypes_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html
https://root.cern/doc/master/Rtypes_8h_source.html:30147,Integrability,interface,interface,30147,"cts.Definition TBuffer.h:43; TClassStreamerDefinition TClassStreamer.h:26; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollectionCollection abstract base class.Definition TCollection.h:65; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileMergeInfoDefinition TFileMergeInfo.h:42; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjectMother of all ROOT objects.Definition TObject.h:41; TStringBasic string class.Definition TString.h:139; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualIsAProxyDefinition TVirtualIsAProxy.h:27; bool; int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Internal::DefaultStreamervoid DefaultStreamer(TBuffer &R__b, const TClass *cl, void *objpointer)Default streamer implementation used by ClassDefInline to avoid requirement to include TBuffer....Definition TBuffer.cxx:30; ROOT::Internal::DefineBehaviorconst TInitBehavior * DefineBehavior(void *, void *)Definition TGenericClassInfo.cxx:45; ROOT::Internal::HasConsistentHashMemberBool_t HasConsistentHashMember(TClass &clRef)Return true is the Hash/RecursiveRemove setup is consistent, i.e.Definition TClass.cxx:7438; ROOT::Internal::GetDemangledTypeNamestd::string GetDemangledTypeName(const std::type_info &t)Definition TGenericClassInfo.cxx:31; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExe",MatchSource.WIKI,doc/master/Rtypes_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html
https://root.cern/doc/master/Rtypes_8h_source.html:6426,Modifiability,inherit,inherit,6426,"Class*, const char*, Short_t);; 133 extern ROOT::TClassAlt* AddClassAlternate(const char *normName, const char *alternate);; 134 extern void RemoveClassAlternate(ROOT::TClassAlt*);; 135 ; 136 extern TNamed *RegisterClassTemplate(const char *name,; 137 const char *file, Int_t line);; 138 ; 139 extern void Class_ShowMembers(TClass *cl, const void *obj, TMemberInspector&);; 140 ; 141#if 0; 142 // This function is only implemented in the dictionary file.; 143 // The parameter is 'only' for overloading resolution.; 144 // Used to be a template <class T> TGenericClassInfo *GenerateInitInstance(const T*);; 145 template <class T> TGenericClassInfo *GetClassInfo(const T* t) {; 146 TGenericClassInfo *GenerateInitInstance(const T*);; 147 return CreateInitInstance(t);; 148 };; 149#endif; 150 ; 151 namespace Internal {; 152 class TInitBehavior {; 153 // This class defines the interface for the class registration and; 154 // the TClass creation. To modify the default behavior, one would; 155 // inherit from this class and overload ROOT::DefineBehavior().; 156 // See TQObject.h and table/inc/Ttypes.h for examples.; 157 public:; 158 virtual ~TInitBehavior() { }; 159 ; 160 virtual void Register(const char *cname, Version_t id,; 161 const std::type_info &info,; 162 DictFuncPtr_t dict, Int_t pragmabits) const = 0;; 163 virtual void Unregister(const char *classname, TClass *cl) const = 0;; 164 virtual TClass *CreateClass(const char *cname, Version_t id,; 165 const std::type_info &info, TVirtualIsAProxy *isa,; 166 const char *dfil, const char *ifil,; 167 Int_t dl, Int_t il) const = 0;; 168 };; 169 ; 170 class TDefaultInitBehavior: public TInitBehavior {; 171 public:; 172 void Register(const char *cname, Version_t id,; 173 const std::type_info &info,; 174 DictFuncPtr_t dict, Int_t pragmabits) const override {; 175 ROOT::AddClass(cname, id, info, dict, pragmabits);; 176 }; 177 ; 178 void Unregister(const char *classname, TClass *cl) const override {; 179 ROOT::RemoveClass(classname, cl);; ",MatchSource.WIKI,doc/master/Rtypes_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html
https://root.cern/doc/master/Rtypes_8h_source.html:10023,Performance,load,load,10023,"05namespace ROOT { namespace Internal {; 206 ; 207class TCDGIILIBase {; 208public:; 209 // All implemented in TGenericClassInfo.cxx.; 210 static void SetInstance(::ROOT::TGenericClassInfo& R__instance,; 211 NewFunc_t, NewArrFunc_t, DelFunc_t, DelArrFunc_t, DesFunc_t);; 212 static void SetName(const std::string& name, std::string& nameMember);; 213 static void SetfgIsA(atomic_TClass_ptr& isA, TClass*(*dictfun)());; 214};; 215 ; 216template <typename T>; 217class ClassDefGenerateInitInstanceLocalInjector:; 218 public TCDGIILIBase {; 219 static atomic_TClass_ptr fgIsA;; 220 static ::ROOT::TGenericClassInfo *fgGenericInfo;; 221 public:; 222 static void *New(void *p) { return p ? new(p) T : new T; };; 223 static void *NewArray(Long_t nElements, void *p) {; 224 return p ? new(p) T[nElements] : new T[nElements]; }; 225 static void Delete(void *p) { delete ((T*)p); }; 226 static void DeleteArray(void *p) { delete[] ((T*)p); }; 227 static void Destruct(void *p) { ((T*)p)->~T(); }; 228 static ::ROOT::TGenericClassInfo *GenerateInitInstanceLocal() {; 229 static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy<T>(nullptr);; 230 static ::ROOT::TGenericClassInfo; 231 R__instance(T::Class_Name(), T::Class_Version(),; 232 T::DeclFileName(), T::DeclFileLine(),; 233 typeid(T), ::ROOT::Internal::DefineBehavior((T*)nullptr, (T*)nullptr),; 234 &T::Dictionary, isa_proxy, 0, sizeof(T) );; 235 SetInstance(R__instance, &New, &NewArray, &Delete, &DeleteArray, &Destruct);; 236 return &R__instance;; 237 }; 238 // We need a reference to the template instance static member in a concrete function in order; 239 // to force its instantiation (even before the function is actually run); 240 // Since we do have a reference to Dictionary (in T::Dictionary), using fgGenericInfo; 241 // here will insure that it is initialized at process start or library load time.; 242 static TClass *Dictionary() { fgIsA = fgGenericInfo->GetClass(); return fgIsA; }; 243 static TClass *Class() { SetfgIsA(fgIsA,",MatchSource.WIKI,doc/master/Rtypes_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html
https://root.cern/doc/master/Rtypes_8h_source.html:20223,Performance,load,load,20223," 430 ; 431//---- ClassDefT macros for templates with two template arguments --------------; 432// ClassDef2T2 goes in the same header as ClassDefT but must be; 433// outside the class scope; 434// ClassImp2T corresponds to ClassImpT; 435 ; 436#define ClassDef2T2(name,Tmpl1,Tmpl2); 437#define ClassImp2T(name,Tmpl1,Tmpl2) templateClassImp(name); 438 ; 439 ; 440//---- ClassDefT macros for templates with three template arguments ------------; 441// ClassDef3T2 goes in the same header as ClassDefT but must be; 442// outside the class scope; 443// ClassImp3T corresponds to ClassImpT; 444 ; 445#define ClassDef3T2(name,Tmpl1,Tmpl2,Tmpl3); 446#define ClassImp3T(name,Tmpl1,Tmpl2,Tmpl3) templateClassImp(name); 447 ; 448 ; 449//---- Macro to set the class version of non instrumented classes --------------; 450 ; 451#define RootClassVersion(name,VersionNumber) \; 452namespace ROOT { /** \cond HIDDEN_SYMBOLS */ \; 453 TGenericClassInfo *GenerateInitInstance(const name*); /** \endcond */ \; 454 /** \cond HIDDEN_SYMBOLS */ \; 455 static Short_t _R__UNIQUE_(R__dummyVersionNumber) = \; 456 GenerateInitInstance((name*)0x0)->SetVersion(VersionNumber); \; 457 /** \endcond */ \; 458 R__UseDummy(_R__UNIQUE_(R__dummyVersionNumber)); \; 459}; 460 ; 461#define RootStreamer(name,STREAMER) \; 462namespace ROOT { \; 463 /** \cond HIDDEN_SYMBOLS */ \; 464 TGenericClassInfo *GenerateInitInstance(const name*); /** \endcond */ \; 465 /** \cond HIDDEN_SYMBOLS */ \; 466 static Short_t _R__UNIQUE_(R__dummyStreamer) = \; 467 GenerateInitInstance((name*)0x0)->SetStreamer(STREAMER); \; 468 /** \endcond */ \; 469 R__UseDummy(_R__UNIQUE_(R__dummyStreamer)); \; 470}; 471 ; 472//---- Macro to load a library into the interpreter --------------; 473// Call as R__LOAD_LIBRARY(libEvent); 474// This macro intentionally does not take string as argument, to; 475// prevent compilation errors with complex diagnostics due to; 476// TString BAD_DO_NOT_TRY = ""lib"";; 477// R__LOAD_LIBRARY(BAD_DO_NOT_TRY + ""BAD_DO_NOT_TRY.",MatchSource.WIKI,doc/master/Rtypes_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html
https://root.cern/doc/master/Rtypes_8h_source.html:20679,Performance,load,load,20679," \cond HIDDEN_SYMBOLS */ \; 466 static Short_t _R__UNIQUE_(R__dummyStreamer) = \; 467 GenerateInitInstance((name*)0x0)->SetStreamer(STREAMER); \; 468 /** \endcond */ \; 469 R__UseDummy(_R__UNIQUE_(R__dummyStreamer)); \; 470}; 471 ; 472//---- Macro to load a library into the interpreter --------------; 473// Call as R__LOAD_LIBRARY(libEvent); 474// This macro intentionally does not take string as argument, to; 475// prevent compilation errors with complex diagnostics due to; 476// TString BAD_DO_NOT_TRY = ""lib"";; 477// R__LOAD_LIBRARY(BAD_DO_NOT_TRY + ""BAD_DO_NOT_TRY.so"") // ERROR!; 478#ifdef __CLING__; 479# define _R_PragmaStr(x) _Pragma(#x); 480# define R__LOAD_LIBRARY(LIBRARY) _R_PragmaStr(cling load ( #LIBRARY )); 481# define R__ADD_INCLUDE_PATH(PATH) _R_PragmaStr(cling add_include_path ( #PATH )); 482# define R__ADD_LIBRARY_PATH(PATH) _R_PragmaStr(cling add_library_path ( #PATH )); 483#elif defined(R__WIN32); 484# define _R_PragmaStr(x) __pragma(#x); 485# define R__LOAD_LIBRARY(LIBRARY) _R_PragmaStr(comment(lib, #LIBRARY)); 486# define R__ADD_INCLUDE_PATH(PATH) _R_PragmaStr(comment(path, #PATH)); 487# define R__ADD_LIBRARY_PATH(PATH) _R_PragmaStr(comment(path, #PATH)); 488#else; 489// No way to inform linker though preprocessor :-(; 490// We could even inform the user:; 491/*; 492# define R__LOAD_LIBRARY(LIBRARY) \; 493 _R_PragmaStr(message ""Compiler cannot handle linking against "" #LIBRARY \; 494 "". Use -L and -l instead.""); 495*/; 496# define R__LOAD_LIBRARY(LIBRARY); 497# define R__ADD_INCLUDE_PATH(PATH); 498# define R__ADD_LIBRARY_PATH(PATH); 499#endif; 500 ; 501// Convenience macros to disable cling pointer check.; 502#ifdef __CLING__; 503# define R__CLING_PTRCHECK(ONOFF) __attribute__((annotate(""__cling__ptrcheck("" #ONOFF "")""))); 504#else; 505# define R__CLING_PTRCHECK(ONOFF); 506#endif; 507 ; 508#endif; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; RtypesCore.h; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefin",MatchSource.WIKI,doc/master/Rtypes_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html
https://root.cern/doc/master/Rtypes_8h_source.html:29419,Performance,load,load,29419,":TInitBehaviorDefinition Rtypes.h:152; ROOT::Internal::TInitBehavior::Unregistervirtual void Unregister(const char *classname, TClass *cl) const =0; ROOT::Internal::TInitBehavior::CreateClassvirtual TClass * CreateClass(const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il) const =0; ROOT::Internal::TInitBehavior::~TInitBehaviorvirtual ~TInitBehavior()Definition Rtypes.h:158; ROOT::Internal::TInitBehavior::Registervirtual void Register(const char *cname, Version_t id, const std::type_info &info, DictFuncPtr_t dict, Int_t pragmabits) const =0; ROOT::TClassAltDefinition TClassTable.cxx:128; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassStreamerDefinition TClassStreamer.h:26; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollectionCollection abstract base class.Definition TCollection.h:65; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileMergeInfoDefinition TFileMergeInfo.h:42; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjectMother of all ROOT objects.Definition TObject.h:41; TStringBasic string class.Definition TString.h:139; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualIsAProxyDefinition TVirtualIsAProxy.h:27; bool; int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Internal::DefaultStreamervoid DefaultStr",MatchSource.WIKI,doc/master/Rtypes_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html
https://root.cern/doc/master/Rtypes_8h_source.html:17598,Safety,redund,redundant,17598," __LINE__; } /** \endcond */; 357 ; 358#define ClassDefInlineOverride(name,id) \; 359 _ClassDefInline_(name,id,,override) \; 360 /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */; 361 ; 362#define ClassDefInlineNV(name,id) \; 363 _ClassDefInline_(name,id,,) \; 364 /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */; 365 ; 366//#define _ClassDefInterp_(name,id) ClassDefInline(name,id); 367 ; 368#define R__UseDummy(name) \; 369 class _NAME2_(name,_c) { public: _NAME2_(name,_c)() { if (name) { } } }; 370 ; 371#define ClassImpUnique(name,key) \; 372 namespace ROOT { \; 373 /** \cond HIDDEN_SYMBOLS */ TGenericClassInfo *GenerateInitInstance(const name*); /** \endcond */ \; 374 namespace { \; 375 static int _R__UNIQUE_(_NAME2_(R__dummyint,key)) __attribute__((unused)) = \; 376 GenerateInitInstance((name*)0x0)->SetImplFile(__FILE__, __LINE__); \; 377 R__UseDummy(_R__UNIQUE_(_NAME2_(R__dummyint,key))); \; 378 } \; 379 }; 380 ; 381/// \deprecated; 382#define ClassImp(name) ClassImpUnique(name,default); 383 ; 384/// Macro for Namespace; 385#define NamespaceImpUnique(name,key) \; 386 namespace name { \; 387 namespace ROOTDict { \; 388 /** \cond HIDDEN_SYMBOLS */ \; 389 ::ROOT::TGenericClassInfo *GenerateInitInstance(); /** \endcond */ \; 390 namespace { \; 391 static int _R__UNIQUE_(_NAME2_(R__dummyint,key)) = \; 392 GenerateInitInstance()->SetImplFile(__FILE__, __LINE__); \; 393 R__UseDummy(_R__UNIQUE_(_NAME2_(R__dummyint,key))); \; 394 } \; 395 } \; 396 }; 397 ; 398#define NamespaceImp(name) NamespaceImpUnique(name,default); 399 ; 400//---- ClassDefT macros for templates with one template argument ---------------; 401// ClassDefT corresponds to ClassDef; 402// ClassDefT2 goes in the same header as ClassDefT but must be; 403// outside the class scope; 404// ClassImpT corresponds to ClassImp; 405 ; 406 ; 407/// This ClassDefT is strictly redundant and is kept only for; 408/// backward compatibility.",MatchSource.WIKI,doc/master/Rtypes_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html
https://root.cern/doc/master/Rtypes_8h_source.html:30549,Safety,avoid,avoid,30549,"to TClass of the specified class name.Definition TClass.cxx:3035; TCollectionCollection abstract base class.Definition TCollection.h:65; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileMergeInfoDefinition TFileMergeInfo.h:42; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjectMother of all ROOT objects.Definition TObject.h:41; TStringBasic string class.Definition TString.h:139; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualIsAProxyDefinition TVirtualIsAProxy.h:27; bool; int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Internal::DefaultStreamervoid DefaultStreamer(TBuffer &R__b, const TClass *cl, void *objpointer)Default streamer implementation used by ClassDefInline to avoid requirement to include TBuffer....Definition TBuffer.cxx:30; ROOT::Internal::DefineBehaviorconst TInitBehavior * DefineBehavior(void *, void *)Definition TGenericClassInfo.cxx:45; ROOT::Internal::HasConsistentHashMemberBool_t HasConsistentHashMember(TClass &clRef)Return true is the Hash/RecursiveRemove setup is consistent, i.e.Definition TClass.cxx:7438; ROOT::Internal::GetDemangledTypeNamestd::string GetDemangledTypeName(const std::type_info &t)Definition TGenericClassInfo.cxx:31; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::DirAutoAdd_tvoid(* DirAutoAdd_t)(void *, TDirectory *)Definition Rtypes.h:119; ROOT::AddClassAlternateROOT::TClassAlt * AddClassAlternate(const char *normName, const char *alternate)Global function called by GenerateInitInstance.Definition TClassTable.cxx:918; ROOT::ResetAfterMergeFunc_tvoid(",MatchSource.WIKI,doc/master/Rtypes_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html
https://root.cern/doc/master/Rtypes_8h_source.html:29784,Security,access,accessing,29784,"dl, Int_t il) const =0; ROOT::Internal::TInitBehavior::~TInitBehaviorvirtual ~TInitBehavior()Definition Rtypes.h:158; ROOT::Internal::TInitBehavior::Registervirtual void Register(const char *cname, Version_t id, const std::type_info &info, DictFuncPtr_t dict, Int_t pragmabits) const =0; ROOT::TClassAltDefinition TClassTable.cxx:128; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassStreamerDefinition TClassStreamer.h:26; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollectionCollection abstract base class.Definition TCollection.h:65; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileMergeInfoDefinition TFileMergeInfo.h:42; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjectMother of all ROOT objects.Definition TObject.h:41; TStringBasic string class.Definition TString.h:139; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualIsAProxyDefinition TVirtualIsAProxy.h:27; bool; int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Internal::DefaultStreamervoid DefaultStreamer(TBuffer &R__b, const TClass *cl, void *objpointer)Default streamer implementation used by ClassDefInline to avoid requirement to include TBuffer....Definition TBuffer.cxx:30; ROOT::Internal::DefineBehaviorconst TInitBehavior * DefineBehavior(void *, void *)Definition TGenericClassInfo.cxx:45; ROOT::Internal::HasConsistentHashMemberBool_t",MatchSource.WIKI,doc/master/Rtypes_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html
https://root.cern/doc/master/runplugin_8C.html:1676,Deployability,update,update,1676,"; .  . Loading...; Searching...; No Matches. runplugin.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Creates and runs a simple iterator plugin connected to TGeoPainter iterator. ; It demonstrates the possibility to dynamically change the color of drawn volumes according some arbitrary criteria WITHOUT changing the color of the same volume drawn on branches that do not match the criteria.; To run:; root[0] .L iterplugin.cxx+; root[1] .x runplugin.C; root[2] select(2,kMagenta);; root[3] select(3,kBlue); ...; kMagenta@ kMagentaDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; iterpluginDefinition iterplugin.cxx:10; ; #include ""iterplugin.cxx""; ; iterplugin *plugin = nullptr;; ; void runplugin(); {; ; ; TString tutdir = gROOT->GetTutorialDir();; gROOT->ProcessLine("".x "" + tutdir + ""/geom/rootgeom.C"");; plugin = new iterplugin();; gGeoManager->GetGeomPainter()->SetIteratorPlugin(plugin);; }; ; void select(Int_t replica=1, Int_t color=kGreen); {; // Change current color. Replica range: 1-4; plugin->Select(replica, color);; gGeoManager->GetGeomPainter()->ModifiedPad();; }; Int_tint Int_tDefinition RtypesCore.h:45; kGreen@ kGreenDefinition Rtypes.h:66; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; gROOT#define gROOTDefinition TROOT.h:406; TGeoManager::GetGeomPainterTVirtualGeoPainter * GetGeomPainter()Make a default painter if none present. Returns pointer to it.Definition TGeoManager.cxx:2916; TStringBasic string class.Definition TString.h:139; TVirtualGeoPainter::ModifiedPadvirtual void ModifiedPad(Bool_t update=kFALSE) const =0; TVirtualGeoPainter::SetIteratorPluginvirtual void SetIteratorPlugin(TGeoIteratorPlugin *plugin)=0; iterplugin::Selectvoid Select(Int_t replica, Int_t color)Definition iterplugin.cxx:16; iterplugin.cxx; AuthorAndrei Gheata ; Definition in file runplugin.C. tutorialsgeomrunplugin.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:28 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/runplugin_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/runplugin_8C.html
https://root.cern/doc/master/runplugin_8C.html:247,Modifiability,plugin,plugin,247,". ROOT: tutorials/geom/runplugin.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. runplugin.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Creates and runs a simple iterator plugin connected to TGeoPainter iterator. ; It demonstrates the possibility to dynamically change the color of drawn volumes according some arbitrary criteria WITHOUT changing the color of the same volume drawn on branches that do not match the criteria.; To run:; root[0] .L iterplugin.cxx+; root[1] .x runplugin.C; root[2] select(2,kMagenta);; root[3] select(3,kBlue); ...; kMagenta@ kMagentaDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; iterpluginDefinition iterplugin.cxx:10; ; #include ""iterplugin.cxx""; ; iterplugin *plugin = nullptr;; ; void runplugin(); {; ; ; TString tutdir = gROOT->GetTutorialDir();; gROOT->ProcessLine("".x "" + tutdir + ""/geom/rootgeom.C"");; plugin = new iterplugin();; gGeoManager->GetGeomPainter()->SetIteratorPlugin(plugin);; }; ; void select(Int_t replica=1, Int_t color=kGreen); {; // Change current color. Replica range: 1-4; plugin->Select(replica, color);; gGeoManager->GetGeomPainter()->ModifiedPad();; }; Int_tint Int_tDefinition RtypesCore.h:45; kGreen@ kGreenDefinition Rtypes.h:66; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; gROOT#define gROOTDefinition TROOT.h:406; TGeoManager::GetGeomPainterTVirtualGeoPainter * GetGeomPainter()Make a default painter if none present. Returns pointer to it.Definition TGeoManager.cxx:2916; TStringBasic string class.Definition TString.h:139; TVirtualGeoPainter::ModifiedPadvirtual void ModifiedPad(Bool_t update=kFALSE) const =0; TVirtualGeoPainter::SetIteratorPluginvirtual void SetIteratorPlugin(TGeoIteratorPlugin *plugin)=0; iterplugin::Selectvoid Select(Int_t replica, Int_t color)Definition iterplugin.cxx:16; iterplugin.cxx; AuthorAndrei Gheata ; Definition in file runplugin.C. tutorialsgeomrunplugin.C. ROOT master - Refe",MatchSource.WIKI,doc/master/runplugin_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/runplugin_8C.html
https://root.cern/doc/master/runplugin_8C.html:784,Modifiability,plugin,plugin,784,". ROOT: tutorials/geom/runplugin.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. runplugin.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Creates and runs a simple iterator plugin connected to TGeoPainter iterator. ; It demonstrates the possibility to dynamically change the color of drawn volumes according some arbitrary criteria WITHOUT changing the color of the same volume drawn on branches that do not match the criteria.; To run:; root[0] .L iterplugin.cxx+; root[1] .x runplugin.C; root[2] select(2,kMagenta);; root[3] select(3,kBlue); ...; kMagenta@ kMagentaDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; iterpluginDefinition iterplugin.cxx:10; ; #include ""iterplugin.cxx""; ; iterplugin *plugin = nullptr;; ; void runplugin(); {; ; ; TString tutdir = gROOT->GetTutorialDir();; gROOT->ProcessLine("".x "" + tutdir + ""/geom/rootgeom.C"");; plugin = new iterplugin();; gGeoManager->GetGeomPainter()->SetIteratorPlugin(plugin);; }; ; void select(Int_t replica=1, Int_t color=kGreen); {; // Change current color. Replica range: 1-4; plugin->Select(replica, color);; gGeoManager->GetGeomPainter()->ModifiedPad();; }; Int_tint Int_tDefinition RtypesCore.h:45; kGreen@ kGreenDefinition Rtypes.h:66; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; gROOT#define gROOTDefinition TROOT.h:406; TGeoManager::GetGeomPainterTVirtualGeoPainter * GetGeomPainter()Make a default painter if none present. Returns pointer to it.Definition TGeoManager.cxx:2916; TStringBasic string class.Definition TString.h:139; TVirtualGeoPainter::ModifiedPadvirtual void ModifiedPad(Bool_t update=kFALSE) const =0; TVirtualGeoPainter::SetIteratorPluginvirtual void SetIteratorPlugin(TGeoIteratorPlugin *plugin)=0; iterplugin::Selectvoid Select(Int_t replica, Int_t color)Definition iterplugin.cxx:16; iterplugin.cxx; AuthorAndrei Gheata ; Definition in file runplugin.C. tutorialsgeomrunplugin.C. ROOT master - Refe",MatchSource.WIKI,doc/master/runplugin_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/runplugin_8C.html
https://root.cern/doc/master/runplugin_8C.html:931,Modifiability,plugin,plugin,931,"rials/geom/runplugin.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. runplugin.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Creates and runs a simple iterator plugin connected to TGeoPainter iterator. ; It demonstrates the possibility to dynamically change the color of drawn volumes according some arbitrary criteria WITHOUT changing the color of the same volume drawn on branches that do not match the criteria.; To run:; root[0] .L iterplugin.cxx+; root[1] .x runplugin.C; root[2] select(2,kMagenta);; root[3] select(3,kBlue); ...; kMagenta@ kMagentaDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; iterpluginDefinition iterplugin.cxx:10; ; #include ""iterplugin.cxx""; ; iterplugin *plugin = nullptr;; ; void runplugin(); {; ; ; TString tutdir = gROOT->GetTutorialDir();; gROOT->ProcessLine("".x "" + tutdir + ""/geom/rootgeom.C"");; plugin = new iterplugin();; gGeoManager->GetGeomPainter()->SetIteratorPlugin(plugin);; }; ; void select(Int_t replica=1, Int_t color=kGreen); {; // Change current color. Replica range: 1-4; plugin->Select(replica, color);; gGeoManager->GetGeomPainter()->ModifiedPad();; }; Int_tint Int_tDefinition RtypesCore.h:45; kGreen@ kGreenDefinition Rtypes.h:66; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; gROOT#define gROOTDefinition TROOT.h:406; TGeoManager::GetGeomPainterTVirtualGeoPainter * GetGeomPainter()Make a default painter if none present. Returns pointer to it.Definition TGeoManager.cxx:2916; TStringBasic string class.Definition TString.h:139; TVirtualGeoPainter::ModifiedPadvirtual void ModifiedPad(Bool_t update=kFALSE) const =0; TVirtualGeoPainter::SetIteratorPluginvirtual void SetIteratorPlugin(TGeoIteratorPlugin *plugin)=0; iterplugin::Selectvoid Select(Int_t replica, Int_t color)Definition iterplugin.cxx:16; iterplugin.cxx; AuthorAndrei Gheata ; Definition in file runplugin.C. tutorialsgeomrunplugin.C. ROOT master - Reference Guide ",MatchSource.WIKI,doc/master/runplugin_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/runplugin_8C.html
https://root.cern/doc/master/runplugin_8C.html:1008,Modifiability,plugin,plugin,1008,"rials/geom/runplugin.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. runplugin.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Creates and runs a simple iterator plugin connected to TGeoPainter iterator. ; It demonstrates the possibility to dynamically change the color of drawn volumes according some arbitrary criteria WITHOUT changing the color of the same volume drawn on branches that do not match the criteria.; To run:; root[0] .L iterplugin.cxx+; root[1] .x runplugin.C; root[2] select(2,kMagenta);; root[3] select(3,kBlue); ...; kMagenta@ kMagentaDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; iterpluginDefinition iterplugin.cxx:10; ; #include ""iterplugin.cxx""; ; iterplugin *plugin = nullptr;; ; void runplugin(); {; ; ; TString tutdir = gROOT->GetTutorialDir();; gROOT->ProcessLine("".x "" + tutdir + ""/geom/rootgeom.C"");; plugin = new iterplugin();; gGeoManager->GetGeomPainter()->SetIteratorPlugin(plugin);; }; ; void select(Int_t replica=1, Int_t color=kGreen); {; // Change current color. Replica range: 1-4; plugin->Select(replica, color);; gGeoManager->GetGeomPainter()->ModifiedPad();; }; Int_tint Int_tDefinition RtypesCore.h:45; kGreen@ kGreenDefinition Rtypes.h:66; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; gROOT#define gROOTDefinition TROOT.h:406; TGeoManager::GetGeomPainterTVirtualGeoPainter * GetGeomPainter()Make a default painter if none present. Returns pointer to it.Definition TGeoManager.cxx:2916; TStringBasic string class.Definition TString.h:139; TVirtualGeoPainter::ModifiedPadvirtual void ModifiedPad(Bool_t update=kFALSE) const =0; TVirtualGeoPainter::SetIteratorPluginvirtual void SetIteratorPlugin(TGeoIteratorPlugin *plugin)=0; iterplugin::Selectvoid Select(Int_t replica, Int_t color)Definition iterplugin.cxx:16; iterplugin.cxx; AuthorAndrei Gheata ; Definition in file runplugin.C. tutorialsgeomrunplugin.C. ROOT master - Reference Guide ",MatchSource.WIKI,doc/master/runplugin_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/runplugin_8C.html
https://root.cern/doc/master/runplugin_8C.html:1121,Modifiability,plugin,plugin,1121,"; .  . Loading...; Searching...; No Matches. runplugin.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Creates and runs a simple iterator plugin connected to TGeoPainter iterator. ; It demonstrates the possibility to dynamically change the color of drawn volumes according some arbitrary criteria WITHOUT changing the color of the same volume drawn on branches that do not match the criteria.; To run:; root[0] .L iterplugin.cxx+; root[1] .x runplugin.C; root[2] select(2,kMagenta);; root[3] select(3,kBlue); ...; kMagenta@ kMagentaDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; iterpluginDefinition iterplugin.cxx:10; ; #include ""iterplugin.cxx""; ; iterplugin *plugin = nullptr;; ; void runplugin(); {; ; ; TString tutdir = gROOT->GetTutorialDir();; gROOT->ProcessLine("".x "" + tutdir + ""/geom/rootgeom.C"");; plugin = new iterplugin();; gGeoManager->GetGeomPainter()->SetIteratorPlugin(plugin);; }; ; void select(Int_t replica=1, Int_t color=kGreen); {; // Change current color. Replica range: 1-4; plugin->Select(replica, color);; gGeoManager->GetGeomPainter()->ModifiedPad();; }; Int_tint Int_tDefinition RtypesCore.h:45; kGreen@ kGreenDefinition Rtypes.h:66; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; gROOT#define gROOTDefinition TROOT.h:406; TGeoManager::GetGeomPainterTVirtualGeoPainter * GetGeomPainter()Make a default painter if none present. Returns pointer to it.Definition TGeoManager.cxx:2916; TStringBasic string class.Definition TString.h:139; TVirtualGeoPainter::ModifiedPadvirtual void ModifiedPad(Bool_t update=kFALSE) const =0; TVirtualGeoPainter::SetIteratorPluginvirtual void SetIteratorPlugin(TGeoIteratorPlugin *plugin)=0; iterplugin::Selectvoid Select(Int_t replica, Int_t color)Definition iterplugin.cxx:16; iterplugin.cxx; AuthorAndrei Gheata ; Definition in file runplugin.C. tutorialsgeomrunplugin.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:28 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/runplugin_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/runplugin_8C.html
https://root.cern/doc/master/runplugin_8C.html:1789,Modifiability,plugin,plugin,1789,"; .  . Loading...; Searching...; No Matches. runplugin.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Creates and runs a simple iterator plugin connected to TGeoPainter iterator. ; It demonstrates the possibility to dynamically change the color of drawn volumes according some arbitrary criteria WITHOUT changing the color of the same volume drawn on branches that do not match the criteria.; To run:; root[0] .L iterplugin.cxx+; root[1] .x runplugin.C; root[2] select(2,kMagenta);; root[3] select(3,kBlue); ...; kMagenta@ kMagentaDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; iterpluginDefinition iterplugin.cxx:10; ; #include ""iterplugin.cxx""; ; iterplugin *plugin = nullptr;; ; void runplugin(); {; ; ; TString tutdir = gROOT->GetTutorialDir();; gROOT->ProcessLine("".x "" + tutdir + ""/geom/rootgeom.C"");; plugin = new iterplugin();; gGeoManager->GetGeomPainter()->SetIteratorPlugin(plugin);; }; ; void select(Int_t replica=1, Int_t color=kGreen); {; // Change current color. Replica range: 1-4; plugin->Select(replica, color);; gGeoManager->GetGeomPainter()->ModifiedPad();; }; Int_tint Int_tDefinition RtypesCore.h:45; kGreen@ kGreenDefinition Rtypes.h:66; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; gROOT#define gROOTDefinition TROOT.h:406; TGeoManager::GetGeomPainterTVirtualGeoPainter * GetGeomPainter()Make a default painter if none present. Returns pointer to it.Definition TGeoManager.cxx:2916; TStringBasic string class.Definition TString.h:139; TVirtualGeoPainter::ModifiedPadvirtual void ModifiedPad(Bool_t update=kFALSE) const =0; TVirtualGeoPainter::SetIteratorPluginvirtual void SetIteratorPlugin(TGeoIteratorPlugin *plugin)=0; iterplugin::Selectvoid Select(Int_t replica, Int_t color)Definition iterplugin.cxx:16; iterplugin.cxx; AuthorAndrei Gheata ; Definition in file runplugin.C. tutorialsgeomrunplugin.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:28 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/runplugin_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/runplugin_8C.html
https://root.cern/doc/master/runplugin_8C.html:231,Usability,simpl,simple,231,". ROOT: tutorials/geom/runplugin.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. runplugin.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Creates and runs a simple iterator plugin connected to TGeoPainter iterator. ; It demonstrates the possibility to dynamically change the color of drawn volumes according some arbitrary criteria WITHOUT changing the color of the same volume drawn on branches that do not match the criteria.; To run:; root[0] .L iterplugin.cxx+; root[1] .x runplugin.C; root[2] select(2,kMagenta);; root[3] select(3,kBlue); ...; kMagenta@ kMagentaDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; iterpluginDefinition iterplugin.cxx:10; ; #include ""iterplugin.cxx""; ; iterplugin *plugin = nullptr;; ; void runplugin(); {; ; ; TString tutdir = gROOT->GetTutorialDir();; gROOT->ProcessLine("".x "" + tutdir + ""/geom/rootgeom.C"");; plugin = new iterplugin();; gGeoManager->GetGeomPainter()->SetIteratorPlugin(plugin);; }; ; void select(Int_t replica=1, Int_t color=kGreen); {; // Change current color. Replica range: 1-4; plugin->Select(replica, color);; gGeoManager->GetGeomPainter()->ModifiedPad();; }; Int_tint Int_tDefinition RtypesCore.h:45; kGreen@ kGreenDefinition Rtypes.h:66; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; gROOT#define gROOTDefinition TROOT.h:406; TGeoManager::GetGeomPainterTVirtualGeoPainter * GetGeomPainter()Make a default painter if none present. Returns pointer to it.Definition TGeoManager.cxx:2916; TStringBasic string class.Definition TString.h:139; TVirtualGeoPainter::ModifiedPadvirtual void ModifiedPad(Bool_t update=kFALSE) const =0; TVirtualGeoPainter::SetIteratorPluginvirtual void SetIteratorPlugin(TGeoIteratorPlugin *plugin)=0; iterplugin::Selectvoid Select(Int_t replica, Int_t color)Definition iterplugin.cxx:16; iterplugin.cxx; AuthorAndrei Gheata ; Definition in file runplugin.C. tutorialsgeomrunplugin.C. ROOT master - Refe",MatchSource.WIKI,doc/master/runplugin_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/runplugin_8C.html
https://root.cern/doc/master/run__h1analysis_8C.html:2444,Modifiability,variab,variable,2444,"; chain.SetCacheSize(20*1024*1024);; chain.Add(""$H1/dstarmb.root"");; chain.Add(""$H1/dstarp1a.root"");; chain.Add(""$H1/dstarp1b.root"");; chain.Add(""$H1/dstarp2.root"");; ; TString selectionMacro = gSystem->GetDirName(__FILE__) + ""/h1analysis.C"";; ; if (type == 0); chain.Process(selectionMacro);; else if (type == 1) {; // use AClic ( add a + at the end; selectionMacro += ""+"";; chain.Process(selectionMacro);; }; else if (type == 2) {; chain.Process(selectionMacro,""fillList"");; chain.Process(selectionMacro,""useList"");; }; }; ; ; ; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TChainA chain is a collection of files containing TTree objects.Definition TChain.h:33; TStringBasic string class.Definition TString.h:139; TSystem::Setenvvirtual void Setenv(const char *name, const char *value)Set environment variable.Definition TSystem.cxx:1649; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; Author; Definition in file run_h1analysis.C. tutorialstreerun_h1analysis.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/run__h1analysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/run__h1analysis_8C.html
https://root.cern/doc/master/RVec_8hxx_source.html:4907,Availability,error,error,4907,"ECK(off) SmallVectorBase {; 139public:; 140 // This limits the maximum size of an RVec<char> to ~4GB but we don't expect this to ever be a problem,; 141 // and we prefer the smaller Size_T to reduce the size of each RVec object.; 142 using Size_T = int32_t;; 143 ; 144protected:; 145 void *fBeginX;; 146 /// Always >= 0.; 147 // Type is signed only for consistency with fCapacity.; 148 Size_T fSize = 0;; 149 /// Always >= -1. fCapacity == -1 indicates the RVec is in ""memory adoption"" mode.; 150 Size_T fCapacity;; 151 ; 152 /// The maximum value of the Size_T used.; 153 static constexpr size_t SizeTypeMax() { return std::numeric_limits<Size_T>::max(); }; 154 ; 155 SmallVectorBase() = delete;; 156 SmallVectorBase(void *FirstEl, size_t TotalCapacity) : fBeginX(FirstEl), fCapacity(TotalCapacity) {}; 157 ; 158 /// This is an implementation of the grow() method which only works; 159 /// on POD-like data types and is out of line to reduce code duplication.; 160 /// This function will report a fatal error if it cannot increase capacity.; 161 void grow_pod(void *FirstEl, size_t MinSize, size_t TSize);; 162 ; 163 /// Report that MinSize doesn't fit into this vector's size type. Throws; 164 /// std::length_error or calls report_fatal_error.; 165 static void report_size_overflow(size_t MinSize);; 166 /// Report that this vector is already at maximum capacity. Throws; 167 /// std::length_error or calls report_fatal_error.; 168 static void report_at_maximum_capacity();; 169 ; 170 /// If false, the RVec is in ""memory adoption"" mode, i.e. it is acting as a view on a memory buffer it does not own.; 171 bool Owns() const { return fCapacity != -1; }; 172 ; 173public:; 174 size_t size() const { return fSize; }; 175 size_t capacity() const noexcept { return Owns() ? fCapacity : fSize; }; 176 ; 177 R__RVEC_NODISCARD bool empty() const { return !fSize; }; 178 ; 179 /// Set the array size to \p N, which the current array must have enough; 180 /// capacity for.; 181 ///; 182 /// This does not c",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:6105,Availability,avail,available,6105,"fit into this vector's size type. Throws; 164 /// std::length_error or calls report_fatal_error.; 165 static void report_size_overflow(size_t MinSize);; 166 /// Report that this vector is already at maximum capacity. Throws; 167 /// std::length_error or calls report_fatal_error.; 168 static void report_at_maximum_capacity();; 169 ; 170 /// If false, the RVec is in ""memory adoption"" mode, i.e. it is acting as a view on a memory buffer it does not own.; 171 bool Owns() const { return fCapacity != -1; }; 172 ; 173public:; 174 size_t size() const { return fSize; }; 175 size_t capacity() const noexcept { return Owns() ? fCapacity : fSize; }; 176 ; 177 R__RVEC_NODISCARD bool empty() const { return !fSize; }; 178 ; 179 /// Set the array size to \p N, which the current array must have enough; 180 /// capacity for.; 181 ///; 182 /// This does not construct or destroy any elements in the vector.; 183 ///; 184 /// Clients can use this in conjunction with capacity() to write past the end; 185 /// of the buffer when they know that more elements are available, and only; 186 /// update the size later. This avoids the cost of value initializing elements; 187 /// which will only be overwritten.; 188 void set_size(size_t N); 189 {; 190 if (N > capacity()) {; 191 throw std::runtime_error(""Setting size to a value greater than capacity."");; 192 }; 193 fSize = N;; 194 }; 195};; 196 ; 197/// Used to figure out the offset of the first element of an RVec; 198template <class T>; 199struct SmallVectorAlignmentAndSize {; 200 alignas(SmallVectorBase) char Base[sizeof(SmallVectorBase)];; 201 alignas(T) char FirstEl[sizeof(T)];; 202};; 203 ; 204/// This is the part of SmallVectorTemplateBase which does not depend on whether the type T is a POD.; 205template <typename T>; 206class R__CLING_PTRCHECK(off) SmallVectorTemplateCommon : public SmallVectorBase {; 207 using Base = SmallVectorBase;; 208 ; 209 /// Find the address of the first element. For this pointer math to be valid; 210 /// with small-si",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:22842,Availability,avail,available,22842,"72 explicit RVecImpl(unsigned N) : ROOT::Internal::VecOps::SmallVectorTemplateBase<T>(N) {}; 573 ; 574public:; 575 RVecImpl(const RVecImpl &) = delete;; 576 ; 577 ~RVecImpl(); 578 {; 579 // Subclass has already destructed this vector's elements.; 580 // If this wasn't grown from the inline copy, deallocate the old space.; 581 if (!this->isSmall() && this->Owns()); 582 free(this->begin());; 583 }; 584 ; 585 // also give up adopted memory if applicable; 586 void clear(); 587 {; 588 if (this->Owns()) {; 589 this->destroy_range(this->begin(), this->end());; 590 this->fSize = 0;; 591 } else {; 592 this->resetToSmall();; 593 }; 594 }; 595 ; 596 void resize(size_type N); 597 {; 598 if (N < this->size()) {; 599 if (this->Owns()); 600 this->destroy_range(this->begin() + N, this->end());; 601 this->set_size(N);; 602 } else if (N > this->size()) {; 603 if (this->capacity() < N); 604 this->grow(N);; 605 for (auto I = this->end(), E = this->begin() + N; I != E; ++I); 606 new (&*I) T();; 607 this->set_size(N);; 608 }; 609 }; 610 ; 611 void resize(size_type N, const T &NV); 612 {; 613 if (N < this->size()) {; 614 if (this->Owns()); 615 this->destroy_range(this->begin() + N, this->end());; 616 this->set_size(N);; 617 } else if (N > this->size()) {; 618 if (this->capacity() < N); 619 this->grow(N);; 620 std::uninitialized_fill(this->end(), this->begin() + N, NV);; 621 this->set_size(N);; 622 }; 623 }; 624 ; 625 void reserve(size_type N); 626 {; 627 if (this->capacity() < N); 628 this->grow(N);; 629 }; 630 ; 631 void pop_back_n(size_type NumItems); 632 {; 633 if (this->size() < NumItems) {; 634 throw std::runtime_error(""Popping back more elements than those available."");; 635 }; 636 if (this->Owns()); 637 this->destroy_range(this->end() - NumItems, this->end());; 638 this->set_size(this->size() - NumItems);; 639 }; 640 ; 641 R__RVEC_NODISCARD T pop_back_val(); 642 {; 643 T Result = ::std::move(this->back());; 644 this->pop_back();; 645 return Result;; 646 }; 647 ; 648 void swap(RVecI",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:25433,Availability,down,down,25433,"nts.; 679 ; 680 void assign(size_type NumElts, const T &Elt); 681 {; 682 clear();; 683 if (this->capacity() < NumElts); 684 this->grow(NumElts);; 685 this->set_size(NumElts);; 686 std::uninitialized_fill(this->begin(), this->end(), Elt);; 687 }; 688 ; 689 template <typename in_iter,; 690 typename = typename std::enable_if<std::is_convertible<; 691 typename std::iterator_traits<in_iter>::iterator_category, std::input_iterator_tag>::value>::type>; 692 void assign(in_iter in_start, in_iter in_end); 693 {; 694 clear();; 695 append(in_start, in_end);; 696 }; 697 ; 698 void assign(std::initializer_list<T> IL); 699 {; 700 clear();; 701 append(IL);; 702 }; 703 ; 704 iterator erase(const_iterator CI); 705 {; 706 // Just cast away constness because this is a non-const member function.; 707 iterator I = const_cast<iterator>(CI);; 708 ; 709 if (I < this->begin() || I >= this->end()) {; 710 throw std::runtime_error(""The iterator passed to `erase` is out of bounds."");; 711 }; 712 ; 713 iterator N = I;; 714 // Shift all elts down one.; 715 std::move(I + 1, this->end(), I);; 716 // Drop the last elt.; 717 this->pop_back();; 718 return (N);; 719 }; 720 ; 721 iterator erase(const_iterator CS, const_iterator CE); 722 {; 723 // Just cast away constness because this is a non-const member function.; 724 iterator S = const_cast<iterator>(CS);; 725 iterator E = const_cast<iterator>(CE);; 726 ; 727 if (S < this->begin() || E > this->end() || S > E) {; 728 throw std::runtime_error(""Invalid start/end pair passed to `erase` (out of bounds or start > end)."");; 729 }; 730 ; 731 iterator N = S;; 732 // Shift all elts down.; 733 iterator I = std::move(E, this->end(), S);; 734 // Drop the last elts.; 735 if (this->Owns()); 736 this->destroy_range(I, this->end());; 737 this->set_size(I - this->begin());; 738 return (N);; 739 }; 740 ; 741 iterator insert(iterator I, T &&Elt); 742 {; 743 if (I == this->end()) { // Important special case for empty vector.; 744 this->push_back(::std::move(Elt));; 745 re",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:26021,Availability,down,down,26021,":initializer_list<T> IL); 699 {; 700 clear();; 701 append(IL);; 702 }; 703 ; 704 iterator erase(const_iterator CI); 705 {; 706 // Just cast away constness because this is a non-const member function.; 707 iterator I = const_cast<iterator>(CI);; 708 ; 709 if (I < this->begin() || I >= this->end()) {; 710 throw std::runtime_error(""The iterator passed to `erase` is out of bounds."");; 711 }; 712 ; 713 iterator N = I;; 714 // Shift all elts down one.; 715 std::move(I + 1, this->end(), I);; 716 // Drop the last elt.; 717 this->pop_back();; 718 return (N);; 719 }; 720 ; 721 iterator erase(const_iterator CS, const_iterator CE); 722 {; 723 // Just cast away constness because this is a non-const member function.; 724 iterator S = const_cast<iterator>(CS);; 725 iterator E = const_cast<iterator>(CE);; 726 ; 727 if (S < this->begin() || E > this->end() || S > E) {; 728 throw std::runtime_error(""Invalid start/end pair passed to `erase` (out of bounds or start > end)."");; 729 }; 730 ; 731 iterator N = S;; 732 // Shift all elts down.; 733 iterator I = std::move(E, this->end(), S);; 734 // Drop the last elts.; 735 if (this->Owns()); 736 this->destroy_range(I, this->end());; 737 this->set_size(I - this->begin());; 738 return (N);; 739 }; 740 ; 741 iterator insert(iterator I, T &&Elt); 742 {; 743 if (I == this->end()) { // Important special case for empty vector.; 744 this->push_back(::std::move(Elt));; 745 return this->end() - 1;; 746 }; 747 ; 748 if (I < this->begin() || I > this->end()) {; 749 throw std::runtime_error(""The iterator passed to `insert` is out of bounds."");; 750 }; 751 ; 752 if (this->size() >= this->capacity()) {; 753 size_t EltNo = I - this->begin();; 754 this->grow();; 755 I = this->begin() + EltNo;; 756 }; 757 ; 758 ::new ((void *)this->end()) T(::std::move(this->back()));; 759 // Push everything else over.; 760 std::move_backward(I, this->end() - 1, this->end());; 761 this->set_size(this->size() + 1);; 762 ; 763 // If we just moved the element we're inserting, be",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:46197,Availability,avail,available,46197,"e RVecN is shorter than `pos`.; 1314 value_type at(size_type pos, value_type fallback) const; 1315 {; 1316 if (pos >= size_type(this->fSize)); 1317 return fallback;; 1318 return this->operator[](pos);; 1319 }; 1320};; 1321 ; 1322// clang-format off; 1323/**; 1324\class ROOT::VecOps::RVec; 1325\brief A ""std::vector""-like collection of values implementing handy operation to analyse them; 1326\tparam T The type of the contained objects; 1327 ; 1328A RVec is a container designed to make analysis of values' collections fast and easy.; 1329Its storage is contiguous in memory and its interface is designed such to resemble to the one; 1330of the stl vector. In addition the interface features methods and; 1331[external functions](https://root.cern/doc/master/namespaceROOT_1_1VecOps.html) to ease the manipulation and analysis; 1332of the data in the RVec.; 1333 ; 1334\note ROOT::VecOps::RVec can also be spelled simply ROOT::RVec. Shorthand aliases such as ROOT::RVecI or ROOT::RVecD; 1335are also available as template instantiations of RVec of fundamental types. The full list of available aliases:; 1336- RVecB (`bool`); 1337- RVecC (`char`); 1338- RVecD (`double`); 1339- RVecF (`float`); 1340- RVecI (`int`); 1341- RVecL (`long`); 1342- RVecLL (`long long`); 1343- RVecU (`unsigned`); 1344- RVecUL (`unsigned long`); 1345- RVecULL (`unsigned long long`); 1346 ; 1347\note RVec does not attempt to be exception safe. Exceptions thrown by element constructors during insertions, swaps or; 1348other operations will be propagated potentially leaving the RVec object in an invalid state.; 1349 ; 1350\note RVec methods (e.g. `at` or `size`) follow the STL naming convention instead of the ROOT naming convention in order; 1351to make RVec a drop-in replacement for `std::vector`.; 1352 ; 1353\htmlonly; 1354<a href=""https://doi.org/10.5281/zenodo.1253756""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.1253756.svg"" alt=""DOI""></a>; 1355\endhtmlonly; 1356 ; 1357## Table of Contents; 1358- ",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:46281,Availability,avail,available,46281,"off; 1323/**; 1324\class ROOT::VecOps::RVec; 1325\brief A ""std::vector""-like collection of values implementing handy operation to analyse them; 1326\tparam T The type of the contained objects; 1327 ; 1328A RVec is a container designed to make analysis of values' collections fast and easy.; 1329Its storage is contiguous in memory and its interface is designed such to resemble to the one; 1330of the stl vector. In addition the interface features methods and; 1331[external functions](https://root.cern/doc/master/namespaceROOT_1_1VecOps.html) to ease the manipulation and analysis; 1332of the data in the RVec.; 1333 ; 1334\note ROOT::VecOps::RVec can also be spelled simply ROOT::RVec. Shorthand aliases such as ROOT::RVecI or ROOT::RVecD; 1335are also available as template instantiations of RVec of fundamental types. The full list of available aliases:; 1336- RVecB (`bool`); 1337- RVecC (`char`); 1338- RVecD (`double`); 1339- RVecF (`float`); 1340- RVecI (`int`); 1341- RVecL (`long`); 1342- RVecLL (`long long`); 1343- RVecU (`unsigned`); 1344- RVecUL (`unsigned long`); 1345- RVecULL (`unsigned long long`); 1346 ; 1347\note RVec does not attempt to be exception safe. Exceptions thrown by element constructors during insertions, swaps or; 1348other operations will be propagated potentially leaving the RVec object in an invalid state.; 1349 ; 1350\note RVec methods (e.g. `at` or `size`) follow the STL naming convention instead of the ROOT naming convention in order; 1351to make RVec a drop-in replacement for `std::vector`.; 1352 ; 1353\htmlonly; 1354<a href=""https://doi.org/10.5281/zenodo.1253756""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.1253756.svg"" alt=""DOI""></a>; 1355\endhtmlonly; 1356 ; 1357## Table of Contents; 1358- [Example](\ref example); 1359- [Arithmetic operations, logical operations and mathematical functions](\ref operationsandfunctions); 1360- [Owning and adopting memory](\ref owningandadoptingmemory); 1361- [Sorting and manipulation of indices](\re",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:50102,Availability,avail,available,50102,"ion of transverse momenta can be used within the rest of the data analysis, for; 1395example to fill a histogram.; 1396 ; 1397\anchor operationsandfunctions; 1398## Arithmetic operations, logical operations and mathematical functions; 1399Arithmetic operations on RVec instances can be performed: for example, they can be added, subtracted, multiplied.; 1400~~~{.cpp}; 1401RVec<double> v1 {1.,2.,3.,4.};; 1402RVec<float> v2 {5.f,6.f,7.f,8.f};; 1403auto v3 = v1+v2;; 1404auto v4 = 3 * v1;; 1405~~~; 1406The supported operators are ; 1407 - +, -, *, /; 1408 - +=, -=, *=, /=; 1409 - <, >, ==, !=, <=, >=, &&, ||; 1410 - ~, !; 1411 - &, |, ^; 1412 - &=, |=, ^=; 1413 - <<=, >>=; 1414 ; 1415The most common mathematical functions are supported. It is possible to invoke them passing ; 1416RVecs as arguments.; 1417 - abs, fdim, fmod, remainder; 1418 - floor, ceil, trunc, round, lround, llround; 1419 - exp, exp2, expm1; 1420 - log, log10, log2, log1p; 1421 - pow; 1422 - sqrt, cbrt; 1423 - sin, cos, tan, asin, acos, atan, atan2, hypot; 1424 - sinh, cosh, tanh, asinh, acosh; 1425 - erf, erfc; 1426 - lgamma, tgamma; 1427 ; 1428If the VDT library is available, the following functions can be invoked. Internally the calculations; 1429are vectorized:; 1430 - fast_expf, fast_logf, fast_sinf, fast_cosf, fast_tanf, fast_asinf, fast_acosf, fast_atanf; 1431 - fast_exp, fast_log, fast_sin, fast_cos, fast_tan, fast_asin, fast_acos, fast_atan; 1432 ; 1433\anchor owningandadoptingmemory; 1434## Owning and adopting memory; 1435RVec has contiguous memory associated to it. It can own it or simply adopt it. In the latter case,; 1436it can be constructed with the address of the memory associated to it and its length. For example:; 1437~~~{.cpp}; 1438std::vector<int> myStlVec {1,2,3};; 1439RVec<int> myRVec(myStlVec.data(), myStlVec.size());; 1440~~~; 1441In this case, the memory associated to myStlVec and myRVec is the same, myRVec simply ""adopted it"".; 1442If any method which implies a re-allocation is c",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:128401,Availability,error,error,128401,"igned long int>;; 3531using RVecULL = ROOT::VecOps::RVec<unsigned long long int>;; 3532 ; 3533} // End of ROOT NS; 3534 ; 3535#endif // ROOT_RVEC; fSizedim_t fSizeDefinition DeclareExecutors.h:184; R__unlikely#define R__unlikely(expr)Definition RConfig.hxx:586; d#define d(i)Definition RSha256.hxx:102; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; e#define e(i)Definition RSha256.hxx:103; R__RVEC_NODISCARD#define R__RVEC_NODISCARDDefinition RVec.hxx:19; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; M_PI#define M_PIDefinition Rotated.cxx:105; Rtypes.h; operator<<TBuffer & operator<<(TBuffer &buf, const Tmpl *obj)Definition TBuffer.h:397; R__CLING_PTRCHECK#define R__CLING_PTRCHECK(ONOFF)Definition Rtypes.h:505; Productstatic Double_t Product(const Double_t *x, const Float_t *y)Product.Definition TCTUB.cxx:101; X#define X(type, name); TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; N#define N; CompareInt_t Compare(const void *item1, const void *item2)Definition TGListTree.cxx:2135; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; lengthOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char f",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:6134,Deployability,update,update,6134,"fit into this vector's size type. Throws; 164 /// std::length_error or calls report_fatal_error.; 165 static void report_size_overflow(size_t MinSize);; 166 /// Report that this vector is already at maximum capacity. Throws; 167 /// std::length_error or calls report_fatal_error.; 168 static void report_at_maximum_capacity();; 169 ; 170 /// If false, the RVec is in ""memory adoption"" mode, i.e. it is acting as a view on a memory buffer it does not own.; 171 bool Owns() const { return fCapacity != -1; }; 172 ; 173public:; 174 size_t size() const { return fSize; }; 175 size_t capacity() const noexcept { return Owns() ? fCapacity : fSize; }; 176 ; 177 R__RVEC_NODISCARD bool empty() const { return !fSize; }; 178 ; 179 /// Set the array size to \p N, which the current array must have enough; 180 /// capacity for.; 181 ///; 182 /// This does not construct or destroy any elements in the vector.; 183 ///; 184 /// Clients can use this in conjunction with capacity() to write past the end; 185 /// of the buffer when they know that more elements are available, and only; 186 /// update the size later. This avoids the cost of value initializing elements; 187 /// which will only be overwritten.; 188 void set_size(size_t N); 189 {; 190 if (N > capacity()) {; 191 throw std::runtime_error(""Setting size to a value greater than capacity."");; 192 }; 193 fSize = N;; 194 }; 195};; 196 ; 197/// Used to figure out the offset of the first element of an RVec; 198template <class T>; 199struct SmallVectorAlignmentAndSize {; 200 alignas(SmallVectorBase) char Base[sizeof(SmallVectorBase)];; 201 alignas(T) char FirstEl[sizeof(T)];; 202};; 203 ; 204/// This is the part of SmallVectorTemplateBase which does not depend on whether the type T is a POD.; 205template <typename T>; 206class R__CLING_PTRCHECK(off) SmallVectorTemplateCommon : public SmallVectorBase {; 207 using Base = SmallVectorBase;; 208 ; 209 /// Find the address of the first element. For this pointer math to be valid; 210 /// with small-si",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:27002,Deployability,update,update,27002,"t of bounds or start > end)."");; 729 }; 730 ; 731 iterator N = S;; 732 // Shift all elts down.; 733 iterator I = std::move(E, this->end(), S);; 734 // Drop the last elts.; 735 if (this->Owns()); 736 this->destroy_range(I, this->end());; 737 this->set_size(I - this->begin());; 738 return (N);; 739 }; 740 ; 741 iterator insert(iterator I, T &&Elt); 742 {; 743 if (I == this->end()) { // Important special case for empty vector.; 744 this->push_back(::std::move(Elt));; 745 return this->end() - 1;; 746 }; 747 ; 748 if (I < this->begin() || I > this->end()) {; 749 throw std::runtime_error(""The iterator passed to `insert` is out of bounds."");; 750 }; 751 ; 752 if (this->size() >= this->capacity()) {; 753 size_t EltNo = I - this->begin();; 754 this->grow();; 755 I = this->begin() + EltNo;; 756 }; 757 ; 758 ::new ((void *)this->end()) T(::std::move(this->back()));; 759 // Push everything else over.; 760 std::move_backward(I, this->end() - 1, this->end());; 761 this->set_size(this->size() + 1);; 762 ; 763 // If we just moved the element we're inserting, be sure to update; 764 // the reference.; 765 T *EltPtr = &Elt;; 766 if (I <= EltPtr && EltPtr < this->end()); 767 ++EltPtr;; 768 ; 769 *I = ::std::move(*EltPtr);; 770 return I;; 771 }; 772 ; 773 iterator insert(iterator I, const T &Elt); 774 {; 775 if (I == this->end()) { // Important special case for empty vector.; 776 this->push_back(Elt);; 777 return this->end() - 1;; 778 }; 779 ; 780 if (I < this->begin() || I > this->end()) {; 781 throw std::runtime_error(""The iterator passed to `insert` is out of bounds."");; 782 }; 783 ; 784 if (this->size() >= this->capacity()) {; 785 size_t EltNo = I - this->begin();; 786 this->grow();; 787 I = this->begin() + EltNo;; 788 }; 789 ::new ((void *)this->end()) T(std::move(this->back()));; 790 // Push everything else over.; 791 std::move_backward(I, this->end() - 1, this->end());; 792 this->set_size(this->size() + 1);; 793 ; 794 // If we just moved the element we're inserting, be sure to up",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:27930,Deployability,update,update,27930," this->end() - 1, this->end());; 761 this->set_size(this->size() + 1);; 762 ; 763 // If we just moved the element we're inserting, be sure to update; 764 // the reference.; 765 T *EltPtr = &Elt;; 766 if (I <= EltPtr && EltPtr < this->end()); 767 ++EltPtr;; 768 ; 769 *I = ::std::move(*EltPtr);; 770 return I;; 771 }; 772 ; 773 iterator insert(iterator I, const T &Elt); 774 {; 775 if (I == this->end()) { // Important special case for empty vector.; 776 this->push_back(Elt);; 777 return this->end() - 1;; 778 }; 779 ; 780 if (I < this->begin() || I > this->end()) {; 781 throw std::runtime_error(""The iterator passed to `insert` is out of bounds."");; 782 }; 783 ; 784 if (this->size() >= this->capacity()) {; 785 size_t EltNo = I - this->begin();; 786 this->grow();; 787 I = this->begin() + EltNo;; 788 }; 789 ::new ((void *)this->end()) T(std::move(this->back()));; 790 // Push everything else over.; 791 std::move_backward(I, this->end() - 1, this->end());; 792 this->set_size(this->size() + 1);; 793 ; 794 // If we just moved the element we're inserting, be sure to update; 795 // the reference.; 796 const T *EltPtr = &Elt;; 797 if (I <= EltPtr && EltPtr < this->end()); 798 ++EltPtr;; 799 ; 800 *I = *EltPtr;; 801 return I;; 802 }; 803 ; 804 iterator insert(iterator I, size_type NumToInsert, const T &Elt); 805 {; 806 // Convert iterator to elt# to avoid invalidating iterator when we reserve(); 807 size_t InsertElt = I - this->begin();; 808 ; 809 if (I == this->end()) { // Important special case for empty vector.; 810 append(NumToInsert, Elt);; 811 return this->begin() + InsertElt;; 812 }; 813 ; 814 if (I < this->begin() || I > this->end()) {; 815 throw std::runtime_error(""The iterator passed to `insert` is out of bounds."");; 816 }; 817 ; 818 // Ensure there is enough space.; 819 reserve(this->size() + NumToInsert);; 820 ; 821 // Uninvalidate the iterator.; 822 I = this->begin() + InsertElt;; 823 ; 824 // If there are more elements between the insertion point and the end of the; 8",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:51023,Deployability,release,released,51023,", asinh, acosh; 1425 - erf, erfc; 1426 - lgamma, tgamma; 1427 ; 1428If the VDT library is available, the following functions can be invoked. Internally the calculations; 1429are vectorized:; 1430 - fast_expf, fast_logf, fast_sinf, fast_cosf, fast_tanf, fast_asinf, fast_acosf, fast_atanf; 1431 - fast_exp, fast_log, fast_sin, fast_cos, fast_tan, fast_asin, fast_acos, fast_atan; 1432 ; 1433\anchor owningandadoptingmemory; 1434## Owning and adopting memory; 1435RVec has contiguous memory associated to it. It can own it or simply adopt it. In the latter case,; 1436it can be constructed with the address of the memory associated to it and its length. For example:; 1437~~~{.cpp}; 1438std::vector<int> myStlVec {1,2,3};; 1439RVec<int> myRVec(myStlVec.data(), myStlVec.size());; 1440~~~; 1441In this case, the memory associated to myStlVec and myRVec is the same, myRVec simply ""adopted it"".; 1442If any method which implies a re-allocation is called, e.g. *emplace_back* or *resize*, the adopted; 1443memory is released and new one is allocated. The previous content is copied in the new memory and; 1444preserved.; 1445 ; 1446\anchor sorting; 1447## Sorting and manipulation of indices; 1448 ; 1449### Sorting; 1450RVec complies to the STL interfaces when it comes to iterations. As a result, standard algorithms; 1451can be used, for example sorting:; 1452~~~{.cpp}; 1453RVec<double> v{6., 4., 5.};; 1454std::sort(v.begin(), v.end());; 1455~~~; 1456 ; 1457For convenience, helpers are provided too:; 1458~~~{.cpp}; 1459auto sorted_v = Sort(v);; 1460auto reversed_v = Reverse(v);; 1461~~~; 1462 ; 1463### Manipulation of indices; 1464 ; 1465It is also possible to manipulated the RVecs acting on their indices. For example,; 1466the following syntax; 1467~~~{.cpp}; 1468RVecD v0 {9., 7., 8.};; 1469auto v1 = Take(v0, {1, 2, 0});; 1470~~~; 1471will yield a new RVec<double> the content of which is the first, second and zeroth element of; 1472v0, i.e. `{7., 8., 9.}`.; 1473 ; 1474The `Argsort` and `S",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:95074,Deployability,toggle,toggle,95074,"716/// Return the indices of the elements which are not zero; 2717///; 2718/// Example code, at the ROOT prompt:; 2719/// ~~~{.cpp}; 2720/// using namespace ROOT::VecOps;; 2721/// RVecD v {2., 0., 3., 0., 1.};; 2722/// auto nonzero_idx = Nonzero(v);; 2723/// nonzero_idx; 2724/// // (ROOT::VecOps::RVec<unsigned long> &) { 0, 2, 4 }; 2725/// ~~~; 2726template <typename T>; 2727RVec<typename RVec<T>::size_type> Nonzero(const RVec<T> &v); 2728{; 2729 using size_type = typename RVec<T>::size_type;; 2730 RVec<size_type> r;; 2731 const auto size = v.size();; 2732 r.reserve(size);; 2733 for(size_type i=0; i<size; i++) {; 2734 if(v[i] != 0) {; 2735 r.emplace_back(i);; 2736 }; 2737 }; 2738 return r;; 2739}; 2740 ; 2741/// Return the intersection of elements of two RVecs.; 2742///; 2743/// Each element of v1 is looked up in v2 and added to the returned vector if; 2744/// found. Following, the order of v1 is preserved. If v2 is already sorted, the; 2745/// optional argument v2_is_sorted can be used to toggle of the internal sorting; 2746/// step, therewith optimising runtime.; 2747///; 2748/// Example code, at the ROOT prompt:; 2749/// ~~~{.cpp}; 2750/// using namespace ROOT::VecOps;; 2751/// RVecD v1 {1., 2., 3.};; 2752/// RVecD v2 {-4., -5., 2., 1.};; 2753/// auto v1_intersect_v2 = Intersect(v1, v2);; 2754/// v1_intersect_v2; 2755/// // (ROOT::VecOps::RVec<double> &) { 1.0000000, 2.0000000 }; 2756/// ~~~; 2757template <typename T>; 2758RVec<T> Intersect(const RVec<T>& v1, const RVec<T>& v2, bool v2_is_sorted = false); 2759{; 2760 RVec<T> v2_sorted;; 2761 if (!v2_is_sorted) v2_sorted = Sort(v2);; 2762 const auto v2_begin = v2_is_sorted ? v2.begin() : v2_sorted.begin();; 2763 const auto v2_end = v2_is_sorted ? v2.end() : v2_sorted.end();; 2764 RVec<T> r;; 2765 const auto size = v1.size();; 2766 r.reserve(size);; 2767 using size_type = typename RVec<T>::size_type;; 2768 for(size_type i=0; i<size; i++) {; 2769 if (std::binary_search(v2_begin, v2_end, v1[i])) {; 2770 r.emplace_bac",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:113117,Deployability,update,update,113117,"// The function computes the invariant mass of multiple particles with the; 3166/// four-vectors (pt, eta, phi, mass).; 3167template <typename T0, typename T1 = T0, typename T2 = T0, typename T3 = T0, typename Common_t = std::common_type_t<T0, T1, T2, T3>>; 3168Common_t InvariantMass(const RVec<T0>& pt, const RVec<T1>& eta, const RVec<T2>& phi, const RVec<T3>& mass); 3169{; 3170 const std::size_t size = pt.size();; 3171 ; 3172 R__ASSERT(eta.size() == size && phi.size() == size && mass.size() == size);; 3173 ; 3174 Common_t x_sum = 0.;; 3175 Common_t y_sum = 0.;; 3176 Common_t z_sum = 0.;; 3177 Common_t e_sum = 0.;; 3178 ; 3179 for (std::size_t i = 0u; i < size; ++ i) {; 3180 // Convert to (e, x, y, z) coordinate system and update sums; 3181 const auto x = pt[i] * std::cos(phi[i]);; 3182 x_sum += x;; 3183 const auto y = pt[i] * std::sin(phi[i]);; 3184 y_sum += y;; 3185 const auto z = pt[i] * std::sinh(eta[i]);; 3186 z_sum += z;; 3187 const auto e = std::sqrt(x * x + y * y + z * z + mass[i] * mass[i]);; 3188 e_sum += e;; 3189 }; 3190 ; 3191 // Return invariant mass with (+, -, -, -) metric; 3192 return std::sqrt(e_sum * e_sum - x_sum * x_sum - y_sum * y_sum - z_sum * z_sum);; 3193}; 3194 ; 3195////////////////////////////////////////////////////////////////////////////; 3196/// \brief Build an RVec of objects starting from RVecs of input to their constructors.; 3197/// \tparam T Type of the objects contained in the created RVec.; 3198/// \tparam Args_t Pack of types templating the input RVecs.; 3199/// \param[in] args The RVecs containing the values used to initialise the output objects.; 3200/// \return The RVec of objects initialised with the input parameters.; 3201///; 3202/// Example code, at the ROOT prompt:; 3203/// ~~~{.cpp}; 3204/// using namespace ROOT::VecOps;; 3205/// RVecF pts = {15.5, 34.32, 12.95};; 3206/// RVecF etas = {0.3, 2.2, 1.32};; 3207/// RVecF phis = {0.1, 3.02, 2.2};; 3208/// RVecF masses = {105.65, 105.65, 105.65};; 3209/// auto fourVecs = Con",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:149136,Deployability,integrat,integration,149136,"::RVec::RVecRVec(std::initializer_list< T > IL)Definition RVec.hxx:1555; ROOT::VecOps::RVec::const_referencetypename SuperClass::const_reference const_referenceDefinition RVec.hxx:1536; ROOT::VecOps::RVec::RVecRVec()Definition RVec.hxx:1542; ROOT::VecOps::RVec::RVecRVec(size_t Size)Definition RVec.hxx:1546; ROOT::VecOps::RVec::RVecRVec(ItTy S, ItTy E)Definition RVec.hxx:1551; ROOT::VecOps::RVec::RVecRVec(const std::vector< T > &RHS)Definition RVec.hxx:1581; ROOT::VecOps::RVec::size_typetypename SuperClass::size_type size_typeDefinition RVec.hxx:1537; ROOT::VecOps::RVec::RVecRVec(Detail::VecOps::RVecImpl< T > &&RHS)Definition RVec.hxx:1573; ROOT::VecOps::RVec::RVecRVec(RVec &&RHS)Definition RVec.hxx:1565; ROOT::VecOps::RVec::value_typetypename SuperClass::value_type value_typeDefinition RVec.hxx:1538; ROOT::VecOps::RVec::operator=RVec & operator=(const RVec &RHS)Definition RVec.hxx:1559; R; double; ptTPaveText * ptDefinition entrylist_figure1.C:7; ROOT::Math::IntegrationOneDim::TypeTypeenumeration specifying the integration types.Definition AllIntegrationTypes.h:32; ROOT::VecOps::ReverseRVec< T > Reverse(const RVec< T > &v)Return copy of reversed vector.Definition RVec.hxx:2481; ROOT::VecOps::IntersectRVec< T > Intersect(const RVec< T > &v1, const RVec< T > &v2, bool v2_is_sorted=false)Return the intersection of elements of two RVecs.Definition RVec.hxx:2758; ROOT::VecOps::NonzeroRVec< typename RVec< T >::size_type > Nonzero(const RVec< T > &v)Return the indices of the elements which are not zero.Definition RVec.hxx:2727; RVEC_UNARY_OPERATOR#define RVEC_UNARY_OPERATOR(OP)Definition RVec.hxx:1616; RVEC_ASSIGNMENT_OPERATOR#define RVEC_ASSIGNMENT_OPERATOR(OP)Definition RVec.hxx:1687; ROOT::VecOps::StableArgsortRVec< typename RVec< T >::size_type > StableArgsort(const RVec< T > &v)Return an RVec of indices that sort the input RVec while keeping the order of equal elements.Definition RVec.hxx:2295; ROOT::VecOps::ConcatenateRVec< Common_t > Concatenate(const RVec< T0 > &v0,",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:270,Energy Efficiency,adapt,adapted,270,". ROOT: math/vecops/inc/ROOT/RVec.hxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. RVec.hxx. Go to the documentation of this file. 1// Author: Enrico Guiraud, Enric Tejedor, Danilo Piparo CERN 04/2021; 2// Implementation adapted from from llvm::SmallVector.; 3// See /math/vecops/ARCHITECTURE.md for more information.; 4 ; 5/*************************************************************************; 6 * Copyright (C) 1995-2021, Rene Brun and Fons Rademakers. *; 7 * All rights reserved. *; 8 * *; 9 * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 *************************************************************************/; 12 ; 13#ifndef ROOT_RVEC; 14#define ROOT_RVEC; 15 ; 16#if __cplusplus > 201402L; 17#define R__RVEC_NODISCARD [[nodiscard]]; 18#else; 19#define R__RVEC_NODISCARD; 20#endif; 21 ; 22#ifdef _WIN32; 23 #ifndef M_PI; 24 #ifndef _USE_MATH_DEFINES; 25 #define _USE_MATH_DEFINES; 26 #endif; 27 #include <math.h>; 28 #undef _USE_MATH_DEFINES; 29 #endif; 30 #define _VECOPS_USE_EXTERN_TEMPLATES false; 31#else; 32 #define _VECOPS_USE_EXTERN_TEMPLATES true; 33#endif; 34 ; 35#include <Rtypes.h> // R__CLING_PTRCHECK; 36#include <TError.h> // R__ASSERT; 37 ; 38#include <algorithm>; 39#include <cmath>; 40#include <cstring>; 41#include <limits> // for numeric_limits; 42#include <memory> // uninitialized_value_construct; 43#include <new>; 44#include <numeric> // for inner_product; 45#include <sstream>; 46#include <stdexcept>; 47#include <string>; 48#include <tuple>; 49#include <type_traits>; 50#include <utility>; 51#include <vector>; 52 ; 53#ifdef R__HAS_VDT; 54#include <vdt/vdtMath.h>; 55#endif; 56 ; 57 ; 58namespace ROOT {; 59 ; 60namespace VecOps {; 61template<typename T>; 62class RVec;; 63}; 64 ; 65namespace Internal {; 66namespace VecOps {; 67 ; 68template<typename T>; 69using RVec = ROOT::VecOps::RVec<T>;; 70 ; 71// clang-format off; 72template <typena",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:3525,Energy Efficiency,power,power,3525,"f (nArgs > 1) {; 93 for (auto i = 1UL; i < nArgs; i++) {; 94 if (sizes[0] == sizes[i]); 95 continue;; 96 std::string msg(id);; 97 msg += "": input RVec instances have different lengths!"";; 98 throw std::runtime_error(msg);; 99 }; 100 }; 101 return sizes[0];; 102}; 103 ; 104template <typename F, typename... RVecs>; 105auto MapImpl(F &&f, RVecs &&... vs) -> RVec<decltype(f(vs[0]...))>; 106{; 107 const auto size = GetVectorsSize(""Map"", vs...);; 108 RVec<decltype(f(vs[0]...))> ret(size);; 109 ; 110 for (auto i = 0UL; i < size; i++); 111 ret[i] = f(vs[i]...);; 112 ; 113 return ret;; 114}; 115 ; 116template <typename Tuple_t, std::size_t... Is>; 117auto MapFromTuple(Tuple_t &&t, std::index_sequence<Is...>); 118 -> decltype(MapImpl(std::get<std::tuple_size<Tuple_t>::value - 1>(t), std::get<Is>(t)...)); 119{; 120 constexpr const auto tupleSizeM1 = std::tuple_size<Tuple_t>::value - 1;; 121 return MapImpl(std::get<tupleSizeM1>(t), std::get<Is>(t)...);; 122}; 123 ; 124/// Return the next power of two (in 64-bits) that is strictly greater than A.; 125/// Return zero on overflow.; 126inline uint64_t NextPowerOf2(uint64_t A); 127{; 128 A |= (A >> 1);; 129 A |= (A >> 2);; 130 A |= (A >> 4);; 131 A |= (A >> 8);; 132 A |= (A >> 16);; 133 A |= (A >> 32);; 134 return A + 1;; 135}; 136 ; 137/// This is all the stuff common to all SmallVectors.; 138class R__CLING_PTRCHECK(off) SmallVectorBase {; 139public:; 140 // This limits the maximum size of an RVec<char> to ~4GB but we don't expect this to ever be a problem,; 141 // and we prefer the smaller Size_T to reduce the size of each RVec object.; 142 using Size_T = int32_t;; 143 ; 144protected:; 145 void *fBeginX;; 146 /// Always >= 0.; 147 // Type is signed only for consistency with fCapacity.; 148 Size_T fSize = 0;; 149 /// Always >= -1. fCapacity == -1 indicates the RVec is in ""memory adoption"" mode.; 150 Size_T fCapacity;; 151 ; 152 /// The maximum value of the Size_T used.; 153 static constexpr size_t SizeTypeMax() { return std::numeric",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:4095,Energy Efficiency,reduce,reduce,4095,"...))> ret(size);; 109 ; 110 for (auto i = 0UL; i < size; i++); 111 ret[i] = f(vs[i]...);; 112 ; 113 return ret;; 114}; 115 ; 116template <typename Tuple_t, std::size_t... Is>; 117auto MapFromTuple(Tuple_t &&t, std::index_sequence<Is...>); 118 -> decltype(MapImpl(std::get<std::tuple_size<Tuple_t>::value - 1>(t), std::get<Is>(t)...)); 119{; 120 constexpr const auto tupleSizeM1 = std::tuple_size<Tuple_t>::value - 1;; 121 return MapImpl(std::get<tupleSizeM1>(t), std::get<Is>(t)...);; 122}; 123 ; 124/// Return the next power of two (in 64-bits) that is strictly greater than A.; 125/// Return zero on overflow.; 126inline uint64_t NextPowerOf2(uint64_t A); 127{; 128 A |= (A >> 1);; 129 A |= (A >> 2);; 130 A |= (A >> 4);; 131 A |= (A >> 8);; 132 A |= (A >> 16);; 133 A |= (A >> 32);; 134 return A + 1;; 135}; 136 ; 137/// This is all the stuff common to all SmallVectors.; 138class R__CLING_PTRCHECK(off) SmallVectorBase {; 139public:; 140 // This limits the maximum size of an RVec<char> to ~4GB but we don't expect this to ever be a problem,; 141 // and we prefer the smaller Size_T to reduce the size of each RVec object.; 142 using Size_T = int32_t;; 143 ; 144protected:; 145 void *fBeginX;; 146 /// Always >= 0.; 147 // Type is signed only for consistency with fCapacity.; 148 Size_T fSize = 0;; 149 /// Always >= -1. fCapacity == -1 indicates the RVec is in ""memory adoption"" mode.; 150 Size_T fCapacity;; 151 ; 152 /// The maximum value of the Size_T used.; 153 static constexpr size_t SizeTypeMax() { return std::numeric_limits<Size_T>::max(); }; 154 ; 155 SmallVectorBase() = delete;; 156 SmallVectorBase(void *FirstEl, size_t TotalCapacity) : fBeginX(FirstEl), fCapacity(TotalCapacity) {}; 157 ; 158 /// This is an implementation of the grow() method which only works; 159 /// on POD-like data types and is out of line to reduce code duplication.; 160 /// This function will report a fatal error if it cannot increase capacity.; 161 void grow_pod(void *FirstEl, size_t MinSize, size_t TSi",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:4839,Energy Efficiency,reduce,reduce,4839,"{; 128 A |= (A >> 1);; 129 A |= (A >> 2);; 130 A |= (A >> 4);; 131 A |= (A >> 8);; 132 A |= (A >> 16);; 133 A |= (A >> 32);; 134 return A + 1;; 135}; 136 ; 137/// This is all the stuff common to all SmallVectors.; 138class R__CLING_PTRCHECK(off) SmallVectorBase {; 139public:; 140 // This limits the maximum size of an RVec<char> to ~4GB but we don't expect this to ever be a problem,; 141 // and we prefer the smaller Size_T to reduce the size of each RVec object.; 142 using Size_T = int32_t;; 143 ; 144protected:; 145 void *fBeginX;; 146 /// Always >= 0.; 147 // Type is signed only for consistency with fCapacity.; 148 Size_T fSize = 0;; 149 /// Always >= -1. fCapacity == -1 indicates the RVec is in ""memory adoption"" mode.; 150 Size_T fCapacity;; 151 ; 152 /// The maximum value of the Size_T used.; 153 static constexpr size_t SizeTypeMax() { return std::numeric_limits<Size_T>::max(); }; 154 ; 155 SmallVectorBase() = delete;; 156 SmallVectorBase(void *FirstEl, size_t TotalCapacity) : fBeginX(FirstEl), fCapacity(TotalCapacity) {}; 157 ; 158 /// This is an implementation of the grow() method which only works; 159 /// on POD-like data types and is out of line to reduce code duplication.; 160 /// This function will report a fatal error if it cannot increase capacity.; 161 void grow_pod(void *FirstEl, size_t MinSize, size_t TSize);; 162 ; 163 /// Report that MinSize doesn't fit into this vector's size type. Throws; 164 /// std::length_error or calls report_fatal_error.; 165 static void report_size_overflow(size_t MinSize);; 166 /// Report that this vector is already at maximum capacity. Throws; 167 /// std::length_error or calls report_fatal_error.; 168 static void report_at_maximum_capacity();; 169 ; 170 /// If false, the RVec is in ""memory adoption"" mode, i.e. it is acting as a view on a memory buffer it does not own.; 171 bool Owns() const { return fCapacity != -1; }; 172 ; 173public:; 174 size_t size() const { return fSize; }; 175 size_t capacity() const noexcept { return ",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:7766,Energy Efficiency,allocate,allocated,7766,"orBase)];; 201 alignas(T) char FirstEl[sizeof(T)];; 202};; 203 ; 204/// This is the part of SmallVectorTemplateBase which does not depend on whether the type T is a POD.; 205template <typename T>; 206class R__CLING_PTRCHECK(off) SmallVectorTemplateCommon : public SmallVectorBase {; 207 using Base = SmallVectorBase;; 208 ; 209 /// Find the address of the first element. For this pointer math to be valid; 210 /// with small-size of 0 for T with lots of alignment, it's important that; 211 /// SmallVectorStorage is properly-aligned even for small-size of 0.; 212 void *getFirstEl() const; 213 {; 214 return const_cast<void *>(reinterpret_cast<const void *>(reinterpret_cast<const char *>(this) +; 215 offsetof(SmallVectorAlignmentAndSize<T>, FirstEl)));; 216 }; 217 // Space after 'FirstEl' is clobbered, do not add any instance vars after it.; 218 ; 219protected:; 220 SmallVectorTemplateCommon(size_t Size) : Base(getFirstEl(), Size) {}; 221 ; 222 void grow_pod(size_t MinSize, size_t TSize) { Base::grow_pod(getFirstEl(), MinSize, TSize); }; 223 ; 224 /// Return true if this is a smallvector which has not had dynamic; 225 /// memory allocated for it.; 226 bool isSmall() const { return this->fBeginX == getFirstEl(); }; 227 ; 228 /// Put this vector in a state of being small.; 229 void resetToSmall(); 230 {; 231 this->fBeginX = getFirstEl();; 232 // from the original LLVM implementation:; 233 // FIXME: Setting fCapacity to 0 is suspect.; 234 this->fSize = this->fCapacity = 0;; 235 }; 236 ; 237public:; 238 // note that fSize is a _signed_ integer, but we expose it as an unsigned integer for consistency with STL containers; 239 // as well as backward-compatibility; 240 using size_type = size_t;; 241 using difference_type = ptrdiff_t;; 242 using value_type = T;; 243 using iterator = T *;; 244 using const_iterator = const T *;; 245 ; 246 using const_reverse_iterator = std::reverse_iterator<const_iterator>;; 247 using reverse_iterator = std::reverse_iterator<iterator>;; 248 ; 249 usin",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:12785,Energy Efficiency,allocate,allocated,12785,"_constructible<T>::value) &&; 327 std::is_trivially_destructible<T>::value>; 328class R__CLING_PTRCHECK(off) SmallVectorTemplateBase : public SmallVectorTemplateCommon<T> {; 329protected:; 330 SmallVectorTemplateBase(size_t Size) : SmallVectorTemplateCommon<T>(Size) {}; 331 ; 332 static void destroy_range(T *S, T *E); 333 {; 334 while (S != E) {; 335 --E;; 336 E->~T();; 337 }; 338 }; 339 ; 340 /// Move the range [I, E) into the uninitialized memory starting with ""Dest"",; 341 /// constructing elements as needed.; 342 template <typename It1, typename It2>; 343 static void uninitialized_move(It1 I, It1 E, It2 Dest); 344 {; 345 std::uninitialized_copy(std::make_move_iterator(I), std::make_move_iterator(E), Dest);; 346 }; 347 ; 348 /// Copy the range [I, E) onto the uninitialized memory starting with ""Dest"",; 349 /// constructing elements as needed.; 350 template <typename It1, typename It2>; 351 static void uninitialized_copy(It1 I, It1 E, It2 Dest); 352 {; 353 std::uninitialized_copy(I, E, Dest);; 354 }; 355 ; 356 /// Grow the allocated memory (without initializing new elements), doubling; 357 /// the size of the allocated memory. Guarantees space for at least one more; 358 /// element, or MinSize more elements if specified.; 359 void grow(size_t MinSize = 0);; 360 ; 361public:; 362 void push_back(const T &Elt); 363 {; 364 if (R__unlikely(this->size() >= this->capacity())); 365 this->grow();; 366 ::new ((void *)this->end()) T(Elt);; 367 this->set_size(this->size() + 1);; 368 }; 369 ; 370 void push_back(T &&Elt); 371 {; 372 if (R__unlikely(this->size() >= this->capacity())); 373 this->grow();; 374 ::new ((void *)this->end()) T(::std::move(Elt));; 375 this->set_size(this->size() + 1);; 376 }; 377 ; 378 void pop_back(); 379 {; 380 this->set_size(this->size() - 1);; 381 this->end()->~T();; 382 }; 383};; 384 ; 385// Define this out-of-line to dissuade the C++ compiler from inlining it.; 386template <typename T, bool TriviallyCopyable>; 387void R__CLING_PTRCHECK(off) SmallVec",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:12873,Energy Efficiency,allocate,allocated,12873,"_constructible<T>::value) &&; 327 std::is_trivially_destructible<T>::value>; 328class R__CLING_PTRCHECK(off) SmallVectorTemplateBase : public SmallVectorTemplateCommon<T> {; 329protected:; 330 SmallVectorTemplateBase(size_t Size) : SmallVectorTemplateCommon<T>(Size) {}; 331 ; 332 static void destroy_range(T *S, T *E); 333 {; 334 while (S != E) {; 335 --E;; 336 E->~T();; 337 }; 338 }; 339 ; 340 /// Move the range [I, E) into the uninitialized memory starting with ""Dest"",; 341 /// constructing elements as needed.; 342 template <typename It1, typename It2>; 343 static void uninitialized_move(It1 I, It1 E, It2 Dest); 344 {; 345 std::uninitialized_copy(std::make_move_iterator(I), std::make_move_iterator(E), Dest);; 346 }; 347 ; 348 /// Copy the range [I, E) onto the uninitialized memory starting with ""Dest"",; 349 /// constructing elements as needed.; 350 template <typename It1, typename It2>; 351 static void uninitialized_copy(It1 I, It1 E, It2 Dest); 352 {; 353 std::uninitialized_copy(I, E, Dest);; 354 }; 355 ; 356 /// Grow the allocated memory (without initializing new elements), doubling; 357 /// the size of the allocated memory. Guarantees space for at least one more; 358 /// element, or MinSize more elements if specified.; 359 void grow(size_t MinSize = 0);; 360 ; 361public:; 362 void push_back(const T &Elt); 363 {; 364 if (R__unlikely(this->size() >= this->capacity())); 365 this->grow();; 366 ::new ((void *)this->end()) T(Elt);; 367 this->set_size(this->size() + 1);; 368 }; 369 ; 370 void push_back(T &&Elt); 371 {; 372 if (R__unlikely(this->size() >= this->capacity())); 373 this->grow();; 374 ::new ((void *)this->end()) T(::std::move(Elt));; 375 this->set_size(this->size() + 1);; 376 }; 377 ; 378 void pop_back(); 379 {; 380 this->set_size(this->size() - 1);; 381 this->end()->~T();; 382 }; 383};; 384 ; 385// Define this out-of-line to dissuade the C++ compiler from inlining it.; 386template <typename T, bool TriviallyCopyable>; 387void R__CLING_PTRCHECK(off) SmallVec",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:17281,Energy Efficiency,allocate,allocated,17281,"nto it as needed.; 448 template <typename It1, typename It2>; 449 static void uninitialized_copy(It1 I, It1 E, It2 Dest); 450 {; 451 // Arbitrary iterator types; just use the basic implementation.; 452 std::uninitialized_copy(I, E, Dest);; 453 }; 454 ; 455 /// Copy the range [I, E) onto the uninitialized memory; 456 /// starting with ""Dest"", constructing elements into it as needed.; 457 template <typename T1, typename T2>; 458 static void uninitialized_copy(; 459 T1 *I, T1 *E, T2 *Dest,; 460 typename std::enable_if<std::is_same<typename std::remove_const<T1>::type, T2>::value>::type * = nullptr); 461 {; 462 // Use memcpy for PODs iterated by pointers (which includes SmallVector; 463 // iterators): std::uninitialized_copy optimizes to memmove, but we can; 464 // use memcpy here. Note that I and E are iterators and thus might be; 465 // invalid for memcpy if they are equal.; 466 if (I != E); 467 memcpy(reinterpret_cast<void *>(Dest), I, (E - I) * sizeof(T));; 468 }; 469 ; 470 /// Double the size of the allocated memory, guaranteeing space for at; 471 /// least one more element or MinSize if specified.; 472 void grow(size_t MinSize = 0); 473 {; 474 this->grow_pod(MinSize, sizeof(T));; 475 }; 476 ; 477public:; 478 using iterator = typename SuperClass::iterator;; 479 using const_iterator = typename SuperClass::const_iterator;; 480 using reference = typename SuperClass::reference;; 481 using size_type = typename SuperClass::size_type;; 482 ; 483 void push_back(const T &Elt); 484 {; 485 if (R__unlikely(this->size() >= this->capacity())); 486 this->grow();; 487 memcpy(reinterpret_cast<void *>(this->end()), &Elt, sizeof(T));; 488 this->set_size(this->size() + 1);; 489 }; 490 ; 491 void pop_back() { this->set_size(this->size() - 1); }; 492};; 493 ; 494/// Storage for the SmallVector elements. This is specialized for the N=0 case; 495/// to avoid allocating unnecessary storage.; 496template <typename T, unsigned N>; 497struct SmallVectorStorage {; 498 alignas(T) char InlineElt",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:18642,Energy Efficiency,allocate,allocate,18642,"_type;; 482 ; 483 void push_back(const T &Elt); 484 {; 485 if (R__unlikely(this->size() >= this->capacity())); 486 this->grow();; 487 memcpy(reinterpret_cast<void *>(this->end()), &Elt, sizeof(T));; 488 this->set_size(this->size() + 1);; 489 }; 490 ; 491 void pop_back() { this->set_size(this->size() - 1); }; 492};; 493 ; 494/// Storage for the SmallVector elements. This is specialized for the N=0 case; 495/// to avoid allocating unnecessary storage.; 496template <typename T, unsigned N>; 497struct SmallVectorStorage {; 498 alignas(T) char InlineElts[N * sizeof(T)]{};; 499};; 500 ; 501/// We need the storage to be properly aligned even for small-size of 0 so that; 502/// the pointer math in \a SmallVectorTemplateCommon::getFirstEl() is; 503/// well-defined.; 504template <typename T>; 505struct alignas(T) SmallVectorStorage<T, 0> {; 506};; 507 ; 508/// The size of the inline storage of an RVec.; 509/// Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline); 510/// unless the size of the buffer with 8 elements would be over a certain maximum size.; 511template <typename T>; 512struct RVecInlineStorageSize {; 513private:; 514#ifdef R__HAS_HARDWARE_INTERFERENCE_SIZE; 515 static constexpr std::size_t cacheLineSize = std::hardware_destructive_interference_size;; 516#else; 517 // safe bet: assume the typical 64 bytes; 518 static constexpr std::size_t cacheLineSize = 64;; 519#endif; 520 static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);; 521 static constexpr unsigned maxInlineByteSize = 1024;; 522 ; 523public:; 524 static constexpr unsigned value =; 525 elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8);; 526};; 527 ; 528// A C++14-compatible implementation of std::uninitialized_value_construct; 529template <typename ForwardIt>; 530void UninitializedValueConstruct(ForwardIt first, ForwardIt last); 531{; 532#if __cplusplus < 201703L; 533 for (; f",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:20594,Energy Efficiency,reduce,reduce,20594,"tion of std::uninitialized_value_construct; 529template <typename ForwardIt>; 530void UninitializedValueConstruct(ForwardIt first, ForwardIt last); 531{; 532#if __cplusplus < 201703L; 533 for (; first != last; ++first); 534 new (static_cast<void *>(std::addressof(*first))) typename std::iterator_traits<ForwardIt>::value_type();; 535#else; 536 std::uninitialized_value_construct(first, last);; 537#endif; 538}; 539 ; 540/// An unsafe function to reset the buffer for which this RVec is acting as a view.; 541///; 542/// \note This is a low-level method that _must_ be called on RVecs that are already non-owning:; 543/// - it does not put the RVec in ""non-owning mode"" (fCapacity == -1); 544/// - it does not free any owned buffer; 545template <typename T>; 546void ResetView(RVec<T> &v, T* addr, std::size_t sz); 547{; 548 v.fBeginX = addr;; 549 v.fSize = sz;; 550}; 551 ; 552} // namespace VecOps; 553} // namespace Internal; 554 ; 555namespace Detail {; 556namespace VecOps {; 557 ; 558/// This class consists of common code factored out of the SmallVector class to; 559/// reduce code duplication based on the SmallVector 'N' template parameter.; 560template <typename T>; 561class R__CLING_PTRCHECK(off) RVecImpl : public Internal::VecOps::SmallVectorTemplateBase<T> {; 562 using SuperClass = Internal::VecOps::SmallVectorTemplateBase<T>;; 563 ; 564public:; 565 using iterator = typename SuperClass::iterator;; 566 using const_iterator = typename SuperClass::const_iterator;; 567 using reference = typename SuperClass::reference;; 568 using size_type = typename SuperClass::size_type;; 569 ; 570protected:; 571 // Default ctor - Initialize to empty.; 572 explicit RVecImpl(unsigned N) : ROOT::Internal::VecOps::SmallVectorTemplateBase<T>(N) {}; 573 ; 574public:; 575 RVecImpl(const RVecImpl &) = delete;; 576 ; 577 ~RVecImpl(); 578 {; 579 // Subclass has already destructed this vector's elements.; 580 // If this wasn't grown from the inline copy, deallocate the old space.; 581 if (!this->isS",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:33244,Energy Efficiency,efficient,efficient,33244,"; 916 ; 917 void insert(iterator I, std::initializer_list<T> IL) { insert(I, IL.begin(), IL.end()); }; 918 ; 919 template <typename... ArgTypes>; 920 reference emplace_back(ArgTypes &&...Args); 921 {; 922 if (R__unlikely(this->size() >= this->capacity())); 923 this->grow();; 924 ::new ((void *)this->end()) T(std::forward<ArgTypes>(Args)...);; 925 this->set_size(this->size() + 1);; 926 return this->back();; 927 }; 928 ; 929 RVecImpl &operator=(const RVecImpl &RHS);; 930 ; 931 RVecImpl &operator=(RVecImpl &&RHS);; 932};; 933 ; 934template <typename T>; 935void RVecImpl<T>::swap(RVecImpl<T> &RHS); 936{; 937 if (this == &RHS); 938 return;; 939 ; 940 // We can only avoid copying elements if neither vector is small.; 941 if (!this->isSmall() && !RHS.isSmall()) {; 942 std::swap(this->fBeginX, RHS.fBeginX);; 943 std::swap(this->fSize, RHS.fSize);; 944 std::swap(this->fCapacity, RHS.fCapacity);; 945 return;; 946 }; 947 ; 948 // This block handles the swap of a small and a non-owning vector; 949 // It is more efficient to first move the non-owning vector, hence the 2 cases; 950 if (this->isSmall() && !RHS.Owns()) { // the right vector is non-owning; 951 RVecImpl<T> temp(0);; 952 temp = std::move(RHS);; 953 RHS = std::move(*this);; 954 *this = std::move(temp);; 955 return;; 956 } else if (RHS.isSmall() && !this->Owns()) { // the left vector is non-owning; 957 RVecImpl<T> temp(0);; 958 temp = std::move(*this);; 959 *this = std::move(RHS);; 960 RHS = std::move(temp);; 961 return;; 962 }; 963 ; 964 if (RHS.size() > this->capacity()); 965 this->grow(RHS.size());; 966 if (this->size() > RHS.capacity()); 967 RHS.grow(this->size());; 968 ; 969 // Swap the shared elements.; 970 size_t NumShared = this->size();; 971 if (NumShared > RHS.size()); 972 NumShared = RHS.size();; 973 for (size_type i = 0; i != NumShared; ++i); 974 std::iter_swap(this->begin() + i, RHS.begin() + i);; 975 ; 976 // Copy over the extra elts.; 977 if (this->size() > RHS.size()) {; 978 size_t EltDiff = this->size()",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:35856,Energy Efficiency,efficient,efficiently,35856,"991 }; 992}; 993 ; 994template <typename T>; 995RVecImpl<T> &RVecImpl<T>::operator=(const RVecImpl<T> &RHS); 996{; 997 // Avoid self-assignment.; 998 if (this == &RHS); 999 return *this;; 1000 ; 1001 // If we already have sufficient space, assign the common elements, then; 1002 // destroy any excess.; 1003 size_t RHSSize = RHS.size();; 1004 size_t CurSize = this->size();; 1005 if (CurSize >= RHSSize) {; 1006 // Assign common elements.; 1007 iterator NewEnd;; 1008 if (RHSSize); 1009 NewEnd = std::copy(RHS.begin(), RHS.begin() + RHSSize, this->begin());; 1010 else; 1011 NewEnd = this->begin();; 1012 ; 1013 // Destroy excess elements.; 1014 if (this->Owns()); 1015 this->destroy_range(NewEnd, this->end());; 1016 ; 1017 // Trim.; 1018 this->set_size(RHSSize);; 1019 return *this;; 1020 }; 1021 ; 1022 // If we have to grow to have enough elements, destroy the current elements.; 1023 // This allows us to avoid copying them during the grow.; 1024 // From the original LLVM implementation:; 1025 // FIXME: don't do this if they're efficiently moveable.; 1026 if (this->capacity() < RHSSize) {; 1027 if (this->Owns()) {; 1028 // Destroy current elements.; 1029 this->destroy_range(this->begin(), this->end());; 1030 }; 1031 this->set_size(0);; 1032 CurSize = 0;; 1033 this->grow(RHSSize);; 1034 } else if (CurSize) {; 1035 // Otherwise, use assignment for the already-constructed elements.; 1036 std::copy(RHS.begin(), RHS.begin() + CurSize, this->begin());; 1037 }; 1038 ; 1039 // Copy construct the new elements in place.; 1040 this->uninitialized_copy(RHS.begin() + CurSize, RHS.end(), this->begin() + CurSize);; 1041 ; 1042 // Set end.; 1043 this->set_size(RHSSize);; 1044 return *this;; 1045}; 1046 ; 1047template <typename T>; 1048RVecImpl<T> &RVecImpl<T>::operator=(RVecImpl<T> &&RHS); 1049{; 1050 // Avoid self-assignment.; 1051 if (this == &RHS); 1052 return *this;; 1053 ; 1054 // If the RHS isn't small, clear this vector and then steal its buffer.; 1055 if (!RHS.isSmall()) {; 1056 if (",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:37996,Energy Efficiency,efficient,efficiently,37996,"1061 this->fBeginX = RHS.fBeginX;; 1062 this->fSize = RHS.fSize;; 1063 this->fCapacity = RHS.fCapacity;; 1064 RHS.resetToSmall();; 1065 return *this;; 1066 }; 1067 ; 1068 // If we already have sufficient space, assign the common elements, then; 1069 // destroy any excess.; 1070 size_t RHSSize = RHS.size();; 1071 size_t CurSize = this->size();; 1072 if (CurSize >= RHSSize) {; 1073 // Assign common elements.; 1074 iterator NewEnd = this->begin();; 1075 if (RHSSize); 1076 NewEnd = std::move(RHS.begin(), RHS.end(), NewEnd);; 1077 ; 1078 // Destroy excess elements and trim the bounds.; 1079 if (this->Owns()); 1080 this->destroy_range(NewEnd, this->end());; 1081 this->set_size(RHSSize);; 1082 ; 1083 // Clear the RHS.; 1084 RHS.clear();; 1085 ; 1086 return *this;; 1087 }; 1088 ; 1089 // If we have to grow to have enough elements, destroy the current elements.; 1090 // This allows us to avoid copying them during the grow.; 1091 // From the original LLVM implementation:; 1092 // FIXME: this may not actually make any sense if we can efficiently move; 1093 // elements.; 1094 if (this->capacity() < RHSSize) {; 1095 if (this->Owns()) {; 1096 // Destroy current elements.; 1097 this->destroy_range(this->begin(), this->end());; 1098 }; 1099 this->set_size(0);; 1100 CurSize = 0;; 1101 this->grow(RHSSize);; 1102 } else if (CurSize) {; 1103 // Otherwise, use assignment for the already-constructed elements.; 1104 std::move(RHS.begin(), RHS.begin() + CurSize, this->begin());; 1105 }; 1106 ; 1107 // Move-construct the new elements in place.; 1108 this->uninitialized_move(RHS.begin() + CurSize, RHS.end(), this->begin() + CurSize);; 1109 ; 1110 // Set end.; 1111 this->set_size(RHSSize);; 1112 ; 1113 RHS.clear();; 1114 return *this;; 1115}; 1116 ; 1117template <typename T>; 1118bool IsSmall(const ROOT::VecOps::RVec<T> &v); 1119{; 1120 return v.isSmall();; 1121}; 1122 ; 1123template <typename T>; 1124bool IsAdopting(const ROOT::VecOps::RVec<T> &v); 1125{; 1126 return !v.Owns();; 1127}; 1128 ;",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:47835,Energy Efficiency,charge,charge,47835," object in an invalid state.; 1349 ; 1350\note RVec methods (e.g. `at` or `size`) follow the STL naming convention instead of the ROOT naming convention in order; 1351to make RVec a drop-in replacement for `std::vector`.; 1352 ; 1353\htmlonly; 1354<a href=""https://doi.org/10.5281/zenodo.1253756""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.1253756.svg"" alt=""DOI""></a>; 1355\endhtmlonly; 1356 ; 1357## Table of Contents; 1358- [Example](\ref example); 1359- [Arithmetic operations, logical operations and mathematical functions](\ref operationsandfunctions); 1360- [Owning and adopting memory](\ref owningandadoptingmemory); 1361- [Sorting and manipulation of indices](\ref sorting); 1362- [Usage in combination with RDataFrame](\ref usagetdataframe); 1363- [Reference for the RVec class](\ref RVecdoxyref); 1364- [Reference for RVec helper functions](https://root.cern/doc/master/namespaceROOT_1_1VecOps.html); 1365 ; 1366\anchor example; 1367## Example; 1368Suppose to have an event featuring a collection of muons with a certain pseudorapidity,; 1369momentum and charge, e.g.:; 1370~~~{.cpp}; 1371std::vector<short> mu_charge {1, 1, -1, -1, -1, 1, 1, -1};; 1372std::vector<float> mu_pt {56, 45, 32, 24, 12, 8, 7, 6.2};; 1373std::vector<float> mu_eta {3.1, -.2, -1.1, 1, 4.1, 1.6, 2.4, -.5};; 1374~~~; 1375Suppose you want to extract the transverse momenta of the muons satisfying certain; 1376criteria, for example consider only negatively charged muons with a pseudorapidity; 1377smaller or equal to 2 and with a transverse momentum greater than 10 GeV.; 1378Such a selection would require, among the other things, the management of an explicit; 1379loop, for example:; 1380~~~{.cpp}; 1381std::vector<float> goodMuons_pt;; 1382const auto size = mu_charge.size();; 1383for (size_t i=0; i < size; ++i) {; 1384 if (mu_pt[i] > 10 && abs(mu_eta[i]) <= 2. && mu_charge[i] == -1) {; 1385 goodMuons_pt.emplace_back(mu_pt[i]);; 1386 }; 1387}; 1388~~~; 1389These operations become straightforward ",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:48212,Energy Efficiency,charge,charged,48212,"58- [Example](\ref example); 1359- [Arithmetic operations, logical operations and mathematical functions](\ref operationsandfunctions); 1360- [Owning and adopting memory](\ref owningandadoptingmemory); 1361- [Sorting and manipulation of indices](\ref sorting); 1362- [Usage in combination with RDataFrame](\ref usagetdataframe); 1363- [Reference for the RVec class](\ref RVecdoxyref); 1364- [Reference for RVec helper functions](https://root.cern/doc/master/namespaceROOT_1_1VecOps.html); 1365 ; 1366\anchor example; 1367## Example; 1368Suppose to have an event featuring a collection of muons with a certain pseudorapidity,; 1369momentum and charge, e.g.:; 1370~~~{.cpp}; 1371std::vector<short> mu_charge {1, 1, -1, -1, -1, 1, 1, -1};; 1372std::vector<float> mu_pt {56, 45, 32, 24, 12, 8, 7, 6.2};; 1373std::vector<float> mu_eta {3.1, -.2, -1.1, 1, 4.1, 1.6, 2.4, -.5};; 1374~~~; 1375Suppose you want to extract the transverse momenta of the muons satisfying certain; 1376criteria, for example consider only negatively charged muons with a pseudorapidity; 1377smaller or equal to 2 and with a transverse momentum greater than 10 GeV.; 1378Such a selection would require, among the other things, the management of an explicit; 1379loop, for example:; 1380~~~{.cpp}; 1381std::vector<float> goodMuons_pt;; 1382const auto size = mu_charge.size();; 1383for (size_t i=0; i < size; ++i) {; 1384 if (mu_pt[i] > 10 && abs(mu_eta[i]) <= 2. && mu_charge[i] == -1) {; 1385 goodMuons_pt.emplace_back(mu_pt[i]);; 1386 }; 1387}; 1388~~~; 1389These operations become straightforward with RVec - we just need to *write what; 1390we mean*:; 1391~~~{.cpp}; 1392auto goodMuons_pt = mu_pt[ (mu_pt > 10.f && abs(mu_eta) <= 2.f && mu_charge == -1) ]; 1393~~~; 1394Now the clean collection of transverse momenta can be used within the rest of the data analysis, for; 1395example to fill a histogram.; 1396 ; 1397\anchor operationsandfunctions; 1398## Arithmetic operations, logical operations and mathematical functions; 139",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:51047,Energy Efficiency,allocate,allocated,51047,", asinh, acosh; 1425 - erf, erfc; 1426 - lgamma, tgamma; 1427 ; 1428If the VDT library is available, the following functions can be invoked. Internally the calculations; 1429are vectorized:; 1430 - fast_expf, fast_logf, fast_sinf, fast_cosf, fast_tanf, fast_asinf, fast_acosf, fast_atanf; 1431 - fast_exp, fast_log, fast_sin, fast_cos, fast_tan, fast_asin, fast_acos, fast_atan; 1432 ; 1433\anchor owningandadoptingmemory; 1434## Owning and adopting memory; 1435RVec has contiguous memory associated to it. It can own it or simply adopt it. In the latter case,; 1436it can be constructed with the address of the memory associated to it and its length. For example:; 1437~~~{.cpp}; 1438std::vector<int> myStlVec {1,2,3};; 1439RVec<int> myRVec(myStlVec.data(), myStlVec.size());; 1440~~~; 1441In this case, the memory associated to myStlVec and myRVec is the same, myRVec simply ""adopted it"".; 1442If any method which implies a re-allocation is called, e.g. *emplace_back* or *resize*, the adopted; 1443memory is released and new one is allocated. The previous content is copied in the new memory and; 1444preserved.; 1445 ; 1446\anchor sorting; 1447## Sorting and manipulation of indices; 1448 ; 1449### Sorting; 1450RVec complies to the STL interfaces when it comes to iterations. As a result, standard algorithms; 1451can be used, for example sorting:; 1452~~~{.cpp}; 1453RVec<double> v{6., 4., 5.};; 1454std::sort(v.begin(), v.end());; 1455~~~; 1456 ; 1457For convenience, helpers are provided too:; 1458~~~{.cpp}; 1459auto sorted_v = Sort(v);; 1460auto reversed_v = Reverse(v);; 1461~~~; 1462 ; 1463### Manipulation of indices; 1464 ; 1465It is also possible to manipulated the RVecs acting on their indices. For example,; 1466the following syntax; 1467~~~{.cpp}; 1468RVecD v0 {9., 7., 8.};; 1469auto v1 = Take(v0, {1, 2, 0});; 1470~~~; 1471will yield a new RVec<double> the content of which is the first, second and zeroth element of; 1472v0, i.e. `{7., 8., 9.}`.; 1473 ; 1474The `Argsort` and `S",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:53552,Energy Efficiency,energy,energy,53552,"ract portions of the `RVec`. The content to be *taken*; 1482can be specified with an `RVec` of indices or an integer. If the integer is negative,; 1483elements will be picked starting from the end of the container:; 1484~~~{.cpp}; 1485RVecF vf {1.f, 2.f, 3.f, 4.f};; 1486auto vf_1 = Take(vf, {1, 3}); // The content is {2.f, 4.f}; 1487auto vf_2 = Take(vf, 2); // The content is {1.f, 2.f}; 1488auto vf_3 = Take(vf, -3); // The content is {2.f, 3.f, 4.f}; 1489~~~; 1490 ; 1491\anchor usagetdataframe; 1492## Usage in combination with RDataFrame; 1493RDataFrame leverages internally RVecs. Suppose to have a dataset stored in a; 1494TTree which holds these columns (here we choose C arrays to represent the; 1495collections, they could be as well std::vector instances):; 1496~~~{.bash}; 1497 nPart ""nPart/I"" An integer representing the number of particles; 1498 px ""px[nPart]/D"" The C array of the particles' x component of the momentum; 1499 py ""py[nPart]/D"" The C array of the particles' y component of the momentum; 1500 E ""E[nPart]/D"" The C array of the particles' Energy; 1501~~~; 1502Suppose you'd like to plot in a histogram the transverse momenta of all particles; 1503for which the energy is greater than 200 MeV.; 1504The code required would just be:; 1505~~~{.cpp}; 1506RDataFrame d(""mytree"", ""myfile.root"");; 1507auto cutPt = [](RVecD &pxs, RVecD &pys, RVecD &Es) {; 1508 auto all_pts = sqrt(pxs * pxs + pys * pys);; 1509 auto good_pts = all_pts[Es > 200.];; 1510 return good_pts;; 1511 };; 1512 ; 1513auto hpt = d.Define(""pt"", cutPt, {""px"", ""py"", ""E""}); 1514 .Histo1D(""pt"");; 1515hpt->Draw();; 1516~~~; 1517And if you'd like to express your selection as a string:; 1518~~~{.cpp}; 1519RDataFrame d(""mytree"", ""myfile.root"");; 1520auto hpt = d.Define(""pt"", ""sqrt(pxs * pxs + pys * pys)[E>200]""); 1521 .Histo1D(""pt"");; 1522hpt->Draw();; 1523~~~; 1524\anchor RVecdoxyref; 1525**/; 1526// clang-format on; 1527 ; 1528template <typename T>; 1529class R__CLING_PTRCHECK(off) RVec : public RVecN<T",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:131272,Energy Efficiency,reduce,reduce,131272,"Style GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; free#define freeDefinition civetweb.c:1539; malloc#define mallocDefinition civetweb.c:1536; ROOT::Detail::VecOps::RVecImplThis class consists of common code factored out of the SmallVector class to reduce code duplication b...Definition RVec.hxx:561; ROOT::Detail::VecOps::RVecImpl::assignvoid assign(size_type NumElts, const T &Elt)Definition RVec.hxx:680; ROOT::Detail::VecOps::RVecImpl::iteratortypename SuperClass::iterator iteratorDefinition RVec.hxx:565; ROOT::Detail::VecOps::RVecImpl::size_typetypename SuperClass::size_type size_typeDefinition RVec.hxx:568; ROOT::Detail::VecOps::RVecImpl::appendvoid append(in_iter in_start, in_iter in_end)Add the specified range to the end of the SmallVector.Definition RVec.hxx:654; ROOT::Detail::VecOps::RVecImpl::insertiterator insert(iterator I, T &&Elt)Definition RVec.hxx:741; ROOT::Detail::VecOps::RVecImpl::resizevoid resize(size_type N)Definition RVec.hxx:596; ROOT::Detail::VecOps::RVecImpl::assignvoid assign(std::initializer_list< T > IL)Definition RVec.hxx:698; ROOT::Detail::VecOps::RVecImpl::const_iteratortypename SuperClass::const_iterator const_iteratorDefinition RVec.hxx:566; ROOT::Detail:",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:136257,Energy Efficiency,allocate,allocated,136257,"() constDefinition RVec.hxx:177; ROOT::Internal::VecOps::SmallVectorBase::fSizeSize_T fSizeAlways >= 0.Definition RVec.hxx:148; ROOT::Internal::VecOps::SmallVectorBase::Ownsbool Owns() constIf false, the RVec is in ""memory adoption"" mode, i.e. it is acting as a view on a memory buffer it do...Definition RVec.hxx:171; ROOT::Internal::VecOps::SmallVectorBase::capacitysize_t capacity() const noexceptDefinition RVec.hxx:175; ROOT::Internal::VecOps::SmallVectorBase::sizesize_t size() constDefinition RVec.hxx:174; ROOT::Internal::VecOps::SmallVectorBase::set_sizevoid set_size(size_t N)Set the array size to N, which the current array must have enough capacity for.Definition RVec.hxx:188; ROOT::Internal::VecOps::SmallVectorBase::fBeginXvoid * fBeginXDefinition RVec.hxx:145; ROOT::Internal::VecOps::SmallVectorTemplateBase< T, true >::iteratortypename SuperClass::iterator iteratorDefinition RVec.hxx:478; ROOT::Internal::VecOps::SmallVectorTemplateBase< T, true >::growvoid grow(size_t MinSize=0)Double the size of the allocated memory, guaranteeing space for at least one more element or MinSize ...Definition RVec.hxx:472; ROOT::Internal::VecOps::SmallVectorTemplateBase< T, true >::size_typetypename SuperClass::size_type size_typeDefinition RVec.hxx:481; ROOT::Internal::VecOps::SmallVectorTemplateBase< T, true >::referencetypename SuperClass::reference referenceDefinition RVec.hxx:480; ROOT::Internal::VecOps::SmallVectorTemplateBase< T, true >::push_backvoid push_back(const T &Elt)Definition RVec.hxx:483; ROOT::Internal::VecOps::SmallVectorTemplateBase< T, true >::pop_backvoid pop_back()Definition RVec.hxx:491; ROOT::Internal::VecOps::SmallVectorTemplateBase< T, true >::uninitialized_movestatic void uninitialized_move(It1 I, It1 E, It2 Dest)Move the range [I, E) onto the uninitialized memory starting with ""Dest"", constructing elements into ...Definition RVec.hxx:440; ROOT::Internal::VecOps::SmallVectorTemplateBase< T, true >::SmallVectorTemplateBaseSmallVectorTemplateBase(size_t",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:138759,Energy Efficiency,allocate,allocated,138759,"o ...Definition RVec.hxx:458; ROOT::Internal::VecOps::SmallVectorTemplateBase< T, true >::destroy_rangestatic void destroy_range(T *, T *)Definition RVec.hxx:435; ROOT::Internal::VecOps::SmallVectorTemplateBase< T, true >::uninitialized_copystatic void uninitialized_copy(It1 I, It1 E, It2 Dest)Copy the range [I, E) onto the uninitialized memory starting with ""Dest"", constructing elements into ...Definition RVec.hxx:449; ROOT::Internal::VecOps::SmallVectorTemplateBaseSmallVectorTemplateBase<TriviallyCopyable = false> - This is where we put method implementations that...Definition RVec.hxx:328; ROOT::Internal::VecOps::SmallVectorTemplateBase::pop_backvoid pop_back()Definition RVec.hxx:378; ROOT::Internal::VecOps::SmallVectorTemplateBase::push_backvoid push_back(T &&Elt)Definition RVec.hxx:370; ROOT::Internal::VecOps::SmallVectorTemplateBase::push_backvoid push_back(const T &Elt)Definition RVec.hxx:362; ROOT::Internal::VecOps::SmallVectorTemplateBase::growvoid grow(size_t MinSize=0)Grow the allocated memory (without initializing new elements), doubling the size of the allocated mem...; ROOT::Internal::VecOps::SmallVectorTemplateBase::uninitialized_movestatic void uninitialized_move(It1 I, It1 E, It2 Dest)Move the range [I, E) into the uninitialized memory starting with ""Dest"", constructing elements as ne...Definition RVec.hxx:343; ROOT::Internal::VecOps::SmallVectorTemplateBase::SmallVectorTemplateBaseSmallVectorTemplateBase(size_t Size)Definition RVec.hxx:330; ROOT::Internal::VecOps::SmallVectorTemplateBase::destroy_rangestatic void destroy_range(T *S, T *E)Definition RVec.hxx:332; ROOT::Internal::VecOps::SmallVectorTemplateBase::uninitialized_copystatic void uninitialized_copy(It1 I, It1 E, It2 Dest)Copy the range [I, E) onto the uninitialized memory starting with ""Dest"", constructing elements as ne...Definition RVec.hxx:351; ROOT::Internal::VecOps::SmallVectorTemplateCommonThis is the part of SmallVectorTemplateBase which does not depend on whether the type T is a PO",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:138838,Energy Efficiency,allocate,allocated,138838,"o ...Definition RVec.hxx:458; ROOT::Internal::VecOps::SmallVectorTemplateBase< T, true >::destroy_rangestatic void destroy_range(T *, T *)Definition RVec.hxx:435; ROOT::Internal::VecOps::SmallVectorTemplateBase< T, true >::uninitialized_copystatic void uninitialized_copy(It1 I, It1 E, It2 Dest)Copy the range [I, E) onto the uninitialized memory starting with ""Dest"", constructing elements into ...Definition RVec.hxx:449; ROOT::Internal::VecOps::SmallVectorTemplateBaseSmallVectorTemplateBase<TriviallyCopyable = false> - This is where we put method implementations that...Definition RVec.hxx:328; ROOT::Internal::VecOps::SmallVectorTemplateBase::pop_backvoid pop_back()Definition RVec.hxx:378; ROOT::Internal::VecOps::SmallVectorTemplateBase::push_backvoid push_back(T &&Elt)Definition RVec.hxx:370; ROOT::Internal::VecOps::SmallVectorTemplateBase::push_backvoid push_back(const T &Elt)Definition RVec.hxx:362; ROOT::Internal::VecOps::SmallVectorTemplateBase::growvoid grow(size_t MinSize=0)Grow the allocated memory (without initializing new elements), doubling the size of the allocated mem...; ROOT::Internal::VecOps::SmallVectorTemplateBase::uninitialized_movestatic void uninitialized_move(It1 I, It1 E, It2 Dest)Move the range [I, E) into the uninitialized memory starting with ""Dest"", constructing elements as ne...Definition RVec.hxx:343; ROOT::Internal::VecOps::SmallVectorTemplateBase::SmallVectorTemplateBaseSmallVectorTemplateBase(size_t Size)Definition RVec.hxx:330; ROOT::Internal::VecOps::SmallVectorTemplateBase::destroy_rangestatic void destroy_range(T *S, T *E)Definition RVec.hxx:332; ROOT::Internal::VecOps::SmallVectorTemplateBase::uninitialized_copystatic void uninitialized_copy(It1 I, It1 E, It2 Dest)Copy the range [I, E) onto the uninitialized memory starting with ""Dest"", constructing elements as ne...Definition RVec.hxx:351; ROOT::Internal::VecOps::SmallVectorTemplateCommonThis is the part of SmallVectorTemplateBase which does not depend on whether the type T is a PO",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:141667,Energy Efficiency,allocate,allocated,141667,T::Internal::VecOps::SmallVectorTemplateCommon::backconst_reference back() constDefinition RVec.hxx:308; ROOT::Internal::VecOps::SmallVectorTemplateCommon::const_pointerconst T * const_pointerDefinition RVec.hxx:252; ROOT::Internal::VecOps::SmallVectorTemplateCommon::resetToSmallvoid resetToSmall()Put this vector in a state of being small.Definition RVec.hxx:229; ROOT::Internal::VecOps::SmallVectorTemplateCommon::pointerT * pointerDefinition RVec.hxx:251; ROOT::Internal::VecOps::SmallVectorTemplateCommon::frontreference front()Definition RVec.hxx:284; ROOT::Internal::VecOps::SmallVectorTemplateCommon::beginiterator begin() noexceptDefinition RVec.hxx:259; ROOT::Internal::VecOps::SmallVectorTemplateCommon::reverse_iteratorstd::reverse_iterator< iterator > reverse_iteratorDefinition RVec.hxx:247; ROOT::Internal::VecOps::SmallVectorTemplateCommon::const_referenceconst T & const_referenceDefinition RVec.hxx:250; ROOT::Internal::VecOps::SmallVectorTemplateCommon::isSmallbool isSmall() constReturn true if this is a smallvector which has not had dynamic memory allocated for it.Definition RVec.hxx:226; ROOT::Internal::VecOps::SmallVectorTemplateCommon::value_typeT value_typeDefinition RVec.hxx:242; ROOT::Internal::VecOps::SmallVectorTemplateCommon::crendconst_reverse_iterator crend() const noexceptDefinition RVec.hxx:272; ROOT::Internal::VecOps::SmallVectorTemplateCommon::endconst_iterator end() const noexceptDefinition RVec.hxx:263; ROOT::Internal::VecOps::SmallVectorTemplateCommon::SmallVectorTemplateCommonSmallVectorTemplateCommon(size_t Size)Definition RVec.hxx:220; ROOT::Internal::VecOps::SmallVectorTemplateCommon::emptybool empty() constDefinition RVec.hxx:177; ROOT::Internal::VecOps::SmallVectorTemplateCommon::referenceT & referenceDefinition RVec.hxx:249; ROOT::Internal::VecOps::SmallVectorTemplateCommon::crbeginconst_reverse_iterator crbegin() const noexceptDefinition RVec.hxx:269; ROOT::Internal::VecOps::SmallVectorTemplateCommon::iteratorT * iteratorDefinition RV,MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:154983,Energy Efficiency,power,power,154983," yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; T2#define T2Definition md5.inl:147; T7#define T7Definition md5.inl:152; T6#define T6Definition md5.inl:151; T3#define T3Definition md5.inl:148; T5#define T5Definition md5.inl:150; T4#define T4Definition md5.inl:149; F#define F(x, y, z); I#define I(x, y, z); T1#define T1Definition md5.inl:146; ROOT::Detail::VecOps::IsSmallbool IsSmall(const ROOT::VecOps::RVec< T > &v)Definition RVec.hxx:1118; ROOT::Detail::VecOps::IsAdoptingbool IsAdopting(const ROOT::VecOps::RVec< T > &v)Definition RVec.hxx:1124; ROOT::Internal::VecOps::MapImplauto MapImpl(F &&f, RVecs &&... vs) -> RVec< decltype(f(vs[0]...))>Definition RVec.hxx:105; ROOT::Internal::VecOps::ResetViewvoid ResetView(RVec< T > &v, T *addr, std::size_t sz)An unsafe function to reset the buffer for which this RVec is acting as a view.Definition RVec.hxx:546; ROOT::Internal::VecOps::NextPowerOf2uint64_t NextPowerOf2(uint64_t A)Return the next power of two (in 64-bits) that is strictly greater than A.Definition RVec.hxx:126; ROOT::Internal::VecOps::Allconstexpr bool All(const bool *vals, std::size_t size)Definition RVec.hxx:79; ROOT::Internal::VecOps::GetVectorsSizestd::size_t GetVectorsSize(const std::string &id, const RVec< T > &... vs)Definition RVec.hxx:88; ROOT::Internal::VecOps::UninitializedValueConstructvoid UninitializedValueConstruct(ForwardIt first, ForwardIt last)Definition RVec.hxx:530; ROOT::Internal::VecOps::MapFromTupleauto MapFromTuple(Tuple_t &&t, std::index_sequence< Is... >) -> decltype(MapImpl(std::get< std::tuple_size< Tuple_t >::value - 1 >(t), std::get< Is >(t)...))Definition RVec.hxx:117; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; Dot#define Dot(u, v)Definition normal.c:49; v2@ v2Definition rootcling_impl.cxx:3702; v0@ v0Definition rootcling_impl.cxx:3700; v@ vDefinition rootcling_imp",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:6758,Integrability,depend,depend,6758,"() const { return fSize; }; 175 size_t capacity() const noexcept { return Owns() ? fCapacity : fSize; }; 176 ; 177 R__RVEC_NODISCARD bool empty() const { return !fSize; }; 178 ; 179 /// Set the array size to \p N, which the current array must have enough; 180 /// capacity for.; 181 ///; 182 /// This does not construct or destroy any elements in the vector.; 183 ///; 184 /// Clients can use this in conjunction with capacity() to write past the end; 185 /// of the buffer when they know that more elements are available, and only; 186 /// update the size later. This avoids the cost of value initializing elements; 187 /// which will only be overwritten.; 188 void set_size(size_t N); 189 {; 190 if (N > capacity()) {; 191 throw std::runtime_error(""Setting size to a value greater than capacity."");; 192 }; 193 fSize = N;; 194 }; 195};; 196 ; 197/// Used to figure out the offset of the first element of an RVec; 198template <class T>; 199struct SmallVectorAlignmentAndSize {; 200 alignas(SmallVectorBase) char Base[sizeof(SmallVectorBase)];; 201 alignas(T) char FirstEl[sizeof(T)];; 202};; 203 ; 204/// This is the part of SmallVectorTemplateBase which does not depend on whether the type T is a POD.; 205template <typename T>; 206class R__CLING_PTRCHECK(off) SmallVectorTemplateCommon : public SmallVectorBase {; 207 using Base = SmallVectorBase;; 208 ; 209 /// Find the address of the first element. For this pointer math to be valid; 210 /// with small-size of 0 for T with lots of alignment, it's important that; 211 /// SmallVectorStorage is properly-aligned even for small-size of 0.; 212 void *getFirstEl() const; 213 {; 214 return const_cast<void *>(reinterpret_cast<const void *>(reinterpret_cast<const char *>(this) +; 215 offsetof(SmallVectorAlignmentAndSize<T>, FirstEl)));; 216 }; 217 // Space after 'FirstEl' is clobbered, do not add any instance vars after it.; 218 ; 219protected:; 220 SmallVectorTemplateCommon(size_t Size) : Base(getFirstEl(), Size) {}; 221 ; 222 void grow_pod(s",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:45780,Integrability,interface,interface,45780," this->operator[](pos);; 1303 }; 1304 ; 1305 /// No exception thrown. The user specifies the desired value in case the RVecN is shorter than `pos`.; 1306 value_type at(size_type pos, value_type fallback); 1307 {; 1308 if (pos >= size_type(this->fSize)); 1309 return fallback;; 1310 return this->operator[](pos);; 1311 }; 1312 ; 1313 /// No exception thrown. The user specifies the desired value in case the RVecN is shorter than `pos`.; 1314 value_type at(size_type pos, value_type fallback) const; 1315 {; 1316 if (pos >= size_type(this->fSize)); 1317 return fallback;; 1318 return this->operator[](pos);; 1319 }; 1320};; 1321 ; 1322// clang-format off; 1323/**; 1324\class ROOT::VecOps::RVec; 1325\brief A ""std::vector""-like collection of values implementing handy operation to analyse them; 1326\tparam T The type of the contained objects; 1327 ; 1328A RVec is a container designed to make analysis of values' collections fast and easy.; 1329Its storage is contiguous in memory and its interface is designed such to resemble to the one; 1330of the stl vector. In addition the interface features methods and; 1331[external functions](https://root.cern/doc/master/namespaceROOT_1_1VecOps.html) to ease the manipulation and analysis; 1332of the data in the RVec.; 1333 ; 1334\note ROOT::VecOps::RVec can also be spelled simply ROOT::RVec. Shorthand aliases such as ROOT::RVecI or ROOT::RVecD; 1335are also available as template instantiations of RVec of fundamental types. The full list of available aliases:; 1336- RVecB (`bool`); 1337- RVecC (`char`); 1338- RVecD (`double`); 1339- RVecF (`float`); 1340- RVecI (`int`); 1341- RVecL (`long`); 1342- RVecLL (`long long`); 1343- RVecU (`unsigned`); 1344- RVecUL (`unsigned long`); 1345- RVecULL (`unsigned long long`); 1346 ; 1347\note RVec does not attempt to be exception safe. Exceptions thrown by element constructors during insertions, swaps or; 1348other operations will be propagated potentially leaving the RVec object in an invalid state.; 134",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:45870,Integrability,interface,interface,45870,"e in case the RVecN is shorter than `pos`.; 1306 value_type at(size_type pos, value_type fallback); 1307 {; 1308 if (pos >= size_type(this->fSize)); 1309 return fallback;; 1310 return this->operator[](pos);; 1311 }; 1312 ; 1313 /// No exception thrown. The user specifies the desired value in case the RVecN is shorter than `pos`.; 1314 value_type at(size_type pos, value_type fallback) const; 1315 {; 1316 if (pos >= size_type(this->fSize)); 1317 return fallback;; 1318 return this->operator[](pos);; 1319 }; 1320};; 1321 ; 1322// clang-format off; 1323/**; 1324\class ROOT::VecOps::RVec; 1325\brief A ""std::vector""-like collection of values implementing handy operation to analyse them; 1326\tparam T The type of the contained objects; 1327 ; 1328A RVec is a container designed to make analysis of values' collections fast and easy.; 1329Its storage is contiguous in memory and its interface is designed such to resemble to the one; 1330of the stl vector. In addition the interface features methods and; 1331[external functions](https://root.cern/doc/master/namespaceROOT_1_1VecOps.html) to ease the manipulation and analysis; 1332of the data in the RVec.; 1333 ; 1334\note ROOT::VecOps::RVec can also be spelled simply ROOT::RVec. Shorthand aliases such as ROOT::RVecI or ROOT::RVecD; 1335are also available as template instantiations of RVec of fundamental types. The full list of available aliases:; 1336- RVecB (`bool`); 1337- RVecC (`char`); 1338- RVecD (`double`); 1339- RVecF (`float`); 1340- RVecI (`int`); 1341- RVecL (`long`); 1342- RVecLL (`long long`); 1343- RVecU (`unsigned`); 1344- RVecUL (`unsigned long`); 1345- RVecULL (`unsigned long long`); 1346 ; 1347\note RVec does not attempt to be exception safe. Exceptions thrown by element constructors during insertions, swaps or; 1348other operations will be propagated potentially leaving the RVec object in an invalid state.; 1349 ; 1350\note RVec methods (e.g. `at` or `size`) follow the STL naming convention instead of the ROOT nam",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:51253,Integrability,interface,interfaces,51253," fast_expf, fast_logf, fast_sinf, fast_cosf, fast_tanf, fast_asinf, fast_acosf, fast_atanf; 1431 - fast_exp, fast_log, fast_sin, fast_cos, fast_tan, fast_asin, fast_acos, fast_atan; 1432 ; 1433\anchor owningandadoptingmemory; 1434## Owning and adopting memory; 1435RVec has contiguous memory associated to it. It can own it or simply adopt it. In the latter case,; 1436it can be constructed with the address of the memory associated to it and its length. For example:; 1437~~~{.cpp}; 1438std::vector<int> myStlVec {1,2,3};; 1439RVec<int> myRVec(myStlVec.data(), myStlVec.size());; 1440~~~; 1441In this case, the memory associated to myStlVec and myRVec is the same, myRVec simply ""adopted it"".; 1442If any method which implies a re-allocation is called, e.g. *emplace_back* or *resize*, the adopted; 1443memory is released and new one is allocated. The previous content is copied in the new memory and; 1444preserved.; 1445 ; 1446\anchor sorting; 1447## Sorting and manipulation of indices; 1448 ; 1449### Sorting; 1450RVec complies to the STL interfaces when it comes to iterations. As a result, standard algorithms; 1451can be used, for example sorting:; 1452~~~{.cpp}; 1453RVec<double> v{6., 4., 5.};; 1454std::sort(v.begin(), v.end());; 1455~~~; 1456 ; 1457For convenience, helpers are provided too:; 1458~~~{.cpp}; 1459auto sorted_v = Sort(v);; 1460auto reversed_v = Reverse(v);; 1461~~~; 1462 ; 1463### Manipulation of indices; 1464 ; 1465It is also possible to manipulated the RVecs acting on their indices. For example,; 1466the following syntax; 1467~~~{.cpp}; 1468RVecD v0 {9., 7., 8.};; 1469auto v1 = Take(v0, {1, 2, 0});; 1470~~~; 1471will yield a new RVec<double> the content of which is the first, second and zeroth element of; 1472v0, i.e. `{7., 8., 9.}`.; 1473 ; 1474The `Argsort` and `StableArgsort` helper extracts the indices which order the content of a `RVec`.; 1475For example, this snippet accomplishes in a more expressive way what we just achieved:; 1476~~~{.cpp}; 1477auto v",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:139721,Integrability,depend,depend,139721,"nal::VecOps::SmallVectorTemplateBase::growvoid grow(size_t MinSize=0)Grow the allocated memory (without initializing new elements), doubling the size of the allocated mem...; ROOT::Internal::VecOps::SmallVectorTemplateBase::uninitialized_movestatic void uninitialized_move(It1 I, It1 E, It2 Dest)Move the range [I, E) into the uninitialized memory starting with ""Dest"", constructing elements as ne...Definition RVec.hxx:343; ROOT::Internal::VecOps::SmallVectorTemplateBase::SmallVectorTemplateBaseSmallVectorTemplateBase(size_t Size)Definition RVec.hxx:330; ROOT::Internal::VecOps::SmallVectorTemplateBase::destroy_rangestatic void destroy_range(T *S, T *E)Definition RVec.hxx:332; ROOT::Internal::VecOps::SmallVectorTemplateBase::uninitialized_copystatic void uninitialized_copy(It1 I, It1 E, It2 Dest)Copy the range [I, E) onto the uninitialized memory starting with ""Dest"", constructing elements as ne...Definition RVec.hxx:351; ROOT::Internal::VecOps::SmallVectorTemplateCommonThis is the part of SmallVectorTemplateBase which does not depend on whether the type T is a POD.Definition RVec.hxx:206; ROOT::Internal::VecOps::SmallVectorTemplateCommon::max_sizesize_type max_size() const noexceptDefinition RVec.hxx:275; ROOT::Internal::VecOps::SmallVectorTemplateCommon::cbeginconst_iterator cbegin() const noexceptDefinition RVec.hxx:261; ROOT::Internal::VecOps::SmallVectorTemplateCommon::grow_podvoid grow_pod(size_t MinSize, size_t TSize)Definition RVec.hxx:222; ROOT::Internal::VecOps::SmallVectorTemplateCommon::difference_typeptrdiff_t difference_typeDefinition RVec.hxx:241; ROOT::Internal::VecOps::SmallVectorTemplateCommon::rbeginreverse_iterator rbegin() noexceptDefinition RVec.hxx:267; ROOT::Internal::VecOps::SmallVectorTemplateCommon::backreference back()Definition RVec.hxx:300; ROOT::Internal::VecOps::SmallVectorTemplateCommon::cendconst_iterator cend() const noexceptDefinition RVec.hxx:264; ROOT::Internal::VecOps::SmallVectorTemplateCommon::backconst_reference back() constDefin",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:149136,Integrability,integrat,integration,149136,"::RVec::RVecRVec(std::initializer_list< T > IL)Definition RVec.hxx:1555; ROOT::VecOps::RVec::const_referencetypename SuperClass::const_reference const_referenceDefinition RVec.hxx:1536; ROOT::VecOps::RVec::RVecRVec()Definition RVec.hxx:1542; ROOT::VecOps::RVec::RVecRVec(size_t Size)Definition RVec.hxx:1546; ROOT::VecOps::RVec::RVecRVec(ItTy S, ItTy E)Definition RVec.hxx:1551; ROOT::VecOps::RVec::RVecRVec(const std::vector< T > &RHS)Definition RVec.hxx:1581; ROOT::VecOps::RVec::size_typetypename SuperClass::size_type size_typeDefinition RVec.hxx:1537; ROOT::VecOps::RVec::RVecRVec(Detail::VecOps::RVecImpl< T > &&RHS)Definition RVec.hxx:1573; ROOT::VecOps::RVec::RVecRVec(RVec &&RHS)Definition RVec.hxx:1565; ROOT::VecOps::RVec::value_typetypename SuperClass::value_type value_typeDefinition RVec.hxx:1538; ROOT::VecOps::RVec::operator=RVec & operator=(const RVec &RHS)Definition RVec.hxx:1559; R; double; ptTPaveText * ptDefinition entrylist_figure1.C:7; ROOT::Math::IntegrationOneDim::TypeTypeenumeration specifying the integration types.Definition AllIntegrationTypes.h:32; ROOT::VecOps::ReverseRVec< T > Reverse(const RVec< T > &v)Return copy of reversed vector.Definition RVec.hxx:2481; ROOT::VecOps::IntersectRVec< T > Intersect(const RVec< T > &v1, const RVec< T > &v2, bool v2_is_sorted=false)Return the intersection of elements of two RVecs.Definition RVec.hxx:2758; ROOT::VecOps::NonzeroRVec< typename RVec< T >::size_type > Nonzero(const RVec< T > &v)Return the indices of the elements which are not zero.Definition RVec.hxx:2727; RVEC_UNARY_OPERATOR#define RVEC_UNARY_OPERATOR(OP)Definition RVec.hxx:1616; RVEC_ASSIGNMENT_OPERATOR#define RVEC_ASSIGNMENT_OPERATOR(OP)Definition RVec.hxx:1687; ROOT::VecOps::StableArgsortRVec< typename RVec< T >::size_type > StableArgsort(const RVec< T > &v)Return an RVec of indices that sort the input RVec while keeping the order of equal elements.Definition RVec.hxx:2295; ROOT::VecOps::ConcatenateRVec< Common_t > Concatenate(const RVec< T0 > &v0,",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:270,Modifiability,adapt,adapted,270,". ROOT: math/vecops/inc/ROOT/RVec.hxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. RVec.hxx. Go to the documentation of this file. 1// Author: Enrico Guiraud, Enric Tejedor, Danilo Piparo CERN 04/2021; 2// Implementation adapted from from llvm::SmallVector.; 3// See /math/vecops/ARCHITECTURE.md for more information.; 4 ; 5/*************************************************************************; 6 * Copyright (C) 1995-2021, Rene Brun and Fons Rademakers. *; 7 * All rights reserved. *; 8 * *; 9 * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 *************************************************************************/; 12 ; 13#ifndef ROOT_RVEC; 14#define ROOT_RVEC; 15 ; 16#if __cplusplus > 201402L; 17#define R__RVEC_NODISCARD [[nodiscard]]; 18#else; 19#define R__RVEC_NODISCARD; 20#endif; 21 ; 22#ifdef _WIN32; 23 #ifndef M_PI; 24 #ifndef _USE_MATH_DEFINES; 25 #define _USE_MATH_DEFINES; 26 #endif; 27 #include <math.h>; 28 #undef _USE_MATH_DEFINES; 29 #endif; 30 #define _VECOPS_USE_EXTERN_TEMPLATES false; 31#else; 32 #define _VECOPS_USE_EXTERN_TEMPLATES true; 33#endif; 34 ; 35#include <Rtypes.h> // R__CLING_PTRCHECK; 36#include <TError.h> // R__ASSERT; 37 ; 38#include <algorithm>; 39#include <cmath>; 40#include <cstring>; 41#include <limits> // for numeric_limits; 42#include <memory> // uninitialized_value_construct; 43#include <new>; 44#include <numeric> // for inner_product; 45#include <sstream>; 46#include <stdexcept>; 47#include <string>; 48#include <tuple>; 49#include <type_traits>; 50#include <utility>; 51#include <vector>; 52 ; 53#ifdef R__HAS_VDT; 54#include <vdt/vdtMath.h>; 55#endif; 56 ; 57 ; 58namespace ROOT {; 59 ; 60namespace VecOps {; 61template<typename T>; 62class RVec;; 63}; 64 ; 65namespace Internal {; 66namespace VecOps {; 67 ; 68template<typename T>; 69using RVec = ROOT::VecOps::RVec<T>;; 70 ; 71// clang-format off; 72template <typena",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:39421,Modifiability,variab,variable-sized,39421,"0);; 1100 CurSize = 0;; 1101 this->grow(RHSSize);; 1102 } else if (CurSize) {; 1103 // Otherwise, use assignment for the already-constructed elements.; 1104 std::move(RHS.begin(), RHS.begin() + CurSize, this->begin());; 1105 }; 1106 ; 1107 // Move-construct the new elements in place.; 1108 this->uninitialized_move(RHS.begin() + CurSize, RHS.end(), this->begin() + CurSize);; 1109 ; 1110 // Set end.; 1111 this->set_size(RHSSize);; 1112 ; 1113 RHS.clear();; 1114 return *this;; 1115}; 1116 ; 1117template <typename T>; 1118bool IsSmall(const ROOT::VecOps::RVec<T> &v); 1119{; 1120 return v.isSmall();; 1121}; 1122 ; 1123template <typename T>; 1124bool IsAdopting(const ROOT::VecOps::RVec<T> &v); 1125{; 1126 return !v.Owns();; 1127}; 1128 ; 1129} // namespace VecOps; 1130} // namespace Detail; 1131 ; 1132namespace VecOps {; 1133// Note that we open here with @{ the Doxygen group vecops and it is; 1134// closed again at the end of the C++ namespace VecOps; 1135/**; 1136 * \defgroup vecops VecOps; 1137 * A ""std::vector""-like collection of values implementing handy operation to analyse them; 1138 * @{; 1139*/; 1140 ; 1141// From the original SmallVector code:; 1142// This is a 'vector' (really, a variable-sized array), optimized; 1143// for the case when the array is small. It contains some number of elements; 1144// in-place, which allows it to avoid heap allocation when the actual number of; 1145// elements is below that threshold. This allows normal ""small"" cases to be; 1146// fast without losing generality for large inputs.; 1147//; 1148// Note that this does not attempt to be exception safe.; 1149 ; 1150template <typename T, unsigned int N>; 1151class R__CLING_PTRCHECK(off) RVecN : public Detail::VecOps::RVecImpl<T>, Internal::VecOps::SmallVectorStorage<T, N> {; 1152public:; 1153 RVecN() : Detail::VecOps::RVecImpl<T>(N) {}; 1154 ; 1155 ~RVecN(); 1156 {; 1157 if (this->Owns()) {; 1158 // Destroy the constructed elements in the vector.; 1159 this->destroy_range(this->begin(),",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:16996,Performance,optimiz,optimizes,16996,"range [I, E) onto the uninitialized memory; 438 /// starting with ""Dest"", constructing elements into it as needed.; 439 template <typename It1, typename It2>; 440 static void uninitialized_move(It1 I, It1 E, It2 Dest); 441 {; 442 // Just do a copy.; 443 uninitialized_copy(I, E, Dest);; 444 }; 445 ; 446 /// Copy the range [I, E) onto the uninitialized memory; 447 /// starting with ""Dest"", constructing elements into it as needed.; 448 template <typename It1, typename It2>; 449 static void uninitialized_copy(It1 I, It1 E, It2 Dest); 450 {; 451 // Arbitrary iterator types; just use the basic implementation.; 452 std::uninitialized_copy(I, E, Dest);; 453 }; 454 ; 455 /// Copy the range [I, E) onto the uninitialized memory; 456 /// starting with ""Dest"", constructing elements into it as needed.; 457 template <typename T1, typename T2>; 458 static void uninitialized_copy(; 459 T1 *I, T1 *E, T2 *Dest,; 460 typename std::enable_if<std::is_same<typename std::remove_const<T1>::type, T2>::value>::type * = nullptr); 461 {; 462 // Use memcpy for PODs iterated by pointers (which includes SmallVector; 463 // iterators): std::uninitialized_copy optimizes to memmove, but we can; 464 // use memcpy here. Note that I and E are iterators and thus might be; 465 // invalid for memcpy if they are equal.; 466 if (I != E); 467 memcpy(reinterpret_cast<void *>(Dest), I, (E - I) * sizeof(T));; 468 }; 469 ; 470 /// Double the size of the allocated memory, guaranteeing space for at; 471 /// least one more element or MinSize if specified.; 472 void grow(size_t MinSize = 0); 473 {; 474 this->grow_pod(MinSize, sizeof(T));; 475 }; 476 ; 477public:; 478 using iterator = typename SuperClass::iterator;; 479 using const_iterator = typename SuperClass::const_iterator;; 480 using reference = typename SuperClass::reference;; 481 using size_type = typename SuperClass::size_type;; 482 ; 483 void push_back(const T &Elt); 484 {; 485 if (R__unlikely(this->size() >= this->capacity())); 486 this->grow();; 487 memcpy",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:18705,Performance,cache,cacheline,18705,"_type;; 482 ; 483 void push_back(const T &Elt); 484 {; 485 if (R__unlikely(this->size() >= this->capacity())); 486 this->grow();; 487 memcpy(reinterpret_cast<void *>(this->end()), &Elt, sizeof(T));; 488 this->set_size(this->size() + 1);; 489 }; 490 ; 491 void pop_back() { this->set_size(this->size() - 1); }; 492};; 493 ; 494/// Storage for the SmallVector elements. This is specialized for the N=0 case; 495/// to avoid allocating unnecessary storage.; 496template <typename T, unsigned N>; 497struct SmallVectorStorage {; 498 alignas(T) char InlineElts[N * sizeof(T)]{};; 499};; 500 ; 501/// We need the storage to be properly aligned even for small-size of 0 so that; 502/// the pointer math in \a SmallVectorTemplateCommon::getFirstEl() is; 503/// well-defined.; 504template <typename T>; 505struct alignas(T) SmallVectorStorage<T, 0> {; 506};; 507 ; 508/// The size of the inline storage of an RVec.; 509/// Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline); 510/// unless the size of the buffer with 8 elements would be over a certain maximum size.; 511template <typename T>; 512struct RVecInlineStorageSize {; 513private:; 514#ifdef R__HAS_HARDWARE_INTERFERENCE_SIZE; 515 static constexpr std::size_t cacheLineSize = std::hardware_destructive_interference_size;; 516#else; 517 // safe bet: assume the typical 64 bytes; 518 static constexpr std::size_t cacheLineSize = 64;; 519#endif; 520 static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);; 521 static constexpr unsigned maxInlineByteSize = 1024;; 522 ; 523public:; 524 static constexpr unsigned value =; 525 elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8);; 526};; 527 ; 528// A C++14-compatible implementation of std::uninitialized_value_construct; 529template <typename ForwardIt>; 530void UninitializedValueConstruct(ForwardIt first, ForwardIt last); 531{; 532#if __cplusplus < 201703L; 533 for (; f",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:18961,Performance,cache,cacheLineSize,18961,"SmallVectorTemplateCommon::getFirstEl() is; 503/// well-defined.; 504template <typename T>; 505struct alignas(T) SmallVectorStorage<T, 0> {; 506};; 507 ; 508/// The size of the inline storage of an RVec.; 509/// Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline); 510/// unless the size of the buffer with 8 elements would be over a certain maximum size.; 511template <typename T>; 512struct RVecInlineStorageSize {; 513private:; 514#ifdef R__HAS_HARDWARE_INTERFERENCE_SIZE; 515 static constexpr std::size_t cacheLineSize = std::hardware_destructive_interference_size;; 516#else; 517 // safe bet: assume the typical 64 bytes; 518 static constexpr std::size_t cacheLineSize = 64;; 519#endif; 520 static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);; 521 static constexpr unsigned maxInlineByteSize = 1024;; 522 ; 523public:; 524 static constexpr unsigned value =; 525 elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8);; 526};; 527 ; 528// A C++14-compatible implementation of std::uninitialized_value_construct; 529template <typename ForwardIt>; 530void UninitializedValueConstruct(ForwardIt first, ForwardIt last); 531{; 532#if __cplusplus < 201703L; 533 for (; first != last; ++first); 534 new (static_cast<void *>(std::addressof(*first))) typename std::iterator_traits<ForwardIt>::value_type();; 535#else; 536 std::uninitialized_value_construct(first, last);; 537#endif; 538}; 539 ; 540/// An unsafe function to reset the buffer for which this RVec is acting as a view.; 541///; 542/// \note This is a low-level method that _must_ be called on RVecs that are already non-owning:; 543/// - it does not put the RVec in ""non-owning mode"" (fCapacity == -1); 544/// - it does not free any owned buffer; 545template <typename T>; 546void ResetView(RVec<T> &v, T* addr, std::size_t sz); 547{; 548 v.fBeginX = addr;; 549 v.fSize = sz;; 550}; 551 ; 552} // namespace VecOp",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:19112,Performance,cache,cacheLineSize,19112,"SmallVectorTemplateCommon::getFirstEl() is; 503/// well-defined.; 504template <typename T>; 505struct alignas(T) SmallVectorStorage<T, 0> {; 506};; 507 ; 508/// The size of the inline storage of an RVec.; 509/// Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline); 510/// unless the size of the buffer with 8 elements would be over a certain maximum size.; 511template <typename T>; 512struct RVecInlineStorageSize {; 513private:; 514#ifdef R__HAS_HARDWARE_INTERFERENCE_SIZE; 515 static constexpr std::size_t cacheLineSize = std::hardware_destructive_interference_size;; 516#else; 517 // safe bet: assume the typical 64 bytes; 518 static constexpr std::size_t cacheLineSize = 64;; 519#endif; 520 static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);; 521 static constexpr unsigned maxInlineByteSize = 1024;; 522 ; 523public:; 524 static constexpr unsigned value =; 525 elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8);; 526};; 527 ; 528// A C++14-compatible implementation of std::uninitialized_value_construct; 529template <typename ForwardIt>; 530void UninitializedValueConstruct(ForwardIt first, ForwardIt last); 531{; 532#if __cplusplus < 201703L; 533 for (; first != last; ++first); 534 new (static_cast<void *>(std::addressof(*first))) typename std::iterator_traits<ForwardIt>::value_type();; 535#else; 536 std::uninitialized_value_construct(first, last);; 537#endif; 538}; 539 ; 540/// An unsafe function to reset the buffer for which this RVec is acting as a view.; 541///; 542/// \note This is a low-level method that _must_ be called on RVecs that are already non-owning:; 543/// - it does not put the RVec in ""non-owning mode"" (fCapacity == -1); 544/// - it does not free any owned buffer; 545template <typename T>; 546void ResetView(RVec<T> &v, T* addr, std::size_t sz); 547{; 548 v.fBeginX = addr;; 549 v.fSize = sz;; 550}; 551 ; 552} // namespace VecOp",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:19198,Performance,cache,cacheLineSize,19198,"SmallVectorTemplateCommon::getFirstEl() is; 503/// well-defined.; 504template <typename T>; 505struct alignas(T) SmallVectorStorage<T, 0> {; 506};; 507 ; 508/// The size of the inline storage of an RVec.; 509/// Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline); 510/// unless the size of the buffer with 8 elements would be over a certain maximum size.; 511template <typename T>; 512struct RVecInlineStorageSize {; 513private:; 514#ifdef R__HAS_HARDWARE_INTERFERENCE_SIZE; 515 static constexpr std::size_t cacheLineSize = std::hardware_destructive_interference_size;; 516#else; 517 // safe bet: assume the typical 64 bytes; 518 static constexpr std::size_t cacheLineSize = 64;; 519#endif; 520 static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);; 521 static constexpr unsigned maxInlineByteSize = 1024;; 522 ; 523public:; 524 static constexpr unsigned value =; 525 elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8);; 526};; 527 ; 528// A C++14-compatible implementation of std::uninitialized_value_construct; 529template <typename ForwardIt>; 530void UninitializedValueConstruct(ForwardIt first, ForwardIt last); 531{; 532#if __cplusplus < 201703L; 533 for (; first != last; ++first); 534 new (static_cast<void *>(std::addressof(*first))) typename std::iterator_traits<ForwardIt>::value_type();; 535#else; 536 std::uninitialized_value_construct(first, last);; 537#endif; 538}; 539 ; 540/// An unsafe function to reset the buffer for which this RVec is acting as a view.; 541///; 542/// \note This is a low-level method that _must_ be called on RVecs that are already non-owning:; 543/// - it does not put the RVec in ""non-owning mode"" (fCapacity == -1); 544/// - it does not free any owned buffer; 545template <typename T>; 546void ResetView(RVec<T> &v, T* addr, std::size_t sz); 547{; 548 v.fBeginX = addr;; 549 v.fSize = sz;; 550}; 551 ; 552} // namespace VecOp",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:39444,Performance,optimiz,optimized,39444,"0);; 1100 CurSize = 0;; 1101 this->grow(RHSSize);; 1102 } else if (CurSize) {; 1103 // Otherwise, use assignment for the already-constructed elements.; 1104 std::move(RHS.begin(), RHS.begin() + CurSize, this->begin());; 1105 }; 1106 ; 1107 // Move-construct the new elements in place.; 1108 this->uninitialized_move(RHS.begin() + CurSize, RHS.end(), this->begin() + CurSize);; 1109 ; 1110 // Set end.; 1111 this->set_size(RHSSize);; 1112 ; 1113 RHS.clear();; 1114 return *this;; 1115}; 1116 ; 1117template <typename T>; 1118bool IsSmall(const ROOT::VecOps::RVec<T> &v); 1119{; 1120 return v.isSmall();; 1121}; 1122 ; 1123template <typename T>; 1124bool IsAdopting(const ROOT::VecOps::RVec<T> &v); 1125{; 1126 return !v.Owns();; 1127}; 1128 ; 1129} // namespace VecOps; 1130} // namespace Detail; 1131 ; 1132namespace VecOps {; 1133// Note that we open here with @{ the Doxygen group vecops and it is; 1134// closed again at the end of the C++ namespace VecOps; 1135/**; 1136 * \defgroup vecops VecOps; 1137 * A ""std::vector""-like collection of values implementing handy operation to analyse them; 1138 * @{; 1139*/; 1140 ; 1141// From the original SmallVector code:; 1142// This is a 'vector' (really, a variable-sized array), optimized; 1143// for the case when the array is small. It contains some number of elements; 1144// in-place, which allows it to avoid heap allocation when the actual number of; 1145// elements is below that threshold. This allows normal ""small"" cases to be; 1146// fast without losing generality for large inputs.; 1147//; 1148// Note that this does not attempt to be exception safe.; 1149 ; 1150template <typename T, unsigned int N>; 1151class R__CLING_PTRCHECK(off) RVecN : public Detail::VecOps::RVecImpl<T>, Internal::VecOps::SmallVectorStorage<T, N> {; 1152public:; 1153 RVecN() : Detail::VecOps::RVecImpl<T>(N) {}; 1154 ; 1155 ~RVecN(); 1156 {; 1157 if (this->Owns()) {; 1158 // Destroy the constructed elements in the vector.; 1159 this->destroy_range(this->begin(),",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:49241,Performance,perform,performed,49241,"consider only negatively charged muons with a pseudorapidity; 1377smaller or equal to 2 and with a transverse momentum greater than 10 GeV.; 1378Such a selection would require, among the other things, the management of an explicit; 1379loop, for example:; 1380~~~{.cpp}; 1381std::vector<float> goodMuons_pt;; 1382const auto size = mu_charge.size();; 1383for (size_t i=0; i < size; ++i) {; 1384 if (mu_pt[i] > 10 && abs(mu_eta[i]) <= 2. && mu_charge[i] == -1) {; 1385 goodMuons_pt.emplace_back(mu_pt[i]);; 1386 }; 1387}; 1388~~~; 1389These operations become straightforward with RVec - we just need to *write what; 1390we mean*:; 1391~~~{.cpp}; 1392auto goodMuons_pt = mu_pt[ (mu_pt > 10.f && abs(mu_eta) <= 2.f && mu_charge == -1) ]; 1393~~~; 1394Now the clean collection of transverse momenta can be used within the rest of the data analysis, for; 1395example to fill a histogram.; 1396 ; 1397\anchor operationsandfunctions; 1398## Arithmetic operations, logical operations and mathematical functions; 1399Arithmetic operations on RVec instances can be performed: for example, they can be added, subtracted, multiplied.; 1400~~~{.cpp}; 1401RVec<double> v1 {1.,2.,3.,4.};; 1402RVec<float> v2 {5.f,6.f,7.f,8.f};; 1403auto v3 = v1+v2;; 1404auto v4 = 3 * v1;; 1405~~~; 1406The supported operators are ; 1407 - +, -, *, /; 1408 - +=, -=, *=, /=; 1409 - <, >, ==, !=, <=, >=, &&, ||; 1410 - ~, !; 1411 - &, |, ^; 1412 - &=, |=, ^=; 1413 - <<=, >>=; 1414 ; 1415The most common mathematical functions are supported. It is possible to invoke them passing ; 1416RVecs as arguments.; 1417 - abs, fdim, fmod, remainder; 1418 - floor, ceil, trunc, round, lround, llround; 1419 - exp, exp2, expm1; 1420 - log, log10, log2, log1p; 1421 - pow; 1422 - sqrt, cbrt; 1423 - sin, cos, tan, asin, acos, atan, atan2, hypot; 1424 - sinh, cosh, tanh, asinh, acosh; 1425 - erf, erfc; 1426 - lgamma, tgamma; 1427 ; 1428If the VDT library is available, the following functions can be invoked. Internally the calculations; 1429ar",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:6162,Safety,avoid,avoids,6162,");; 166 /// Report that this vector is already at maximum capacity. Throws; 167 /// std::length_error or calls report_fatal_error.; 168 static void report_at_maximum_capacity();; 169 ; 170 /// If false, the RVec is in ""memory adoption"" mode, i.e. it is acting as a view on a memory buffer it does not own.; 171 bool Owns() const { return fCapacity != -1; }; 172 ; 173public:; 174 size_t size() const { return fSize; }; 175 size_t capacity() const noexcept { return Owns() ? fCapacity : fSize; }; 176 ; 177 R__RVEC_NODISCARD bool empty() const { return !fSize; }; 178 ; 179 /// Set the array size to \p N, which the current array must have enough; 180 /// capacity for.; 181 ///; 182 /// This does not construct or destroy any elements in the vector.; 183 ///; 184 /// Clients can use this in conjunction with capacity() to write past the end; 185 /// of the buffer when they know that more elements are available, and only; 186 /// update the size later. This avoids the cost of value initializing elements; 187 /// which will only be overwritten.; 188 void set_size(size_t N); 189 {; 190 if (N > capacity()) {; 191 throw std::runtime_error(""Setting size to a value greater than capacity."");; 192 }; 193 fSize = N;; 194 }; 195};; 196 ; 197/// Used to figure out the offset of the first element of an RVec; 198template <class T>; 199struct SmallVectorAlignmentAndSize {; 200 alignas(SmallVectorBase) char Base[sizeof(SmallVectorBase)];; 201 alignas(T) char FirstEl[sizeof(T)];; 202};; 203 ; 204/// This is the part of SmallVectorTemplateBase which does not depend on whether the type T is a POD.; 205template <typename T>; 206class R__CLING_PTRCHECK(off) SmallVectorTemplateCommon : public SmallVectorBase {; 207 using Base = SmallVectorBase;; 208 ; 209 /// Find the address of the first element. For this pointer math to be valid; 210 /// with small-size of 0 for T with lots of alignment, it's important that; 211 /// SmallVectorStorage is properly-aligned even for small-size of 0.; 212 void *getFir",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:18127,Safety,avoid,avoid,18127,"or memcpy if they are equal.; 466 if (I != E); 467 memcpy(reinterpret_cast<void *>(Dest), I, (E - I) * sizeof(T));; 468 }; 469 ; 470 /// Double the size of the allocated memory, guaranteeing space for at; 471 /// least one more element or MinSize if specified.; 472 void grow(size_t MinSize = 0); 473 {; 474 this->grow_pod(MinSize, sizeof(T));; 475 }; 476 ; 477public:; 478 using iterator = typename SuperClass::iterator;; 479 using const_iterator = typename SuperClass::const_iterator;; 480 using reference = typename SuperClass::reference;; 481 using size_type = typename SuperClass::size_type;; 482 ; 483 void push_back(const T &Elt); 484 {; 485 if (R__unlikely(this->size() >= this->capacity())); 486 this->grow();; 487 memcpy(reinterpret_cast<void *>(this->end()), &Elt, sizeof(T));; 488 this->set_size(this->size() + 1);; 489 }; 490 ; 491 void pop_back() { this->set_size(this->size() - 1); }; 492};; 493 ; 494/// Storage for the SmallVector elements. This is specialized for the N=0 case; 495/// to avoid allocating unnecessary storage.; 496template <typename T, unsigned N>; 497struct SmallVectorStorage {; 498 alignas(T) char InlineElts[N * sizeof(T)]{};; 499};; 500 ; 501/// We need the storage to be properly aligned even for small-size of 0 so that; 502/// the pointer math in \a SmallVectorTemplateCommon::getFirstEl() is; 503/// well-defined.; 504template <typename T>; 505struct alignas(T) SmallVectorStorage<T, 0> {; 506};; 507 ; 508/// The size of the inline storage of an RVec.; 509/// Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline); 510/// unless the size of the buffer with 8 elements would be over a certain maximum size.; 511template <typename T>; 512struct RVecInlineStorageSize {; 513private:; 514#ifdef R__HAS_HARDWARE_INTERFERENCE_SIZE; 515 static constexpr std::size_t cacheLineSize = std::hardware_destructive_interference_size;; 516#else; 517 // safe bet: assume the typical 64 bytes; 518 static constexpr std::size_t cacheLine",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:19040,Safety,safe,safe,19040,"SmallVectorTemplateCommon::getFirstEl() is; 503/// well-defined.; 504template <typename T>; 505struct alignas(T) SmallVectorStorage<T, 0> {; 506};; 507 ; 508/// The size of the inline storage of an RVec.; 509/// Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline); 510/// unless the size of the buffer with 8 elements would be over a certain maximum size.; 511template <typename T>; 512struct RVecInlineStorageSize {; 513private:; 514#ifdef R__HAS_HARDWARE_INTERFERENCE_SIZE; 515 static constexpr std::size_t cacheLineSize = std::hardware_destructive_interference_size;; 516#else; 517 // safe bet: assume the typical 64 bytes; 518 static constexpr std::size_t cacheLineSize = 64;; 519#endif; 520 static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);; 521 static constexpr unsigned maxInlineByteSize = 1024;; 522 ; 523public:; 524 static constexpr unsigned value =; 525 elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8);; 526};; 527 ; 528// A C++14-compatible implementation of std::uninitialized_value_construct; 529template <typename ForwardIt>; 530void UninitializedValueConstruct(ForwardIt first, ForwardIt last); 531{; 532#if __cplusplus < 201703L; 533 for (; first != last; ++first); 534 new (static_cast<void *>(std::addressof(*first))) typename std::iterator_traits<ForwardIt>::value_type();; 535#else; 536 std::uninitialized_value_construct(first, last);; 537#endif; 538}; 539 ; 540/// An unsafe function to reset the buffer for which this RVec is acting as a view.; 541///; 542/// \note This is a low-level method that _must_ be called on RVecs that are already non-owning:; 543/// - it does not put the RVec in ""non-owning mode"" (fCapacity == -1); 544/// - it does not free any owned buffer; 545template <typename T>; 546void ResetView(RVec<T> &v, T* addr, std::size_t sz); 547{; 548 v.fBeginX = addr;; 549 v.fSize = sz;; 550}; 551 ; 552} // namespace VecOp",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:19944,Safety,unsafe,unsafe,19944,"SmallVectorTemplateCommon::getFirstEl() is; 503/// well-defined.; 504template <typename T>; 505struct alignas(T) SmallVectorStorage<T, 0> {; 506};; 507 ; 508/// The size of the inline storage of an RVec.; 509/// Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline); 510/// unless the size of the buffer with 8 elements would be over a certain maximum size.; 511template <typename T>; 512struct RVecInlineStorageSize {; 513private:; 514#ifdef R__HAS_HARDWARE_INTERFERENCE_SIZE; 515 static constexpr std::size_t cacheLineSize = std::hardware_destructive_interference_size;; 516#else; 517 // safe bet: assume the typical 64 bytes; 518 static constexpr std::size_t cacheLineSize = 64;; 519#endif; 520 static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);; 521 static constexpr unsigned maxInlineByteSize = 1024;; 522 ; 523public:; 524 static constexpr unsigned value =; 525 elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8);; 526};; 527 ; 528// A C++14-compatible implementation of std::uninitialized_value_construct; 529template <typename ForwardIt>; 530void UninitializedValueConstruct(ForwardIt first, ForwardIt last); 531{; 532#if __cplusplus < 201703L; 533 for (; first != last; ++first); 534 new (static_cast<void *>(std::addressof(*first))) typename std::iterator_traits<ForwardIt>::value_type();; 535#else; 536 std::uninitialized_value_construct(first, last);; 537#endif; 538}; 539 ; 540/// An unsafe function to reset the buffer for which this RVec is acting as a view.; 541///; 542/// \note This is a low-level method that _must_ be called on RVecs that are already non-owning:; 543/// - it does not put the RVec in ""non-owning mode"" (fCapacity == -1); 544/// - it does not free any owned buffer; 545template <typename T>; 546void ResetView(RVec<T> &v, T* addr, std::size_t sz); 547{; 548 v.fBeginX = addr;; 549 v.fSize = sz;; 550}; 551 ; 552} // namespace VecOp",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:28216,Safety,avoid,avoid,28216,"71 }; 772 ; 773 iterator insert(iterator I, const T &Elt); 774 {; 775 if (I == this->end()) { // Important special case for empty vector.; 776 this->push_back(Elt);; 777 return this->end() - 1;; 778 }; 779 ; 780 if (I < this->begin() || I > this->end()) {; 781 throw std::runtime_error(""The iterator passed to `insert` is out of bounds."");; 782 }; 783 ; 784 if (this->size() >= this->capacity()) {; 785 size_t EltNo = I - this->begin();; 786 this->grow();; 787 I = this->begin() + EltNo;; 788 }; 789 ::new ((void *)this->end()) T(std::move(this->back()));; 790 // Push everything else over.; 791 std::move_backward(I, this->end() - 1, this->end());; 792 this->set_size(this->size() + 1);; 793 ; 794 // If we just moved the element we're inserting, be sure to update; 795 // the reference.; 796 const T *EltPtr = &Elt;; 797 if (I <= EltPtr && EltPtr < this->end()); 798 ++EltPtr;; 799 ; 800 *I = *EltPtr;; 801 return I;; 802 }; 803 ; 804 iterator insert(iterator I, size_type NumToInsert, const T &Elt); 805 {; 806 // Convert iterator to elt# to avoid invalidating iterator when we reserve(); 807 size_t InsertElt = I - this->begin();; 808 ; 809 if (I == this->end()) { // Important special case for empty vector.; 810 append(NumToInsert, Elt);; 811 return this->begin() + InsertElt;; 812 }; 813 ; 814 if (I < this->begin() || I > this->end()) {; 815 throw std::runtime_error(""The iterator passed to `insert` is out of bounds."");; 816 }; 817 ; 818 // Ensure there is enough space.; 819 reserve(this->size() + NumToInsert);; 820 ; 821 // Uninvalidate the iterator.; 822 I = this->begin() + InsertElt;; 823 ; 824 // If there are more elements between the insertion point and the end of the; 825 // range than there are being inserted, we can use a simple approach to; 826 // insertion. Since we already reserved space, we know that this won't; 827 // reallocate the vector.; 828 if (size_t(this->end() - I) >= NumToInsert) {; 829 T *OldEnd = this->end();; 830 append(std::move_iterator<iterator>(this->e",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:30331,Safety,avoid,avoid,30331,"r>(this->end()));; 831 ; 832 // Copy the existing elements that get replaced.; 833 std::move_backward(I, OldEnd - NumToInsert, OldEnd);; 834 ; 835 std::fill_n(I, NumToInsert, Elt);; 836 return I;; 837 }; 838 ; 839 // Otherwise, we're inserting more elements than exist already, and we're; 840 // not inserting at the end.; 841 ; 842 // Move over the elements that we're about to overwrite.; 843 T *OldEnd = this->end();; 844 this->set_size(this->size() + NumToInsert);; 845 size_t NumOverwritten = OldEnd - I;; 846 this->uninitialized_move(I, OldEnd, this->end() - NumOverwritten);; 847 ; 848 // Replace the overwritten part.; 849 std::fill_n(I, NumOverwritten, Elt);; 850 ; 851 // Insert the non-overwritten middle part.; 852 std::uninitialized_fill_n(OldEnd, NumToInsert - NumOverwritten, Elt);; 853 return I;; 854 }; 855 ; 856 template <typename ItTy,; 857 typename = typename std::enable_if<std::is_convertible<; 858 typename std::iterator_traits<ItTy>::iterator_category, std::input_iterator_tag>::value>::type>; 859 iterator insert(iterator I, ItTy From, ItTy To); 860 {; 861 // Convert iterator to elt# to avoid invalidating iterator when we reserve(); 862 size_t InsertElt = I - this->begin();; 863 ; 864 if (I == this->end()) { // Important special case for empty vector.; 865 append(From, To);; 866 return this->begin() + InsertElt;; 867 }; 868 ; 869 if (I < this->begin() || I > this->end()) {; 870 throw std::runtime_error(""The iterator passed to `insert` is out of bounds."");; 871 }; 872 ; 873 size_t NumToInsert = std::distance(From, To);; 874 ; 875 // Ensure there is enough space.; 876 reserve(this->size() + NumToInsert);; 877 ; 878 // Uninvalidate the iterator.; 879 I = this->begin() + InsertElt;; 880 ; 881 // If there are more elements between the insertion point and the end of the; 882 // range than there are being inserted, we can use a simple approach to; 883 // insertion. Since we already reserved space, we know that this won't; 884 // reallocate the vector.; 885 if (size",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:32898,Safety,avoid,avoid,32898,"e.; 900 T *OldEnd = this->end();; 901 this->set_size(this->size() + NumToInsert);; 902 size_t NumOverwritten = OldEnd - I;; 903 this->uninitialized_move(I, OldEnd, this->end() - NumOverwritten);; 904 ; 905 // Replace the overwritten part.; 906 for (T *J = I; NumOverwritten > 0; --NumOverwritten) {; 907 *J = *From;; 908 ++J;; 909 ++From;; 910 }; 911 ; 912 // Insert the non-overwritten middle part.; 913 this->uninitialized_copy(From, To, OldEnd);; 914 return I;; 915 }; 916 ; 917 void insert(iterator I, std::initializer_list<T> IL) { insert(I, IL.begin(), IL.end()); }; 918 ; 919 template <typename... ArgTypes>; 920 reference emplace_back(ArgTypes &&...Args); 921 {; 922 if (R__unlikely(this->size() >= this->capacity())); 923 this->grow();; 924 ::new ((void *)this->end()) T(std::forward<ArgTypes>(Args)...);; 925 this->set_size(this->size() + 1);; 926 return this->back();; 927 }; 928 ; 929 RVecImpl &operator=(const RVecImpl &RHS);; 930 ; 931 RVecImpl &operator=(RVecImpl &&RHS);; 932};; 933 ; 934template <typename T>; 935void RVecImpl<T>::swap(RVecImpl<T> &RHS); 936{; 937 if (this == &RHS); 938 return;; 939 ; 940 // We can only avoid copying elements if neither vector is small.; 941 if (!this->isSmall() && !RHS.isSmall()) {; 942 std::swap(this->fBeginX, RHS.fBeginX);; 943 std::swap(this->fSize, RHS.fSize);; 944 std::swap(this->fCapacity, RHS.fCapacity);; 945 return;; 946 }; 947 ; 948 // This block handles the swap of a small and a non-owning vector; 949 // It is more efficient to first move the non-owning vector, hence the 2 cases; 950 if (this->isSmall() && !RHS.Owns()) { // the right vector is non-owning; 951 RVecImpl<T> temp(0);; 952 temp = std::move(RHS);; 953 RHS = std::move(*this);; 954 *this = std::move(temp);; 955 return;; 956 } else if (RHS.isSmall() && !this->Owns()) { // the left vector is non-owning; 957 RVecImpl<T> temp(0);; 958 temp = std::move(*this);; 959 *this = std::move(RHS);; 960 RHS = std::move(temp);; 961 return;; 962 }; 963 ; 964 if (RHS.size() > thi",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:35731,Safety,avoid,avoid,35731,"his->destroy_range(RHS.begin() + NumShared, RHS.end());; 990 RHS.set_size(NumShared);; 991 }; 992}; 993 ; 994template <typename T>; 995RVecImpl<T> &RVecImpl<T>::operator=(const RVecImpl<T> &RHS); 996{; 997 // Avoid self-assignment.; 998 if (this == &RHS); 999 return *this;; 1000 ; 1001 // If we already have sufficient space, assign the common elements, then; 1002 // destroy any excess.; 1003 size_t RHSSize = RHS.size();; 1004 size_t CurSize = this->size();; 1005 if (CurSize >= RHSSize) {; 1006 // Assign common elements.; 1007 iterator NewEnd;; 1008 if (RHSSize); 1009 NewEnd = std::copy(RHS.begin(), RHS.begin() + RHSSize, this->begin());; 1010 else; 1011 NewEnd = this->begin();; 1012 ; 1013 // Destroy excess elements.; 1014 if (this->Owns()); 1015 this->destroy_range(NewEnd, this->end());; 1016 ; 1017 // Trim.; 1018 this->set_size(RHSSize);; 1019 return *this;; 1020 }; 1021 ; 1022 // If we have to grow to have enough elements, destroy the current elements.; 1023 // This allows us to avoid copying them during the grow.; 1024 // From the original LLVM implementation:; 1025 // FIXME: don't do this if they're efficiently moveable.; 1026 if (this->capacity() < RHSSize) {; 1027 if (this->Owns()) {; 1028 // Destroy current elements.; 1029 this->destroy_range(this->begin(), this->end());; 1030 }; 1031 this->set_size(0);; 1032 CurSize = 0;; 1033 this->grow(RHSSize);; 1034 } else if (CurSize) {; 1035 // Otherwise, use assignment for the already-constructed elements.; 1036 std::copy(RHS.begin(), RHS.begin() + CurSize, this->begin());; 1037 }; 1038 ; 1039 // Copy construct the new elements in place.; 1040 this->uninitialized_copy(RHS.begin() + CurSize, RHS.end(), this->begin() + CurSize);; 1041 ; 1042 // Set end.; 1043 this->set_size(RHSSize);; 1044 return *this;; 1045}; 1046 ; 1047template <typename T>; 1048RVecImpl<T> &RVecImpl<T>::operator=(RVecImpl<T> &&RHS); 1049{; 1050 // Avoid self-assignment.; 1051 if (this == &RHS); 1052 return *this;; 1053 ; 1054 // If the RHS isn't sma",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:37849,Safety,avoid,avoid,37849,"stroy_range(this->begin(), this->end());; 1058 if (!this->isSmall()); 1059 free(this->begin());; 1060 }; 1061 this->fBeginX = RHS.fBeginX;; 1062 this->fSize = RHS.fSize;; 1063 this->fCapacity = RHS.fCapacity;; 1064 RHS.resetToSmall();; 1065 return *this;; 1066 }; 1067 ; 1068 // If we already have sufficient space, assign the common elements, then; 1069 // destroy any excess.; 1070 size_t RHSSize = RHS.size();; 1071 size_t CurSize = this->size();; 1072 if (CurSize >= RHSSize) {; 1073 // Assign common elements.; 1074 iterator NewEnd = this->begin();; 1075 if (RHSSize); 1076 NewEnd = std::move(RHS.begin(), RHS.end(), NewEnd);; 1077 ; 1078 // Destroy excess elements and trim the bounds.; 1079 if (this->Owns()); 1080 this->destroy_range(NewEnd, this->end());; 1081 this->set_size(RHSSize);; 1082 ; 1083 // Clear the RHS.; 1084 RHS.clear();; 1085 ; 1086 return *this;; 1087 }; 1088 ; 1089 // If we have to grow to have enough elements, destroy the current elements.; 1090 // This allows us to avoid copying them during the grow.; 1091 // From the original LLVM implementation:; 1092 // FIXME: this may not actually make any sense if we can efficiently move; 1093 // elements.; 1094 if (this->capacity() < RHSSize) {; 1095 if (this->Owns()) {; 1096 // Destroy current elements.; 1097 this->destroy_range(this->begin(), this->end());; 1098 }; 1099 this->set_size(0);; 1100 CurSize = 0;; 1101 this->grow(RHSSize);; 1102 } else if (CurSize) {; 1103 // Otherwise, use assignment for the already-constructed elements.; 1104 std::move(RHS.begin(), RHS.begin() + CurSize, this->begin());; 1105 }; 1106 ; 1107 // Move-construct the new elements in place.; 1108 this->uninitialized_move(RHS.begin() + CurSize, RHS.end(), this->begin() + CurSize);; 1109 ; 1110 // Set end.; 1111 this->set_size(RHSSize);; 1112 ; 1113 RHS.clear();; 1114 return *this;; 1115}; 1116 ; 1117template <typename T>; 1118bool IsSmall(const ROOT::VecOps::RVec<T> &v); 1119{; 1120 return v.isSmall();; 1121}; 1122 ; 1123template <typen",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:39573,Safety,avoid,avoid,39573," + CurSize);; 1109 ; 1110 // Set end.; 1111 this->set_size(RHSSize);; 1112 ; 1113 RHS.clear();; 1114 return *this;; 1115}; 1116 ; 1117template <typename T>; 1118bool IsSmall(const ROOT::VecOps::RVec<T> &v); 1119{; 1120 return v.isSmall();; 1121}; 1122 ; 1123template <typename T>; 1124bool IsAdopting(const ROOT::VecOps::RVec<T> &v); 1125{; 1126 return !v.Owns();; 1127}; 1128 ; 1129} // namespace VecOps; 1130} // namespace Detail; 1131 ; 1132namespace VecOps {; 1133// Note that we open here with @{ the Doxygen group vecops and it is; 1134// closed again at the end of the C++ namespace VecOps; 1135/**; 1136 * \defgroup vecops VecOps; 1137 * A ""std::vector""-like collection of values implementing handy operation to analyse them; 1138 * @{; 1139*/; 1140 ; 1141// From the original SmallVector code:; 1142// This is a 'vector' (really, a variable-sized array), optimized; 1143// for the case when the array is small. It contains some number of elements; 1144// in-place, which allows it to avoid heap allocation when the actual number of; 1145// elements is below that threshold. This allows normal ""small"" cases to be; 1146// fast without losing generality for large inputs.; 1147//; 1148// Note that this does not attempt to be exception safe.; 1149 ; 1150template <typename T, unsigned int N>; 1151class R__CLING_PTRCHECK(off) RVecN : public Detail::VecOps::RVecImpl<T>, Internal::VecOps::SmallVectorStorage<T, N> {; 1152public:; 1153 RVecN() : Detail::VecOps::RVecImpl<T>(N) {}; 1154 ; 1155 ~RVecN(); 1156 {; 1157 if (this->Owns()) {; 1158 // Destroy the constructed elements in the vector.; 1159 this->destroy_range(this->begin(), this->end());; 1160 }; 1161 }; 1162 ; 1163 explicit RVecN(size_t Size, const T &Value) : Detail::VecOps::RVecImpl<T>(N) { this->assign(Size, Value); }; 1164 ; 1165 explicit RVecN(size_t Size) : Detail::VecOps::RVecImpl<T>(N); 1166 {; 1167 if (Size > N); 1168 this->grow(Size);; 1169 this->fSize = Size;; 1170 ROOT::Internal::VecOps::UninitializedValueConstruct(t",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:39823,Safety,safe,safe,39823," 1120 return v.isSmall();; 1121}; 1122 ; 1123template <typename T>; 1124bool IsAdopting(const ROOT::VecOps::RVec<T> &v); 1125{; 1126 return !v.Owns();; 1127}; 1128 ; 1129} // namespace VecOps; 1130} // namespace Detail; 1131 ; 1132namespace VecOps {; 1133// Note that we open here with @{ the Doxygen group vecops and it is; 1134// closed again at the end of the C++ namespace VecOps; 1135/**; 1136 * \defgroup vecops VecOps; 1137 * A ""std::vector""-like collection of values implementing handy operation to analyse them; 1138 * @{; 1139*/; 1140 ; 1141// From the original SmallVector code:; 1142// This is a 'vector' (really, a variable-sized array), optimized; 1143// for the case when the array is small. It contains some number of elements; 1144// in-place, which allows it to avoid heap allocation when the actual number of; 1145// elements is below that threshold. This allows normal ""small"" cases to be; 1146// fast without losing generality for large inputs.; 1147//; 1148// Note that this does not attempt to be exception safe.; 1149 ; 1150template <typename T, unsigned int N>; 1151class R__CLING_PTRCHECK(off) RVecN : public Detail::VecOps::RVecImpl<T>, Internal::VecOps::SmallVectorStorage<T, N> {; 1152public:; 1153 RVecN() : Detail::VecOps::RVecImpl<T>(N) {}; 1154 ; 1155 ~RVecN(); 1156 {; 1157 if (this->Owns()) {; 1158 // Destroy the constructed elements in the vector.; 1159 this->destroy_range(this->begin(), this->end());; 1160 }; 1161 }; 1162 ; 1163 explicit RVecN(size_t Size, const T &Value) : Detail::VecOps::RVecImpl<T>(N) { this->assign(Size, Value); }; 1164 ; 1165 explicit RVecN(size_t Size) : Detail::VecOps::RVecImpl<T>(N); 1166 {; 1167 if (Size > N); 1168 this->grow(Size);; 1169 this->fSize = Size;; 1170 ROOT::Internal::VecOps::UninitializedValueConstruct(this->begin(), this->end());; 1171 }; 1172 ; 1173 template <typename ItTy,; 1174 typename = typename std::enable_if<std::is_convertible<; 1175 typename std::iterator_traits<ItTy>::iterator_category, std::input_ite",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:46614,Safety,safe,safe,46614,"off; 1323/**; 1324\class ROOT::VecOps::RVec; 1325\brief A ""std::vector""-like collection of values implementing handy operation to analyse them; 1326\tparam T The type of the contained objects; 1327 ; 1328A RVec is a container designed to make analysis of values' collections fast and easy.; 1329Its storage is contiguous in memory and its interface is designed such to resemble to the one; 1330of the stl vector. In addition the interface features methods and; 1331[external functions](https://root.cern/doc/master/namespaceROOT_1_1VecOps.html) to ease the manipulation and analysis; 1332of the data in the RVec.; 1333 ; 1334\note ROOT::VecOps::RVec can also be spelled simply ROOT::RVec. Shorthand aliases such as ROOT::RVecI or ROOT::RVecD; 1335are also available as template instantiations of RVec of fundamental types. The full list of available aliases:; 1336- RVecB (`bool`); 1337- RVecC (`char`); 1338- RVecD (`double`); 1339- RVecF (`float`); 1340- RVecI (`int`); 1341- RVecL (`long`); 1342- RVecLL (`long long`); 1343- RVecU (`unsigned`); 1344- RVecUL (`unsigned long`); 1345- RVecULL (`unsigned long long`); 1346 ; 1347\note RVec does not attempt to be exception safe. Exceptions thrown by element constructors during insertions, swaps or; 1348other operations will be propagated potentially leaving the RVec object in an invalid state.; 1349 ; 1350\note RVec methods (e.g. `at` or `size`) follow the STL naming convention instead of the ROOT naming convention in order; 1351to make RVec a drop-in replacement for `std::vector`.; 1352 ; 1353\htmlonly; 1354<a href=""https://doi.org/10.5281/zenodo.1253756""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.1253756.svg"" alt=""DOI""></a>; 1355\endhtmlonly; 1356 ; 1357## Table of Contents; 1358- [Example](\ref example); 1359- [Arithmetic operations, logical operations and mathematical functions](\ref operationsandfunctions); 1360- [Owning and adopting memory](\ref owningandadoptingmemory); 1361- [Sorting and manipulation of indices](\re",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:60506,Safety,avoid,avoid,60506,"86 ; 1687#define RVEC_ASSIGNMENT_OPERATOR(OP) \; 1688template <typename T0, typename T1> \; 1689RVec<T0>& operator OP(RVec<T0> &v, const T1 &y) \; 1690{ \; 1691 auto op = [&y](T0 &x) { return x OP y; }; \; 1692 std::transform(v.begin(), v.end(), v.begin(), op); \; 1693 return v; \; 1694} \; 1695 \; 1696template <typename T0, typename T1> \; 1697RVec<T0>& operator OP(RVec<T0> &v0, const RVec<T1> &v1) \; 1698{ \; 1699 if (v0.size() != v1.size()) \; 1700 throw std::runtime_error(ERROR_MESSAGE(OP)); \; 1701 \; 1702 auto op = [](T0 &x, const T1 &y) { return x OP y; }; \; 1703 std::transform(v0.begin(), v0.end(), v1.begin(), v0.begin(), op); \; 1704 return v0; \; 1705} \; 1706 ; 1707RVEC_ASSIGNMENT_OPERATOR(+=); 1708RVEC_ASSIGNMENT_OPERATOR(-=); 1709RVEC_ASSIGNMENT_OPERATOR(*=); 1710RVEC_ASSIGNMENT_OPERATOR(/=); 1711RVEC_ASSIGNMENT_OPERATOR(%=); 1712RVEC_ASSIGNMENT_OPERATOR(^=); 1713RVEC_ASSIGNMENT_OPERATOR(|=); 1714RVEC_ASSIGNMENT_OPERATOR(&=); 1715RVEC_ASSIGNMENT_OPERATOR(>>=); 1716RVEC_ASSIGNMENT_OPERATOR(<<=); 1717#undef RVEC_ASSIGNMENT_OPERATOR; 1718 ; 1719///@}; 1720///@name RVec Comparison and Logical Operators; 1721///@{; 1722 ; 1723#define RVEC_LOGICAL_OPERATOR(OP) \; 1724template <typename T0, typename T1> \; 1725auto operator OP(const RVec<T0> &v, const T1 &y) \; 1726 -> RVec<int> /* avoid std::vector<bool> */ \; 1727{ \; 1728 RVec<int> ret(v.size()); \; 1729 auto op = [y](const T0 &x) -> int { return x OP y; }; \; 1730 std::transform(v.begin(), v.end(), ret.begin(), op); \; 1731 return ret; \; 1732} \; 1733 \; 1734template <typename T0, typename T1> \; 1735auto operator OP(const T0 &x, const RVec<T1> &v) \; 1736 -> RVec<int> /* avoid std::vector<bool> */ \; 1737{ \; 1738 RVec<int> ret(v.size()); \; 1739 auto op = [x](const T1 &y) -> int { return x OP y; }; \; 1740 std::transform(v.begin(), v.end(), ret.begin(), op); \; 1741 return ret; \; 1742} \; 1743 \; 1744template <typename T0, typename T1> \; 1745auto operator OP(const RVec<T0> &v0, const RVec<T1> &v1) \;",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:60858,Safety,avoid,avoid,60858,"v0.end(), v1.begin(), v0.begin(), op); \; 1704 return v0; \; 1705} \; 1706 ; 1707RVEC_ASSIGNMENT_OPERATOR(+=); 1708RVEC_ASSIGNMENT_OPERATOR(-=); 1709RVEC_ASSIGNMENT_OPERATOR(*=); 1710RVEC_ASSIGNMENT_OPERATOR(/=); 1711RVEC_ASSIGNMENT_OPERATOR(%=); 1712RVEC_ASSIGNMENT_OPERATOR(^=); 1713RVEC_ASSIGNMENT_OPERATOR(|=); 1714RVEC_ASSIGNMENT_OPERATOR(&=); 1715RVEC_ASSIGNMENT_OPERATOR(>>=); 1716RVEC_ASSIGNMENT_OPERATOR(<<=); 1717#undef RVEC_ASSIGNMENT_OPERATOR; 1718 ; 1719///@}; 1720///@name RVec Comparison and Logical Operators; 1721///@{; 1722 ; 1723#define RVEC_LOGICAL_OPERATOR(OP) \; 1724template <typename T0, typename T1> \; 1725auto operator OP(const RVec<T0> &v, const T1 &y) \; 1726 -> RVec<int> /* avoid std::vector<bool> */ \; 1727{ \; 1728 RVec<int> ret(v.size()); \; 1729 auto op = [y](const T0 &x) -> int { return x OP y; }; \; 1730 std::transform(v.begin(), v.end(), ret.begin(), op); \; 1731 return ret; \; 1732} \; 1733 \; 1734template <typename T0, typename T1> \; 1735auto operator OP(const T0 &x, const RVec<T1> &v) \; 1736 -> RVec<int> /* avoid std::vector<bool> */ \; 1737{ \; 1738 RVec<int> ret(v.size()); \; 1739 auto op = [x](const T1 &y) -> int { return x OP y; }; \; 1740 std::transform(v.begin(), v.end(), ret.begin(), op); \; 1741 return ret; \; 1742} \; 1743 \; 1744template <typename T0, typename T1> \; 1745auto operator OP(const RVec<T0> &v0, const RVec<T1> &v1) \; 1746 -> RVec<int> /* avoid std::vector<bool> */ \; 1747{ \; 1748 if (v0.size() != v1.size()) \; 1749 throw std::runtime_error(ERROR_MESSAGE(OP)); \; 1750 \; 1751 RVec<int> ret(v0.size()); \; 1752 auto op = [](const T0 &x, const T1 &y) -> int { return x OP y; }; \; 1753 std::transform(v0.begin(), v0.end(), v1.begin(), ret.begin(), op); \; 1754 return ret; \; 1755} \; 1756 ; 1757RVEC_LOGICAL_OPERATOR(<); 1758RVEC_LOGICAL_OPERATOR(>); 1759RVEC_LOGICAL_OPERATOR(==); 1760RVEC_LOGICAL_OPERATOR(!=); 1761RVEC_LOGICAL_OPERATOR(<=); 1762RVEC_LOGICAL_OPERATOR(>=); 1763RVEC_LOGICAL_OPERATOR(&&); 1764RVEC_LOGI",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:61218,Safety,avoid,avoid,61218,"15RVEC_ASSIGNMENT_OPERATOR(>>=); 1716RVEC_ASSIGNMENT_OPERATOR(<<=); 1717#undef RVEC_ASSIGNMENT_OPERATOR; 1718 ; 1719///@}; 1720///@name RVec Comparison and Logical Operators; 1721///@{; 1722 ; 1723#define RVEC_LOGICAL_OPERATOR(OP) \; 1724template <typename T0, typename T1> \; 1725auto operator OP(const RVec<T0> &v, const T1 &y) \; 1726 -> RVec<int> /* avoid std::vector<bool> */ \; 1727{ \; 1728 RVec<int> ret(v.size()); \; 1729 auto op = [y](const T0 &x) -> int { return x OP y; }; \; 1730 std::transform(v.begin(), v.end(), ret.begin(), op); \; 1731 return ret; \; 1732} \; 1733 \; 1734template <typename T0, typename T1> \; 1735auto operator OP(const T0 &x, const RVec<T1> &v) \; 1736 -> RVec<int> /* avoid std::vector<bool> */ \; 1737{ \; 1738 RVec<int> ret(v.size()); \; 1739 auto op = [x](const T1 &y) -> int { return x OP y; }; \; 1740 std::transform(v.begin(), v.end(), ret.begin(), op); \; 1741 return ret; \; 1742} \; 1743 \; 1744template <typename T0, typename T1> \; 1745auto operator OP(const RVec<T0> &v0, const RVec<T1> &v1) \; 1746 -> RVec<int> /* avoid std::vector<bool> */ \; 1747{ \; 1748 if (v0.size() != v1.size()) \; 1749 throw std::runtime_error(ERROR_MESSAGE(OP)); \; 1750 \; 1751 RVec<int> ret(v0.size()); \; 1752 auto op = [](const T0 &x, const T1 &y) -> int { return x OP y; }; \; 1753 std::transform(v0.begin(), v0.end(), v1.begin(), ret.begin(), op); \; 1754 return ret; \; 1755} \; 1756 ; 1757RVEC_LOGICAL_OPERATOR(<); 1758RVEC_LOGICAL_OPERATOR(>); 1759RVEC_LOGICAL_OPERATOR(==); 1760RVEC_LOGICAL_OPERATOR(!=); 1761RVEC_LOGICAL_OPERATOR(<=); 1762RVEC_LOGICAL_OPERATOR(>=); 1763RVEC_LOGICAL_OPERATOR(&&); 1764RVEC_LOGICAL_OPERATOR(||); 1765#undef RVEC_LOGICAL_OPERATOR; 1766 ; 1767///@}; 1768///@name RVec Standard Mathematical Functions; 1769///@{; 1770 ; 1771/// \cond; 1772template <typename T> struct PromoteTypeImpl;; 1773 ; 1774template <> struct PromoteTypeImpl<float> { using Type = float; };; 1775template <> struct PromoteTypeImpl<double> { using Type = double",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:154797,Safety,unsafe,unsafe,154797,"cOps::ArgMaxstd::size_t ArgMax(const RVec< T > &v)Get the index of the greatest element of an RVec In case of multiple occurrences of the maximum value...Definition RVec.hxx:2067; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; T2#define T2Definition md5.inl:147; T7#define T7Definition md5.inl:152; T6#define T6Definition md5.inl:151; T3#define T3Definition md5.inl:148; T5#define T5Definition md5.inl:150; T4#define T4Definition md5.inl:149; F#define F(x, y, z); I#define I(x, y, z); T1#define T1Definition md5.inl:146; ROOT::Detail::VecOps::IsSmallbool IsSmall(const ROOT::VecOps::RVec< T > &v)Definition RVec.hxx:1118; ROOT::Detail::VecOps::IsAdoptingbool IsAdopting(const ROOT::VecOps::RVec< T > &v)Definition RVec.hxx:1124; ROOT::Internal::VecOps::MapImplauto MapImpl(F &&f, RVecs &&... vs) -> RVec< decltype(f(vs[0]...))>Definition RVec.hxx:105; ROOT::Internal::VecOps::ResetViewvoid ResetView(RVec< T > &v, T *addr, std::size_t sz)An unsafe function to reset the buffer for which this RVec is acting as a view.Definition RVec.hxx:546; ROOT::Internal::VecOps::NextPowerOf2uint64_t NextPowerOf2(uint64_t A)Return the next power of two (in 64-bits) that is strictly greater than A.Definition RVec.hxx:126; ROOT::Internal::VecOps::Allconstexpr bool All(const bool *vals, std::size_t size)Definition RVec.hxx:79; ROOT::Internal::VecOps::GetVectorsSizestd::size_t GetVectorsSize(const std::string &id, const RVec< T > &... vs)Definition RVec.hxx:88; ROOT::Internal::VecOps::UninitializedValueConstructvoid UninitializedValueConstruct(ForwardIt first, ForwardIt last)Definition RVec.hxx:530; ROOT::Internal::VecOps::MapFromTupleauto MapFromTuple(Tuple_t &&t, std::index_sequence< Is... >) -> decltype(MapImpl(std::get< std::tuple_size< Tuple_t >::value - 1 >(t), std::get< Is >(t)...))Definition RVec.hxx:117; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition E",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:8193,Security,expose,expose,8193,"8 ; 219protected:; 220 SmallVectorTemplateCommon(size_t Size) : Base(getFirstEl(), Size) {}; 221 ; 222 void grow_pod(size_t MinSize, size_t TSize) { Base::grow_pod(getFirstEl(), MinSize, TSize); }; 223 ; 224 /// Return true if this is a smallvector which has not had dynamic; 225 /// memory allocated for it.; 226 bool isSmall() const { return this->fBeginX == getFirstEl(); }; 227 ; 228 /// Put this vector in a state of being small.; 229 void resetToSmall(); 230 {; 231 this->fBeginX = getFirstEl();; 232 // from the original LLVM implementation:; 233 // FIXME: Setting fCapacity to 0 is suspect.; 234 this->fSize = this->fCapacity = 0;; 235 }; 236 ; 237public:; 238 // note that fSize is a _signed_ integer, but we expose it as an unsigned integer for consistency with STL containers; 239 // as well as backward-compatibility; 240 using size_type = size_t;; 241 using difference_type = ptrdiff_t;; 242 using value_type = T;; 243 using iterator = T *;; 244 using const_iterator = const T *;; 245 ; 246 using const_reverse_iterator = std::reverse_iterator<const_iterator>;; 247 using reverse_iterator = std::reverse_iterator<iterator>;; 248 ; 249 using reference = T &;; 250 using const_reference = const T &;; 251 using pointer = T *;; 252 using const_pointer = const T *;; 253 ; 254 using Base::capacity;; 255 using Base::empty;; 256 using Base::size;; 257 ; 258 // forward iterator creation methods.; 259 iterator begin() noexcept { return (iterator)this->fBeginX; }; 260 const_iterator begin() const noexcept { return (const_iterator)this->fBeginX; }; 261 const_iterator cbegin() const noexcept { return (const_iterator)this->fBeginX; }; 262 iterator end() noexcept { return begin() + size(); }; 263 const_iterator end() const noexcept { return begin() + size(); }; 264 const_iterator cend() const noexcept { return begin() + size(); }; 265 ; 266 // reverse iterator creation methods.; 267 reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }; 268 const_reverse_iterator rbegin(",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:47251,Testability,log,logical,47251,"VecF (`float`); 1340- RVecI (`int`); 1341- RVecL (`long`); 1342- RVecLL (`long long`); 1343- RVecU (`unsigned`); 1344- RVecUL (`unsigned long`); 1345- RVecULL (`unsigned long long`); 1346 ; 1347\note RVec does not attempt to be exception safe. Exceptions thrown by element constructors during insertions, swaps or; 1348other operations will be propagated potentially leaving the RVec object in an invalid state.; 1349 ; 1350\note RVec methods (e.g. `at` or `size`) follow the STL naming convention instead of the ROOT naming convention in order; 1351to make RVec a drop-in replacement for `std::vector`.; 1352 ; 1353\htmlonly; 1354<a href=""https://doi.org/10.5281/zenodo.1253756""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.1253756.svg"" alt=""DOI""></a>; 1355\endhtmlonly; 1356 ; 1357## Table of Contents; 1358- [Example](\ref example); 1359- [Arithmetic operations, logical operations and mathematical functions](\ref operationsandfunctions); 1360- [Owning and adopting memory](\ref owningandadoptingmemory); 1361- [Sorting and manipulation of indices](\ref sorting); 1362- [Usage in combination with RDataFrame](\ref usagetdataframe); 1363- [Reference for the RVec class](\ref RVecdoxyref); 1364- [Reference for RVec helper functions](https://root.cern/doc/master/namespaceROOT_1_1VecOps.html); 1365 ; 1366\anchor example; 1367## Example; 1368Suppose to have an event featuring a collection of muons with a certain pseudorapidity,; 1369momentum and charge, e.g.:; 1370~~~{.cpp}; 1371std::vector<short> mu_charge {1, 1, -1, -1, -1, 1, 1, -1};; 1372std::vector<float> mu_pt {56, 45, 32, 24, 12, 8, 7, 6.2};; 1373std::vector<float> mu_eta {3.1, -.2, -1.1, 1, 4.1, 1.6, 2.4, -.5};; 1374~~~; 1375Suppose you want to extract the transverse momenta of the muons satisfying certain; 1376criteria, for example consider only negatively charged muons with a pseudorapidity; 1377smaller or equal to 2 and with a transverse momentum greater than 10 GeV.; 1378Such a selection would require, among the ot",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:49143,Testability,log,logical,49143,"consider only negatively charged muons with a pseudorapidity; 1377smaller or equal to 2 and with a transverse momentum greater than 10 GeV.; 1378Such a selection would require, among the other things, the management of an explicit; 1379loop, for example:; 1380~~~{.cpp}; 1381std::vector<float> goodMuons_pt;; 1382const auto size = mu_charge.size();; 1383for (size_t i=0; i < size; ++i) {; 1384 if (mu_pt[i] > 10 && abs(mu_eta[i]) <= 2. && mu_charge[i] == -1) {; 1385 goodMuons_pt.emplace_back(mu_pt[i]);; 1386 }; 1387}; 1388~~~; 1389These operations become straightforward with RVec - we just need to *write what; 1390we mean*:; 1391~~~{.cpp}; 1392auto goodMuons_pt = mu_pt[ (mu_pt > 10.f && abs(mu_eta) <= 2.f && mu_charge == -1) ]; 1393~~~; 1394Now the clean collection of transverse momenta can be used within the rest of the data analysis, for; 1395example to fill a histogram.; 1396 ; 1397\anchor operationsandfunctions; 1398## Arithmetic operations, logical operations and mathematical functions; 1399Arithmetic operations on RVec instances can be performed: for example, they can be added, subtracted, multiplied.; 1400~~~{.cpp}; 1401RVec<double> v1 {1.,2.,3.,4.};; 1402RVec<float> v2 {5.f,6.f,7.f,8.f};; 1403auto v3 = v1+v2;; 1404auto v4 = 3 * v1;; 1405~~~; 1406The supported operators are ; 1407 - +, -, *, /; 1408 - +=, -=, *=, /=; 1409 - <, >, ==, !=, <=, >=, &&, ||; 1410 - ~, !; 1411 - &, |, ^; 1412 - &=, |=, ^=; 1413 - <<=, >>=; 1414 ; 1415The most common mathematical functions are supported. It is possible to invoke them passing ; 1416RVecs as arguments.; 1417 - abs, fdim, fmod, remainder; 1418 - floor, ceil, trunc, round, lround, llround; 1419 - exp, exp2, expm1; 1420 - log, log10, log2, log1p; 1421 - pow; 1422 - sqrt, cbrt; 1423 - sin, cos, tan, asin, acos, atan, atan2, hypot; 1424 - sinh, cosh, tanh, asinh, acosh; 1425 - erf, erfc; 1426 - lgamma, tgamma; 1427 ; 1428If the VDT library is available, the following functions can be invoked. Internally the calculations; 1429ar",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:49879,Testability,log,log,49879,"ion of transverse momenta can be used within the rest of the data analysis, for; 1395example to fill a histogram.; 1396 ; 1397\anchor operationsandfunctions; 1398## Arithmetic operations, logical operations and mathematical functions; 1399Arithmetic operations on RVec instances can be performed: for example, they can be added, subtracted, multiplied.; 1400~~~{.cpp}; 1401RVec<double> v1 {1.,2.,3.,4.};; 1402RVec<float> v2 {5.f,6.f,7.f,8.f};; 1403auto v3 = v1+v2;; 1404auto v4 = 3 * v1;; 1405~~~; 1406The supported operators are ; 1407 - +, -, *, /; 1408 - +=, -=, *=, /=; 1409 - <, >, ==, !=, <=, >=, &&, ||; 1410 - ~, !; 1411 - &, |, ^; 1412 - &=, |=, ^=; 1413 - <<=, >>=; 1414 ; 1415The most common mathematical functions are supported. It is possible to invoke them passing ; 1416RVecs as arguments.; 1417 - abs, fdim, fmod, remainder; 1418 - floor, ceil, trunc, round, lround, llround; 1419 - exp, exp2, expm1; 1420 - log, log10, log2, log1p; 1421 - pow; 1422 - sqrt, cbrt; 1423 - sin, cos, tan, asin, acos, atan, atan2, hypot; 1424 - sinh, cosh, tanh, asinh, acosh; 1425 - erf, erfc; 1426 - lgamma, tgamma; 1427 ; 1428If the VDT library is available, the following functions can be invoked. Internally the calculations; 1429are vectorized:; 1430 - fast_expf, fast_logf, fast_sinf, fast_cosf, fast_tanf, fast_asinf, fast_acosf, fast_atanf; 1431 - fast_exp, fast_log, fast_sin, fast_cos, fast_tan, fast_asin, fast_acos, fast_atan; 1432 ; 1433\anchor owningandadoptingmemory; 1434## Owning and adopting memory; 1435RVec has contiguous memory associated to it. It can own it or simply adopt it. In the latter case,; 1436it can be constructed with the address of the memory associated to it and its length. For example:; 1437~~~{.cpp}; 1438std::vector<int> myStlVec {1,2,3};; 1439RVec<int> myRVec(myStlVec.data(), myStlVec.size());; 1440~~~; 1441In this case, the memory associated to myStlVec and myRVec is the same, myRVec simply ""adopted it"".; 1442If any method which implies a re-allocation is c",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:64526,Testability,log,log,64526,,MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:124103,Testability,log,log,124103,"<T>> NAME(const RVec<T> &);; 3435 ; 3436#define RVEC_EXTERN_STD_UNARY_FUNCTION(T, F) RVEC_EXTERN_UNARY_FUNCTION(T, F, std::F); 3437 ; 3438#define RVEC_EXTERN_BINARY_FUNCTION(T0, T1, NAME, FUNC) \; 3439 extern template RVec<PromoteTypes<T0, T1>> NAME(const RVec<T0> &, const T1 &); \; 3440 extern template RVec<PromoteTypes<T0, T1>> NAME(const T0 &, const RVec<T1> &); \; 3441 extern template RVec<PromoteTypes<T0, T1>> NAME(const RVec<T0> &, const RVec<T1> &);; 3442 ; 3443#define RVEC_EXTERN_STD_BINARY_FUNCTION(T, F) RVEC_EXTERN_BINARY_FUNCTION(T, T, F, std::F); 3444 ; 3445#define RVEC_EXTERN_STD_FUNCTIONS(T) \; 3446 RVEC_EXTERN_STD_UNARY_FUNCTION(T, abs) \; 3447 RVEC_EXTERN_STD_BINARY_FUNCTION(T, fdim) \; 3448 RVEC_EXTERN_STD_BINARY_FUNCTION(T, fmod) \; 3449 RVEC_EXTERN_STD_BINARY_FUNCTION(T, remainder) \; 3450 RVEC_EXTERN_STD_UNARY_FUNCTION(T, exp) \; 3451 RVEC_EXTERN_STD_UNARY_FUNCTION(T, exp2) \; 3452 RVEC_EXTERN_STD_UNARY_FUNCTION(T, expm1) \; 3453 RVEC_EXTERN_STD_UNARY_FUNCTION(T, log) \; 3454 RVEC_EXTERN_STD_UNARY_FUNCTION(T, log10) \; 3455 RVEC_EXTERN_STD_UNARY_FUNCTION(T, log2) \; 3456 RVEC_EXTERN_STD_UNARY_FUNCTION(T, log1p) \; 3457 RVEC_EXTERN_STD_BINARY_FUNCTION(T, pow) \; 3458 RVEC_EXTERN_STD_UNARY_FUNCTION(T, sqrt) \; 3459 RVEC_EXTERN_STD_UNARY_FUNCTION(T, cbrt) \; 3460 RVEC_EXTERN_STD_BINARY_FUNCTION(T, hypot) \; 3461 RVEC_EXTERN_STD_UNARY_FUNCTION(T, sin) \; 3462 RVEC_EXTERN_STD_UNARY_FUNCTION(T, cos) \; 3463 RVEC_EXTERN_STD_UNARY_FUNCTION(T, tan) \; 3464 RVEC_EXTERN_STD_UNARY_FUNCTION(T, asin) \; 3465 RVEC_EXTERN_STD_UNARY_FUNCTION(T, acos) \; 3466 RVEC_EXTERN_STD_UNARY_FUNCTION(T, atan) \; 3467 RVEC_EXTERN_STD_BINARY_FUNCTION(T, atan2) \; 3468 RVEC_EXTERN_STD_UNARY_FUNCTION(T, sinh) \; 3469 RVEC_EXTERN_STD_UNARY_FUNCTION(T, cosh) \; 3470 RVEC_EXTERN_STD_UNARY_FUNCTION(T, tanh) \; 3471 RVEC_EXTERN_STD_UNARY_FUNCTION(T, asinh) \; 3472 RVEC_EXTERN_STD_UNARY_FUNCTION(T, acosh) \; 3473 RVEC_EXTERN_STD_UNARY_FUNCTION(T, atanh) \; 3474 RVEC_EXTERN_STD_UNARY_F",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:21639,Usability,clear,clear,21639,"72 explicit RVecImpl(unsigned N) : ROOT::Internal::VecOps::SmallVectorTemplateBase<T>(N) {}; 573 ; 574public:; 575 RVecImpl(const RVecImpl &) = delete;; 576 ; 577 ~RVecImpl(); 578 {; 579 // Subclass has already destructed this vector's elements.; 580 // If this wasn't grown from the inline copy, deallocate the old space.; 581 if (!this->isSmall() && this->Owns()); 582 free(this->begin());; 583 }; 584 ; 585 // also give up adopted memory if applicable; 586 void clear(); 587 {; 588 if (this->Owns()) {; 589 this->destroy_range(this->begin(), this->end());; 590 this->fSize = 0;; 591 } else {; 592 this->resetToSmall();; 593 }; 594 }; 595 ; 596 void resize(size_type N); 597 {; 598 if (N < this->size()) {; 599 if (this->Owns()); 600 this->destroy_range(this->begin() + N, this->end());; 601 this->set_size(N);; 602 } else if (N > this->size()) {; 603 if (this->capacity() < N); 604 this->grow(N);; 605 for (auto I = this->end(), E = this->begin() + N; I != E; ++I); 606 new (&*I) T();; 607 this->set_size(N);; 608 }; 609 }; 610 ; 611 void resize(size_type N, const T &NV); 612 {; 613 if (N < this->size()) {; 614 if (this->Owns()); 615 this->destroy_range(this->begin() + N, this->end());; 616 this->set_size(N);; 617 } else if (N > this->size()) {; 618 if (this->capacity() < N); 619 this->grow(N);; 620 std::uninitialized_fill(this->end(), this->begin() + N, NV);; 621 this->set_size(N);; 622 }; 623 }; 624 ; 625 void reserve(size_type N); 626 {; 627 if (this->capacity() < N); 628 this->grow(N);; 629 }; 630 ; 631 void pop_back_n(size_type NumItems); 632 {; 633 if (this->size() < NumItems) {; 634 throw std::runtime_error(""Popping back more elements than those available."");; 635 }; 636 if (this->Owns()); 637 this->destroy_range(this->end() - NumItems, this->end());; 638 this->set_size(this->size() - NumItems);; 639 }; 640 ; 641 R__RVEC_NODISCARD T pop_back_val(); 642 {; 643 T Result = ::std::move(this->back());; 644 this->pop_back();; 645 return Result;; 646 }; 647 ; 648 void swap(RVecI",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:24340,Usability,clear,clearing,24340,"= typename std::enable_if<std::is_convertible<; 653 typename std::iterator_traits<in_iter>::iterator_category, std::input_iterator_tag>::value>::type>; 654 void append(in_iter in_start, in_iter in_end); 655 {; 656 size_type NumInputs = std::distance(in_start, in_end);; 657 if (NumInputs > this->capacity() - this->size()); 658 this->grow(this->size() + NumInputs);; 659 ; 660 this->uninitialized_copy(in_start, in_end, this->end());; 661 this->set_size(this->size() + NumInputs);; 662 }; 663 ; 664 /// Append \p NumInputs copies of \p Elt to the end.; 665 void append(size_type NumInputs, const T &Elt); 666 {; 667 if (NumInputs > this->capacity() - this->size()); 668 this->grow(this->size() + NumInputs);; 669 ; 670 std::uninitialized_fill_n(this->end(), NumInputs, Elt);; 671 this->set_size(this->size() + NumInputs);; 672 }; 673 ; 674 void append(std::initializer_list<T> IL) { append(IL.begin(), IL.end()); }; 675 ; 676 // from the original LLVM implementation:; 677 // FIXME: Consider assigning over existing elements, rather than clearing &; 678 // re-initializing them - for all assign(...) variants.; 679 ; 680 void assign(size_type NumElts, const T &Elt); 681 {; 682 clear();; 683 if (this->capacity() < NumElts); 684 this->grow(NumElts);; 685 this->set_size(NumElts);; 686 std::uninitialized_fill(this->begin(), this->end(), Elt);; 687 }; 688 ; 689 template <typename in_iter,; 690 typename = typename std::enable_if<std::is_convertible<; 691 typename std::iterator_traits<in_iter>::iterator_category, std::input_iterator_tag>::value>::type>; 692 void assign(in_iter in_start, in_iter in_end); 693 {; 694 clear();; 695 append(in_start, in_end);; 696 }; 697 ; 698 void assign(std::initializer_list<T> IL); 699 {; 700 clear();; 701 append(IL);; 702 }; 703 ; 704 iterator erase(const_iterator CI); 705 {; 706 // Just cast away constness because this is a non-const member function.; 707 iterator I = const_cast<iterator>(CI);; 708 ; 709 if (I < this->begin() || I >= this->end()) {; 710 throw",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
https://root.cern/doc/master/RVec_8hxx_source.html:24480,Usability,clear,clear,24480,"/// Append \p NumInputs copies of \p Elt to the end.; 665 void append(size_type NumInputs, const T &Elt); 666 {; 667 if (NumInputs > this->capacity() - this->size()); 668 this->grow(this->size() + NumInputs);; 669 ; 670 std::uninitialized_fill_n(this->end(), NumInputs, Elt);; 671 this->set_size(this->size() + NumInputs);; 672 }; 673 ; 674 void append(std::initializer_list<T> IL) { append(IL.begin(), IL.end()); }; 675 ; 676 // from the original LLVM implementation:; 677 // FIXME: Consider assigning over existing elements, rather than clearing &; 678 // re-initializing them - for all assign(...) variants.; 679 ; 680 void assign(size_type NumElts, const T &Elt); 681 {; 682 clear();; 683 if (this->capacity() < NumElts); 684 this->grow(NumElts);; 685 this->set_size(NumElts);; 686 std::uninitialized_fill(this->begin(), this->end(), Elt);; 687 }; 688 ; 689 template <typename in_iter,; 690 typename = typename std::enable_if<std::is_convertible<; 691 typename std::iterator_traits<in_iter>::iterator_category, std::input_iterator_tag>::value>::type>; 692 void assign(in_iter in_start, in_iter in_end); 693 {; 694 clear();; 695 append(in_start, in_end);; 696 }; 697 ; 698 void assign(std::initializer_list<T> IL); 699 {; 700 clear();; 701 append(IL);; 702 }; 703 ; 704 iterator erase(const_iterator CI); 705 {; 706 // Just cast away constness because this is a non-const member function.; 707 iterator I = const_cast<iterator>(CI);; 708 ; 709 if (I < this->begin() || I >= this->end()) {; 710 throw std::runtime_error(""The iterator passed to `erase` is out of bounds."");; 711 }; 712 ; 713 iterator N = I;; 714 // Shift all elts down one.; 715 std::move(I + 1, this->end(), I);; 716 // Drop the last elt.; 717 this->pop_back();; 718 return (N);; 719 }; 720 ; 721 iterator erase(const_iterator CS, const_iterator CE); 722 {; 723 // Just cast away constness because this is a non-const member function.; 724 iterator S = const_cast<iterator>(CS);; 725 iterator E = const_cast<iterator>(CE);; 726 ; 72",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
