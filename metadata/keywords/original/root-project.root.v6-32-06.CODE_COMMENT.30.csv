id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/RustDemangle.cpp:59,Availability,error,error,59,/// Computes A + B. When computation wraps around sets the error and returns; /// false. Otherwise assigns the result to A and returns true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Demangle/RustDemangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/RustDemangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/RustDemangle.cpp:37,Integrability,wrap,wraps,37,/// Computes A + B. When computation wraps around sets the error and returns; /// false. Otherwise assigns the result to A and returns true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Demangle/RustDemangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/RustDemangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/RustDemangle.cpp:59,Availability,error,error,59,/// Computes A * B. When computation wraps around sets the error and returns; /// false. Otherwise assigns the result to A and returns true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Demangle/RustDemangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/RustDemangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/RustDemangle.cpp:37,Integrability,wrap,wraps,37,/// Computes A * B. When computation wraps around sets the error and returns; /// false. Otherwise assigns the result to A and returns true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Demangle/RustDemangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/RustDemangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:42,Integrability,interface,interfaces,42,/// Collect references to parseable Swift interfaces in imported; /// DW_TAG_module blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:15,Integrability,interface,interfaces,15,// Don't track interfaces that are part of the SDK.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:15,Integrability,interface,interfaces,15,"// Don't track interfaces that are part of the toolchain.; // For example: Swift, _Concurrency, ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:31,Performance,perform,performed,31,/// The distinct types of work performed by the work loop in; /// analyzeContextInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:104,Performance,perform,performed,104,/// This class represents an item in the work list. The type defines what kind; /// of work needs to be performed when processing the current item. Everything; /// but the Type and Die fields are optional based on the type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:257,Modifiability,extend,extend,257,"// Clang imposes an ODR on modules(!) regardless of the language:; // ""The module-id should consist of only a single identifier,; // which provides the name of the module being defined. Each; // module shall have a single definition.""; //; // This does not extend to the types inside the modules:; // ""[I]n C, this implies that if two structs are defined in; // different submodules with the same name, those two types are; // distinct types (but may be compatible types if their; // definitions match).""; //; // We treat non-C++ modules like namespaces for this reason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:69,Deployability,update,updated,69,/// Check if a variable describing DIE should be kept.; /// \returns updated TraversalFlags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:15,Modifiability,variab,variable,15,/// Check if a variable describing DIE should be kept.; /// \returns updated TraversalFlags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:10,Modifiability,variab,variables,10,// Global variables with constant value can always be kept.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:75,Modifiability,variab,variable,75,"// See if there is a relocation to a valid debug map entry inside this; // variable's location. The order is important here. We want to always check; // if the variable has a valid relocation, so that the DIEInfo is filled.; // However, we don't want a static variable in a function to force us to keep; // the enclosing function, unless requested explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:160,Modifiability,variab,variable,160,"// See if there is a relocation to a valid debug map entry inside this; // variable's location. The order is important here. We want to always check; // if the variable has a valid relocation, so that the DIEInfo is filled.; // However, we don't want a static variable in a function to force us to keep; // the enclosing function, unless requested explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:260,Modifiability,variab,variable,260,"// See if there is a relocation to a valid debug map entry inside this; // variable's location. The order is important here. We want to always check; // if the variable has a valid relocation, so that the DIEInfo is filled.; // However, we don't want a static variable in a function to force us to keep; // the enclosing function, unless requested explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:69,Deployability,update,updated,69,/// Check if a function describing DIE should be kept.; /// \returns updated TraversalFlags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:49,Deployability,update,updated,49,/// Check if a DIE should be kept.; /// \returns updated TraversalFlags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:16,Deployability,update,updates,16,/// Helper that updates the completeness of the current DIE based on the; /// completeness of one of its children. It depends on the incompleteness of; /// the children already being computed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:118,Integrability,depend,depends,118,/// Helper that updates the completeness of the current DIE based on the; /// completeness of one of its children. It depends on the incompleteness of; /// the children already being computed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:16,Deployability,update,updates,16,/// Helper that updates the completeness of the current DIE based on the; /// completeness of the DIEs it references. It depends on the incompleteness of; /// the referenced DIE already being computed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:121,Integrability,depend,depends,121,/// Helper that updates the completeness of the current DIE based on the; /// completeness of the DIEs it references. It depends on the incompleteness of; /// the referenced DIE already being computed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:1168,Deployability,Update,UpdateChildIncompleteness,1168,"/// Recursively walk the \p DIE tree and look for DIEs to keep. Store that; /// information in \p CU's DIEInfo.; ///; /// This function is the entry point of the DIE selection algorithm. It is; /// expected to walk the DIE tree in file order and (though the mediation of; /// its helper) call hasValidRelocation() on each DIE that might be a 'root; /// DIE' (See DwarfLinker class comment).; ///; /// While walking the dependencies of root DIEs, this function is also called,; /// but during these dependency walks the file order is not respected. The; /// TF_DependencyWalk flag tells us which kind of traversal we are currently; /// doing.; ///; /// The recursive algorithm is implemented iteratively as a work list because; /// very deep recursion could exhaust the stack for large projects. The work; /// list acts as a scheduler for different types of work that need to be; /// performed.; ///; /// The recursive nature of the algorithm is simulated by running the ""main""; /// algorithm (LookForDIEsToKeep) followed by either looking at more DIEs; /// (LookForChildDIEsToKeep, LookForRefDIEsToKeep, LookForParentDIEsToKeep) or; /// fixing up a computed property (UpdateChildIncompleteness,; /// UpdateRefIncompleteness).; ///; /// The return value indicates whether the DIE is incomplete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:1200,Deployability,Update,UpdateRefIncompleteness,1200,"/// Recursively walk the \p DIE tree and look for DIEs to keep. Store that; /// information in \p CU's DIEInfo.; ///; /// This function is the entry point of the DIE selection algorithm. It is; /// expected to walk the DIE tree in file order and (though the mediation of; /// its helper) call hasValidRelocation() on each DIE that might be a 'root; /// DIE' (See DwarfLinker class comment).; ///; /// While walking the dependencies of root DIEs, this function is also called,; /// but during these dependency walks the file order is not respected. The; /// TF_DependencyWalk flag tells us which kind of traversal we are currently; /// doing.; ///; /// The recursive algorithm is implemented iteratively as a work list because; /// very deep recursion could exhaust the stack for large projects. The work; /// list acts as a scheduler for different types of work that need to be; /// performed.; ///; /// The recursive nature of the algorithm is simulated by running the ""main""; /// algorithm (LookForDIEsToKeep) followed by either looking at more DIEs; /// (LookForChildDIEsToKeep, LookForRefDIEsToKeep, LookForParentDIEsToKeep) or; /// fixing up a computed property (UpdateChildIncompleteness,; /// UpdateRefIncompleteness).; ///; /// The return value indicates whether the DIE is incomplete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:824,Energy Efficiency,schedul,scheduler,824,"/// Recursively walk the \p DIE tree and look for DIEs to keep. Store that; /// information in \p CU's DIEInfo.; ///; /// This function is the entry point of the DIE selection algorithm. It is; /// expected to walk the DIE tree in file order and (though the mediation of; /// its helper) call hasValidRelocation() on each DIE that might be a 'root; /// DIE' (See DwarfLinker class comment).; ///; /// While walking the dependencies of root DIEs, this function is also called,; /// but during these dependency walks the file order is not respected. The; /// TF_DependencyWalk flag tells us which kind of traversal we are currently; /// doing.; ///; /// The recursive algorithm is implemented iteratively as a work list because; /// very deep recursion could exhaust the stack for large projects. The work; /// list acts as a scheduler for different types of work that need to be; /// performed.; ///; /// The recursive nature of the algorithm is simulated by running the ""main""; /// algorithm (LookForDIEsToKeep) followed by either looking at more DIEs; /// (LookForChildDIEsToKeep, LookForRefDIEsToKeep, LookForParentDIEsToKeep) or; /// fixing up a computed property (UpdateChildIncompleteness,; /// UpdateRefIncompleteness).; ///; /// The return value indicates whether the DIE is incomplete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:258,Integrability,mediat,mediation,258,"/// Recursively walk the \p DIE tree and look for DIEs to keep. Store that; /// information in \p CU's DIEInfo.; ///; /// This function is the entry point of the DIE selection algorithm. It is; /// expected to walk the DIE tree in file order and (though the mediation of; /// its helper) call hasValidRelocation() on each DIE that might be a 'root; /// DIE' (See DwarfLinker class comment).; ///; /// While walking the dependencies of root DIEs, this function is also called,; /// but during these dependency walks the file order is not respected. The; /// TF_DependencyWalk flag tells us which kind of traversal we are currently; /// doing.; ///; /// The recursive algorithm is implemented iteratively as a work list because; /// very deep recursion could exhaust the stack for large projects. The work; /// list acts as a scheduler for different types of work that need to be; /// performed.; ///; /// The recursive nature of the algorithm is simulated by running the ""main""; /// algorithm (LookForDIEsToKeep) followed by either looking at more DIEs; /// (LookForChildDIEsToKeep, LookForRefDIEsToKeep, LookForParentDIEsToKeep) or; /// fixing up a computed property (UpdateChildIncompleteness,; /// UpdateRefIncompleteness).; ///; /// The return value indicates whether the DIE is incomplete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:419,Integrability,depend,dependencies,419,"/// Recursively walk the \p DIE tree and look for DIEs to keep. Store that; /// information in \p CU's DIEInfo.; ///; /// This function is the entry point of the DIE selection algorithm. It is; /// expected to walk the DIE tree in file order and (though the mediation of; /// its helper) call hasValidRelocation() on each DIE that might be a 'root; /// DIE' (See DwarfLinker class comment).; ///; /// While walking the dependencies of root DIEs, this function is also called,; /// but during these dependency walks the file order is not respected. The; /// TF_DependencyWalk flag tells us which kind of traversal we are currently; /// doing.; ///; /// The recursive algorithm is implemented iteratively as a work list because; /// very deep recursion could exhaust the stack for large projects. The work; /// list acts as a scheduler for different types of work that need to be; /// performed.; ///; /// The recursive nature of the algorithm is simulated by running the ""main""; /// algorithm (LookForDIEsToKeep) followed by either looking at more DIEs; /// (LookForChildDIEsToKeep, LookForRefDIEsToKeep, LookForParentDIEsToKeep) or; /// fixing up a computed property (UpdateChildIncompleteness,; /// UpdateRefIncompleteness).; ///; /// The return value indicates whether the DIE is incomplete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:498,Integrability,depend,dependency,498,"/// Recursively walk the \p DIE tree and look for DIEs to keep. Store that; /// information in \p CU's DIEInfo.; ///; /// This function is the entry point of the DIE selection algorithm. It is; /// expected to walk the DIE tree in file order and (though the mediation of; /// its helper) call hasValidRelocation() on each DIE that might be a 'root; /// DIE' (See DwarfLinker class comment).; ///; /// While walking the dependencies of root DIEs, this function is also called,; /// but during these dependency walks the file order is not respected. The; /// TF_DependencyWalk flag tells us which kind of traversal we are currently; /// doing.; ///; /// The recursive algorithm is implemented iteratively as a work list because; /// very deep recursion could exhaust the stack for large projects. The work; /// list acts as a scheduler for different types of work that need to be; /// performed.; ///; /// The recursive nature of the algorithm is simulated by running the ""main""; /// algorithm (LookForDIEsToKeep) followed by either looking at more DIEs; /// (LookForChildDIEsToKeep, LookForRefDIEsToKeep, LookForParentDIEsToKeep) or; /// fixing up a computed property (UpdateChildIncompleteness,; /// UpdateRefIncompleteness).; ///; /// The return value indicates whether the DIE is incomplete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:883,Performance,perform,performed,883,"/// Recursively walk the \p DIE tree and look for DIEs to keep. Store that; /// information in \p CU's DIEInfo.; ///; /// This function is the entry point of the DIE selection algorithm. It is; /// expected to walk the DIE tree in file order and (though the mediation of; /// its helper) call hasValidRelocation() on each DIE that might be a 'root; /// DIE' (See DwarfLinker class comment).; ///; /// While walking the dependencies of root DIEs, this function is also called,; /// but during these dependency walks the file order is not respected. The; /// TF_DependencyWalk flag tells us which kind of traversal we are currently; /// doing.; ///; /// The recursive algorithm is implemented iteratively as a work list because; /// very deep recursion could exhaust the stack for large projects. The work; /// list acts as a scheduler for different types of work that need to be; /// performed.; ///; /// The recursive nature of the algorithm is simulated by running the ""main""; /// algorithm (LookForDIEsToKeep) followed by either looking at more DIEs; /// (LookForChildDIEsToKeep, LookForRefDIEsToKeep, LookForParentDIEsToKeep) or; /// fixing up a computed property (UpdateChildIncompleteness,; /// UpdateRefIncompleteness).; ///; /// The return value indicates whether the DIE is incomplete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:60,Performance,perform,perform,60,// Look at the worklist type to decide what kind of work to perform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:21,Integrability,depend,dependencies,21,// We're walking the dependencies of a module forward declaration that was; // kept because there is no definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:60,Integrability,depend,dependencies,60,"// If the Keep flag is set, we are marking a required DIE's dependencies.; // If our target is already marked as kept, we're all set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:81,Energy Efficiency,schedul,schedule,81,// Finish by looking for child DIEs. Because of the LIFO worklist we need; // to schedule that work before any subsequent items are added to the; // worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:56,Integrability,depend,dependencies,56,// If it is a newly kept DIE mark it as well as all its dependencies as; // kept.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:108,Energy Efficiency,schedul,schedule,108,"// After looking at the parent chain, look for referenced DIEs. Because of; // the LIFO worklist we need to schedule that work before any subsequent; // items are added to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:7,Energy Efficiency,schedul,schedule,7,// Now schedule the parent walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:3,Deployability,Update,Update,3,// Update attributes info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:23,Modifiability,variab,variable-length,23,// DW_OP_const_type is variable-length and has 3; // operands. Thus far we only support 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:41,Deployability,update,updated,41,// The expression location data might be updated and exceed the original; // size. Check whether the new data fits into the original form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:482,Safety,avoid,avoid,482,"// Cloned Die may have address attributes relocated to a; // totally unrelated value. This can happen:; // - If high_pc is an address (Dwarf version == 2), then it might have been; // relocated to a totally unrelated value (because the end address in the; // object file might be start address of another function which got moved; // independently by the linker).; // - If address relocated in an inline_subprogram that happens at the; // beginning of its inlining function.; // To avoid above cases and to not apply relocation twice (in; // applyValidRelocs and here), read address attribute from InputDIE and apply; // Info.PCOffset here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:12,Deployability,Update,Update,12,// In case !Update the .debug_addr table is not generated/preserved.; // Thus instead of DW_FORM_rnglistx the DW_FORM_sec_offset is used.; // Since DW_AT_rnglists_base is used for only DW_FORM_rnglistx the; // DW_AT_rnglists_base is removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:12,Deployability,Update,Update,12,// In case !Update the .debug_addr table is not generated/preserved.; // Thus instead of DW_FORM_loclistx the DW_FORM_sec_offset is used.; // Since DW_AT_loclists_base is used for only DW_FORM_loclistx the; // DW_AT_loclists_base is removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:123,Availability,down,downside,123,"// We could copy the data only if we need to apply a relocation to it. After; // testing, it seems there is no performance downside to doing the copy; // unconditionally, and it makes the code simpler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:111,Performance,perform,performance,111,"// We could copy the data only if we need to apply a relocation to it. After; // testing, it seems there is no performance downside to doing the copy; // unconditionally, and it makes the code simpler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:81,Testability,test,testing,81,"// We could copy the data only if we need to apply a relocation to it. After; // testing, it seems there is no performance downside to doing the copy; // unconditionally, and it makes the code simpler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:193,Usability,simpl,simpler,193,"// We could copy the data only if we need to apply a relocation to it. After; // testing, it seems there is no performance downside to doing the copy; // unconditionally, and it makes the code simpler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:78,Deployability,install,install,78,// Add the DW_AT_APPLE_origin attribute to Compile Unit die if we have; // an install name and the DWARF doesn't have the attribute yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:3,Deployability,Update,Update,3,// Update fixups with the size of the abbreviation number,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:3,Deployability,Update,Update,3,// Update our size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:3,Deployability,Update,Update,3,// Update our size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:4,Deployability,Patch,Patch,4,/// Patch the input object file relevant debug_ranges or debug_rnglists; /// entries and emit them in the output file. Update the relevant attributes; /// to point at the new entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:119,Deployability,Update,Update,119,/// Patch the input object file relevant debug_ranges or debug_rnglists; /// entries and emit them in the output file. Update the relevant attributes; /// to point at the new entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:3,Deployability,Update,Update,3,// Update the cloned DW_AT_stmt_list with the correct debug_line offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:60,Usability,clear,clear,60,"// If all the line table contains is a DW_LNE_end_sequence, clear the line; // table rows, it will be inserted again in the DWARFStreamer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:519,Security,validat,validation,519,"// FIXME: This logic is meant to generate exactly the same output as; // Darwin's classic dsymutil. There is a nicer way to implement this; // by simply putting all the relocated line info in NewRows and simply; // sorting NewRows before passing it to emitLineTableForUnit. This; // should be correct as sequences for a function should stay; // together in the sorted output. There are a few corner cases that; // look suspicious though, and that required to implement the logic; // this way. Revisit that once initial validation is finished.; // Iterate over the object file line info and extract the sequences; // that correspond to linked functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:15,Testability,log,logic,15,"// FIXME: This logic is meant to generate exactly the same output as; // Darwin's classic dsymutil. There is a nicer way to implement this; // by simply putting all the relocated line info in NewRows and simply; // sorting NewRows before passing it to emitLineTableForUnit. This; // should be correct as sequences for a function should stay; // together in the sorted output. There are a few corner cases that; // look suspicious though, and that required to implement the logic; // this way. Revisit that once initial validation is finished.; // Iterate over the object file line info and extract the sequences; // that correspond to linked functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:473,Testability,log,logic,473,"// FIXME: This logic is meant to generate exactly the same output as; // Darwin's classic dsymutil. There is a nicer way to implement this; // by simply putting all the relocated line info in NewRows and simply; // sorting NewRows before passing it to emitLineTableForUnit. This; // should be correct as sequences for a function should stay; // together in the sorted output. There are a few corner cases that; // look suspicious though, and that required to implement the logic; // this way. Revisit that once initial validation is finished.; // Iterate over the object file line info and extract the sequences; // that correspond to linked functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:146,Usability,simpl,simply,146,"// FIXME: This logic is meant to generate exactly the same output as; // Darwin's classic dsymutil. There is a nicer way to implement this; // by simply putting all the relocated line info in NewRows and simply; // sorting NewRows before passing it to emitLineTableForUnit. This; // should be correct as sequences for a function should stay; // together in the sorted output. There are a few corner cases that; // look suspicious though, and that required to implement the logic; // this way. Revisit that once initial validation is finished.; // Iterate over the object file line info and extract the sequences; // that correspond to linked functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:204,Usability,simpl,simply,204,"// FIXME: This logic is meant to generate exactly the same output as; // Darwin's classic dsymutil. There is a nicer way to implement this; // by simply putting all the relocated line info in NewRows and simply; // sorting NewRows before passing it to emitLineTableForUnit. This; // should be correct as sequences for a function should stay; // together in the sorted output. There are a few corner cases that; // look suspicious though, and that required to implement the logic; // this way. Revisit that once initial validation is finished.; // Iterate over the object file line info and extract the sequences; // that correspond to linked functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:64,Deployability,patch,patched,64,"/// Read the frame info stored in the object, and emit the; /// patched frame descriptions for the resulting file.; ///; /// This is actually pretty easy as the data of the CIEs and FDEs can; /// be considered as black boxes and moved as is. The only thing to do; /// is to patch the addresses in the headers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:274,Deployability,patch,patch,274,"/// Read the frame info stored in the object, and emit the; /// patched frame descriptions for the resulting file.; ///; /// This is actually pretty easy as the data of the CIEs and FDEs can; /// be considered as black boxes and moved as is. The only thing to do; /// is to patch the addresses in the headers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:21,Deployability,update,updated,21,// Emit the FDE with updated address and CIE pointer.; // (4 + AddrSize) is the size of the CIEId + initial_location; // fields that will get reconstructed by emitFDE().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:10,Integrability,depend,dependencies,10,"// Cyclic dependencies are disallowed by Clang, but we still; // shouldn't run into an infinite loop, so mark it as processed now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:35,Performance,load,loadClangModule,35,/// Using a SmallString<0> because loadClangModule() is recursive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:17,Performance,cache,cached,17,// Don't use the cached binary holder because we have no thread-safety; // guarantee and the lifetime is limited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:64,Safety,safe,safety,64,// Don't use the cached binary holder because we have no thread-safety; // guarantee and the lifetime is limited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:3,Deployability,Update,Update,3,// Update the cache entry with the DwoId of the module loaded from disk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:14,Performance,cache,cache,14,// Update the cache entry with the DwoId of the module loaded from disk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:55,Performance,load,loaded,55,// Update the cache entry with the DwoId of the module loaded from disk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:24,Performance,optimiz,optimize,24,// ODR Contexts for the optimize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:9,Security,access,access,9,// Setup access to the debug info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:306,Performance,concurren,concurrently,306,"// At this point we know how much data we have emitted. We use this value to; // compare canonical DIE offsets in analyzeContextInfo to see if a definition; // is already emitted, without being affected by canonical die offsets set; // later. This prevents undeterminism when analyze and clone execute; // concurrently, as clone set the canonical DIE offset and analyze reads it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:9,Modifiability,variab,variables,9,// These variables manage the list of processed object files.; // The mutex and condition variable are to ensure that this is thread safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:90,Modifiability,variab,variable,90,// These variables manage the list of processed object files.; // The mutex and condition variable are to ensure that this is thread safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:133,Safety,safe,safe,133,// These variables manage the list of processed object files.; // The mutex and condition variable are to ensure that this is thread safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerCompileUnit.cpp:131,Integrability,depend,depending,131,"// Try to guess which DIEs must go to the accelerator tables. We do that; // just for variables, because functions will be handled depending on; // whether they carry a DW_AT_low_pc attribute or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerCompileUnit.cpp:86,Modifiability,variab,variables,86,"// Try to guess which DIEs must go to the accelerator tables. We do that; // just for variables, because functions will be handled depending on; // whether they carry a DW_AT_low_pc attribute or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerDeclContext.cpp:339,Safety,safe,safer,339,"// Gather some discriminating data about the DeclContext we will be; // creating: File, line number and byte size. This shouldn't be necessary,; // because the ODR is just about names, but given that we do some; // approximations with overloaded functions and anonymous namespaces, use; // these additional data points to make the process safer.; //; // This is disabled for clang modules, because forward declarations of; // module-defined types do not have a file and line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerDeclContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerDeclContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerDeclContext.cpp:3,Performance,Cache,Cache,3,"// Cache the resolved paths based on the index in the line table,; // because calling realpath is expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerDeclContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerDeclContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerDeclContext.cpp:6,Security,hash,hash,6,"// We hash NameRef, which is the mangled name, in order to get most; // overloaded functions resolve correctly.; //; // Strictly speaking, hashing the Tag is only necessary for a; // DW_TAG_module, to prevent uniquing of a module and a namespace; // with the same name.; //; // FIXME: dsymutil-classic won't unique the same type presented; // once as a struct and once as a class. Using the Tag in the fully; // qualified name hash to get the same effect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerDeclContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerDeclContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerDeclContext.cpp:139,Security,hash,hashing,139,"// We hash NameRef, which is the mangled name, in order to get most; // overloaded functions resolve correctly.; //; // Strictly speaking, hashing the Tag is only necessary for a; // DW_TAG_module, to prevent uniquing of a module and a namespace; // with the same name.; //; // FIXME: dsymutil-classic won't unique the same type presented; // once as a struct and once as a class. Using the Tag in the fully; // qualified name hash to get the same effect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerDeclContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerDeclContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerDeclContext.cpp:427,Security,hash,hash,427,"// We hash NameRef, which is the mangled name, in order to get most; // overloaded functions resolve correctly.; //; // Strictly speaking, hashing the Tag is only necessary for a; // DW_TAG_module, to prevent uniquing of a module and a namespace; // with the same name.; //; // FIXME: dsymutil-classic won't unique the same type presented; // once as a struct and once as a class. Using the Tag in the fully; // qualified name hash to get the same effect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerDeclContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerDeclContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFStreamer.cpp:127,Availability,avail,available,127,"// An unsigned LEB128 number representing the (implementation-defined) time; // of last modification for the file, or 0 if not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFStreamer.cpp:91,Availability,avail,available,91,"// An unsigned LEB128 number representing the length in bytes of the file,; // or 0 if not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFStreamer.cpp:3,Deployability,Update,Update,3,// Update macro attribute of cloned compile unit with the proper offset to; // the macro table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h:79,Energy Efficiency,allocate,allocated,79,/// This class is a simple list of T structures. It keeps elements as; /// pre-allocated groups to save memory for each element's next pointer.; /// It allocates internal data using specified per-thread BumpPtrAllocator.; /// Method add() can be called asynchronously.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h:152,Energy Efficiency,allocate,allocates,152,/// This class is a simple list of T structures. It keeps elements as; /// pre-allocated groups to save memory for each element's next pointer.; /// It allocates internal data using specified per-thread BumpPtrAllocator.; /// Method add() can be called asynchronously.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h:20,Usability,simpl,simple,20,/// This class is a simple list of T structures. It keeps elements as; /// pre-allocated groups to save memory for each element's next pointer.; /// It allocates internal data using specified per-thread BumpPtrAllocator.; /// Method add() can be called asynchronously.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h:3,Energy Efficiency,Allocate,Allocate,3,// Allocate head group if it is not allocated yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h:36,Energy Efficiency,allocate,allocated,36,// Allocate head group if it is not allocated yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h:3,Energy Efficiency,Allocate,Allocate,3,// Allocate next group if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h:3,Energy Efficiency,Allocate,Allocate,3,// Allocate new group. Put allocated group into the \p AtomicGroup if; // it is empty. If \p AtomicGroup is filled by another thread then; // put allocated group into the end of groups list.; // \returns true if allocated group is put into the \p AtomicGroup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h:27,Energy Efficiency,allocate,allocated,27,// Allocate new group. Put allocated group into the \p AtomicGroup if; // it is empty. If \p AtomicGroup is filled by another thread then; // put allocated group into the end of groups list.; // \returns true if allocated group is put into the \p AtomicGroup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h:146,Energy Efficiency,allocate,allocated,146,// Allocate new group. Put allocated group into the \p AtomicGroup if; // it is empty. If \p AtomicGroup is filled by another thread then; // put allocated group into the end of groups list.; // \returns true if allocated group is put into the \p AtomicGroup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h:212,Energy Efficiency,allocate,allocated,212,// Allocate new group. Put allocated group into the \p AtomicGroup if; // it is empty. If \p AtomicGroup is filled by another thread then; // put allocated group into the end of groups list.; // \returns true if allocated group is put into the \p AtomicGroup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h:3,Energy Efficiency,Allocate,Allocate,3,// Allocate new group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h:37,Energy Efficiency,allocate,allocated,37,// Try to replace current group with allocated one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h:7,Energy Efficiency,allocate,allocated,7,// Put allocated group as last group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DebugLineSectionEmitter.h:17,Integrability,depend,dependence,17,"// FIXME: remove dependence on MCDwarfLineAddr::encode.; // As we reuse MCDwarfLineAddr::encode, we need to create/initialize; // some MC* classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DebugLineSectionEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DebugLineSectionEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DebugLineSectionEmitter.h:3,Deployability,Update,Update,3,// Update unit length field with actual length value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DebugLineSectionEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DebugLineSectionEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DebugLineSectionEmitter.h:3,Deployability,Update,Update,3,// Update prologue length field with actual length value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DebugLineSectionEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DebugLineSectionEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DebugLineSectionEmitter.h:127,Availability,avail,available,127,"// An unsigned LEB128 number representing the (implementation-defined); // time of last modification for the file, or 0 if not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DebugLineSectionEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DebugLineSectionEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DebugLineSectionEmitter.h:91,Availability,avail,available,91,"// An unsigned LEB128 number representing the length in bytes of the file,; // or 0 if not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DebugLineSectionEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DebugLineSectionEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp:6,Integrability,Depend,DependencyTracker,6,"//=== DependencyTracker.cpp -----------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp:8,Modifiability,variab,variable,8,// Keep variable referencing live address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp:6,Modifiability,variab,variable,6,"// If variable is in module scope and this module allows ODR; // deduplication set ""TypeTable"" placement, otherwise set """" placement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp:30,Deployability,update,update,30,// FIXME: we probably need to update getKeepTypeChildren status for; // parents of *Root.ReferencedBy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp:75,Integrability,Depend,Depending,75,"// This function tries to set specified \p Placement for the \p Entry.; // Depending on the concrete entry, the placement could be:; // a) changed to another.; // b) joined with current entry placement.; // c) set as requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp:14,Modifiability,variab,variable,14,"// Do not put variable into the ""TypeTable"" and ""PlainDwarf"" at the same; // time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp:10,Modifiability,variab,variables,10,// Global variables with constant value can always be kept.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp:75,Modifiability,variab,variable,75,"// See if there is a relocation to a valid debug map entry inside this; // variable's location. The order is important here. We want to always; // check if the variable has a location expression address. However, we; // don't want a static variable in a function to force us to keep the; // enclosing function, unless requested explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp:160,Modifiability,variab,variable,160,"// See if there is a relocation to a valid debug map entry inside this; // variable's location. The order is important here. We want to always; // check if the variable has a location expression address. However, we; // don't want a static variable in a function to force us to keep the; // enclosing function, unless requested explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp:240,Modifiability,variab,variable,240,"// See if there is a relocation to a valid debug map entry inside this; // variable's location. The order is important here. We want to always; // check if the variable has a location expression address. However, we; // don't want a static variable in a function to force us to keep the; // enclosing function, unless requested explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp:3,Security,Validat,Validate,3,// Validate subprogram address range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h:8,Integrability,Depend,DependencyTracker,8,"//===- ""DependencyTracker.h"" ------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h:30,Integrability,depend,dependencies,30,"/// This class discovers DIEs dependencies: marks ""live"" DIEs, marks DIE; /// locations (whether DIE should be cloned as regular DIE or it should be put; /// into the artificial type unit).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h:244,Integrability,mediat,mediation,244,"/// Recursively walk the \p DIE tree and look for DIEs to keep. Store that; /// information in \p CU's DIEInfo.; ///; /// This function is the entry point of the DIE selection algorithm. It is; /// expected to walk the DIE tree and(through the mediation of; /// Context.File.Addresses) ask for relocation adjustment value on each; /// DIE that might be a 'root DIE'(f.e. subprograms, variables).; ///; /// Returns true if all dependencies are correctly discovered. Inter-CU; /// dependencies cannot be discovered if referenced CU is not analyzed yet.; /// If that is the case this method returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h:426,Integrability,depend,dependencies,426,"/// Recursively walk the \p DIE tree and look for DIEs to keep. Store that; /// information in \p CU's DIEInfo.; ///; /// This function is the entry point of the DIE selection algorithm. It is; /// expected to walk the DIE tree and(through the mediation of; /// Context.File.Addresses) ask for relocation adjustment value on each; /// DIE that might be a 'root DIE'(f.e. subprograms, variables).; ///; /// Returns true if all dependencies are correctly discovered. Inter-CU; /// dependencies cannot be discovered if referenced CU is not analyzed yet.; /// If that is the case this method returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h:479,Integrability,depend,dependencies,479,"/// Recursively walk the \p DIE tree and look for DIEs to keep. Store that; /// information in \p CU's DIEInfo.; ///; /// This function is the entry point of the DIE selection algorithm. It is; /// expected to walk the DIE tree and(through the mediation of; /// Context.File.Addresses) ask for relocation adjustment value on each; /// DIE that might be a 'root DIE'(f.e. subprograms, variables).; ///; /// Returns true if all dependencies are correctly discovered. Inter-CU; /// dependencies cannot be discovered if referenced CU is not analyzed yet.; /// If that is the case this method returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h:384,Modifiability,variab,variables,384,"/// Recursively walk the \p DIE tree and look for DIEs to keep. Store that; /// information in \p CU's DIEInfo.; ///; /// This function is the entry point of the DIE selection algorithm. It is; /// expected to walk the DIE tree and(through the mediation of; /// Context.File.Addresses) ask for relocation adjustment value on each; /// DIE that might be a 'root DIE'(f.e. subprograms, variables).; ///; /// Returns true if all dependencies are correctly discovered. Inter-CU; /// dependencies cannot be discovered if referenced CU is not analyzed yet.; /// If that is the case this method returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h:155,Deployability,update,updated,155,"/// Check if dependencies have incompatible placement.; /// If that is the case modify placement to be compatible.; /// \returns true if any placement was updated, otherwise returns false.; /// This method should be called as a followup processing after; /// resolveDependenciesAndMarkLiveness().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h:13,Integrability,depend,dependencies,13,"/// Check if dependencies have incompatible placement.; /// If that is the case modify placement to be compatible.; /// \returns true if any placement was updated, otherwise returns false.; /// This method should be called as a followup processing after; /// resolveDependenciesAndMarkLiveness().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h:101,Availability,error,error,101,"/// Recursively walk the \p DIE tree and check ""keepness"" and ""placement""; /// information. It is an error if parent node does not have ""keep"" flag,; /// while child has one. It is an error if parent node has ""TypeTable""; /// placement while child has ""PlainDwarf"" placement. This function dump error; /// at stderr in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h:184,Availability,error,error,184,"/// Recursively walk the \p DIE tree and check ""keepness"" and ""placement""; /// information. It is an error if parent node does not have ""keep"" flag,; /// while child has one. It is an error if parent node has ""TypeTable""; /// placement while child has ""PlainDwarf"" placement. This function dump error; /// at stderr in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h:295,Availability,error,error,295,"/// Recursively walk the \p DIE tree and check ""keepness"" and ""placement""; /// information. It is an error if parent node does not have ""keep"" flag,; /// while child has one. It is an error if parent node has ""TypeTable""; /// placement while child has ""PlainDwarf"" placement. This function dump error; /// at stderr in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h:96,Deployability,update,update,96,/// Another root entry which references this RootDieEntry.; /// ReferencedByDieEntry is kept to update placement.; /// if RootDieEntry has placement incompatible with placement; /// of ReferencedByDieEntry then it should be updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h:224,Deployability,update,updated,224,/// Another root entry which references this RootDieEntry.; /// ReferencedByDieEntry is kept to update placement.; /// if RootDieEntry has placement incompatible with placement; /// of ReferencedByDieEntry then it should be updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h:30,Modifiability,variab,variable,30,/// Returns true if specified variable references live code section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h:20,Integrability,depend,dependencies,20,/// List of entries dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp:123,Availability,down,downside,123,"// We could copy the data only if we need to apply a relocation to it. After; // testing, it seems there is no performance downside to doing the copy; // unconditionally, and it makes the code simpler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp:111,Performance,perform,performance,111,"// We could copy the data only if we need to apply a relocation to it. After; // testing, it seems there is no performance downside to doing the copy; // unconditionally, and it makes the code simpler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp:81,Testability,test,testing,81,"// We could copy the data only if we need to apply a relocation to it. After; // testing, it seems there is no performance downside to doing the copy; // unconditionally, and it makes the code simpler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp:193,Usability,simpl,simpler,193,"// We could copy the data only if we need to apply a relocation to it. After; // testing, it seems there is no performance downside to doing the copy; // unconditionally, and it makes the code simpler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp:12,Deployability,Update,Update,12,// In case !Update the .debug_addr table is not generated/preserved.; // Thus instead of DW_FORM_rnglistx the DW_FORM_sec_offset is used.; // Since DW_AT_rnglists_base is used for only DW_FORM_rnglistx the; // DW_AT_rnglists_base is removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp:12,Deployability,Update,Update,12,// In case !Update the .debug_addr table is not generated/preserved.; // Thus instead of DW_FORM_loclistx the DW_FORM_sec_offset is used.; // Since DW_AT_loclists_base is used for only DW_FORM_loclistx the; // DW_AT_loclists_base is removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp:3,Deployability,Update,Update,3,// Update attributes info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp:58,Deployability,patch,patch,58,// If offset value is not known at this point then create patch for the; // reference value and write dummy value into the attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp:10,Deployability,patch,patches,10,// Create patches for attribute referencing other non invariant section.; // Invariant section could not be updated here as this section and; // reference to it do not change value in case --update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp:108,Deployability,update,updated,108,// Create patches for attribute referencing other non invariant section.; // Invariant section could not be updated here as this section and; // reference to it do not change value in case --update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp:191,Deployability,update,update,191,// Create patches for attribute referencing other non invariant section.; // Invariant section could not be updated here as this section and; // reference to it do not change value in case --update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp:125,Deployability,patch,patching,125,// Use size of .debug_str_offsets header as attribute value. The offset; // to .debug_str_offsets would be added later while patching.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp:129,Deployability,update,update,129,// Value of DW_AT_decl_file may exceed original form. Longer; // form can affect offsets to the following attributes. To not; // update offsets of the following attributes we always remove; // original DW_AT_decl_file and attach it to the last position; // later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp:10,Deployability,patch,patch,10,// Create patch for the range offset value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp:10,Deployability,patch,patch,10,// Create patch for the location offset value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp:111,Deployability,patch,patching,111,// Use size of .debug_addr header as attribute value. The offset to; // .debug_addr would be added later while patching.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp:41,Deployability,update,updated,41,// The expression location data might be updated and exceed the original size.; // Check whether the new data fits into the original form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp:3,Deployability,Update,Update,3,// Update patches offsets with the size of length field for Bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp:10,Deployability,patch,patches,10,// Update patches offsets with the size of length field for Bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp:482,Safety,avoid,avoid,482,"// Cloned Die may have address attributes relocated to a; // totally unrelated value. This can happen:; // - If high_pc is an address (Dwarf version == 2), then it might have been; // relocated to a totally unrelated value (because the end address in the; // object file might be start address of another function which got moved; // independently by the linker).; // - If address relocated in an inline_subprogram that happens at the; // beginning of its inlining function.; // To avoid above cases and to not apply relocation twice (in; // applyValidRelocs and here), read address attribute from InputDIE and apply; // Info.PCOffset here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.h:19,Performance,concurren,concurrently,19,/// Cannot be used concurrently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.h:34,Modifiability,variab,variable,34,/// Relocation adjustment for the variable locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.h:4,Deployability,Patch,Patches,4,/// Patches for the cloned attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEGenerator.h:41,Deployability,update,updated,41,// The expression location data might be updated and exceed the original; // size. Check whether the new data fits into the original form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEGenerator.h:90,Deployability,Update,Updates,90,/// Creates appreviations for the current DIE. Returns value of; /// abbreviation number. Updates offsets with the size of abbreviation; /// number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFEmitterImpl.h:24,Deployability,patch,patches,24,// Enumerate all string patches and write them into the destination section.; // Order of patches is the same as in original input file. To avoid emitting; // the same string twice we accumulate NextOffset value. Thus if string; // offset smaller than NextOffset value then the patch is skipped (as that; // string was emitted earlier).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFEmitterImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFEmitterImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFEmitterImpl.h:90,Deployability,patch,patches,90,// Enumerate all string patches and write them into the destination section.; // Order of patches is the same as in original input file. To avoid emitting; // the same string twice we accumulate NextOffset value. Thus if string; // offset smaller than NextOffset value then the patch is skipped (as that; // string was emitted earlier).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFEmitterImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFEmitterImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFEmitterImpl.h:278,Deployability,patch,patch,278,// Enumerate all string patches and write them into the destination section.; // Order of patches is the same as in original input file. To avoid emitting; // the same string twice we accumulate NextOffset value. Thus if string; // offset smaller than NextOffset value then the patch is skipped (as that; // string was emitted earlier).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFEmitterImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFEmitterImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFEmitterImpl.h:140,Safety,avoid,avoid,140,// Enumerate all string patches and write them into the destination section.; // Order of patches is the same as in original input file. To avoid emitting; // the same string twice we accumulate NextOffset value. Thus if string; // offset smaller than NextOffset value then the patch is skipped (as that; // string was emitted earlier).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFEmitterImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFEmitterImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:43,Performance,Load,Loaded,43,"// Nothing to reset if stage is less than ""Loaded"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:36,Performance,Load,Loaded,36,"// Note: We need to do erasing for ""Loaded"" stage because; // if live analysys failed then we will have ""Loaded"" stage; // with marking from ""LivenessAnalysisDone"" stage partially; // done. That marking should be cleared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:105,Performance,Load,Loaded,105,"// Note: We need to do erasing for ""Loaded"" stage because; // if live analysys failed then we will have ""Loaded"" stage; // with marking from ""LivenessAnalysisDone"" stage partially; // done. That marking should be cleared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:213,Usability,clear,cleared,213,"// Note: We need to do erasing for ""Loaded"" stage because; // if live analysys failed then we will have ""Loaded"" stage; // with marking from ""LivenessAnalysisDone"" stage partially; // done. That marking should be cleared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:3,Performance,load,load,3,"// load input dies, resize Info structures array.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:3,Performance,Cache,Cache,3,"// Cache the resolved paths based on the index in the line table,; // because calling realpath is expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:60,Performance,cache,cache,60,"// If the ParentPath has not yet been resolved, resolve and cache it for; // future look-ups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:42,Integrability,interface,interfaces,42,/// Collect references to parseable Swift interfaces in imported; /// DW_TAG_module blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:15,Integrability,interface,interfaces,15,// Don't track interfaces that are part of the SDK.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:15,Integrability,interface,interfaces,15,"// Don't track interfaces that are part of the toolchain.; // For example: Swift, _Concurrency, ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:71,Performance,load,loaded,71,// Referenced DIE is in other compile unit.; // Check whether DIEs are loaded for that compile unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:3,Deployability,Patch,Patch,3,// Patch section length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:3,Deployability,Update,Update,3,// Update Aranges lentgh.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:23,Modifiability,variab,variable-length,23,// DW_OP_const_type is variable-length and has 3; // operands. Thus far we only support 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:53,Deployability,update,update,53,"// Use fixed size for ULEB128 data, since we need to update that size; // later with the proper offsets. Use 5 for DWARF32, 9 for DWARF64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:3,Deployability,Update,Update,3,// Update our size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:51,Modifiability,variab,variable,51,// Get relocation adjustment value for the current variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:4,Energy Efficiency,Allocate,Allocates,4,/// Allocates output DIE for the specified \p TypeDescriptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:10,Energy Efficiency,allocate,allocate,10,// Do not allocate any new DIE if definition DIE is already met.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate definition DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:72,Safety,avoid,avoid,72,// if AttributesCloner.getOutOffset() == 0 then we need to add; // 1 to avoid assertion for zero size. We will subtract it back later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:78,Testability,assert,assertion,78,// if AttributesCloner.getOutOffset() == 0 then we need to add; // 1 to avoid assertion for zero size. We will subtract it back later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:60,Usability,clear,clear,60,"// If all the line table contains is a DW_LNE_end_sequence, clear the line; // table rows, it will be inserted again in the DWARFStreamer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:519,Security,validat,validation,519,"// FIXME: This logic is meant to generate exactly the same output as; // Darwin's classic dsymutil. There is a nicer way to implement this; // by simply putting all the relocated line info in NewRows and simply; // sorting NewRows before passing it to emitLineTableForUnit. This; // should be correct as sequences for a function should stay; // together in the sorted output. There are a few corner cases that; // look suspicious though, and that required to implement the logic; // this way. Revisit that once initial validation is finished.; // Iterate over the object file line info and extract the sequences; // that correspond to linked functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:15,Testability,log,logic,15,"// FIXME: This logic is meant to generate exactly the same output as; // Darwin's classic dsymutil. There is a nicer way to implement this; // by simply putting all the relocated line info in NewRows and simply; // sorting NewRows before passing it to emitLineTableForUnit. This; // should be correct as sequences for a function should stay; // together in the sorted output. There are a few corner cases that; // look suspicious though, and that required to implement the logic; // this way. Revisit that once initial validation is finished.; // Iterate over the object file line info and extract the sequences; // that correspond to linked functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:473,Testability,log,logic,473,"// FIXME: This logic is meant to generate exactly the same output as; // Darwin's classic dsymutil. There is a nicer way to implement this; // by simply putting all the relocated line info in NewRows and simply; // sorting NewRows before passing it to emitLineTableForUnit. This; // should be correct as sequences for a function should stay; // together in the sorted output. There are a few corner cases that; // look suspicious though, and that required to implement the logic; // this way. Revisit that once initial validation is finished.; // Iterate over the object file line info and extract the sequences; // that correspond to linked functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:146,Usability,simpl,simply,146,"// FIXME: This logic is meant to generate exactly the same output as; // Darwin's classic dsymutil. There is a nicer way to implement this; // by simply putting all the relocated line info in NewRows and simply; // sorting NewRows before passing it to emitLineTableForUnit. This; // should be correct as sequences for a function should stay; // together in the sorted output. There are a few corner cases that; // look suspicious though, and that required to implement the logic; // this way. Revisit that once initial validation is finished.; // Iterate over the object file line info and extract the sequences; // that correspond to linked functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:204,Usability,simpl,simply,204,"// FIXME: This logic is meant to generate exactly the same output as; // Darwin's classic dsymutil. There is a nicer way to implement this; // by simply putting all the relocated line info in NewRows and simply; // sorting NewRows before passing it to emitLineTableForUnit. This; // should be correct as sequences for a function should stay; // together in the sorted output. There are a few corner cases that; // look suspicious though, and that required to implement the logic; // this way. Revisit that once initial validation is finished.; // Iterate over the object file line info and extract the sequences; // that correspond to linked functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:261,Integrability,Depend,DependencyTracker,261,"/// Stores all information related to a compile unit, be it in its original; /// instance of the object file or its brand new cloned and generated DIE tree.; /// NOTE: we need alignment of at least 8 bytes as we use; /// PointerIntPair<CompileUnit *, 3> in the DependencyTracker.h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:19,Performance,load,loaded,19,/// Input DWARF is loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:13,Integrability,depend,dependencies,13,/// Check if dependencies have incompatible placement.; /// If that is the case modify placement to be compatible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:19,Deployability,patch,patch,19,/// Offsets inside patch records are updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:37,Deployability,update,updated,37,/// Offsets inside patch records are updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:50,Deployability,release,released,50,"/// Resources(Input DWARF, Output DWARF tree) are released.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:4,Performance,Load,Loads,4,/// Loads unit line table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:4,Performance,Load,Load,4,/// Load DIEs of input compilation unit. \returns true if input DIEs; /// successfully loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:87,Performance,load,loaded,87,/// Load DIEs of input compilation unit. \returns true if input DIEs; /// successfully loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:111,Performance,Load,Loaded,111,"/// Reset compile units data(results of liveness analysis, clonning); /// if current stage greater than Stage::Loaded. We need to reset data; /// as we are going to repeat stages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:42,Integrability,interface,interfaces,42,/// Collect references to parseable Swift interfaces in imported; /// DW_TAG_module blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:134,Deployability,patch,patches,134,/// After cloning stage the output DIEs offsets are deallocated.; /// This method copies output offsets for referenced DIEs into DIEs patches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:81,Integrability,depend,dependend,81,"/// Search for subprograms and variables referencing live code and discover; /// dependend DIEs. Mark live DIEs, set placement for DIEs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:31,Modifiability,variab,variables,31,"/// Search for subprograms and variables referencing live code and discover; /// dependend DIEs. Mark live DIEs, set placement for DIEs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:10,Integrability,depend,dependend,10,/// Check dependend DIEs for incompatible placement.; /// Make placement to be consistent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:11,Availability,avail,available,11,/// DIE is available for ODR type deduplication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:32,Security,access,access,32,/// \defgroup Helper methods to access OrigUnit.; ///; /// @{; /// Returns paired compile unit from input DWARF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:62,Availability,error,errors,62,/// @}; /// \defgroup Methods used for reporting warnings and errors:; ///; /// @{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:4,Security,Access,Accessor,4,/// Accessor for common functionality.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:4,Performance,Cache,Cached,4,"/// Cached resolved paths from the line table.; /// The key is <UniqueUnitID, FileIdx>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:27,Security,access,accessed,27,/// \defgroup Data Members accessed asinchronously.; ///; /// @{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:154,Safety,avoid,avoid,154,/// \returns list of attributes referencing type DIEs which might be; /// deduplicated.; /// Note: it does not include DW_AT_containing_type attribute to avoid; /// infinite recursion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerGlobalData.h:24,Testability,log,log,24,/// Generate processing log to the standard output.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerGlobalData.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerGlobalData.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerGlobalData.h:4,Deployability,Update,Update,4,/// Update index tables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerGlobalData.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerGlobalData.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerGlobalData.h:29,Modifiability,variab,variable,29,/// Whether we want a static variable to force us to keep its enclosing; /// function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerGlobalData.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerGlobalData.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerGlobalData.h:8,Availability,error,error,8,/// Set error handler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerGlobalData.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerGlobalData.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerGlobalData.h:11,Availability,error,error,11,/// Report error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerGlobalData.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerGlobalData.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerGlobalData.h:11,Availability,error,error,11,/// Report error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerGlobalData.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerGlobalData.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:92,Deployability,update,update,92,"// At this stage each compile units are cloned to their own set of debug; // sections. Now, update patches, assign offsets and assemble final file; // glueing debug tables from each compile unit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:99,Deployability,patch,patches,99,"// At this stage each compile units are cloned to their own set of debug; // sections. Now, update patches, assign offsets and assemble final file; // glueing debug tables from each compile unit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:43,Deployability,update,update,43,// Do not do types deduplication in case --update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:274,Security,hash,hash,274,"/// If this compile unit is really a skeleton CU that points to a; /// clang module, register it in ClangModules and return true.; ///; /// A skeleton CU is a CU without children, a DW_AT_gnu_dwo_name; /// pointing to the module, and a DW_AT_gnu_dwo_id with the module; /// hash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:10,Integrability,depend,dependencies,10,"// Cyclic dependencies are disallowed by Clang, but we still; // shouldn't run into an infinite loop, so mark it as processed now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:35,Performance,load,loadClangModule,35,/// Using a SmallString<0> because loadClangModule() is recursive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:17,Performance,cache,cached,17,// Don't use the cached binary holder because we have no thread-safety; // guarantee and the lifetime is limited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:64,Safety,safe,safety,64,// Don't use the cached binary holder because we have no thread-safety; // guarantee and the lifetime is limited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:3,Deployability,Update,Update,3,// Update the cache entry with the DwoId of the module loaded from disk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:14,Performance,cache,cache,14,// Update the cache entry with the DwoId of the module loaded from disk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:55,Performance,load,loaded,55,// Update the cache entry with the DwoId of the module loaded from disk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:38,Performance,load,loaded,38,"// Preload line table, as it can't be loaded asynchronously.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:42,Performance,load,loaded,42,"// Preload macro tables, as they can't be loaded asynchronously.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:83,Performance,load,load,83,"// Create CompileUnit structures to keep information about source; // DWARFUnit`s, load line tables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:3,Performance,Load,Load,3,// Load only unit DIE at this stage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:38,Performance,load,loaded,38,"// Preload line table, as it can't be loaded asynchronously.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:3,Performance,Load,Load,3,// Load inter-connected units.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:3,Deployability,Update,Update,3,// Update dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:10,Integrability,depend,dependencies,10,// Update dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:3,Deployability,Update,Update,3,// Update patches for inter-connected units.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:10,Deployability,patch,patches,10,// Update patches for inter-connected units.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:3,Deployability,Release,Release,3,// Release data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:3,Performance,Load,Load,3,// Load input compilation unit DIEs.; // Analyze properties of DIEs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:209,Availability,error,errors,209,"// The registerModuleReference() condition effectively skips; // over fully resolved skeleton units. This second pass of; // registerModuleReferences doesn't do any new work, but it; // will collect top-level errors, which are suppressed. Module; // warnings were already displayed in the first iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:3,Deployability,Update,Update,3,// Update DIEs referencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:55,Deployability,update,update,55,"// Remember offset to the FDE record, so that we might update; // field referencing CIE record(containing OffsetToCIERecord),; // when final offsets are known. OffsetToCIERecord(which is written later); // is local to the current .debug_frame section, it should be updated; // with final offset of the .debug_frame section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:265,Deployability,update,updated,265,"// Remember offset to the FDE record, so that we might update; // field referencing CIE record(containing OffsetToCIERecord),; // when final offsets are known. OffsetToCIERecord(which is written later); // is local to the current .debug_frame section, it should be updated; // with final offset of the .debug_frame section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:21,Deployability,update,updated,21,// Emit the FDE with updated address and CIE pointer.; // (4 + AddrSize) is the size of the CIEId + initial_location; // fields that will get reconstructed by emitFDE().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:3,Deployability,Patch,Patch,3,// Patch size/offsets fields according to the assigned CU offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:97,Deployability,patch,patches,97,// To save space we do not create any separate string table.; // We use already allocated string patches and accelerator entries:; // enumerate them in natural order and assign offsets.; // ASSUMPTION: strings should be stored into .debug_str/.debug_line_str; // sections in the same order as they were assigned offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:80,Energy Efficiency,allocate,allocated,80,// To save space we do not create any separate string table.; // We use already allocated string patches and accelerator entries:; // enumerate them in natural order and assign offsets.; // ASSUMPTION: strings should be stored into .debug_str/.debug_line_str; // sections in the same order as they were assigned offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:120,Safety,safe,safe,120,// Create section descriptors ahead if they are not exist at the moment.; // SectionDescriptors container is not thread safe. Thus we should be sure; // that descriptors would not be created in following parallel tasks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:235,Deployability,Update,Update,235,"/// Add object file to be linked. Pre-load compile unit die. Call; /// \p OnCUDieLoaded for each compile unit die. If specified \p File; /// has reference to the Clang module then such module would be; /// pre-loaded by \p Loader for !Update case.; ///; /// \pre NoODR, Update options should be set before call to addObjectFile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:270,Deployability,Update,Update,270,"/// Add object file to be linked. Pre-load compile unit die. Call; /// \p OnCUDieLoaded for each compile unit die. If specified \p File; /// has reference to the Clang module then such module would be; /// pre-loaded by \p Loader for !Update case.; ///; /// \pre NoODR, Update options should be set before call to addObjectFile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:38,Performance,load,load,38,"/// Add object file to be linked. Pre-load compile unit die. Call; /// \p OnCUDieLoaded for each compile unit die. If specified \p File; /// has reference to the Clang module then such module would be; /// pre-loaded by \p Loader for !Update case.; ///; /// \pre NoODR, Update options should be set before call to addObjectFile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:210,Performance,load,loaded,210,"/// Add object file to be linked. Pre-load compile unit die. Call; /// \p OnCUDieLoaded for each compile unit die. If specified \p File; /// has reference to the Clang module then such module would be; /// pre-loaded by \p Loader for !Update case.; ///; /// \pre NoODR, Update options should be set before call to addObjectFile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:223,Performance,Load,Loader,223,"/// Add object file to be linked. Pre-load compile unit die. Call; /// \p OnCUDieLoaded for each compile unit die. If specified \p File; /// has reference to the Clang module then such module would be; /// pre-loaded by \p Loader for !Update case.; ///; /// \pre NoODR, Update options should be set before call to addObjectFile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:97,Testability,log,log,97,/// \defgroup Methods setting various linking options:; ///; /// @{; ///; /// Allows to generate log of linking process to the standard output.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:4,Deployability,Update,Update,4,/// Update index tables only(do not modify rest of DWARF).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:52,Modifiability,variab,variable,52,/// Set to keep the enclosing function for a static variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:77,Availability,error,errors,77,/// Set verification handler which would be used to report verification; /// errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:22,Integrability,interface,interfaces,22,/// Set map for Swift interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:4,Security,Validat,Validate,4,/// Validate specified options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:58,Performance,load,loaded,58,/// Keep information for referenced clang module: already loaded DWARF info; /// of the clang module and a CompileUnit of the module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:36,Security,access,accessed,36,/// Set of Compilation Units(may be accessed asynchroniously for reading).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:30,Performance,optimiz,optimizing,30,/// Size of Debug info before optimizing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:55,Performance,load,loaded,55,/// Flag indicating that all inter-connected units are loaded; /// and the dwarf linking process for these units is started.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:105,Availability,error,error,105,/// Check whether specified \p CUDie is a Clang module reference.; /// if \p Quiet is false then display error messages.; /// \return first == true if CUDie is a Clang module reference.; /// second == true if module is already loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:111,Integrability,message,messages,111,/// Check whether specified \p CUDie is a Clang module reference.; /// if \p Quiet is false then display error messages.; /// \return first == true if CUDie is a Clang module reference.; /// second == true if module is already loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:227,Performance,load,loaded,227,/// Check whether specified \p CUDie is a Clang module reference.; /// if \p Quiet is false then display error messages.; /// \return first == true if CUDie is a Clang module reference.; /// second == true if module is already loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:274,Security,hash,hash,274,"/// If this compile unit is really a skeleton CU that points to a; /// clang module, register it in ClangModules and return true.; ///; /// A skeleton CU is a CU without children, a DW_AT_gnu_dwo_name; /// pointing to the module, and a DW_AT_gnu_dwo_id with the module; /// hash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:19,Deployability,patch,patches,19,/// Enumerates all patches and update them with the correct values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:31,Deployability,update,update,31,/// Enumerates all patches and update them with the correct values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:27,Security,access,accessed,27,/// \defgroup Data members accessed asinchroniously.; ///; /// @{; /// Unique ID for compile unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:35,Security,access,accessed,35,/// @}; /// \defgroup Data members accessed sequentially.; ///; /// @{; /// DwarfStringPoolEntries for .debug_str section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.cpp:3,Deployability,Update,Update,3,// Update patch offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.cpp:10,Deployability,patch,patch,10,// Update patch offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.cpp:18,Deployability,patch,patches,18,// Sort decl type patches to have a deterministic output.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.cpp:8,Deployability,patch,patches,8,// Sort patches to have a deterministic output.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.cpp:3,Deployability,Update,Update,3,// Update DW_AT_decl_file attribute,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.cpp:8,Deployability,patch,patches,8,// Sort patches to have a deterministic output.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.cpp:8,Deployability,patch,patches,8,// Sort patches to have a deterministic output.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.h:22,Modifiability,extend,extends,22,/// TypeUnitAccelInfo extends AccelInfo structure with type specific fileds.; /// We need these additional fields to decide whether OutDIE should have an; /// accelerator record or not. The TypeEntryBodyPtr can refer to the; /// declaration DIE and definition DIE corresponding to the type entry.; /// Only one of them would be used in final output. So if TypeUnitAccelInfo; /// refers OutDIE which does not match with TypeEntryBodyPtr->getFinalDie(); /// then such record should be skipped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerTypeUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.cpp:17,Integrability,depend,dependence,17,// FIXME: Remove dependence on DwarfEmitterImpl/AsmPrinter and emit DIEs; // directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.cpp:8,Deployability,patch,patch,8,// Note patch for string offset value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.cpp:3,Deployability,Patch,Patch,3,// Patch section length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.h:62,Availability,error,errors,62,/// @}; /// \defgroup Methods used for reporting warnings and errors:; ///; /// @{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.h:4,Security,Hash,Hash,4,/// Hash of the fully qualified name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.h:4,Safety,Avoid,Avoid,4,/// Avoid emitting this entry for pub sections.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.h:4,Performance,Cache,Cache,4,/// Cache for file names for this unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.cpp:66,Deployability,Patch,PatchOffset,66,/// Writes integer value \p Val of SLEB128 format by specified \p PatchOffset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:53,Deployability,update,updated,53,"/// There are fields(sizes, offsets) which should be updated after; /// sections are generated. To remember offsets and related data; /// the descendants of SectionPatch structure should be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:30,Deployability,update,update,30,/// This structure is used to update strings offsets into .debug_str.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:30,Deployability,update,update,30,/// This structure is used to update strings offsets into .debug_line_str.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:30,Deployability,update,update,30,/// This structure is used to update range list offset into; /// .debug_ranges/.debug_rnglists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:14,Deployability,patch,patch,14,/// Indicates patch which points to immediate compile unit's attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:30,Deployability,update,update,30,/// This structure is used to update location list offset into; /// .debug_loc/.debug_loclists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:30,Deployability,update,update,30,/// This structure is used to update offset with start of another section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:30,Deployability,update,update,30,/// This structure is used to update reference to the DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:30,Deployability,update,update,30,/// This structure is used to update reference to the DIE of ULEB128 form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:30,Deployability,update,update,30,/// This structure is used to update reference to the type DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:30,Deployability,update,update,30,/// This structure is used to update reference to the type DIE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:33,Deployability,patch,patches,33,/// Type for list of pointers to patches offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:94,Deployability,patch,patches,94,"/// This structure is used to keep data of the concrete section.; /// Like data bits, list of patches, format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:51,Deployability,patch,patches,51,"/// Erase whole section content(data bits, list of patches).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:12,Deployability,patch,patches,12,/// Section patches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:19,Deployability,patch,patches,19,"/// While creating patches, offsets to attributes may be partially; /// unknown(because size of abbreviation number is unknown). In such case we; /// remember patch itself and pointer to patch application offset to add size; /// of abbreviation number later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:159,Deployability,patch,patch,159,"/// While creating patches, offsets to attributes may be partially; /// unknown(because size of abbreviation number is unknown). In such case we; /// remember patch itself and pointer to patch application offset to add size; /// of abbreviation number later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:187,Deployability,patch,patch,187,"/// While creating patches, offsets to attributes may be partially; /// unknown(because size of abbreviation number is unknown). In such case we; /// remember patch itself and pointer to patch application offset to add size; /// of abbreviation number later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:35,Deployability,update,updated,35,// emit bad offset which should be updated later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:54,Deployability,Patch,PatchOffset,54,/// Write specified \p Value of \p AttrForm to the \p PatchOffset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:61,Deployability,Patch,PatchOffset,61,/// Returns integer value of \p Size located by specified \p PatchOffset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:59,Deployability,Patch,PatchOffset,59,/// Writes integer value \p Val of \p Size by specified \p PatchOffset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:66,Deployability,Patch,PatchOffset,66,/// Writes integer value \p Val of ULEB128 format by specified \p PatchOffset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:66,Deployability,Patch,PatchOffset,66,/// Writes integer value \p Val of SLEB128 format by specified \p PatchOffset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:107,Deployability,update,update,107,"/// Enumerate all sections, for each section set current offset; /// (kept by \p SectionSizesAccumulator), update current offset with section; /// length.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h:63,Deployability,patch,patches,63,"/// Enumerate all sections, for each section apply all section patches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/OutputSections.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/SyntheticTypeNameBuilder.h:211,Integrability,depend,depending,211,"/// Analyze \p InputUnitEntryPair for the type name and possibly assign; /// built type name to the DIE's type info.; /// NOTE: while analyzing types we may create different kind of names; /// for the same type depending on whether the type is part of another type.; /// f.e. DW_TAG_formal_parameter would receive ""{02}01"" name when; /// examined alone. Or ""{0}int"" name when it is a part of a function name:; /// {a}void foo({0}int). The \p AssignNameToTypeDescriptor tells whether; /// the type name is part of another type name and then should not be assigned; /// to DIE type descriptor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/SyntheticTypeNameBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/SyntheticTypeNameBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/TypePool.h:13,Security,Hash,Hash,13,/// \returns Hash value for the specified \p Key.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/TypePool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/TypePool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWP/DWP.cpp:29,Availability,error,error,29,// Could possibly produce an error or warning if one of these was non-null but; // the other was null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/DWP/DWP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWP/DWP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:512,Deployability,update,updated,512,"//===-- ExecutionEngine.cpp - Common Implementation shared by EEs ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the common interface used by the various execution engine; // subclasses.; //; // FIXME: This file needs to be updated to support scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:412,Integrability,interface,interface,412,"//===-- ExecutionEngine.cpp - Common Implementation shared by EEs ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the common interface used by the various execution engine; // subclasses.; //; // FIXME: This file needs to be updated to support scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:531,Performance,scalab,scalable,531,"//===-- ExecutionEngine.cpp - Common Implementation shared by EEs ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the common interface used by the various execution engine; // subclasses.; //; // FIXME: This file needs to be updated to support scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:96,Deployability,release,release,96,"// IR module verification is enabled by default in debug builds, and disabled; // by default in release builds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:6,Energy Efficiency,allocate,allocated,6,"// We allocated with operator new and with some extra memory hanging off the; // end, so don't just delete this. I'm not sure if this is actually; // required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:10,Safety,safe,safe,10,// Endian safe: Array[i] = (PointerTy)Dest;,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:186,Testability,assert,assert,186,// FIXME: It is marginally lame that we just do nothing here if we see an; // entry we don't recognize. It might not be unreasonable for the verifier; // to not even allow this and just assert here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:96,Deployability,release,release,96,"// IR module verification is enabled by default in debug builds, and disabled; // by default in release builds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:137,Performance,load,load,137,"// Take ownership.; // Make sure we can resolve symbols in the program as well. The zero arg; // to the function tells DynamicLibrary to load the program, not a library.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:10,Modifiability,variab,variable,10,// Global variable might have been added since interpreter started.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:24,Usability,simpl,simple,24,"// Otherwise, we have a simple constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:9,Safety,safe,safe,9,// It is safe to treat TargetExtType as its layout type since the underlying; // bits are only copied and are not inspected.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:18,Integrability,depend,dependent,18,"// This is endian dependent, but it will only work on x86 anyway.; // FIXME: Will not trap if loading a signaling NaN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:94,Performance,load,loading,94,"// This is endian dependent, but it will only work on x86 anyway.; // FIXME: Will not trap if loading a signaling NaN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:41,Modifiability,variab,variables,41,"/// EmitGlobals - Emit all of the global variables to memory, storing their; /// addresses into GlobalAddress. This must make sure to copy the contents of; /// their initializers into the memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:31,Modifiability,variab,variables,31,"// Loop over all of the global variables in the program, allocating the memory; // to hold them. If there is more than one module, do a prepass over globals; // to figure out how the different modules should link together.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:12,Modifiability,variab,variable,12,// External variable reference. Try to use the dynamic loader to; // get a pointer to it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:55,Performance,load,loader,55,// External variable reference. Try to use the dynamic loader to; // get a pointer to it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:21,Modifiability,variab,variable,21,// Not the canonical variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:124,Energy Efficiency,allocate,allocates,124,"// EmitGlobalVariable - This method emits the specified global variable to the; // address specified in GlobalAddresses, or allocates new memory if it's not; // already in the map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:63,Modifiability,variab,variable,63,"// EmitGlobalVariable - This method emits the specified global variable to the; // address specified in GlobalAddresses, or allocates new memory if it's not; // already in the map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:34,Energy Efficiency,allocate,allocate,34,"// If it's not already specified, allocate memory for the global.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:19,Energy Efficiency,allocate,allocate,19,"// If we failed to allocate memory for this global, return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngineBindings.cpp:3,Integrability,Wrap,Wrapping,3,// Wrapping the C bindings types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngineBindings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngineBindings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngineBindings.cpp:278,Availability,avail,available,278,"// Defend against the user having an old version of the API by ensuring that; // any fields they didn't see are cleared. We must defend against fields being; // set to the bitwise equivalent of zero, and assume that this means ""do the; // default"" as if that option hadn't been available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngineBindings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngineBindings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngineBindings.cpp:112,Usability,clear,cleared,112,"// Defend against the user having an old version of the API by ensuring that; // any fields they didn't see are cleared. We must defend against fields being; // set to the bitwise equivalent of zero, and assume that this means ""do the; // default"" as if that option hadn't been available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngineBindings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngineBindings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp:168,Integrability,interface,interface,168,"// FIXME: lli aims to provide both, RuntimeDyld and JITLink, as the dynamic; // loaders for it's JIT implementations. And they both offer debugging via the; // GDB JIT interface, which builds on the two well-known symbol names below.; // As these symbols must be unique accross the linked executable, we can only; // define them in one of the libraries and make the other depend on it.; // OrcTargetProcess is a minimal stub for embedding a JIT client in remote; // executors. For the moment it seems reasonable to have the definition there; // and let ExecutionEngine depend on it, until we find a better solution.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp:372,Integrability,depend,depend,372,"// FIXME: lli aims to provide both, RuntimeDyld and JITLink, as the dynamic; // loaders for it's JIT implementations. And they both offer debugging via the; // GDB JIT interface, which builds on the two well-known symbol names below.; // As these symbols must be unique accross the linked executable, we can only; // define them in one of the libraries and make the other depend on it.; // OrcTargetProcess is a minimal stub for embedding a JIT client in remote; // executors. For the moment it seems reasonable to have the definition there; // and let ExecutionEngine depend on it, until we find a better solution.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp:569,Integrability,depend,depend,569,"// FIXME: lli aims to provide both, RuntimeDyld and JITLink, as the dynamic; // loaders for it's JIT implementations. And they both offer debugging via the; // GDB JIT interface, which builds on the two well-known symbol names below.; // As these symbols must be unique accross the linked executable, we can only; // define them in one of the libraries and make the other depend on it.; // OrcTargetProcess is a minimal stub for embedding a JIT client in remote; // executors. For the moment it seems reasonable to have the definition there; // and let ExecutionEngine depend on it, until we find a better solution.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp:80,Performance,load,loaders,80,"// FIXME: lli aims to provide both, RuntimeDyld and JITLink, as the dynamic; // loaders for it's JIT implementations. And they both offer debugging via the; // GDB JIT interface, which builds on the two well-known symbol names below.; // As these symbols must be unique accross the linked executable, we can only; // define them in one of the libraries and make the other depend on it.; // OrcTargetProcess is a minimal stub for embedding a JIT client in remote; // executors. For the moment it seems reasonable to have the definition there; // and let ExecutionEngine depend on it, until we find a better solution.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp:420,Testability,stub,stub,420,"// FIXME: lli aims to provide both, RuntimeDyld and JITLink, as the dynamic; // loaders for it's JIT implementations. And they both offer debugging via the; // GDB JIT interface, which builds on the two well-known symbol names below.; // As these symbols must be unique accross the linked executable, we can only; // define them in one of the libraries and make the other depend on it.; // OrcTargetProcess is a minimal stub for embedding a JIT client in remote; // executors. For the moment it seems reasonable to have the definition there; // and let ExecutionEngine depend on it, until we find a better solution.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp:46,Integrability,interface,interface,46,/// Global access point for the JIT debugging interface designed for use with a; /// singleton toolbox. Handles thread-safe registration and deregistration of; /// object files that are in executable memory managed by the client of this; /// class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp:119,Safety,safe,safe,119,/// Global access point for the JIT debugging interface designed for use with a; /// singleton toolbox. Handles thread-safe registration and deregistration of; /// object files that are in executable memory managed by the client of this; /// class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp:11,Security,access,access,11,/// Global access point for the JIT debugging interface designed for use with a; /// singleton toolbox. Handles thread-safe registration and deregistration of; /// object files that are in executable memory managed by the client of this; /// class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp:86,Modifiability,variab,variables,86,"/// Lock used to serialize all jit registration events, since they; /// modify global variables.; ///; /// Only a single instance of GDBJITRegistrationListener is ever created,; /// and so the lock can be a member variable of that instance. This ensures; /// destructors are run in the correct order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp:214,Modifiability,variab,variable,214,"/// Lock used to serialize all jit registration events, since they; /// modify global variables.; ///; /// Only a single instance of GDBJITRegistrationListener is ever created,; /// and so the lock can be a member variable of that instance. This ensures; /// destructors are run in the correct order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp:80,Integrability,interface,interface,80,/// A map of in-memory object files that have been registered with the; /// JIT interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp:63,Deployability,release,releases,63,/// Unregisters each object that was previously registered and releases all; /// internal resources.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp:40,Deployability,update,update,40,// Call the private method that doesn't update the map so our iterator; // doesn't break.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:79,Availability,avail,available,79,// Look in the list of free memory regions and use a block there if one; // is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:163,Deployability,update,updated,163,// No pre-allocated free block was large enough. Allocate a new memory region.; // Note that all sections get allocated as read-write. The permissions will; // be updated later based on memory group.; //; // FIXME: It would be useful to define a default allocation size (or add; // it as a constructor parameter) to minimize the number of allocations.; //; // FIXME: Initialize the Near member for each memory group to avoid; // interleaving.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:10,Energy Efficiency,allocate,allocated,10,// No pre-allocated free block was large enough. Allocate a new memory region.; // Note that all sections get allocated as read-write. The permissions will; // be updated later based on memory group.; //; // FIXME: It would be useful to define a default allocation size (or add; // it as a constructor parameter) to minimize the number of allocations.; //; // FIXME: Initialize the Near member for each memory group to avoid; // interleaving.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:49,Energy Efficiency,Allocate,Allocate,49,// No pre-allocated free block was large enough. Allocate a new memory region.; // Note that all sections get allocated as read-write. The permissions will; // be updated later based on memory group.; //; // FIXME: It would be useful to define a default allocation size (or add; // it as a constructor parameter) to minimize the number of allocations.; //; // FIXME: Initialize the Near member for each memory group to avoid; // interleaving.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:110,Energy Efficiency,allocate,allocated,110,// No pre-allocated free block was large enough. Allocate a new memory region.; // Note that all sections get allocated as read-write. The permissions will; // be updated later based on memory group.; //; // FIXME: It would be useful to define a default allocation size (or add; // it as a constructor parameter) to minimize the number of allocations.; //; // FIXME: Initialize the Near member for each memory group to avoid; // interleaving.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:419,Safety,avoid,avoid,419,// No pre-allocated free block was large enough. Allocate a new memory region.; // Note that all sections get allocated as read-write. The permissions will; // be updated later based on memory group.; //; // FIXME: It would be useful to define a default allocation size (or add; // it as a constructor parameter) to minimize the number of allocations.; //; // FIXME: Initialize the Near member for each memory group to avoid; // interleaving.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:14,Availability,error,error,14,// FIXME: Add error propagation to the interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:39,Integrability,interface,interface,39,// FIXME: Add error propagation to the interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:20,Energy Efficiency,allocate,allocated,20,// Remember that we allocated this memory,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:7,Energy Efficiency,allocate,allocateMappedMemory,7,"// The allocateMappedMemory may allocate much more memory than we need. In; // this case, we store the unused memory as a free memory block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:32,Energy Efficiency,allocate,allocate,32,"// The allocateMappedMemory may allocate much more memory than we need. In; // this case, we store the unused memory as a free memory block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:59,Availability,error,error,59,// FIXME: Should in-progress permissions be reverted if an error occurs?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:100,Performance,cache,cache,100,"// Read-write data memory already has the correct permissions; // Some platforms with separate data cache and instruction cache require; // explicit cache flush, otherwise JIT code manipulations (like resolved; // relocations) will get to the data cache but not to the instruction cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:122,Performance,cache,cache,122,"// Read-write data memory already has the correct permissions; // Some platforms with separate data cache and instruction cache require; // explicit cache flush, otherwise JIT code manipulations (like resolved; // relocations) will get to the data cache but not to the instruction cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:149,Performance,cache,cache,149,"// Read-write data memory already has the correct permissions; // Some platforms with separate data cache and instruction cache require; // explicit cache flush, otherwise JIT code manipulations (like resolved; // relocations) will get to the data cache but not to the instruction cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:248,Performance,cache,cache,248,"// Read-write data memory already has the correct permissions; // Some platforms with separate data cache and instruction cache require; // explicit cache flush, otherwise JIT code manipulations (like resolved; // relocations) will get to the data cache but not to the instruction cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:281,Performance,cache,cache,281,"// Read-write data memory already has the correct permissions; // Some platforms with separate data cache and instruction cache require; // explicit cache flush, otherwise JIT code manipulations (like resolved; // relocations) will get to the data cache but not to the instruction cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:6,Usability,clear,cleared,6,"// We cleared the PendingMem list, so all these pointers are now invalid",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/TargetSelect.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a target...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/TargetSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/TargetSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp:59,Safety,avoid,avoid,59,"// Hereinafter: don't change SectionNamesVector content to avoid vector; // reallocation - reallocation invalidates all the references, pointers, and; // iterators referring to the elements in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp:25,Availability,error,errors,25,// TODO: Actually report errors helpfully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp:25,Availability,error,errors,25,// TODO: Actually report errors helpfully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp:25,Availability,error,errors,25,// TODO: Actually report errors helpfully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp:25,Availability,error,errors,25,// TODO: Actually report errors helpfully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp:42,Integrability,message,message,42,// Build the function loaded notification message,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp:22,Performance,load,loaded,22,// Build the function loaded notification message,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp:111,Performance,load,loaded,111,"// To support object unload notification, we need to keep a list of; // registered function addresses for each loaded object. We will; // use the MethodIDs map to get the registered ID for each function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp:39,Performance,Load,LoadedObjectMap,39,// Get the object's function list from LoadedObjectMap,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp:25,Performance,Load,LoadedObjectMap,25,// Erase the object from LoadedObjectMap,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp:7,Testability,test,testing,7,// for testing,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventsWrapper.h:640,Availability,avail,available,640,"//===-- IntelJITEventsWrapper.h - Intel JIT Events API Wrapper --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a wrapper for the Intel JIT Events API. It allows for the; // implementation of the jitprofiling library to be swapped with an alternative; // implementation (for testing). To include this file, you must have the; // jitprofiling.h header available; it is available in Intel(R) VTune(TM); // Amplifier XE 2011.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventsWrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventsWrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventsWrapper.h:657,Availability,avail,available,657,"//===-- IntelJITEventsWrapper.h - Intel JIT Events API Wrapper --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a wrapper for the Intel JIT Events API. It allows for the; // implementation of the jitprofiling library to be swapped with an alternative; // implementation (for testing). To include this file, you must have the; // jitprofiling.h header available; it is available in Intel(R) VTune(TM); // Amplifier XE 2011.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventsWrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventsWrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventsWrapper.h:55,Integrability,Wrap,Wrapper,55,"//===-- IntelJITEventsWrapper.h - Intel JIT Events API Wrapper --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a wrapper for the Intel JIT Events API. It allows for the; // implementation of the jitprofiling library to be swapped with an alternative; // implementation (for testing). To include this file, you must have the; // jitprofiling.h header available; it is available in Intel(R) VTune(TM); // Amplifier XE 2011.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventsWrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventsWrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventsWrapper.h:403,Integrability,wrap,wrapper,403,"//===-- IntelJITEventsWrapper.h - Intel JIT Events API Wrapper --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a wrapper for the Intel JIT Events API. It allows for the; // implementation of the jitprofiling library to be swapped with an alternative; // implementation (for testing). To include this file, you must have the; // jitprofiling.h header available; it is available in Intel(R) VTune(TM); // Amplifier XE 2011.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventsWrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventsWrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventsWrapper.h:564,Testability,test,testing,564,"//===-- IntelJITEventsWrapper.h - Intel JIT Events API Wrapper --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a wrapper for the Intel JIT Events API. It allows for the; // implementation of the jitprofiling library to be swapped with an alternative; // implementation (for testing). To include this file, you must have the; // jitprofiling.h header available; it is available in Intel(R) VTune(TM); // Amplifier XE 2011.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventsWrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventsWrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventsWrapper.h:30,Testability,test,testing,30,// Function pointer types for testing implementation of Intel jitprofiling; // library,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventsWrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventsWrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h:56,Modifiability,config,config,56,"/*===-- ittnotify_config.h - JIT Profiling API internal config-----*- C -*-===*; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===----------------------------------------------------------------------===*; *; * This file provides Intel(R) Performance Analyzer JIT (Just-In-Time); * Profiling API internal config.; *; * NOTE: This file comes in a style different from the rest of LLVM; * source base since this is a piece of code shared from Intel(R); * products. Please do not reformat / re-style this code to make; * subsequent merges and contributions from the original source base eaiser.; *; *===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h:467,Modifiability,config,config,467,"/*===-- ittnotify_config.h - JIT Profiling API internal config-----*- C -*-===*; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===----------------------------------------------------------------------===*; *; * This file provides Intel(R) Performance Analyzer JIT (Just-In-Time); * Profiling API internal config.; *; * NOTE: This file comes in a style different from the rest of LLVM; * source base since this is a piece of code shared from Intel(R); * products. Please do not reformat / re-style this code to make; * subsequent merges and contributions from the original source base eaiser.; *; *===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h:401,Performance,Perform,Performance,401,"/*===-- ittnotify_config.h - JIT Profiling API internal config-----*- C -*-===*; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===----------------------------------------------------------------------===*; *; * This file provides Intel(R) Performance Analyzer JIT (Just-In-Time); * Profiling API internal config.; *; * NOTE: This file comes in a style different from the rest of LLVM; * source base since this is a piece of code shared from Intel(R); * products. Please do not reformat / re-style this code to make; * subsequent merges and contributions from the original source base eaiser.; *; *===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h:88,Performance,optimiz,optimization,88,"/* ITT_PLATFORM==ITT_PLATFORM_WIN */; /*; * Generally, functions are not inlined unless optimization is specified.; * For functions declared inline, this attribute inlines the function even; * if no optimization level was specified.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h:199,Performance,optimiz,optimization,199,"/* ITT_PLATFORM==ITT_PLATFORM_WIN */; /*; * Generally, functions are not inlined unless optimization is specified.; * For functions declared inline, this attribute inlines the function even; * if no optimization level was specified.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h:19,Usability,pause,paused,19,/*!< Thread state (paused or normal) */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:401,Performance,Perform,Performance,401,"/*===-- jitprofiling.c - JIT (Just-In-Time) Profiling API----------*- C -*-===*; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===----------------------------------------------------------------------===*; *; * This file provides Intel(R) Performance Analyzer JIT (Just-In-Time) ; * Profiling API implementation. ; *; * NOTE: This file comes in a style different from the rest of LLVM; * source base since this is a piece of code shared from Intel(R); * products. Please do not reformat / re-style this code to make; * subsequent merges and contributions from the original source base eaiser.; *; *===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:266,Availability,failure,failure,266,"/* end collector dll part. */; /* loadiJIT_Funcs() : this function is called just in the beginning ; * and is responsible to load the functions from BistroJavaCollector.dll; * result:; * on success: the functions loads, iJIT_DLL_is_missing=0, return value = 1; * on failure: the functions are NULL, iJIT_DLL_is_missing=1, return value = 0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:125,Performance,load,load,125,"/* end collector dll part. */; /* loadiJIT_Funcs() : this function is called just in the beginning ; * and is responsible to load the functions from BistroJavaCollector.dll; * result:; * on success: the functions loads, iJIT_DLL_is_missing=0, return value = 1; * on failure: the functions are NULL, iJIT_DLL_is_missing=1, return value = 0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:213,Performance,load,loads,213,"/* end collector dll part. */; /* loadiJIT_Funcs() : this function is called just in the beginning ; * and is responsible to load the functions from BistroJavaCollector.dll; * result:; * on success: the functions loads, iJIT_DLL_is_missing=0, return value = 1; * on failure: the functions are NULL, iJIT_DLL_is_missing=1, return value = 0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:64,Performance,load,loaded,64,/* global representing whether the BistroJavaCollector can't be loaded */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:372,Availability,failure,failure,372,"/* end of virtual stack. */; /*; * The function for reporting virtual-machine related events to VTune.; * Note: when reporting iJVM_EVENT_TYPE_ENTER_NIDS, there is no need to fill ; * in the stack_id field in the iJIT_Method_NIDS structure, as VTune fills it.; * The return value in iJVM_EVENT_TYPE_ENTER_NIDS && ; * iJVM_EVENT_TYPE_LEAVE_NIDS events will be 0 in case of failure.; * in iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED event ; * it will be -1 if EventSpecificData == 0 otherwise it will be 0.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:85,Modifiability,variab,variables,85,"/*; * This section is for debugging outside of VTune. ; * It creates the environment variables that indicates call graph mode.; * If running outside of VTune remove the remark.; *; *; * static int firstTime = 1;; * char DoCallGraph[12] = ""DoCallGraph"";; * if (firstTime); * {; * firstTime = 0;; * SetEnvironmentVariable( ""BISTRO_COLLECTORS_DO_CALLGRAPH"", DoCallGraph);; * }; *; * end of section.; */; /* initialization part - the functions have not been loaded yet. This part; * will load the functions, and check if we are in Call Graph mode. ; * (for special treatment).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:454,Performance,load,loaded,454,"/*; * This section is for debugging outside of VTune. ; * It creates the environment variables that indicates call graph mode.; * If running outside of VTune remove the remark.; *; *; * static int firstTime = 1;; * char DoCallGraph[12] = ""DoCallGraph"";; * if (firstTime); * {; * firstTime = 0;; * SetEnvironmentVariable( ""BISTRO_COLLECTORS_DO_CALLGRAPH"", DoCallGraph);; * }; *; * end of section.; */; /* initialization part - the functions have not been loaded yet. This part; * will load the functions, and check if we are in Call Graph mode. ; * (for special treatment).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:484,Performance,load,load,484,"/*; * This section is for debugging outside of VTune. ; * It creates the environment variables that indicates call graph mode.; * If running outside of VTune remove the remark.; *; *; * static int firstTime = 1;; * char DoCallGraph[12] = ""DoCallGraph"";; * if (firstTime); * {; * firstTime = 0;; * SetEnvironmentVariable( ""BISTRO_COLLECTORS_DO_CALLGRAPH"", DoCallGraph);; * }; *; * end of section.; */; /* initialization part - the functions have not been loaded yet. This part; * will load the functions, and check if we are in Call Graph mode. ; * (for special treatment).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:3,Performance,load,load,3,/* load the Function from the DLL */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:67,Deployability,update,updates,67,"/* This section is performed when method enter event occurs.; * It updates the virtual stack, or creates it if this is the first ; * method entry in the thread. The stack pointer is decreased.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:19,Performance,perform,performed,19,"/* This section is performed when method enter event occurs.; * It updates the virtual stack, or creates it if this is the first ; * method entry in the thread. The stack pointer is decreased.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:66,Deployability,update,updates,66,/* This section is performed when method leave event occurs; * It updates the virtual stack.; * Increases the stack pointer.; * If the stack pointer reached the top (left the global function); * increase the pointer and the top pointer.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:19,Performance,perform,performed,19,/* This section is performed when method leave event occurs; * It updates the virtual stack.; * Increases the stack pointer.; * If the stack pointer reached the top (left the global function); * increase the pointer and the top pointer.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:3,Availability,Error,Error,3,/* Error: first report in this thread is method exit */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:26,Integrability,rout,routine,26,/* The new mode call back routine */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:35,Performance,load,load,35,/* is it already missing... or the load of functions from the DLL failed */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:3,Availability,Error,Error,3,/* Error: could not load JIT functions. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:20,Performance,load,load,20,/* Error: could not load JIT functions. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:178,Availability,failure,failure,178,"/* this function loads the collector dll (BistroJavaCollector) ; * and the relevant functions.; * on success: all functions load, iJIT_DLL_is_missing = 0, return value = 1; * on failure: all functions are NULL, iJIT_DLL_is_missing = 1, return value = 0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:17,Performance,load,loads,17,"/* this function loads the collector dll (BistroJavaCollector) ; * and the relevant functions.; * on success: all functions load, iJIT_DLL_is_missing = 0, return value = 1; * on failure: all functions are NULL, iJIT_DLL_is_missing = 1, return value = 0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:124,Performance,load,load,124,"/* this function loads the collector dll (BistroJavaCollector) ; * and the relevant functions.; * on success: all functions load, iJIT_DLL_is_missing = 0, return value = 1; * on failure: all functions are NULL, iJIT_DLL_is_missing = 1, return value = 0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:14,Safety,avoid,avoid,14,/* !! Just to avoid unused code elimination */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:19,Performance,load,loaded,19,"/* dll was already loaded, no need to do it for the second time */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:10,Performance,load,load,10,/* Try to load the dll from the PATH... */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:30,Modifiability,variab,variable,30,/* Try to use old VS_PROFILER variable */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:10,Performance,load,load,10,/* Try to load the dll from the PATH... */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:10,Performance,load,load,10,/* Try to load the dll from the PATH... */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:21,Performance,load,loaded,21,/* if the dll wasn't loaded - exit. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:3,Energy Efficiency,Allocate,Allocate,3,"/* Allocate a thread local storage slot for the thread ""stack"" */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:3,Availability,ERROR,ERROR,3,/* ERROR : this is not a valid value */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.h:401,Performance,Perform,Performance,401,"/*===-- jitprofiling.h - JIT Profiling API-------------------------*- C -*-===*; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===----------------------------------------------------------------------===*; *; * This file provides Intel(R) Performance Analyzer JIT (Just-In-Time); * Profiling API declaration.; *; * NOTE: This file comes in a style different from the rest of LLVM; * source base since this is a piece of code shared from Intel(R); * products. Please do not reformat / re-style this code to make; * subsequent merges and contributions from the original source base eaiser.; *; *===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.h:26,Integrability,rout,routine,26,/* The new mode call back routine */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp:40,Availability,mask,mask,40,// if vector input detect NaNs and fill mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp:19,Safety,detect,detect,19,// if vector input detect NaNs and fill mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp:18,Availability,mask,mask,18,// in vector case mask out NaN elements,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp:95,Modifiability,variab,variable,95,"/// Pop the last stack frame off of ECStack and then copy the result; /// back into the result variable if we are not returning void. The; /// result variable may be the ExitValue, or the Value of the calling; /// CallInst if there was a previous stack frame. This method may; /// invalidate any ECStack iterators you have. This method also takes; /// care of switching to the normal destination BB, if we are returning; /// from an invoke.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp:150,Modifiability,variab,variable,150,"/// Pop the last stack frame off of ECStack and then copy the result; /// back into the result variable if we are not returning void. The; /// result variable may be the ExitValue, or the Value of the calling; /// CallInst if there was a previous stack frame. This method may; /// invalidate any ECStack iterators you have. This method also takes; /// care of switching to the normal destination BB, if we are returning; /// from an invoke.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp:376,Deployability,update,updated,376,"// SwitchToNewBasicBlock - This method is used to jump to a new basic block.; // This function handles the actual updating of block and instruction iterators; // as well as execution of all of the PHI nodes in the destination block.; //; // This method does this because all of the PHI nodes must be executed; // atomically, reading their inputs before any of the results are updated. Not; // doing this can cause problems if the PHI nodes depend on other PHI nodes for; // their inputs. If the input PHI node is updated before it is read, incorrect; // results can happen. Thus we use a two phase approach.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp:513,Deployability,update,updated,513,"// SwitchToNewBasicBlock - This method is used to jump to a new basic block.; // This function handles the actual updating of block and instruction iterators; // as well as execution of all of the PHI nodes in the destination block.; //; // This method does this because all of the PHI nodes must be executed; // atomically, reading their inputs before any of the results are updated. Not; // doing this can cause problems if the PHI nodes depend on other PHI nodes for; // their inputs. If the input PHI node is updated before it is read, incorrect; // results can happen. Thus we use a two phase approach.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp:440,Integrability,depend,depend,440,"// SwitchToNewBasicBlock - This method is used to jump to a new basic block.; // This function handles the actual updating of block and instruction iterators; // as well as execution of all of the PHI nodes in the destination block.; //; // This method does this because all of the PHI nodes must be executed; // atomically, reading their inputs before any of the results are updated. Not; // doing this can cause problems if the PHI nodes depend on other PHI nodes for; // their inputs. If the input PHI node is updated before it is read, incorrect; // results can happen. Thus we use a two phase approach.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp:3,Deployability,Update,Update,3,// Update CurBB to branch destination,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp:3,Deployability,Update,Update,3,// Update new instruction ptr...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp:14,Energy Efficiency,allocate,allocated,14,// Type to be allocated; // Get the number of elements being allocated by the array...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp:61,Energy Efficiency,allocate,allocated,61,// Type to be allocated; // Get the number of elements being allocated by the array...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp:3,Safety,Avoid,Avoid,3,"// Avoid malloc-ing zero bytes, use max()...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate enough memory to hold the type...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp:866,Availability,avail,available,866,"//===-- ExternalFunctions.cpp - Implement External Functions --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains both code to deal with invoking ""external"" functions, but; // also contains code that implements ""exported"" external functions.; //; // There are currently two mechanisms for handling external functions in the; // Interpreter. The first is to implement lle_* wrapper functions that are; // specific to well-known library functions which manually translate the; // arguments from GenericValues and make the call. If such a wrapper does; // not exist, and libffi is available, then the Interpreter will attempt to; // invoke the function using libffi, after finding its address.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp:661,Integrability,wrap,wrapper,661,"//===-- ExternalFunctions.cpp - Implement External Functions --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains both code to deal with invoking ""external"" functions, but; // also contains code that implements ""exported"" external functions.; //; // There are currently two mechanisms for handling external functions in the; // Interpreter. The first is to implement lle_* wrapper functions that are; // specific to well-known library functions which manually translate the; // arguments from GenericValues and make the call. If such a wrapper does; // not exist, and libffi is available, then the Interpreter will attempt to; // invoke the function using libffi, after finding its address.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp:824,Integrability,wrap,wrapper,824,"//===-- ExternalFunctions.cpp - Implement External Functions --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains both code to deal with invoking ""external"" functions, but; // also contains code that implements ""exported"" external functions.; //; // There are currently two mechanisms for handling external functions in the; // Interpreter. The first is to implement lle_* wrapper functions that are; // specific to well-known library functions which manually translate the; // arguments from GenericValues and make the call. If such a wrapper does; // not exist, and libffi is available, then the Interpreter will attempt to; // invoke the function using libffi, after finding its address.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp:3,Safety,Detect,Detect,3,// Detect libffi,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp:3,Performance,Cache,Cache,3,// Cache for later,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp:48,Performance,cache,cache,48,// Do a lookup to see if the function is in our cache... this should just be a; // deferred annotation!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp:3,Performance,Cache,Cache,3,// Cache for later,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp:8,Safety,abort,abort,8,// void abort(void),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Interpreter.cpp:512,Modifiability,portab,portable,512,"//===- Interpreter.cpp - Top-Level LLVM Interpreter Implementation --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the top-level functionality for the LLVM interpreter.; // This interpreter is designed to be a very simple, portable, inefficient; // interpreter.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Interpreter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Interpreter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Interpreter.cpp:504,Usability,simpl,simple,504,"//===- Interpreter.cpp - Top-Level LLVM Interpreter Implementation --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the top-level functionality for the LLVM interpreter.; // This interpreter is designed to be a very simple, portable, inefficient; // interpreter.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Interpreter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Interpreter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Interpreter.cpp:50,Deployability,release,release,50,// Tell this Module to materialize everything and release the GVMaterializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Interpreter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Interpreter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Interpreter.cpp:13,Availability,error,error,13,"// We got an error, just return 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Interpreter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Interpreter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Interpreter.h:62,Energy Efficiency,allocate,allocated,62,"// AllocaHolder - Object to track all of the blocks of memory allocated by; // alloca. When the function returns, this object is popped off the execution; // stack, which causes the dtor to be run, which frees all the alloca'd memory.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Interpreter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Interpreter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Interpreter.h:16,Energy Efficiency,allocate,allocated,16,// Track memory allocated by alloca,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Interpreter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Interpreter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp:54,Testability,stub,stub,54,/// Create a new node in the link-graph for the given stub template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp:10,Testability,stub,stubs,10,// Create stubs for external branch targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp:42,Testability,stub,stubs,42,"// For local targets, create interworking stubs if we switch Arm/Thumb with an; // instruction that cannot switch the instruction set state natively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp:38,Testability,stub,stub,38,// Branch to Thumb needs interworking stub,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp:36,Testability,stub,stub,36,// Branch to Arm needs interworking stub,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp:23,Testability,stub,stub,23,// The ArmThumbv5LdrPc stub has 2 entrypoints: Thumb at offset 0 is taken only; // for Thumb B instructions. Thumb BL is rewritten to BLX and takes the Arm; // entrypoint at offset 4. Arm branches always use that one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp:23,Testability,stub,stub,23,// The ArmThumbv5LdrPc stub has 2 entrypoints: Thumb at offset 0 is taken only; // for Thumb B instructions. Thumb BL is rewritten to BLX and takes the Arm; // entrypoint at offset 4. Arm branches always use that one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp:85,Energy Efficiency,reduce,reduce,85,// Stub Arm/Thumb follows instruction set state at relocation site.; // TODO: We may reduce them at relaxation time and reuse freed slots.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp:3,Testability,Stub,Stub,3,// Stub Arm/Thumb follows instruction set state at relocation site.; // TODO: We may reduce them at relaxation time and reuse freed slots.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/COFFLinkGraphBuilder.cpp:307,Testability,log,logarithmic,307,"// In COFF, most of the defined symbols don't contain the size information.; // Hence, we calculate the ""implicit"" size of symbol by taking the delta of; // offsets of consecutive symbols within a block. We maintain a balanced tree; // set of symbols sorted by offset per each block in order to achieve; // logarithmic time complexity of sorted symbol insertion. Symbol is inserted to; // the set once it's processed in graphifySymbols. In this function, we iterate; // each collected symbol in sorted order and calculate the implicit size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/COFFLinkGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/COFFLinkGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/COFFLinkGraphBuilder.cpp:33,Security,validat,validation,33,// FIXME: Implement size/content validation when LinkGraph is able to; // handle this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/COFFLinkGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/COFFLinkGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/COFFLinkGraphBuilder.h:143,Availability,Error,Error,143,"/// Traverse all matching relocation records in the given section. The handler; /// function Func should be callable with this signature:; /// Error(const object::RelocationRef&,; /// const object::SectionRef&, Section &); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/COFFLinkGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/COFFLinkGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/COFFLinkGraphBuilder.h:84,Integrability,wrap,wrapper,84,/// Traverse all matching relocation records in the given section. Convenience; /// wrapper to allow passing a member function for the handler.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/COFFLinkGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/COFFLinkGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/DefineExternalSectionStartAndEndSymbols.h:976,Deployability,pipeline,pipeline,976,"/// Returns a JITLink pass (as a function class) that uses the given symbol; /// identification function to identify external section start and end symbols; /// (and their associated Section*s) and transform the identified externals; /// into defined symbols pointing to the start of the first block in the; /// section and the end of the last (start and end symbols for empty sections; /// will be transformed into absolute symbols at address 0).; ///; /// The identification function should be callable as; ///; /// SectionRangeSymbolDesc (LinkGraph &G, Symbol &Sym); ///; /// If Sym is not a section range start or end symbol then a default; /// constructed SectionRangeSymbolDesc should be returned. If Sym is a start; /// symbol then SectionRangeSymbolDesc(Sec, true), where Sec is a reference to; /// the target Section. If Sym is an end symbol then; /// SectionRangeSymbolDesc(Sec, false) should be returned.; ///; /// This pass should be run in the PostAllocationPass pipeline, at which point; /// all blocks should have been assigned their final addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/DefineExternalSectionStartAndEndSymbols.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/DefineExternalSectionStartAndEndSymbols.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/DWARFRecordSectionSplitter.cpp:23,Performance,cache,caches,23,// Pre-build the split caches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/DWARFRecordSectionSplitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/DWARFRecordSectionSplitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/DWARFRecordSectionSplitter.cpp:53,Performance,Cache,Caches,53,"// Iterate over blocks (we do this by iterating over Caches entries rather; // than Section->blocks() as we will be inserting new blocks along the way,; // which would invalidate iterators in the latter sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/DWARFRecordSectionSplitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/DWARFRecordSectionSplitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/EHFrameSupport.cpp:84,Modifiability,extend,extended,84,"// If Length < 0xffffffff then use the regular length field, otherwise; // read the extended length field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/EHFrameSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/EHFrameSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/EHFrameSupport.cpp:12,Security,validat,validate,12,// Read and validate the code alignment factor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/EHFrameSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/EHFrameSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/EHFrameSupport.cpp:12,Security,validat,validate,12,// Read and validate the data alignment factor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/EHFrameSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/EHFrameSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/EHFrameSupport.cpp:14,Availability,alive,alive,14,// Add a keep-alive edge from the FDE target to the FDE to ensure that the; // FDE is kept alive if its target is.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/EHFrameSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/EHFrameSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/EHFrameSupport.cpp:91,Availability,alive,alive,91,// Add a keep-alive edge from the FDE target to the FDE to ensure that the; // FDE is kept alive if its target is.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/EHFrameSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/EHFrameSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h:154,Availability,Error,Error,154,"/// Traverse all matching ELFT::Rela relocation records in the given section.; /// The handler function Func should be callable with this signature:; /// Error(const typename ELFT::Rela &,; /// const typename ELFT::Shdr &, Section &); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h:153,Availability,Error,Error,153,"/// Traverse all matching ELFT::Rel relocation records in the given section.; /// The handler function Func should be callable with this signature:; /// Error(const typename ELFT::Rel &,; /// const typename ELFT::Shdr &, Section &); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h:89,Integrability,wrap,wrapper,89,/// Traverse all matching rela relocation records in the given section.; /// Convenience wrapper to allow passing a member function for the handler.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h:88,Integrability,wrap,wrapper,88,/// Traverse all matching rel relocation records in the given section.; /// Convenience wrapper to allow passing a member function for the handler.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h:3,Modifiability,Extend,Extended,3,// Extended table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h:22,Safety,avoid,avoid,22,// Add live symbol to avoid dead-stripping for .ARM.exidx sections,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h:10,Modifiability,extend,extended,10,// Handle extended tables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_aarch32.cpp:24,Deployability,configurat,configuration,24,"// Resolve our internal configuration for the target. If at some point the; // CPUArch alone becomes too unprecise, we can find more details in the; // Tag_CPU_arch_profile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_aarch32.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_aarch32.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_aarch32.cpp:24,Modifiability,config,configuration,24,"// Resolve our internal configuration for the target. If at some point the; // CPUArch alone becomes too unprecise, we can find more details in the; // Tag_CPU_arch_profile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_aarch32.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_aarch32.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_aarch64.cpp:27,Testability,Stub,Stubs,27,// Add an in-place GOT/TLS/Stubs build pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_aarch64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_aarch64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_i386.cpp:3,Security,Validat,Validate,3,// Validate the section to read relocation entries from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_i386.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_i386.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_i386.cpp:17,Performance,optimiz,optimizer,17,// Add GOT/Stubs optimizer pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_i386.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_i386.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_i386.cpp:11,Testability,Stub,Stubs,11,// Add GOT/Stubs optimizer pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_i386.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_i386.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_ppc64.cpp:3,Security,Validat,Validate,3,// Validate the section to read relocation entries from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_ppc64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_ppc64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_ppc64.cpp:23,Performance,optimiz,optimization,23,"// TODO: Support PCREL optimization, now ignore it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_ppc64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_ppc64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_ppc64.cpp:274,Testability,stub,stub,274,"// Determining a target is external or not is deferred in PostPrunePass.; // We assume branching to local entry by default, since in PostPrunePass,; // we don't have any context to determine LocalEntryOffset. If it finally; // turns out to be an external call, we'll have a stub for the external; // target, the target of this edge will be the stub and its addend will be; // set 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_ppc64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_ppc64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_ppc64.cpp:344,Testability,stub,stub,344,"// Determining a target is external or not is deferred in PostPrunePass.; // We assume branching to local entry by default, since in PostPrunePass,; // we don't have any context to determine LocalEntryOffset. If it finally; // turns out to be an external call, we'll have a stub for the external; // target, the target of this edge will be the stub and its addend will be; // set 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_ppc64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_ppc64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp:73,Energy Efficiency,efficient,efficiently,73,"// Sort anchors by offset so that we can find the closest relocation; // efficiently. For a zero size symbol, ensure that its start anchor precedes; // its end anchor. For two symbols with anchors at the same offset, their; // order does not matter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp:153,Energy Efficiency,power,power,153,// E points to the start of the padding bytes.; // E + Addend points to the instruction to be aligned by removing padding.; // Alignment is the smallest power of 2 strictly greater than Addend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp:173,Deployability,update,update,173,"// For all anchors whose offsets are <= E->getOffset(), they are preceded by; // the previous relocation whose RelocDeltas value equals Delta.; // Decrease their offset and update their size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp:3,Deployability,Update,Update,3,// Update section content: remove NOPs for R_RISCV_ALIGN and rewrite; // instructions for relaxed relocations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp:61,Modifiability,rewrite,rewrite,61,// Update section content: remove NOPs for R_RISCV_ALIGN and rewrite; // instructions for relaxed relocations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp:276,Modifiability,rewrite,rewrite,276,"// For R_RISCV_ALIGN, we will place Offset in a location (among NOPs) to; // satisfy the alignment requirement. If both Remove and E->getAddend(); // are multiples of 4, it is as if we have skipped some NOPs. Otherwise we; // are in the middle of a 4-byte NOP, and we need to rewrite the NOP; // sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_x86_64.cpp:3,Security,Validat,Validate,3,// Validate the section to read relocation entries from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_x86_64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_x86_64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_x86_64.cpp:3,Security,Validat,Validate,3,// Validate the relocation kind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_x86_64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_x86_64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_x86_64.cpp:23,Testability,Stub,Stubs,23,// Add an in-place GOT/Stubs/TLSInfoEntry build pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_x86_64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_x86_64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_x86_64.cpp:17,Performance,optimiz,optimizer,17,// Add GOT/Stubs optimizer pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_x86_64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_x86_64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_x86_64.cpp:11,Testability,Stub,Stubs,11,// Add GOT/Stubs optimizer pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_x86_64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_x86_64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp:69,Availability,Error,Error,69,"// FIXME: This class is only here to support the transition to llvm::Error. It; // will be removed once this transition is complete. Clients should prefer to; // deal with the Error value directly, rather than converting to error_code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp:176,Availability,Error,Error,176,"// FIXME: This class is only here to support the transition to llvm::Error. It; // will be removed once this transition is complete. Clients should prefer to; // deal with the Error value directly, rather than converting to error_code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp:24,Deployability,update,update,24,// Handle edge transfer/update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp:97,Deployability,update,update,97,"// Copy edges to NewBlock (recording their iterators so that we can remove; // them from B), and update of Edges remaining on B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp:26,Deployability,update,update,26,// Handle symbol transfer/update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp:26,Performance,cache,cache,26,// Initialize the symbols cache if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp:43,Deployability,update,update,43,"// If the symbol extends beyond the split, update the size to be within; // the new block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp:17,Modifiability,extend,extends,17,"// If the symbol extends beyond the split, update the size to be within; // the new block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp:3,Deployability,Update,Update,3,// Update offsets for all remaining symbols in B.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.cpp:13,Performance,optimiz,optimize,13,// Prune and optimize the graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.cpp:89,Usability,simpl,simplified,89,"// FIXME: Once MSVC implements c++17 order of evaluation rules for calls; // this can be simplified to; // S->linkPhase2(std::move(S), std::move(AR));",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.cpp:89,Usability,simpl,simplified,89,// FIXME: Once MSVC implements c++17 order of evaluation rules for calls; // this can be simplified. See below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.cpp:244,Usability,simpl,simplified,244,"// We're about to hand off ownership of ourself to the continuation. Grab a; // pointer to the context so that we can call it to initiate the lookup.; //; // FIXME: Once MSVC implements c++17 order of evaluation rules for calls this; // can be simplified to:; //; // Ctx->lookup(std::move(UnresolvedExternals),; // [Self=std::move(Self)](Expected<AsyncLookupResult> Result) {; // Self->linkPhase3(std::move(Self), std::move(Result));; // });",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.cpp:89,Usability,simpl,simplified,89,"// FIXME: Once MSVC implements c++17 order of evaluation rules for calls; // this can be simplified to; // S->linkPhase2(std::move(S), std::move(AR));",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.h:308,Performance,perform,performed,308,"/// Base class for a JIT linker.; ///; /// A JITLinkerBase instance links one object file into an ongoing JIT; /// session. Symbol resolution and finalization operations are pluggable,; /// and called using continuation passing (passing a continuation for the; /// remaining linker work) to allow them to be performed asynchronously.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.h:103,Energy Efficiency,Allocate,Allocate,103,// Phase 1:; // 1.1: Run pre-prune passes; // 1.2: Prune graph; // 1.3: Run post-prune passes; // 1.4: Allocate memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.h:93,Availability,error,error,93,"// Run all passes in the given pass list, bailing out immediately if any pass; // returns an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.h:77,Energy Efficiency,allocate,allocated,77,// If this is a no-alloc section then copy the block content into; // memory allocated on the Graph's allocator (if it hasn't been; // already).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp:3,Deployability,Update,Update,3,// Update block addr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp:40,Deployability,update,update,40,"// Copy content to working memory, then update content to point at working; // memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp:3,Deployability,Update,Update,3,// Update block addr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp:3,Deployability,Release,Release,3,// Release the finalize segments slab.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp:89,Testability,assert,assert,89,// Set 'G' to null to flag that we've been successfully finalized.; // This allows us to assert at destruction time that a call has been made; // to either finalize or abandon.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp:89,Testability,assert,assert,89,// Set 'G' to null to flag that we've been successfully finalized.; // This allows us to assert at destruction time that a call has been made; // to either finalize or abandon.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate one slab for the whole thing (to make sure everything is; // in-range), then partition into standard and finalization blocks.; //; // FIXME: Make two separate allocations in the future to reduce; // fragmentation: finalization segments will usually be a single page, and; // standard segments are likely to be more than one page. Where multiple; // allocations are in-flight at once (likely) the current approach will leave; // a lot of single-page holes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp:200,Energy Efficiency,reduce,reduce,200,"// Allocate one slab for the whole thing (to make sure everything is; // in-range), then partition into standard and finalization blocks.; //; // FIXME: Make two separate allocations in the future to reduce; // fragmentation: finalization segments will usually be a single page, and; // standard segments are likely to be more than one page. Where multiple; // allocations are in-flight at once (likely) the current approach will leave; // a lot of single-page holes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp:4,Deployability,Release,Release,4,/// Release the standard segments slab.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.cpp:45,Testability,test,test,45,// Get prot flags.; // FIXME: Make sure this test is correct (it's probably missing cases; // as-is).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.cpp:22,Performance,perform,performing,22,// Loop over sections performing regular graphification for those that; // don't have custom parsers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h:62,Availability,error,error,62,"/// Try to get the section at the given index. Will return an error if the; /// given index is out of range, or if no section has been added for the given; /// index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h:61,Availability,error,error,61,"/// Try to get the symbol at the given index. Will return an error if the; /// given index is out of range, or if no symbol has been added for the given; /// index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h:96,Availability,error,error,96,"/// Returns the symbol with the highest address not greater than the search; /// address, or an error if no such symbol exists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h:140,Safety,safe,safely,140,"// There should be no symbol at this address, or, if there is,; // it should be a zero-sized symbol from an empty section (which; // we can safely override).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h:114,Deployability,update,updated,114,/// Create and return a graph symbol for the given normalized symbol.; ///; /// NSym's GraphSymbol member will be updated to point at the newly created; /// symbol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_arm64.cpp:51,Integrability,depend,depending,51,"// Find 'ToSymbol' using symbol number or address, depending on whether the; // paired UNSIGNED relocation is extern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_arm64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_arm64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_arm64.cpp:3,Security,Validat,Validate,3,// Validate the relocation kind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_arm64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_arm64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_arm64.cpp:209,Integrability,depend,depending,209,"// We use Delta32/Delta64 to represent SUBTRACTOR relocations.; // parsePairRelocation handles the paired reloc, and returns the; // edge kind to be used (either Delta32/Delta64, or; // NegDelta32/NegDelta64, depending on the direction of the; // subtraction) along with the addend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_arm64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_arm64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_arm64.cpp:79,Availability,avail,available,79,// Add eh-frame passes.; // FIXME: Prune eh-frames for which compact-unwind is available once; // we support compact-unwind registration with libunwind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_arm64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_arm64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_arm64.cpp:23,Testability,Stub,Stubs,23,// Add an in-place GOT/Stubs pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_arm64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_arm64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_x86_64.cpp:51,Integrability,depend,depending,51,"// Find 'ToSymbol' using symbol number or address, depending on whether the; // paired UNSIGNED relocation is extern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_x86_64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_x86_64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_x86_64.cpp:3,Security,Validat,Validate,3,// Validate the relocation kind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_x86_64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_x86_64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_x86_64.cpp:209,Integrability,depend,depending,209,"// We use Delta32/Delta64 to represent SUBTRACTOR relocations.; // parsePairRelocation handles the paired reloc, and returns the; // edge kind to be used (either Delta32/Delta64, or; // NegDelta32/NegDelta64, depending on the direction of the; // subtraction) along with the addend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_x86_64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_x86_64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_x86_64.cpp:23,Testability,Stub,Stubs,23,// Add an in-place GOT/Stubs pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_x86_64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_x86_64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_x86_64.cpp:17,Performance,optimiz,optimizer,17,// Add GOT/Stubs optimizer pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_x86_64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_x86_64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_x86_64.cpp:11,Testability,Stub,Stubs,11,// Add GOT/Stubs optimizer pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_x86_64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_x86_64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/PerGraphGOTAndPLTStubsBuilder.h:27,Testability,Stub,Stub,27,"/// Per-object GOT and PLT Stub builder.; ///; /// Constructs GOT entries and PLT stubs in every graph for referenced symbols.; /// Building these blocks in every graph is likely to lead to duplicate entries; /// in the JITLinkDylib, but allows graphs to be trivially removed independently; /// without affecting other graphs (since those other graphs will have their own; /// copies of any required entries).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/PerGraphGOTAndPLTStubsBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/PerGraphGOTAndPLTStubsBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/PerGraphGOTAndPLTStubsBuilder.h:82,Testability,stub,stubs,82,"/// Per-object GOT and PLT Stub builder.; ///; /// Constructs GOT entries and PLT stubs in every graph for referenced symbols.; /// Building these blocks in every graph is likely to lead to duplicate entries; /// in the JITLinkDylib, but allows graphs to be trivially removed independently; /// without affecting other graphs (since those other graphs will have their own; /// copies of any required entries).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/PerGraphGOTAndPLTStubsBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/PerGraphGOTAndPLTStubsBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ppc64.cpp:430,Energy Efficiency,Power,PowerPC,430,"//===----- ppc64.cpp - Generic JITLink ppc64 edge kinds, utilities ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Generic utilities for graphs representing 64-bit PowerPC objects.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ppc64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ppc64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/SEHFrameSupport.h:24,Availability,alive,alive,24,/// This pass adds keep-alive edge from SEH frame sections; /// to the parent function content block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/SEHFrameSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/SEHFrameSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/SEHFrameSupport.h:106,Availability,alive,alive,106,"// Simply consider every block pointed by seh frame block as parants.; // This adds some unnecessary keep-alive edges to unwind info blocks,; // (xdata) but these blocks are usually dead by default, so they wouldn't; // count for the fate of seh frame block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/SEHFrameSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/SEHFrameSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/SEHFrameSupport.h:3,Usability,Simpl,Simply,3,"// Simply consider every block pointed by seh frame block as parants.; // This adds some unnecessary keep-alive edges to unwind info blocks,; // (xdata) but these blocks are usually dead by default, so they wouldn't; // count for the fate of seh frame block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/SEHFrameSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/SEHFrameSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/x86_64.cpp:80,Performance,optimiz,optimization,80,"// If both of the Target and displacement is out of range, then; // there isn't optimization chance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/x86_64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/x86_64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:119,Safety,avoid,avoid,119,"// FIXME: We are managing our modules, so we do not want the base class; // ExecutionEngine to manage them as well. To avoid double destruction; // of the first (and only) module added in ExecutionEngine constructor; // we remove it from EE and will destruct it ourselves.; //; // It may make sense to move our module manager (based on SmallStPtr) back; // into EE if the JIT and Interpreter can live with it.; // If so, additional functions: addModule, removeModule, FindFunctionNamed,; // runStaticConstructorsDestructors could be moved back to EE as well.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:62,Performance,load,loaded,62,"// This must be a module which has already been added but not loaded to this; // MCJIT instance, since these conditions are tested by our caller,; // generateCodeForModule.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:124,Testability,test,tested,124,"// This must be a module which has already been added but not loaded to this; // MCJIT instance, since these conditions are tested by our caller,; // generateCodeForModule.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:24,Performance,cache,cache,24,"// If we have an object cache, tell it about the new object.; // Note that we're using the compiled image, not the loaded image (as below).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:115,Performance,load,loaded,115,"// If we have an object cache, tell it about the new object.; // Note that we're using the compiled image, not the loaded image (as below).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:26,Integrability,wrap,wrapper,26,"// MemoryBuffer is a thin wrapper around the actual memory, so it's OK; // to create a temporary object here and delete it after the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:54,Performance,load,load,54,// Get a thread lock to make sure we aren't trying to load multiple times,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:10,Performance,load,load,10,// Try to load the pre-compiled object from cache if possible,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:44,Performance,cache,cache,44,// Try to load the pre-compiled object from cache if possible,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:10,Performance,cache,cache,10,"// If the cache did not contain a suitable object, compile the object",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:3,Performance,Load,Load,3,// Load the object into the dynamic linker.; // MCJIT now owns the ObjectImage pointer (via its LoadedObjects list).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:96,Performance,Load,LoadedObjects,96,// Load the object into the dynamic linker.; // MCJIT now owns the ObjectImage pointer (via its LoadedObjects list).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:18,Availability,error,error,18,// Check for Dyld error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:63,Performance,load,loaded,63,// Register EH frame data for any module we own which has been loaded,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:25,Availability,error,errors,25,// TODO: Actually report errors helpfully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:37,Performance,load,loaded,37,// This causes the object file to be loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:31,Deployability,install,installed,31,"// If a LazyFunctionCreator is installed, use it to get/create the function.; // FIXME: Should we instead have a LazySymbolCreator callback?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:55,Performance,load,loaded,55,// Make sure the relevant module has been compiled and loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:226,Testability,assert,assertion,226,"// If this function doesn't belong to one of our modules, we're done.; // FIXME: Asking for the pointer to a function that hasn't been registered,; // and isn't a declaration (which is handled above) should probably; // be an assertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:156,Performance,load,load,156,"// FIXME: Should the Dyld be retaining module information? Probably not.; //; // This is the accessor for the target address, so make sure to check the; // load address of the symbol, not the local address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:93,Security,access,accessor,93,"// FIXME: Should the Dyld be retaining module information? Probably not.; //; // This is the accessor for the target address, so make sure to check the; // load address of the symbol, not the local address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:32,Deployability,install,installed,32,"/// If a LazyFunctionCreator is installed, use it to get/create the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:25,Testability,log,logical,25,// MCJIT doesn't support logical dylibs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:31,Performance,load,loaded,31,"// About Module states: added->loaded->finalized.; //; // The purpose of the ""added"" state is having modules in standby. (added=known; // but not compiled). The idea is that you can add a module to provide function; // definitions but if nothing in that module is referenced by a module in which; // a function is executed (note the wording here because it's not exactly the; // ideal case) then the module never gets compiled. This is sort of lazy; // compilation.; //; // The purpose of the ""loaded"" state (loaded=compiled and required sections; // copied into local memory but not yet ready for execution) is to have an; // intermediate state wherein clients can remap the addresses of sections, using; // MCJIT::mapSectionAddress, (in preparation for later copying to a new location; // or an external process) before relocations and page permissions are applied.; //; // It might not be obvious at first glance, but the ""remote-mcjit"" case in the; // lli tool does this. In that case, the intermediate action is taken by the; // RemoteMemoryManager in response to the notifyObjectLoaded function being; // called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:494,Performance,load,loaded,494,"// About Module states: added->loaded->finalized.; //; // The purpose of the ""added"" state is having modules in standby. (added=known; // but not compiled). The idea is that you can add a module to provide function; // definitions but if nothing in that module is referenced by a module in which; // a function is executed (note the wording here because it's not exactly the; // ideal case) then the module never gets compiled. This is sort of lazy; // compilation.; //; // The purpose of the ""loaded"" state (loaded=compiled and required sections; // copied into local memory but not yet ready for execution) is to have an; // intermediate state wherein clients can remap the addresses of sections, using; // MCJIT::mapSectionAddress, (in preparation for later copying to a new location; // or an external process) before relocations and page permissions are applied.; //; // It might not be obvious at first glance, but the ""remote-mcjit"" case in the; // lli tool does this. In that case, the intermediate action is taken by the; // RemoteMemoryManager in response to the notifyObjectLoaded function being; // called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:509,Performance,load,loaded,509,"// About Module states: added->loaded->finalized.; //; // The purpose of the ""added"" state is having modules in standby. (added=known; // but not compiled). The idea is that you can add a module to provide function; // definitions but if nothing in that module is referenced by a module in which; // a function is executed (note the wording here because it's not exactly the; // ideal case) then the module never gets compiled. This is sort of lazy; // compilation.; //; // The purpose of the ""loaded"" state (loaded=compiled and required sections; // copied into local memory but not yet ready for execution) is to have an; // intermediate state wherein clients can remap the addresses of sections, using; // MCJIT::mapSectionAddress, (in preparation for later copying to a new location; // or an external process) before relocations and page permissions are applied.; //; // It might not be obvious at first glance, but the ""remote-mcjit"" case in the; // lli tool does this. In that case, the intermediate action is taken by the; // RemoteMemoryManager in response to the notifyObjectLoaded function being; // called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:35,Performance,load,loaded,35,"// If the module is in either the ""loaded"" or ""finalized"" sections it; // has been loaded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:83,Performance,load,loaded,83,"// If the module is in either the ""loaded"" or ""finalized"" sections it; // has been loaded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:29,Availability,error,errors,29,// This checks against logic errors in the MCJIT implementation.; // This function should never be called with either a Module that MCJIT; // does not own or a Module that has already been loaded and/or finalized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:189,Performance,load,loaded,189,// This checks against logic errors in the MCJIT implementation.; // This function should never be called with either a Module that MCJIT; // does not own or a Module that has already been loaded and/or finalized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:23,Testability,log,logic,23,// This checks against logic errors in the MCJIT implementation.; // This function should never be called with either a Module that MCJIT; // does not own or a Module that has already been loaded and/or finalized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:26,Performance,Load,Loaded,26,"// Add the Module to the ""Loaded"" set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:29,Availability,error,errors,29,"// This checks against logic errors in the MCJIT implementation.; // This function should never be called with either a Module that MCJIT; // does not own, a Module that has not been loaded or a Module that has; // already been finalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:183,Performance,load,loaded,183,"// This checks against logic errors in the MCJIT implementation.; // This function should never be called with either a Module that MCJIT; // does not own, a Module that has not been loaded or a Module that has; // already been finalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:23,Testability,log,logic,23,"// This checks against logic errors in the MCJIT implementation.; // This function should never be called with either a Module that MCJIT; // does not own, a Module that has not been loaded or a Module that has; // already been finalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:31,Performance,Load,Loaded,31,"// Remove the module from the ""Loaded"" section of the list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:78,Performance,perform,perform,78,// An optional ObjectCache to be notified of compiled objects and used to; // perform lookup of pre-compiled code to avoid re-compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:117,Safety,avoid,avoid,117,// An optional ObjectCache to be notified of compiled objects and used to; // perform lookup of pre-compiled code to avoid re-compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:26,Integrability,interface,interface,26,/// @name ExecutionEngine interface implementation; /// @{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:87,Modifiability,variab,variable,87,/// FindGlobalVariableNamed - Search all of the active modules to find the; /// global variable that defines Name. This is very slow operation and; /// shouldn't be used for general code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:53,Safety,avoid,avoid,53,/// Sets the object manager that MCJIT should use to avoid compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:380,Performance,load,loaded,380,"/// finalizeObject - ensure the module is fully processed and is usable.; ///; /// It is the user-level function for completing the process of making the; /// object usable for execution. It should be called after sections within an; /// object have been relocated using mapSectionAddress. When this method is; /// called the MCJIT execution engine will reapply relocations for a loaded; /// object.; /// Is it OK to finalize a set of modules, add modules and finalize again.; // FIXME: Do we really need both of these?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:65,Usability,usab,usable,65,"/// finalizeObject - ensure the module is fully processed and is usable.; ///; /// It is the user-level function for completing the process of making the; /// object usable for execution. It should be called after sections within an; /// object have been relocated using mapSectionAddress. When this method is; /// called the MCJIT execution engine will reapply relocations for a loaded; /// object.; /// Is it OK to finalize a set of modules, add modules and finalize again.; // FIXME: Do we really need both of these?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:166,Usability,usab,usable,166,"/// finalizeObject - ensure the module is fully processed and is usable.; ///; /// It is the user-level function for completing the process of making the; /// object usable for execution. It should be called after sections within an; /// object have been relocated using mapSectionAddress. When this method is; /// called the MCJIT execution engine will reapply relocations for a loaded; /// object.; /// Is it OK to finalize a set of modules, add modules and finalize again.; // FIXME: Do we really need both of these?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:382,Integrability,message,message,382,"/// getPointerToNamedFunction - This method returns the address of the; /// specified function by using the dlsym function call. As such it is only; /// useful for resolving library symbols, not code generated symbols.; ///; /// If AbortOnFailure is false and no function with the given name is; /// found, this function silently returns a null pointer. Otherwise,; /// it prints a message to stderr and aborts.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:232,Safety,Abort,AbortOnFailure,232,"/// getPointerToNamedFunction - This method returns the address of the; /// specified function by using the dlsym function call. As such it is only; /// useful for resolving library symbols, not code generated symbols.; ///; /// If AbortOnFailure is false and no function with the given name is; /// found, this function silently returns a null pointer. Otherwise,; /// it prints a message to stderr and aborts.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:404,Safety,abort,aborts,404,"/// getPointerToNamedFunction - This method returns the address of the; /// specified function by using the dlsym function call. As such it is only; /// useful for resolving library symbols, not code generated symbols.; ///; /// If AbortOnFailure is false and no function with the given name is; /// found, this function silently returns a null pointer. Otherwise,; /// it prints a message to stderr and aborts.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:62,Performance,load,loaded,62,"// If successful, these function will implicitly finalize all loaded objects.; // To get a function address within MCJIT without causing a finalize, use; // getSymbolAddress.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:41,Integrability,Interface,Interfaces,41,/// @}; /// @name (Private) Registration Interfaces; /// @{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:76,Security,expose,exposed,76,"// DEPRECATED - Please use findSymbol instead.; //; // This is not directly exposed via the ExecutionEngine API, but it is; // used by the LinkingMemoryManager.; //; // getSymbolAddress takes an unmangled name and returns the corresponding; // JITSymbol if a definition of the name has been added to the JIT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/OProfileJIT/OProfileJITEventListener.cpp:65,Performance,load,loaded,65,"// If there was no agent registered when the original object was loaded then; // we won't have created a debug object for it, so bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/OProfileJIT/OProfileJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/OProfileJIT/OProfileJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp:47,Integrability,Wrap,Wrapper,47,"//===-- OProfileWrapper.cpp - OProfile JIT API Wrapper implementation -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the interface in OProfileWrapper.h. It is responsible; // for loading the opagent dynamic library when the first call to an op_; // function occurs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp:408,Integrability,interface,interface,408,"//===-- OProfileWrapper.cpp - OProfile JIT API Wrapper implementation -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the interface in OProfileWrapper.h. It is responsible; // for loading the opagent dynamic library when the first call to an op_; // function occurs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp:466,Performance,load,loading,466,"//===-- OProfileWrapper.cpp - OProfile JIT API Wrapper implementation -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the interface in OProfileWrapper.h. It is responsible; // for loading the opagent dynamic library when the first call to an op_; // function occurs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp:48,Performance,load,load,48,"// If the oprofile daemon is not running, don't load the opagent library",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp:3,Testability,Test,Test,3,// Test this to see if it is the oprofile daemon,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/COFFPlatform.cpp:3,Performance,Load,Load,3,// Load vc runtime,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/COFFPlatform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/COFFPlatform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/COFFPlatform.cpp:13,Integrability,wrap,wrapper,13,// Associate wrapper function tags with JIT-side function implementations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/COFFPlatform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/COFFPlatform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp:52,Modifiability,variab,variable,52,// We need to turn deleted aliases into function or variable decls based; // on the type of their aliasee.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp:249,Modifiability,variab,variable,249,"// Expands the partition to ensure the following rules hold:; // (1) If any alias is in the partition, its aliasee is also in the partition.; // (2) If any aliasee is in the partition, its aliases are also in the; // partiton.; // (3) If any global variable is in the partition then all global variables; // are in the partition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp:294,Modifiability,variab,variables,294,"// Expands the partition to ensure the following rules hold:; // (1) If any alias is in the partition, its aliasee is also in the partition.; // (2) If any aliasee is in the partition, its aliases are also in the; // partiton.; // (3) If any global variable is in the partition then all global variables; // are in the partition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp:4,Performance,Perform,Perform,4,"/// Perform partitioning with the context lock held, since the partition; /// function is allowed to access the globals to compute the partition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp:101,Security,access,access,101,"/// Perform partitioning with the context lock held, since the partition; /// function is allowed to access the globals to compute the partition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp:310,Safety,safe,safe,310,"// Ok -- we actually need to partition the symbols. Promote the symbol; // linkages/names, expand the partition to include any required symbols; // (i.e. symbols that can't be separated from our partition), and; // then extract the partition.; //; // FIXME: We apply this promotion once per partitioning. It's safe, but; // overkill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp:30,Security,hash,hashing,30,// Submodule name is given by hashing the names of the globals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:57,Availability,error,errors,57,// FIXME: Use a new dep-map type for FailedToMaterialize errors so that we; // don't have to manually retain/release.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:109,Deployability,release,release,109,// FIXME: Use a new dep-map type for FailedToMaterialize errors so that we; // don't have to manually retain/release.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:85,Deployability,update,update,85,"// If this is a materialization-side-effects-only symbol then drop it,; // otherwise update its map entry with its resolved address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:68,Availability,failure,failure,68,// Even though these are just absolute symbols we need to check for failure; // to resolve/emit: the tracker for these symbols may have been removed while; // the materialization was in flight (e.g. due to a failure in some action; // triggered by the queries attached to the resolution/emission of these; // symbols).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:208,Availability,failure,failure,208,// Even though these are just absolute symbols we need to check for failure; // to resolve/emit: the tracker for these symbols may have been removed while; // the materialization was in flight (e.g. due to a failure in some action; // triggered by the queries attached to the resolution/emission of these; // symbols).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:47,Availability,failure,failure,47,// FIXME: Should this be reported / treated as failure to materialize?; // Or should this be treated as a sanctioned bailing-out?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:9,Safety,detect,detected,9,// Chain detected. Skip this symbol for this round.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:10,Energy Efficiency,Reduce,Reduce,10,// FIXME: Reduce the number of SymbolStringPtrs here. See; // https://github.com/llvm/llvm-project/issues/55576.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:3,Usability,Resume,Resumed,3,// Resumed after being auto-suspended before generator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:119,Availability,error,errors,119,// DefGenerator moved into TmpDG to ensure that it's destroyed outside the; // session lock (since it may have to send errors to pending queries).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:39,Availability,error,error,39,// If this is a strong definition then error out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:28,Availability,error,error,28,// If Name is already in an error state then just bail out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:68,Availability,error,error,68,"// Register dependencies, record whether any depenendency is in the error; // state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:12,Integrability,depend,dependencies,12,"// Register dependencies, record whether any depenendency is in the error; // state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:31,Integrability,depend,dependency,31,// Check the sym entry for the dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:3,Testability,Assert,Assert,3,// Assert that this symbol exists and has not reached the ready state; // already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:73,Integrability,depend,dependency,73,// If the other symbol is already in the Ready state then there's no; // dependency to add.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:30,Availability,error,error,30,"// If the dependency is in an error state then note this and continue,; // we will move this symbol to the error state below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:107,Availability,error,error,107,"// If the dependency is in an error state then note this and continue,; // we will move this symbol to the error state below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:10,Integrability,depend,dependency,10,"// If the dependency is in an error state then note this and continue,; // we will move this symbol to the error state below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:36,Availability,error,error,36,// If the dependency was not in the error state then add it to; // our list of dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:10,Integrability,depend,dependency,10,// If the dependency was not in the error state then add it to; // our list of dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:79,Integrability,depend,dependencies,79,// If the dependency was not in the error state then add it to; // our list of dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:52,Availability,error,error,52,// If this symbol dependended on any symbols in the error state then move; // this symbol to the error state too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:97,Availability,error,error,97,// If this symbol dependended on any symbols in the error state then move; // this symbol to the error state too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:18,Integrability,depend,dependended,18,// If this symbol dependended on any symbols in the error state then move; // this symbol to the error state too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:51,Availability,error,error,51,// Build worklist and check for any symbols in the error state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:30,Availability,error,error,30,// If any symbols were in the error state then bail out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:30,Availability,error,error,30,// If any symbols were in the error state then bail out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:13,Deployability,update,update,13,// Otherwise update dependencies and move to the emitted state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:20,Integrability,depend,dependencies,20,// Otherwise update dependencies and move to the emitted state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:74,Deployability,Update,Update,74,// If this symbol has no MaterializingInfo then it's trivially ready.; // Update its state and continue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:12,Integrability,depend,dependant,12,"// For each dependant, transfer this node's emitted dependencies to; // it. If the dependant node is ready (i.e. has no unemitted; // dependencies) then notify any pending queries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:52,Integrability,depend,dependencies,52,"// For each dependant, transfer this node's emitted dependencies to; // it. If the dependant node is ready (i.e. has no unemitted; // dependencies) then notify any pending queries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:83,Integrability,depend,dependant,83,"// For each dependant, transfer this node's emitted dependencies to; // it. If the dependant node is ready (i.e. has no unemitted; // dependencies) then notify any pending queries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:134,Integrability,depend,dependencies,134,"// For each dependant, transfer this node's emitted dependencies to; // it. If the dependant node is ready (i.e. has no unemitted; // dependencies) then notify any pending queries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:14,Integrability,depend,dependant,14,// Remove the dependant's dependency on this node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:26,Integrability,depend,dependency,26,// Remove the dependant's dependency on this node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:22,Integrability,depend,dependencies,22,// Transfer unemitted dependencies from this node to the; // dependant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:61,Integrability,depend,dependant,61,// Transfer unemitted dependencies from this node to the; // dependant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:10,Integrability,depend,dependant,10,"// If the dependant is emitted and this node was the last of its; // unemitted dependencies then the dependant node is now ready, so; // notify any pending queries on the dependant node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:79,Integrability,depend,dependencies,79,"// If the dependant is emitted and this node was the last of its; // unemitted dependencies then the dependant node is now ready, so; // notify any pending queries on the dependant node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:101,Integrability,depend,dependant,101,"// If the dependant is emitted and this node was the last of its; // unemitted dependencies then the dependant node is now ready, so; // notify any pending queries on the dependant node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:171,Integrability,depend,dependant,171,"// If the dependant is emitted and this node was the last of its; // unemitted dependencies then the dependant node is now ready, so; // notify any pending queries on the dependant node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:77,Deployability,update,update,77,"// Since this dependant is now ready, we erase its; // MaterializingInfo and update its materializing state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:14,Integrability,depend,dependant,14,"// Since this dependant is now ready, we erase its; // MaterializingInfo and update its materializing state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:90,Availability,failure,failure,90,"// It's possible that this symbol has already been removed, e.g. if a; // materialization failure happens concurrently with a ResourceTracker or; // JITDylib removal. In that case we can safely skip this symbol and; // continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:106,Performance,concurren,concurrently,106,"// It's possible that this symbol has already been removed, e.g. if a; // materialization failure happens concurrently with a ResourceTracker or; // JITDylib removal. In that case we can safely skip this symbol and; // continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:187,Safety,safe,safely,187,"// It's possible that this symbol has already been removed, e.g. if a; // materialization failure happens concurrently with a ResourceTracker or; // JITDylib removal. In that case we can safely skip this symbol and; // continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:28,Availability,error,error,28,// Move the symbol into the error state.; // Note that this may be redundant: The symbol might already have been; // moved to this state in response to the failure of a dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:67,Availability,redundant,redundant,67,// Move the symbol into the error state.; // Note that this may be redundant: The symbol might already have been; // moved to this state in response to the failure of a dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:156,Availability,failure,failure,156,// Move the symbol into the error state.; // Note that this may be redundant: The symbol might already have been; // moved to this state in response to the failure of a dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:169,Integrability,depend,dependence,169,// Move the symbol into the error state.; // Note that this may be redundant: The symbol might already have been; // moved to this state in response to the failure of a dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:67,Safety,redund,redundant,67,// Move the symbol into the error state.; // Note that this may be redundant: The symbol might already have been; // moved to this state in response to the failure of a dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:99,Testability,assert,assert,99,"// FIXME: Come up with a sane mapping of state to; // presence-of-MaterializingInfo so that we can assert presence / absence; // here, rather than testing it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:147,Testability,test,testing,147,"// FIXME: Come up with a sane mapping of state to; // presence-of-MaterializingInfo so that we can assert presence / absence; // here, rather than testing it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:30,Availability,error,error,30,// Move all dependants to the error state and disconnect from them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:12,Integrability,depend,dependants,12,// Move all dependants to the error state and disconnect from them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:52,Availability,error,error,52,"// If any of the symbols are not defined, return an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:64,Availability,error,error,64,"// If any of the symbols are currently materializing, return an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:70,Testability,test,tests,70,// Sort symbols so we get a deterministic order and can check them in tests.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:3,Deployability,Update,Update,3,// Update trackers for any not-yet materialized units.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:3,Deployability,Update,Update,3,// Update trackers for any active materialization responsibilities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:19,Integrability,depend,dependencies,19,// Do not add self dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:31,Integrability,depend,dependencies,31,"// If we haven't looked up the dependencies for DependencyJD yet, do it; // now and cache the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:48,Integrability,Depend,DependencyJD,48,"// If we haven't looked up the dependencies for DependencyJD yet, do it; // now and cache the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:84,Performance,cache,cache,84,"// If we haven't looked up the dependencies for DependencyJD yet, do it; // now and cache the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:3,Usability,Clear,Clear,3,// Clear JITDylibs and notify the platform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:27,Usability,Clear,Clear,27,// Set JD to closed state. Clear remaining data structures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:118,Integrability,depend,depends,118,"// lookup can be re-entered recursively if running on a single thread. Run any; // outstanding MUs in case this query depends on them, otherwise this lookup; // will starve waiting for a result from an MU that is stuck in the queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:226,Performance,queue,queue,226,"// lookup can be re-entered recursively if running on a single thread. Run any; // outstanding MUs in case this query depends on them, otherwise this lookup; // will starve waiting for a result from an MU that is stuck in the queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:3,Performance,Perform,Perform,3,// Perform the asynchronous lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:141,Availability,error,error,141,"// If we match against a materialization-side-effects only symbol; // then make sure it is weakly-referenced. Otherwise bail out with; // an error.; // FIXME: Use a ""materialization-side-effects-only symbols must be; // weakly referenced"" specific error here to reduce confusion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:248,Availability,error,error,248,"// If we match against a materialization-side-effects only symbol; // then make sure it is weakly-referenced. Otherwise bail out with; // an error.; // FIXME: Use a ""materialization-side-effects-only symbols must be; // weakly referenced"" specific error here to reduce confusion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:262,Energy Efficiency,reduce,reduce,262,"// If we match against a materialization-side-effects only symbol; // then make sure it is weakly-referenced. Otherwise bail out with; // an error.; // FIXME: Use a ""materialization-side-effects-only symbols must be; // weakly referenced"" specific error here to reduce confusion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:54,Availability,error,error,54,// If we matched against this symbol but it is in the error state; // then bail out and treat it as a failure to materialize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:102,Availability,failure,failure,102,// If we matched against this symbol but it is in the error state; // then bail out and treat it as a failure to materialize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:13,Usability,resume,resume,13,// Otherwise resume the next lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:258,Energy Efficiency,reduce,reduced,258,// FIXME: We should attach the query as we go: This provides a result in a; // single pass in the common case where all symbols have already reached the; // required state. The query could be detached again in the 'fail' method on; // IPLS. Phase 2 would be reduced to collecting and dispatching the MUs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:27,Availability,error,error,27,// If we've been handed an error or received one back from a generator then; // fail the query. We don't need to unlink: At this stage the query hasn't; // actually been lodged.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:45,Performance,perform,perform,45,// If we've just reached a new JITDylib then perform some setup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:3,Deployability,Update,Update,3,// Update the list of candidates (and non-candidates) for definition; // generation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:22,Usability,resume,resumed,22,// If this lookup was resumed after auto-suspension but all candidates; // have already been generated (by some previous call to the generator); // treat the lookup as if it had completed generation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:24,Availability,error,error,24,// If we encountered an error while filtering generation candidates then; // bail out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:81,Usability,Resume,ResumedForGenerator,81,"// At this point the lookup is in either the NotInGenerator state, or in; // the ResumedForGenerator state.; // If this lookup is in the NotInGenerator state then check whether the; // generator is in use. If the generator is not in use then move the; // lookup to the InGenerator state and continue. If the generator is; // already in use then just add this lookup to the pending lookups list; // and bail out.; // If this lookup is in the ResumedForGenerator state then just move it; // to InGenerator and continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:441,Usability,Resume,ResumedForGenerator,441,"// At this point the lookup is in either the NotInGenerator state, or in; // the ResumedForGenerator state.; // If this lookup is in the NotInGenerator state then check whether the; // generator is in use. If the generator is not in use then move the; // lookup to the InGenerator state and continue. If the generator is; // already in use then just add this lookup to the pending lookups list; // and bail out.; // If this lookup is in the ResumedForGenerator state then just move it; // to InGenerator and continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:19,Availability,error,error,19,// If there was an error then fail the query.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:54,Deployability,update,update,54,// Otherwise if we're continuing around the loop then update candidates; // for the next round.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:167,Availability,error,error,167,"// If we get here then we've finished searching all JITDylibs.; // If we matched all symbols then move to phase 2, otherwise fail the query; // with a SymbolsNotFound error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:141,Availability,error,error,141,"// If we match against a materialization-side-effects only symbol; // then make sure it is weakly-referenced. Otherwise bail out with; // an error.; // FIXME: Use a ""materialization-side-effects-only symbols must be; // weakly referenced"" specific error here to reduce confusion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:248,Availability,error,error,248,"// If we match against a materialization-side-effects only symbol; // then make sure it is weakly-referenced. Otherwise bail out with; // an error.; // FIXME: Use a ""materialization-side-effects-only symbols must be; // weakly referenced"" specific error here to reduce confusion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:262,Energy Efficiency,reduce,reduce,262,"// If we match against a materialization-side-effects only symbol; // then make sure it is weakly-referenced. Otherwise bail out with; // an error.; // FIXME: Use a ""materialization-side-effects-only symbols must be; // weakly referenced"" specific error here to reduce confusion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:54,Availability,error,error,54,// If we matched against this symbol but it is in the error state; // then bail out and treat it as a failure to materialize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:102,Availability,failure,failure,102,// If we matched against this symbol but it is in the error state; // then bail out and treat it as a failure to materialize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:10,Availability,failure,failure,10,// Handle failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp:390,Deployability,Update,Update,390,"//===------- DebugObjectManagerPlugin.cpp - JITLink debug objects ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // FIXME: Update Plugin to poke the debug object into a new JITLink section,; // rather than creating a new allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp:397,Modifiability,Plugin,Plugin,397,"//===------- DebugObjectManagerPlugin.cpp - JITLink debug objects ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // FIXME: Update Plugin to poke the debug object into a new JITLink section,; // rather than creating a new allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp:57,Deployability,patch,patching,57,// All recorded sections are candidates for load-address patching.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp:44,Performance,load,load-address,44,// All recorded sections are candidates for load-address patching.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp:31,Performance,load,load-addresses,31,// Request final target memory load-addresses for all sections.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp:139,Deployability,configurat,configuration,139,"/// The plugin creates a debug object from when JITLink starts processing the; /// corresponding LinkGraph. It provides access to the pass configuration of; /// the LinkGraph and calls the finalization function, once the resulting link; /// artifact was emitted.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp:8,Modifiability,plugin,plugin,8,"/// The plugin creates a debug object from when JITLink starts processing the; /// corresponding LinkGraph. It provides access to the pass configuration of; /// the LinkGraph and calls the finalization function, once the resulting link; /// artifact was emitted.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp:139,Modifiability,config,configuration,139,"/// The plugin creates a debug object from when JITLink starts processing the; /// corresponding LinkGraph. It provides access to the pass configuration of; /// the LinkGraph and calls the finalization function, once the resulting link; /// artifact was emitted.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp:120,Security,access,access,120,"/// The plugin creates a debug object from when JITLink starts processing the; /// corresponding LinkGraph. It provides access to the pass configuration of; /// the LinkGraph and calls the finalization function, once the resulting link; /// artifact was emitted.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp:102,Deployability,patch,patches,102,/// The current implementation of ELFDebugObject replicates the approach used in; /// RuntimeDyld: It patches executable and data section headers in the given; /// object buffer with load-addresses of their corresponding sections in target; /// memory.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp:183,Performance,load,load-addresses,183,/// The current implementation of ELFDebugObject replicates the approach used in; /// RuntimeDyld: It patches executable and data section headers in the given; /// object buffer with load-addresses of their corresponding sections in target; /// memory.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate working memory for debug object in read-only segment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp:7,Availability,failure,failure,7,// Any failure here will fail materialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp:29,Deployability,update,updated,29,"// Once our tracking info is updated, notifyEmitted() can return and; // finish materialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp:111,Deployability,update,updated,111,"// Debug objects are stored by ResourceKey only after registration.; // Thus, pending objects don't need to be updated here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ELFNixPlatform.cpp:45,Testability,test,tested,45,"// FIXME: jitlink for ppc64 hasn't been well tested, leave it unsupported; // right now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ELFNixPlatform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ELFNixPlatform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ELFNixPlatform.cpp:13,Integrability,wrap,wrapper,13,// Associate wrapper function tags with JIT-side function implementations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ELFNixPlatform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ELFNixPlatform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ELFNixPlatform.cpp:10,Safety,Avoid,Avoid,10,// FIXME: Avoid copy here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ELFNixPlatform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ELFNixPlatform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ELFNixPlatform.cpp:249,Energy Efficiency,allocate,allocate,249,"// Insert TLV lowering at the start of the PostPrunePasses, since we want; // it to run before GOT/PLT lowering.; // TODO: Check that before the fixTLVSectionsAndEdges pass, the GOT/PLT build; // pass has done. Because the TLS descriptor need to be allocate in GOT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ELFNixPlatform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ELFNixPlatform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericJITLinkMemoryManager.cpp:69,Availability,failure,failures,69,// FIXME: The C++98 initializer is an attempt to work around compile failures; // due to http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1397.; // We should be able to switch this back to member initialization once that; // issue is fixed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericJITLinkMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericJITLinkMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericJITLinkMemoryManager.cpp:10,Deployability,Release,Release,10,// FIXME: Release abandoned alloc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericJITLinkMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericJITLinkMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp:17,Availability,error,errors,17,// FIXME: Report errors through EPC once that functionality is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp:63,Availability,avail,available,63,// FIXME: Report errors through EPC once that functionality is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp:25,Availability,error,error,25,// If there's already an error then bail out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp:40,Availability,error,error,40,// Bail out early if there's already an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp:17,Availability,error,error,17,// If there's an error then bail out here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp:64,Integrability,wrap,wrapper,64,// We'll also need to make an extra allocation for the eh-frame wrapper call; // arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCIndirectionUtils.cpp:32,Availability,avail,available,32,// If there aren't enough stubs available then allocate some more.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCIndirectionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCIndirectionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCIndirectionUtils.cpp:47,Energy Efficiency,allocate,allocate,47,// If there aren't enough stubs available then allocate some more.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCIndirectionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCIndirectionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCIndirectionUtils.cpp:26,Testability,stub,stubs,26,// If there aren't enough stubs available then allocate some more.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCIndirectionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/EPCIndirectionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ExecutionUtils.cpp:67,Security,access,accessed,67,// Create PLT stub; // FIXME: check PLT stub of data symbol is not accessed,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ExecutionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ExecutionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ExecutionUtils.cpp:14,Testability,stub,stub,14,// Create PLT stub; // FIXME: check PLT stub of data symbol is not accessed,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ExecutionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ExecutionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ExecutionUtils.cpp:40,Testability,stub,stub,40,// Create PLT stub; // FIXME: check PLT stub of data symbol is not accessed,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ExecutionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ExecutionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ExecutorProcessControl.cpp:45,Availability,error,erroring,45,// FIXME: Collect all failing symbols before erroring out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ExecutorProcessControl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ExecutorProcessControl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/IndirectionUtils.cpp:6,Integrability,depend,dependencies,6,"// No dependencies, so these calls cannot fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/IndirectionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/IndirectionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/IndirectionUtils.cpp:80,Availability,error,error,80,// If this address is not associated with a compile callback then report an; // error to the execution session and return ErrorHandlerAddress to the; // callee.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/IndirectionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/IndirectionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/IndirectionUtils.cpp:122,Availability,Error,ErrorHandlerAddress,122,// If this address is not associated with a compile callback then report an; // error to the execution session and return ErrorHandlerAddress to the; // callee.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/IndirectionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/IndirectionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/IndirectionUtils.cpp:93,Availability,Error,ErrorHandlerAddress,93,// If anything goes wrong materializing Sym then report it to the session; // and return the ErrorHandlerAddress;,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/IndirectionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/IndirectionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Layer.cpp:44,Integrability,interface,interfaces,44,"//===-------------------- Layer.cpp - Layer interfaces --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Layer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Layer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Layer.cpp:44,Integrability,depend,depending,44,// thread locals generate different symbols depending on whether or not; // emulated TLS is enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Layer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Layer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Layer.cpp:51,Usability,usab,usable,51,// Throw away the SymbolToDefinition map: it's not usable after we hand; // off the module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Layer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Layer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LazyReexports.cpp:100,Availability,failure,failures,100,// Declaring SLS and the callback outside of the call to ES.lookup is a; // workaround to fix build failures on AIX and on z/OS platforms.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LazyReexports.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LazyReexports.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LazyReexports.cpp:17,Integrability,depend,dependencies,17,"// No registered dependencies, so these calls cannot fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LazyReexports.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LazyReexports.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp:35,Integrability,wrap,wrapper,35,"/// Adds helper function decls and wrapper functions that call the helper with; /// some additional prefix arguments.; ///; /// E.g. For wrapper ""foo"" with type i8(i8, i64), helper ""bar"", and prefix; /// args i32 4 and i16 12345, this function will add:; ///; /// declare i8 @bar(i32, i16, i8, i64); ///; /// define i8 @foo(i8, i64) {; /// entry:; /// %2 = call i8 @bar(i32 4, i16 12345, i8 %0, i64 %1); /// ret i8 %2; /// }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp:137,Integrability,wrap,wrapper,137,"/// Adds helper function decls and wrapper functions that call the helper with; /// some additional prefix arguments.; ///; /// E.g. For wrapper ""foo"" with type i8(i8, i64), helper ""bar"", and prefix; /// args i32 4 and i16 12345, this function will add:; ///; /// declare i8 @bar(i32, i16, i8, i64); ///; /// define i8 @foo(i8, i64) {; /// entry:; /// %2 = call i8 @bar(i32 4, i16 12345, i8 %0, i64 %1); /// ret i8 %2; /// }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp:155,Integrability,Inject,Injects,155,"/// Generic IR Platform Support; ///; /// Scrapes llvm.global_ctors and llvm.global_dtors and replaces them with; /// specially named 'init' and 'deinit'. Injects definitions / interposes for; /// some runtime API, including __cxa_atexit, dlopen, and dlclose.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp:155,Security,Inject,Injects,155,"/// Generic IR Platform Support; ///; /// Scrapes llvm.global_ctors and llvm.global_dtors and replaces them with; /// specially named 'init' and 'deinit'. Injects definitions / interposes for; /// some runtime API, including __cxa_atexit, dlopen, and dlclose.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp:97,Integrability,depend,depends,97,/// Issue lookups for all init symbols required to initialize JD (and any; /// JITDylibs that it depends on).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp:172,Integrability,inject,injected,172,/// Inactive Platform Support; ///; /// Explicitly disables platform support. JITDylibs are not scanned for special; /// init/deinit symbols. No runtime API interposes are injected.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp:172,Security,inject,injected,172,/// Inactive Platform Support; ///; /// Explicitly disables platform support. JITDylibs are not scanned for special; /// init/deinit symbols. No runtime API interposes are injected.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp:24,Modifiability,config,configure,24,// If the client didn't configure any linker options then auto-configure the; // JIT linker.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp:63,Modifiability,config,configure,63,// If the client didn't configure any linker options then auto-configure the; // JIT linker.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp:10,Modifiability,config,config,10,// If the config state provided an ObjectLinkingLayer factory then use it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp:83,Availability,error,errors,83,// FIXME: Explicit conversion to std::unique_ptr<ObjectLayer> added to silence; // errors from some GCC / libstdc++ bots. Remove this conversion (i.e.; // just return ObjLinkingLayer) once those bots are upgraded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp:204,Deployability,upgrade,upgraded,204,// FIXME: Explicit conversion to std::unique_ptr<ObjectLayer> added to silence; // errors from some GCC / libstdc++ bots. Remove this conversion (i.e.; // just return ObjLinkingLayer) once those bots are upgraded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp:80,Integrability,depend,depending,80,"// Otherwise default to creating a SimpleCompiler, or ConcurrentIRCompiler,; // depending on the number of threads requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp:54,Performance,Concurren,ConcurrentIRCompiler,54,"// Otherwise default to creating a SimpleCompiler, or ConcurrentIRCompiler,; // depending on the number of threads requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp:35,Usability,Simpl,SimpleCompiler,35,"// Otherwise default to creating a SimpleCompiler, or ConcurrentIRCompiler,; // depending on the number of threads requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp:28,Testability,stub,stubs,28,// Take/Create the indirect stubs manager builder.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp:42,Integrability,wrap,wrappers,42,"// In-process LLJIT uses eh-frame section wrappers via EPC, so we need to force; // them to be linked in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp:1548,Availability,avail,available,1548,"itself (to build the allocation actions that will call the registration; // functions). Further complicating the situation (a) the graph containing; // the registration functions is allowed to depend on other graphs (e.g. the; // graph containing the ORC runtime RTTI support) so we need to handle an; // unknown set of dependencies during bootstrap, and (b) these graphs may; // be linked concurrently if the user has installed a concurrent dispatcher.; //; // We satisfy these constraints by implementing a bootstrap phase during which; // allocation actions generated by MachOPlatform are appended to a list of; // deferred allocation actions, rather than to the graphs themselves. At the; // end of the bootstrap process the deferred actions are attached to a final; // ""complete-bootstrap"" graph that causes them to be run.; //; // The bootstrap steps are as follows:; //; // 1. Request the graph containing the mach header. This graph is guaranteed; // not to have any metadata so the fact that the registration functions; // are not available yet is not a problem.; //; // 2. Look up the registration functions and discard the results. This will; // trigger linking of the graph containing these functions, and; // consequently any graphs that it depends on. We do not use the lookup; // result to find the addresses of the functions requested (as described; // above the lookup will return too late for that), instead we capture the; // addresses in a post-allocation pass injected by the platform runtime; // during bootstrap only.; //; // 3. During bootstrap the MachOPlatformPlugin keeps a count of the number of; // graphs being linked (potentially concurrently), and we block until all; // of these graphs have completed linking. This is to avoid a race on the; // deferred-actions vector: the lookup for the runtime registration; // functions may return while some functions (those that are being; // incidentally linked in, but aren't reachable via the runtime functions); // are still",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp:927,Deployability,install,installed,927,"// Bootstrap process -- here be phase-ordering dragons.; //; // The MachOPlatform class uses allocation actions to register metadata; // sections with the ORC runtime, however the runtime contains metadata; // registration functions that have their own metadata that they need to; // register (e.g. the frame-info registration functions have frame-info).; // We can't use an ordinary lookup to find these registration functions; // because their address is needed during the link of the containing graph; // itself (to build the allocation actions that will call the registration; // functions). Further complicating the situation (a) the graph containing; // the registration functions is allowed to depend on other graphs (e.g. the; // graph containing the ORC runtime RTTI support) so we need to handle an; // unknown set of dependencies during bootstrap, and (b) these graphs may; // be linked concurrently if the user has installed a concurrent dispatcher.; //; // We satisfy these constraints by implementing a bootstrap phase during which; // allocation actions generated by MachOPlatform are appended to a list of; // deferred allocation actions, rather than to the graphs themselves. At the; // end of the bootstrap process the deferred actions are attached to a final; // ""complete-bootstrap"" graph that causes them to be run.; //; // The bootstrap steps are as follows:; //; // 1. Request the graph containing the mach header. This graph is guaranteed; // not to have any metadata so the fact that the registration functions; // are not available yet is not a problem.; //; // 2. Look up the registration functions and discard the results. This will; // trigger linking of the graph containing these functions, and; // consequently any graphs that it depends on. We do not use the lookup; // result to find the addresses of the functions requested (as described; // above the lookup will return too late for that), instead we capture the; // addresses in a post-allocation pass injected by ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp:701,Integrability,depend,depend,701,"// Bootstrap process -- here be phase-ordering dragons.; //; // The MachOPlatform class uses allocation actions to register metadata; // sections with the ORC runtime, however the runtime contains metadata; // registration functions that have their own metadata that they need to; // register (e.g. the frame-info registration functions have frame-info).; // We can't use an ordinary lookup to find these registration functions; // because their address is needed during the link of the containing graph; // itself (to build the allocation actions that will call the registration; // functions). Further complicating the situation (a) the graph containing; // the registration functions is allowed to depend on other graphs (e.g. the; // graph containing the ORC runtime RTTI support) so we need to handle an; // unknown set of dependencies during bootstrap, and (b) these graphs may; // be linked concurrently if the user has installed a concurrent dispatcher.; //; // We satisfy these constraints by implementing a bootstrap phase during which; // allocation actions generated by MachOPlatform are appended to a list of; // deferred allocation actions, rather than to the graphs themselves. At the; // end of the bootstrap process the deferred actions are attached to a final; // ""complete-bootstrap"" graph that causes them to be run.; //; // The bootstrap steps are as follows:; //; // 1. Request the graph containing the mach header. This graph is guaranteed; // not to have any metadata so the fact that the registration functions; // are not available yet is not a problem.; //; // 2. Look up the registration functions and discard the results. This will; // trigger linking of the graph containing these functions, and; // consequently any graphs that it depends on. We do not use the lookup; // result to find the addresses of the functions requested (as described; // above the lookup will return too late for that), instead we capture the; // addresses in a post-allocation pass injected by ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp:828,Integrability,depend,dependencies,828,"// Bootstrap process -- here be phase-ordering dragons.; //; // The MachOPlatform class uses allocation actions to register metadata; // sections with the ORC runtime, however the runtime contains metadata; // registration functions that have their own metadata that they need to; // register (e.g. the frame-info registration functions have frame-info).; // We can't use an ordinary lookup to find these registration functions; // because their address is needed during the link of the containing graph; // itself (to build the allocation actions that will call the registration; // functions). Further complicating the situation (a) the graph containing; // the registration functions is allowed to depend on other graphs (e.g. the; // graph containing the ORC runtime RTTI support) so we need to handle an; // unknown set of dependencies during bootstrap, and (b) these graphs may; // be linked concurrently if the user has installed a concurrent dispatcher.; //; // We satisfy these constraints by implementing a bootstrap phase during which; // allocation actions generated by MachOPlatform are appended to a list of; // deferred allocation actions, rather than to the graphs themselves. At the; // end of the bootstrap process the deferred actions are attached to a final; // ""complete-bootstrap"" graph that causes them to be run.; //; // The bootstrap steps are as follows:; //; // 1. Request the graph containing the mach header. This graph is guaranteed; // not to have any metadata so the fact that the registration functions; // are not available yet is not a problem.; //; // 2. Look up the registration functions and discard the results. This will; // trigger linking of the graph containing these functions, and; // consequently any graphs that it depends on. We do not use the lookup; // result to find the addresses of the functions requested (as described; // above the lookup will return too late for that), instead we capture the; // addresses in a post-allocation pass injected by ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp:1762,Integrability,depend,depends,1762,"other graphs (e.g. the; // graph containing the ORC runtime RTTI support) so we need to handle an; // unknown set of dependencies during bootstrap, and (b) these graphs may; // be linked concurrently if the user has installed a concurrent dispatcher.; //; // We satisfy these constraints by implementing a bootstrap phase during which; // allocation actions generated by MachOPlatform are appended to a list of; // deferred allocation actions, rather than to the graphs themselves. At the; // end of the bootstrap process the deferred actions are attached to a final; // ""complete-bootstrap"" graph that causes them to be run.; //; // The bootstrap steps are as follows:; //; // 1. Request the graph containing the mach header. This graph is guaranteed; // not to have any metadata so the fact that the registration functions; // are not available yet is not a problem.; //; // 2. Look up the registration functions and discard the results. This will; // trigger linking of the graph containing these functions, and; // consequently any graphs that it depends on. We do not use the lookup; // result to find the addresses of the functions requested (as described; // above the lookup will return too late for that), instead we capture the; // addresses in a post-allocation pass injected by the platform runtime; // during bootstrap only.; //; // 3. During bootstrap the MachOPlatformPlugin keeps a count of the number of; // graphs being linked (potentially concurrently), and we block until all; // of these graphs have completed linking. This is to avoid a race on the; // deferred-actions vector: the lookup for the runtime registration; // functions may return while some functions (those that are being; // incidentally linked in, but aren't reachable via the runtime functions); // are still being linked, and we need to capture any allocation actions; // for this incidental code before we proceed.; //; // 4. Once all active links are complete we transfer the deferred actions to; // a newly a",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp:1989,Integrability,inject,injected,1989," if the user has installed a concurrent dispatcher.; //; // We satisfy these constraints by implementing a bootstrap phase during which; // allocation actions generated by MachOPlatform are appended to a list of; // deferred allocation actions, rather than to the graphs themselves. At the; // end of the bootstrap process the deferred actions are attached to a final; // ""complete-bootstrap"" graph that causes them to be run.; //; // The bootstrap steps are as follows:; //; // 1. Request the graph containing the mach header. This graph is guaranteed; // not to have any metadata so the fact that the registration functions; // are not available yet is not a problem.; //; // 2. Look up the registration functions and discard the results. This will; // trigger linking of the graph containing these functions, and; // consequently any graphs that it depends on. We do not use the lookup; // result to find the addresses of the functions requested (as described; // above the lookup will return too late for that), instead we capture the; // addresses in a post-allocation pass injected by the platform runtime; // during bootstrap only.; //; // 3. During bootstrap the MachOPlatformPlugin keeps a count of the number of; // graphs being linked (potentially concurrently), and we block until all; // of these graphs have completed linking. This is to avoid a race on the; // deferred-actions vector: the lookup for the runtime registration; // functions may return while some functions (those that are being; // incidentally linked in, but aren't reachable via the runtime functions); // are still being linked, and we need to capture any allocation actions; // for this incidental code before we proceed.; //; // 4. Once all active links are complete we transfer the deferred actions to; // a newly added CompleteBootstrap graph and then request a symbol from; // the CompleteBootstrap graph to trigger materialization. This will cause; // all deferred actions to be run, and once this lookup return",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp:3051,Modifiability,variab,variables,3051," the bootstrap process the deferred actions are attached to a final; // ""complete-bootstrap"" graph that causes them to be run.; //; // The bootstrap steps are as follows:; //; // 1. Request the graph containing the mach header. This graph is guaranteed; // not to have any metadata so the fact that the registration functions; // are not available yet is not a problem.; //; // 2. Look up the registration functions and discard the results. This will; // trigger linking of the graph containing these functions, and; // consequently any graphs that it depends on. We do not use the lookup; // result to find the addresses of the functions requested (as described; // above the lookup will return too late for that), instead we capture the; // addresses in a post-allocation pass injected by the platform runtime; // during bootstrap only.; //; // 3. During bootstrap the MachOPlatformPlugin keeps a count of the number of; // graphs being linked (potentially concurrently), and we block until all; // of these graphs have completed linking. This is to avoid a race on the; // deferred-actions vector: the lookup for the runtime registration; // functions may return while some functions (those that are being; // incidentally linked in, but aren't reachable via the runtime functions); // are still being linked, and we need to capture any allocation actions; // for this incidental code before we proceed.; //; // 4. Once all active links are complete we transfer the deferred actions to; // a newly added CompleteBootstrap graph and then request a symbol from; // the CompleteBootstrap graph to trigger materialization. This will cause; // all deferred actions to be run, and once this lookup returns we can; // proceed.; //; // 5. Finally, we associate runtime support methods in MachOPlatform with; // the corresponding jit-dispatch tag variables in the ORC runtime to make; // the support methods callable. The bootstrap is now complete.; // Step (1) Add header materialization unit and request.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp:898,Performance,concurren,concurrently,898,"// Bootstrap process -- here be phase-ordering dragons.; //; // The MachOPlatform class uses allocation actions to register metadata; // sections with the ORC runtime, however the runtime contains metadata; // registration functions that have their own metadata that they need to; // register (e.g. the frame-info registration functions have frame-info).; // We can't use an ordinary lookup to find these registration functions; // because their address is needed during the link of the containing graph; // itself (to build the allocation actions that will call the registration; // functions). Further complicating the situation (a) the graph containing; // the registration functions is allowed to depend on other graphs (e.g. the; // graph containing the ORC runtime RTTI support) so we need to handle an; // unknown set of dependencies during bootstrap, and (b) these graphs may; // be linked concurrently if the user has installed a concurrent dispatcher.; //; // We satisfy these constraints by implementing a bootstrap phase during which; // allocation actions generated by MachOPlatform are appended to a list of; // deferred allocation actions, rather than to the graphs themselves. At the; // end of the bootstrap process the deferred actions are attached to a final; // ""complete-bootstrap"" graph that causes them to be run.; //; // The bootstrap steps are as follows:; //; // 1. Request the graph containing the mach header. This graph is guaranteed; // not to have any metadata so the fact that the registration functions; // are not available yet is not a problem.; //; // 2. Look up the registration functions and discard the results. This will; // trigger linking of the graph containing these functions, and; // consequently any graphs that it depends on. We do not use the lookup; // result to find the addresses of the functions requested (as described; // above the lookup will return too late for that), instead we capture the; // addresses in a post-allocation pass injected by ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp:939,Performance,concurren,concurrent,939,"// Bootstrap process -- here be phase-ordering dragons.; //; // The MachOPlatform class uses allocation actions to register metadata; // sections with the ORC runtime, however the runtime contains metadata; // registration functions that have their own metadata that they need to; // register (e.g. the frame-info registration functions have frame-info).; // We can't use an ordinary lookup to find these registration functions; // because their address is needed during the link of the containing graph; // itself (to build the allocation actions that will call the registration; // functions). Further complicating the situation (a) the graph containing; // the registration functions is allowed to depend on other graphs (e.g. the; // graph containing the ORC runtime RTTI support) so we need to handle an; // unknown set of dependencies during bootstrap, and (b) these graphs may; // be linked concurrently if the user has installed a concurrent dispatcher.; //; // We satisfy these constraints by implementing a bootstrap phase during which; // allocation actions generated by MachOPlatform are appended to a list of; // deferred allocation actions, rather than to the graphs themselves. At the; // end of the bootstrap process the deferred actions are attached to a final; // ""complete-bootstrap"" graph that causes them to be run.; //; // The bootstrap steps are as follows:; //; // 1. Request the graph containing the mach header. This graph is guaranteed; // not to have any metadata so the fact that the registration functions; // are not available yet is not a problem.; //; // 2. Look up the registration functions and discard the results. This will; // trigger linking of the graph containing these functions, and; // consequently any graphs that it depends on. We do not use the lookup; // result to find the addresses of the functions requested (as described; // above the lookup will return too late for that), instead we capture the; // addresses in a post-allocation pass injected by ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp:2169,Performance,concurren,concurrently,2169," rather than to the graphs themselves. At the; // end of the bootstrap process the deferred actions are attached to a final; // ""complete-bootstrap"" graph that causes them to be run.; //; // The bootstrap steps are as follows:; //; // 1. Request the graph containing the mach header. This graph is guaranteed; // not to have any metadata so the fact that the registration functions; // are not available yet is not a problem.; //; // 2. Look up the registration functions and discard the results. This will; // trigger linking of the graph containing these functions, and; // consequently any graphs that it depends on. We do not use the lookup; // result to find the addresses of the functions requested (as described; // above the lookup will return too late for that), instead we capture the; // addresses in a post-allocation pass injected by the platform runtime; // during bootstrap only.; //; // 3. During bootstrap the MachOPlatformPlugin keeps a count of the number of; // graphs being linked (potentially concurrently), and we block until all; // of these graphs have completed linking. This is to avoid a race on the; // deferred-actions vector: the lookup for the runtime registration; // functions may return while some functions (those that are being; // incidentally linked in, but aren't reachable via the runtime functions); // are still being linked, and we need to capture any allocation actions; // for this incidental code before we proceed.; //; // 4. Once all active links are complete we transfer the deferred actions to; // a newly added CompleteBootstrap graph and then request a symbol from; // the CompleteBootstrap graph to trigger materialization. This will cause; // all deferred actions to be run, and once this lookup returns we can; // proceed.; //; // 5. Finally, we associate runtime support methods in MachOPlatform with; // the corresponding jit-dispatch tag variables in the ORC runtime to make; // the support methods callable. The bootstrap is now complete.; /",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp:2262,Safety,avoid,avoid,2262," the bootstrap process the deferred actions are attached to a final; // ""complete-bootstrap"" graph that causes them to be run.; //; // The bootstrap steps are as follows:; //; // 1. Request the graph containing the mach header. This graph is guaranteed; // not to have any metadata so the fact that the registration functions; // are not available yet is not a problem.; //; // 2. Look up the registration functions and discard the results. This will; // trigger linking of the graph containing these functions, and; // consequently any graphs that it depends on. We do not use the lookup; // result to find the addresses of the functions requested (as described; // above the lookup will return too late for that), instead we capture the; // addresses in a post-allocation pass injected by the platform runtime; // during bootstrap only.; //; // 3. During bootstrap the MachOPlatformPlugin keeps a count of the number of; // graphs being linked (potentially concurrently), and we block until all; // of these graphs have completed linking. This is to avoid a race on the; // deferred-actions vector: the lookup for the runtime registration; // functions may return while some functions (those that are being; // incidentally linked in, but aren't reachable via the runtime functions); // are still being linked, and we need to capture any allocation actions; // for this incidental code before we proceed.; //; // 4. Once all active links are complete we transfer the deferred actions to; // a newly added CompleteBootstrap graph and then request a symbol from; // the CompleteBootstrap graph to trigger materialization. This will cause; // all deferred actions to be run, and once this lookup returns we can; // proceed.; //; // 5. Finally, we associate runtime support methods in MachOPlatform with; // the corresponding jit-dispatch tag variables in the ORC runtime to make; // the support methods callable. The bootstrap is now complete.; // Step (1) Add header materialization unit and request.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp:1989,Security,inject,injected,1989," if the user has installed a concurrent dispatcher.; //; // We satisfy these constraints by implementing a bootstrap phase during which; // allocation actions generated by MachOPlatform are appended to a list of; // deferred allocation actions, rather than to the graphs themselves. At the; // end of the bootstrap process the deferred actions are attached to a final; // ""complete-bootstrap"" graph that causes them to be run.; //; // The bootstrap steps are as follows:; //; // 1. Request the graph containing the mach header. This graph is guaranteed; // not to have any metadata so the fact that the registration functions; // are not available yet is not a problem.; //; // 2. Look up the registration functions and discard the results. This will; // trigger linking of the graph containing these functions, and; // consequently any graphs that it depends on. We do not use the lookup; // result to find the addresses of the functions requested (as described; // above the lookup will return too late for that), instead we capture the; // addresses in a post-allocation pass injected by the platform runtime; // during bootstrap only.; //; // 3. During bootstrap the MachOPlatformPlugin keeps a count of the number of; // graphs being linked (potentially concurrently), and we block until all; // of these graphs have completed linking. This is to avoid a race on the; // deferred-actions vector: the lookup for the runtime registration; // functions may return while some functions (those that are being; // incidentally linked in, but aren't reachable via the runtime functions); // are still being linked, and we need to capture any allocation actions; // for this incidental code before we proceed.; //; // 4. Once all active links are complete we transfer the deferred actions to; // a newly added CompleteBootstrap graph and then request a symbol from; // the CompleteBootstrap graph to trigger materialization. This will cause; // all deferred actions to be run, and once this lookup return",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp:100,Availability,alive,alive,100,// Notify Bootstrap->CV while holding the mutex because the mutex is; // also keeping Bootstrap->CV alive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp:49,Integrability,depend,dependencies,49,"// Skip ObjCImageInfo -- this shouldn't have any dependencies, and we may; // remove it later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp:80,Performance,optimiz,optimize,80,// Check that the __objc_imageinfo section is unreferenced.; // FIXME: We could optimize this check if Symbols had a ref-count.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp:36,Deployability,update,update,36,// Lock the mutex while we verify / update the ObjCImageInfos map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp:80,Modifiability,plugin,plugins,80,"// The LinkGraph builder should have created single strings blocks, and all; // plugins should have maintained this invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MapperJITLinkMemoryManager.cpp:158,Availability,failure,failure,158,"// TODO: How should we treat memory that we fail to deinitialize?; // We're currently bailing out and treating it as ""burned"" -- should we; // require that a failure to deinitialize still reset the memory so that; // we can reclaim it?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MapperJITLinkMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MapperJITLinkMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MemoryMapper.cpp:10,Deployability,Release,Release,10,// FIXME: Release finalize lifetime segments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MemoryMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MemoryMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MemoryMapper.cpp:38,Security,access,accessing,38,// this prevents other processes from accessing it by name,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MemoryMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MemoryMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp:41,Integrability,interface,interface,41,"//===------ ObjectFileInterface.cpp - MU interface utils for objects ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp:19,Availability,error,error,19,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp:9,Testability,Test,Test,9,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp:19,Availability,error,error,19,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp:9,Testability,Test,Test,9,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp:19,Availability,error,error,19,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp:9,Testability,Test,Test,9,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp:19,Availability,error,error,19,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp:9,Testability,Test,Test,9,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectFileInterface.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:122,Availability,fault,faulty,122,"// Check that InternedResult matches up with MR->getSymbols(), overriding; // flags if requested.; // This guards against faulty transformations / compilers / object caches.; // First check that there aren't any missing symbols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:166,Performance,cache,caches,166,"// Check that InternedResult matches up with MR->getSymbols(), overriding; // flags if requested.; // This guards against faulty transformations / compilers / object caches.; // First check that there aren't any missing symbols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:49,Availability,error,error,49,// If there were missing symbols then report the error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:51,Availability,error,error,51,// If there were extra definitions then report the error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:107,Integrability,depend,dependence,107,"// Add passes to mark duplicate defs as should-discard, and to walk the; // link graph to build the symbol dependence graph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:15,Integrability,depend,dependencies,15,// Symbol name dependencies:; // Internal: Defined in this graph.; // External: Defined externally.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:13,Performance,cache,cache,13,// Check the cache first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:26,Performance,cache,cache,26,// No value. Populate the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:13,Performance,cache,cache,13,// Check the cache first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:11,Integrability,depend,dependencies,11,// Compute dependencies for symbols defined in the JITLink graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:39,Integrability,depend,dependencies,39,// Skip local symbols: we do not track dependencies for these.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:7,Energy Efficiency,allocate,allocate,7,// Pre-allocate map entries. This prevents any iterator/reference; // invalidation in the next loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:40,Integrability,depend,dependencies,40,"// Build initial worklist, record block dependencies/dependants and; // non-local symbol dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:53,Integrability,depend,dependants,53,"// Build initial worklist, record block dependencies/dependants and; // non-local symbol dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:89,Integrability,depend,dependencies,89,"// Build initial worklist, record block dependencies/dependants and; // non-local symbol dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:25,Integrability,depend,dependants,25,// If this node has both dependants and dependencies then add it to the; // worklist to propagate the dependencies to the dependants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:40,Integrability,depend,dependencies,40,// If this node has both dependants and dependencies then add it to the; // worklist to propagate the dependencies to the dependants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:102,Integrability,depend,dependencies,102,// If this node has both dependants and dependencies then add it to the; // worklist to propagate the dependencies to the dependants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:122,Integrability,depend,dependants,122,// If this node has both dependants and dependencies then add it to the; // worklist to propagate the dependencies to the dependants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:25,Integrability,depend,dependencies,25,// Propagate block-level dependencies through the block-dependence graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:56,Integrability,depend,dependence,56,// Propagate block-level dependencies through the block-dependence graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp:86,Performance,load,load,86,"// Stub format is:; //; // .section __orc_stubs; // stub1:; // ldr x16, ptr1 ; PC-rel load of ptr1; // br x16 ; Jump to resolver; // stub2:; // ldr x16, ptr2 ; PC-rel load of ptr2; // br x16 ; Jump to resolver; //; // ...; //; // .section __orc_ptrs; // ptr1:; // .quad 0x0; // ptr2:; // .quad 0x0; //; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp:167,Performance,load,load,167,"// Stub format is:; //; // .section __orc_stubs; // stub1:; // ldr x16, ptr1 ; PC-rel load of ptr1; // br x16 ; Jump to resolver; // stub2:; // ldr x16, ptr2 ; PC-rel load of ptr2; // br x16 ; Jump to resolver; //; // ...; //; // .section __orc_ptrs; // ptr1:; // .quad 0x0; // ptr2:; // .quad 0x0; //; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp:3,Testability,Stub,Stub,3,"// Stub format is:; //; // .section __orc_stubs; // stub1:; // ldr x16, ptr1 ; PC-rel load of ptr1; // br x16 ; Jump to resolver; // stub2:; // ldr x16, ptr2 ; PC-rel load of ptr2; // br x16 ; Jump to resolver; //; // ...; //; // .section __orc_ptrs; // ptr1:; // .quad 0x0; // ptr2:; // .quad 0x0; //; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp:3,Testability,Stub,Stub,3,// Stub format is:; //; // .section __orc_stubs; // stub1:; // jmpq *ptr1(%rip); // .byte 0xC4 ; <- Invalid opcode padding.; // .byte 0xF1; // stub2:; // jmpq *ptr2(%rip); //; // ...; //; // .section __orc_ptrs; // ptr1:; // .quad 0x0; // ptr2:; // .quad 0x0; //; // ...; // Populate the stubs page stubs and mark it executable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp:288,Testability,stub,stubs,288,// Stub format is:; //; // .section __orc_stubs; // stub1:; // jmpq *ptr1(%rip); // .byte 0xC4 ; <- Invalid opcode padding.; // .byte 0xF1; // stub2:; // jmpq *ptr2(%rip); //; // ...; //; // .section __orc_ptrs; // ptr1:; // .quad 0x0; // ptr2:; // .quad 0x0; //; // ...; // Populate the stubs page stubs and mark it executable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp:299,Testability,stub,stubs,299,// Stub format is:; //; // .section __orc_stubs; // stub1:; // jmpq *ptr1(%rip); // .byte 0xC4 ; <- Invalid opcode padding.; // .byte 0xF1; // stub2:; // jmpq *ptr2(%rip); //; // ...; //; // .section __orc_ptrs; // ptr1:; // .quad 0x0; // ptr2:; // .quad 0x0; //; // ...; // Populate the stubs page stubs and mark it executable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp:24,Energy Efficiency,Allocate,Allocate,24,"// 0x42: sub rsp, 0x20 (Allocate shadow space)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp:3,Testability,Stub,Stub,3,// Stub format is:; //; // .section __orc_stubs; // stub1:; // jmpq *ptr1; // .byte 0xC4 ; <- Invalid opcode padding.; // .byte 0xF1; // stub2:; // jmpq *ptr2; //; // ...; //; // .section __orc_ptrs; // ptr1:; // .quad 0x0; // ptr2:; // .quad 0x0; //; // ...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp:3,Integrability,Depend,Depending,3,// Depending on endian return value will be in v0 or v1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp:3,Testability,Stub,Stub,3,"// Stub format is:; //; // .section __orc_stubs; // stub1:; // lui $t9, ptr1; // lw $t9, %lo(ptr1)($t9); // jr $t9; // stub2:; // lui $t9, ptr2; // lw $t9,%lo(ptr1)($t9); // jr $t9; //; // ...; //; // .section __orc_ptrs; // ptr1:; // .word 0x0; // ptr2:; // .word 0x0; //; // i..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp:16,Testability,stub,stubs,16,// Populate the stubs page stubs and mark it executable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp:27,Testability,stub,stubs,27,// Populate the stubs page stubs and mark it executable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp:3,Testability,Stub,Stub,3,"// Stub format is:; //; // .section __orc_stubs; // stub1:; // lui $t9,ptr1; // dsll $t9,$t9,16; // daddiu $t9,$t9,%hi(ptr); // dsll $t9,$t9,16; // ld $t9,%lo(ptr); // jr $t9; // stub2:; // lui $t9,ptr1; // dsll $t9,$t9,16; // daddiu $t9,$t9,%hi(ptr); // dsll $t9,$t9,16; // ld $t9,%lo(ptr); // jr $t9; //; // ...; //; // .section __orc_ptrs; // ptr1:; // .dword 0x0; // ptr2:; // .dword 0x0; //; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp:16,Testability,stub,stubs,16,// Populate the stubs page stubs and mark it executable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp:27,Testability,stub,stubs,27,// Populate the stubs page stubs and mark it executable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp:92,Performance,load,load,92,"// Stub format is:; //; // .section __orc_stubs; // stub1:; // auipc t0, %hi(ptr1) ; PC-rel load of ptr1; // ld t0, %lo(t0); // jr t0 ; Jump to resolver; // .quad 0 ; Pad to 16 bytes; // stub2:; // auipc t0, %hi(ptr1) ; PC-rel load of ptr1; // ld t0, %lo(t0); // jr t0 ; Jump to resolver; // .quad 0; //; // ...; //; // .section __orc_ptrs; // ptr1:; // .quad 0x0; // ptr2:; // .quad 0x0; //; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp:227,Performance,load,load,227,"// Stub format is:; //; // .section __orc_stubs; // stub1:; // auipc t0, %hi(ptr1) ; PC-rel load of ptr1; // ld t0, %lo(t0); // jr t0 ; Jump to resolver; // .quad 0 ; Pad to 16 bytes; // stub2:; // auipc t0, %hi(ptr1) ; PC-rel load of ptr1; // ld t0, %lo(t0); // jr t0 ; Jump to resolver; // .quad 0; //; // ...; //; // .section __orc_ptrs; // ptr1:; // .quad 0x0; // ptr2:; // .quad 0x0; //; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp:3,Testability,Stub,Stub,3,"// Stub format is:; //; // .section __orc_stubs; // stub1:; // auipc t0, %hi(ptr1) ; PC-rel load of ptr1; // ld t0, %lo(t0); // jr t0 ; Jump to resolver; // .quad 0 ; Pad to 16 bytes; // stub2:; // auipc t0, %hi(ptr1) ; PC-rel load of ptr1; // ld t0, %lo(t0); // jr t0 ; Jump to resolver; // .quad 0; //; // ...; //; // .section __orc_ptrs; // ptr1:; // .quad 0x0; // ptr2:; // .quad 0x0; //; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp:102,Performance,load,load,102,"// Stub format is:; //; // .section __orc_stubs; // stub1:; // pcaddu12i $t0, %pc_hi20(ptr1) ; PC-rel load of ptr1; // ld.d $t0, $t0, %pc_lo12(ptr1); // jr $t0 ; Jump to resolver; // .dword 0 ; Pad to 16 bytes; // stub2:; // pcaddu12i $t0, %pc_hi20(ptr2) ; PC-rel load of ptr2; // ld.d $t0, $t0, %pc_lo12(ptr2); // jr $t0 ; Jump to resolver; // .dword 0 ; Pad to 16 bytes; // ...; //; // .section __orc_ptrs; // ptr1:; // .dword 0x0; // ptr2:; // .dword 0x0; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp:264,Performance,load,load,264,"// Stub format is:; //; // .section __orc_stubs; // stub1:; // pcaddu12i $t0, %pc_hi20(ptr1) ; PC-rel load of ptr1; // ld.d $t0, $t0, %pc_lo12(ptr1); // jr $t0 ; Jump to resolver; // .dword 0 ; Pad to 16 bytes; // stub2:; // pcaddu12i $t0, %pc_hi20(ptr2) ; PC-rel load of ptr2; // ld.d $t0, $t0, %pc_lo12(ptr2); // jr $t0 ; Jump to resolver; // .dword 0 ; Pad to 16 bytes; // ...; //; // .section __orc_ptrs; // ptr1:; // .dword 0x0; // ptr2:; // .dword 0x0; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp:3,Testability,Stub,Stub,3,"// Stub format is:; //; // .section __orc_stubs; // stub1:; // pcaddu12i $t0, %pc_hi20(ptr1) ; PC-rel load of ptr1; // ld.d $t0, $t0, %pc_lo12(ptr1); // jr $t0 ; Jump to resolver; // .dword 0 ; Pad to 16 bytes; // stub2:; // pcaddu12i $t0, %pc_hi20(ptr2) ; PC-rel load of ptr2; // ld.d $t0, $t0, %pc_lo12(ptr2); // jr $t0 ; Jump to resolver; // .dword 0 ; Pad to 16 bytes; // ...; //; // .section __orc_ptrs; // ptr1:; // .dword 0x0; // ptr2:; // .dword 0x0; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/OrcABISupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.cpp:12,Integrability,depend,dependencies,12,// Register dependencies for all symbols contained in this set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.cpp:19,Availability,error,error,19,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.cpp:9,Testability,Test,Test,9,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/SimpleRemoteEPC.cpp:13,Usability,Simpl,SimpleRemoteEPC,13,"//===------- SimpleRemoteEPC.cpp -- Simple remote executor control --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/SimpleRemoteEPC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/SimpleRemoteEPC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/SimpleRemoteEPC.cpp:36,Usability,Simpl,Simple,36,"//===------- SimpleRemoteEPC.cpp -- Simple remote executor control --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/SimpleRemoteEPC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/SimpleRemoteEPC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/SpeculateAnalyses.cpp:64,Availability,down,downwards,64,"// visit NHotBlocks,; // traverse upwards to entry; // traverse downwards to end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/SpeculateAnalyses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/SpeculateAnalyses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/SpeculateAnalyses.cpp:3,Energy Efficiency,reduce,reduce,3,// reduce the number of lists!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/SpeculateAnalyses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/SpeculateAnalyses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp:183,Integrability,contract,contract,183,"// If two modules, share the same LLVMContext, different threads must; // not access them concurrently without locking the associated LLVMContext; // this implementation follows this contract.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp:90,Performance,concurren,concurrently,90,"// If two modules, share the same LLVMContext, different threads must; // not access them concurrently without locking the associated LLVMContext; // this implementation follows this contract.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp:78,Security,access,access,78,"// If two modules, share the same LLVMContext, different threads must; // not access them concurrently without locking the associated LLVMContext; // this implementation follows this contract.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp:114,Safety,predict,prediction,114,"// QueryAnalysis allowed to transform the IR source, one such example is; // Simplify CFG helps the static branch prediction heuristics!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp:77,Usability,Simpl,Simplify,77,"// QueryAnalysis allowed to transform the IR source, one such example is; // Simplify CFG helps the static branch prediction heuristics!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp:11,Performance,load,loaded,11,"// if just loaded value equal to 0,return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ThreadSafeModule.cpp:38,Safety,safe,safe,38,"//===-- ThreadSafeModule.cpp - Thread safe Module, Context, and Utilities; //h-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ThreadSafeModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ThreadSafeModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/DebuggerSupportPlugin.cpp:40,Performance,load,load,40,// Write MachO header and debug section load commands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/DebuggerSupportPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/DebuggerSupportPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/DebuggerSupportPlugin.cpp:35,Availability,error,error,35,// Try to parse line data. Consume error on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/DebuggerSupportPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/DebuggerSupportPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/DebuggerSupportPlugin.cpp:44,Availability,failure,failure,44,// Try to parse line data. Consume error on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/DebuggerSupportPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/DebuggerSupportPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/DebuggerSupportPlugin.cpp:3,Deployability,Update,Update,3,// Update stab symbol addresses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/DebuggerSupportPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/DebuggerSupportPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/DebuggerSupportPlugin.cpp:48,Deployability,install,install,48,// Scan for debug sections. If we find one then install passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/DebuggerSupportPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/DebuggerSupportPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/PerfSupportPlugin.cpp:124,Integrability,inject,injects,124,// Creates an EH frame header prepared for a 32-bit relative relocation; // to the start of the .eh_frame section. Absolute injects a 64-bit absolute; // address space offset 4 bytes from the start instead of 4 bytes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/PerfSupportPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/PerfSupportPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/PerfSupportPlugin.cpp:124,Security,inject,injects,124,// Creates an EH frame header prepared for a 32-bit relative relocation; // to the start of the .eh_frame section. Absolute injects a 64-bit absolute; // address space offset 4 bytes from the start instead of 4 bytes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/PerfSupportPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/PerfSupportPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/PerfSupportPlugin.cpp:16,Availability,avail,available,16,// No line info available,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/PerfSupportPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Debugging/PerfSupportPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/OrcError.cpp:37,Availability,Error,Error,37,"//===---------------- OrcError.cpp - Error codes for ORC ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Error codes for ORC.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/OrcError.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/OrcError.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/OrcError.cpp:383,Availability,Error,Error,383,"//===---------------- OrcError.cpp - Error codes for ORC ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Error codes for ORC.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/OrcError.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/OrcError.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/OrcError.cpp:69,Availability,Error,Error,69,"// FIXME: This class is only here to support the transition to llvm::Error. It; // will be removed once this transition is complete. Clients should prefer to; // deal with the Error value directly, rather than converting to error_code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/OrcError.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/OrcError.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/OrcError.cpp:176,Availability,Error,Error,176,"// FIXME: This class is only here to support the transition to llvm::Error. It; // will be removed once this transition is complete. Clients should prefer to; // deal with the Error value directly, rather than converting to error_code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/OrcError.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/OrcError.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp:383,Integrability,Message,Message,383,"//===------ SimpleRemoteEPCUtils.cpp - Utils for Simple Remote EPC --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Message definitions and other utilities for SimpleRemoteEPC and; // SimpleRemoteEPCServer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp:12,Usability,Simpl,SimpleRemoteEPCUtils,12,"//===------ SimpleRemoteEPCUtils.cpp - Utils for Simple Remote EPC --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Message definitions and other utilities for SimpleRemoteEPC and; // SimpleRemoteEPCServer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp:49,Usability,Simpl,Simple,49,"//===------ SimpleRemoteEPCUtils.cpp - Utils for Simple Remote EPC --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Message definitions and other utilities for SimpleRemoteEPC and; // SimpleRemoteEPCServer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp:427,Usability,Simpl,SimpleRemoteEPC,427,"//===------ SimpleRemoteEPCUtils.cpp - Utils for Simple Remote EPC --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Message definitions and other utilities for SimpleRemoteEPC and; // SimpleRemoteEPCServer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp:451,Usability,Simpl,SimpleRemoteEPCServer,451,"//===------ SimpleRemoteEPCUtils.cpp - Utils for Simple Remote EPC --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Message definitions and other utilities for SimpleRemoteEPC and; // SimpleRemoteEPCServer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp:17,Usability,Simpl,SimpleRemoteEPCDefaultBootstrapSymbolNames,17,// end namespace SimpleRemoteEPCDefaultBootstrapSymbolNames,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp:53,Integrability,interface,interface,53,"//===- JITLoaderGDB.h - Register objects via GDB JIT interface -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp:40,Integrability,interface,interface,40,// Debuggers that implement the GDB JIT interface put a special breakpoint in; // this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp:74,Performance,optimiz,optimized,74,// The noinline and the asm prevent calls to this function from being; // optimized out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp:33,Availability,error,error,33,"// Register debug object, return error message or null for success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp:39,Integrability,message,message,39,"// Register debug object, return error message or null for success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp:53,Security,access,access,53,// Serialize rendezvous with the debugger as well as access to shared data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderPerf.cpp:441,Integrability,interface,interface,441,"//===------- JITLoaderPerf.cpp - Register profiler objects ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Register objects for access by profilers via the perf JIT interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderPerf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderPerf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderPerf.cpp:404,Security,access,access,404,"//===------- JITLoaderPerf.cpp - Register profiler objects ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Register objects for access by profilers via the perf JIT interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderPerf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderPerf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderPerf.cpp:3,Performance,cache,cache,3,// cache lookups,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderPerf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderPerf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderPerf.cpp:11,Performance,concurren,concurrent,11,// prevent concurrent dumps from messing up the output file,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderPerf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderPerf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderPerf.cpp:314,Safety,detect,detect,314,"// We mmap the jitdump to create an MMAP RECORD in perf.data file. The mmap; // is captured either live (perf record running when we mmap) or in deferred; // mode, via /proc/PID/maps. The MMAP record is used as a marker of a jitdump; // file for more meta data info about the jitted code. Perf report/annotate; // detect this special filename and process the jitdump file.; //; // Mapping must be PROT_EXEC to ensure it is captured by perf record; // even when not using -d option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderPerf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderPerf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderPerf.cpp:105,Security,expose,expose,105,"// Need to open ourselves, because we need to hand the FD to OpenMarker() and; // raw_fd_ostream doesn't expose the FD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderPerf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderPerf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/OrcRTBootstrap.h:540,Security,access,access,540,"//===----------------------- OrcRTBootstrap.h -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // OrcRTPrelinkImpl provides functions that should be linked into the executor; // to bootstrap common JIT functionality (e.g. memory allocation and memory; // access).; //; // Call rt_impl::addTo to add these functions to a bootstrap symbols map.; //; // FIXME: The functionality in this file should probably be moved to an ORC; // runtime bootstrap library in compiler-rt.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/OrcRTBootstrap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/OrcRTBootstrap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/RegisterEHFrames.cpp:112,Performance,load,loaded,112,"// The building compiler does not have __(de)register_frame but; // it may be found at runtime in a dynamically-loaded library.; // For example, this happens when building LLVM with Visual C++; // but using the MingW runtime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/RegisterEHFrames.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/RegisterEHFrames.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/RegisterEHFrames.cpp:112,Safety,detect,detect,112,/* libgcc and libunwind __register_frame behave differently. We use the; * presence of __unw_add_dynamic_fde to detect libunwind. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/RegisterEHFrames.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/RegisterEHFrames.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleExecutorDylibManager.cpp:9,Usability,Simpl,SimpleExecutorDylibManager,9,"//===--- SimpleExecutorDylibManager.cpp - Executor-side dylib management --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleExecutorDylibManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleExecutorDylibManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleExecutorMemoryManager.cpp:7,Usability,Simpl,SimpleExecuorMemoryManagare,7,"//===- SimpleExecuorMemoryManagare.cpp - Simple executor-side memory mgmt -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleExecutorMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleExecutorMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleExecutorMemoryManager.cpp:41,Usability,Simpl,Simple,41,"//===- SimpleExecuorMemoryManagare.cpp - Simple executor-side memory mgmt -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleExecutorMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleExecutorMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleExecutorMemoryManager.cpp:66,Availability,error,error,66,// NOTE: Finalizing nothing is currently a no-op. Should it be an error?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleExecutorMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleExecutorMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp:13,Usability,Simpl,SimpleEPCServer,13,"//===------- SimpleEPCServer.cpp - EPC over simple abstract channel -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp:44,Usability,simpl,simple,44,"//===------- SimpleEPCServer.cpp - EPC over simple abstract channel -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp:22,Integrability,message,message,22,// TODO: Clean detach message?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp:20,Availability,error,errors,20,// Send out-of-band errors to any waiting threads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp:26,Usability,clear,clear,26,// Wait for dispatcher to clear.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp:8,Availability,down,down,8,// Shut down services.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp:556,Availability,avail,available,556,"//===-- PerfJITEventListener.cpp - Tell Linux's perf about JITted code ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a JITEventListener object that tells perf about JITted; // functions, including source line information.; //; // Documentation for perf jit integration is available at:; // https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/tools/perf/Documentation/jitdump-specification.txt; // https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/tools/perf/Documentation/jit-interface.txt; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp:541,Deployability,integrat,integration,541,"//===-- PerfJITEventListener.cpp - Tell Linux's perf about JITted code ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a JITEventListener object that tells perf about JITted; // functions, including source line information.; //; // Documentation for perf jit integration is available at:; // https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/tools/perf/Documentation/jitdump-specification.txt; // https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/tools/perf/Documentation/jit-interface.txt; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp:541,Integrability,integrat,integration,541,"//===-- PerfJITEventListener.cpp - Tell Linux's perf about JITted code ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a JITEventListener object that tells perf about JITted; // functions, including source line information.; //; // Documentation for perf jit integration is available at:; // https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/tools/perf/Documentation/jitdump-specification.txt; // https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/tools/perf/Documentation/jit-interface.txt; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp:796,Integrability,interface,interface,796,"//===-- PerfJITEventListener.cpp - Tell Linux's perf about JITted code ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a JITEventListener object that tells perf about JITted; // functions, including source line information.; //; // Documentation for perf jit integration is available at:; // https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/tools/perf/Documentation/jitdump-specification.txt; // https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/tools/perf/Documentation/jit-interface.txt; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp:3,Performance,cache,cache,3,// cache lookups,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp:11,Performance,concurren,concurrent,11,// prevent concurrent dumps from messing up the output file,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp:105,Security,expose,expose,105,"// Need to open ourselves, because we need to hand the FD to OpenMarker() and; // raw_fd_ostream doesn't expose the FD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp:32,Availability,error,errors,32,// There's not much we can with errors here,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp:55,Performance,load,loading,55,// According to spec debugging info has to come before loading the; // corresponding code load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp:90,Performance,load,load,90,// According to spec debugging info has to come before loading the; // corresponding code load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp:3,Safety,avoid,avoid,3,// avoid races with writes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp:34,Integrability,interface,interface,34,"// perf currently doesn't have an interface for unloading. But munmap()ing the; // code section does, so that's ok.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp:314,Safety,detect,detect,314,"// We mmap the jitdump to create an MMAP RECORD in perf.data file. The mmap; // is captured either live (perf record running when we mmap) or in deferred; // mode, via /proc/PID/maps. The MMAP record is used as a marker of a jitdump; // file for more meta data info about the jitted code. Perf report/annotate; // detect this special filename and process the jitdump file.; //; // Mapping must be PROT_EXEC to ensure it is captured by perf record; // even when not using -d option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp:3,Safety,avoid,avoid,3,// avoid interspersing output,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp:33,Modifiability,variab,variable,33,// compute total size of record (variable due to filenames),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp:393,Safety,avoid,avoid,393,"// The debug_entry describes the source line information. It is defined as; // follows in order:; // * uint64_t code_addr: address of function for which the debug information; // is generated; // * uint32_t line : source file line number (starting at 1); // * uint32_t discrim : column discriminator, 0 is default; // * char name[n] : source file name in ASCII, including null termination; // avoid interspersing output",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/JITSymbol.cpp:19,Availability,error,error,19,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/JITSymbol.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/JITSymbol.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/JITSymbol.cpp:9,Testability,Test,Test,9,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/JITSymbol.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/JITSymbol.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/JITSymbol.cpp:25,Availability,error,errors,25,// TODO: Actually report errors helpfully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/JITSymbol.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/JITSymbol.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/JITSymbol.cpp:4,Performance,Perform,Performs,4,"/// Performs lookup by, for each symbol, first calling; /// findSymbolInLogicalDylib and if that fails calling; /// findSymbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/JITSymbol.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/JITSymbol.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/JITSymbol.cpp:4,Performance,Perform,Performs,4,/// Performs flags lookup by calling findSymbolInLogicalDylib and; /// returning the flags value for that symbol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/JITSymbol.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/JITSymbol.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RTDyldMemoryManager.cpp:112,Performance,load,loaded,112,"// The building compiler does not have __(de)register_frame but; // it may be found at runtime in a dynamically-loaded library.; // For example, this happens when building LLVM with Visual C++; // but using the MingW runtime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RTDyldMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RTDyldMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RTDyldMemoryManager.cpp:112,Safety,detect,detect,112,/* libgcc and libunwind __register_frame behave differently. We use the presence; * of __unw_add_dynamic_fde to detect libunwind. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RTDyldMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RTDyldMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RTDyldMemoryManager.cpp:158,Performance,Load,LoadAddr,158,// This implementation handles frame registration for local targets.; // Memory managers for remote targets should re-implement this function; // and use the LoadAddr parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RTDyldMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RTDyldMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RTDyldMemoryManager.cpp:82,Availability,avail,available,82,"// ARM math functions are statically linked on Android from libgcc.a, but not; // available at runtime for dynamic linking. On Linux these are usually placed; // in libgcc_s.so so can be found by normal dynamic lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RTDyldMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RTDyldMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RTDyldMemoryManager.cpp:304,Testability,test,test,304,// List of functions which are statically linked on Android and can be generated; // by LLVM. This is done as a nested macro which is used once to declare the; // imported functions with ARM_MATH_DECL and once to compare them to the; // user-requested symbol in getSymbolAddress with ARM_MATH_CHECK. The test; // assumes that all functions start with __aeabi_ and getSymbolAddress must be; // modified if that changes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RTDyldMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RTDyldMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RTDyldMemoryManager.cpp:92,Testability,stub,stubs,92,"//===--------------------------------------------------------------------===//; // Function stubs that are invoked instead of certain library calls; //; // Force the following functions to be linked in to anything that uses the; // JIT. This is a hack designed to work around the all-too-clever Glibc; // strategy of making these functions work differently when inlined vs. when; // not inlined, and hiding their real definitions in a separate archive file; // that the dynamic linker can't see. For more info, search for; // 'libc_nonshared.a' on Google, or read http://llvm.org/PR274.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RTDyldMemoryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RTDyldMemoryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:69,Availability,Error,Error,69,"// FIXME: This class is only here to support the transition to llvm::Error. It; // will be removed once this transition is complete. Clients should prefer to; // deal with the Error value directly, rather than converting to error_code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:176,Availability,Error,Error,176,"// FIXME: This class is only here to support the transition to llvm::Error. It; // will be removed once this transition is complete. Clients should prefer to; // deal with the Error value directly, rather than converting to error_code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:7,Performance,Load,LoadedObjectInfo,7,// Pin LoadedObjectInfo's vtables to this file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:39,Performance,load,load,39,// Compute the memory size required to load all sections to be loaded; // and pass this information to the memory manager,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:63,Performance,load,loaded,63,// Compute the memory size required to load all sections to be loaded; // and pass this information to the memory manager,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:19,Availability,error,error,19,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:9,Testability,Test,Test,9,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:19,Availability,error,error,19,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:9,Testability,Test,Test,9,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:13,Deployability,update,update,13,// Otherwise update the flags on the symbol to make this definition; // strong.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate common symbols,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:77,Testability,stub,stubs,77,"// If there is a NotifyStubEmitted callback set, call it to register any; // stubs created for this section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:22,Testability,stub,stub,22,"// If this is a named stub, just call NotifyStubEmitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:18,Performance,load,loaded,18,/* Ignore already loaded sections */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:87,Energy Efficiency,allocate,allocate,87,"// A helper method for computeTotalAllocSize.; // Computes the memory size required to allocate sections with the given sizes,; // assuming that all sections are allocated with the given alignment",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:162,Energy Efficiency,allocate,allocated,162,"// A helper method for computeTotalAllocSize.; // Computes the memory size required to allocate sections with the given sizes,; // assuming that all sections are allocated with the given alignment",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:9,Performance,load,loading,9,"// Avoid loading zero-sized COFF sections.; // In PE files, VirtualSize gives the section size, and SizeOfRawData; // may be zero for sections with content. In Obj files, SizeOfRawData; // gives the section size, and VirtualSize is always zero. Hence; // the need to check for both cases below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:3,Safety,Avoid,Avoid,3,"// Avoid loading zero-sized COFF sections.; // In PE files, VirtualSize gives the section size, and SizeOfRawData; // may be zero for sections with content. In Obj files, SizeOfRawData; // gives the section size, and VirtualSize is always zero. Hence; // the need to check for both cases below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:65,Performance,load,load,65,// Compute an upper bound of the memory size that is required to load all; // sections,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:39,Performance,load,loaded,39,// Collect sizes of all sections to be loaded;; // also determine the max alignment of all sections,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:54,Performance,load,loaded,54,// Consider only the sections that are required to be loaded for execution,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:67,Deployability,update,update,67,"// Compute Global Offset Table size. If it is not zero we; // also update alignment, which is equal to a size of a; // single GOT entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:19,Availability,error,error,19,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:9,Testability,Test,Test,9,// TODO: Test this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:43,Energy Efficiency,allocate,allocate,43,// Add the common symbols to a list. We'll allocate them all below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:47,Testability,stub,stub,47,// Add 64 bytes for a potential IFunc resolver stub,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:156,Energy Efficiency,allocate,allocated,156,"// Compute the required allocation space for each different type of sections; // (code, read-only data, read-write data) assuming that all sections are; // allocated with the max alignment. Note that we cannot compute with the; // individual alignments of the sections, because then the required size; // depends on the order, in which the sections are allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:353,Energy Efficiency,allocate,allocated,353,"// Compute the required allocation space for each different type of sections; // (code, read-only data, read-write data) assuming that all sections are; // allocated with the max alignment. Note that we cannot compute with the; // individual alignments of the sections, because then the required size; // depends on the order, in which the sections are allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:305,Integrability,depend,depends,305,"// Compute the required allocation space for each different type of sections; // (code, read-only data, read-write data) assuming that all sections are; // allocated with the max alignment. Note that we cannot compute with the; // individual alignments of the sections, because then the required size; // depends on the order, in which the sections are allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:11,Testability,stub,stub,11,// compute stub buffer size for the given section,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:117,Performance,load,loadObject,117,// FIXME: this is an inefficient way to handle this. We should computed the; // necessary section allocation size in loadObject by walking all the sections; // once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:7,Testability,stub,stubbuf,7,// Add stubbuf size alignment,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate memory for the section,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:20,Testability,stub,stubs,20,// If there are any stubs then the section alignment needs to be at least as; // high as stub alignment or padding calculations may by incorrect when the; // section is remapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:89,Testability,stub,stub,89,// If there are any stubs then the section alignment needs to be at least as; // high as stub alignment or padding calculations may by incorrect when the; // section is remapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:55,Performance,load,loaded,55,"// Some sections, such as debug info, don't need to be loaded for execution.; // Process those only if explicitly requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:30,Energy Efficiency,allocate,allocated,30,// Fill in any extra bytes we allocated for padding,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:3,Deployability,Update,Update,3,// Update the DataSize variable to include padding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:23,Modifiability,variab,variable,23,// Update the DataSize variable to include padding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:21,Testability,stub,stub,21,// Align DataSize to stub alignment if we have any stubs (PaddingSize will; // have been increased above to account for this).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:51,Testability,stub,stubs,51,// Align DataSize to stub alignment if we have any stubs (PaddingSize will; // have been increased above to account for this).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:21,Performance,load,load,21,"// Even if we didn't load the section, we need to record an entry for it; // to handle later processing (and by 'handle' I mean don't do anything; // with these sections).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:7,Performance,load,load,7,// The load address of a TLS section is not equal to the address of its; // initialization image,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:46,Performance,load,load,46,// Debug info sections are linked as if their load address was zero,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:31,Security,access,access,31,"// This stub has to be able to access the full address space,; // since symbol lookup won't necessarily find a handy, in-range,; // PLT stub for functions which could be anywhere.; // Stub can use ip0 (== x16) to calculate address",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:8,Testability,stub,stub,8,"// This stub has to be able to access the full address space,; // since symbol lookup won't necessarily find a handy, in-range,; // PLT stub for functions which could be anywhere.; // Stub can use ip0 (== x16) to calculate address",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:136,Testability,stub,stub,136,"// This stub has to be able to access the full address space,; // since symbol lookup won't necessarily find a handy, in-range,; // PLT stub for functions which could be anywhere.; // Stub can use ip0 (== x16) to calculate address",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:184,Testability,Stub,Stub,184,"// This stub has to be able to access the full address space,; // since symbol lookup won't necessarily find a handy, in-range,; // PLT stub for functions which could be anywhere.; // Stub can use ip0 (== x16) to calculate address",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:31,Testability,stub,stub,31,"// TODO: There is only ARM far stub now. We should add the Thumb stub,; // and stubs for branches Thumb - ARM and ARM - Thumb.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:65,Testability,stub,stub,65,"// TODO: There is only ARM far stub now. We should add the Thumb stub,; // and stubs for branches Thumb - ARM and ARM - Thumb.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:79,Testability,stub,stubs,79,"// TODO: There is only ARM far stub now. We should add the Thumb stub,; // and stubs for branches Thumb - ARM and ARM - Thumb.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:3,Integrability,Depend,Depending,3,"// Depending on which version of the ELF ABI is in use, we need to; // generate one of two variants of the stub. They both start with; // the same sequence to load the target address into r12.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:159,Performance,load,load,159,"// Depending on which version of the ELF ABI is in use, we need to; // generate one of two variants of the stub. They both start with; // the same sequence to load the target address into r12.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:107,Testability,stub,stub,107,"// Depending on which version of the ELF ABI is in use, we need to; // generate one of two variants of the stub. They both start with; // the same sequence to load the target address into r12.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:13,Testability,stub,stub,13,// PowerPC64 stub ELFv2 ABI: The address points to the function itself.; // The address is already in r12 as required by the ABI. Branch to it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:78,Performance,Load,Load,78,// PowerPC64 stub ELFv1 ABI: The address points to a function descriptor.; // Load the function address on r11 and sets it to control register. Also; // loads the function TOC in r2 and environment pointer to r11.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:153,Performance,load,loads,153,// PowerPC64 stub ELFv1 ABI: The address points to a function descriptor.; // Load the function address on r11 and sets it to control register. Also; // loads the function TOC in r2 and environment pointer to r11.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:13,Testability,stub,stub,13,// PowerPC64 stub ELFv1 ABI: The address points to a function descriptor.; // Load the function address on r11 and sets it to control register. Also; // loads the function TOC in r2 and environment pointer to r11.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:49,Performance,load,loaded,49,// Ignore relocations for sections that were not loaded,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:84,Performance,load,loaded,84,// We found the symbol in our global table. It was probably in a; // Module that we loaded previously.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:20,Availability,error,error,20,// FIXME: Implement error handling that doesn't kill the host program!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:117,Deployability,toggle,toggle,117,"// Tweak the address based on the symbol flags if necessary.; // For example, this is used by RuntimeDyldMachOARM to toggle the low bit; // if the target symbol is Thumb.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:100,Performance,load,load,100,"// FIXME: There's a potential issue lurking here if a single instance of; // RuntimeDyld is used to load multiple objects. The current implementation; // associates a single memory manager with a RuntimeDyld instance. Even; // though the public class spawns a new 'impl' instance for each load,; // they share a single memory manager. This can become a problem when page; // permissions are applied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:289,Performance,load,load,289,"// FIXME: There's a potential issue lurking here if a single instance of; // RuntimeDyld is used to load multiple objects. The current implementation; // associates a single memory manager with a RuntimeDyld instance. Even; // though the public class spawns a new 'impl' instance for each load,; // they share a single memory manager. This can become a problem when page; // permissions are applied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:159,Integrability,interface,interface,159,// FIXME: Kill this with fire once we have a new JIT linker: this is only here; // so that we can re-use RuntimeDyld's implementation without twisting the; // interface any further for ORC's purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp:46,Testability,test,tester,46,"//===--- RuntimeDyldChecker.cpp - RuntimeDyld tester framework --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp:168,Performance,load,load,168,"// RuntimeDyldCheckerExprEval requires some context when parsing exprs. In; // particular, it needs to know whether a symbol is being evaluated in the; // context of a load, in which case we want the linker's local address for; // the symbol, or outside of a load, in which case we want the symbol's; // address in the remote target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp:259,Performance,load,load,259,"// RuntimeDyldCheckerExprEval requires some context when parsing exprs. In; // particular, it needs to know whether a symbol is being evaluated in the; // context of a load, in which case we want the linker's local address for; // the symbol, or outside of a load, in which case we want the symbol's; // address in the remote target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp:152,Availability,error,error,152,"// Evaluate a call to decode_operand. Decode the instruction operand at the; // given symbol and get the value of the requested operand.; // Returns an error if the instruction cannot be decoded, or the requested; // operand is not an immediate.; // On success, returns a pair containing the value of the operand, plus; // the expression remaining to be evaluated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp:139,Availability,error,error,139,"// Evaluate a call to next_pc.; // Decode the instruction at the given symbol and return the following program; // counter.; // Returns an error if the instruction cannot be decoded.; // On success, returns a pair containing the next PC, plus of the; // expression remaining to be evaluated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp:84,Testability,stub,stub,84,"// Evaluate a call to stub_addr/got_addr.; // Look up and return the address of the stub for the given; // (<file name>, <section name>, <symbol name>) tuple.; // On success, returns a pair containing the stub address, plus the expression; // remaining to be evaluated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp:205,Testability,stub,stub,205,"// Evaluate a call to stub_addr/got_addr.; // Look up and return the address of the stub for the given; // (<file name>, <section name>, <symbol name>) tuple.; // On success, returns a pair containing the stub address, plus the expression; // remaining to be evaluated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp:41,Testability,stub,stub,41,// Parse optional parameter to filter by stub kind,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp:28,Integrability,depend,depends,28,"// The value for the symbol depends on the context we're evaluating in:; // Inside a load this is the address in the linker's memory, outside a; // load it's the address in the target processes memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp:85,Performance,load,load,85,"// The value for the symbol depends on the context we're evaluating in:; // Inside a load this is the address in the linker's memory, outside a; // load it's the address in the target processes memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp:148,Performance,load,load,148,"// The value for the symbol depends on the context we're evaluating in:; // Inside a load this is the address in the linker's memory, outside a; // load it's the address in the target processes memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp:44,Performance,load,load,44,// Evaluate the expression representing the load address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp:18,Availability,error,error,18,// If there is no error but the content pointer is null then this is a; // zero-fill symbol/section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp:15,Usability,simpl,simple,15,"// Evaluate a ""simple"" expression. This is any expression that _isn't_ an; // un-parenthesized binary expression.; //; // ""Simple"" expressions can be optionally bit-sliced. See evalSlicedExpr.; //; // Returns a pair containing the result of the evaluation, plus the; // expression remaining to be parsed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp:123,Usability,Simpl,Simple,123,"// Evaluate a ""simple"" expression. This is any expression that _isn't_ an; // un-parenthesized binary expression.; //; // ""Simple"" expressions can be optionally bit-sliced. See evalSlicedExpr.; //; // Returns a pair containing the result of the evaluation, plus the; // expression remaining to be parsed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp:19,Availability,error,error,19,"// If there was an error, or there's nothing left to evaluate, return the; // result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp:19,Availability,error,error,19,"// If there was an error evaluating the RHS, return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp:42,Performance,load,load,42,"// If this address is being looked up in ""load"" mode, return the content; // pointer, otherwise return the target address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldCheckerImpl.h:48,Testability,test,test,48,"//===-- RuntimeDyldCheckerImpl.h -- RuntimeDyld test framework --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldCheckerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldCheckerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldCheckerImpl.h:3,Testability,Stub,StubMap,3,// StubMap typedefs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldCheckerImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldCheckerImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:59,Integrability,wrap,wrapper,59,"// The MemoryBuffer passed into this constructor is just a wrapper around the; // actual memory. Ultimately, the Binary parent class will take ownership of; // this MemoryBuffer object but not the underlying memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:14,Availability,mask,masks,14,"// Relocation masks following the #lo(value), #hi(value), #ha(value),; // #higher(value), #highera(value), #highest(value), and #highesta(value); // macros defined in section 4.5.1. Relocation Types of the PPC-elf64abi; // document.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:277,Performance,load,loaded,277,"// The target location for the relocation is described by RE.SectionID and; // RE.Offset. RE.SectionID can be used to find the SectionEntry. Each; // SectionEntry has three members describing its location.; // SectionEntry::Address is the address at which the section has been loaded; // into memory in the current (host) process. SectionEntry::LoadAddress is the; // address that the section will have in the target process.; // SectionEntry::ObjAddress is the address of the bits for this section in the; // original emitted object image (also in the current address space).; //; // Relocations will be applied as if the section were loaded at; // SectionEntry::LoadAddress, but they will be applied at an address based; // on SectionEntry::Address. SectionEntry::ObjAddress will be used to refer to; // Target memory contents if they are required for value calculations.; //; // The Value parameter here is the load address of the symbol for the; // relocation to be applied. For relocations which refer to symbols in the; // current object Value will be the LoadAddress of the section in which; // the symbol resides (RE.Addend provides additional information about the; // symbol location). For external symbols, Value will be the address of the; // symbol in the target address space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:345,Performance,Load,LoadAddress,345,"// The target location for the relocation is described by RE.SectionID and; // RE.Offset. RE.SectionID can be used to find the SectionEntry. Each; // SectionEntry has three members describing its location.; // SectionEntry::Address is the address at which the section has been loaded; // into memory in the current (host) process. SectionEntry::LoadAddress is the; // address that the section will have in the target process.; // SectionEntry::ObjAddress is the address of the bits for this section in the; // original emitted object image (also in the current address space).; //; // Relocations will be applied as if the section were loaded at; // SectionEntry::LoadAddress, but they will be applied at an address based; // on SectionEntry::Address. SectionEntry::ObjAddress will be used to refer to; // Target memory contents if they are required for value calculations.; //; // The Value parameter here is the load address of the symbol for the; // relocation to be applied. For relocations which refer to symbols in the; // current object Value will be the LoadAddress of the section in which; // the symbol resides (RE.Addend provides additional information about the; // symbol location). For external symbols, Value will be the address of the; // symbol in the target address space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:636,Performance,load,loaded,636,"// The target location for the relocation is described by RE.SectionID and; // RE.Offset. RE.SectionID can be used to find the SectionEntry. Each; // SectionEntry has three members describing its location.; // SectionEntry::Address is the address at which the section has been loaded; // into memory in the current (host) process. SectionEntry::LoadAddress is the; // address that the section will have in the target process.; // SectionEntry::ObjAddress is the address of the bits for this section in the; // original emitted object image (also in the current address space).; //; // Relocations will be applied as if the section were loaded at; // SectionEntry::LoadAddress, but they will be applied at an address based; // on SectionEntry::Address. SectionEntry::ObjAddress will be used to refer to; // Target memory contents if they are required for value calculations.; //; // The Value parameter here is the load address of the symbol for the; // relocation to be applied. For relocations which refer to symbols in the; // current object Value will be the LoadAddress of the section in which; // the symbol resides (RE.Addend provides additional information about the; // symbol location). For external symbols, Value will be the address of the; // symbol in the target address space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:664,Performance,Load,LoadAddress,664,"// The target location for the relocation is described by RE.SectionID and; // RE.Offset. RE.SectionID can be used to find the SectionEntry. Each; // SectionEntry has three members describing its location.; // SectionEntry::Address is the address at which the section has been loaded; // into memory in the current (host) process. SectionEntry::LoadAddress is the; // address that the section will have in the target process.; // SectionEntry::ObjAddress is the address of the bits for this section in the; // original emitted object image (also in the current address space).; //; // Relocations will be applied as if the section were loaded at; // SectionEntry::LoadAddress, but they will be applied at an address based; // on SectionEntry::Address. SectionEntry::ObjAddress will be used to refer to; // Target memory contents if they are required for value calculations.; //; // The Value parameter here is the load address of the symbol for the; // relocation to be applied. For relocations which refer to symbols in the; // current object Value will be the LoadAddress of the section in which; // the symbol resides (RE.Addend provides additional information about the; // symbol location). For external symbols, Value will be the address of the; // symbol in the target address space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:914,Performance,load,load,914,"// The target location for the relocation is described by RE.SectionID and; // RE.Offset. RE.SectionID can be used to find the SectionEntry. Each; // SectionEntry has three members describing its location.; // SectionEntry::Address is the address at which the section has been loaded; // into memory in the current (host) process. SectionEntry::LoadAddress is the; // address that the section will have in the target process.; // SectionEntry::ObjAddress is the address of the bits for this section in the; // original emitted object image (also in the current address space).; //; // Relocations will be applied as if the section were loaded at; // SectionEntry::LoadAddress, but they will be applied at an address based; // on SectionEntry::Address. SectionEntry::ObjAddress will be used to refer to; // Target memory contents if they are required for value calculations.; //; // The Value parameter here is the load address of the symbol for the; // relocation to be applied. For relocations which refer to symbols in the; // current object Value will be the LoadAddress of the section in which; // the symbol resides (RE.Addend provides additional information about the; // symbol location). For external symbols, Value will be the address of the; // symbol in the target address space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:1062,Performance,Load,LoadAddress,1062,"// The target location for the relocation is described by RE.SectionID and; // RE.Offset. RE.SectionID can be used to find the SectionEntry. Each; // SectionEntry has three members describing its location.; // SectionEntry::Address is the address at which the section has been loaded; // into memory in the current (host) process. SectionEntry::LoadAddress is the; // address that the section will have in the target process.; // SectionEntry::ObjAddress is the address of the bits for this section in the; // original emitted object image (also in the current address space).; //; // Relocations will be applied as if the section were loaded at; // SectionEntry::LoadAddress, but they will be applied at an address based; // on SectionEntry::Address. SectionEntry::ObjAddress will be used to refer to; // Target memory contents if they are required for value calculations.; //; // The Value parameter here is the load address of the symbol for the; // relocation to be applied. For relocations which refer to symbols in the; // current object Value will be the LoadAddress of the section in which; // the symbol resides (RE.Addend provides additional information about the; // symbol location). For external symbols, Value will be the address of the; // symbol in the target address space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:24,Testability,stub,stub,24,// Look for an existing stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:16,Testability,stub,stub,16,// Create a new stub function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:51,Testability,stub,stub,51,"// This is an ARM branch relocation, need to use a stub function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:24,Testability,stub,stub,24,// Look for an existing stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:16,Testability,stub,stub,16,// Create a new stub function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:52,Testability,stub,stub,52,"// This is an Mips branch relocation, need to use a stub function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:91,Availability,down,down,91,// Extract the addend from the instruction.; // We shift up by two since the Value will be down shifted again; // when applying the relocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:24,Testability,stub,stub,24,// Look up for existing stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:16,Testability,stub,stub,16,// Create a new stub function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:49,Testability,stub,stub,49,// Creating Hi and Lo relocations for the filled stub instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:52,Testability,stub,stub,52,"// This is an Mips branch relocation, need to use a stub function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:24,Testability,stub,stub,24,// Look up for existing stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:16,Testability,stub,stub,16,// Create a new stub function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:49,Testability,stub,stub,49,// Creating Hi and Lo relocations for the filled stub instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:66,Testability,stub,stub,66,"// Creating Highest, Higher, Hi and Lo relocations for the filled stub; // instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:39,Testability,stub,stub,39,"// A PPC branch relocation will need a stub function if the target is; // an external symbol (either Value.SymbolName is set, or SymType is; // Symbol::ST_Unknown) or if the target address is not within the; // signed 24-bits branch address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:19,Testability,stub,stub,19,"// Symbol function stub already created, just relocate to it",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:16,Testability,stub,stub,16,// Create a new stub function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:188,Deployability,update,update,188,"// Generates the 64-bits address loads as exemplified in section; // 4.5.1 in PPC64 ELF ABI. Note that the relocations need to; // apply to the low part of the instructions, so we have to update; // the offset according to the target endianness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:33,Performance,load,loads,33,"// Generates the 64-bits address loads as exemplified in section; // 4.5.1 in PPC64 ELF ABI. Note that the relocations need to; // apply to the low part of the instructions, so we have to update; // the offset according to the target endianness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:401,Energy Efficiency,allocate,allocate,401,"// Create function stubs for both PLT and GOT references, regardless of; // whether the GOT reference is to data or code. The stub contains the; // full address of the symbol, as needed by GOT references, and the; // executable part only adds an overhead of 8 bytes.; //; // We could try to conserve space by allocating the code and data; // parts of the stub separately. However, as things stand, we allocate; // a stub for every relocation, so using a GOT in JIT code should be; // no less space efficient than using an explicit constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:498,Energy Efficiency,efficient,efficient,498,"// Create function stubs for both PLT and GOT references, regardless of; // whether the GOT reference is to data or code. The stub contains the; // full address of the symbol, as needed by GOT references, and the; // executable part only adds an overhead of 8 bytes.; //; // We could try to conserve space by allocating the code and data; // parts of the stub separately. However, as things stand, we allocate; // a stub for every relocation, so using a GOT in JIT code should be; // no less space efficient than using an explicit constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:19,Testability,stub,stubs,19,"// Create function stubs for both PLT and GOT references, regardless of; // whether the GOT reference is to data or code. The stub contains the; // full address of the symbol, as needed by GOT references, and the; // executable part only adds an overhead of 8 bytes.; //; // We could try to conserve space by allocating the code and data; // parts of the stub separately. However, as things stand, we allocate; // a stub for every relocation, so using a GOT in JIT code should be; // no less space efficient than using an explicit constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:126,Testability,stub,stub,126,"// Create function stubs for both PLT and GOT references, regardless of; // whether the GOT reference is to data or code. The stub contains the; // full address of the symbol, as needed by GOT references, and the; // executable part only adds an overhead of 8 bytes.; //; // We could try to conserve space by allocating the code and data; // parts of the stub separately. However, as things stand, we allocate; // a stub for every relocation, so using a GOT in JIT code should be; // no less space efficient than using an explicit constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:355,Testability,stub,stub,355,"// Create function stubs for both PLT and GOT references, regardless of; // whether the GOT reference is to data or code. The stub contains the; // full address of the symbol, as needed by GOT references, and the; // executable part only adds an overhead of 8 bytes.; //; // We could try to conserve space by allocating the code and data; // parts of the stub separately. However, as things stand, we allocate; // a stub for every relocation, so using a GOT in JIT code should be; // no less space efficient than using an explicit constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:416,Testability,stub,stub,416,"// Create function stubs for both PLT and GOT references, regardless of; // whether the GOT reference is to data or code. The stub contains the; // full address of the symbol, as needed by GOT references, and the; // executable part only adds an overhead of 8 bytes.; //; // We could try to conserve space by allocating the code and data; // parts of the stub separately. However, as things stand, we allocate; // a stub for every relocation, so using a GOT in JIT code should be; // no less space efficient than using an explicit constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:24,Testability,stub,stub,24,// Look for an existing stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:16,Testability,stub,stub,16,// Create a new stub function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:64,Energy Efficiency,allocate,allocates,64,"// The way the PLT relocations normally work is that the linker allocates; // the; // PLT and this relocation makes a PC-relative call into the PLT. The PLT; // entry will then jump to an address provided by the GOT. On first call,; // the; // GOT address will point back into PLT code that resolves the symbol. After; // the first call, the GOT entry points to the actual function.; //; // For local functions we're ignoring all of that here and just replacing; // the PLT32 relocation type with PC32, which will translate the relocation; // into a PC-relative call directly to the function. For external symbols we; // can't be sure the function will be within 2^32 bytes of the call site, so; // we need to create a stub, which calls into the GOT. This case is; // equivalent to the usual PLT implementation except that we use the stub; // mechanism in RuntimeDyld (which puts stubs at the end of the section); // rather than allocating a PLT section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:719,Testability,stub,stub,719,"// The way the PLT relocations normally work is that the linker allocates; // the; // PLT and this relocation makes a PC-relative call into the PLT. The PLT; // entry will then jump to an address provided by the GOT. On first call,; // the; // GOT address will point back into PLT code that resolves the symbol. After; // the first call, the GOT entry points to the actual function.; //; // For local functions we're ignoring all of that here and just replacing; // the PLT32 relocation type with PC32, which will translate the relocation; // into a PC-relative call directly to the function. For external symbols we; // can't be sure the function will be within 2^32 bytes of the call site, so; // we need to create a stub, which calls into the GOT. This case is; // equivalent to the usual PLT implementation except that we use the stub; // mechanism in RuntimeDyld (which puts stubs at the end of the section); // rather than allocating a PLT section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:834,Testability,stub,stub,834,"// The way the PLT relocations normally work is that the linker allocates; // the; // PLT and this relocation makes a PC-relative call into the PLT. The PLT; // entry will then jump to an address provided by the GOT. On first call,; // the; // GOT address will point back into PLT code that resolves the symbol. After; // the first call, the GOT entry points to the actual function.; //; // For local functions we're ignoring all of that here and just replacing; // the PLT32 relocation type with PC32, which will translate the relocation; // into a PC-relative call directly to the function. For external symbols we; // can't be sure the function will be within 2^32 bytes of the call site, so; // we need to create a stub, which calls into the GOT. This case is; // equivalent to the usual PLT implementation except that we use the stub; // mechanism in RuntimeDyld (which puts stubs at the end of the section); // rather than allocating a PLT section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:880,Testability,stub,stubs,880,"// The way the PLT relocations normally work is that the linker allocates; // the; // PLT and this relocation makes a PC-relative call into the PLT. The PLT; // entry will then jump to an address provided by the GOT. On first call,; // the; // GOT address will point back into PLT code that resolves the symbol. After; // the first call, the GOT entry points to the actual function.; //; // For local functions we're ignoring all of that here and just replacing; // the PLT32 relocation type with PC32, which will translate the relocation; // into a PC-relative call directly to the function. For external symbols we; // can't be sure the function will be within 2^32 bytes of the call site, so; // we need to create a stub, which calls into the GOT. This case is; // equivalent to the usual PLT implementation except that we use the stub; // mechanism in RuntimeDyld (which puts stubs at the end of the section); // rather than allocating a PLT section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:68,Testability,stub,stub,68,// This is a call to an external function.; // Look for an existing stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:16,Testability,stub,stub,16,// Create a new stub function (equivalent to a PLT entry).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:12,Testability,stub,stub,12,// Bump our stub offset counter,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a GOT Entry,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:7,Performance,load,load,7,// The load of the GOT address has an addend of -4,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:40,Testability,stub,stub,40,// Make the target call a call into the stub table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:40,Performance,Optimiz,Optimizations,40,"// Use the approach from ""x86-64 Linker Optimizations"" from the TLS spec; // to replace the GOTTPOFF relocation with a TPOFF relocation. The spec; // only mentions one optimization even though there are two different; // code sequences for the Initial Exec TLS Model. We match the code to; // find out which one was used.; // A possible TLS code sequence and its replacement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:168,Performance,optimiz,optimization,168,"// Use the approach from ""x86-64 Linker Optimizations"" from the TLS spec; // to replace the GOTTPOFF relocation with a TPOFF relocation. The spec; // only mentions one optimization even though there are two different; // code sequences for the Initial Exec TLS Model. We match the code to; // find out which one was used.; // A possible TLS code sequence and its replacement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:103,Performance,optimiz,optimize,103,"// The GOTTPOFF relocation was not used in one of the sequences; // described in the spec, so we can't optimize it to a TPOFF; // relocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:178,Performance,Optimiz,Optimizations,178,"// Since we are statically linking and have no additional DSOs, we can resolve; // the relocation directly without using __tls_get_addr.; // Use the approach from ""x86-64 Linker Optimizations"" from the TLS spec; // to replace it with the Local Exec relocation variant.; // Find out whether the code was compiled with the large or small memory; // model. For this we look at the next relocation which is the relocation; // for the __tls_get_addr function. If it's a 32 bit relocation, it's the; // small code model, with a 64 bit relocation it's the large code model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:31,Energy Efficiency,allocate,allocate,31,// Reserve a section id. We'll allocate the section later; // once we know the total size,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:58,Testability,stub,stub,58,// Fill in the relative address of the GOT Entry into the stub,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:31,Availability,error,error,31,// This should never return an error as `processNewSymbol` wouldn't have been; // called if getFlags() returned an error before.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:115,Availability,error,error,115,// This should never return an error as `processNewSymbol` wouldn't have been; // called if getFlags() returned an error before.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:71,Energy Efficiency,allocate,allocated,71,// Create a dummy section for the ifunc stubs. It will be actually; // allocated in finalizeLoad() below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:40,Testability,stub,stubs,40,// Create a dummy section for the ifunc stubs. It will be actually; // allocated in finalizeLoad() below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:52,Testability,stub,stub,52,// Modify the symbol so that it points to the ifunc stub instead of to the; // resolver function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:20,Testability,stub,stubs,20,"// Create the IFunc stubs if necessary. This must be done before processing; // the GOT entries, as the IFunc stubs may create some.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:110,Testability,stub,stubs,110,"// Create the IFunc stubs if necessary. This must be done before processing; // the GOT entries, as the IFunc stubs may create some.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:17,Energy Efficiency,allocate,allocate,17,"// If necessary, allocate the global offset table",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate memory for the section,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:326,Deployability,update,updated,326,"// The adddres of the GOT1 entry is in %r11, the GOT2 entry is in %r11+8; // (see createIFuncStub() for details); // The following code first saves all registers that contain the original; // function arguments as those registers are not saved by the resolver; // function. %r11 is saved as well so that the GOT2 entry can be updated; // afterwards. Then it calls the actual IFunc resolver function whose; // address is stored in GOT2. After the resolver function returns, all; // saved registers are restored and the return value is written to GOT1.; // Finally, jump to the now resolved function.; // clang-format off",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:354,Deployability,update,update,354,"// The first instruction loads a PC-relative address into %r11 which is a; // GOT entry for this stub. This initially contains the address to the; // IFunc resolver. We can use %r11 here as it's caller saved but not used; // to pass any arguments. In fact, x86_64 ABI even suggests using %r11 for; // code in the PLT. The IFunc resolver will use %r11 to update the GOT; // entry.; //; // The next instruction just jumps to the address contained in the GOT; // entry. As mentioned above, we do this two-step jump by first setting; // %r11 so that the IFunc resolver has access to it.; //; // The IFunc resolver of course also needs to know the actual address of; // the actual IFunc resolver function. This will be stored in a GOT entry; // right next to the first one for this stub. So, the IFunc resolver will; // be able to call it with %r11+8.; //; // In total, two adjacent GOT entries (+relocation) and one additional; // relocation are required:; // GOT1: Address of the IFunc resolver.; // GOT2: Address of the IFunc resolver function.; // IFuncStubOffset+3: 32-bit PC-relative address of GOT1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:25,Performance,load,loads,25,"// The first instruction loads a PC-relative address into %r11 which is a; // GOT entry for this stub. This initially contains the address to the; // IFunc resolver. We can use %r11 here as it's caller saved but not used; // to pass any arguments. In fact, x86_64 ABI even suggests using %r11 for; // code in the PLT. The IFunc resolver will use %r11 to update the GOT; // entry.; //; // The next instruction just jumps to the address contained in the GOT; // entry. As mentioned above, we do this two-step jump by first setting; // %r11 so that the IFunc resolver has access to it.; //; // The IFunc resolver of course also needs to know the actual address of; // the actual IFunc resolver function. This will be stored in a GOT entry; // right next to the first one for this stub. So, the IFunc resolver will; // be able to call it with %r11+8.; //; // In total, two adjacent GOT entries (+relocation) and one additional; // relocation are required:; // GOT1: Address of the IFunc resolver.; // GOT2: Address of the IFunc resolver function.; // IFuncStubOffset+3: 32-bit PC-relative address of GOT1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:569,Security,access,access,569,"// The first instruction loads a PC-relative address into %r11 which is a; // GOT entry for this stub. This initially contains the address to the; // IFunc resolver. We can use %r11 here as it's caller saved but not used; // to pass any arguments. In fact, x86_64 ABI even suggests using %r11 for; // code in the PLT. The IFunc resolver will use %r11 to update the GOT; // entry.; //; // The next instruction just jumps to the address contained in the GOT; // entry. As mentioned above, we do this two-step jump by first setting; // %r11 so that the IFunc resolver has access to it.; //; // The IFunc resolver of course also needs to know the actual address of; // the actual IFunc resolver function. This will be stored in a GOT entry; // right next to the first one for this stub. So, the IFunc resolver will; // be able to call it with %r11+8.; //; // In total, two adjacent GOT entries (+relocation) and one additional; // relocation are required:; // GOT1: Address of the IFunc resolver.; // GOT2: Address of the IFunc resolver function.; // IFuncStubOffset+3: 32-bit PC-relative address of GOT1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:97,Testability,stub,stub,97,"// The first instruction loads a PC-relative address into %r11 which is a; // GOT entry for this stub. This initially contains the address to the; // IFunc resolver. We can use %r11 here as it's caller saved but not used; // to pass any arguments. In fact, x86_64 ABI even suggests using %r11 for; // code in the PLT. The IFunc resolver will use %r11 to update the GOT; // entry.; //; // The next instruction just jumps to the address contained in the GOT; // entry. As mentioned above, we do this two-step jump by first setting; // %r11 so that the IFunc resolver has access to it.; //; // The IFunc resolver of course also needs to know the actual address of; // the actual IFunc resolver function. This will be stored in a GOT entry; // right next to the first one for this stub. So, the IFunc resolver will; // be able to call it with %r11+8.; //; // In total, two adjacent GOT entries (+relocation) and one additional; // relocation are required:; // GOT1: Address of the IFunc resolver.; // GOT2: Address of the IFunc resolver function.; // IFuncStubOffset+3: 32-bit PC-relative address of GOT1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:777,Testability,stub,stub,777,"// The first instruction loads a PC-relative address into %r11 which is a; // GOT entry for this stub. This initially contains the address to the; // IFunc resolver. We can use %r11 here as it's caller saved but not used; // to pass any arguments. In fact, x86_64 ABI even suggests using %r11 for; // code in the PLT. The IFunc resolver will use %r11 to update the GOT; // entry.; //; // The next instruction just jumps to the address contained in the GOT; // entry. As mentioned above, we do this two-step jump by first setting; // %r11 so that the IFunc resolver has access to it.; //; // The IFunc resolver of course also needs to know the actual address of; // the actual IFunc resolver function. This will be stored in a GOT entry; // right next to the first one for this stub. So, the IFunc resolver will; // be able to call it with %r11+8.; //; // In total, two adjacent GOT entries (+relocation) and one additional; // relocation are required:; // GOT1: Address of the IFunc resolver.; // GOT2: Address of the IFunc resolver function.; // IFuncStubOffset+3: 32-bit PC-relative address of GOT1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:87,Modifiability,extend,extended,87,// We know that these reloation types won't need a stub function. This list; // can be extended as needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:51,Testability,stub,stub,51,// We know that these reloation types won't need a stub function. This list; // can be extended as needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h:3,Energy Efficiency,Allocate,Allocate,3,// Allocate no GOT entries for use in the given section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h:33,Energy Efficiency,allocate,allocated,33,// Records the current number of allocated slots in the GOT; // (This would be equivalent to GOTEntries.size() were it not for relocations; // that consume more than one slot),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h:12,Safety,avoid,avoid,12,// A map to avoid duplicate got entries (Mips64 specific),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h:20,Performance,load,loaded,20,// When a module is loaded we save the SectionID of the EH frame section; // in a table until we receive a request to register all unregistered; // EH frame sections with the memory manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h:32,Testability,stub,stub,32,/// The ID of the current IFunc stub section,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h:38,Testability,stub,stub,38,/// The current offset into the IFunc stub section,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h:12,Testability,stub,stub,12,/// A IFunc stub and its original symbol,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h:23,Testability,stub,stub,23,/// The offset of this stub in the IFunc stub section,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h:41,Testability,stub,stub,41,/// The offset of this stub in the IFunc stub section,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h:14,Testability,stub,stubs,14,/// The IFunc stubs,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h:104,Testability,stub,stubs,104,/// Create the code for the IFunc resolver at the given address. This code; /// works together with the stubs created in createIFuncStub() to call the; /// resolver function and then jump to the real function address.; /// It must not be larger than 64B.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h:33,Testability,stub,stub,33,/// Create the code for an IFunc stub for the IFunc that is defined in; /// section IFuncSectionID at offset IFuncOffset. The IFunc resolver created; /// by createIFuncResolver() is defined in the section IFuncStubSectionID at; /// offset IFuncResolverOffset. The code should be written into the section; /// with the id IFuncStubSectionID at the offset IFuncStubOffset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h:33,Testability,stub,stub,33,/// Return the maximum size of a stub created by createIFuncStub(),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:383,Integrability,Interface,Interface,383,"//===-- RuntimeDyldImpl.h - Run-time dynamic linker for MC-JIT --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Interface for the implementations of runtime dynamic linker facilities.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:45,Testability,stub,stubs,45,/// Size - section size. Doesn't include the stubs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:4,Performance,Load,LoadAddress,4,"/// LoadAddress - the address of the section in the target process's memory.; /// Used for situations in which JIT-ed code is being executed in the address; /// space of a separate process. If the code executes in the same address; /// space where it was JIT-ed, this just equals Address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:4,Testability,Stub,StubOffset,4,/// StubOffset - used for architectures with stub functions for far; /// relocations (like ARM).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:45,Testability,stub,stub,45,/// StubOffset - used for architectures with stub functions for far; /// relocations (like ARM).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:30,Energy Efficiency,allocate,allocated,30,/// The total amount of space allocated for this section. This includes the; /// section size and the maximum amount of space that the stubs can occupy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:135,Testability,stub,stubs,135,/// The total amount of space allocated for this section. This includes the; /// section size and the maximum amount of space that the stubs can occupy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:34,Testability,assert,asserts,34,"// AllocationSize is used only in asserts, prevent an ""unused private field""; // warning:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:15,Performance,load,load,15,/// Return the load address of this section with an offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:24,Performance,load,load,24,// The MemoryManager to load objects into.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:46,Performance,load,loaded,46,// A global symbol table for symbols from all loaded modules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:35,Performance,load,loaded,35,// Relocations to sections already loaded. Indexed by SectionID which is the; // source of the address. The target where the address will be written is; // SectionID/Offset in the relocation itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:144,Performance,load,loaded,144,// Relocations to external symbols that are not yet resolved. Symbols are; // external when they aren't found in the global symbol table of all loaded; // modules. This map is indexed by symbol name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:38,Performance,load,loading,38,"// This mutex prevents simultaneously loading objects from two different; // threads. This keeps us from having to protect individual data structures; // and guarantees that section allocation requests to the memory manager; // won't be interleaved between modules. It is also used in mapSectionAddress; // and resolveRelocations to protect write access to internal data structures.; //; // loadObject may be called on the same thread during the handling of; // processRelocations, and that's OK. The handling of the relocation lists; // is written in such a way as to work correctly if new elements are added to; // the end of the list while the list is being processed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:391,Performance,load,loadObject,391,"// This mutex prevents simultaneously loading objects from two different; // threads. This keeps us from having to protect individual data structures; // and guarantees that section allocation requests to the memory manager; // won't be interleaved between modules. It is also used in mapSectionAddress; // and resolveRelocations to protect write access to internal data structures.; //; // loadObject may be called on the same thread during the handling of; // processRelocations, and that's OK. The handling of the relocation lists; // is written in such a way as to work correctly if new elements are added to; // the end of the list while the list is being processed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:347,Security,access,access,347,"// This mutex prevents simultaneously loading objects from two different; // threads. This keeps us from having to protect individual data structures; // and guarantees that section allocation requests to the memory manager; // won't be interleaved between modules. It is also used in mapSectionAddress; // and resolveRelocations to protect write access to internal data structures.; //; // loadObject may be called on the same thread during the handling of; // processRelocations, and that's OK. The handling of the relocation lists; // is written in such a way as to work correctly if new elements are added to; // the end of the list while the list is being processed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:97,Deployability,update,update,97,"/// Given the common symbols discovered in the object file, emit a; /// new section for them and update the symbol mappings in the object and; /// symbol table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:103,Energy Efficiency,allocate,allocateCodeSection,103,"/// Emits section data from the object file to the MemoryManager.; /// \param IsCode if it's true then allocateCodeSection() will be; /// used for emits, else allocateDataSection() will be used.; /// \return SectionID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:159,Energy Efficiency,allocate,allocateDataSection,159,"/// Emits section data from the object file to the MemoryManager.; /// \param IsCode if it's true then allocateCodeSection() will be; /// used for emits, else allocateDataSection() will be used.; /// \return SectionID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:142,Energy Efficiency,allocate,allocateCodeSection,142,"/// Find Section in LocalSections. If the secton is not found - emit; /// it and store in LocalSections.; /// \param IsCode if it's true then allocateCodeSection() will be; /// used for emmits, else allocateDataSection() will be used.; /// \return SectionID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:199,Energy Efficiency,allocate,allocateDataSection,199,"/// Find Section in LocalSections. If the secton is not found - emit; /// it and store in LocalSections.; /// \param IsCode if it's true then allocateCodeSection() will be; /// used for emmits, else allocateDataSection() will be used.; /// \return SectionID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:154,Integrability,depend,depends,154,/// Parses one or more object file relocations (some object files use; /// relocation pairs) and stores it to Relocations or SymbolRelocations; /// (this depends on the object file type).; /// \return Iterator to the next relocation that needs to be parsed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:60,Performance,load,load,60,// Compute an upper bound of the memory that is required to load all; // sections,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:15,Testability,stub,stub,15,// Compute the stub buffer size required for a section,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:45,Performance,load,loadObject,45,// Implementation of the generic part of the loadObject algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:60,Testability,stub,stub,60,// Return true if the relocation R may require allocating a stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:53,Usability,simpl,simple,53,// FIXME: Just look up as a function for now. Overly simple of course.; // Work in progress.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:53,Usability,simpl,simple,53,// FIXME: Just look up as a function for now. Overly simple of course.; // Work in progress.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:23,Availability,error,error,23,// Is the linker in an error state?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:12,Availability,error,error,12,// Mark the error condition as handled and continue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:11,Availability,error,error,11,// Get the error message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:17,Integrability,message,message,17,// Get the error message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldMachO.cpp:114,Availability,down,down,114,"// Force emission of the __text, __eh_frame, and __gcc_except_tab sections; // if they're present. Otherwise call down to the impl to handle other; // sections that have already been emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldMachO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldMachO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldMachO.h:20,Performance,load,loaded,20,// When a module is loaded we save the SectionID of the EH frame section; // in a table until we receive a request to register all unregistered; // EH frame sections with the memory manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldMachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldMachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldMachO.h:263,Usability,simpl,simple,263,"/// Given a relocation_iterator for a non-scattered relocation, construct a; /// RelocationEntry and fill in the common fields. The 'Addend' field is *not*; /// filled in, since immediate encodings are highly target/opcode specific.; /// For targets/opcodes with simple, contiguous immediates (e.g. X86) the; /// memcpyAddend method can be used to read the immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldMachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldMachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldMachO.h:167,Security,access,accessed,167,"/// RuntimeDyldMachOTarget - Templated base class for generic MachO linker; /// algorithms and data structures.; ///; /// Concrete, target specific sub-classes can be accessed via the impl(); /// methods. (i.e. the RuntimeDyldMachO hierarchy uses the Curiously; /// Recurring Template Idiom). Concrete subclasses for each target; /// can be found in ./Targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldMachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldMachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h:85,Testability,Stub,Stub,85,// This relocation type is used for handling long branch instruction; // through the Stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h:20,Performance,load,loaded,20,// When a module is loaded we save the SectionID of the unwind; // sections in a table until we receive a request to register all; // unregisteredEH frame sections with the memory manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h:55,Performance,load,loaded,55,"// The Sections list may contain sections that weren't loaded for; // whatever reason: they may be debug sections, and ProcessAllSections; // is false, or they may be sections that contain 0 bytes. If the; // section isn't loaded, the load address will be 0, and it should not; // be included in the ImageBase calculation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h:223,Performance,load,loaded,223,"// The Sections list may contain sections that weren't loaded for; // whatever reason: they may be debug sections, and ProcessAllSections; // is false, or they may be sections that contain 0 bytes. If the; // section isn't loaded, the load address will be 0, and it should not; // be included in the ImageBase calculation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h:235,Performance,load,load,235,"// The Sections list may contain sections that weren't loaded for; // whatever reason: they may be debug sections, and ProcessAllSections; // is false, or they may be sections that contain 0 bytes. If the; // section isn't loaded, the load address will be 0, and it should not; // be included in the ImageBase calculation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h:34,Testability,stub,stub,34,// Resolve original relocation to stub function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h:54,Testability,stub,stub,54,// adjust relocation info so resolution writes to the stub function; // Here an internal relocation type is used for resolving long branch via; // stub instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h:147,Testability,stub,stub,147,// adjust relocation info so resolution writes to the stub function; // Here an internal relocation type is used for resolving long branch via; // stub instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h:44,Testability,Stub,Stub,44,// Encode the immadiate value for generated Stub instruction (MOVZ),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFAArch64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFThumb.h:10,Performance,load,load,10,"// 8-byte load instructions, 4-byte jump, 4-byte padding",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFThumb.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFThumb.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h:20,Performance,load,loaded,20,// When a module is loaded we save the SectionID of the unwind; // sections in a table until we receive a request to register all; // unregisteredEH frame sections with the memory manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h:55,Performance,load,loaded,55,"// The Sections list may contain sections that weren't loaded for; // whatever reason: they may be debug sections, and ProcessAllSections; // is false, or they may be sections that contain 0 bytes. If the; // section isn't loaded, the load address will be 0, and it should not; // be included in the ImageBase calculation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h:223,Performance,load,loaded,223,"// The Sections list may contain sections that weren't loaded for; // whatever reason: they may be debug sections, and ProcessAllSections; // is false, or they may be sections that contain 0 bytes. If the; // section isn't loaded, the load address will be 0, and it should not; // be included in the ImageBase calculation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h:235,Performance,load,load,235,"// The Sections list may contain sections that weren't loaded for; // whatever reason: they may be debug sections, and ProcessAllSections; // is false, or they may be sections that contain 0 bytes. If the; // section isn't loaded, the load address will be 0, and it should not; // be included in the ImageBase calculation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h:277,Performance,load,loaded,277,"// The target location for the relocation is described by RE.SectionID and; // RE.Offset. RE.SectionID can be used to find the SectionEntry. Each; // SectionEntry has three members describing its location.; // SectionEntry::Address is the address at which the section has been loaded; // into memory in the current (host) process. SectionEntry::LoadAddress is; // the address that the section will have in the target process.; // SectionEntry::ObjAddress is the address of the bits for this section in the; // original emitted object image (also in the current address space).; //; // Relocations will be applied as if the section were loaded at; // SectionEntry::LoadAddress, but they will be applied at an address based; // on SectionEntry::Address. SectionEntry::ObjAddress will be used to refer; // to Target memory contents if they are required for value calculations.; //; // The Value parameter here is the load address of the symbol for the; // relocation to be applied. For relocations which refer to symbols in the; // current object Value will be the LoadAddress of the section in which; // the symbol resides (RE.Addend provides additional information about the; // symbol location). For external symbols, Value will be the address of the; // symbol in the target address space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h:345,Performance,Load,LoadAddress,345,"// The target location for the relocation is described by RE.SectionID and; // RE.Offset. RE.SectionID can be used to find the SectionEntry. Each; // SectionEntry has three members describing its location.; // SectionEntry::Address is the address at which the section has been loaded; // into memory in the current (host) process. SectionEntry::LoadAddress is; // the address that the section will have in the target process.; // SectionEntry::ObjAddress is the address of the bits for this section in the; // original emitted object image (also in the current address space).; //; // Relocations will be applied as if the section were loaded at; // SectionEntry::LoadAddress, but they will be applied at an address based; // on SectionEntry::Address. SectionEntry::ObjAddress will be used to refer; // to Target memory contents if they are required for value calculations.; //; // The Value parameter here is the load address of the symbol for the; // relocation to be applied. For relocations which refer to symbols in the; // current object Value will be the LoadAddress of the section in which; // the symbol resides (RE.Addend provides additional information about the; // symbol location). For external symbols, Value will be the address of the; // symbol in the target address space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h:636,Performance,load,loaded,636,"// The target location for the relocation is described by RE.SectionID and; // RE.Offset. RE.SectionID can be used to find the SectionEntry. Each; // SectionEntry has three members describing its location.; // SectionEntry::Address is the address at which the section has been loaded; // into memory in the current (host) process. SectionEntry::LoadAddress is; // the address that the section will have in the target process.; // SectionEntry::ObjAddress is the address of the bits for this section in the; // original emitted object image (also in the current address space).; //; // Relocations will be applied as if the section were loaded at; // SectionEntry::LoadAddress, but they will be applied at an address based; // on SectionEntry::Address. SectionEntry::ObjAddress will be used to refer; // to Target memory contents if they are required for value calculations.; //; // The Value parameter here is the load address of the symbol for the; // relocation to be applied. For relocations which refer to symbols in the; // current object Value will be the LoadAddress of the section in which; // the symbol resides (RE.Addend provides additional information about the; // symbol location). For external symbols, Value will be the address of the; // symbol in the target address space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h:664,Performance,Load,LoadAddress,664,"// The target location for the relocation is described by RE.SectionID and; // RE.Offset. RE.SectionID can be used to find the SectionEntry. Each; // SectionEntry has three members describing its location.; // SectionEntry::Address is the address at which the section has been loaded; // into memory in the current (host) process. SectionEntry::LoadAddress is; // the address that the section will have in the target process.; // SectionEntry::ObjAddress is the address of the bits for this section in the; // original emitted object image (also in the current address space).; //; // Relocations will be applied as if the section were loaded at; // SectionEntry::LoadAddress, but they will be applied at an address based; // on SectionEntry::Address. SectionEntry::ObjAddress will be used to refer; // to Target memory contents if they are required for value calculations.; //; // The Value parameter here is the load address of the symbol for the; // relocation to be applied. For relocations which refer to symbols in the; // current object Value will be the LoadAddress of the section in which; // the symbol resides (RE.Addend provides additional information about the; // symbol location). For external symbols, Value will be the address of the; // symbol in the target address space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h:914,Performance,load,load,914,"// The target location for the relocation is described by RE.SectionID and; // RE.Offset. RE.SectionID can be used to find the SectionEntry. Each; // SectionEntry has three members describing its location.; // SectionEntry::Address is the address at which the section has been loaded; // into memory in the current (host) process. SectionEntry::LoadAddress is; // the address that the section will have in the target process.; // SectionEntry::ObjAddress is the address of the bits for this section in the; // original emitted object image (also in the current address space).; //; // Relocations will be applied as if the section were loaded at; // SectionEntry::LoadAddress, but they will be applied at an address based; // on SectionEntry::Address. SectionEntry::ObjAddress will be used to refer; // to Target memory contents if they are required for value calculations.; //; // The Value parameter here is the load address of the symbol for the; // relocation to be applied. For relocations which refer to symbols in the; // current object Value will be the LoadAddress of the section in which; // the symbol resides (RE.Addend provides additional information about the; // symbol location). For external symbols, Value will be the address of the; // symbol in the target address space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h:1062,Performance,Load,LoadAddress,1062,"// The target location for the relocation is described by RE.SectionID and; // RE.Offset. RE.SectionID can be used to find the SectionEntry. Each; // SectionEntry has three members describing its location.; // SectionEntry::Address is the address at which the section has been loaded; // into memory in the current (host) process. SectionEntry::LoadAddress is; // the address that the section will have in the target process.; // SectionEntry::ObjAddress is the address of the bits for this section in the; // original emitted object image (also in the current address space).; //; // Relocations will be applied as if the section were loaded at; // SectionEntry::LoadAddress, but they will be applied at an address based; // on SectionEntry::Address. SectionEntry::ObjAddress will be used to refer; // to Target memory contents if they are required for value calculations.; //; // The Value parameter here is the load address of the symbol for the; // relocation to be applied. For relocations which refer to symbols in the; // current object Value will be the LoadAddress of the section in which; // the symbol resides (RE.Addend provides additional information about the; // symbol location). For external symbols, Value will be the address of the; // symbol in the target address space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h:139,Testability,stub,stub,139,"// FIXME: If RelType == COFF::IMAGE_REL_AMD64_ADDR32NB we should be able; // to ignore the __ImageBase requirement and just forward to the stub; // directly as an offset of this section:; // write32BitOffset(Section.getAddressWithOffset(Offset), 0, StubOffset);; // .xdata exception handler's aren't having this though.; // Resolve original relocation to stub function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h:249,Testability,Stub,StubOffset,249,"// FIXME: If RelType == COFF::IMAGE_REL_AMD64_ADDR32NB we should be able; // to ignore the __ImageBase requirement and just forward to the stub; // directly as an offset of this section:; // write32BitOffset(Section.getAddressWithOffset(Offset), 0, StubOffset);; // .xdata exception handler's aren't having this though.; // Resolve original relocation to stub function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h:355,Testability,stub,stub,355,"// FIXME: If RelType == COFF::IMAGE_REL_AMD64_ADDR32NB we should be able; // to ignore the __ImageBase requirement and just forward to the stub; // directly as an offset of this section:; // write32BitOffset(Section.getAddressWithOffset(Offset), 0, StubOffset);; // .xdata exception handler's aren't having this though.; // Resolve original relocation to stub function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h:54,Testability,stub,stub,54,// adjust relocation info so resolution writes to the stub function,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldCOFFX86_64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h:68,Modifiability,extend,extend,68,// Get the 26 bit addend encoded in the branch instruction and sign-extend; // to 64 bit. The lower 2 bits are always zeros and are therefore implicit; // (<< 2).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h:66,Modifiability,extend,extend,66,// Get the 21 bit addend encoded in the adrp instruction and sign-extend; // to 64 bit. The lower 12 bits (4096 byte page) are always zeros and are; // therefore implicit (<< 12).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h:60,Performance,load,load,60,// Verify that the relocation points to one of the expected load / store; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h:60,Performance,load,load,60,// Verify that the relocation points to one of the expected load / store; // or add / sub instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h:6,Performance,load,load,6,// << load / store; // For load / store instructions the size is encoded in bits 31:30.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h:27,Performance,load,load,27,// << load / store; // For load / store instructions the size is encoded in bits 31:30.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h:60,Performance,load,load,60,// Verify that the relocation points to one of the expected load / store; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h:60,Performance,load,load,60,// Verify that the relocation points to one of the expected load / store; // or add / sub instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h:6,Performance,load,load,6,// << load / store; // For load / store instructions the size is encoded in bits 31:30.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h:27,Performance,load,load,27,// << load / store; // For load / store instructions the size is encoded in bits 31:30.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h:8,Modifiability,extend,extend,8,// Sign-extend the 24-bit to 64-bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h:3,Availability,Mask,Mask,3,"// Mask in the target value a byte at a time (we don't have an alignment; // guarantee for the target address, so this is safest).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h:122,Safety,safe,safest,122,"// Mask in the target value a byte at a time (we don't have an alignment; // guarantee for the target address, so this is safest).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h:3,Availability,Mask,Mask,3,// Mask out the page address and only use the lower 12 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h:3,Availability,Mask,Mask,3,"// Mask out the opcode.; // Now we've got the shifted immediate, shift by 2, sign extend and ret.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h:82,Modifiability,extend,extend,82,"// Mask out the opcode.; // Now we've got the shifted immediate, shift by 2, sign extend and ret.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h:3,Security,Validat,Validate,3,// Validate the relocation type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h:106,Testability,stub,stub,106,// If this is a branch from a thumb function (BR22) then make sure we mark; // the value as being a thumb stub: we don't want to mix it up with an ARM; // stub targeting the same function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h:155,Testability,stub,stub,155,// If this is a branch from a thumb function (BR22) then make sure we mark; // the value as being a thumb stub: we don't want to mix it up with an ARM; // stub targeting the same function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h:3,Availability,Mask,Mask,3,"// Mask the value into the target address. We know instructions are; // 32-bit aligned, so we can do it all at once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h:3,Availability,Mask,Mask,3,// Mask the value to 24 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h:51,Testability,stub,stub,51,"// This is an ARM branch relocation, need to use a stub function.; // Look up for existing stub.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h:91,Testability,stub,stub,91,"// This is an ARM branch relocation, need to use a stub function.; // Look up for existing stub.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h:16,Testability,stub,stub,16,// Create a new stub function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOI386.h:185,Testability,log,logic,185,"// Addends for external, PC-rel relocations on i386 point back to the zero; // offset. Calculate the final offset from the relocation target instead.; // This allows us to use the same logic for both external and internal; // relocations in resolveI386RelocationRef.; // bool IsExtern = Obj.getPlainRelocationExternal(RelInfo);; // if (IsExtern && RE.IsPCRel) {; // uint64_t RelocAddr = 0;; // RelI->getAddress(RelocAddr);; // Value.Addend += RelocAddr + 4;; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOI386.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOI386.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOI386.h:12,Testability,stub,stubs,12,// Populate stubs in __jump_table section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOI386.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOI386.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:434,Security,validat,validates,434,"//===- FileCheck.cpp - Check that File's Contents match what is expected --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // FileCheck does a line-by line check of a file that validates whether it; // contains the expected content. This is useful for regression tests etc.; //; // This file implements most of the API that will be used by the FileCheck utility; // as well as various unittests.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:520,Testability,test,tests,520,"//===- FileCheck.cpp - Check that File's Contents match what is expected --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // FileCheck does a line-by line check of a file that validates whether it; // contains the expected content. This is useful for regression tests etc.; //; // This file implements most of the API that will be used by the FileCheck utility; // as well as various unittests.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:17,Availability,error,error,17,// Bubble up any error (e.g. undefined variables) in the recursive; // evaluation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:39,Modifiability,variab,variables,39,// Bubble up any error (e.g. undefined variables) in the recursive; // evaluation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:3,Modifiability,Variab,Variable,3,// Variable names are composed of alphanumeric characters and underscores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:48,Modifiability,variab,variables,48,// Detect collisions between string and numeric variables when the latter; // is created later than the former.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:3,Safety,Detect,Detect,3,// Detect collisions between string and numeric variables when the latter; // is created later than the former.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:11,Modifiability,variab,variable,11,"// Numeric variable definitions and uses are parsed in the order in which; // they appear in the CHECK patterns. For each definition, the pointer to the; // class instance of the corresponding numeric variable definition is stored; // in GlobalNumericVariableTable in parsePattern. Therefore, if the pointer; // we get below is null, it means no such variable was defined before. When; // that happens, we create a dummy variable so that parsing can continue. All; // uses of undefined variables, whether string or numeric, are then diagnosed; // in printNoMatch() after failing to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:201,Modifiability,variab,variable,201,"// Numeric variable definitions and uses are parsed in the order in which; // they appear in the CHECK patterns. For each definition, the pointer to the; // class instance of the corresponding numeric variable definition is stored; // in GlobalNumericVariableTable in parsePattern. Therefore, if the pointer; // we get below is null, it means no such variable was defined before. When; // that happens, we create a dummy variable so that parsing can continue. All; // uses of undefined variables, whether string or numeric, are then diagnosed; // in printNoMatch() after failing to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:351,Modifiability,variab,variable,351,"// Numeric variable definitions and uses are parsed in the order in which; // they appear in the CHECK patterns. For each definition, the pointer to the; // class instance of the corresponding numeric variable definition is stored; // in GlobalNumericVariableTable in parsePattern. Therefore, if the pointer; // we get below is null, it means no such variable was defined before. When; // that happens, we create a dummy variable so that parsing can continue. All; // uses of undefined variables, whether string or numeric, are then diagnosed; // in printNoMatch() after failing to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:421,Modifiability,variab,variable,421,"// Numeric variable definitions and uses are parsed in the order in which; // they appear in the CHECK patterns. For each definition, the pointer to the; // class instance of the corresponding numeric variable definition is stored; // in GlobalNumericVariableTable in parsePattern. Therefore, if the pointer; // we get below is null, it means no such variable was defined before. When; // that happens, we create a dummy variable so that parsing can continue. All; // uses of undefined variables, whether string or numeric, are then diagnosed; // in printNoMatch() after failing to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:486,Modifiability,variab,variables,486,"// Numeric variable definitions and uses are parsed in the order in which; // they appear in the CHECK patterns. For each definition, the pointer to the; // class instance of the corresponding numeric variable definition is stored; // in GlobalNumericVariableTable in parsePattern. Therefore, if the pointer; // we get below is null, it means no such variable was defined before. When; // that happens, we create a dummy variable so that parsing can continue. All; // uses of undefined variables, whether string or numeric, are then diagnosed; // in printNoMatch() after failing to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:29,Modifiability,variab,variable,29,// Try to parse as a numeric variable use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:14,Availability,error,error,14,// Ignore the error and retry parsing as a literal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:67,Performance,perform,perform,67,// Check if this is a supported operation and select a function to perform; // it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:24,Availability,error,error,24,// Prefer an expression error over a generic invalid argument message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:62,Integrability,message,message,62,// Prefer an expression error over a generic invalid argument message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:22,Availability,avail,available,22,// Have we parsed all available arguments?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:8,Modifiability,variab,variable,8,// Save variable definition expression if any.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:81,Modifiability,variab,variable,81,// The first operand in a legacy @LINE expression is always the @LINE; // pseudo variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:173,Availability,Error,Error,173,"// Select format of the expression, i.e. (i) its explicit format, if any,; // otherwise (ii) its implicit format, if any, otherwise (iii) the default; // format (unsigned). Error out in case of conflicting implicit format; // without explicit format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:21,Modifiability,variab,variable,21,// Parse the numeric variable definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:636,Availability,error,errors,636,"// String and numeric substitution blocks. Pattern substitution blocks come; // in two forms: [[foo:.*]] and [[foo]]. The former matches .* (or some; // other regex) and assigns it to the string variable 'foo'. The latter; // substitutes foo's value. Numeric substitution blocks recognize the same; // form as string ones, but start with a '#' sign after the double; // brackets. They also accept a combined form which sets a numeric variable; // to the evaluation of an expression. Both string and numeric variable; // names must satisfy the regular expression ""[a-zA-Z_][0-9a-zA-Z_]*"" to be; // valid, as this helps catch some common errors. If there are extra '['s; // before the ""[["", treat them literally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:195,Modifiability,variab,variable,195,"// String and numeric substitution blocks. Pattern substitution blocks come; // in two forms: [[foo:.*]] and [[foo]]. The former matches .* (or some; // other regex) and assigns it to the string variable 'foo'. The latter; // substitutes foo's value. Numeric substitution blocks recognize the same; // form as string ones, but start with a '#' sign after the double; // brackets. They also accept a combined form which sets a numeric variable; // to the evaluation of an expression. Both string and numeric variable; // names must satisfy the regular expression ""[a-zA-Z_][0-9a-zA-Z_]*"" to be; // valid, as this helps catch some common errors. If there are extra '['s; // before the ""[["", treat them literally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:434,Modifiability,variab,variable,434,"// String and numeric substitution blocks. Pattern substitution blocks come; // in two forms: [[foo:.*]] and [[foo]]. The former matches .* (or some; // other regex) and assigns it to the string variable 'foo'. The latter; // substitutes foo's value. Numeric substitution blocks recognize the same; // form as string ones, but start with a '#' sign after the double; // brackets. They also accept a combined form which sets a numeric variable; // to the evaluation of an expression. Both string and numeric variable; // names must satisfy the regular expression ""[a-zA-Z_][0-9a-zA-Z_]*"" to be; // valid, as this helps catch some common errors. If there are extra '['s; // before the ""[["", treat them literally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:507,Modifiability,variab,variable,507,"// String and numeric substitution blocks. Pattern substitution blocks come; // in two forms: [[foo:.*]] and [[foo]]. The former matches .* (or some; // other regex) and assigns it to the string variable 'foo'. The latter; // substitutes foo's value. Numeric substitution blocks recognize the same; // form as string ones, but start with a '#' sign after the double; // brackets. They also accept a combined form which sets a numeric variable; // to the evaluation of an expression. Both string and numeric variable; // names must satisfy the regular expression ""[a-zA-Z_][0-9a-zA-Z_]*"" to be; // valid, as this helps catch some common errors. If there are extra '['s; // before the ""[["", treat them literally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:16,Modifiability,variab,variable,16,// Parse string variable or legacy @LINE expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:48,Modifiability,variab,variables,48,// Detect collisions between string and numeric variables when the; // former is created later than the latter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:3,Safety,Detect,Detect,3,// Detect collisions between string and numeric variables when the; // former is created later than the latter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:10,Modifiability,variab,variable,10,// Handle variable definition: [[<def>:(...)]] and [[#(...)<def>:(...)]].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:147,Modifiability,variab,variable,147,// This store is done here rather than in match() to allow; // parseNumericVariableUse() to get the pointer to the class instance; // of the right variable definition corresponding to a given numeric; // variable use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:204,Modifiability,variab,variable,204,// This store is done here rather than in match() to allow; // parseNumericVariableUse() to get the pointer to the class instance; // of the right variable definition corresponding to a given numeric; // variable use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:15,Modifiability,variab,variable,15,// Mark string variable as defined to detect collisions between; // string and numeric variables in parseNumericVariableUse() and; // defineCmdlineVariables() when the latter is created later than the; // former. We cannot reuse GlobalVariableTable for this by populating; // it with an empty string since we would then lose the ability to; // detect the use of an undefined variable in match().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:87,Modifiability,variab,variables,87,// Mark string variable as defined to detect collisions between; // string and numeric variables in parseNumericVariableUse() and; // defineCmdlineVariables() when the latter is created later than the; // former. We cannot reuse GlobalVariableTable for this by populating; // it with an empty string since we would then lose the ability to; // detect the use of an undefined variable in match().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:375,Modifiability,variab,variable,375,// Mark string variable as defined to detect collisions between; // string and numeric variables in parseNumericVariableUse() and; // defineCmdlineVariables() when the latter is created later than the; // former. We cannot reuse GlobalVariableTable for this by populating; // it with an empty string since we would then lose the ability to; // detect the use of an undefined variable in match().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:38,Safety,detect,detect,38,// Mark string variable as defined to detect collisions between; // string and numeric variables in parseNumericVariableUse() and; // defineCmdlineVariables() when the latter is created later than the; // former. We cannot reuse GlobalVariableTable for this by populating; // it with an empty string since we would then lose the ability to; // detect the use of an undefined variable in match().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:344,Safety,detect,detect,344,// Mark string variable as defined to detect collisions between; // string and numeric variables in parseNumericVariableUse() and; // defineCmdlineVariables() when the latter is created later than the; // former. We cannot reuse GlobalVariableTable for this by populating; // it with an empty string since we would then lose the ability to; // detect the use of an undefined variable in match().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:33,Modifiability,variab,variables,33,// Handle substitution of string variables that were defined earlier on; // the same line by emitting a backreference. Expressions do not; // support substituting a numeric variable defined on the same line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:173,Modifiability,variab,variable,173,// Handle substitution of string variables that were defined earlier on; // the same line by emitting a backreference. Expressions do not; // support substituting a numeric variable defined on the same line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:33,Modifiability,variab,variables,33,"// Handle substitution of string variables ([[<var>]]) defined in; // previous CHECK patterns, and substitution of expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:25,Modifiability,variab,variables,25,// Substitute all string variables and expressions whose values are only; // now known. Use of string variables defined on the same line are handled; // by back-references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:102,Modifiability,variab,variables,102,// Substitute all string variables and expressions whose values are only; // now known. Use of string variables defined on the same line are handled; // by back-references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:28,Availability,failure,failure,28,// Substitute and check for failure (e.g. use of undefined variable).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:59,Modifiability,variab,variable,59,// Substitute and check for failure (e.g. use of undefined variable).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:17,Availability,Error,ErrorDiagnostic,17,// Convert to an ErrorDiagnostic to get location information. This is; // done here rather than printMatch/printNoMatch since now we know which; // substitution block caused the overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:30,Modifiability,variab,variables,30,"// If this defines any string variables, remember their values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:31,Modifiability,variab,variables,31,"// If this defines any numeric variables, remember their values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:16,Availability,failure,failures,16,// Substitution failures are handled in printNoMatch().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:17,Modifiability,variab,variable,17,// Build list of variable captures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:8,Modifiability,variab,variable,8,"// Sort variable captures by the order in which they matched the input.; // Ranges shouldn't be overlapping, so we can just compare the start.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:60,Availability,error,error,60,"// Attempt to find the closest/best fuzzy match. Usually an error happens; // because some string in the output didn't exactly match. In these cases, we; // would like to show the user a best guess at what ""should have"" matched, to; // save them having to actually check the input manually.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:111,Usability,simpl,simple,111,"// FIXME: If we wanted to be really friendly we would show why the match; // failed, as it can be hard to spot simple one character differences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:3,Availability,Error,Error,3,// Error happened in parsing integer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:624,Availability,failure,failure,624,"/// Searches the buffer for the first prefix in the prefix regular expression.; ///; /// This searches the buffer using the provided regular expression, however it; /// enforces constraints beyond that:; /// 1) The found prefix must not be a suffix of something that looks like; /// a valid prefix.; /// 2) The found prefix must be followed by a valid check type suffix using \c; /// FindCheckType above.; ///; /// \returns a pair of StringRefs into the Buffer, which combines:; /// - the first match of the regular expression to satisfy these two is; /// returned,; /// otherwise an empty StringRef is returned to indicate failure.; /// - buffer rewound to the location right after parsed suffix, for parsing; /// to continue from; ///; /// If this routine returns a valid prefix, it will also shrink \p Buffer to; /// start at the beginning of the returned prefix, increment \p LineNumber for; /// each new line consumed from \p Buffer, and set \p CheckTy to the type of; /// check found by examining the suffix.; ///; /// If no valid prefix is found, the state of Buffer, LineNumber, and CheckTy; /// is unspecified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:750,Integrability,rout,routine,750,"/// Searches the buffer for the first prefix in the prefix regular expression.; ///; /// This searches the buffer using the provided regular expression, however it; /// enforces constraints beyond that:; /// 1) The found prefix must not be a suffix of something that looks like; /// a valid prefix.; /// 2) The found prefix must be followed by a valid check type suffix using \c; /// FindCheckType above.; ///; /// \returns a pair of StringRefs into the Buffer, which combines:; /// - the first match of the regular expression to satisfy these two is; /// returned,; /// otherwise an empty StringRef is returned to indicate failure.; /// - buffer rewound to the location right after parsed suffix, for parsing; /// to continue from; ///; /// If this routine returns a valid prefix, it will also shrink \p Buffer to; /// start at the beginning of the returned prefix, increment \p LineNumber for; /// each new line consumed from \p Buffer, and set \p CheckTy to the type of; /// check found by examining the suffix.; ///; /// If no valid prefix is found, the state of Buffer, LineNumber, and CheckTy; /// is unspecified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:23,Availability,error,error,23,// Location to use for error messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:29,Integrability,message,messages,29,// Location to use for error messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:54,Modifiability,variab,variables,54,// Verify that CHECK-LABEL lines do not define or use variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:48,Availability,error,error,48,// When there are no used prefixes we report an error except in the case that; // no prefix is specified explicitly but -implicit-check-not is specified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:126,Availability,error,error,126,"// Add an EOF pattern for any trailing --implicit-check-not/CHECK-DAG/-NOTs,; // and use the first prefix as a filler for the error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:132,Integrability,message,message,132,"// Add an EOF pattern for any trailing --implicit-check-not/CHECK-DAG/-NOTs,; // and use the first prefix as a filler for the error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:26,Availability,Error,ErrorSuccess,26,"/// Returns either (1) \c ErrorSuccess if there was no error or (2); /// \c ErrorReported if an error was reported, such as an unexpected match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:55,Availability,error,error,55,"/// Returns either (1) \c ErrorSuccess if there was no error or (2); /// \c ErrorReported if an error was reported, such as an unexpected match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:76,Availability,Error,ErrorReported,76,"/// Returns either (1) \c ErrorSuccess if there was no error or (2); /// \c ErrorReported if an error was reported, such as an unexpected match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:96,Availability,error,error,96,"/// Returns either (1) \c ErrorSuccess if there was no error or (2); /// \c ErrorReported if an error was reported, such as an unexpected match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:41,Availability,error,error,41,// Suppress some verbosity if there's no error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:46,Modifiability,variab,variable,46,"// Add ""found"" diagnostic, substitutions, and variable definitions to Diags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:71,Availability,error,errors,71,"// Print additional information, which can be useful even if there are errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:9,Availability,error,errors,9,"// Print errors and add them to Diags. We report these errors after the match; // itself because we found them after the match. If we had found them before; // the match, we'd be in printNoMatch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:55,Availability,error,errors,55,"// Print errors and add them to Diags. We report these errors after the match; // itself because we found them after the match. If we had found them before; // the match, we'd be in printNoMatch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:26,Availability,Error,ErrorSuccess,26,"/// Returns either (1) \c ErrorSuccess if there was no error, or (2); /// \c ErrorReported if an error was reported, such as an expected match not; /// found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:55,Availability,error,error,55,"/// Returns either (1) \c ErrorSuccess if there was no error, or (2); /// \c ErrorReported if an error was reported, such as an expected match not; /// found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:77,Availability,Error,ErrorReported,77,"/// Returns either (1) \c ErrorSuccess if there was no error, or (2); /// \c ErrorReported if an error was reported, such as an expected match not; /// found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:97,Availability,error,error,97,"/// Returns either (1) \c ErrorSuccess if there was no error, or (2); /// \c ErrorReported if an error was reported, such as an expected match not; /// found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:21,Availability,error,errors,21,"// Print any pattern errors, and record them to be added to Diags later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:41,Availability,error,error,41,// Suppress some verbosity if there's no error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:58,Availability,error,errors,58,"// Add ""not found"" diagnostic, substitutions, and pattern errors to Diags.; //; // We handle Diags a little differently than the errors we print directly:; // we add the ""not found"" diagnostic to Diags even if there are pattern; // errors. The reason is that we need to attach pattern errors as notes; // somewhere in the input, and the input search range from the ""not found""; // diagnostic is all we have to anchor them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:129,Availability,error,errors,129,"// Add ""not found"" diagnostic, substitutions, and pattern errors to Diags.; //; // We handle Diags a little differently than the errors we print directly:; // we add the ""not found"" diagnostic to Diags even if there are pattern; // errors. The reason is that we need to attach pattern errors as notes; // somewhere in the input, and the input search range from the ""not found""; // diagnostic is all we have to anchor them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:232,Availability,error,errors,232,"// Add ""not found"" diagnostic, substitutions, and pattern errors to Diags.; //; // We handle Diags a little differently than the errors we print directly:; // we add the ""not found"" diagnostic to Diags even if there are pattern; // errors. The reason is that we need to attach pattern errors as notes; // somewhere in the input, and the input search range from the ""not found""; // diagnostic is all we have to anchor them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:285,Availability,error,errors,285,"// Add ""not found"" diagnostic, substitutions, and pattern errors to Diags.; //; // We handle Diags a little differently than the errors we print directly:; // we add the ""not found"" diagnostic to Diags even if there are pattern; // errors. The reason is that we need to attach pattern errors as notes; // somewhere in the input, and the input search range from the ""not found""; // diagnostic is all we have to anchor them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:91,Availability,error,error,91,"// Print ""not found"" diagnostic, except that's implied if we already printed a; // pattern error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:78,Availability,error,error,78,"// Print additional information, which can be useful even after a pattern; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:26,Availability,Error,ErrorSuccess,26,"/// Returns either (1) \c ErrorSuccess if there was no error, or (2); /// \c ErrorReported if an error was reported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:55,Availability,error,error,55,"/// Returns either (1) \c ErrorSuccess if there was no error, or (2); /// \c ErrorReported if an error was reported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:77,Availability,Error,ErrorReported,77,"/// Returns either (1) \c ErrorSuccess if there was no error, or (2); /// \c ErrorReported if an error was reported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:97,Availability,error,error,97,"/// Returns either (1) \c ErrorSuccess if there was no error, or (2); /// \c ErrorReported if an error was reported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:110,Modifiability,variab,variable,110,// IsLabelScanMode is true when we are scanning forward to find CHECK-LABEL; // bounds; we have not processed variable definitions within the bounded block; // yet so cannot handle any final CHECK-DAG yet; this is handled when going; // over the block again (including the last CHECK-LABEL) in normal mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:39,Safety,detect,detecting,39,"// We need PatItr and PatEnd later for detecting the end of a CHECK-DAG; // group, so we don't use a range-based for loop here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:3,Usability,Clear,Clear,3,"// Clear ""not strings"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:10,Security,validat,validate,10,"// Do not validate the default prefixes, or diagnostics about duplicates might; // incorrectly indicate that they were supplied by the user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:11,Modifiability,variab,variable,11,// Numeric variable definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:48,Energy Efficiency,adapt,adapted,48,// Append a copy of the command-line definition adapted to use the same; // format as in the input file to be able to reuse; // parseNumericSubstitutionBlock.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:48,Modifiability,adapt,adapted,48,// Append a copy of the command-line definition adapted to use the same; // format as in the input file to be able to reuse; // parseNumericSubstitutionBlock.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:11,Modifiability,variab,variable,11,// Numeric variable definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:228,Availability,error,error,228,"// Now evaluate the expression whose value this variable should be set; // to, since the expression of a command-line variable definition should; // only use variables defined earlier on the command-line. If not, this; // is an error and we report it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:48,Modifiability,variab,variable,48,"// Now evaluate the expression whose value this variable should be set; // to, since the expression of a command-line variable definition should; // only use variables defined earlier on the command-line. If not, this; // is an error and we report it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:118,Modifiability,variab,variable,118,"// Now evaluate the expression whose value this variable should be set; // to, since the expression of a command-line variable definition should; // only use variables defined earlier on the command-line. If not, this; // is an error and we report it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:158,Modifiability,variab,variables,158,"// Now evaluate the expression whose value this variable should be set; // to, since the expression of a command-line variable definition should; // only use variables defined earlier on the command-line. If not, this; // is an error and we report it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:15,Modifiability,variab,variable,15,// Record this variable definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:10,Modifiability,variab,variable,10,// String variable definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:51,Modifiability,variab,variable,51,"// Check that CmdlineName does not denote a pseudo variable is only; // composed of the parsed numeric variable. This catches cases like; // ""FOO+2"" in a ""FOO+2=10"" definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:103,Modifiability,variab,variable,103,"// Check that CmdlineName does not denote a pseudo variable is only; // composed of the parsed numeric variable. This catches cases like; // ""FOO+2"" in a ""FOO+2=10"" definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:48,Modifiability,variab,variables,48,// Detect collisions between string and numeric variables when the former; // is created later than the latter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:3,Safety,Detect,Detect,3,// Detect collisions between string and numeric variables when the former; // is created later than the latter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:19,Modifiability,variab,variable,19,// Mark the string variable as defined to detect collisions between; // string and numeric variables in defineCmdlineVariables when the latter; // is created later than the former. We cannot reuse GlobalVariableTable; // for this by populating it with an empty string since we would then; // lose the ability to detect the use of an undefined variable in; // match().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:91,Modifiability,variab,variables,91,// Mark the string variable as defined to detect collisions between; // string and numeric variables in defineCmdlineVariables when the latter; // is created later than the former. We cannot reuse GlobalVariableTable; // for this by populating it with an empty string since we would then; // lose the ability to detect the use of an undefined variable in; // match().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:343,Modifiability,variab,variable,343,// Mark the string variable as defined to detect collisions between; // string and numeric variables in defineCmdlineVariables when the latter; // is created later than the former. We cannot reuse GlobalVariableTable; // for this by populating it with an empty string since we would then; // lose the ability to detect the use of an undefined variable in; // match().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:42,Safety,detect,detect,42,// Mark the string variable as defined to detect collisions between; // string and numeric variables in defineCmdlineVariables when the latter; // is created later than the former. We cannot reuse GlobalVariableTable; // for this by populating it with an empty string since we would then; // lose the ability to detect the use of an undefined variable in; // match().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:312,Safety,detect,detect,312,// Mark the string variable as defined to detect collisions between; // string and numeric variables in defineCmdlineVariables when the latter; // is created later than the former. We cannot reuse GlobalVariableTable; // for this by populating it with an empty string since we would then; // lose the ability to detect the use of an undefined variable in; // match().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:210,Availability,failure,failure,210,"// Numeric substitution reads the value of a variable directly, not via; // GlobalNumericVariableTable. Therefore, we clear local variables by; // clearing their value which will lead to a numeric substitution failure. We; // also mark the variable for removal from GlobalNumericVariableTable since; // this is what defineCmdlineVariables checks to decide that no global; // variable has been defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:45,Modifiability,variab,variable,45,"// Numeric substitution reads the value of a variable directly, not via; // GlobalNumericVariableTable. Therefore, we clear local variables by; // clearing their value which will lead to a numeric substitution failure. We; // also mark the variable for removal from GlobalNumericVariableTable since; // this is what defineCmdlineVariables checks to decide that no global; // variable has been defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:130,Modifiability,variab,variables,130,"// Numeric substitution reads the value of a variable directly, not via; // GlobalNumericVariableTable. Therefore, we clear local variables by; // clearing their value which will lead to a numeric substitution failure. We; // also mark the variable for removal from GlobalNumericVariableTable since; // this is what defineCmdlineVariables checks to decide that no global; // variable has been defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:240,Modifiability,variab,variable,240,"// Numeric substitution reads the value of a variable directly, not via; // GlobalNumericVariableTable. Therefore, we clear local variables by; // clearing their value which will lead to a numeric substitution failure. We; // also mark the variable for removal from GlobalNumericVariableTable since; // this is what defineCmdlineVariables checks to decide that no global; // variable has been defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:375,Modifiability,variab,variable,375,"// Numeric substitution reads the value of a variable directly, not via; // GlobalNumericVariableTable. Therefore, we clear local variables by; // clearing their value which will lead to a numeric substitution failure. We; // also mark the variable for removal from GlobalNumericVariableTable since; // this is what defineCmdlineVariables checks to decide that no global; // variable has been defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:118,Usability,clear,clear,118,"// Numeric substitution reads the value of a variable directly, not via; // GlobalNumericVariableTable. Therefore, we clear local variables by; // clearing their value which will lead to a numeric substitution failure. We; // also mark the variable for removal from GlobalNumericVariableTable since; // this is what defineCmdlineVariables checks to decide that no global; // variable has been defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:147,Usability,clear,clearing,147,"// Numeric substitution reads the value of a variable directly, not via; // GlobalNumericVariableTable. Therefore, we clear local variables by; // clearing their value which will lead to a numeric substitution failure. We; // also mark the variable for removal from GlobalNumericVariableTable since; // this is what defineCmdlineVariables checks to decide that no global; // variable has been defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:101,Modifiability,variab,variables,101,// Do not clear the first region as it's the one before the first; // CHECK-LABEL and it would clear variables defined on the command-line; // before they get used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:10,Usability,clear,clear,10,// Do not clear the first region as it's the one before the first; // CHECK-LABEL and it would clear variables defined on the command-line; // before they get used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:95,Usability,clear,clear,95,// Do not clear the first region as it's the one before the first; // CHECK-LABEL and it would clear variables defined on the command-line; // before they get used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:44,Integrability,Interface,Interface,44,"//===-- FileCheckImpl.h - Private FileCheck Interface ------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the private interfaces of FileCheck. Its purpose is to; // allow unit testing of FileCheck and to separate the interface from the; // implementation. It is only meant to be used by FileCheck.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:413,Integrability,interface,interfaces,413,"//===-- FileCheckImpl.h - Private FileCheck Interface ------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the private interfaces of FileCheck. Its purpose is to; // allow unit testing of FileCheck and to separate the interface from the; // implementation. It is only meant to be used by FileCheck.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:512,Integrability,interface,interface,512,"//===-- FileCheckImpl.h - Private FileCheck Interface ------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the private interfaces of FileCheck. Its purpose is to; // allow unit testing of FileCheck and to separate the interface from the; // implementation. It is only meant to be used by FileCheck.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:471,Testability,test,testing,471,"//===-- FileCheckImpl.h - Private FileCheck Interface ------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the private interfaces of FileCheck. Its purpose is to; // allow unit testing of FileCheck and to separate the interface from the; // implementation. It is only meant to be used by FileCheck.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:404,Modifiability,variab,variables,404,//===----------------------------------------------------------------------===//; // Numeric substitution handling code.; //===----------------------------------------------------------------------===//; /// Type representing the format an expression value should be textualized into; /// for matching. Used to represent both explicit format specifiers as well as; /// implicit format from using numeric variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:147,Availability,error,error,147,"/// \returns a wildcard regular expression string that matches any value in; /// the format represented by this instance and no other value, or an error; /// if the format is NoFormat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:106,Availability,error,error,106,"/// \returns the string representation of \p Value in the format represented; /// by this instance, or an error if conversion to this format failed or the; /// format is NoFormat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:35,Availability,error,error,35,/// Class to represent an overflow error that might result when manipulating a; /// value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:53,Availability,error,error,53,"/// Performs operation and \returns its result or an error in case of failure,; /// such as if an overflow occurs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:70,Availability,failure,failure,70,"/// Performs operation and \returns its result or an error in case of failure,; /// such as if an overflow occurs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:4,Performance,Perform,Performs,4,"/// Performs operation and \returns its result or an error in case of failure,; /// such as if an overflow occurs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:90,Availability,error,error,90,/// Evaluates and \returns the value of the expression represented by this; /// AST or an error if evaluation fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:45,Availability,error,error,45,"/// Class to represent an undefined variable error, which quotes that; /// variable's name when printed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:36,Modifiability,variab,variable,36,"/// Class to represent an undefined variable error, which quotes that; /// variable's name when printed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:75,Modifiability,variab,variable,75,"/// Class to represent an undefined variable error, which quotes that; /// variable's name when printed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:48,Availability,error,error,48,/// Print name of variable associated with this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:18,Modifiability,variab,variable,18,/// Print name of variable associated with this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:33,Modifiability,variab,variable,33,/// Class representing a numeric variable and its associated current value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:24,Modifiability,variab,variable,24,/// Name of the numeric variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:45,Modifiability,variab,variable,45,/// Format to use for expressions using this variable without an explicit; /// format.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:21,Modifiability,variab,variable,21,"/// Value of numeric variable, if defined, or std::nullopt otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:27,Modifiability,variab,variable,27,"/// Line number where this variable is defined, or std::nullopt if defined; /// before input is parsed. Used to determine whether a variable is defined on; /// the same line as a given use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:132,Modifiability,variab,variable,132,"/// Line number where this variable is defined, or std::nullopt if defined; /// before input is parsed. Used to determine whether a variable is defined on; /// the same line as a given use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:22,Modifiability,variab,variable,22,/// Constructor for a variable \p Name with implicit format \p ImplicitFormat; /// defined at line \p DefLineNumber or defined before input is parsed if; /// \p DefLineNumber is std::nullopt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:34,Modifiability,variab,variable,34,/// \returns name of this numeric variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:45,Modifiability,variab,variable,45,/// \returns implicit format of this numeric variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:18,Modifiability,variab,variable,18,/// \returns this variable's value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:55,Modifiability,variab,variable,55,"/// \returns the input buffer's string from which this variable's value was; /// parsed, or std::nullopt if the value is not yet defined or was not parsed; /// from the input buffer. For example, the value of @LINE is not parsed from; /// the input buffer, and some numeric variables are parsed from the command; /// line instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:274,Modifiability,variab,variables,274,"/// \returns the input buffer's string from which this variable's value was; /// parsed, or std::nullopt if the value is not yet defined or was not parsed; /// from the input buffer. For example, the value of @LINE is not parsed from; /// the input buffer, and some numeric variables are parsed from the command; /// line instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:31,Modifiability,variab,variable,31,"/// Sets value of this numeric variable to \p NewValue, and sets the input; /// buffer string from which it was parsed to \p NewStrValue. See comments on; /// getStringValue for a discussion of when the latter can be std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:33,Modifiability,variab,variable,33,"/// Clears value of this numeric variable, regardless of whether it is; /// currently defined or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:4,Usability,Clear,Clears,4,"/// Clears value of this numeric variable, regardless of whether it is; /// currently defined or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:40,Modifiability,variab,variable,40,"/// \returns the line number where this variable is defined, if any, or; /// std::nullopt if defined before input is parsed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:44,Modifiability,variab,variable,44,/// Class representing the use of a numeric variable in the AST of an; /// expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:42,Modifiability,variab,variable,42,/// Pointer to the class instance for the variable this use is about.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:30,Modifiability,variab,variable,30,/// \returns the value of the variable referenced by this instance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:45,Modifiability,variab,variable,45,/// \returns implicit format of this numeric variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:189,Availability,error,error,189,"/// Evaluates the value of the binary operation represented by this AST,; /// using EvalBinop on the result of recursively evaluating the operands.; /// \returns the expression value or an error if an undefined numeric; /// variable is used in one of the operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:224,Modifiability,variab,variable,224,"/// Evaluates the value of the binary operation represented by this AST,; /// using EvalBinop on the result of recursively evaluating the operands.; /// \returns the expression value or an error if an undefined numeric; /// variable is used in one of the operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:41,Performance,perform,perform,41,/// Class representing a substitution to perform in the RegExStr string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:107,Modifiability,variab,variables,107,"/// Pointer to a class instance holding, among other things, the table with; /// the values of live string variables at the start of any given CHECK line.; /// Used for substituting string variables with the text they were defined; /// as. Expressions are linked to the numeric variables they use at; /// parse time and directly access the value of the numeric variable to; /// evaluate their value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:189,Modifiability,variab,variables,189,"/// Pointer to a class instance holding, among other things, the table with; /// the values of live string variables at the start of any given CHECK line.; /// Used for substituting string variables with the text they were defined; /// as. Expressions are linked to the numeric variables they use at; /// parse time and directly access the value of the numeric variable to; /// evaluate their value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:278,Modifiability,variab,variables,278,"/// Pointer to a class instance holding, among other things, the table with; /// the values of live string variables at the start of any given CHECK line.; /// Used for substituting string variables with the text they were defined; /// as. Expressions are linked to the numeric variables they use at; /// parse time and directly access the value of the numeric variable to; /// evaluate their value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:361,Modifiability,variab,variable,361,"/// Pointer to a class instance holding, among other things, the table with; /// the values of live string variables at the start of any given CHECK line.; /// Used for substituting string variables with the text they were defined; /// as. Expressions are linked to the numeric variables they use at; /// parse time and directly access the value of the numeric variable to; /// evaluate their value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:329,Security,access,access,329,"/// Pointer to a class instance holding, among other things, the table with; /// the values of live string variables at the start of any given CHECK line.; /// Used for substituting string variables with the text they were defined; /// as. Expressions are linked to the numeric variables they use at; /// parse time and directly access the value of the numeric variable to; /// evaluate their value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:82,Modifiability,variab,variable,82,"/// The string that needs to be substituted for something else. For a; /// string variable this is its name, otherwise this is the whole expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:55,Performance,perform,performed,55,/// \returns the index where the substitution is to be performed in RegExStr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:110,Availability,error,error,110,/// \returns a string containing the result of the substitution represented; /// by this class instance or an error if substitution failed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:101,Availability,error,error,101,"/// \returns the text that the string variable in this substitution matched; /// when defined, or an error if the variable is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:38,Modifiability,variab,variable,38,"/// \returns the text that the string variable in this substitution matched; /// when defined, or an error if the variable is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:114,Modifiability,variab,variable,114,"/// \returns the text that the string variable in this substitution matched; /// when defined, or an error if the variable is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:106,Availability,error,error,106,"/// \returns a string containing the result of evaluating the expression in; /// this substitution, or an error if evaluation failed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:289,Modifiability,variab,variables,289,"//===----------------------------------------------------------------------===//; // Pattern handling code.; //===----------------------------------------------------------------------===//; /// Class holding the Pattern global state, shared by all patterns: tables; /// holding values of variables and whether they are defined or not at any; /// given time in the matching process.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:79,Modifiability,variab,variables,79,"/// When matching a given pattern, this holds the value of all the string; /// variables defined in previous patterns. In a pattern, only the last; /// definition for a given variable is recorded in this table.; /// Back-references are used for uses after any the other definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:175,Modifiability,variab,variable,175,"/// When matching a given pattern, this holds the value of all the string; /// variables defined in previous patterns. In a pattern, only the last; /// definition for a given variable is recorded in this table.; /// Back-references are used for uses after any the other definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:22,Modifiability,variab,variables,22,/// Map of all string variables defined so far. Used at parse time to detect; /// a name conflict between a numeric variable and a string variable when; /// the former is defined on a later line than the latter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:116,Modifiability,variab,variable,116,/// Map of all string variables defined so far. Used at parse time to detect; /// a name conflict between a numeric variable and a string variable when; /// the former is defined on a later line than the latter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:138,Modifiability,variab,variable,138,/// Map of all string variables defined so far. Used at parse time to detect; /// a name conflict between a numeric variable and a string variable when; /// the former is defined on a later line than the latter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:70,Safety,detect,detect,70,/// Map of all string variables defined so far. Used at parse time to detect; /// a name conflict between a numeric variable and a string variable when; /// the former is defined on a later line than the latter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:104,Modifiability,variab,variables,104,"/// When matching a given pattern, this holds the pointers to the classes; /// representing the numeric variables defined in previous patterns. When; /// matching a pattern all definitions for that pattern are recorded in the; /// NumericVariableDefs table in the Pattern instance of that pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:64,Modifiability,variab,variable,64,/// Pointer to the class instance representing the @LINE pseudo variable for; /// easily updating its value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:50,Modifiability,variab,variables,50,/// Vector holding pointers to all parsed numeric variables. Used to; /// automatically free them once they are guaranteed to no longer be used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:59,Availability,error,error,59,/// \returns the value of string variable \p VarName or an error if no such; /// variable has been defined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:33,Modifiability,variab,variable,33,/// \returns the value of string variable \p VarName or an error if no such; /// variable has been defined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:81,Modifiability,variab,variable,81,/// \returns the value of string variable \p VarName or an error if no such; /// variable has been defined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:170,Availability,error,error,170,"/// Defines string and numeric variables from definitions given on the; /// command line, passed as a vector of [#]VAR=VAL strings in; /// \p CmdlineDefines. \returns an error list containing diagnostics against; /// \p SM for all definition parsing failures, if any, or Success otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:250,Availability,failure,failures,250,"/// Defines string and numeric variables from definitions given on the; /// command line, passed as a vector of [#]VAR=VAL strings in; /// \p CmdlineDefines. \returns an error list containing diagnostics against; /// \p SM for all definition parsing failures, if any, or Success otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:31,Modifiability,variab,variables,31,"/// Defines string and numeric variables from definitions given on the; /// command line, passed as a vector of [#]VAR=VAL strings in; /// \p CmdlineDefines. \returns an error list containing diagnostics against; /// \p SM for all definition parsing failures, if any, or Success otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:24,Modifiability,variab,variable,24,/// Create @LINE pseudo variable. Value is set when pattern are being; /// matched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:20,Modifiability,variab,variables,20,"/// Undefines local variables (variables whose name does not start with a '$'; /// sign), i.e. removes them from GlobalVariableTable and from; /// GlobalNumericVariableTable and also clears the value of numeric; /// variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:31,Modifiability,variab,variables,31,"/// Undefines local variables (variables whose name does not start with a '$'; /// sign), i.e. removes them from GlobalVariableTable and from; /// GlobalNumericVariableTable and also clears the value of numeric; /// variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:216,Modifiability,variab,variables,216,"/// Undefines local variables (variables whose name does not start with a '$'; /// sign), i.e. removes them from GlobalVariableTable and from; /// GlobalNumericVariableTable and also clears the value of numeric; /// variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:183,Usability,clear,clears,183,"/// Undefines local variables (variables whose name does not start with a '$'; /// sign), i.e. removes them from GlobalVariableTable and from; /// GlobalNumericVariableTable and also clears the value of numeric; /// variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:24,Modifiability,variab,variable,24,/// Makes a new numeric variable and registers it for destruction when the; /// context is destroyed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:26,Availability,error,error,26,/// Class to represent an error holding a diagnostic with location information; /// used when printing it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:42,Availability,error,error,42,/// Print diagnostic associated with this error when printing the error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:66,Availability,error,error,66,/// Print diagnostic associated with this error when printing the error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:42,Availability,error,error,42,/// Print diagnostic associated with this error when printing the error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:66,Availability,error,error,66,/// Print diagnostic associated with this error when printing the error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:7,Availability,error,error,7,"/// An error that has already been reported.; ///; /// This class is designed to support a function whose callers may need to know; /// whether the function encountered and reported an error but never need to; /// know the nature of that error. For example, the function has a return type; /// of \c Error and always returns either \c ErrorReported or \c ErrorSuccess.; /// That interface is similar to that of a function returning bool to indicate; /// an error except, in the former case, (1) there is no confusion over polarity; /// and (2) the caller must either check the result or explicitly ignore it with; /// a call like \c consumeError.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:185,Availability,error,error,185,"/// An error that has already been reported.; ///; /// This class is designed to support a function whose callers may need to know; /// whether the function encountered and reported an error but never need to; /// know the nature of that error. For example, the function has a return type; /// of \c Error and always returns either \c ErrorReported or \c ErrorSuccess.; /// That interface is similar to that of a function returning bool to indicate; /// an error except, in the former case, (1) there is no confusion over polarity; /// and (2) the caller must either check the result or explicitly ignore it with; /// a call like \c consumeError.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:238,Availability,error,error,238,"/// An error that has already been reported.; ///; /// This class is designed to support a function whose callers may need to know; /// whether the function encountered and reported an error but never need to; /// know the nature of that error. For example, the function has a return type; /// of \c Error and always returns either \c ErrorReported or \c ErrorSuccess.; /// That interface is similar to that of a function returning bool to indicate; /// an error except, in the former case, (1) there is no confusion over polarity; /// and (2) the caller must either check the result or explicitly ignore it with; /// a call like \c consumeError.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:300,Availability,Error,Error,300,"/// An error that has already been reported.; ///; /// This class is designed to support a function whose callers may need to know; /// whether the function encountered and reported an error but never need to; /// know the nature of that error. For example, the function has a return type; /// of \c Error and always returns either \c ErrorReported or \c ErrorSuccess.; /// That interface is similar to that of a function returning bool to indicate; /// an error except, in the former case, (1) there is no confusion over polarity; /// and (2) the caller must either check the result or explicitly ignore it with; /// a call like \c consumeError.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:335,Availability,Error,ErrorReported,335,"/// An error that has already been reported.; ///; /// This class is designed to support a function whose callers may need to know; /// whether the function encountered and reported an error but never need to; /// know the nature of that error. For example, the function has a return type; /// of \c Error and always returns either \c ErrorReported or \c ErrorSuccess.; /// That interface is similar to that of a function returning bool to indicate; /// an error except, in the former case, (1) there is no confusion over polarity; /// and (2) the caller must either check the result or explicitly ignore it with; /// a call like \c consumeError.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:355,Availability,Error,ErrorSuccess,355,"/// An error that has already been reported.; ///; /// This class is designed to support a function whose callers may need to know; /// whether the function encountered and reported an error but never need to; /// know the nature of that error. For example, the function has a return type; /// of \c Error and always returns either \c ErrorReported or \c ErrorSuccess.; /// That interface is similar to that of a function returning bool to indicate; /// an error except, in the former case, (1) there is no confusion over polarity; /// and (2) the caller must either check the result or explicitly ignore it with; /// a call like \c consumeError.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:457,Availability,error,error,457,"/// An error that has already been reported.; ///; /// This class is designed to support a function whose callers may need to know; /// whether the function encountered and reported an error but never need to; /// know the nature of that error. For example, the function has a return type; /// of \c Error and always returns either \c ErrorReported or \c ErrorSuccess.; /// That interface is similar to that of a function returning bool to indicate; /// an error except, in the former case, (1) there is no confusion over polarity; /// and (2) the caller must either check the result or explicitly ignore it with; /// a call like \c consumeError.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:379,Integrability,interface,interface,379,"/// An error that has already been reported.; ///; /// This class is designed to support a function whose callers may need to know; /// whether the function encountered and reported an error but never need to; /// know the nature of that error. For example, the function has a return type; /// of \c Error and always returns either \c ErrorReported or \c ErrorSuccess.; /// That interface is similar to that of a function returning bool to indicate; /// an error except, in the former case, (1) there is no confusion over polarity; /// and (2) the caller must either check the result or explicitly ignore it with; /// a call like \c consumeError.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:42,Availability,error,error,42,/// Print diagnostic associated with this error when printing the error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:66,Availability,error,error,66,/// Print diagnostic associated with this error when printing the error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:64,Modifiability,variab,variable,64,"/// Entries in this vector represent a substitution of a string variable or; /// an expression in the RegExStr regex at match time. For example, in the; /// case of a CHECK directive with the pattern ""foo[[bar]]baz[[#N+1]]"",; /// RegExStr will contain ""foobaz"" and we'll get two entries in this vector; /// that tells us to insert the value of string variable ""bar"" at offset 3; /// and the value of expression ""N+1"" at offset 6.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:351,Modifiability,variab,variable,351,"/// Entries in this vector represent a substitution of a string variable or; /// an expression in the RegExStr regex at match time. For example, in the; /// case of a CHECK directive with the pattern ""foo[[bar]]baz[[#N+1]]"",; /// RegExStr will contain ""foobaz"" and we'll get two entries in this vector; /// that tells us to insert the value of string variable ""bar"" at offset 3; /// and the value of expression ""N+1"" at offset 6.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:25,Modifiability,variab,variables,25,"/// Maps names of string variables defined in a pattern to the number of; /// their parenthesis group in RegExStr capturing their last definition.; ///; /// E.g. for the pattern ""foo[[bar:.*]]baz([[bar]][[QUUX]][[bar:.*]])"",; /// RegExStr will be ""foo(.*)baz(\1<quux value>(.*))"" where <quux value> is; /// the value captured for QUUX on the earlier line where it was defined, and; /// VariableDefs will map ""bar"" to the third parenthesis group which captures; /// the second definition of ""bar"".; ///; /// Note: uses std::map rather than StringMap to be able to get the key when; /// iterating over values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:386,Modifiability,Variab,VariableDefs,386,"/// Maps names of string variables defined in a pattern to the number of; /// their parenthesis group in RegExStr capturing their last definition.; ///; /// E.g. for the pattern ""foo[[bar:.*]]baz([[bar]][[QUUX]][[bar:.*]])"",; /// RegExStr will be ""foo(.*)baz(\1<quux value>(.*))"" where <quux value> is; /// the value captured for QUUX on the earlier line where it was defined, and; /// VariableDefs will map ""bar"" to the third parenthesis group which captures; /// the second definition of ""bar"".; ///; /// Note: uses std::map rather than StringMap to be able to get the key when; /// iterating over values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:55,Modifiability,variab,variable,55,/// Structure representing the definition of a numeric variable in a pattern.; /// It holds the pointer to the class instance holding the value and matching; /// format of the numeric variable whose value is being defined and the; /// number of the parenthesis group in RegExStr to capture that value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:184,Modifiability,variab,variable,184,/// Structure representing the definition of a numeric variable in a pattern.; /// It holds the pointer to the class instance holding the value and matching; /// format of the numeric variable whose value is being defined and the; /// number of the parenthesis group in RegExStr to capture that value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:88,Modifiability,variab,variable,88,/// Pointer to class instance holding the value and matching format of the; /// numeric variable being defined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:93,Modifiability,variab,variable,93,/// Number of the parenthesis group in RegExStr that captures the value of; /// this numeric variable definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:142,Modifiability,variab,variable,142,/// Holds the number of the parenthesis group in RegExStr and pointer to the; /// corresponding NumericVariable class instance of all numeric variable; /// definitions. Used to set the matched value of all those variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:212,Modifiability,variab,variables,212,/// Holds the number of the parenthesis group in RegExStr and pointer to the; /// corresponding NumericVariable class instance of all numeric variable; /// definitions. Used to set the matched value of all those variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:152,Modifiability,variab,variables,152,/// Pointer to a class instance holding the global state shared by all; /// patterns:; /// - separate tables with the values of live string and numeric variables; /// respectively at the start of any given CHECK line;; /// - table holding whether a string variable has been defined at any given; /// point during the parsing phase.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:256,Modifiability,variab,variable,256,/// Pointer to a class instance holding the global state shared by all; /// patterns:; /// - separate tables with the values of live string and numeric variables; /// respectively at the start of any given CHECK line;; /// - table holding whether a string variable has been defined at any given; /// point during the parsing phase.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:118,Modifiability,variab,variable,118,/// Line number for this CHECK pattern or std::nullopt if it is an implicit; /// pattern. Used to determine whether a variable definition is made on an; /// earlier line to the one with this CHECK.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:59,Modifiability,variab,variable,59,/// \returns whether \p C is a valid first character for a variable name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:32,Modifiability,variab,variable,32,/// Parsing information about a variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:197,Availability,error,error,197,"/// Parses the string at the start of \p Str for a variable name. \returns; /// a VariableProperties structure holding the variable name and whether it; /// is the name of a pseudo variable, or an error holding a diagnostic; /// against \p SM if parsing fail. If parsing was successful, also strips; /// \p Str from the variable name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:51,Modifiability,variab,variable,51,"/// Parses the string at the start of \p Str for a variable name. \returns; /// a VariableProperties structure holding the variable name and whether it; /// is the name of a pseudo variable, or an error holding a diagnostic; /// against \p SM if parsing fail. If parsing was successful, also strips; /// \p Str from the variable name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:82,Modifiability,Variab,VariableProperties,82,"/// Parses the string at the start of \p Str for a variable name. \returns; /// a VariableProperties structure holding the variable name and whether it; /// is the name of a pseudo variable, or an error holding a diagnostic; /// against \p SM if parsing fail. If parsing was successful, also strips; /// \p Str from the variable name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:123,Modifiability,variab,variable,123,"/// Parses the string at the start of \p Str for a variable name. \returns; /// a VariableProperties structure holding the variable name and whether it; /// is the name of a pseudo variable, or an error holding a diagnostic; /// against \p SM if parsing fail. If parsing was successful, also strips; /// \p Str from the variable name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:181,Modifiability,variab,variable,181,"/// Parses the string at the start of \p Str for a variable name. \returns; /// a VariableProperties structure holding the variable name and whether it; /// is the name of a pseudo variable, or an error holding a diagnostic; /// against \p SM if parsing fail. If parsing was successful, also strips; /// \p Str from the variable name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:320,Modifiability,variab,variable,320,"/// Parses the string at the start of \p Str for a variable name. \returns; /// a VariableProperties structure holding the variable name and whether it; /// is the name of a pseudo variable, or an error holding a diagnostic; /// against \p SM if parsing fail. If parsing was successful, also strips; /// \p Str from the variable name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:442,Availability,error,error,442,"/// Parses \p Expr for a numeric substitution block at line \p LineNumber,; /// or before input is parsed if \p LineNumber is None. Parameter; /// \p IsLegacyLineExpr indicates whether \p Expr should be a legacy @LINE; /// expression and \p Context points to the class instance holding the live; /// string and numeric variables. \returns a pointer to the class instance; /// representing the expression whose value must be substitued, or an error; /// holding a diagnostic against \p SM if parsing fails. If substitution was; /// successful, sets \p DefinedNumericVariable to point to the class; /// representing the numeric variable defined in this numeric substitution; /// block, or std::nullopt if this block does not define any variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:319,Modifiability,variab,variables,319,"/// Parses \p Expr for a numeric substitution block at line \p LineNumber,; /// or before input is parsed if \p LineNumber is None. Parameter; /// \p IsLegacyLineExpr indicates whether \p Expr should be a legacy @LINE; /// expression and \p Context points to the class instance holding the live; /// string and numeric variables. \returns a pointer to the class instance; /// representing the expression whose value must be substitued, or an error; /// holding a diagnostic against \p SM if parsing fails. If substitution was; /// successful, sets \p DefinedNumericVariable to point to the class; /// representing the numeric variable defined in this numeric substitution; /// block, or std::nullopt if this block does not define any variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:626,Modifiability,variab,variable,626,"/// Parses \p Expr for a numeric substitution block at line \p LineNumber,; /// or before input is parsed if \p LineNumber is None. Parameter; /// \p IsLegacyLineExpr indicates whether \p Expr should be a legacy @LINE; /// expression and \p Context points to the class instance holding the live; /// string and numeric variables. \returns a pointer to the class instance; /// representing the expression whose value must be substitued, or an error; /// holding a diagnostic against \p SM if parsing fails. If substitution was; /// successful, sets \p DefinedNumericVariable to point to the class; /// representing the numeric variable defined in this numeric substitution; /// block, or std::nullopt if this block does not define any variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:734,Modifiability,variab,variable,734,"/// Parses \p Expr for a numeric substitution block at line \p LineNumber,; /// or before input is parsed if \p LineNumber is None. Parameter; /// \p IsLegacyLineExpr indicates whether \p Expr should be a legacy @LINE; /// expression and \p Context points to the class instance holding the live; /// string and numeric variables. \returns a pointer to the class instance; /// representing the expression whose value must be substitued, or an error; /// holding a diagnostic against \p SM if parsing fails. If substitution was; /// successful, sets \p DefinedNumericVariable to point to the class; /// representing the numeric variable defined in this numeric substitution; /// block, or std::nullopt if this block does not define any variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:304,Availability,error,error,304,"/// Parses the pattern in \p PatternStr and initializes this Pattern instance; /// accordingly.; ///; /// \p Prefix provides which prefix is being matched, \p Req describes the; /// global options that influence the parsing such as whitespace; /// canonicalization, \p SM provides the SourceMgr used for error reports.; /// \returns true in case of an error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:352,Availability,error,error,352,"/// Parses the pattern in \p PatternStr and initializes this Pattern instance; /// accordingly.; ///; /// \p Prefix provides which prefix is being matched, \p Req describes the; /// global options that influence the parsing such as whitespace; /// canonicalization, \p SM provides the SourceMgr used for error reports.; /// \returns true in case of an error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:100,Availability,error,error,100,"/// Matches the pattern string against the input buffer \p Buffer.; ///; /// \returns either (1) an error resulting in no match or (2) a match possibly; /// with an error encountered while processing the match.; ///; /// The GlobalVariableTable StringMap in the FileCheckPatternContext class; /// instance provides the current values of FileCheck string variables and is; /// updated if this match defines new values. Likewise, the; /// GlobalNumericVariableTable StringMap in the same class provides the; /// current values of FileCheck numeric variables and is updated if this; /// match defines new numeric values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:165,Availability,error,error,165,"/// Matches the pattern string against the input buffer \p Buffer.; ///; /// \returns either (1) an error resulting in no match or (2) a match possibly; /// with an error encountered while processing the match.; ///; /// The GlobalVariableTable StringMap in the FileCheckPatternContext class; /// instance provides the current values of FileCheck string variables and is; /// updated if this match defines new values. Likewise, the; /// GlobalNumericVariableTable StringMap in the same class provides the; /// current values of FileCheck numeric variables and is updated if this; /// match defines new numeric values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:376,Deployability,update,updated,376,"/// Matches the pattern string against the input buffer \p Buffer.; ///; /// \returns either (1) an error resulting in no match or (2) a match possibly; /// with an error encountered while processing the match.; ///; /// The GlobalVariableTable StringMap in the FileCheckPatternContext class; /// instance provides the current values of FileCheck string variables and is; /// updated if this match defines new values. Likewise, the; /// GlobalNumericVariableTable StringMap in the same class provides the; /// current values of FileCheck numeric variables and is updated if this; /// match defines new numeric values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:563,Deployability,update,updated,563,"/// Matches the pattern string against the input buffer \p Buffer.; ///; /// \returns either (1) an error resulting in no match or (2) a match possibly; /// with an error encountered while processing the match.; ///; /// The GlobalVariableTable StringMap in the FileCheckPatternContext class; /// instance provides the current values of FileCheck string variables and is; /// updated if this match defines new values. Likewise, the; /// GlobalNumericVariableTable StringMap in the same class provides the; /// current values of FileCheck numeric variables and is updated if this; /// match defines new numeric values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:354,Modifiability,variab,variables,354,"/// Matches the pattern string against the input buffer \p Buffer.; ///; /// \returns either (1) an error resulting in no match or (2) a match possibly; /// with an error encountered while processing the match.; ///; /// The GlobalVariableTable StringMap in the FileCheckPatternContext class; /// instance provides the current values of FileCheck string variables and is; /// updated if this match defines new values. Likewise, the; /// GlobalNumericVariableTable StringMap in the same class provides the; /// current values of FileCheck numeric variables and is updated if this; /// match defines new numeric values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:546,Modifiability,variab,variables,546,"/// Matches the pattern string against the input buffer \p Buffer.; ///; /// \returns either (1) an error resulting in no match or (2) a match possibly; /// with an error encountered while processing the match.; ///; /// The GlobalVariableTable StringMap in the FileCheckPatternContext class; /// instance provides the current values of FileCheck string variables and is; /// updated if this match defines new values. Likewise, the; /// GlobalNumericVariableTable StringMap in the same class provides the; /// current values of FileCheck numeric variables and is updated if this; /// match defines new numeric values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:213,Availability,error,error,213,"/// Finds the closing sequence of a regex variable usage or definition.; ///; /// \p Str has to point in the beginning of the definition (right after the; /// opening sequence). \p SM holds the SourceMgr used for error reporting.; /// \returns the offset of the closing sequence within Str, or npos if it; /// was not found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:42,Modifiability,variab,variable,42,"/// Finds the closing sequence of a regex variable usage or definition.; ///; /// \p Str has to point in the beginning of the definition (right after the; /// opening sequence). \p SM holds the SourceMgr used for error reporting.; /// \returns the offset of the closing sequence within Str, or npos if it; /// was not found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:256,Availability,error,error,256,"/// Parses \p Expr for the name of a numeric variable to be defined at line; /// \p LineNumber, or before input is parsed if \p LineNumber is None.; /// \returns a pointer to the class instance representing that variable,; /// creating it if needed, or an error holding a diagnostic against \p SM; /// should defining such a variable be invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:45,Modifiability,variab,variable,45,"/// Parses \p Expr for the name of a numeric variable to be defined at line; /// \p LineNumber, or before input is parsed if \p LineNumber is None.; /// \returns a pointer to the class instance representing that variable,; /// creating it if needed, or an error holding a diagnostic against \p SM; /// should defining such a variable be invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:212,Modifiability,variab,variable,212,"/// Parses \p Expr for the name of a numeric variable to be defined at line; /// \p LineNumber, or before input is parsed if \p LineNumber is None.; /// \returns a pointer to the class instance representing that variable,; /// creating it if needed, or an error holding a diagnostic against \p SM; /// should defining such a variable be invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:325,Modifiability,variab,variable,325,"/// Parses \p Expr for the name of a numeric variable to be defined at line; /// \p LineNumber, or before input is parsed if \p LineNumber is None.; /// \returns a pointer to the class instance representing that variable,; /// creating it if needed, or an error holding a diagnostic against \p SM; /// should defining such a variable be invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:360,Availability,error,error,360,"/// Parses \p Name as a (pseudo if \p IsPseudo is true) numeric variable use; /// at line \p LineNumber, or before input is parsed if \p LineNumber is; /// None. Parameter \p Context points to the class instance holding the live; /// string and numeric variables. \returns the pointer to the class instance; /// representing that variable if successful, or an error holding a; /// diagnostic against \p SM otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:64,Modifiability,variab,variable,64,"/// Parses \p Name as a (pseudo if \p IsPseudo is true) numeric variable use; /// at line \p LineNumber, or before input is parsed if \p LineNumber is; /// None. Parameter \p Context points to the class instance holding the live; /// string and numeric variables. \returns the pointer to the class instance; /// representing that variable if successful, or an error holding a; /// diagnostic against \p SM otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:253,Modifiability,variab,variables,253,"/// Parses \p Name as a (pseudo if \p IsPseudo is true) numeric variable use; /// at line \p LineNumber, or before input is parsed if \p LineNumber is; /// None. Parameter \p Context points to the class instance holding the live; /// string and numeric variables. \returns the pointer to the class instance; /// representing that variable if successful, or an error holding a; /// diagnostic against \p SM otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:330,Modifiability,variab,variable,330,"/// Parses \p Name as a (pseudo if \p IsPseudo is true) numeric variable use; /// at line \p LineNumber, or before input is parsed if \p LineNumber is; /// None. Parameter \p Context points to the class instance holding the live; /// string and numeric variables. \returns the pointer to the class instance; /// representing that variable if successful, or an error holding a; /// diagnostic against \p SM otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:513,Availability,error,error,513,"/// Parses \p Expr for use of a numeric operand at line \p LineNumber, or; /// before input is parsed if \p LineNumber is None. Accepts literal values,; /// numeric variables and function calls, depending on the value of \p AO.; /// \p MaybeInvalidConstraint indicates whether the text being parsed could; /// be an invalid constraint. \p Context points to the class instance holding; /// the live string and numeric variables. \returns the class representing; /// that operand in the AST of the expression or an error holding a; /// diagnostic against \p SM otherwise. If \p Expr starts with a ""("" this; /// function will attempt to parse a parenthesized expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:195,Integrability,depend,depending,195,"/// Parses \p Expr for use of a numeric operand at line \p LineNumber, or; /// before input is parsed if \p LineNumber is None. Accepts literal values,; /// numeric variables and function calls, depending on the value of \p AO.; /// \p MaybeInvalidConstraint indicates whether the text being parsed could; /// be an invalid constraint. \p Context points to the class instance holding; /// the live string and numeric variables. \returns the class representing; /// that operand in the AST of the expression or an error holding a; /// diagnostic against \p SM otherwise. If \p Expr starts with a ""("" this; /// function will attempt to parse a parenthesized expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:165,Modifiability,variab,variables,165,"/// Parses \p Expr for use of a numeric operand at line \p LineNumber, or; /// before input is parsed if \p LineNumber is None. Accepts literal values,; /// numeric variables and function calls, depending on the value of \p AO.; /// \p MaybeInvalidConstraint indicates whether the text being parsed could; /// be an invalid constraint. \p Context points to the class instance holding; /// the live string and numeric variables. \returns the class representing; /// that operand in the AST of the expression or an error holding a; /// diagnostic against \p SM otherwise. If \p Expr starts with a ""("" this; /// function will attempt to parse a parenthesized expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:417,Modifiability,variab,variables,417,"/// Parses \p Expr for use of a numeric operand at line \p LineNumber, or; /// before input is parsed if \p LineNumber is None. Accepts literal values,; /// numeric variables and function calls, depending on the value of \p AO.; /// \p MaybeInvalidConstraint indicates whether the text being parsed could; /// be an invalid constraint. \p Context points to the class instance holding; /// the live string and numeric variables. \returns the class representing; /// that operand in the AST of the expression or an error holding a; /// diagnostic against \p SM otherwise. If \p Expr starts with a ""("" this; /// function will attempt to parse a parenthesized expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:600,Availability,error,error,600,"/// Parses and updates \p RemainingExpr for a binary operation at line; /// \p LineNumber, or before input is parsed if \p LineNumber is None. The; /// left operand of this binary operation is given in \p LeftOp and \p Expr; /// holds the string for the full expression, including the left operand.; /// Parameter \p IsLegacyLineExpr indicates whether we are parsing a legacy; /// @LINE expression. Parameter \p Context points to the class instance; /// holding the live string and numeric variables. \returns the class; /// representing the binary operation in the AST of the expression, or an; /// error holding a diagnostic against \p SM otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:15,Deployability,update,updates,15,"/// Parses and updates \p RemainingExpr for a binary operation at line; /// \p LineNumber, or before input is parsed if \p LineNumber is None. The; /// left operand of this binary operation is given in \p LeftOp and \p Expr; /// holds the string for the full expression, including the left operand.; /// Parameter \p IsLegacyLineExpr indicates whether we are parsing a legacy; /// @LINE expression. Parameter \p Context points to the class instance; /// holding the live string and numeric variables. \returns the class; /// representing the binary operation in the AST of the expression, or an; /// error holding a diagnostic against \p SM otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:490,Modifiability,variab,variables,490,"/// Parses and updates \p RemainingExpr for a binary operation at line; /// \p LineNumber, or before input is parsed if \p LineNumber is None. The; /// left operand of this binary operation is given in \p LeftOp and \p Expr; /// holds the string for the full expression, including the left operand.; /// Parameter \p IsLegacyLineExpr indicates whether we are parsing a legacy; /// @LINE expression. Parameter \p Context points to the class instance; /// holding the live string and numeric variables. \returns the class; /// representing the binary operation in the AST of the expression, or an; /// error holding a diagnostic against \p SM otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:412,Availability,error,error,412,"/// Parses a parenthesized expression inside \p Expr at line \p LineNumber, or; /// before input is parsed if \p LineNumber is None. \p Expr must start with; /// a '('. Accepts both literal values and numeric variables. Parameter \p; /// Context points to the class instance holding the live string and numeric; /// variables. \returns the class representing that operand in the AST of the; /// expression or an error holding a diagnostic against \p SM otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:209,Modifiability,variab,variables,209,"/// Parses a parenthesized expression inside \p Expr at line \p LineNumber, or; /// before input is parsed if \p LineNumber is None. \p Expr must start with; /// a '('. Accepts both literal values and numeric variables. Parameter \p; /// Context points to the class instance holding the live string and numeric; /// variables. \returns the class representing that operand in the AST of the; /// expression or an error holding a diagnostic against \p SM otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:316,Modifiability,variab,variables,316,"/// Parses a parenthesized expression inside \p Expr at line \p LineNumber, or; /// before input is parsed if \p LineNumber is None. \p Expr must start with; /// a '('. Accepts both literal values and numeric variables. Parameter \p; /// Context points to the class instance holding the live string and numeric; /// variables. \returns the class representing that operand in the AST of the; /// expression or an error holding a diagnostic against \p SM otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:424,Availability,error,error,424,"/// Parses \p Expr for an argument list belonging to a call to function \p; /// FuncName at line \p LineNumber, or before input is parsed if \p LineNumber; /// is None. Parameter \p FuncLoc is the source location used for diagnostics.; /// Parameter \p Context points to the class instance holding the live string; /// and numeric variables. \returns the class representing that call in the; /// AST of the expression or an error holding a diagnostic against \p SM; /// otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:331,Modifiability,variab,variables,331,"/// Parses \p Expr for an argument list belonging to a call to function \p; /// FuncName at line \p LineNumber, or before input is parsed if \p LineNumber; /// is None. Parameter \p FuncLoc is the source location used for diagnostics.; /// Parameter \p Context points to the class instance holding the live string; /// and numeric variables. \returns the class representing that call in the; /// AST of the expression or an error holding a diagnostic against \p SM; /// otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:172,Integrability,message,messages,172,"/// Hold the information about the DAG/NOT strings in the program, which are; /// not explicitly stored otherwise. This allows for better and more accurate; /// diagnostic messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:65,Availability,Error,Errors,65,/// Verifies that there is a single line in the given \p Buffer. Errors are; /// reported against \p SM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:62,Availability,Error,Errors,62,/// Verifies that there is no newline in the given \p Buffer. Errors are; /// reported against \p SM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:94,Availability,Error,Errors,94,/// Verifies that none of the strings in \p NotStrings are found in the given; /// \p Buffer. Errors are reported against \p SM and diagnostics recorded in; /// \p Diags according to the verbosity level set in \p Req.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp:195,Availability,avail,available,195,"/// Creates binary descriptor for the given device images. Binary descriptor; /// is an object that is passed to the offloading runtime at program startup; /// and it describes all device images available in the executable or shared; /// library. It is defined as follows; ///; /// __attribute__((visibility(""hidden""))); /// extern __tgt_offload_entry *__start_omp_offloading_entries;; /// __attribute__((visibility(""hidden""))); /// extern __tgt_offload_entry *__stop_omp_offloading_entries;; ///; /// static const char Image0[] = { <Bufs.front() contents> };; /// ...; /// static const char ImageN[] = { <Bufs.back() contents> };; ///; /// static const __tgt_device_image Images[] = {; /// {; /// Image0, /*ImageStart*/; /// Image0 + sizeof(Image0), /*ImageEnd*/; /// __start_omp_offloading_entries, /*EntriesBegin*/; /// __stop_omp_offloading_entries /*EntriesEnd*/; /// },; /// ...; /// {; /// ImageN, /*ImageStart*/; /// ImageN + sizeof(ImageN), /*ImageEnd*/; /// __start_omp_offloading_entries, /*EntriesBegin*/; /// __stop_omp_offloading_entries /*EntriesEnd*/; /// }; /// };; ///; /// static const __tgt_bin_desc BinDesc = {; /// sizeof(Images) / sizeof(Images[0]), /*NumDeviceImages*/; /// Images, /*DeviceImages*/; /// __start_omp_offloading_entries, /*HostEntriesBegin*/; /// __stop_omp_offloading_entries /*HostEntriesEnd*/; /// };; ///; /// Global variable that represents BinDesc is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp:1360,Modifiability,variab,variable,1360,"/// Creates binary descriptor for the given device images. Binary descriptor; /// is an object that is passed to the offloading runtime at program startup; /// and it describes all device images available in the executable or shared; /// library. It is defined as follows; ///; /// __attribute__((visibility(""hidden""))); /// extern __tgt_offload_entry *__start_omp_offloading_entries;; /// __attribute__((visibility(""hidden""))); /// extern __tgt_offload_entry *__stop_omp_offloading_entries;; ///; /// static const char Image0[] = { <Bufs.front() contents> };; /// ...; /// static const char ImageN[] = { <Bufs.back() contents> };; ///; /// static const __tgt_device_image Images[] = {; /// {; /// Image0, /*ImageStart*/; /// Image0 + sizeof(Image0), /*ImageEnd*/; /// __start_omp_offloading_entries, /*EntriesBegin*/; /// __stop_omp_offloading_entries /*EntriesEnd*/; /// },; /// ...; /// {; /// ImageN, /*ImageStart*/; /// ImageN + sizeof(ImageN), /*ImageEnd*/; /// __start_omp_offloading_entries, /*EntriesBegin*/; /// __stop_omp_offloading_entries /*EntriesEnd*/; /// }; /// };; ///; /// static const __tgt_bin_desc BinDesc = {; /// sizeof(Images) / sizeof(Images[0]), /*NumDeviceImages*/; /// Images, /*DeviceImages*/; /// __start_omp_offloading_entries, /*HostEntriesBegin*/; /// __stop_omp_offloading_entries /*HostEntriesEnd*/; /// };; ///; /// Global variable that represents BinDesc is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp:222,Modifiability,plugin,plugin,222,// Add this function to constructors.; // Set priority to 1 so that __tgt_register_lib is executed AFTER; // __tgt_register_requires (we want to know what requirements have been; // asked for before we load a libomptarget plugin so that by the time the; // plugin is loaded it can report how many devices there are which can; // satisfy these requirements).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp:257,Modifiability,plugin,plugin,257,// Add this function to constructors.; // Set priority to 1 so that __tgt_register_lib is executed AFTER; // __tgt_register_requires (we want to know what requirements have been; // asked for before we load a libomptarget plugin so that by the time the; // plugin is loaded it can report how many devices there are which can; // satisfy these requirements).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp:202,Performance,load,load,202,// Add this function to constructors.; // Set priority to 1 so that __tgt_register_lib is executed AFTER; // __tgt_register_requires (we want to know what requirements have been; // asked for before we load a libomptarget plugin so that by the time the; // plugin is loaded it can report how many devices there are which can; // satisfy these requirements).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp:267,Performance,load,loaded,267,// Add this function to constructors.; // Set priority to 1 so that __tgt_register_lib is executed AFTER; // __tgt_register_requires (we want to know what requirements have been; // asked for before we load a libomptarget plugin so that by the time the; // plugin is loaded it can report how many devices there are which can; // satisfy these requirements).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp:24,Integrability,wrap,wrapper,24,// Create the fatbinary wrapper,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp:17,Modifiability,variab,variable,17,// Create global variable registration code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp:18,Modifiability,variab,variable,18,// Create managed variable registration code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp:18,Modifiability,variab,variable,18,// Create surface variable registration code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp:18,Modifiability,variab,variable,18,// Create texture variable registration code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/OffloadWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/Utility.cpp:21,Integrability,interface,interface,21,// TODO: Rework this interface to be more generic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/Offloading/Utility.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/Utility.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/Utility.cpp:204,Modifiability,variab,variable,204,// We assume that external begin/end symbols that we have created above will; // be defined by the linker. This is done whenever a section name with a; // valid C-identifier is present. We define a dummy variable here to force; // the linker to always provide these symbols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/Offloading/Utility.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/Utility.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPContext.cpp:64,Availability,failure,failure,64,"// We missed a property, provide some debug output and indicate failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPContext.cpp:16,Usability,clear,clearly,16,// Check if its clearly not the best.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPContext.cpp:127,Availability,avail,available,127,// Special handling for `device={isa(...)}` as we accept anything here. It is; // up to the target to decide if the feature is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:20,Energy Efficiency,schedul,scheduling,20,"/// Determine which scheduling algorithm to use, determined from schedule clause; /// arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:65,Energy Efficiency,schedul,schedule,65,"/// Determine which scheduling algorithm to use, determined from schedule clause; /// arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:26,Energy Efficiency,schedul,schedule,26,"// Currently, the default schedule it static.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:36,Energy Efficiency,schedul,schedule,36,/// Adds ordering modifier flags to schedule type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:40,Energy Efficiency,schedul,schedule,40,/// Adds monotonicity modifier flags to schedule type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:81,Energy Efficiency,schedul,schedule,81,"// OpenMP 5.1, 2.11.4 Worksharing-Loop Construct, Description.; // If the static schedule kind is specified or if the ordered clause is; // specified, and if the nonmonotonic modifier is not specified, the; // effect is as if the monotonic modifier is specified. Otherwise, unless; // the monotonic modifier is specified, the effect is as if the; // nonmonotonic modifier is specified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:18,Energy Efficiency,schedul,schedule,18,/// Determine the schedule type using schedule and ordering clause arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:38,Energy Efficiency,schedul,schedule,38,/// Determine the schedule type using schedule and ordering clause arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:23,Deployability,update,updates,23,"// SetInsertPoint also updates the Builder's debug location, but we want to; // keep the one the Builder was configured to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:109,Modifiability,config,configured,109,"// SetInsertPoint also updates the Builder's debug location, but we want to; // keep the one the Builder was configured to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:23,Deployability,update,updates,23,"// SetInsertPoint also updates the Builder's debug location, but we want to; // keep the one the Builder was configured to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:109,Modifiability,config,configured,109,"// SetInsertPoint also updates the Builder's debug location, but we want to; // keep the one the Builder was configured to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:23,Deployability,update,updates,23,"// SetInsertPoint also updates the Builder's debug location, but we want to; // keep the one the Builder was configured to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:109,Modifiability,config,configured,109,"// SetInsertPoint also updates the Builder's debug location, but we want to; // keep the one the Builder was configured to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:57,Energy Efficiency,allocate,allocate,57,"// If we generate code for the target device, we need to allocate; // struct for aggregate params in the device default alloca address space.; // OpenMP runtime requires that the params of the extracted functions are; // passed as zero address space pointers. This flag ensures that; // CodeExtractor generates correct code for extracted functions; // which are used by OpenMP runtime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:120,Usability,simpl,simple,120,"// If we are in a cancellable parallel region, barriers are cancellation; // points.; // TODO: Check why we would force simple calls or to ignore the cancel flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:21,Testability,log,logic,21,"// The actual cancel logic is shared with others, e.g., cancel_barriers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:3,Deployability,Update,Update,3,// Update the insertion point and remove the terminator we introduced.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:546,Performance,optimiz,optimization,546,"// On top of the arrays that were filled up, the target offloading call; // takes as arguments the device id as well as the host pointer. The host; // pointer is used by the runtime library to identify the current target; // region, so it only has to be unique and not necessarily point to; // anything. It could be the pointer to the outlined function that; // implements the target region, but we aren't using that so that the; // compiler doesn't need to keep that, and could therefore inline the host; // function if proven worthwhile during optimization.; // From this point on, we need to have an ID of the target region defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:682,Availability,error,error,682,"// The target region is an outlined function launched by the runtime; // via calls to __tgt_target_kernel().; //; // Note that on the host and CPU targets, the runtime implementation of; // these calls simply call the outlined function without forking threads.; // The outlined functions themselves have runtime calls to; // __kmpc_fork_teams() and __kmpc_fork() for this purpose, codegen'd by; // the compiler in emitTeamsCall() and emitParallelCall().; //; // In contrast, on the NVPTX target, the implementation of; // __tgt_target_teams() launches a GPU kernel with the requested number; // of teams and threads so no additional calls to the runtime are required.; // Check the error code and execute the host version if required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:202,Usability,simpl,simply,202,"// The target region is an outlined function launched by the runtime; // via calls to __tgt_target_kernel().; //; // Note that on the host and CPU targets, the runtime implementation of; // these calls simply call the outlined function without forking threads.; // The outlined functions themselves have runtime calls to; // __kmpc_fork_teams() and __kmpc_fork() for this purpose, codegen'd by; // the compiler in emitTeamsCall() and emitParallelCall().; //; // In contrast, on the NVPTX target, the implementation of; // __tgt_target_teams() launches a GPU kernel with the requested number; // of teams and threads so no additional calls to the runtime are required.; // Check the error code and execute the host version if required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:47,Modifiability,variab,variables,47,// From the cancellation block we finalize all variables and go to the; // post finalization block that is known to the FiniCB callback.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:64,Energy Efficiency,allocate,allocated,64,// Add address space cast if array for storing arguments is not allocated; // in address space 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:3,Integrability,wrap,wrapper,3,/* wrapper function */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:10,Availability,redundant,redundant,10,// Remove redundant call to the outlined function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:10,Safety,redund,redundant,10,// Remove redundant call to the outlined function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:10,Availability,redundant,redundant,10,// Remove redundant call to the outlined function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:10,Safety,redund,redundant,10,// Remove redundant call to the outlined function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:57,Energy Efficiency,allocate,allocate,57,"// If we generate code for the target device, we need to allocate; // struct for aggregate params in the device default alloca address space.; // OpenMP runtime requires that the params of the extracted functions are; // passed as zero address space pointers. This flag ensures that extracted; // function arguments are declared in zero address space",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:268,Usability,simpl,simplify,268,// EntryBB; // |; // V; // PRegionEntryBB <- Privatization allocas are placed here.; // |; // V; // PRegionBodyBB <- BodeGen is invoked here.; // |; // V; // PRegPreFiniBB <- The block we will start finalization from.; // |; // V; // PRegionExitBB <- A common exit to simplify block collection.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:168,Performance,load,load,168,"// __kmpc_fork_call expects extra arguments as pointers. If the input; // already has a pointer type, everything is fine. Otherwise, store the; // value onto stack and load it back inside the to-be-outlined region. This; // will ensure only the pointer will be passed to the function.; // FIXME: if there are more than 15 trailing arguments, they must be; // additionally packed in a struct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:3,Performance,Load,Load,3,// Load back next to allocations in the to-be-outlined region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:251,Availability,avail,available,251,// Reset the inner alloca insertion as it will be used for loading the values; // wrapped into pointers before passing them into the to-be-outlined region.; // Configure it to insert immediately after the fake use of zero address so; // that they are available in the generated body and so that the; // OpenMP-related values (thread ID and zero address pointers) remain leading; // in the argument list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:82,Integrability,wrap,wrapped,82,// Reset the inner alloca insertion as it will be used for loading the values; // wrapped into pointers before passing them into the to-be-outlined region.; // Configure it to insert immediately after the fake use of zero address so; // that they are available in the generated body and so that the; // OpenMP-related values (thread ID and zero address pointers) remain leading; // in the argument list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:160,Modifiability,Config,Configure,160,// Reset the inner alloca insertion as it will be used for loading the values; // wrapped into pointers before passing them into the to-be-outlined region.; // Configure it to insert immediately after the fake use of zero address so; // that they are available in the generated body and so that the; // OpenMP-related values (thread ID and zero address pointers) remain leading; // in the argument list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:59,Performance,load,loading,59,// Reset the inner alloca insertion as it will be used for loading the values; // wrapped into pointers before passing them into the to-be-outlined region.; // Configure it to insert immediately after the fake use of zero address so; // that they are available in the generated body and so that the; // OpenMP-related values (thread ID and zero address pointers) remain leading; // in the argument list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:29,Modifiability,variab,variables,29,"// HasShareds is true if any variables are captured in the outlined region,; // false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:142,Security,access,accessed,142,// Argument - `sizeof_kmp_task_t` (TaskSize); // Tasksize refers to the size in bytes of kmp_task_t data structure; // including private vars accessed in task.; // TODO: add kmp_task_t_with_privates (privates),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:126,Modifiability,variab,variables,126,// Emit the @__kmpc_omp_task_alloc runtime call; // The runtime call returns a pointer to an area where the task captured; // variables must be copied before the task is run (TaskData),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:28,Modifiability,variab,variable,28,// Store the pointer to the variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:25,Modifiability,variab,variable,25,// Store the size of the variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:13,Integrability,depend,dependency,13,// Store the dependency kind,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:149,Energy Efficiency,reduce,reduces,149,// Populate the non-atomic reduction using the elementwise reduction function.; // This loads the elements from the global and private variables and reduces; // them before storing back the result to the global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:135,Modifiability,variab,variables,135,// Populate the non-atomic reduction using the elementwise reduction function.; // This loads the elements from the global and private variables and reduces; // them before storing back the result to the global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:211,Modifiability,variab,variable,211,// Populate the non-atomic reduction using the elementwise reduction function.; // This loads the elements from the global and private variables and reduces; // them before storing back the result to the global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:88,Performance,load,loads,88,// Populate the non-atomic reduction using the elementwise reduction function.; // This loads the elements from the global and private variables and reduces; // them before storing back the result to the global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:99,Performance,load,loads,99,// Populate the atomic reduction using the atomic elementwise reduction; // function. There are no loads/stores here because they will be happening; // inside the atomic elementwise reduction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:173,Modifiability,variab,variables,173,// Populate the outlined reduction function using the elementwise reduction; // function. Partial values are extracted from the type-erased array of; // pointers to private variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:79,Safety,avoid,avoid,79,// Emit the body content. We do it after connecting the loop to the CFG to; // avoid that the callback encounters degenerate BBs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:3,Safety,Avoid,Avoid,3,// Avoid incrementing past stop since it could overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:89,Energy Efficiency,schedul,scheduling,89,// Returns an LLVM function to call for initializing loop bounds using OpenMP; // static scheduling depending on `type`. Only i32 and i64 are supported by the; // runtime. Always interpret integers as unsigned similarly to; // CanonicalLoopInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:100,Integrability,depend,depending,100,// Returns an LLVM function to call for initializing loop bounds using OpenMP; // static scheduling depending on `type`. Only i32 and i64 are supported by the; // runtime. Always interpret integers as unsigned similarly to; // CanonicalLoopInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate space for computed loop bounds as expected by the ""init"" function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:120,Energy Efficiency,allocate,allocated,120,"// At the end of the preheader, prepare for calling the ""init"" function by; // storing the current loop bounds into the allocated space. A canonical loop; // always iterates from 0 to trip-count with step 1. Note that ""init"" expects; // and produces an inclusive upper bound.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:32,Deployability,update,update,32,"// Call the ""init"" function and update the trip count of the loop with the; // value it produced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:3,Deployability,Update,Update,3,"// Update all uses of the induction variable except the one in the condition; // block that compares it with the actual upper bound, and the increment in; // the latch block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:36,Modifiability,variab,variable,36,"// Update all uses of the induction variable except the one in the condition; // block that compares it with the actual upper bound, and the increment in; // the latch block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate space for computed loop bounds as expected by the ""init"" function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:9,Safety,Detect,Detect,9,// TODO: Detect overflow in ubsan or max-out with current tripcount.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:32,Deployability,update,update,32,"// Call the ""init"" function and update the trip count of the loop with the; // value it produced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:3,Performance,Load,Load,3,"// Load values written by the ""init"" function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:3,Deployability,Update,Update,3,"// Update all uses of the induction variable except the one in the condition; // block that compares it with the actual upper bound, and the increment in; // the latch block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:36,Modifiability,variab,variable,36,"// Update all uses of the induction variable except the one in the condition; // block that compares it with the actual upper bound, and the increment in; // the latch block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:92,Integrability,depend,depending,92,// Returns an LLVM function to call for executing an OpenMP static worksharing; // for loop depending on `type`. Only i32 and i64 are supported by the runtime.; // Always interpret integers as unsigned similarly to CanonicalLoopInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:27,Modifiability,variab,variable,27,// Insert new loop counter variable which will be used only in loop; // body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:37,Availability,redundant,redundant,37,// New loop counter instructions are redundant in the loop preheader when; // code generation for workshare loop is finshed. That's why mark them as; // ready for deletion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:37,Safety,redund,redundant,37,// New loop counter instructions are redundant in the loop preheader when; // code generation for workshare loop is finshed. That's why mark them as; // ready for deletion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:44,Modifiability,variab,variables,44,// Analyse loop body region. Find all input variables which are used inside; // loop body region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:112,Modifiability,variab,variable,112,"// We need to model loop body region as the function f(cnt, loop_arg).; // That's why we replace loop induction variable by the new counter; // which will be one of loop body function argument",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:31,Modifiability,variab,variable,31,// Make sure that loop counter variable is not merged into loop body; // function argument structure and it is passed as separate variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:130,Modifiability,variab,variable,130,// Make sure that loop counter variable is not merged into loop body; // function argument structure and it is passed as separate variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:249,Testability,log,logic,249,// PostOutline CB is invoked when loop body function is outlined and; // loop body is replaced by call to outlined function. We need to add; // call to OpenMP device rtl inside loop preheader. OpenMP device rtl; // function will handle loop control logic.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:92,Energy Efficiency,schedul,scheduling,92,/// Returns an LLVM function to call for initializing loop bounds using OpenMP; /// dynamic scheduling depending on `type`. Only i32 and i64 are supported by; /// the runtime. Always interpret integers as unsigned similarly to; /// CanonicalLoopInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:103,Integrability,depend,depending,103,/// Returns an LLVM function to call for initializing loop bounds using OpenMP; /// dynamic scheduling depending on `type`. Only i32 and i64 are supported by; /// the runtime. Always interpret integers as unsigned similarly to; /// CanonicalLoopInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:90,Energy Efficiency,schedul,scheduling,90,/// Returns an LLVM function to call for updating the next loop using OpenMP; /// dynamic scheduling depending on `type`. Only i32 and i64 are supported by; /// the runtime. Always interpret integers as unsigned similarly to; /// CanonicalLoopInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:101,Integrability,depend,depending,101,/// Returns an LLVM function to call for updating the next loop using OpenMP; /// dynamic scheduling depending on `type`. Only i32 and i64 are supported by; /// the runtime. Always interpret integers as unsigned similarly to; /// CanonicalLoopInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:80,Integrability,depend,depending,80,/// Returns an LLVM function to call for finalizing the dynamic loop using; /// depending on `type`. Only i32 and i64 are supported by the runtime. Always; /// interpret integers as unsigned similarly to CanonicalLoopInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate space for computed loop bounds as expected by the ""init"" function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:120,Energy Efficiency,allocate,allocated,120,"// At the end of the preheader, prepare for calling the ""init"" function by; // storing the current loop bounds into the allocated space. A canonical loop; // always iterates from 0 to trip-count with step 1. Note that ""init"" expects; // and produces an inclusive upper bound.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:88,Modifiability,variab,variables,88,"// Build the collapsed loop body code.; // Start with deriving the input loop induction variables from the collapsed; // one, using a divmod scheme. To preserve the original loops' order, the; // innermost loop use the least significant bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:46,Modifiability,variab,variable,46,"// Collect original trip counts and induction variable to be accessible by; // index. Also, the structure of the original loops is not preserved during; // the construction of the tiled loops, so do it before we scavenge the BBs of; // any original CanonicalLoopInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:61,Security,access,accessible,61,"// Collect original trip counts and induction variable to be accessible by; // index. Also, the structure of the original loops is not preserved during; // the construction of the tiled loops, so do it before we scavenge the BBs of; // any original CanonicalLoopInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:123,Usability,usab,usable,123,"// Collect the code between loop headers. These may contain SSA definitions; // that are used in the loop nest body. To be usable with in the innermost; // body, these BasicBlocks will be sunk into the loop nest body. That is,; // these instructions may be executed more often than before the tiling.; // TODO: It would be sufficient to only sink them into body of the; // corresponding tile loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:34,Modifiability,variab,variable,34,// Replace the original induction variable with an induction variable computed; // from the tile and floor induction variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:61,Modifiability,variab,variable,61,// Replace the original induction variable with an induction variable computed; // from the tile and floor induction variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:117,Modifiability,variab,variables,117,// Replace the original induction variable with an induction variable computed; // from the tile and floor induction variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:16,Security,access,access,16,/// Attach llvm.access.group metadata to the memref instructions of \p Block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:43,Security,access,access,43,// TODO: This instruction may already have access group from; // other pragmas e.g. #pragma clang loop vectorize. Append; // so that the existing metadata is not overwritten.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:128,Integrability,depend,dependences,128,"// In presence of finite 'safelen', it may be unsafe to mark all; // the memory instructions parallel, because loop-carried; // dependences of 'safelen' iterations are possible.; // If clause order(concurrent) is specified then the memory instructions; // are marked parallel even if 'safelen' is finite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:198,Performance,concurren,concurrent,198,"// In presence of finite 'safelen', it may be unsafe to mark all; // the memory instructions parallel, because loop-carried; // dependences of 'safelen' iterations are possible.; // If clause order(concurrent) is specified then the memory instructions; // are marked parallel even if 'safelen' is finite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:26,Safety,safe,safelen,26,"// In presence of finite 'safelen', it may be unsafe to mark all; // the memory instructions parallel, because loop-carried; // dependences of 'safelen' iterations are possible.; // If clause order(concurrent) is specified then the memory instructions; // are marked parallel even if 'safelen' is finite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:46,Safety,unsafe,unsafe,46,"// In presence of finite 'safelen', it may be unsafe to mark all; // the memory instructions parallel, because loop-carried; // dependences of 'safelen' iterations are possible.; // If clause order(concurrent) is specified then the memory instructions; // are marked parallel even if 'safelen' is finite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:144,Safety,safe,safelen,144,"// In presence of finite 'safelen', it may be unsafe to mark all; // the memory instructions parallel, because loop-carried; // dependences of 'safelen' iterations are possible.; // If clause order(concurrent) is specified then the memory instructions; // are marked parallel even if 'safelen' is finite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:285,Safety,safe,safelen,285,"// In presence of finite 'safelen', it may be unsafe to mark all; // the memory instructions parallel, because loop-carried; // dependences of 'safelen' iterations are possible.; // If clause order(concurrent) is specified then the memory instructions; // are marked parallel even if 'safelen' is finite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:7,Security,access,access,7,// Add access group metadata to memory-access instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:39,Security,access,access,39,// Add access group metadata to memory-access instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:43,Security,access,access,43,"// TODO: If the loop has existing parallel access metadata, have; // to combine two lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:17,Security,access,access,17,"// Use the above access group metadata to create loop level; // metadata, which should be distinct for each loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:23,Safety,safe,safelen,23,"// If both simdlen and safelen clauses are specified, the value of the; // simdlen parameter must be less than or equal to the value of the safelen; // parameter. Therefore, use safelen only in the absence of simdlen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:140,Safety,safe,safelen,140,"// If both simdlen and safelen clauses are specified, the value of the; // simdlen parameter must be less than or equal to the value of the safelen; // parameter. Therefore, use safelen only in the absence of simdlen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:178,Safety,safe,safelen,178,"// If both simdlen and safelen clauses are specified, the value of the; // simdlen parameter must be less than or equal to the value of the safelen; // parameter. Therefore, use safelen only in the absence of simdlen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:61,Performance,optimiz,optimization,61,"/// Create the TargetMachine object to query the backend for optimization; /// preferences.; ///; /// Ideally, this would be passed from the front-end to the OpenMPBuilder, but; /// e.g. Clang does not pass it to its CodeGen layer and creates it only when; /// needed for the LLVM pass pipline. We use some default options to avoid; /// having to pass too many settings from the frontend that probably do not; /// matter.; ///; /// Currently, TargetMachine is only used sometimes by the unrollLoopPartial; /// method. If we are going to use TargetMachine for more purposes, especially; /// those that are sensitive to TargetOptions, RelocModel and CodeModel, it; /// might become be worth requiring front-ends to pass on their TargetMachine,; /// or at least cache it between methods. Note that while fontends such as Clang; /// have just a single main TargetMachine per translation unit, ""target-cpu"" and; /// ""target-features"" that determine the TargetMachine are per-function and can; /// be overrided using __attribute__((target(""OPTIONS""))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:759,Performance,cache,cache,759,"/// Create the TargetMachine object to query the backend for optimization; /// preferences.; ///; /// Ideally, this would be passed from the front-end to the OpenMPBuilder, but; /// e.g. Clang does not pass it to its CodeGen layer and creates it only when; /// needed for the LLVM pass pipline. We use some default options to avoid; /// having to pass too many settings from the frontend that probably do not; /// matter.; ///; /// Currently, TargetMachine is only used sometimes by the unrollLoopPartial; /// method. If we are going to use TargetMachine for more purposes, especially; /// those that are sensitive to TargetOptions, RelocModel and CodeModel, it; /// might become be worth requiring front-ends to pass on their TargetMachine,; /// or at least cache it between methods. Note that while fontends such as Clang; /// have just a single main TargetMachine per translation unit, ""target-cpu"" and; /// ""target-features"" that determine the TargetMachine are per-function and can; /// be overrided using __attribute__((target(""OPTIONS""))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:326,Safety,avoid,avoid,326,"/// Create the TargetMachine object to query the backend for optimization; /// preferences.; ///; /// Ideally, this would be passed from the front-end to the OpenMPBuilder, but; /// e.g. Clang does not pass it to its CodeGen layer and creates it only when; /// needed for the LLVM pass pipline. We use some default options to avoid; /// having to pass too many settings from the frontend that probably do not; /// matter.; ///; /// Currently, TargetMachine is only used sometimes by the unrollLoopPartial; /// method. If we are going to use TargetMachine for more purposes, especially; /// those that are sensitive to TargetOptions, RelocModel and CodeModel, it; /// might become be worth requiring front-ends to pass on their TargetMachine,; /// or at least cache it between methods. Note that while fontends such as Clang; /// have just a single main TargetMachine per translation unit, ""target-cpu"" and; /// ""target-features"" that determine the TargetMachine are per-function and can; /// be overrided using __attribute__((target(""OPTIONS""))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:84,Integrability,depend,depends,84,/// Heuristically determine the best-performant unroll factor for \p CLI. This; /// depends on the target processor. We are re-using the same heuristics as the; /// LoopUnrollPass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:37,Performance,perform,performant,37,/// Heuristically determine the best-performant unroll factor for \p CLI. This; /// depends on the target processor. We are re-using the same heuristics as the; /// LoopUnrollPass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:95,Performance,optimiz,optimized,95,"// Assume the user requests the most aggressive unrolling, even if the rest of; // the code is optimized using a lower setting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:26,Performance,optimiz,optimizations,26,// Account for additional optimizations taking place before the LoopUnrollPass; // would unroll the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:61,Performance,optimiz,optimized,61,// Use normal unroll factors even if the rest of the code is optimized for; // size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:41,Modifiability,variab,variables,41,"// Assume that reads and writes to stack variables can be eliminated by; // Mem2Reg, SROA or LICM. That is, don't count them towards the loop body's; // size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate space for vector and generate alloc instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:40,Integrability,depend,depend,40,// Store the index value with offset in depend vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:86,Usability,clear,clear,86,"// If we are skipping the region of a non conditional, remove the exit; // block, and clear the builder's insertion point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:23,Deployability,configurat,configuration,23,// Manifest the launch configuration in the metadata matching the kernel; // environment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:23,Modifiability,config,configuration,23,// Manifest the launch configuration in the metadata matching the kernel; // environment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:3,Deployability,Update,Update,3,"// Update the ""maxntidx"" metadata for NVIDIA, or add it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:42,Availability,avail,available,42,// TODO: Read from backend annotations if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:113,Safety,avoid,avoids,113,"// If we don't require privatization of device pointers, we emit the body in; // between the runtime calls. This avoids duplicating the body code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite uses of input valus to parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:101,Security,access,access,101,"// Things like GEP's can come in the form of Constants. Constants and; // ConstantExpr's do not have access to the knowledge of what they're; // contained in, so we must dig a little to find an instruction so we can; // tell if they're used inside of the function we're outlining. We also; // replace the original constant expression with a new instruction; // equivalent; an instruction as it allows easy modification in the; // following loop, as we can now know the constant (instruction) is owned by; // our target function and replaceUsesOfWith can now be invoked on it; // (cannot do this with constants it seems). A brand new one also allows us; // to be cautious as it is perhaps possible the old expression was used; // inside of the function but exists and is used externally (unlikely by the; // nature of a Constant, but still).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:74,Modifiability,variab,variable,74,"// TODO: investigate the appropriate linkage type used for the global; // variable for possibly changing that to internal or private, or maybe; // create different versions of the function for different OMP internal; // variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:220,Modifiability,variab,variables,220,"// TODO: investigate the appropriate linkage type used for the global; // variable for possibly changing that to internal or private, or maybe; // create different versions of the function for different OMP internal; // variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:78,Safety,avoid,avoid,78,"// If there is no user-defined mapper, set the mapper array to nullptr to; // avoid an unnecessary data privatization",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:21,Modifiability,variab,variable,21,"// We need two index variable here since the size of ""Dims"" is the same as; // the size of Components, however, the size of offset, count, and stride is; // equal to the size of base declaration that is non-contiguous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:3,Safety,Detect,Detect,3,// Detect if we have any capture size requiring runtime evaluation of the; // size so that a constant array could be eventually used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:61,Safety,avoid,avoid,61,"// If the condition constant folds and can be elided, try to avoid emitting; // the condition and the dead arm of the if/else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:14,Performance,perform,perform,14,// We need to perform atomic op as integer,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:26,Performance,perform,perform,26,// We need to bitcast and perform atomic op as integers,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:66,Energy Efficiency,power,power,66,// TODO: handle the case where XElemTy is not byte-sized or not a power of 2; // or a complex datatype.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:6,Deployability,Update,UpdateExpr,6,"// If UpdateExpr is 'x' updated with some `expr` not based on 'x',; // 'x' is simply atomically rewritten with 'expr'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:24,Deployability,update,updated,24,"// If UpdateExpr is 'x' updated with some `expr` not based on 'x',; // 'x' is simply atomically rewritten with 'expr'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:78,Usability,simpl,simply,78,"// If UpdateExpr is 'x' updated with some `expr` not based on 'x',; // 'x' is simply atomically rewritten with 'expr'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:38,Security,expose,exposed,38,// Create all simple and struct types exposed by the runtime and remember; // the llvm::PointerTypes of them for easy access later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:118,Security,access,access,118,// Create all simple and struct types exposed by the runtime and remember; // the llvm::PointerTypes of them for easy access later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:14,Usability,simpl,simple,14,// Create all simple and struct types exposed by the runtime and remember; // the llvm::PointerTypes of them for easy access later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:32,Modifiability,variab,variables,32,// TODO: Add support for global variables on the device after declare target; // support.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:62,Modifiability,variab,variable,62,// Create function that emits metadata for each device global variable entry;,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:32,Modifiability,variab,variables,32,// Generate metadata for global variables. Each entry of this metadata; // contains:; // - Entry 0 -> Kind of this type of metadata (1).; // - Entry 1 -> Mangled name of the variable.; // - Entry 2 -> Declare target kind.; // - Entry 3 -> Order the entry was created.; // The first element of the metadata node is the kind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:174,Modifiability,variab,variable,174,// Generate metadata for global variables. Each entry of this metadata; // contains:; // - Entry 0 -> Kind of this type of metadata (1).; // - Entry 1 -> Mangled name of the variable.; // - Entry 2 -> Declare target kind.; // - Entry 3 -> Order the entry was created.; // The first element of the metadata node is the kind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:161,Modifiability,variab,variables,161,// Hidden or internal symbols on the device are not externally visible.; // We should not attempt to register them by creating an offloading; // entry. Indirect variables are handled separately on the device.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:79,Availability,down,down,79,// TODO: convert this to utilise the IRBuilder Config rather than; // a passed down argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:47,Modifiability,Config,Config,47,// TODO: convert this to utilise the IRBuilder Config rather than; // a passed down argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:102,Modifiability,variab,variables,102,// This is a workaround carried over from Clang which prevents undesired; // optimisation of internal variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:62,Availability,avail,available,62,"// Do not create a ""ref-variable"" if the original is not also available; // on the host.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:24,Modifiability,variab,variable,24,"// Do not create a ""ref-variable"" if the original is not also available; // on the host.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:4,Performance,Load,Loads,4,/// Loads all the offload entries information from the host IR; /// metadata.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:29,Performance,load,load,29,"// If we are in target mode, load the metadata from the host IR. This code has; // to match the metadata creation in createOffloadEntriesAndInfoMetadata().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:38,Availability,avail,available,38,// Update the EntryInfo with the next available count for this location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:3,Deployability,Update,Update,3,// Update the EntryInfo with the next available count for this location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:38,Availability,avail,available,38,// Update the EntryInfo with the next available count for this location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:3,Deployability,Update,Update,3,// Update the EntryInfo with the next available count for this location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:38,Performance,perform,perform,38,// Scan all target region entries and perform the provided action.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:38,Performance,perform,perform,38,// Scan all target region entries and perform the provided action.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:53,Deployability,update,updater,53,// Record all uses excluding those introduced by the updater. Uses by the; // CanonicalLoopInfo itself to keep track of the number of iterations are; // excluded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:11,Deployability,update,updater,11,// Run the updater that may introduce new uses,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:55,Deployability,update,updater,55,// Replace the old uses with the value returned by the updater.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:20,Usability,simpl,simple,20,// TODO: To support simple redirecting of the end of the body code that has; // multiple; introduce another auxiliary basic block like preheader and after.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/FuzzerCLI.cpp:9,Modifiability,Refactor,Refactor,9,// TODO: Refactor parts common with the 'handleExecNameEncodedBEOpts',MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FuzzMutate/FuzzerCLI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/FuzzerCLI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp:10,Modifiability,inherit,inherits,10,"// `Sink` inherits Blocks' terminator, `Source` will have a BranchInst; // directly jumps to `Sink`. Here, we have to create a new terminator for; // `Source`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp:71,Performance,perform,performance,71,// A deterministic alternative to SmallPtrSet with the same lookup; // performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp:101,Integrability,depend,dependencies,101,"// Shuffle these instructions using topological sort.; // Returns false if all current instruction's dependencies in this block have; // been shuffled. If so, this instruction can be shuffled too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp:11,Availability,alive,alive,11,// Get all alive instructions that depend on the current instruction.; // Takes Instruction* instead of index because the instruction is already; // shuffled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp:35,Integrability,depend,depend,35,// Get all alive instructions that depend on the current instruction.; // Takes Instruction* instead of index because the instruction is already; // shuffled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp:86,Modifiability,variab,variable,86,"// We need values for each phi in the block. Since there isn't a good way; // to do a variable number of input values currently, we just fill them; // with undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp:92,Safety,avoid,avoid,92,// TODO: Handle aggregates and vectors; // TODO: Support multiple indices.; // TODO: Try to avoid meaningless accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp:110,Security,access,accesses,110,// TODO: Handle aggregates and vectors; // TODO: Support multiple indices.; // TODO: Try to avoid meaningless accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp:53,Safety,avoid,avoid,53,"// Create indices at the start, end, and middle, but avoid dups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp:16,Safety,avoid,avoid,16,// TODO: Try to avoid undefined accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp:32,Security,access,accesses,32,// TODO: Try to avoid undefined accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp:16,Safety,avoid,avoid,16,// TODO: Try to avoid undefined accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp:32,Security,access,accesses,32,// TODO: Try to avoid undefined accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/RandomIRBuilder.cpp:33,Energy Efficiency,allocate,allocate,33,"/// TODO: For all Allocas, maybe allocate an array.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FuzzMutate/RandomIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/RandomIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/RandomIRBuilder.cpp:31,Performance,load,load,31,"// If we can find a pointer to load from, use it half the time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FuzzMutate/RandomIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/RandomIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/RandomIRBuilder.cpp:10,Performance,load,load,10,// Create load from the chosen pointer,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FuzzMutate/RandomIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/RandomIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/RandomIRBuilder.cpp:20,Performance,load,load,20,// Only sample this load if it really matches the descriptor,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FuzzMutate/RandomIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/RandomIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/RandomIRBuilder.cpp:30,Security,validat,validate,30,"// TODO: We could potentially validate these, but for now just leave indices; // alone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FuzzMutate/RandomIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/RandomIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/RandomIRBuilder.cpp:10,Energy Efficiency,allocate,allocate,10,/// TODO: allocate a new stack memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FuzzMutate/RandomIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/RandomIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/RandomIRBuilder.cpp:90,Performance,load,loads,90,// Invoke instructions sometimes produce valid pointers but currently; // we can't insert loads or stores from them,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/FuzzMutate/RandomIRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/RandomIRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:3,Usability,Simpl,Simple,3,// Simple struct to hold relevant .dynamic entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:3,Security,Hash,Hash,3,// Hash tables:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:220,Deployability,update,updated,220,"/// This initializes an ELF file header with information specific to a binary; /// dynamic shared object.; /// Offsets, indexes, links, etc. for section and program headers are just; /// zero-initialized as they will be updated elsewhere.; ///; /// @param ElfHeader Target ELFT::Ehdr to populate.; /// @param Machine Target architecture (e_machine from ELF specifications).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:19,Integrability,wrap,wraps,19,// This class just wraps StringTableBuilder for the purpose of adding a; // default constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:27,Availability,error,error,27,"/// This function takes an error, and appends a string of text to the end of; /// that error. Since ""appending"" to an Error isn't supported behavior of an; /// Error, this function technically creates a new error with the combined; /// message and consumes the old error.; ///; /// @param Err Source error.; /// @param After Text to append at the end of Err's error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:87,Availability,error,error,87,"/// This function takes an error, and appends a string of text to the end of; /// that error. Since ""appending"" to an Error isn't supported behavior of an; /// Error, this function technically creates a new error with the combined; /// message and consumes the old error.; ///; /// @param Err Source error.; /// @param After Text to append at the end of Err's error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:118,Availability,Error,Error,118,"/// This function takes an error, and appends a string of text to the end of; /// that error. Since ""appending"" to an Error isn't supported behavior of an; /// Error, this function technically creates a new error with the combined; /// message and consumes the old error.; ///; /// @param Err Source error.; /// @param After Text to append at the end of Err's error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:160,Availability,Error,Error,160,"/// This function takes an error, and appends a string of text to the end of; /// that error. Since ""appending"" to an Error isn't supported behavior of an; /// Error, this function technically creates a new error with the combined; /// message and consumes the old error.; ///; /// @param Err Source error.; /// @param After Text to append at the end of Err's error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:207,Availability,error,error,207,"/// This function takes an error, and appends a string of text to the end of; /// that error. Since ""appending"" to an Error isn't supported behavior of an; /// Error, this function technically creates a new error with the combined; /// message and consumes the old error.; ///; /// @param Err Source error.; /// @param After Text to append at the end of Err's error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:265,Availability,error,error,265,"/// This function takes an error, and appends a string of text to the end of; /// that error. Since ""appending"" to an Error isn't supported behavior of an; /// Error, this function technically creates a new error with the combined; /// message and consumes the old error.; ///; /// @param Err Source error.; /// @param After Text to append at the end of Err's error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:300,Availability,error,error,300,"/// This function takes an error, and appends a string of text to the end of; /// that error. Since ""appending"" to an Error isn't supported behavior of an; /// Error, this function technically creates a new error with the combined; /// message and consumes the old error.; ///; /// @param Err Source error.; /// @param After Text to append at the end of Err's error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:360,Availability,error,error,360,"/// This function takes an error, and appends a string of text to the end of; /// that error. Since ""appending"" to an Error isn't supported behavior of an; /// Error, this function technically creates a new error with the combined; /// message and consumes the old error.; ///; /// @param Err Source error.; /// @param After Text to append at the end of Err's error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:236,Integrability,message,message,236,"/// This function takes an error, and appends a string of text to the end of; /// that error. Since ""appending"" to an Error isn't supported behavior of an; /// Error, this function technically creates a new error with the combined; /// message and consumes the old error.; ///; /// @param Err Source error.; /// @param After Text to append at the end of Err's error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:366,Integrability,message,message,366,"/// This function takes an error, and appends a string of text to the end of; /// that error. Since ""appending"" to an Error isn't supported behavior of an; /// Error, this function technically creates a new error with the combined; /// message and consumes the old error.; ///; /// @param Err Source error.; /// @param After Text to append at the end of Err's error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:212,Availability,error,error,212,"// end anonymous namespace; /// This function behaves similarly to StringRef::substr(), but attempts to; /// terminate the returned StringRef at the first null terminator. If no null; /// terminator is found, an error is returned.; ///; /// @param Str Source string to create a substring from.; /// @param Offset The start index of the desired substring.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:127,Security,validat,validated,127,"/// This function populates a DynamicEntries struct using an ELFT::DynRange.; /// After populating the struct, the members are validated with; /// some basic correctness checks.; ///; /// @param Dyn Target DynamicEntries struct to populate.; /// @param DynTable Source dynamic table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:183,Integrability,InterFace,InterFace,183,/// This function opens a file for writing and then writes a binary ELF stub to; /// the file.; ///; /// @param FilePath File path for writing the ELF binary.; /// @param Stub Source InterFace Stub to generate a binary ELF stub from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:72,Testability,stub,stub,72,/// This function opens a file for writing and then writes a binary ELF stub to; /// the file.; ///; /// @param FilePath File path for writing the ELF binary.; /// @param Stub Source InterFace Stub to generate a binary ELF stub from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:171,Testability,Stub,Stub,171,/// This function opens a file for writing and then writes a binary ELF stub to; /// the file.; ///; /// @param FilePath File path for writing the ELF binary.; /// @param Stub Source InterFace Stub to generate a binary ELF stub from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:193,Testability,Stub,Stub,193,/// This function opens a file for writing and then writes a binary ELF stub to; /// the file.; ///; /// @param FilePath File path for writing the ELF binary.; /// @param Stub Source InterFace Stub to generate a binary ELF stub from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:223,Testability,stub,stub,223,/// This function opens a file for writing and then writes a binary ELF stub to; /// the file.; ///; /// @param FilePath File path for writing the ELF binary.; /// @param Stub Source InterFace Stub to generate a binary ELF stub from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:9,Testability,Stub,Stub,9,// Write Stub to memory first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:76,Safety,abort,abort,76,"// Compare Stub output with existing Stub file.; // If Stub file unchanged, abort updating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:11,Testability,Stub,Stub,11,"// Compare Stub output with existing Stub file.; // If Stub file unchanged, abort updating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:37,Testability,Stub,Stub,37,"// Compare Stub output with existing Stub file.; // If Stub file unchanged, abort updating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:55,Testability,Stub,Stub,55,"// Compare Stub output with existing Stub file.; // If Stub file unchanged, abort updating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:17,Integrability,wrap,wraps,17,// This function wraps the ELFT writeELFBinaryToFile() so writeBinaryStub(); // can be called without having to use ELFType templates directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/IFSHandler.cpp:28,Integrability,depend,depends,28,// The need for symbol size depends on the symbol type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/IFSHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/IFSHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/IFSHandler.cpp:58,Testability,stub,stub,58,// end namespace llvm; /// Attempt to determine if a Text stub uses target triple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/IFSHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/IFSHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/IFSHandler.cpp:2,Integrability,Wrap,WrapColumn,2,/*WrapColumn =*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/IFSHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/IFSHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/IFSHandler.cpp:19,Availability,error,error,19,// TODO: unify the error message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/IFSHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/IFSHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/IFSHandler.cpp:25,Integrability,message,message,25,// TODO: unify the error message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/InterfaceStub/IFSHandler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/IFSHandler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AbstractCallSite.cpp:440,Integrability,interface,interface,440,"//===-- AbstractCallSite.cpp - Implementation of abstract call sites ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements abstract call sites which unify the interface for; // direct, indirect, and callback call sites.; //; // For more information see:; // https://llvm.org/devmtg/2018-10/talk-abstracts.html#talk20; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AbstractCallSite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AbstractCallSite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:610,Availability,toler,tolerant,610,"//===- AsmWriter.cpp - Printing LLVM as an assembly file ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This library implements `print` family of functions in classes like; // Module, Function, Value, etc. In-memory representation of those classes is; // converted to IR strings.; //; // Note that these routines must be extremely tolerant of various errors in the; // LLVM code, because it can be used for debugging transformations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:630,Availability,error,errors,630,"//===- AsmWriter.cpp - Printing LLVM as an assembly file ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This library implements `print` family of functions in classes like; // Module, Function, Value, etc. In-memory representation of those classes is; // converted to IR strings.; //; // Note that these routines must be extremely tolerant of various errors in the; // LLVM code, because it can be used for debugging transformations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:583,Integrability,rout,routines,583,"//===- AsmWriter.cpp - Printing LLVM as an assembly file ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This library implements `print` family of functions in classes like; // Module, Function, Value, etc. In-memory representation of those classes is; // converted to IR strings.; //; // Note that these routines must be extremely tolerant of various errors in the; // LLVM code, because it can be used for debugging transformations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:35,Integrability,wrap,wrapped,35,"/// Look for a value that might be wrapped as metadata, e.g. a value in a; /// metadata operand. Returns the input value as-is if it is not wrapped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:140,Integrability,wrap,wrapped,140,"/// Look for a value that might be wrapped as metadata, e.g. a value in a; /// metadata operand. Returns the input value as-is if it is not wrapped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:19,Performance,cache,cache,19,"// Note: we cannot cache this lookup above, since inserting into the map; // changes the map's size, and thus affects the other IDs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:3,Safety,Predict,Predict,3,// Predict use-list order for this one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:176,Testability,assert,assert,176,"// By making this unsigned, the value passed in to isalnum will always be; // in the range 0-255. This is important when building with MSVC because; // its implementation will assert. This situation can arise when dealing; // with UTF-8 multibyte characters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:115,Usability,simpl,simple,115,"/// Turn the specified name into an 'LLVM name', which is either prefixed with %; /// (if the string only contains simple characters) or is surrounded with """"'s; /// (if it has special chars in it). Print it out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:115,Usability,simpl,simple,115,"/// Turn the specified name into an 'LLVM name', which is either prefixed with %; /// (if the string only contains simple characters) or is surrounded with """"'s; /// (if it has special chars in it). Print it out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:4,Usability,GUID,GUIDMap,4,/// GUIDMap - The slot map for GUIDs used in the summary index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:31,Usability,GUID,GUIDs,31,/// GUIDMap - The slot map for GUIDs used in the summary index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:4,Usability,GUID,GUID,4,/// GUID map iterators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:39,Modifiability,variab,variables,39,"/// Add all of the module level global variables (and their initializers); /// and function declarations, but not the contents of those functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:21,Energy Efficiency,allocate,allocated,21,// Returns number of allocated slots,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:34,Modifiability,variab,variables,34,"// Iterate through all the global variables, functions, and global; // variable initializers and create slots for them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:71,Modifiability,variab,variable,71,"// Iterate through all the global variables, functions, and global; // variable initializers and create slots for them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:33,Modifiability,variab,variables,33,// Add all of the unnamed global variables to the value table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:106,Performance,optimiz,optimizer,106,"// We allow direct calls to any llvm.foo function here, because the; // target may not be linked into the optimizer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:27,Usability,GUID,GUID,27,// Iterate through all the GUID in the index and create slots for them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:23,Usability,GUID,GUIDs,23,// Start numbering the GUIDs after the module ids.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:57,Usability,GUID,GUIDs,57,// Start numbering the TypeIdCompatibleVtables after the GUIDs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:3,Usability,Simpl,Simply,3,// Simply discard the function level map,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:12,Usability,GUID,GUID,12,// Find the GUID in the map,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:40,Usability,GUID,GUID,40,/// Create a new slot for the specified GUID,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:130,Performance,load,loading,130,"// Otherwise we could not reparse it to exactly the same value, so we must; // output the string in hexadecimal format! Note that loading and storing; // floating point types changes the bits of NaNs on some hosts, notably; // x86, so we must not use these types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:134,Usability,clear,clear,134,"// A signaling NaN is quieted on conversion, so we need to recreate the; // expected value after convert (quiet bit of the payload is clear).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:24,Security,checksum,checksum,24,"// Print all values for checksum together, or not at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:4,Integrability,Synchroniz,Synchronization,4,/// Synchronization scope names registered with LLVMContext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:99,Deployability,update,update,99,// FIXME: Change AliasSummary to hold a ValueInfo instead of summary pointer; // for aliasee (then update BitcodeWriter.cpp and remove get/setAliaseeGUID).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:92,Safety,avoid,avoid,92,"// Follow the convention of emitting flags as a boolean value, but only; // emit if true to avoid unnecessary verbosity and test churn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:124,Testability,test,test,124,"// Follow the convention of emitting flags as a boolean value, but only; // emit if true to avoid unnecessary verbosity and test churn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:45,Usability,GUID,GUID,45,// Print all type id that correspond to this GUID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:45,Usability,GUID,GUID,45,// Print all type id that correspond to this GUID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:100,Usability,Simpl,Simply,100,/// printArgument - This member is called for every argument that is passed into; /// the function. Simply print it out,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:19,Availability,avail,available,19,"// Output name, if available...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:24,Performance,load,load,24,"// If this is an atomic load or store, print out the atomic marker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:13,Performance,optimiz,optimization,13,// Print out optimization information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:80,Availability,toler,tolerant,80,"// note that Operand shouldn't be null, but the test helps make dump(); // more tolerant of malformed IR",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:48,Testability,test,test,48,"// note that Operand shouldn't be null, but the test helps make dump(); // more tolerant of malformed IR",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:94,Integrability,Interface,Interface,94,//===----------------------------------------------------------------------===//; // External Interface declarations; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Assumptions.cpp:425,Security,access,accessing,425,"//===- Assumptions.cpp ------ Collection of helpers for assumptions -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements helper functions for accessing assumption infomration; // inside of the ""llvm.assume"" metadata.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Assumptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Assumptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h:50,Availability,avail,available,50,"// AttributesImpl is uniqued, these should not be available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h:350,Integrability,depend,dependent,350,"//===----------------------------------------------------------------------===//; /// \class; /// A set of classes that contain the value of the; /// attribute object. There are three main categories: enum attribute entries,; /// represented by Attribute::AttrKind; alignment attribute entries; and string; /// attribute enties, which are for target-dependent attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h:31,Availability,avail,available,31,/// Bitset with a bit for each available attribute Attribute::AttrKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h:5,Availability,Avail,Available,5,///< Available enum attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h:53,Availability,avail,available,53,"// AttributesSetNode is uniqued, these should not be available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h:41,Availability,Avail,Available,41,///< Number of entries in this set.; /// Available enum function attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h:29,Availability,avail,available,29,/// Union of enum attributes available at any index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h:53,Availability,avail,available,53,"// AttributesSetImpt is uniqued, these should not be available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AttributeImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp:95,Security,Access,Accessor,95,//===----------------------------------------------------------------------===//; // Attribute Accessor Methods; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Attributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp:9,Security,access,access,9,"// Print access kind for ""other"" as the default access kind. This way it; // will apply to any new location kinds that get split out of ""other"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Attributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp:48,Security,access,access,48,"// Print access kind for ""other"" as the default access kind. This way it; // will apply to any new location kinds that get split out of ""other"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Attributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp:18,Integrability,depend,dependent,18,"// Convert target-dependent attributes to strings of the form:; //; // ""kind""; // ""kind"" = ""value""; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Attributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp:303,Integrability,wrap,wraps,303,"//===----------------------------------------------------------------------===//; // AttributeListImpl Definition; //===----------------------------------------------------------------------===//; /// Map from AttributeList index to the internal array index. Adding one happens; /// to work, because -1 wraps around to 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Attributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp:14,Availability,Avail,AvailableFunctionAttrs,14,// Initialize AvailableFunctionAttrs and AvailableSomewhereAttrs; // summary bitsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Attributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp:41,Availability,Avail,AvailableSomewhereAttrs,41,// Initialize AvailableFunctionAttrs and AvailableSomewhereAttrs; // summary bitsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Attributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp:40,Safety,avoid,avoid,40,// TODO: Insert at correct position and avoid sort.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Attributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp:99,Security,Access,Accessor,99,//===----------------------------------------------------------------------===//; // AttributeList Accessor Methods; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Attributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp:16,Testability,log,logical,16,/// Compute the logical AND of the attributes of the caller and the; /// callee.; ///; /// This function sets the caller's attribute to false if the callee's attribute; /// is false.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Attributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp:16,Testability,log,logical,16,/// Compute the logical OR of the attributes of the caller and the; /// callee.; ///; /// This function sets the caller's attribute to true if the callee's attribute; /// is true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Attributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp:35,Usability,clear,clear,35,"// If upgrading the SSP attribute, clear out the old SSP Attributes first.; // Having multiple SSP attributes doesn't actually hurt, but it adds useless; // clutter to the IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Attributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:41,Deployability,upgrade,upgrade,41,"//===-- AutoUpgrade.cpp - Implement auto-upgrade helper functions ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the auto-upgrade helper functions.; // This is where deprecated IR intrinsics and other IR features are updated to; // current specifications.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:413,Deployability,upgrade,upgrade,413,"//===-- AutoUpgrade.cpp - Implement auto-upgrade helper functions ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the auto-upgrade helper functions.; // This is where deprecated IR intrinsics and other IR features are updated to; // current specifications.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:508,Deployability,update,updated,508,"//===-- AutoUpgrade.cpp - Implement auto-upgrade helper functions ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the auto-upgrade helper functions.; // This is where deprecated IR intrinsics and other IR features are updated to; // current specifications.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade the declarations of the SSE4.1 ptest intrinsics whose arguments have; // changed their type from v4f32 to v2i64.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:73,Availability,mask,mask,73,// Upgrade the declarations of intrinsic functions whose 8-bit immediate mask; // arguments have changed their type from i32 to i8.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade the declarations of intrinsic functions whose 8-bit immediate mask; // arguments have changed their type from i32 to i8.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:36,Availability,down,down,36,// Move this function aside and map down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:100,Availability,mask,mask,100,// Upgrade the declaration of fp compare intrinsics that change return type; // from scalar to vXi1 mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade the declaration of fp compare intrinsics that change return type; // from scalar to vXi1 mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:192,Deployability,upgrade,upgrade,192,// All of the intrinsics matches below should be marked with which llvm; // version started autoupgrading them. At some point in the future we would; // like to use this information to remove upgrade code for some older; // intrinsics. It is currently undecided how we will determine that future; // point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:11,Availability,mask,mask,11,// 'avx512.mask.*',MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:16,Deployability,update,updated,16,// Added in 7.0 updated 9.0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:16,Deployability,update,updated,16,// Added in 7.0 updated 9.0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:16,Deployability,update,updated,16,// Added in 7.0 updated 9.0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:16,Deployability,update,updated,16,// Added in 7.0 updated 9.0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:11,Availability,mask,maskz,11,// 'avx512.maskz.*',MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:17,Deployability,Update,Updated,17,"// Added in 3.2, Updated in 9.0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:45,Availability,mask,masks,45,// Several blend and other instructions with masks used the wrong number of; // bits.; // Added in 3.6,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:24,Availability,mask,mask,24,// No other 'x86.avx523.mask.cmp.*'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:20,Deployability,Upgrade,Upgrade,20,// Added in 3.9; // Upgrade any XOP PERMIL2 index operand still using a float/double; // vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:3,Deployability,Upgrade,Upgrade,3,"// Upgrade ARM (IsArm) or Aarch64 (!IsArm) intrinsic fns. Return true iff so.; // IsArm: 'arm.*', !IsArm: 'aarch64.*'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:56,Modifiability,polymorphi,polymorphic,56,"// Changed in 12.0: bfmmla, bfmlalb and bfmlalt are not polymorphic; // anymore and accept v8bf16 instead of v16i8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:110,Deployability,Upgrade,UpgradeIntrinsicCall,110,// A vctp64 returning a v4i1 is converted to return a v2i1. Rename; // the function and deal with it below in UpgradeIntrinsicCall.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:36,Availability,redundant,redundant,36,// Target specific intrinsic became redundant,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:36,Safety,redund,redundant,36,// Target specific intrinsic became redundant,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:36,Availability,redundant,redundant,36,// Target specific intrinsic became redundant,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:36,Safety,redund,redundant,36,// Target specific intrinsic became redundant,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:32,Energy Efficiency,reduce,reduce,32,// No other 'expermental.vector.reduce.*'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:123,Deployability,Upgrade,UpgradeIntrinsicCall,123,"// The following nvvm intrinsics correspond exactly to an LLVM idiom, but; // not to an intrinsic alone. We expand them in UpgradeIntrinsicCall.; //; // TODO: We could add lohi.i2d.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:15,Performance,load,load,15,"// nvvm.atomic.load.add.{f32.p,f64.p}",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:23,Deployability,upgrade,upgrades,23,// No other applicable upgrades.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:23,Deployability,upgrade,upgrades,23,// No other applicable upgrades.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:23,Deployability,upgrade,upgrades,23,// No other applicable upgrades.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:35,Deployability,upgrade,upgrade,35,// Remangle our intrinsic since we upgrade the mangling,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:153,Deployability,upgrade,upgraded,153,"// This may not belong here. This function is effectively being overloaded; // to both detect an intrinsic which needs upgrading, and to provide the; // upgraded form of the intrinsic. We should perhaps have two separate; // functions for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:87,Safety,detect,detect,87,"// This may not belong here. This function is effectively being overloaded; // to both detect an intrinsic which needs upgrading, and to provide the; // upgraded form of the intrinsic. We should perhaps have two separate; // functions for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade intrinsic attributes. This does not change the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:66,Availability,mask,mask,66,"// If we have less than 8 elements (1, 2 or 4), then the starting mask was an; // i8 and we need to extract down to the right number of elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:108,Availability,down,down,108,"// If we have less than 8 elements (1, 2 or 4), then the starting mask was an; // i8 and we need to extract down to the right number of elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,// If the mask is all ones just emit the first operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,// If the mask is all ones just emit the first operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:26,Availability,mask,masked,26,// Handle autoupgrade for masked PALIGNR and VALIGND/Q intrinsics.; // PALIGNR handles large immediates by shifting while VALIGN masks the immediate; // so we need to handle both cases. VALIGN also doesn't have 128-bit lanes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:129,Availability,mask,masks,129,// Handle autoupgrade for masked PALIGNR and VALIGND/Q intrinsics.; // PALIGNR handles large immediates by shifting while VALIGN masks the immediate; // so we need to handle both cases. VALIGN also doesn't have 128-bit lanes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:3,Availability,Mask,Mask,3,// Mask the immediate for VALIGN.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:11,Integrability,wrap,wrap,11,// Disable wrap for VALIGN.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:7,Availability,mask,masked,7,// For masked intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:138,Energy Efficiency,power,power-of-,138,"// Amount may be scalar immediate, in which case create a splat vector.; // Funnel shifts amounts are treated as modulo and types are all power-of-2 so; // we only care about the lowest log2 bits anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:7,Availability,mask,masked,7,// For masked intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:138,Energy Efficiency,power,power-of-,138,"// Amount may be scalar immediate, in which case create a splat vector.; // Funnel shifts amounts are treated as modulo and types are all power-of-2 so; // we only care about the lowest log2 bits anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:7,Availability,mask,masked,7,// For masked intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,// If the mask is all ones just emit a regular store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:15,Availability,mask,mask,15,// Convert the mask from an integer type to a vector of i1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,// If the mask is all ones just emit a regular store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:15,Availability,mask,mask,15,// Convert the mask from an integer type to a vector of i1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:3,Usability,Clear,Clear,3,// Clear the upper bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:12,Availability,mask,mask,12,// Applying mask on vector of i1's and make sure result is at least 8 bits wide.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:13,Availability,mask,masked,13,// Replace a masked intrinsic with an older unmasked intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:17,Availability,mask,mask,17,// Remove avx512.mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:4,Deployability,Upgrade,Upgrade,4,/// Upgrade comment in call to inline asm that represents an objc retain release; /// marker.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:73,Deployability,release,release,73,/// Upgrade comment in call to inline asm that represents an objc retain release; /// marker.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:4,Deployability,Upgrade,Upgrade,4,/// Upgrade a call to an old intrinsic. All argument and return casting must be; /// provided to seamlessly integrate with existing context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:108,Deployability,integrat,integrate,108,/// Upgrade a call to an old intrinsic. All argument and return casting must be; /// provided to seamlessly integrate with existing context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:108,Integrability,integrat,integrate,108,/// Upgrade a call to an old intrinsic. All argument and return casting must be; /// provided to seamlessly integrate with existing context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:11,Availability,mask,mask,11,"// ""avx512.mask.storeu."" or ""avx512.mask.store.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:36,Availability,mask,mask,36,"// ""avx512.mask.storeu."" or ""avx512.mask.store.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:11,Availability,mask,mask,11,"// ""avx512.mask.storeu"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade packed integer vector compare intrinsics to compare instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:11,Availability,mask,mask,11,"// ""avx512.mask.pcmpeq."" or ""avx512.mask.pcmpgt.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:36,Availability,mask,mask,36,"// ""avx512.mask.pcmpeq."" or ""avx512.mask.pcmpgt.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:11,Availability,mask,mask,11,"// ""avx512.mask.loadu."" or ""avx512.mask.load.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:35,Availability,mask,mask,35,"// ""avx512.mask.loadu."" or ""avx512.mask.load.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:16,Performance,load,loadu,16,"// ""avx512.mask.loadu."" or ""avx512.mask.load.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:40,Performance,load,load,40,"// ""avx512.mask.loadu."" or ""avx512.mask.load.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:11,Availability,mask,mask,11,"// ""avx512.mask.loadu"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:16,Performance,load,loadu,16,"// ""avx512.mask.loadu"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:67,Modifiability,extend,extend,67,// Extract a subvector of the first NumDstElts lanes and sign/zero extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:36,Availability,mask,masked,36,"// If there are 3 arguments, it's a masked intrinsic so we need a select.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:55,Performance,load,load,55,// Replace vbroadcastf128/vbroadcasti128 with a vector load+shuffle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:3,Availability,Mask,Mask,3,// Mask off the high bits of the immediate value; hardware ignores those.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:3,Modifiability,Extend,Extend,3,// Extend the second operand into a vector the size of the destination.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:319,Availability,mask,mask,319,"// Insert the second operand into the first operand.; // Note that there is no guarantee that instruction lowering will actually; // produce a vinsertf128 instruction for the created shuffles. In; // particular, the 0 immediate case involves no lane changes, so it can; // be handled as a blend.; // Example of shuffle mask for 32-bit elements:; // Imm = 1 <i32 0, i32 1, i32 2, i32 3, i32 8, i32 9, i32 10, i32 11>; // Imm = 0 <i32 8, i32 9, i32 10, i32 11, i32 4, i32 5, i32 6, i32 7 >; // First fill with identify mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:517,Availability,mask,mask,517,"// Insert the second operand into the first operand.; // Note that there is no guarantee that instruction lowering will actually; // produce a vinsertf128 instruction for the created shuffles. In; // particular, the 0 immediate case involves no lane changes, so it can; // be handled as a blend.; // Example of shuffle mask for 32-bit elements:; // Imm = 1 <i32 0, i32 1, i32 2, i32 3, i32 8, i32 9, i32 10, i32 11>; // Imm = 0 <i32 8, i32 9, i32 10, i32 11, i32 4, i32 5, i32 6, i32 7 >; // First fill with identify mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:26,Availability,mask,mask,26,"// If the intrinsic has a mask operand, handle that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:3,Availability,Mask,Mask,3,// Mask off the high bits of the immediate value; hardware ignores those.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:26,Availability,mask,mask,26,"// If the intrinsic has a mask operand, handle that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:45,Availability,mask,mask,45,"// If needed, replace operands based on zero mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:37,Integrability,wrap,wrapping,37,"// Lookup the bits for this element, wrapping around the immediate every; // 8-bits. Elements are grouped into sets of 2 or 4 elements so we need; // to offset by the first index of each group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:88,Integrability,Wrap,Wrapping,88,// Now select the specific element. By adding HalfLaneElts bits from; // the immediate. Wrapping around the immediate every 8-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,// avx512.mask.psllv2.di,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,// avx512.mask.psllv4.di,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,// avx512.mask.psllv4.si,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,// avx512.mask.psllv8.si,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,// avx512.mask.psllv8.hi,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,// avx512.mask.psllv16.hi,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,// avx512.mask.psllv32hi,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,"// avx512.mask.psll.d.128, avx512.mask.psll.di.128",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:34,Availability,mask,mask,34,"// avx512.mask.psll.d.128, avx512.mask.psll.di.128",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,"// avx512.mask.psll.q.128, avx512.mask.psll.qi.128",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:34,Availability,mask,mask,34,"// avx512.mask.psll.q.128, avx512.mask.psll.qi.128",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,"// avx512.mask.psll.w.128, avx512.mask.psll.wi.128",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:34,Availability,mask,mask,34,"// avx512.mask.psll.w.128, avx512.mask.psll.wi.128",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,"// avx512.mask.psll.d.256, avx512.mask.psll.di.256",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:34,Availability,mask,mask,34,"// avx512.mask.psll.d.256, avx512.mask.psll.di.256",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,"// avx512.mask.psll.q.256, avx512.mask.psll.qi.256",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:34,Availability,mask,mask,34,"// avx512.mask.psll.q.256, avx512.mask.psll.qi.256",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,"// avx512.mask.psll.w.256, avx512.mask.psll.wi.256",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:34,Availability,mask,mask,34,"// avx512.mask.psll.w.256, avx512.mask.psll.wi.256",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,// avx512.mask.psrlv2.di,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,// avx512.mask.psrlv4.di,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,// avx512.mask.psrlv4.si,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,// avx512.mask.psrlv8.si,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,// avx512.mask.psrlv8.hi,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,// avx512.mask.psrlv16.hi,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,// avx512.mask.psrlv32hi,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,"// avx512.mask.psrl.d.128, avx512.mask.psrl.di.128",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:34,Availability,mask,mask,34,"// avx512.mask.psrl.d.128, avx512.mask.psrl.di.128",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,"// avx512.mask.psrl.q.128, avx512.mask.psrl.qi.128",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:34,Availability,mask,mask,34,"// avx512.mask.psrl.q.128, avx512.mask.psrl.qi.128",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,"// avx512.mask.psrl.w.128, avx512.mask.psrl.wi.128",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:34,Availability,mask,mask,34,"// avx512.mask.psrl.w.128, avx512.mask.psrl.wi.128",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,"// avx512.mask.psrl.d.256, avx512.mask.psrl.di.256",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:34,Availability,mask,mask,34,"// avx512.mask.psrl.d.256, avx512.mask.psrl.di.256",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,"// avx512.mask.psrl.q.256, avx512.mask.psrl.qi.256",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:34,Availability,mask,mask,34,"// avx512.mask.psrl.q.256, avx512.mask.psrl.qi.256",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,"// avx512.mask.psrl.w.256, avx512.mask.psrl.wi.256",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:34,Availability,mask,mask,34,"// avx512.mask.psrl.w.256, avx512.mask.psrl.wi.256",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,// avx512.mask.psrav4.si,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,// avx512.mask.psrav8.si,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,// avx512.mask.psrav8.hi,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,// avx512.mask.psrav16.hi,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,// avx512.mask.psrav32hi,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,"// avx512.mask.psra.d.128, avx512.mask.psra.di.128",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:34,Availability,mask,mask,34,"// avx512.mask.psra.d.128, avx512.mask.psra.di.128",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,"// avx512.mask.psra.q.128, avx512.mask.psra.qi.128",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:34,Availability,mask,mask,34,"// avx512.mask.psra.q.128, avx512.mask.psra.qi.128",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,"// avx512.mask.psra.w.128, avx512.mask.psra.wi.128",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:34,Availability,mask,mask,34,"// avx512.mask.psra.w.128, avx512.mask.psra.wi.128",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,"// avx512.mask.psra.d.256, avx512.mask.psra.di.256",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:34,Availability,mask,mask,34,"// avx512.mask.psra.d.256, avx512.mask.psra.di.256",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,"// avx512.mask.psra.q.256, avx512.mask.psra.qi.256",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:34,Availability,mask,mask,34,"// avx512.mask.psra.q.256, avx512.mask.psra.qi.256",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:10,Availability,mask,mask,10,"// avx512.mask.psra.w.256, avx512.mask.psra.wi.256",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:34,Availability,mask,mask,34,"// avx512.mask.psra.w.256, avx512.mask.psra.wi.256",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:20,Availability,mask,mask,20,"// Drop the ""avx512.mask."" to make it easier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:74,Safety,avoid,avoids,74,"// For Mask3 with NegAcc, we need to create a new extractelement that; // avoids the negation above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:20,Availability,mask,mask,20,"// Drop the ""avx512.mask."" to make it easier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:20,Availability,mask,mask,20,"// Drop the ""avx512.mask."" to make it easier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:15,Deployability,update,updated,15,// Rep will be updated by the call in the condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:19,Deployability,upgrade,upgrade,19,// This must be an upgrade from a named to a literal struct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:19,Deployability,Upgrade,Upgrade,19,// Strip llvm.; // Upgrade `dbg.addr` to `dbg.value` with `DW_OP_deref`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade from the old version that had an extra offset argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:49,Deployability,upgrade,upgrade,49,// Drop nonzero offsets instead of attempting to upgrade them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade from versions that lacked the annotation attribute argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade from versions that lacked the annotation attribute argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:77,Deployability,upgrade,upgraded,77,"// This used to take 1 arguments. If we have no arguments, it is already; // upgraded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:36,Deployability,upgrade,upgraded,36,// Check if this function should be upgraded and get the replacement function; // if there is one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:31,Availability,error,error,31,"// Invalid, punt to a verifier error.; // Check if the tag uses struct-path aware TBAA format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:32,Deployability,release,release,32,/// This checks for objc retain release marker which should be upgraded. It; /// returns true if module is modified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:63,Deployability,upgrade,upgraded,63,/// This checks for objc retain release marker which should be upgraded. It; /// returns true if module is modified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:9,Deployability,upgrade,upgrade,9,// Don't upgrade the intrinsic if it's not valid to bitcast the return; // value to the return type of the old function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:9,Deployability,upgrade,upgrade,9,// Don't upgrade the intrinsic if it's not valid to bitcast the argument; // to the parameter type of the new function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:3,Deployability,Upgrade,Upgrade,3,"// Upgrade the retain release marker. If there is no need to upgrade; // the marker, that means either the module is already new enough to contain; // new intrinsics or it is not ARC. There is no need to upgrade runtime call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:22,Deployability,release,release,22,"// Upgrade the retain release marker. If there is no need to upgrade; // the marker, that means either the module is already new enough to contain; // new intrinsics or it is not ARC. There is no need to upgrade runtime call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:61,Deployability,upgrade,upgrade,61,"// Upgrade the retain release marker. If there is no need to upgrade; // the marker, that means either the module is already new enough to contain; // new intrinsics or it is not ARC. There is no need to upgrade runtime call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:204,Deployability,upgrade,upgrade,204,"// Upgrade the retain release marker. If there is no need to upgrade; // the marker, that means either the module is already new enough to contain; // new intrinsics or it is not ARC. There is no need to upgrade runtime call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:20,Availability,Error,Error,20,// Upgrade PIC from Error/Max to Min.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade PIC from Error/Max to Min.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:28,Availability,Error,Error,28,"// Upgrade ""PIE Level"" from Error to Max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:3,Deployability,Upgrade,Upgrade,3,"// Upgrade ""PIE Level"" from Error to Max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:121,Availability,Error,Error,121,// Upgrade branch protection and return address signing module flags. The; // module flag behavior for these fields were Error and now they are Min.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade branch protection and return address signing module flags. The; // module flag behavior for these fields were Error and now they are Min.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade Objective-C Image Info Section. Removed the whitespce in the; // section name so that llvm-lto will not complain about mismatching; // module flags that is functionally the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:190,Availability,down,downgrade,190,"// ""Objective-C Class Properties"" is recently added for Objective-C. We; // upgrade ObjC bitcodes to contain a ""Objective-C Class Properties"" module; // flag of value 0, so we can correclty downgrade this flag when trying to; // link an ObjC bitcode without this module flag with an ObjC bitcode with; // this module flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:76,Deployability,upgrade,upgrade,76,"// ""Objective-C Class Properties"" is recently added for Objective-C. We; // upgrade ObjC bitcodes to contain a ""Objective-C Class Properties"" module; // flag of value 0, so we can correclty downgrade this flag when trying to; // link an ObjC bitcode without this module flag with an ObjC bitcode with; // this module flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:418,Usability,simpl,simplification,418,"// Prior to LLVM 10.0, the strictfp attribute could be used on individual; // callsites within a function that did not also have the strictfp attribute.; // Since 10.0, if strict FP semantics are needed within a function, the; // function must have the strictfp attribute and all calls within the function; // must also have the strictfp attribute. This latter restriction is; // necessary to prevent unwanted libcall simplification when a function is; // being cloned (such as for inlining).; //; // The ""dangling"" strictfp attribute usage was only used to prevent constant; // folding and other libcall simplification. The nobuiltin attribute on the; // callsite has the same effect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:605,Usability,simpl,simplification,605,"// Prior to LLVM 10.0, the strictfp attribute could be used on individual; // callsites within a function that did not also have the strictfp attribute.; // Since 10.0, if strict FP semantics are needed within a function, the; // function must have the strictfp attribute and all calls within the function; // must also have the strictfp attribute. This latter restriction is; // necessary to prevent unwanted libcall simplification when a function is; // being cloned (such as for inlining).; //; // The ""dangling"" strictfp attribute usage was only used to prevent constant; // folding and other libcall simplification. The nobuiltin attribute on the; // callsite has the same effect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:24,Deployability,Upgrade,Upgrade,24,// This has an old tag. Upgrade it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:24,Deployability,upgrade,upgrades,24,// The only data layout upgrades needed for pre-GCN are setting the address; // space of globals to 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:22,Deployability,upgrade,upgrades,22,// AMDGCN data layout upgrades.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:3,Deployability,Update,Update,3,// Update ni:7 to ni:7:8:9.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:122,Deployability,upgrade,upgraded,122,// Add sizing for address spaces 7 and 8 (fat raw buffers and buffer; // resources) An empty data layout has already been upgraded to G1 by now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:283,Deployability,upgrade,upgrade,283,"// i128 values need to be 16-byte-aligned. LLVM already called into libgcc; // for i128 operations prior to this being reflected in the data layout, and; // clang mostly produced LLVM IR that already aligned i128 to 16 byte; // boundaries, so although this is a breaking change, the upgrade is expected; // to fix more IR than it breaks.; // Intel MCU is an exception and uses 4-byte-alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:190,Deployability,upgrade,upgrade,190,"// For 32-bit MSVC targets, raise the alignment of f80 values to 16 bytes.; // Raising the alignment is safe because Clang did not produce f80 values in; // the MSVC environment before this upgrade was added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:104,Safety,safe,safe,104,"// For 32-bit MSVC targets, raise the alignment of f80 values to 16 bytes.; // Raising the alignment is safe because Clang did not produce f80 values in; // the MSVC environment before this upgrade was added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:283,Performance,optimiz,optimization,283,"// clang.arc.attachedcall bundles are now required to have an operand.; // If they don't, it's okay to drop them entirely: when there is an operand,; // the ""attachedcall"" is meaningful and required, but without an operand,; // it's just a marker NOP. Dropping it merely prevents an optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:31,Availability,failure,failures,31,"// Helper lambda for reporting failures: via assertion, printing, and return; // value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:45,Testability,assert,assertion,45,"// Helper lambda for reporting failures: via assertion, printing, and return; // value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:11,Testability,test,test,11,// Did the test fail?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:12,Testability,assert,asserting,12,"// If we're asserting, then fire off an assertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:40,Testability,assert,assertion,40,"// If we're asserting, then fire off an assertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:8,Security,validat,validate,8,// Only validate if we are using the new format.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:3,Security,Validat,Validate,3,// Validate DebugProgramMarkers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:7,Security,validat,validate,7,// Now validate any DPValues in the marker.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:3,Security,Validat,Validate,3,// Validate DebugProgramValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:280,Availability,alive,alive,280,"// If the address of the block is taken and it is being deleted (e.g. because; // it is dead), this means that there is either a dangling constant expr; // hanging off the block, or an undefined use of the block (source code; // expecting the address of a label to keep the block alive even though there; // is no indirect branch). Handle these cases by zapping the BlockAddress; // nodes. There are no other possible uses at this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:48,Testability,assert,assertion,48,// Use hasNUsesOrMore to bound the cost of this assertion for complex CFGs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:45,Deployability,update,update,45,// Return early if there are no PHI nodes to update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:126,Deployability,update,update,126,"// Now we must loop through all of the successors of the New block (which; // _were_ the successors of the 'this' block), and update any PHI nodes in; // successors. If there were PHI nodes in the successors, then they need to; // know that incoming branches will be from New, not from Old (this).; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:194,Deployability,update,update,194,"// Loop through all of the predecessors of the 'this' block (which will be the; // predecessors of the New block), replace the specified successor 'this'; // block to point at the New block and update any PHI nodes in 'this' block.; // If there were PHI nodes in 'this' block, the PHI nodes are updated; // to reflect that the incoming branches will be from the New block and not; // from predecessors of the 'this' block.; // Save predecessors to separate vector before modifying them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:295,Deployability,update,updated,295,"// Loop through all of the predecessors of the 'this' block (which will be the; // predecessors of the New block), replace the specified successor 'this'; // block to point at the New block and update any PHI nodes in 'this' block.; // If there were PHI nodes in 'this' block, the PHI nodes are updated; // to reflect that the incoming branches will be from the New block and not; // from predecessors of the 'this' block.; // Save predecessors to separate vector before modifying them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:64,Performance,cache,cached,64,// Set the bit to indicate that the instruction order valid and cached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:63,Safety,avoid,avoid,63,"// No current marker, create one and absorb in. (FIXME: we can avoid an; // allocation in the future).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:19,Safety,avoid,avoid,19,// FIXME: we could avoid an allocation here sometimes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:656,Availability,mainten,maintenence,656,"/*; Here's an illustration of what we're about to do. We have two blocks, this; and Src, and two segments of list. Each instruction is marked by a capital; while potential DPValue debug-info is marked out by ""-"" characters and a few; other special characters (+:=) where I want to highlight what's going on. Dest; |; this-block: A----A----A ====A----A----A----A---A---A; Src-block ++++B---B---B---B:::C; | |; First Last. The splice method is going to take all the instructions from First up to; (but not including) Last and insert them in _front_ of Dest, forming one; long list. All the DPValues attached to instructions _between_ First and; Last need no maintenence. However, we have to do special things with the; DPValues marked with the +:= characters. We only have three positions:; should the ""+"" DPValues be transferred, and if so to where? Do we move the; "":"" DPValues? Would they go in front of the ""="" DPValues, or should the ""=""; DPValues go before ""+"" DPValues?. We're told which way it should be by the bits carried in the iterators. The; ""Head"" bit indicates whether the specified position is supposed to be at the; front of the attached DPValues (true) or not (false). The Tail bit is true; on the other end of a range: is the range intended to include DPValues up to; the end (false) or not (true). FIXME: the tail bit doesn't need to be distinct from the head bit, we could; combine them. Here are some examples of different configurations:. Dest.Head = true, First.Head = true, Last.Tail = false. this-block: A----A----A++++B---B---B---B:::====A----A----A----A---A---A; | |; First Dest. Wheras if we didn't want to read from the Src list,. Dest.Head = true, First.Head = false, Last.Tail = false. this-block: A----A----AB---B---B---B:::====A----A----A----A---A---A; | |; First Dest. Or if we didn't want to insert at the head of Dest:. Dest.Head = false, First.Head = false, Last.Tail = false. this-block: A----A----A====B---B---B---B:::A----A----A----A---A---A; | |; First Dest. Te",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:1443,Deployability,configurat,configurations,1443,"bug-info is marked out by ""-"" characters and a few; other special characters (+:=) where I want to highlight what's going on. Dest; |; this-block: A----A----A ====A----A----A----A---A---A; Src-block ++++B---B---B---B:::C; | |; First Last. The splice method is going to take all the instructions from First up to; (but not including) Last and insert them in _front_ of Dest, forming one; long list. All the DPValues attached to instructions _between_ First and; Last need no maintenence. However, we have to do special things with the; DPValues marked with the +:= characters. We only have three positions:; should the ""+"" DPValues be transferred, and if so to where? Do we move the; "":"" DPValues? Would they go in front of the ""="" DPValues, or should the ""=""; DPValues go before ""+"" DPValues?. We're told which way it should be by the bits carried in the iterators. The; ""Head"" bit indicates whether the specified position is supposed to be at the; front of the attached DPValues (true) or not (false). The Tail bit is true; on the other end of a range: is the range intended to include DPValues up to; the end (false) or not (true). FIXME: the tail bit doesn't need to be distinct from the head bit, we could; combine them. Here are some examples of different configurations:. Dest.Head = true, First.Head = true, Last.Tail = false. this-block: A----A----A++++B---B---B---B:::====A----A----A----A---A---A; | |; First Dest. Wheras if we didn't want to read from the Src list,. Dest.Head = true, First.Head = false, Last.Tail = false. this-block: A----A----AB---B---B---B:::====A----A----A----A---A---A; | |; First Dest. Or if we didn't want to insert at the head of Dest:. Dest.Head = false, First.Head = false, Last.Tail = false. this-block: A----A----A====B---B---B---B:::A----A----A----A---A---A; | |; First Dest. Tests for these various configurations can be found in the unit test file; BasicBlockDbgInfoTest.cpp. */; // Detach the marker at Dest -- this lets us move the ""===="" DPValues around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:2023,Deployability,configurat,configurations,2023,"bug-info is marked out by ""-"" characters and a few; other special characters (+:=) where I want to highlight what's going on. Dest; |; this-block: A----A----A ====A----A----A----A---A---A; Src-block ++++B---B---B---B:::C; | |; First Last. The splice method is going to take all the instructions from First up to; (but not including) Last and insert them in _front_ of Dest, forming one; long list. All the DPValues attached to instructions _between_ First and; Last need no maintenence. However, we have to do special things with the; DPValues marked with the +:= characters. We only have three positions:; should the ""+"" DPValues be transferred, and if so to where? Do we move the; "":"" DPValues? Would they go in front of the ""="" DPValues, or should the ""=""; DPValues go before ""+"" DPValues?. We're told which way it should be by the bits carried in the iterators. The; ""Head"" bit indicates whether the specified position is supposed to be at the; front of the attached DPValues (true) or not (false). The Tail bit is true; on the other end of a range: is the range intended to include DPValues up to; the end (false) or not (true). FIXME: the tail bit doesn't need to be distinct from the head bit, we could; combine them. Here are some examples of different configurations:. Dest.Head = true, First.Head = true, Last.Tail = false. this-block: A----A----A++++B---B---B---B:::====A----A----A----A---A---A; | |; First Dest. Wheras if we didn't want to read from the Src list,. Dest.Head = true, First.Head = false, Last.Tail = false. this-block: A----A----AB---B---B---B:::====A----A----A----A---A---A; | |; First Dest. Or if we didn't want to insert at the head of Dest:. Dest.Head = false, First.Head = false, Last.Tail = false. this-block: A----A----A====B---B---B---B:::A----A----A----A---A---A; | |; First Dest. Tests for these various configurations can be found in the unit test file; BasicBlockDbgInfoTest.cpp. */; // Detach the marker at Dest -- this lets us move the ""===="" DPValues around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:1443,Modifiability,config,configurations,1443,"bug-info is marked out by ""-"" characters and a few; other special characters (+:=) where I want to highlight what's going on. Dest; |; this-block: A----A----A ====A----A----A----A---A---A; Src-block ++++B---B---B---B:::C; | |; First Last. The splice method is going to take all the instructions from First up to; (but not including) Last and insert them in _front_ of Dest, forming one; long list. All the DPValues attached to instructions _between_ First and; Last need no maintenence. However, we have to do special things with the; DPValues marked with the +:= characters. We only have three positions:; should the ""+"" DPValues be transferred, and if so to where? Do we move the; "":"" DPValues? Would they go in front of the ""="" DPValues, or should the ""=""; DPValues go before ""+"" DPValues?. We're told which way it should be by the bits carried in the iterators. The; ""Head"" bit indicates whether the specified position is supposed to be at the; front of the attached DPValues (true) or not (false). The Tail bit is true; on the other end of a range: is the range intended to include DPValues up to; the end (false) or not (true). FIXME: the tail bit doesn't need to be distinct from the head bit, we could; combine them. Here are some examples of different configurations:. Dest.Head = true, First.Head = true, Last.Tail = false. this-block: A----A----A++++B---B---B---B:::====A----A----A----A---A---A; | |; First Dest. Wheras if we didn't want to read from the Src list,. Dest.Head = true, First.Head = false, Last.Tail = false. this-block: A----A----AB---B---B---B:::====A----A----A----A---A---A; | |; First Dest. Or if we didn't want to insert at the head of Dest:. Dest.Head = false, First.Head = false, Last.Tail = false. this-block: A----A----A====B---B---B---B:::A----A----A----A---A---A; | |; First Dest. Tests for these various configurations can be found in the unit test file; BasicBlockDbgInfoTest.cpp. */; // Detach the marker at Dest -- this lets us move the ""===="" DPValues around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:2023,Modifiability,config,configurations,2023,"bug-info is marked out by ""-"" characters and a few; other special characters (+:=) where I want to highlight what's going on. Dest; |; this-block: A----A----A ====A----A----A----A---A---A; Src-block ++++B---B---B---B:::C; | |; First Last. The splice method is going to take all the instructions from First up to; (but not including) Last and insert them in _front_ of Dest, forming one; long list. All the DPValues attached to instructions _between_ First and; Last need no maintenence. However, we have to do special things with the; DPValues marked with the +:= characters. We only have three positions:; should the ""+"" DPValues be transferred, and if so to where? Do we move the; "":"" DPValues? Would they go in front of the ""="" DPValues, or should the ""=""; DPValues go before ""+"" DPValues?. We're told which way it should be by the bits carried in the iterators. The; ""Head"" bit indicates whether the specified position is supposed to be at the; front of the attached DPValues (true) or not (false). The Tail bit is true; on the other end of a range: is the range intended to include DPValues up to; the end (false) or not (true). FIXME: the tail bit doesn't need to be distinct from the head bit, we could; combine them. Here are some examples of different configurations:. Dest.Head = true, First.Head = true, Last.Tail = false. this-block: A----A----A++++B---B---B---B:::====A----A----A----A---A---A; | |; First Dest. Wheras if we didn't want to read from the Src list,. Dest.Head = true, First.Head = false, Last.Tail = false. this-block: A----A----AB---B---B---B:::====A----A----A----A---A---A; | |; First Dest. Or if we didn't want to insert at the head of Dest:. Dest.Head = false, First.Head = false, Last.Tail = false. this-block: A----A----A====B---B---B---B:::A----A----A----A---A---A; | |; First Dest. Tests for these various configurations can be found in the unit test file; BasicBlockDbgInfoTest.cpp. */; // Detach the marker at Dest -- this lets us move the ""===="" DPValues around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:1999,Testability,Test,Tests,1999,"bug-info is marked out by ""-"" characters and a few; other special characters (+:=) where I want to highlight what's going on. Dest; |; this-block: A----A----A ====A----A----A----A---A---A; Src-block ++++B---B---B---B:::C; | |; First Last. The splice method is going to take all the instructions from First up to; (but not including) Last and insert them in _front_ of Dest, forming one; long list. All the DPValues attached to instructions _between_ First and; Last need no maintenence. However, we have to do special things with the; DPValues marked with the +:= characters. We only have three positions:; should the ""+"" DPValues be transferred, and if so to where? Do we move the; "":"" DPValues? Would they go in front of the ""="" DPValues, or should the ""=""; DPValues go before ""+"" DPValues?. We're told which way it should be by the bits carried in the iterators. The; ""Head"" bit indicates whether the specified position is supposed to be at the; front of the attached DPValues (true) or not (false). The Tail bit is true; on the other end of a range: is the range intended to include DPValues up to; the end (false) or not (true). FIXME: the tail bit doesn't need to be distinct from the head bit, we could; combine them. Here are some examples of different configurations:. Dest.Head = true, First.Head = true, Last.Tail = false. this-block: A----A----A++++B---B---B---B:::====A----A----A----A---A---A; | |; First Dest. Wheras if we didn't want to read from the Src list,. Dest.Head = true, First.Head = false, Last.Tail = false. this-block: A----A----AB---B---B---B:::====A----A----A----A---A---A; | |; First Dest. Or if we didn't want to insert at the head of Dest:. Dest.Head = false, First.Head = false, Last.Tail = false. this-block: A----A----A====B---B---B---B:::A----A----A----A---A---A; | |; First Dest. Tests for these various configurations can be found in the unit test file; BasicBlockDbgInfoTest.cpp. */; // Detach the marker at Dest -- this lets us move the ""===="" DPValues around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:2063,Testability,test,test,2063,"bug-info is marked out by ""-"" characters and a few; other special characters (+:=) where I want to highlight what's going on. Dest; |; this-block: A----A----A ====A----A----A----A---A---A; Src-block ++++B---B---B---B:::C; | |; First Last. The splice method is going to take all the instructions from First up to; (but not including) Last and insert them in _front_ of Dest, forming one; long list. All the DPValues attached to instructions _between_ First and; Last need no maintenence. However, we have to do special things with the; DPValues marked with the +:= characters. We only have three positions:; should the ""+"" DPValues be transferred, and if so to where? Do we move the; "":"" DPValues? Would they go in front of the ""="" DPValues, or should the ""=""; DPValues go before ""+"" DPValues?. We're told which way it should be by the bits carried in the iterators. The; ""Head"" bit indicates whether the specified position is supposed to be at the; front of the attached DPValues (true) or not (false). The Tail bit is true; on the other end of a range: is the range intended to include DPValues up to; the end (false) or not (true). FIXME: the tail bit doesn't need to be distinct from the head bit, we could; combine them. Here are some examples of different configurations:. Dest.Head = true, First.Head = true, Last.Tail = false. this-block: A----A----A++++B---B---B---B:::====A----A----A----A---A---A; | |; First Dest. Wheras if we didn't want to read from the Src list,. Dest.Head = true, First.Head = false, Last.Tail = false. this-block: A----A----AB---B---B---B:::====A----A----A----A---A---A; | |; First Dest. Or if we didn't want to insert at the head of Dest:. Dest.Head = false, First.Head = false, Last.Tail = false. this-block: A----A----A====B---B---B---B:::A----A----A----A---A---A; | |; First Dest. Tests for these various configurations can be found in the unit test file; BasicBlockDbgInfoTest.cpp. */; // Detach the marker at Dest -- this lets us move the ""===="" DPValues around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:133,Availability,down,down,133,"// ""I"" was originally removed from a position where it was; // immediately in front of Pos. Any DPValues on that position then ""fell down""; // onto Pos. ""I"" has been re-inserted at the front of that wedge of DPValues,; // shuffle them around to represent the original positioning. To illustrate:; //; // Instructions: I1---I---I0; // DPValues: DDD DDD; //; // Instruction ""I"" removed,; //; // Instructions: I1------I0; // DPValues: DDDDDD; // ^Pos; //; // Instruction ""I"" re-inserted (now):; //; // Instructions: I1---I------I0; // DPValues: DDDDDD; // ^Pos; //; // After this method completes:; //; // Instructions: I1---I---I0; // DPValues: DDD DDD; // This happens if there were no DPValues on I0. Are there now DPValues there?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:46,Availability,down,down,46,"// There are DPMarkers there now -- they fell down from ""I"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:7,Testability,assert,asserts,7,"/// In asserts builds, this checks the numbering. In non-asserts builds, it; /// is defined as a no-op inline function in BasicBlock.h.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:57,Testability,assert,asserts,57,"/// In asserts builds, this checks the numbering. In non-asserts builds, it; /// is defined as a no-op inline function in BasicBlock.h.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BuiltinGCs.cpp:236,Energy Efficiency,efficient,efficient,236,"/// A GC strategy for uncooperative targets. This implements lowering for the; /// llvm.gc* intrinsics for targets that do not natively support them (which; /// includes the C backend). Note that the code generated is not quite as; /// efficient as algorithms which generate stack maps to identify roots.; ///; /// In order to support this particular transformation, all stack roots are; /// coallocated in the stack. This allows a fully target-independent stack map; /// while introducing only minor runtime overhead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BuiltinGCs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BuiltinGCs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BuiltinGCs.cpp:177,Usability,usab,usable,177,"/// A GCStrategy which serves as an example for the usage of a statepoint based; /// lowering strategy. This GCStrategy is intended to suitable as a default; /// implementation usable with any collector which can consume the standard; /// stackmap format generated by statepoints, uses the default addrespace to; /// distinguish between gc managed and non-gc managed pointers, and has; /// reasonable relocation semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BuiltinGCs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BuiltinGCs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BuiltinGCs.cpp:151,Deployability,update,updated,151,"// For the sake of this example GC, we arbitrarily pick addrspace(1) as our; // GC managed heap. We know that a pointer into this heap needs to be; // updated and that no other pointer does. Note that addrspace(1) is used; // only as an example, it has no special meaning, and is not reserved for; // GC usage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BuiltinGCs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BuiltinGCs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BuiltinGCs.cpp:315,Safety,Safe,Safe-point,315,"/// A GCStrategy for the CoreCLR Runtime. The strategy is similar to; /// Statepoint-example GC, but differs from it in certain aspects, such as:; /// 1) Base-pointers need not be explicitly tracked and reported for; /// interior pointers; /// 2) Uses a different format for encoding stack-maps; /// 3) Location of Safe-point polls: polls are only needed before loop-back; /// edges and before tail-calls (not needed at function-entry); ///; /// The above differences in behavior are to be implemented in upcoming; /// checkins.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BuiltinGCs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BuiltinGCs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BuiltinGCs.cpp:58,Performance,load,loaded,58,// Provide hook to ensure the containing library is fully loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/BuiltinGCs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BuiltinGCs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:485,Integrability,interface,interface,485,"//===- ConstantFold.cpp - LLVM constant folder ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements folding of constants for LLVM. This implements the; // (internal) ConstantFold.h interface, which is used by the; // ConstantExpr::get* methods to automatically fold constants when possible.; //; // The current constant folding implementation is implemented in two pieces: the; // pieces that don't need DataLayout, and the pieces that do. This is to avoid; // a dependence in IR on Target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:767,Integrability,depend,dependence,767,"//===- ConstantFold.cpp - LLVM constant folder ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements folding of constants for LLVM. This implements the; // (internal) ConstantFold.h interface, which is used by the; // ConstantExpr::get* methods to automatically fold constants when possible.; //; // The current constant folding implementation is implemented in two pieces: the; // pieces that don't need DataLayout, and the pieces that do. This is to avoid; // a dependence in IR on Target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:755,Safety,avoid,avoid,755,"//===- ConstantFold.cpp - LLVM constant folder ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements folding of constants for LLVM. This implements the; // (internal) ConstantFold.h interface, which is used by the; // ConstantExpr::get* methods to automatically fold constants when possible.; //; // The current constant folding implementation is implemented in two pieces: the; // pieces that don't need DataLayout, and the pieces that do. This is to avoid; // a dependence in IR on Target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:404,Integrability,wrap,wrapper,404,//===----------------------------------------------------------------------===//; // ConstantFold*Instruction Implementations; //===----------------------------------------------------------------------===//; /// This function determines which opcode to use to fold two constant cast; /// expressions together. It uses CastInst::isEliminableCastPair to determine; /// the opcode. Consequently its just a wrapper around that function.; /// Determine if it is valid to fold a cast of a cast,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:99,Usability,simpl,simplifications,99,// Canonicalize scalar-to-vector bitcasts into vector-to-vector bitcasts; // This allows for other simplifications (although some of them; // can only be handled by Analysis/ConstantFolding.cpp).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:197,Integrability,depend,depends,197,"// PPC_FP128 is really the sum of two consecutive doubles, where the first; // double is always stored first in memory, regardless of the target; // endianness. The memory layout of i128, however, depends on the target; // endianness, and so we can't fold this without target endianness; // information. This should instead be handled by; // Analysis/ConstantFolding.cpp",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:368,Usability,simpl,simplified,368,"/// V is an integer constant which only has a subset of its bytes used.; /// The bytes used are indicated by ByteStart (which is the first byte used,; /// counting from the least significant byte) and ByteSize, which is the number; /// of bytes used.; ///; /// This function analyzes the specified constant to see if the specified byte; /// range can be returned as a simplified constant. If so, the constant is; /// returned, otherwise null is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:25,Usability,simpl,simple,25,// Constant Integers are simple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:68,Usability,simpl,simplify,68,"// In the input is a constant expr, we might be able to recursively simplify.; // If not, we definitely can't do anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:94,Usability,simpl,simplify,94,"// If the cast operand is a constant expression, there's a few things we can; // do to try to simplify it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:45,Performance,perform,perform,45,"// If the cast operand is a constant vector, perform the cast by; // operating on each element. In the cast of bitcasts, the element; // count may be mismatched; don't attempt to handle that here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:38,Performance,Perform,Perform,38,// We actually have to do a cast now. Perform the cast according to the; // opcode specified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:51,Usability,simpl,simplify,51,// The input must be a constantexpr. See if we can simplify this based on; // the bytes we are demanding. Only do this if the source and dest are an; // even multiple of a byte.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:21,Performance,scalab,scalable,21,// Do not iterate on scalable vector. The num of elements is unknown at; // compile-time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:18,Availability,mask,mask,18,// Poison shuffle mask -> poison value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:10,Availability,mask,mask,10,"// If the mask is all zeros this is a splat, no need to go through all; // elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:21,Performance,scalab,scalable,21,// Do not iterate on scalable vector. The num of elements is unknown at; // compile-time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:25,Availability,mask,mask,25,"// Loop over the shuffle mask, evaluating each element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:32,Performance,scalab,scalable,32,// Handle scalar UndefValue and scalable vector UndefValue. Fixed-length; // vectors are always evaluated per element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:3,Usability,Simpl,Simplify,3,"// Simplify BinOps with their identity values first. They are no-ops and we; // can always return the other value, including undef or poison values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:32,Performance,scalab,scalable,32,// Handle scalar UndefValue and scalable vector UndefValue. Fixed-length; // vectors are always evaluated per element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:164,Integrability,depend,depending,164,"// [any flop] C, undef -> NaN; // [any flop] undef, C -> NaN; // We could potentially specialize NaN/Inf constants vs. 'normal'; // constants (possibly differently depending on opcode and operand). This; // would allow returning undef sometimes. But it is always safe to fold to; // NaN because we can choose the undef operand as NaN, and any FP opcode; // with a NaN operand will propagate NaN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:263,Safety,safe,safe,263,"// [any flop] C, undef -> NaN; // [any flop] undef, C -> NaN; // We could potentially specialize NaN/Inf constants vs. 'normal'; // constants (possibly differently depending on opcode and operand). This; // would allow returning undef sometimes. But it is always safe to fold to; // NaN because we can choose the undef operand as NaN, and any FP opcode; // with a NaN operand will propagate NaN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:10,Usability,simpl,simplifications,10,// Handle simplifications when the RHS is a constant int.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:32,Usability,clear,clear,32,"// If checking bits we know are clear, return zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:13,Usability,simpl,simplified,13,// i1 can be simplified in many cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:131,Usability,simpl,simple,131,"/// This function determines if there is anything we can decide about the two; /// constants provided. This doesn't need to handle simple things like integer; /// comparisons, but should instead handle ConstantExprs and GlobalValues.; /// If we can determine that the two constants have a particular relation to; /// each other, we should return the corresponding ICmp predicate, otherwise; /// return ICmpInst::BAD_ICMP_PREDICATE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:6,Usability,simpl,simplify,6,"// To simplify this code we canonicalize the relation so that the first; // operand is always the most ""complex"" of the two. We consider simple; // constants (like ConstantPointerNull) to be the simplest, followed by; // BlockAddress, GlobalValues, and ConstantExpr's (the most complex).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:137,Usability,simpl,simple,137,"// To simplify this code we canonicalize the relation so that the first; // operand is always the most ""complex"" of the two. We consider simple; // constants (like ConstantPointerNull) to be the simplest, followed by; // BlockAddress, GlobalValues, and ConstantExpr's (the most complex).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:195,Usability,simpl,simplest,195,"// To simplify this code we canonicalize the relation so that the first; // operand is always the most ""complex"" of the two. We consider simple; // constants (like ConstantPointerNull) to be the simplest, followed by; // BlockAddress, GlobalValues, and ConstantExpr's (the most complex).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:49,Usability,simpl,simple,49,// Now we know that the RHS is a BlockAddress or simple constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:62,Usability,simpl,simple,62,"// Now we know that the RHS is a GlobalValue, BlockAddress or simple; // constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:118,Usability,simpl,simple,118,"// Ok, the LHS is known to be a constantexpr. The RHS can be any of a; // constantexpr, a global, block address, or a simple constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:55,Usability,simpl,simplify,55,"// If the comparison is a comparison between two i1's, simplify it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:21,Performance,scalab,scalable,21,// Do not iterate on scalable vector. The number of elements is unknown at; // compile-time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:4,Testability,Test,Test,4,"/// Test whether the given sequence of *normalized* indices is ""inbounds"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:4,Testability,Test,Test,4,/// Test whether a given ConstantInt is in-range for a SequentialType.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:14,Usability,simpl,simple,14,// Handle the simple case of a zero index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:12,Performance,perform,perform,12,"// We could perform the transform with non-constant index, but prefer leaving; // it as GEP of GEP rather than GEP of add for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:26,Modifiability,extend,extended,26,// TODO: This code may be extended to handle vectors as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:29,Modifiability,inherit,inherits,29,"// The combined GEP normally inherits its index inrange attribute from; // the inner GEP, but if the inner GEP's last index was adjusted by the; // outer GEP, any inbounds attribute on that index is invalidated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:3,Safety,Avoid,Avoid,3,// Avoid losing inrange information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:47,Energy Efficiency,power,power,47,// There can be awkward padding in after a non-power of two vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:18,Modifiability,extend,extend,18,"// Before adding, extend both operands to i64 to avoid; // overflow trouble.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:49,Safety,avoid,avoid,49,"// Before adding, extend both operands to i64 to avoid; // overflow trouble.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:65,Usability,simpl,simple,65,"// If all indices are known integers and normalized, we can do a simple; // check for the ""inbounds"" property.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:562,Integrability,wrap,wrap,562,"//===- ConstantRange.cpp - ConstantRange implementation -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Represent a range of possible values that may occur when the program is run; // for an integral value. This keeps track of a lower and upper bound for the; // constant, which MAY wrap around the end of the numeric range. To do this, it; // keeps track of a [lower, upper) bound, which specifies an interval just like; // STL iterators. When used with boolean values, the following are important; // ranges (other integral ranges use min/max values for special range values):; //; // [F, F) = {} = Empty set; // [T, F) = {T}; // [F, T) = {F}; // [T, T) = {F, T} = Full set; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:71,Usability,simpl,simple,71,"// For unsigned ranges, or signed ranges with known sign bit, create a simple; // range between the smallest and largest possible value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:214,Testability,assert,assert,214,"// Computes the exact range that is equal to both the constant ranges returned; // by makeAllowedICmpRegion and makeSatisfyingICmpRegion. This is always true; // when RHS is a singleton such as an APInt and so the assert is valid.; // However for non-singleton RHS, for example ult [2,5) makeAllowedICmpRegion; // returns [0,4) but makeSatisfyICmpRegion returns [0,2).; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:33,Safety,avoid,avoid,33,// Handle 0 and -1 separately to avoid division by zero or overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:3,Safety,Avoid,Avoid,3,// Avoid one makeExactMulNSWRegion() call for the common case of constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:93,Integrability,wrap,wrap,93,"// There are some legal shift amounts, we can compute conservatively-correct; // range of no-wrap inputs. Note that by now we have clamped the ShAmtUMax; // to be at most bitwidth-1, which results in most conservative range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:51,Safety,avoid,avoid,51,"// If this a full set, we need special handling to avoid needing an extra bit; // to represent the size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:38,Energy Efficiency,efficient,efficiently,38,// TODO: This can be implemented more efficiently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:38,Energy Efficiency,efficient,efficiently,38,// TODO: This can be implemented more efficiently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:28,Availability,avail,available,28,// TODO: use input range if available,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:28,Availability,avail,available,28,// TODO: use input range if available,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:38,Integrability,wrap,wrapping,38,"// special case: [X, 0) -- not really wrapping around",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:44,Integrability,wrap,wrapping,44,"// special case: [X, INT_MIN) -- not really wrapping around",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:11,Integrability,wrap,wrapped,11,"// Analyze wrapped sets in their two parts: [0, Upper) \/ [Lower, MaxValue]; // We use the non-wrapped set code to analyze the [Lower, MaxValue) part, and; // then we do the union with [MaxValue, Upper)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:95,Integrability,wrap,wrapped,95,"// Analyze wrapped sets in their two parts: [0, Upper) \/ [Lower, MaxValue]; // We use the non-wrapped set code to analyze the [Lower, MaxValue) part, and; // then we do the union with [MaxValue, Upper)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:3,Availability,Mask,Mask,3,// Mask to just the signficant bits and subtract from LowerDiv/UpperDiv.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:23,Integrability,wrap,wraps,23,// The truncated value wraps around. Check if we can do better than fullset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:34,Integrability,wrap,wraps,34,// Clear the MSB so that UpperDiv wraps around.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:3,Usability,Clear,Clear,3,// Clear the MSB so that UpperDiv wraps around.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:9,Integrability,wrap,wrapped,9,"// We've wrapped, therefore, full set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:62,Integrability,wrap,wrap,62,"// Calculate the range for ""X + Y"" which is guaranteed not to wrap(overflow).; // (X is from this, and Y is from Other)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:9,Integrability,wrap,wrapped,9,"// We've wrapped, therefore, full set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:62,Integrability,wrap,wrap,62,"// Calculate the range for ""X - Y"" which is guaranteed not to wrap(overflow).; // (X is from this, and Y is from Other)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:267,Performance,perform,perform,267,"// If an overflow happens for every value pair in these two constant ranges,; // we must return Empty set. In signed case, we get that for free, because we; // get lucky that intersection of sub() with ssub_sat() results in an; // empty set. But for unsigned we must perform the overflow check manually.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:262,Energy Efficiency,power,power-of-two,262,"// TODO: If either operand is a single element and the multiply is known to; // be non-wrapping, round the result min and max value to the appropriate; // multiple of that element. If wrapping is possible, at least adjust the; // range according to the greatest power-of-two factor of the single element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:87,Integrability,wrap,wrapping,87,"// TODO: If either operand is a single element and the multiply is known to; // be non-wrapping, round the result min and max value to the appropriate; // multiple of that element. If wrapping is possible, at least adjust the; // range according to the greatest power-of-two factor of the single element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:184,Integrability,wrap,wrapping,184,"// TODO: If either operand is a single element and the multiply is known to; // be non-wrapping, round the result min and max value to the appropriate; // multiple of that element. If wrapping is possible, at least adjust the; // range according to the greatest power-of-two factor of the single element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:90,Integrability,depend,depending,90,"// Multiplication is signedness-independent. However different ranges can be; // obtained depending on how the input ranges are treated. These different; // ranges are all conservatively correct, but one might be better than the; // other. We calculate two ranges; one treating the inputs as unsigned; // and the other signed, then return the smallest of these ranges.; // Unsigned range first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:33,Integrability,wrap,wrap,33,"// If the unsigned range doesn't wrap, and isn't negative then it's a range; // from one positive number to another which is as good as we can generate.; // In this case, skip the extra work of generating signed ranges which aren't; // going to be better than this range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:16,Integrability,wrap,wrapping,16,// Prefer a non-wrapping signed range here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:14,Testability,log,logic,14,"// Same basic logic as above, but the result is negative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:9,Integrability,wrap,wrapped,9,// Upper wrapped range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:191,Integrability,wrap,wrapped,191,"// ZeroIsPoison is set, and zero is contained. We discern three cases, in; // which a zero can appear:; // 1) Lower is zero, handling cases of kind [0, 1), [0, 2), etc.; // 2) Upper is zero, wrapped set, handling cases of kind [3, 0], etc.; // 3) Zero contained in a wrapped set, e.g., [3, 2), [3, 1), etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:267,Integrability,wrap,wrapped,267,"// ZeroIsPoison is set, and zero is contained. We discern three cases, in; // which a zero can appear:; // 1) Lower is zero, handling cases of kind [0, 1), [0, 2), etc.; // 2) Upper is zero, wrapped set, handling cases of kind [3, 0], etc.; // 3) Zero contained in a wrapped set, e.g., [3, 2), [3, 1), etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:18,Safety,safe,safe,18,// Zero is either safe or not in the range. The output range is composed by; // the result of countLeadingZero of the two extremes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:191,Integrability,wrap,wrapped,191,"// ZeroIsPoison is set, and zero is contained. We discern three cases, in; // which a zero can appear:; // 1) Lower is zero, handling cases of kind [0, 1), [0, 2), etc.; // 2) Upper is zero, wrapped set, handling cases of kind [3, 0], etc.; // 3) Zero contained in a wrapped set, e.g., [3, 2), [3, 1), etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:267,Integrability,wrap,wrapped,267,"// ZeroIsPoison is set, and zero is contained. We discern three cases, in; // which a zero can appear:; // 1) Lower is zero, handling cases of kind [0, 1), [0, 2), etc.; // 2) Upper is zero, wrapped set, handling cases of kind [3, 0], etc.; // 3) Zero contained in a wrapped set, e.g., [3, 2), [3, 1), etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:16,Integrability,wrap,wrapped,16,"// The range is wrapped. We decompose it into two ranges, [0, Upper) and; // [Lower, 0).; // Handle [Lower, 0)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:16,Integrability,wrap,wrapped,16,"// The range is wrapped. We decompose it into two ranges, [0, Upper) and; // [Lower, 0).; // Handle [Lower, 0) == [Lower, Max]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:163,Integrability,depend,dependent,163,"// When a Constant is destroyed, there may be lingering; // references to the constant by other constants in the constant pool. These; // constants are implicitly dependent on the module that is being deleted,; // but they don't know that. Because we only find out when the CPV is; // deleted, we must now notify all of our users (that should only be; // Constants) that they are, in fact, invalid now and should be deleted.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:45,Safety,safe,safe,45,// Value has no outstanding references it is safe to delete it now...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:247,Energy Efficiency,efficient,efficiently,247,"// While raw uses of blockaddress need to be relocated, differences; // between two of them don't when they are for labels in the same; // function. This is a common idiom when creating a table for the; // indirect goto extension, so we handle it efficiently here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:14,Security,access,accessors,14,// ConstantFP accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:120,Usability,simpl,simple,120,"// If this is an all-zero array, return a ConstantAggregateZero object. If; // all undef, return an UndefValue, if ""all simple"", then return a; // ConstantDataArray.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:18,Security,access,accessors,18,// ConstantStruct accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:15,Modifiability,inherit,inherits,15,"// PoisonValue inherits UndefValue, so its check is not necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:18,Security,access,accessors,18,// ConstantVector accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:17,Availability,mask,mask,17,// Build shuffle mask to perform the splat.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:25,Performance,perform,perform,25,// Build shuffle mask to perform the splat.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:3,Testability,assert,assert,3,// assert okay,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:90,Modifiability,flexible,flexible,90,// These can't be represented as floating point!; // FIXME rounding mode needs to be more flexible,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:3,Performance,Scalab,Scalable,3,// Scalable vectors can use a ConstantExpr to build a splat.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:104,Deployability,release,release,104,// For non-ConstantExpr we use getAggregateElement as a fast path to avoid; // calling getSplatValue in release builds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:69,Safety,avoid,avoid,69,// For non-ConstantExpr we use getAggregateElement as a fast path to avoid; // calling getSplatValue in release builds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:55,Deployability,update,update,55,"// See if the 'new' entry already exists, if not, just update this in place; // and return early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:56,Performance,scalab,scalable,56,// FIXME: We can extract pow of 2 of splat constant for scalable vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:113,Availability,down,down,113,"/// This is the underlying implementation of all of the; /// ConstantDataSequential::get methods. They all thunk down to here, providing; /// the correct element type. We take the bytes in as a StringRef because; /// we *want* an underlying ""char*"" to avoid TBAA type punning violations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:252,Safety,avoid,avoid,252,"/// This is the underlying implementation of all of the; /// ConstantDataSequential::get methods. They all thunk down to here, providing; /// the correct element type. We take the bytes in as a StringRef because; /// we *want* an underlying ""char*"" to avoid TBAA type punning violations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:44,Security,access,access,44,// Use reset because std::make_unique can't access the constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:44,Security,access,access,44,// Use reset because std::make_unique can't access the constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:29,Security,hash,hash,29,// Remove the entry from the hash table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:90,Performance,load,load,90,"// The data is stored in host byte order, make sure to cast back to the right; // type to load with the right endianness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:90,Performance,load,load,90,"// The data is stored in host byte order, make sure to cast back to the right; // type to load with the right endianness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:126,Deployability,Update,Update,126,"//===----------------------------------------------------------------------===//; // handleOperandChange implementations; /// Update this constant array to change uses of; /// 'From' to be uses of 'To'. This must update the uniquing data structures; /// etc.; ///; /// Note that we intentionally replace all uses of From with To here. Consider; /// a large array that uses 'From' 1000 times. By handling this case all here,; /// ConstantArray::handleOperandChange is only invoked once, and that; /// single invocation handles all 1000 uses. Handling them one at a time would; /// work, but would be really slow because it would have to unique each updated; /// array instance.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:213,Deployability,update,update,213,"//===----------------------------------------------------------------------===//; // handleOperandChange implementations; /// Update this constant array to change uses of; /// 'From' to be uses of 'To'. This must update the uniquing data structures; /// etc.; ///; /// Note that we intentionally replace all uses of From with To here. Consider; /// a large array that uses 'From' 1000 times. By handling this case all here,; /// ConstantArray::handleOperandChange is only invoked once, and that; /// single invocation handles all 1000 uses. Handling them one at a time would; /// work, but would be really slow because it would have to unique each updated; /// array instance.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:648,Deployability,update,updated,648,"//===----------------------------------------------------------------------===//; // handleOperandChange implementations; /// Update this constant array to change uses of; /// 'From' to be uses of 'To'. This must update the uniquing data structures; /// etc.; ///; /// Note that we intentionally replace all uses of From with To here. Consider; /// a large array that uses 'From' 1000 times. By handling this case all here,; /// ConstantArray::handleOperandChange is only invoked once, and that; /// single invocation handles all 1000 uses. Handling them one at a time would; /// work, but would be really slow because it would have to unique each updated; /// array instance.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:3,Deployability,Update,Update,3,// Update to the new value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:3,Deployability,Update,Update,3,// Update to the new value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:3,Deployability,Update,Update,3,// Update to the new value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:3,Deployability,Update,Update,3,// Update to the new value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h:3,Energy Efficiency,allocate,allocate,3,// allocate space for exactly one operand,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h:3,Energy Efficiency,allocate,allocate,3,// allocate space for exactly two operands,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h:31,Energy Efficiency,efficient,efficient,31,/// Transparently provide more efficient getOperand methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h:3,Energy Efficiency,allocate,allocate,3,// allocate space for exactly two operands,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h:31,Energy Efficiency,efficient,efficient,31,/// Transparently provide more efficient getOperand methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h:3,Energy Efficiency,allocate,allocate,3,// allocate space for exactly three operands,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h:31,Energy Efficiency,efficient,efficient,31,/// Transparently provide more efficient getOperand methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h:31,Energy Efficiency,efficient,efficient,31,/// Transparently provide more efficient getOperand methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h:31,Energy Efficiency,efficient,efficient,31,/// Transparently provide more efficient getOperand methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h:3,Energy Efficiency,allocate,allocate,3,// allocate space for exactly two operands,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h:31,Energy Efficiency,efficient,efficient,31,/// Transparently provide more efficient getOperand methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h:12,Security,hash,hash,12,"/// Key and hash together, so that we compute the hash only once and reuse it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h:50,Security,hash,hash,50,"/// Key and hash together, so that we compute the hash only once and reuse it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h:4,Security,Hash,Hash,4,"/// Hash once, and reuse it for the lookup and the insertion if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h:4,Security,Hash,Hash,4,"/// Hash once, and reuse it for the lookup and the insertion if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h:3,Deployability,Update,Update,3,"// Update to the new value. Optimize for the case when we have a single; // operand that we're changing, but handle bulk updates efficiently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h:121,Deployability,update,updates,121,"// Update to the new value. Optimize for the case when we have a single; // operand that we're changing, but handle bulk updates efficiently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h:129,Energy Efficiency,efficient,efficiently,129,"// Update to the new value. Optimize for the case when we have a single; // operand that we're changing, but handle bulk updates efficiently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h:28,Performance,Optimiz,Optimize,28,"// Update to the new value. Optimize for the case when we have a single; // operand that we're changing, but handle bulk updates efficiently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp:8,Availability,Error,Error,8,/*===-- Error handling ----------------------------------------------------===*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp:167,Usability,undo,undoes,167,"// MetadataAsValue uses a canonical format which strips the actual MDNode for; // MDNode with just a single constant value, storing just a ConstantAsMetadata; // This undoes this canonicalization, reconstructing the MDNode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp:28,Modifiability,variab,variables,28,"/*--.. Operations on global variables, functions, and aliases (globals) ....--*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp:20,Safety,safe,safe,20,// Using .data() is safe because of how GlobalObject::setSection is; // implemented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp:28,Modifiability,variab,variables,28,"/*--.. Operations on global variables, load and store instructions .........--*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp:39,Performance,load,load,39,"/*--.. Operations on global variables, load and store instructions .........--*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp:28,Modifiability,variab,variables,28,/*--.. Operations on global variables ......................................--*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp:29,Availability,redundant,redundant,29,// This function is strictly redundant to; // LLVMCountParamTypes(LLVMGlobalGetValueType(FnRef)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp:29,Safety,redund,redundant,29,// This function is strictly redundant to; // LLVMCountParamTypes(LLVMGlobalGetValueType(FnRef)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Core.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:46,Integrability,rout,routines,46,"//===- DataLayout.cpp - Data size & alignment routines ---------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines layout properties related to datatype size/offset/alignment; // information.; //; // This structure should be created once, filled in if the defaults are not; // correct and then passed around by const&. None of the members functions; // require modification to the object.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:102,Performance,scalab,scalable,102,"// Add padding if necessary to align the data element properly.; // Currently the only structure with scalable size will be the homogeneous; // scalable vector types. Homogeneous scalable vector types have members of; // the same data type so no alignment issue will happen. The condition here; // assumes so and needs to be adjusted if this assumption changes (e.g. we; // support structures with arbitrary scalable data type, or structure that; // contains both fixed size and scalable size data type members).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:144,Performance,scalab,scalable,144,"// Add padding if necessary to align the data element properly.; // Currently the only structure with scalable size will be the homogeneous; // scalable vector types. Homogeneous scalable vector types have members of; // the same data type so no alignment issue will happen. The condition here; // assumes so and needs to be adjusted if this assumption changes (e.g. we; // support structures with arbitrary scalable data type, or structure that; // contains both fixed size and scalable size data type members).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:179,Performance,scalab,scalable,179,"// Add padding if necessary to align the data element properly.; // Currently the only structure with scalable size will be the homogeneous; // scalable vector types. Homogeneous scalable vector types have members of; // the same data type so no alignment issue will happen. The condition here; // assumes so and needs to be adjusted if this assumption changes (e.g. we; // support structures with arbitrary scalable data type, or structure that; // contains both fixed size and scalable size data type members).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:408,Performance,scalab,scalable,408,"// Add padding if necessary to align the data element properly.; // Currently the only structure with scalable size will be the homogeneous; // scalable vector types. Homogeneous scalable vector types have members of; // the same data type so no alignment issue will happen. The condition here; // assumes so and needs to be adjusted if this assumption changes (e.g. we; // support structures with arbitrary scalable data type, or structure that; // contains both fixed size and scalable size data type members).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:479,Performance,scalab,scalable,479,"// Add padding if necessary to align the data element properly.; // Currently the only structure with scalable size will be the homogeneous; // scalable vector types. Homogeneous scalable vector types have members of; // the same data type so no alignment issue will happen. The condition here; // assumes so and needs to be adjusted if this assumption changes (e.g. we; // support structures with arbitrary scalable data type, or structure that; // contains both fixed size and scalable size data type members).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:39,Availability,error,error,39,"/// Get an unsigned integer, including error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:92,Availability,Error,Error,92,/// Get an unsigned integer representing the number of bits and convert it into; /// bytes. Error out of not a byte width multiple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:45,Performance,load,loading,45,"// Deprecated, but ignoring here to preserve loading older textual llvm; // ASM file",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:36,Modifiability,variab,variables,36,// Default address space for global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:238,Testability,assert,assert,238,"// AlignmentsTy::ABIAlign and AlignmentsTy::PrefAlign were once stored as; // uint16_t, it is unclear if there are requirements for alignment to be less; // than 2^16 other than storage. In the meantime we leave the restriction as; // an assert. See D67400 for context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:3,Deployability,Update,Update,3,"// Update the abi, preferred alignments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:54,Modifiability,variab,variable,54,"// Otherwise, create the struct layout. Because it is variable length, we; // malloc it, then use placement new.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:129,Energy Efficiency,power,power,129,"// If we still couldn't find a reasonable default alignment, fall back; // to a simple heuristic that the alignment is the first power of two; // greater-or-equal to the store size of the type. This is a reasonable; // approximation of reality, and if the user wanted something less; // less conservative, they should have specified it explicitly in the data; // layout.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:80,Usability,simpl,simple,80,"// If we still couldn't find a reasonable default alignment, fall back; // to a simple heuristic that the alignment is the first power of two; // greater-or-equal to the store size of the type. This is a reasonable; // approximation of reality, and if the user wanted something less; // less conservative, they should have specified it explicitly in the data; // layout.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:219,Performance,scalab,scalable,219,"// By default, use natural alignment for vector types. This is consistent; // with what clang and llvm-gcc do.; //; // We're only calculating a natural alignment, so it doesn't have to be; // based on the full size for scalable vectors. Using the minimum element; // count should be enough here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:13,Performance,scalab,scalable,13,"// Skip over scalable or zero size elements. Also skip element sizes larger; // than the positive index space, because the arithmetic below may not be; // correct in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:117,Safety,avoid,avoid,117,"// Vector GEPs are partially broken (e.g. for overaligned element types),; // and may be forbidden in the future, so avoid generating GEPs into; // vectors. See https://discourse.llvm.org/t/67497",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:69,Safety,avoid,avoid,69,// This function is hot. Check whether the value has any metadata to avoid a; // DenseMap lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:69,Safety,avoid,avoid,69,// This function is hot. Check whether the value has any metadata to avoid a; // DenseMap lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:69,Safety,avoid,avoid,69,// This function is hot. Check whether the value has any metadata to avoid a; // DenseMap lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:293,Safety,avoid,avoid,293,"// Some of the users, e.g. CloneFunctionInto / CloneModule, need to set up a; // ValueMap containing identity mappings for all of the DICompileUnit's, not; // just DISubprogram's, referenced from anywhere within the Function being; // cloned prior to calling MapMetadata / RemapInstruction to avoid their; // duplication later as DICompileUnit's are also directly referenced by; // llvm.dbg.cu list. Thefore we need to collect DICompileUnit's here as well.; // Also, DICompileUnit's may reference DISubprogram's too and therefore need; // to be at least looked through.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:145,Deployability,update,updateLoopMetadataDebugLocationsImpl,145,"// If there is no debug location, we do not have to rewrite this; // MDNode. This loop also initializes DILocationReachable, later; // needed by updateLoopMetadataDebugLocationsImpl; the use of; // count_if avoids an early exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:52,Modifiability,rewrite,rewrite,52,"// If there is no debug location, we do not have to rewrite this; // MDNode. This loop also initializes DILocationReachable, later; // needed by updateLoopMetadataDebugLocationsImpl; the use of; // count_if avoids an early exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:207,Safety,avoid,avoids,207,"// If there is no debug location, we do not have to rewrite this; // MDNode. This loop also initializes DILocationReachable, later; // needed by updateLoopMetadataDebugLocationsImpl; the use of; // count_if avoids an early exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:20,Availability,down,downgrade,20,/// Helper class to downgrade -g metadata to -gline-tables-only metadata.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:213,Safety,avoid,avoid,213,"/// Remember what linkage name we originally had before stripping. If we end; /// up making two subprograms identical who originally had different linkage; /// names, then we need to make one of them distinct, to avoid them getting; /// uniqued. Maps the new node to the old linkage name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:324,Availability,down,down,324,"// TODO: Remember the distinct subprogram we created for a given linkage name,; // so that we can continue to unique whenever possible. Map <newly created; // node, old linkage name> to the first (possibly distinct) mdsubprogram; // created for that combination. This is not strictly needed for correctness,; // but can cut down on the number of MDNodes and let us diff cleanly with the; // output of -gline-tables-only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:6,Safety,avoid,avoid,6,"// To avoid cycles, as well as for efficiency sake, we will sometimes prune; // parts of the graph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:40,Modifiability,variab,variables,40,// Drop all dbg attachments from global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the DebugLocs to be equivalent to what; // -gline-tables-only would have created.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:26,Availability,avail,available,26,"// If a function scope is available, set it on the line 0 location. When; // hoisting a call to a predecessor block, using the function scope avoids; // making it look like the callee was reached earlier than it should be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:142,Safety,avoid,avoids,142,"// If a function scope is available, set it on the line 0 location. When; // hoisting a call to a predecessor block, using the function scope avoids; // making it look like the callee was reached earlier than it should be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:23,Integrability,wrap,wrapped,23,"// The ID is only used wrapped in MetadataAsValue(ID), so lets check that; // one of those already exists first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:33,Modifiability,variab,variable,33,"/// Get the FragmentInfo for the variable if it exists, otherwise return a; /// FragmentInfo that covers the entire variable if the variable size is; /// known, otherwise return a zero-sized fragment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:116,Modifiability,variab,variable,116,"/// Get the FragmentInfo for the variable if it exists, otherwise return a; /// FragmentInfo that covers the entire variable if the variable size is; /// known, otherwise return a zero-sized fragment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:132,Modifiability,variab,variable,132,"/// Get the FragmentInfo for the variable if it exists, otherwise return a; /// FragmentInfo that covers the entire variable if the variable size is; /// known, otherwise return a zero-sized fragment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:23,Modifiability,variab,variable,23,"// Get the fragment or variable size, or zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:23,Modifiability,variab,variable,23,"// Get the fragment or variable size, or zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:78,Availability,down,down,78,"// There are multiple offsets at play in this function, so let's break it; // down. Starting with how variables may be stored in allocas:; //; // 1 Simplest case: variable is alloca sized and starts at offset 0.; // 2 Variable is larger than the alloca: the alloca holds just a part of it.; // 3 Variable is smaller than the alloca: the alloca may hold multiple; // variables.; //; // Imagine we have a store to the entire alloca. In case (3) the store; // affects bits outside of the bounds of each variable. In case (2), where; // the alloca holds the Xth bit to the Yth bit of a variable, the; // zero-offset store doesn't represent an assignment at offset zero to the; // variable. It is an assignment to offset X.; //; // # Example 1; // Obviously, not all stores are alloca-sized and have zero offset. Imagine; // the lower 32 bits of this store are dead and are going to be DSEd:; //; // store i64 %v, ptr %dest, !DIAssignID !1; // dbg.assign(..., !DIExpression(fragment, 128, 32), !1, %dest,; // !DIExpression(DW_OP_plus_uconst, 4)); //; // Goal: Given our dead bits at offset:0 size:32 for the store, determine the; // part of the variable, which fits in the fragment expressed by the; // dbg.assign, that has been killed, if any.; //; // calculateFragmentIntersect(..., SliceOffsetInBits=0,; // SliceSizeInBits=32, Dest=%dest, Assign=dbg.assign); //; // Drawing the store (s) in memory followed by the shortened version ($),; // then the dbg.assign (d), with the fragment information on a seperate scale; // underneath:; //; // Memory; // offset; // from; // dest 0 63; // | |; // s[######] - Original stores 64 bits to Dest.; // $----[##] - DSE says the lower 32 bits are dead, to be removed.; // d [##] - Assign's address-modifying expression adds 4 bytes to; // dest.; // Variable | |; // Fragment 128|; // Offsets 159; //; // The answer is achieved in a few steps:; // 1. Add the fragment offset to the store offset:; // SliceOffsetInBits:0 + VarFrag.OffsetInBits:128 = 128; //; // 2. Su",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:102,Modifiability,variab,variables,102,"// There are multiple offsets at play in this function, so let's break it; // down. Starting with how variables may be stored in allocas:; //; // 1 Simplest case: variable is alloca sized and starts at offset 0.; // 2 Variable is larger than the alloca: the alloca holds just a part of it.; // 3 Variable is smaller than the alloca: the alloca may hold multiple; // variables.; //; // Imagine we have a store to the entire alloca. In case (3) the store; // affects bits outside of the bounds of each variable. In case (2), where; // the alloca holds the Xth bit to the Yth bit of a variable, the; // zero-offset store doesn't represent an assignment at offset zero to the; // variable. It is an assignment to offset X.; //; // # Example 1; // Obviously, not all stores are alloca-sized and have zero offset. Imagine; // the lower 32 bits of this store are dead and are going to be DSEd:; //; // store i64 %v, ptr %dest, !DIAssignID !1; // dbg.assign(..., !DIExpression(fragment, 128, 32), !1, %dest,; // !DIExpression(DW_OP_plus_uconst, 4)); //; // Goal: Given our dead bits at offset:0 size:32 for the store, determine the; // part of the variable, which fits in the fragment expressed by the; // dbg.assign, that has been killed, if any.; //; // calculateFragmentIntersect(..., SliceOffsetInBits=0,; // SliceSizeInBits=32, Dest=%dest, Assign=dbg.assign); //; // Drawing the store (s) in memory followed by the shortened version ($),; // then the dbg.assign (d), with the fragment information on a seperate scale; // underneath:; //; // Memory; // offset; // from; // dest 0 63; // | |; // s[######] - Original stores 64 bits to Dest.; // $----[##] - DSE says the lower 32 bits are dead, to be removed.; // d [##] - Assign's address-modifying expression adds 4 bytes to; // dest.; // Variable | |; // Fragment 128|; // Offsets 159; //; // The answer is achieved in a few steps:; // 1. Add the fragment offset to the store offset:; // SliceOffsetInBits:0 + VarFrag.OffsetInBits:128 = 128; //; // 2. Su",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:163,Modifiability,variab,variable,163,"// There are multiple offsets at play in this function, so let's break it; // down. Starting with how variables may be stored in allocas:; //; // 1 Simplest case: variable is alloca sized and starts at offset 0.; // 2 Variable is larger than the alloca: the alloca holds just a part of it.; // 3 Variable is smaller than the alloca: the alloca may hold multiple; // variables.; //; // Imagine we have a store to the entire alloca. In case (3) the store; // affects bits outside of the bounds of each variable. In case (2), where; // the alloca holds the Xth bit to the Yth bit of a variable, the; // zero-offset store doesn't represent an assignment at offset zero to the; // variable. It is an assignment to offset X.; //; // # Example 1; // Obviously, not all stores are alloca-sized and have zero offset. Imagine; // the lower 32 bits of this store are dead and are going to be DSEd:; //; // store i64 %v, ptr %dest, !DIAssignID !1; // dbg.assign(..., !DIExpression(fragment, 128, 32), !1, %dest,; // !DIExpression(DW_OP_plus_uconst, 4)); //; // Goal: Given our dead bits at offset:0 size:32 for the store, determine the; // part of the variable, which fits in the fragment expressed by the; // dbg.assign, that has been killed, if any.; //; // calculateFragmentIntersect(..., SliceOffsetInBits=0,; // SliceSizeInBits=32, Dest=%dest, Assign=dbg.assign); //; // Drawing the store (s) in memory followed by the shortened version ($),; // then the dbg.assign (d), with the fragment information on a seperate scale; // underneath:; //; // Memory; // offset; // from; // dest 0 63; // | |; // s[######] - Original stores 64 bits to Dest.; // $----[##] - DSE says the lower 32 bits are dead, to be removed.; // d [##] - Assign's address-modifying expression adds 4 bytes to; // dest.; // Variable | |; // Fragment 128|; // Offsets 159; //; // The answer is achieved in a few steps:; // 1. Add the fragment offset to the store offset:; // SliceOffsetInBits:0 + VarFrag.OffsetInBits:128 = 128; //; // 2. Su",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:218,Modifiability,Variab,Variable,218,"// There are multiple offsets at play in this function, so let's break it; // down. Starting with how variables may be stored in allocas:; //; // 1 Simplest case: variable is alloca sized and starts at offset 0.; // 2 Variable is larger than the alloca: the alloca holds just a part of it.; // 3 Variable is smaller than the alloca: the alloca may hold multiple; // variables.; //; // Imagine we have a store to the entire alloca. In case (3) the store; // affects bits outside of the bounds of each variable. In case (2), where; // the alloca holds the Xth bit to the Yth bit of a variable, the; // zero-offset store doesn't represent an assignment at offset zero to the; // variable. It is an assignment to offset X.; //; // # Example 1; // Obviously, not all stores are alloca-sized and have zero offset. Imagine; // the lower 32 bits of this store are dead and are going to be DSEd:; //; // store i64 %v, ptr %dest, !DIAssignID !1; // dbg.assign(..., !DIExpression(fragment, 128, 32), !1, %dest,; // !DIExpression(DW_OP_plus_uconst, 4)); //; // Goal: Given our dead bits at offset:0 size:32 for the store, determine the; // part of the variable, which fits in the fragment expressed by the; // dbg.assign, that has been killed, if any.; //; // calculateFragmentIntersect(..., SliceOffsetInBits=0,; // SliceSizeInBits=32, Dest=%dest, Assign=dbg.assign); //; // Drawing the store (s) in memory followed by the shortened version ($),; // then the dbg.assign (d), with the fragment information on a seperate scale; // underneath:; //; // Memory; // offset; // from; // dest 0 63; // | |; // s[######] - Original stores 64 bits to Dest.; // $----[##] - DSE says the lower 32 bits are dead, to be removed.; // d [##] - Assign's address-modifying expression adds 4 bytes to; // dest.; // Variable | |; // Fragment 128|; // Offsets 159; //; // The answer is achieved in a few steps:; // 1. Add the fragment offset to the store offset:; // SliceOffsetInBits:0 + VarFrag.OffsetInBits:128 = 128; //; // 2. Su",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:296,Modifiability,Variab,Variable,296,"// There are multiple offsets at play in this function, so let's break it; // down. Starting with how variables may be stored in allocas:; //; // 1 Simplest case: variable is alloca sized and starts at offset 0.; // 2 Variable is larger than the alloca: the alloca holds just a part of it.; // 3 Variable is smaller than the alloca: the alloca may hold multiple; // variables.; //; // Imagine we have a store to the entire alloca. In case (3) the store; // affects bits outside of the bounds of each variable. In case (2), where; // the alloca holds the Xth bit to the Yth bit of a variable, the; // zero-offset store doesn't represent an assignment at offset zero to the; // variable. It is an assignment to offset X.; //; // # Example 1; // Obviously, not all stores are alloca-sized and have zero offset. Imagine; // the lower 32 bits of this store are dead and are going to be DSEd:; //; // store i64 %v, ptr %dest, !DIAssignID !1; // dbg.assign(..., !DIExpression(fragment, 128, 32), !1, %dest,; // !DIExpression(DW_OP_plus_uconst, 4)); //; // Goal: Given our dead bits at offset:0 size:32 for the store, determine the; // part of the variable, which fits in the fragment expressed by the; // dbg.assign, that has been killed, if any.; //; // calculateFragmentIntersect(..., SliceOffsetInBits=0,; // SliceSizeInBits=32, Dest=%dest, Assign=dbg.assign); //; // Drawing the store (s) in memory followed by the shortened version ($),; // then the dbg.assign (d), with the fragment information on a seperate scale; // underneath:; //; // Memory; // offset; // from; // dest 0 63; // | |; // s[######] - Original stores 64 bits to Dest.; // $----[##] - DSE says the lower 32 bits are dead, to be removed.; // d [##] - Assign's address-modifying expression adds 4 bytes to; // dest.; // Variable | |; // Fragment 128|; // Offsets 159; //; // The answer is achieved in a few steps:; // 1. Add the fragment offset to the store offset:; // SliceOffsetInBits:0 + VarFrag.OffsetInBits:128 = 128; //; // 2. Su",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:366,Modifiability,variab,variables,366,"// There are multiple offsets at play in this function, so let's break it; // down. Starting with how variables may be stored in allocas:; //; // 1 Simplest case: variable is alloca sized and starts at offset 0.; // 2 Variable is larger than the alloca: the alloca holds just a part of it.; // 3 Variable is smaller than the alloca: the alloca may hold multiple; // variables.; //; // Imagine we have a store to the entire alloca. In case (3) the store; // affects bits outside of the bounds of each variable. In case (2), where; // the alloca holds the Xth bit to the Yth bit of a variable, the; // zero-offset store doesn't represent an assignment at offset zero to the; // variable. It is an assignment to offset X.; //; // # Example 1; // Obviously, not all stores are alloca-sized and have zero offset. Imagine; // the lower 32 bits of this store are dead and are going to be DSEd:; //; // store i64 %v, ptr %dest, !DIAssignID !1; // dbg.assign(..., !DIExpression(fragment, 128, 32), !1, %dest,; // !DIExpression(DW_OP_plus_uconst, 4)); //; // Goal: Given our dead bits at offset:0 size:32 for the store, determine the; // part of the variable, which fits in the fragment expressed by the; // dbg.assign, that has been killed, if any.; //; // calculateFragmentIntersect(..., SliceOffsetInBits=0,; // SliceSizeInBits=32, Dest=%dest, Assign=dbg.assign); //; // Drawing the store (s) in memory followed by the shortened version ($),; // then the dbg.assign (d), with the fragment information on a seperate scale; // underneath:; //; // Memory; // offset; // from; // dest 0 63; // | |; // s[######] - Original stores 64 bits to Dest.; // $----[##] - DSE says the lower 32 bits are dead, to be removed.; // d [##] - Assign's address-modifying expression adds 4 bytes to; // dest.; // Variable | |; // Fragment 128|; // Offsets 159; //; // The answer is achieved in a few steps:; // 1. Add the fragment offset to the store offset:; // SliceOffsetInBits:0 + VarFrag.OffsetInBits:128 = 128; //; // 2. Su",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:500,Modifiability,variab,variable,500,"// There are multiple offsets at play in this function, so let's break it; // down. Starting with how variables may be stored in allocas:; //; // 1 Simplest case: variable is alloca sized and starts at offset 0.; // 2 Variable is larger than the alloca: the alloca holds just a part of it.; // 3 Variable is smaller than the alloca: the alloca may hold multiple; // variables.; //; // Imagine we have a store to the entire alloca. In case (3) the store; // affects bits outside of the bounds of each variable. In case (2), where; // the alloca holds the Xth bit to the Yth bit of a variable, the; // zero-offset store doesn't represent an assignment at offset zero to the; // variable. It is an assignment to offset X.; //; // # Example 1; // Obviously, not all stores are alloca-sized and have zero offset. Imagine; // the lower 32 bits of this store are dead and are going to be DSEd:; //; // store i64 %v, ptr %dest, !DIAssignID !1; // dbg.assign(..., !DIExpression(fragment, 128, 32), !1, %dest,; // !DIExpression(DW_OP_plus_uconst, 4)); //; // Goal: Given our dead bits at offset:0 size:32 for the store, determine the; // part of the variable, which fits in the fragment expressed by the; // dbg.assign, that has been killed, if any.; //; // calculateFragmentIntersect(..., SliceOffsetInBits=0,; // SliceSizeInBits=32, Dest=%dest, Assign=dbg.assign); //; // Drawing the store (s) in memory followed by the shortened version ($),; // then the dbg.assign (d), with the fragment information on a seperate scale; // underneath:; //; // Memory; // offset; // from; // dest 0 63; // | |; // s[######] - Original stores 64 bits to Dest.; // $----[##] - DSE says the lower 32 bits are dead, to be removed.; // d [##] - Assign's address-modifying expression adds 4 bytes to; // dest.; // Variable | |; // Fragment 128|; // Offsets 159; //; // The answer is achieved in a few steps:; // 1. Add the fragment offset to the store offset:; // SliceOffsetInBits:0 + VarFrag.OffsetInBits:128 = 128; //; // 2. Su",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:582,Modifiability,variab,variable,582,"// There are multiple offsets at play in this function, so let's break it; // down. Starting with how variables may be stored in allocas:; //; // 1 Simplest case: variable is alloca sized and starts at offset 0.; // 2 Variable is larger than the alloca: the alloca holds just a part of it.; // 3 Variable is smaller than the alloca: the alloca may hold multiple; // variables.; //; // Imagine we have a store to the entire alloca. In case (3) the store; // affects bits outside of the bounds of each variable. In case (2), where; // the alloca holds the Xth bit to the Yth bit of a variable, the; // zero-offset store doesn't represent an assignment at offset zero to the; // variable. It is an assignment to offset X.; //; // # Example 1; // Obviously, not all stores are alloca-sized and have zero offset. Imagine; // the lower 32 bits of this store are dead and are going to be DSEd:; //; // store i64 %v, ptr %dest, !DIAssignID !1; // dbg.assign(..., !DIExpression(fragment, 128, 32), !1, %dest,; // !DIExpression(DW_OP_plus_uconst, 4)); //; // Goal: Given our dead bits at offset:0 size:32 for the store, determine the; // part of the variable, which fits in the fragment expressed by the; // dbg.assign, that has been killed, if any.; //; // calculateFragmentIntersect(..., SliceOffsetInBits=0,; // SliceSizeInBits=32, Dest=%dest, Assign=dbg.assign); //; // Drawing the store (s) in memory followed by the shortened version ($),; // then the dbg.assign (d), with the fragment information on a seperate scale; // underneath:; //; // Memory; // offset; // from; // dest 0 63; // | |; // s[######] - Original stores 64 bits to Dest.; // $----[##] - DSE says the lower 32 bits are dead, to be removed.; // d [##] - Assign's address-modifying expression adds 4 bytes to; // dest.; // Variable | |; // Fragment 128|; // Offsets 159; //; // The answer is achieved in a few steps:; // 1. Add the fragment offset to the store offset:; // SliceOffsetInBits:0 + VarFrag.OffsetInBits:128 = 128; //; // 2. Su",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:676,Modifiability,variab,variable,676,"// There are multiple offsets at play in this function, so let's break it; // down. Starting with how variables may be stored in allocas:; //; // 1 Simplest case: variable is alloca sized and starts at offset 0.; // 2 Variable is larger than the alloca: the alloca holds just a part of it.; // 3 Variable is smaller than the alloca: the alloca may hold multiple; // variables.; //; // Imagine we have a store to the entire alloca. In case (3) the store; // affects bits outside of the bounds of each variable. In case (2), where; // the alloca holds the Xth bit to the Yth bit of a variable, the; // zero-offset store doesn't represent an assignment at offset zero to the; // variable. It is an assignment to offset X.; //; // # Example 1; // Obviously, not all stores are alloca-sized and have zero offset. Imagine; // the lower 32 bits of this store are dead and are going to be DSEd:; //; // store i64 %v, ptr %dest, !DIAssignID !1; // dbg.assign(..., !DIExpression(fragment, 128, 32), !1, %dest,; // !DIExpression(DW_OP_plus_uconst, 4)); //; // Goal: Given our dead bits at offset:0 size:32 for the store, determine the; // part of the variable, which fits in the fragment expressed by the; // dbg.assign, that has been killed, if any.; //; // calculateFragmentIntersect(..., SliceOffsetInBits=0,; // SliceSizeInBits=32, Dest=%dest, Assign=dbg.assign); //; // Drawing the store (s) in memory followed by the shortened version ($),; // then the dbg.assign (d), with the fragment information on a seperate scale; // underneath:; //; // Memory; // offset; // from; // dest 0 63; // | |; // s[######] - Original stores 64 bits to Dest.; // $----[##] - DSE says the lower 32 bits are dead, to be removed.; // d [##] - Assign's address-modifying expression adds 4 bytes to; // dest.; // Variable | |; // Fragment 128|; // Offsets 159; //; // The answer is achieved in a few steps:; // 1. Add the fragment offset to the store offset:; // SliceOffsetInBits:0 + VarFrag.OffsetInBits:128 = 128; //; // 2. Su",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:1140,Modifiability,variab,variable,1140," down. Starting with how variables may be stored in allocas:; //; // 1 Simplest case: variable is alloca sized and starts at offset 0.; // 2 Variable is larger than the alloca: the alloca holds just a part of it.; // 3 Variable is smaller than the alloca: the alloca may hold multiple; // variables.; //; // Imagine we have a store to the entire alloca. In case (3) the store; // affects bits outside of the bounds of each variable. In case (2), where; // the alloca holds the Xth bit to the Yth bit of a variable, the; // zero-offset store doesn't represent an assignment at offset zero to the; // variable. It is an assignment to offset X.; //; // # Example 1; // Obviously, not all stores are alloca-sized and have zero offset. Imagine; // the lower 32 bits of this store are dead and are going to be DSEd:; //; // store i64 %v, ptr %dest, !DIAssignID !1; // dbg.assign(..., !DIExpression(fragment, 128, 32), !1, %dest,; // !DIExpression(DW_OP_plus_uconst, 4)); //; // Goal: Given our dead bits at offset:0 size:32 for the store, determine the; // part of the variable, which fits in the fragment expressed by the; // dbg.assign, that has been killed, if any.; //; // calculateFragmentIntersect(..., SliceOffsetInBits=0,; // SliceSizeInBits=32, Dest=%dest, Assign=dbg.assign); //; // Drawing the store (s) in memory followed by the shortened version ($),; // then the dbg.assign (d), with the fragment information on a seperate scale; // underneath:; //; // Memory; // offset; // from; // dest 0 63; // | |; // s[######] - Original stores 64 bits to Dest.; // $----[##] - DSE says the lower 32 bits are dead, to be removed.; // d [##] - Assign's address-modifying expression adds 4 bytes to; // dest.; // Variable | |; // Fragment 128|; // Offsets 159; //; // The answer is achieved in a few steps:; // 1. Add the fragment offset to the store offset:; // SliceOffsetInBits:0 + VarFrag.OffsetInBits:128 = 128; //; // 2. Subtract the address-modifying expression offset plus difference; // between d.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:1785,Modifiability,Variab,Variable,1785," bits of this store are dead and are going to be DSEd:; //; // store i64 %v, ptr %dest, !DIAssignID !1; // dbg.assign(..., !DIExpression(fragment, 128, 32), !1, %dest,; // !DIExpression(DW_OP_plus_uconst, 4)); //; // Goal: Given our dead bits at offset:0 size:32 for the store, determine the; // part of the variable, which fits in the fragment expressed by the; // dbg.assign, that has been killed, if any.; //; // calculateFragmentIntersect(..., SliceOffsetInBits=0,; // SliceSizeInBits=32, Dest=%dest, Assign=dbg.assign); //; // Drawing the store (s) in memory followed by the shortened version ($),; // then the dbg.assign (d), with the fragment information on a seperate scale; // underneath:; //; // Memory; // offset; // from; // dest 0 63; // | |; // s[######] - Original stores 64 bits to Dest.; // $----[##] - DSE says the lower 32 bits are dead, to be removed.; // d [##] - Assign's address-modifying expression adds 4 bytes to; // dest.; // Variable | |; // Fragment 128|; // Offsets 159; //; // The answer is achieved in a few steps:; // 1. Add the fragment offset to the store offset:; // SliceOffsetInBits:0 + VarFrag.OffsetInBits:128 = 128; //; // 2. Subtract the address-modifying expression offset plus difference; // between d.address and dest:; // 128 - (expression_offset:32 + (d.address - dest):0) = 96; //; // 3. That offset along with the store size (32) represents the bits of the; // variable that'd be affected by the store. Call it SliceOfVariable.; // Intersect that with Assign's fragment info:; // SliceOfVariable  Assign_fragment = none; //; // In this case: none of the dead bits of the store affect Assign.; //; // # Example 2; // Similar example with the same goal. This time the upper 16 bits; // of the store are going to be DSE'd.; //; // store i64 %v, ptr %dest, !DIAssignID !1; // dbg.assign(..., !DIExpression(fragment, 128, 32), !1, %dest,; // !DIExpression(DW_OP_plus_uconst, 4)); //; // calculateFragmentIntersect(..., SliceOffsetInBits=48,; // SliceSizeIn",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:2242,Modifiability,variab,variable,2242,"illed, if any.; //; // calculateFragmentIntersect(..., SliceOffsetInBits=0,; // SliceSizeInBits=32, Dest=%dest, Assign=dbg.assign); //; // Drawing the store (s) in memory followed by the shortened version ($),; // then the dbg.assign (d), with the fragment information on a seperate scale; // underneath:; //; // Memory; // offset; // from; // dest 0 63; // | |; // s[######] - Original stores 64 bits to Dest.; // $----[##] - DSE says the lower 32 bits are dead, to be removed.; // d [##] - Assign's address-modifying expression adds 4 bytes to; // dest.; // Variable | |; // Fragment 128|; // Offsets 159; //; // The answer is achieved in a few steps:; // 1. Add the fragment offset to the store offset:; // SliceOffsetInBits:0 + VarFrag.OffsetInBits:128 = 128; //; // 2. Subtract the address-modifying expression offset plus difference; // between d.address and dest:; // 128 - (expression_offset:32 + (d.address - dest):0) = 96; //; // 3. That offset along with the store size (32) represents the bits of the; // variable that'd be affected by the store. Call it SliceOfVariable.; // Intersect that with Assign's fragment info:; // SliceOfVariable  Assign_fragment = none; //; // In this case: none of the dead bits of the store affect Assign.; //; // # Example 2; // Similar example with the same goal. This time the upper 16 bits; // of the store are going to be DSE'd.; //; // store i64 %v, ptr %dest, !DIAssignID !1; // dbg.assign(..., !DIExpression(fragment, 128, 32), !1, %dest,; // !DIExpression(DW_OP_plus_uconst, 4)); //; // calculateFragmentIntersect(..., SliceOffsetInBits=48,; // SliceSizeInBits=16, Dest=%dest, Assign=dbg.assign); //; // Memory; // offset; // from; // dest 0 63; // | |; // s[######] - Original stores 64 bits to Dest.; // $[####]-- - DSE says the upper 16 bits are dead, to be removed.; // d [##] - Assign's address-modifying expression adds 4 bytes to; // dest.; // Variable | |; // Fragment 128|; // Offsets 159; //; // Using the same steps in the first example:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:3128,Modifiability,Variab,Variable,3128,"st 0 63; // | |; // s[######] - Original stores 64 bits to Dest.; // $----[##] - DSE says the lower 32 bits are dead, to be removed.; // d [##] - Assign's address-modifying expression adds 4 bytes to; // dest.; // Variable | |; // Fragment 128|; // Offsets 159; //; // The answer is achieved in a few steps:; // 1. Add the fragment offset to the store offset:; // SliceOffsetInBits:0 + VarFrag.OffsetInBits:128 = 128; //; // 2. Subtract the address-modifying expression offset plus difference; // between d.address and dest:; // 128 - (expression_offset:32 + (d.address - dest):0) = 96; //; // 3. That offset along with the store size (32) represents the bits of the; // variable that'd be affected by the store. Call it SliceOfVariable.; // Intersect that with Assign's fragment info:; // SliceOfVariable  Assign_fragment = none; //; // In this case: none of the dead bits of the store affect Assign.; //; // # Example 2; // Similar example with the same goal. This time the upper 16 bits; // of the store are going to be DSE'd.; //; // store i64 %v, ptr %dest, !DIAssignID !1; // dbg.assign(..., !DIExpression(fragment, 128, 32), !1, %dest,; // !DIExpression(DW_OP_plus_uconst, 4)); //; // calculateFragmentIntersect(..., SliceOffsetInBits=48,; // SliceSizeInBits=16, Dest=%dest, Assign=dbg.assign); //; // Memory; // offset; // from; // dest 0 63; // | |; // s[######] - Original stores 64 bits to Dest.; // $[####]-- - DSE says the upper 16 bits are dead, to be removed.; // d [##] - Assign's address-modifying expression adds 4 bytes to; // dest.; // Variable | |; // Fragment 128|; // Offsets 159; //; // Using the same steps in the first example:; // 1. SliceOffsetInBits:48 + VarFrag.OffsetInBits:128 = 176; // 2. 176 - (expression_offset:32 + (d.address - dest):0) = 144; // 3. SliceOfVariable offset = 144, size = 16:; // SliceOfVariable  Assign_fragment = (offset: 144, size: 16); // SliceOfVariable tells us the bits of the variable described by Assign that; // are affected by the DSE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:3509,Modifiability,variab,variable,3509,"st 0 63; // | |; // s[######] - Original stores 64 bits to Dest.; // $----[##] - DSE says the lower 32 bits are dead, to be removed.; // d [##] - Assign's address-modifying expression adds 4 bytes to; // dest.; // Variable | |; // Fragment 128|; // Offsets 159; //; // The answer is achieved in a few steps:; // 1. Add the fragment offset to the store offset:; // SliceOffsetInBits:0 + VarFrag.OffsetInBits:128 = 128; //; // 2. Subtract the address-modifying expression offset plus difference; // between d.address and dest:; // 128 - (expression_offset:32 + (d.address - dest):0) = 96; //; // 3. That offset along with the store size (32) represents the bits of the; // variable that'd be affected by the store. Call it SliceOfVariable.; // Intersect that with Assign's fragment info:; // SliceOfVariable  Assign_fragment = none; //; // In this case: none of the dead bits of the store affect Assign.; //; // # Example 2; // Similar example with the same goal. This time the upper 16 bits; // of the store are going to be DSE'd.; //; // store i64 %v, ptr %dest, !DIAssignID !1; // dbg.assign(..., !DIExpression(fragment, 128, 32), !1, %dest,; // !DIExpression(DW_OP_plus_uconst, 4)); //; // calculateFragmentIntersect(..., SliceOffsetInBits=48,; // SliceSizeInBits=16, Dest=%dest, Assign=dbg.assign); //; // Memory; // offset; // from; // dest 0 63; // | |; // s[######] - Original stores 64 bits to Dest.; // $[####]-- - DSE says the upper 16 bits are dead, to be removed.; // d [##] - Assign's address-modifying expression adds 4 bytes to; // dest.; // Variable | |; // Fragment 128|; // Offsets 159; //; // Using the same steps in the first example:; // 1. SliceOffsetInBits:48 + VarFrag.OffsetInBits:128 = 176; // 2. 176 - (expression_offset:32 + (d.address - dest):0) = 144; // 3. SliceOfVariable offset = 144, size = 16:; // SliceOfVariable  Assign_fragment = (offset: 144, size: 16); // SliceOfVariable tells us the bits of the variable described by Assign that; // are affected by the DSE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:148,Usability,Simpl,Simplest,148,"// There are multiple offsets at play in this function, so let's break it; // down. Starting with how variables may be stored in allocas:; //; // 1 Simplest case: variable is alloca sized and starts at offset 0.; // 2 Variable is larger than the alloca: the alloca holds just a part of it.; // 3 Variable is smaller than the alloca: the alloca may hold multiple; // variables.; //; // Imagine we have a store to the entire alloca. In case (3) the store; // affects bits outside of the bounds of each variable. In case (2), where; // the alloca holds the Xth bit to the Yth bit of a variable, the; // zero-offset store doesn't represent an assignment at offset zero to the; // variable. It is an assignment to offset X.; //; // # Example 1; // Obviously, not all stores are alloca-sized and have zero offset. Imagine; // the lower 32 bits of this store are dead and are going to be DSEd:; //; // store i64 %v, ptr %dest, !DIAssignID !1; // dbg.assign(..., !DIExpression(fragment, 128, 32), !1, %dest,; // !DIExpression(DW_OP_plus_uconst, 4)); //; // Goal: Given our dead bits at offset:0 size:32 for the store, determine the; // part of the variable, which fits in the fragment expressed by the; // dbg.assign, that has been killed, if any.; //; // calculateFragmentIntersect(..., SliceOffsetInBits=0,; // SliceSizeInBits=32, Dest=%dest, Assign=dbg.assign); //; // Drawing the store (s) in memory followed by the shortened version ($),; // then the dbg.assign (d), with the fragment information on a seperate scale; // underneath:; //; // Memory; // offset; // from; // dest 0 63; // | |; // s[######] - Original stores 64 bits to Dest.; // $----[##] - DSE says the lower 32 bits are dead, to be removed.; // d [##] - Assign's address-modifying expression adds 4 bytes to; // dest.; // Variable | |; // Fragment 128|; // Offsets 159; //; // The answer is achieved in a few steps:; // 1. Add the fragment offset to the store offset:; // SliceOffsetInBits:0 + VarFrag.OffsetInBits:128 = 128; //; // 2. Su",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:3,Modifiability,Variab,Variable,3,// Variable size is unknown.; // Calculate the difference between Dest and the dbg.assign address +; // address-modifying expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:101,Modifiability,variab,variable,101,// Adjust the slice offset so that we go from describing the a slice; // of memory to a slice of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:72,Availability,down,down,72,// Intersect the variable slice with AssignRecord's fragment to trim it down; // to size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:17,Modifiability,variab,variable,17,// Intersect the variable slice with AssignRecord's fragment to trim it down; // to size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:70,Modifiability,variab,variable,70,/// Returns nullptr if the assignment shouldn't be attributed to this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:78,Modifiability,variab,variables,78,"// NOTE: trackAssignments doesn't understand base expressions yet, so all; // variables that reach here are guaranteed to start at offset 0 in the; // alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:39,Modifiability,variab,variable,39,// Discard stores to bits outside this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:42,Modifiability,variab,variables,42,// Early-exit if there are no interesting variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:53,Modifiability,variab,variables,53,// Scan the instructions looking for stores to local variables' storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:24,Modifiability,variab,variable,24,// We want to track the variable's stack home from its alloca's; // position onwards so we treat it as an assignment (where the stored; // value is Undef).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:45,Modifiability,variab,variable,45,// Check if the store destination is a local variable with debug info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:44,Modifiability,variab,variables,44,// Create another similar map of {storage : variables} that we'll pass to; // trackAssignments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:76,Modifiability,variab,variable,76,"// FIXME: trackAssignments doesn't let you specify any modifiers to the; // variable (e.g. fragment) or location (e.g. offset), so we have to; // leave dbg.declares with non-empty expressions in place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:39,Modifiability,variab,variables,39,// FIXME: Skip VLAs for now (let these variables use dbg.declares).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:19,Performance,scalab,scalable,19,"// Similarly, skip scalable vectors (use dbg.declares instead).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:342,Integrability,depend,dependent,342,"// FIXME: Locals can be backed by caller allocas (sret, byval).; // Note: trackAssignments doesn't respect dbg.declare's IR positions (as it; // doesn't ""understand"" dbg.declares). However, this doesn't appear to break; // any rules given this description of dbg.declare from; // llvm/docs/SourceLevelDebugging.rst:; //; // It is not control-dependent, meaning that if a call to llvm.dbg.declare; // exists and has a valid location argument, that address is considered to; // be the true home of the variable across its entire lifetime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:500,Modifiability,variab,variable,500,"// FIXME: Locals can be backed by caller allocas (sret, byval).; // Note: trackAssignments doesn't respect dbg.declare's IR positions (as it; // doesn't ""understand"" dbg.declares). However, this doesn't appear to break; // any rules given this description of dbg.declare from; // llvm/docs/SourceLevelDebugging.rst:; //; // It is not control-dependent, meaning that if a call to llvm.dbg.declare; // exists and has a valid location argument, that address is considered to; // be the true home of the variable across its entire lifetime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:27,Modifiability,variab,variables,27,// Delete dbg.declares for variables now tracked with assignment tracking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:98,Modifiability,variab,variable,98,"// Assert that the alloca that Declare uses is now linked to a dbg.assign; // describing the same variable (i.e. check that this dbg.declare has; // been replaced by a dbg.assign). Use DebugVariableAggregate to Discard; // the fragment part because trackAssignments may alter the; // fragment. e.g. if the alloca is smaller than the variable, then; // trackAssignments will create an alloca-sized fragment for the; // dbg.assign.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:333,Modifiability,variab,variable,333,"// Assert that the alloca that Declare uses is now linked to a dbg.assign; // describing the same variable (i.e. check that this dbg.declare has; // been replaced by a dbg.assign). Use DebugVariableAggregate to Discard; // the fragment part because trackAssignments may alter the; // fragment. e.g. if the alloca is smaller than the variable, then; // trackAssignments will create an alloca-sized fragment for the; // dbg.assign.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:3,Testability,Assert,Assert,3,"// Assert that the alloca that Declare uses is now linked to a dbg.assign; // describing the same variable (i.e. check that this dbg.declare has; // been replaced by a dbg.assign). Use DebugVariableAggregate to Discard; // the fragment part because trackAssignments may alter the; // fragment. e.g. if the alloca is smaller than the variable, then; // trackAssignments will create an alloca-sized fragment for the; // dbg.assign.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:30,Modifiability,variab,variable,30,// Delete Declare because the variable location is now tracked using; // assignment tracking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp:239,Usability,simpl,simpler,239,"// Encoding may be unsuccessful because of overflow. We determine success by; // checking equivalence of components before & after encoding. Alternatively,; // we could determine Success during encoding, but the current alternative is; // simpler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp:118,Security,Checksum,ChecksumKind,118,"// The first space was originally the CSK_None variant, which is now; // obsolete, but the space is still reserved in ChecksumKind, so we account; // for it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp:81,Performance,cache,cached,81,"// Recreate the scope chain, bottom-up, starting at the new subprogram (or a; // cached result).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp:61,Modifiability,refactor,refactored,61,// The nullptr is for DIScope's File operand. This should be refactored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp:61,Modifiability,refactor,refactored,61,// The nullptr is for DIScope's File operand. This should be refactored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp:122,Modifiability,variab,variable,122,"// Must be more than one implicit element on the stack.; // FIXME: A better way to implement this would be to add a local variable; // that keeps track of the stack depth and introduce something like a; // DW_LLVM_OP_implicit_location as a placeholder for the location this; // DIExpression is attached to, or else pass the number of implicit stack; // elements into isValid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp:214,Usability,simpl,simple,214,"// An entry value operator must appear at the beginning or immediately; // following `DW_OP_LLVM_arg 0`, and the number of operations it cover can; // currently only be 1, because we support only entry values of a simple; // register location. One reason for this is that we currently can't; // calculate the size of the resulting DWARF block for other expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp:3,Safety,Avoid,Avoid,3,"// Avoid UB when encountering LLONG_MIN, because in 2's complement; // abs(LLONG_MIN) is LLONG_MAX+1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp:22,Safety,safe,safe,22,"// Track whether it's safe to split the value at the top of the DWARF stack,; // assuming that it'll be used as an implicit location value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp:12,Safety,safe,safely,12,// We can't safely split arithmetic or shift operations into multiple; // fragments because we can't express carry-over between fragments.; //; // FIXME: We *could* preserve the lowest fragment of a constant offset; // operation if the offset fits into SizeInBits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp:110,Performance,load,loaded,110,// Preceeding arithmetic operations have been applied to compute an; // address. It's okay to split the value loaded from that address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp:14,Deployability,update,update,14,// We need to update the set storage once the Args are updated since they; // form the key to the DIArgLists store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp:55,Deployability,update,updated,55,// We need to update the set storage once the Args are updated since they; // form the key to the DIArgLists store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp:212,Usability,simpl,simply,212,"// We've changed the contents of this DIArgList, and the set storage may; // already contain a DIArgList with our new set of args; if it does, then we; // must RAUW this with the existing DIArgList, otherwise we simply insert this; // back into the set storage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp:3,Usability,Clear,Clear,3,// Clear this here so we don't try to untrack in the destructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugLoc.cpp:9,Performance,cache,cache,9,"// If no cache hits, then back() is the end of the inline chain, that is,; // the DILocation whose scope ends in the Subprogram to be replaced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugLoc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugLoc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugLoc.cpp:79,Performance,cache,cached,79,"// Recreate the location chain, bottom-up, starting at the new scope (or a; // cached result).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugLoc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugLoc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugLoc.cpp:142,Deployability,update,update,142,"// Starting from the top, rebuild the nodes to point to the new inlined-at; // location (then rebuilding the rest of the chain behind it) and update the; // map of already-constructed inlined-at nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugLoc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugLoc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugProgramInstruction.cpp:34,Integrability,wrap,wrapping,34,// Set our location to be the MAV wrapping the new Value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugProgramInstruction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugProgramInstruction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugProgramInstruction.cpp:149,Availability,down,down,149,"// Work out what range of DPValues to clone: normally all the contents of the; // ""From"" marker, optionally we can start from the from_here position down to; // end().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DebugProgramInstruction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugProgramInstruction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DiagnosticInfo.cpp:96,Availability,avail,available,96,// Only include names that correspond to user variables. FIXME: We should use; // debug info if available to get the name of the user variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DiagnosticInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DiagnosticInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DiagnosticInfo.cpp:46,Modifiability,variab,variables,46,// Only include names that correspond to user variables. FIXME: We should use; // debug info if available to get the name of the user variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DiagnosticInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DiagnosticInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DiagnosticInfo.cpp:134,Modifiability,variab,variable,134,// Only include names that correspond to user variables. FIXME: We should use; // debug info if available to get the name of the user variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DiagnosticInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DiagnosticInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp:34,Modifiability,variab,variables,34,// The optimizer may remove local variables. If there is an interest; // to preserve variable info in such situation then stash it in a; // named mdnode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp:85,Modifiability,variab,variable,85,// The optimizer may remove local variables. If there is an interest; // to preserve variable info in such situation then stash it in a; // named mdnode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp:7,Performance,optimiz,optimizer,7,// The optimizer may remove local variables. If there is an interest; // to preserve variable info in such situation then stash it in a; // named mdnode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp:8,Performance,optimiz,optimizer,8,/// The optimizer may remove labels. If there is an interest; /// to preserve label info in such situation then append it to; /// the list of retained nodes of the DISubprogram.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp:322,Usability,simpl,simplicity,322,"// It is okay to *not* make anonymous top-level namespaces distinct, because; // all nodes that have an anonymous namespace as their parent scope are; // guaranteed to be unique and/or are linked to their containing; // DICompileUnit. This decision is an explicit tradeoff of link time versus; // memory usage versus code simplicity and may get revisited in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp:27,Safety,avoid,avoid,27,"// Make these distinct, to avoid merging two lexical blocks on the same; // file/line/column.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Dominators.cpp:500,Availability,avail,available,500,"//===- Dominators.cpp - Dominator Calculation -----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements simple dominator construction algorithms for finding; // forward dominators. Postdominators are available in libanalysis, but are not; // included in libvmcore, because it's not needed. Forward dominators are; // needed to support the Verifier pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Dominators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Dominators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Dominators.cpp:404,Usability,simpl,simple,404,"//===- Dominators.cpp - Dominator Calculation -----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements simple dominator construction algorithms for finding; // forward dominators. Postdominators are available in libanalysis, but are not; // included in libvmcore, because it's not needed. Forward dominators are; // needed to support the Verifier pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Dominators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Dominators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Dominators.cpp:219,Security,access,access,219,"//===----------------------------------------------------------------------===//; // DominatorTree Implementation; //===----------------------------------------------------------------------===//; //; // Provide public access to DominatorTree information. Implementation details; // can be found in Dominators.h, GenericDomTree.h, and; // GenericDomTreeConstruction.h.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Dominators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Dominators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Dominators.cpp:64,Performance,perform,performs,64,// dominates - Return true if Def dominates a use in User. This performs; // the special checks necessary if Def and User are in the same basic block.; // Note that Def doesn't dominate a use in Def itself!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Dominators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Dominators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Dominators.cpp:27,Usability,usab,usable,27,"// Invoke results are only usable in the normal destination, not in the; // exceptional destination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Dominators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Dominators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Dominators.cpp:3,Usability,Simpl,Simple,3,"// Simple case: if the end BB has a single predecessor, the fact that it; // dominates the use block implies that the edge also does.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Dominators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Dominators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Dominators.cpp:52,Usability,simpl,simple,52,"// If the def and use are in different blocks, do a simple CFG dominator; // tree query.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Dominators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Dominators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Dominators.cpp:249,Integrability,wrap,wrapper,249,//===----------------------------------------------------------------------===//; // DominatorTreeWrapperPass Implementation; //===----------------------------------------------------------------------===//; //; // The implementation details of the wrapper pass that holds a DominatorTree; // suitable for use with the legacy pass manager.; //; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Dominators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Dominators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/EHPersonalities.cpp:12,Usability,simpl,simplify,12,// We can't simplify any invokes to nounwind functions if the personality; // function wants to catch asynch exceptions. The nounwind attribute only; // implies that the function does not throw synchronous exceptions.; // Cannot simplify CXX Personality under AsynchEH,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/EHPersonalities.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/EHPersonalities.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/EHPersonalities.cpp:229,Usability,simpl,simplify,229,// We can't simplify any invokes to nounwind functions if the personality; // function wants to catch asynch exceptions. The nounwind attribute only; // implies that the function does not throw synchronous exceptions.; // Cannot simplify CXX Personality under AsynchEH,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/EHPersonalities.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/EHPersonalities.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp:20,Safety,safe,safe,20,// After this it is safe to delete instructions.; // Delete all of the method arguments and unlink from symbol table...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Function.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp:3,Usability,Clear,Clear,3,// Clear the lazy arguments bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Function.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp:39,Security,access,access,39,/// Determine if the function does not access memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Function.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp:39,Security,access,access,39,/// Determine if the function does not access or only reads memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Function.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp:39,Security,access,access,39,/// Determine if the function does not access or only writes memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Function.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp:30,Security,access,access,30,/// Determine if the call can access memmory only using pointers based; /// on its arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Function.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp:39,Security,access,access,39,/// Determine if the function may only access memory that is; /// inaccessible from the IR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Function.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp:39,Security,access,access,39,/// Determine if the function may only access memory that is; /// either inaccessible from the IR or pointed to by its arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Function.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp:175,Usability,simpl,simply,175,"/// Returns a stable mangling for the type specified for use in the name; /// mangling scheme used by 'any' types in intrinsic signatures. The mangling; /// of named types is simply their name. Manglings for unnamed types consist; /// of a prefix ('p' for pointers, 'a' for arrays, 'f_' for functions); /// combined with the mangling of their component types. A vararg function; /// type will have a suffix of 'vararg'. Since function types can contain; /// other function types, we close a function type mangling with suffix 'f'; /// which can't be confused with it's prefix. This ensures we don't have; /// collisions between two unrelated function types. Otherwise, you might; /// parse ffXX as f(fXX) or f(fX)X. (X is a placeholder for any other type.); /// The HasUnnamedType boolean is set if an unnamed type was encountered,; /// indicating that extra care must be taken to ensure a unique name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Function.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp:237,Availability,error,error,237,"// The name already exists, but is not a function or has the wrong; // prototype. Make place for the new one by renaming the old version.; // Either this old version will be removed later on or the module is; // invalid and we'll get an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Function.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp:254,Modifiability,variab,variables,254,"/// hasAddressTaken - returns true if there are any uses of this function; /// other than direct calls or invokes to it. Optionally ignores callback; /// uses, assume like pointer annotation calls, and references in llvm.used; /// and llvm.compiler.used variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Function.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp:20,Energy Efficiency,allocate,allocated,20,"// If we've already allocated a uselist, stop here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Function.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/GCStrategy.cpp:586,Availability,error,error,586,"// We need to link all the builtin GCs when LLVM is used as a static library.; // The linker will quite happily remove the static constructors that register; // the builtin GCs if we don't use a function from that object. This function; // does nothing but we need to make sure it is (or at least could be, even; // with all optimisations enabled) called *somewhere*, and this is a good; // place to do that: if the GC strategies are being used then this function; // obviously can't be removed by the linker, and here it won't affect; // performance, since there's about to be a fatal error anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/GCStrategy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/GCStrategy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/GCStrategy.cpp:539,Performance,perform,performance,539,"// We need to link all the builtin GCs when LLVM is used as a static library.; // The linker will quite happily remove the static constructors that register; // the builtin GCs if we don't use a function from that object. This function; // does nothing but we need to make sure it is (or at least could be, even; // with all optimisations enabled) called *somewhere*, and this is a good; // place to do that: if the GC strategies are being used then this function; // obviously can't be removed by the linker, and here it won't affect; // performance, since there's about to be a fatal error anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/GCStrategy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/GCStrategy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp:290,Testability,assert,assert,290,"//===----------------------------------------------------------------------===//; // GlobalValue Class; //===----------------------------------------------------------------------===//; // GlobalValue should be a Constant, plus a type, a module, some flags, and an; // intrinsic ID. Add an assert to prevent people from accidentally growing; // GlobalValue while adding flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Globals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp:164,Safety,avoid,avoid,164,"// See AsmPrinter::getSymbolPreferLocal(). For a deduplicate comdat kind,; // references to a discarded local symbol from outside the group are not; // allowed, so avoid the local alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Globals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp:23,Usability,clear,clearing,23,// Do nothing if we're clearing the partition and it is already empty.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Globals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp:3,Deployability,Update,Update,3,// Update the HasPartition field. Setting the partition to the empty string; // means this global no longer has a partition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Globals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp:23,Usability,clear,clearing,23,// Do nothing if we're clearing the section and it is already empty.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Globals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp:3,Deployability,Update,Update,3,// Update the HasSectionHashEntryBit. Setting the section to the empty string; // means this global no longer has a section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Globals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp:275,Energy Efficiency,allocate,allocates,275,"// On ELF platforms, we're further restricted in that we can't; // increase the alignment of any variable which might be emitted; // into a shared library, and which is exported. If the main; // executable accesses a variable found in a shared-lib, the main; // exe actually allocates memory for and exports the symbol ITSELF,; // overriding the symbol found in the library. That is, at link; // time, the observed alignment of the variable is copied into the; // executable binary. (A COPY relocation is also generated, to copy; // the initial data from the shadowed variable in the shared-lib; // into the location in the main binary, before running code.); //; // And thus, even though you might think you are defining the; // global, and allocating the memory for the global in your object; // file, and thus should be able to set the alignment arbitrarily,; // that's not actually true. Doing so can cause an ABI breakage; an; // executable might have already been built with the previous; // alignment of the variable, and then assuming an increased; // alignment will be incorrect.; // Conservatively assume ELF if there's no parent pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Globals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp:97,Modifiability,variab,variable,97,"// On ELF platforms, we're further restricted in that we can't; // increase the alignment of any variable which might be emitted; // into a shared library, and which is exported. If the main; // executable accesses a variable found in a shared-lib, the main; // exe actually allocates memory for and exports the symbol ITSELF,; // overriding the symbol found in the library. That is, at link; // time, the observed alignment of the variable is copied into the; // executable binary. (A COPY relocation is also generated, to copy; // the initial data from the shadowed variable in the shared-lib; // into the location in the main binary, before running code.); //; // And thus, even though you might think you are defining the; // global, and allocating the memory for the global in your object; // file, and thus should be able to set the alignment arbitrarily,; // that's not actually true. Doing so can cause an ABI breakage; an; // executable might have already been built with the previous; // alignment of the variable, and then assuming an increased; // alignment will be incorrect.; // Conservatively assume ELF if there's no parent pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Globals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp:217,Modifiability,variab,variable,217,"// On ELF platforms, we're further restricted in that we can't; // increase the alignment of any variable which might be emitted; // into a shared library, and which is exported. If the main; // executable accesses a variable found in a shared-lib, the main; // exe actually allocates memory for and exports the symbol ITSELF,; // overriding the symbol found in the library. That is, at link; // time, the observed alignment of the variable is copied into the; // executable binary. (A COPY relocation is also generated, to copy; // the initial data from the shadowed variable in the shared-lib; // into the location in the main binary, before running code.); //; // And thus, even though you might think you are defining the; // global, and allocating the memory for the global in your object; // file, and thus should be able to set the alignment arbitrarily,; // that's not actually true. Doing so can cause an ABI breakage; an; // executable might have already been built with the previous; // alignment of the variable, and then assuming an increased; // alignment will be incorrect.; // Conservatively assume ELF if there's no parent pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Globals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp:432,Modifiability,variab,variable,432,"// On ELF platforms, we're further restricted in that we can't; // increase the alignment of any variable which might be emitted; // into a shared library, and which is exported. If the main; // executable accesses a variable found in a shared-lib, the main; // exe actually allocates memory for and exports the symbol ITSELF,; // overriding the symbol found in the library. That is, at link; // time, the observed alignment of the variable is copied into the; // executable binary. (A COPY relocation is also generated, to copy; // the initial data from the shadowed variable in the shared-lib; // into the location in the main binary, before running code.); //; // And thus, even though you might think you are defining the; // global, and allocating the memory for the global in your object; // file, and thus should be able to set the alignment arbitrarily,; // that's not actually true. Doing so can cause an ABI breakage; an; // executable might have already been built with the previous; // alignment of the variable, and then assuming an increased; // alignment will be incorrect.; // Conservatively assume ELF if there's no parent pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Globals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp:568,Modifiability,variab,variable,568,"// On ELF platforms, we're further restricted in that we can't; // increase the alignment of any variable which might be emitted; // into a shared library, and which is exported. If the main; // executable accesses a variable found in a shared-lib, the main; // exe actually allocates memory for and exports the symbol ITSELF,; // overriding the symbol found in the library. That is, at link; // time, the observed alignment of the variable is copied into the; // executable binary. (A COPY relocation is also generated, to copy; // the initial data from the shadowed variable in the shared-lib; // into the location in the main binary, before running code.); //; // And thus, even though you might think you are defining the; // global, and allocating the memory for the global in your object; // file, and thus should be able to set the alignment arbitrarily,; // that's not actually true. Doing so can cause an ABI breakage; an; // executable might have already been built with the previous; // alignment of the variable, and then assuming an increased; // alignment will be incorrect.; // Conservatively assume ELF if there's no parent pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Globals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp:1015,Modifiability,variab,variable,1015,"// On ELF platforms, we're further restricted in that we can't; // increase the alignment of any variable which might be emitted; // into a shared library, and which is exported. If the main; // executable accesses a variable found in a shared-lib, the main; // exe actually allocates memory for and exports the symbol ITSELF,; // overriding the symbol found in the library. That is, at link; // time, the observed alignment of the variable is copied into the; // executable binary. (A COPY relocation is also generated, to copy; // the initial data from the shadowed variable in the shared-lib; // into the location in the main binary, before running code.); //; // And thus, even though you might think you are defining the; // global, and allocating the memory for the global in your object; // file, and thus should be able to set the alignment arbitrarily,; // that's not actually true. Doing so can cause an ABI breakage; an; // executable might have already been built with the previous; // alignment of the variable, and then assuming an increased; // alignment will be incorrect.; // Conservatively assume ELF if there's no parent pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Globals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp:206,Security,access,accesses,206,"// On ELF platforms, we're further restricted in that we can't; // increase the alignment of any variable which might be emitted; // into a shared library, and which is exported. If the main; // executable accesses a variable found in a shared-lib, the main; // exe actually allocates memory for and exports the symbol ITSELF,; // overriding the symbol found in the library. That is, at link; // time, the observed alignment of the variable is copied into the; // executable binary. (A COPY relocation is also generated, to copy; // the initial data from the shadowed variable in the shared-lib; // into the location in the main binary, before running code.); //; // And thus, even though you might think you are defining the; // global, and allocating the memory for the global in your object; // file, and thus should be able to set the alignment arbitrarily,; // that's not actually true. Doing so can cause an ABI breakage; an; // executable might have already been built with the previous; // alignment of the variable, and then assuming an increased; // alignment will be incorrect.; // Conservatively assume ELF if there's no parent pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Globals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp:27,Modifiability,variab,variable,27,"// If it is a non constant variable, it needs to be uniqued across shared; // objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Globals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp:103,Usability,Clear,Clearing,103,"// Note, the num operands is used to compute the offset of the operand, so; // the order here matters. Clearing the operand then clearing the num; // operands ensures we have the correct offset to the operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Globals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp:129,Usability,clear,clearing,129,"// Note, the num operands is used to compute the offset of the operand, so; // the order here matters. Clearing the operand then clearing the num; // operands ensures we have the correct offset to the operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Globals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/GVMaterializer.cpp:422,Integrability,interface,interface,422,"//===-- GVMaterializer.cpp - Base implementation for GV materializers -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Minimal implementation of the abstract interface for materializing; // GlobalValues.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/GVMaterializer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/GVMaterializer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/InlineAsm.cpp:109,Modifiability,Enhance,Enhance,109,"// TODO: 1) Unify delimiter for inline asm, we also meet other delimiters; // for example ""\0A"", "";"".; // 2) Enhance StringRef. Some of the special delimiter (""\0"") can't be; // split in StringRef. Also empty StringRef can not call split (will stuck).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/InlineAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/InlineAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/InlineAsm.cpp:3,Availability,Error,Error,3,// Error parsing constraints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/InlineAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/InlineAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/InlineAsm.cpp:17,Security,access,access,17,"// We don't have access to labels here, NumLabels will be checked separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/InlineAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/InlineAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instruction.cpp:44,Usability,clear,clear,44,// Explicitly remove DIAssignID metadata to clear up ID -> Instruction(s); // mapping in LLVMContext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instruction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instruction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instruction.cpp:26,Availability,mainten,maintenence,26,// Perform any debug-info maintenence required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instruction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instruction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instruction.cpp:3,Performance,Perform,Perform,3,// Perform any debug-info maintenence required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instruction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instruction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instruction.cpp:23,Deployability,update,update,23,"// No need to manually update DPValues: if we insert after an instruction; // position, then we can never have any DPValues on ""this"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instruction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instruction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instruction.cpp:10,Availability,avail,available,10,"// Def is available in multiple successors, there's no single dominating; // insertion point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instruction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instruction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instruction.cpp:111,Safety,safe,safe,111,"// !annotation metadata does not impact semantics.; // !range, !nonnull and !align produce poison, so they are safe to speculate.; // !noundef and various AA metadata must be dropped, as it generally produces; // immediate undefined behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instruction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instruction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instruction.cpp:12,Integrability,wrap,wrapping,12,// Copy the wrapping flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instruction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instruction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instruction.cpp:3,Testability,Log,Logical,3,// Logical operators...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instruction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instruction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instruction.cpp:17,Testability,log,logic,17,// WARNING: this logic must be kept in sync with EliminateDuplicatePHINodes()!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instruction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instruction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:38,Availability,down,down,38,"// Move everything after this operand down.; //; // FIXME: we could just swap with the end of the list, then erase. However,; // clients might not expect this to happen. The code as it is thrashes the; // use/def lists, which is kinda lame.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:46,Performance,optimiz,optimized,46,/// Tests if this call site must be tail call optimized. Only a CallInst can; /// be tail call optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:95,Performance,optimiz,optimized,95,/// Tests if this call site must be tail call optimized. Only a CallInst can; /// be tail call optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:4,Testability,Test,Tests,4,/// Tests if this call site must be tail call optimized. Only a CallInst can; /// be tail call optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:4,Testability,Test,Tests,4,/// Tests if this call site is marked as a tail call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:43,Usability,simpl,simple,43,"/// When there isn't many bundles, we do a simple linear search.; /// Else fallback to a binary-search that use the fact that bundles usually; /// have similar number of argument to get faster convergence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:39,Security,access,access,39,/// Determine if the function does not access memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:39,Security,access,access,39,/// Determine if the function does not access or only reads memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:39,Security,access,access,39,/// Determine if the function does not access or only writes memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:30,Security,access,access,30,/// Determine if the call can access memmory only using pointers based; /// on its arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:39,Security,access,access,39,/// Determine if the function may only access memory that is; /// inaccessible from the IR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:39,Security,access,access,39,/// Determine if the function may only access memory that is; /// either inaccessible from the IR or pointed to by its arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:68,Safety,predict,prediction,68,// Set operands in order of their index to match use-list-order; // prediction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:3,Deployability,Update,Update,3,"// Update profile weight for call instruction by scaling it using the ratio; // of S/T. The meaning of ""branch_weights"" meta data for call instruction is; // transfered to represent call count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:68,Safety,predict,prediction,68,// Set operands in order of their index to match use-list-order; // prediction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:68,Safety,predict,prediction,68,// Set operands in order of their index to match use-list-order; // prediction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:85,Usability,Resume,ResumeInst,85,//===----------------------------------------------------------------------===//; // ResumeInst Implementation; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:59,Safety,predict,predictable,59,// Assign in order of operand index to make use-list order predictable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:59,Safety,predict,predictable,59,// Assign in order of operand index to make use-list order predictable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:59,Safety,predict,predictable,59,// Assign in order of operand index to make use-list order predictable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:3,Deployability,Update,Update,3,// Update profile metadata if present and it matches our structural; // expectations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:85,Performance,Load,LoadInst,85,//===----------------------------------------------------------------------===//; // LoadInst Implementation; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:17,Availability,mask,mask,17,// Make sure the mask elements make sense.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:3,Availability,Mask,Mask,3,"// Mask must be vector of i32, and must be the same kind of vector as the; // input vectors",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:19,Availability,Mask,Mask,19,// Check to see if Mask is valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:47,Availability,mask,mask,47,// Allow for degenerate case: completely undef mask means neither source is used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:98,Availability,mask,mask,98,"// We don't have vector operand size information, so assume operands are the; // same size as the mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:98,Availability,mask,mask,98,"// We don't have vector operand size information, so assume operands are the; // same size as the mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:33,Availability,mask,mask,33,// The number of elements in the mask must be at least 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:11,Availability,mask,masks,11,"// Example masks that will return true:; // v1 = <a, b, c, d>; // v2 = <e, f, g, h>; // trn1 = shufflevector v1, v2 <0, 4, 2, 6> = <a, e, c, g>; // trn2 = shufflevector v1, v2 <1, 5, 3, 7> = <b, f, d, h>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:36,Availability,mask,mask,36,// 1. The number of elements in the mask must be a power-of-2 and at least 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:51,Energy Efficiency,power,power-of-,51,// 1. The number of elements in the mask must be a power-of-2 and at least 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:31,Availability,mask,mask,31,// 2. The first element of the mask must be either a 0 or a 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:101,Availability,mask,mask,101,// 3. The difference between the first 2 elements must be equal to the; // number of elements in the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:105,Security,access,access,105,"// Don't support a StartIndex that begins in the second input, or if the; // first non-undef index would access below the StartIndex.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:19,Availability,mask,mask,19,// Determine which mask elements are attributed to which source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:54,Availability,mask,mask,54,// FIXME: Not currently possible to express a shuffle mask for a scalable; // vector for this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:65,Performance,scalab,scalable,65,// FIXME: Not currently possible to express a shuffle mask for a scalable; // vector for this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:25,Availability,mask,mask,25,// The first part of the mask must choose elements from exactly 1 source op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:7,Modifiability,extend,extending,7,// All extending must be with undef elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:54,Availability,mask,mask,54,// FIXME: Not currently possible to express a shuffle mask for a scalable; // vector for this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:65,Performance,scalab,scalable,65,// FIXME: Not currently possible to express a shuffle mask for a scalable; // vector for this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:54,Availability,mask,mask,54,// FIXME: Not currently possible to express a shuffle mask for a scalable; // vector for this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:65,Performance,scalab,scalable,65,// FIXME: Not currently possible to express a shuffle mask for a scalable; // vector for this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:11,Availability,mask,mask,11,"// Use the mask length rather than the operands' vector lengths here. We; // already know that the shuffle returns a vector twice as long as the inputs,; // and neither of the inputs are undef vectors. If the mask picks consecutive; // elements from both inputs, then this is a concatenation of the inputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:209,Availability,mask,mask,209,"// Use the mask length rather than the operands' vector lengths here. We; // already know that the shuffle returns a vector twice as long as the inputs,; // and neither of the inputs are undef vectors. If the mask picks consecutive; // elements from both inputs, then this is a concatenation of the inputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:19,Availability,mask,mask,19,"// However, if the mask contains undef's, we have to enumerate possible tuples; // and pick one. There are bounds on replication factor: [1, mask size]; // (where RF=1 is an identity shuffle, RF=mask size is a broadcast shuffle); // Additionally, mask size is a replication factor multiplied by vector size,; // which further significantly reduces the search space.; // Before doing that, let's perform basic correctness checking first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:141,Availability,mask,mask,141,"// However, if the mask contains undef's, we have to enumerate possible tuples; // and pick one. There are bounds on replication factor: [1, mask size]; // (where RF=1 is an identity shuffle, RF=mask size is a broadcast shuffle); // Additionally, mask size is a replication factor multiplied by vector size,; // which further significantly reduces the search space.; // Before doing that, let's perform basic correctness checking first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:195,Availability,mask,mask,195,"// However, if the mask contains undef's, we have to enumerate possible tuples; // and pick one. There are bounds on replication factor: [1, mask size]; // (where RF=1 is an identity shuffle, RF=mask size is a broadcast shuffle); // Additionally, mask size is a replication factor multiplied by vector size,; // which further significantly reduces the search space.; // Before doing that, let's perform basic correctness checking first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:247,Availability,mask,mask,247,"// However, if the mask contains undef's, we have to enumerate possible tuples; // and pick one. There are bounds on replication factor: [1, mask size]; // (where RF=1 is an identity shuffle, RF=mask size is a broadcast shuffle); // Additionally, mask size is a replication factor multiplied by vector size,; // which further significantly reduces the search space.; // Before doing that, let's perform basic correctness checking first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:340,Energy Efficiency,reduce,reduces,340,"// However, if the mask contains undef's, we have to enumerate possible tuples; // and pick one. There are bounds on replication factor: [1, mask size]; // (where RF=1 is an identity shuffle, RF=mask size is a broadcast shuffle); // Additionally, mask size is a replication factor multiplied by vector size,; // which further significantly reduces the search space.; // Before doing that, let's perform basic correctness checking first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:395,Performance,perform,perform,395,"// However, if the mask contains undef's, we have to enumerate possible tuples; // and pick one. There are bounds on replication factor: [1, mask size]; // (where RF=1 is an identity shuffle, RF=mask size is a broadcast shuffle); // Additionally, mask size is a replication factor multiplied by vector size,; // which further significantly reduces the search space.; // Before doing that, let's perform basic correctness checking first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:37,Availability,mask,mask,37,// Not possible to express a shuffle mask for a scalable vector for this; // case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:48,Performance,scalab,scalable,48,// Not possible to express a shuffle mask for a scalable vector for this; // case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:32,Availability,mask,mask,32,/// Return true if this shuffle mask is a replication mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:54,Availability,mask,mask,54,/// Return true if this shuffle mask is a replication mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:37,Availability,mask,mask,37,// Not possible to express a shuffle mask for a scalable vector for this; // case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:48,Performance,scalab,scalable,48,// Not possible to express a shuffle mask for a scalable vector for this; // case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:65,Performance,scalab,scalable,65,"// shuffle_vector can only interleave fixed length vectors - for scalable; // vectors, see the @llvm.experimental.vector.interleave2 intrinsic",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:36,Security,access,accesses,36,"// Inner loop processes consecutive accesses (x, x+1... in the example)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:37,Availability,Mask,Mask,37,// Lane computes x's position in the Mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:246,Availability,mask,masks,246,"// Undefs are allowed, but defined elements must still be consecutive:; // i.e.: x,..., undef,..., x + 2,..., undef,..., undef,..., x + 5, ....; // Verify this by storing the last non-undef followed by an undef; // Check that following non-undef masks are incremented with the; // corresponding distance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:153,Integrability,rout,routine,153,// There's no fundamental reason why we require at least one index; // (other than weirdness with &*IdxBegin being invalid; see; // getelementptr's init routine for example). But there's no; // present need to support it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:198,Integrability,depend,dependent,198,"// Exchange the two operands to this instruction. This instruction is safe to; // use on any binary instruction and does not modify the semantics of the; // instruction. If the instruction is order-dependent (SetLT f.e.), the opcode; // is changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:70,Safety,safe,safe,70,"// Exchange the two operands to this instruction. This instruction is safe to; // use on any binary instruction and does not modify the semantics of the; // instruction. If the instruction is order-dependent (SetLT f.e.), the opcode; // is changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:1066,Safety,safe,safe,1066,"// Define the 144 possibilities for these two cast instructions. The values; // in this matrix determine what to do in a given situation and select the; // case in the switch below. The rows correspond to firstOp, the columns; // correspond to secondOp. In looking at the table below, keep in mind; // the following cast properties:; //; // Size Compare Source Destination; // Operator Src ? Size Type Sign Type Sign; // -------- ------------ ------------------- ---------------------; // TRUNC > Integer Any Integral Any; // ZEXT < Integral Unsigned Integer Any; // SEXT < Integral Signed Integer Any; // FPTOUI n/a FloatPt n/a Integral Unsigned; // FPTOSI n/a FloatPt n/a Integral Signed; // UITOFP n/a Integral Unsigned FloatPt n/a; // SITOFP n/a Integral Signed FloatPt n/a; // FPTRUNC > FloatPt n/a FloatPt n/a; // FPEXT < FloatPt n/a FloatPt n/a; // PTRTOINT n/a Pointer n/a Integral Unsigned; // INTTOPTR n/a Integral Unsigned Pointer n/a; // BITCAST = FirstClass n/a FirstClass n/a; // ADDRSPCST n/a Pointer n/a Pointer n/a; //; // NOTE: some transforms are safe, but we consider them to be non-profitable.; // For example, we could merge ""fptoui double to i32"" + ""zext i32 to i64"",; // into ""fptoui double to i64"", but this loses information about the range; // of the produced value (we no longer know the top-part is all zeros).; // Further this conversion is often much more expensive for typical hardware,; // and causes issues when building libgcc. We disallow fptosi+sext for the; // same reason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:14,Testability,log,logic,14,"// TODO: This logic could be encoded into the table above and handled in the; // switch below.; // If either of the casts are a bitcast from scalar to vector, disallow the; // merging. However, any pair of bitcasts are allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:29,Performance,optimiz,optimization,29,// Disable inttoptr/ptrtoint optimization if enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:10,Usability,simpl,simplify,10,// Cannot simplify if address spaces are different!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:47,Modifiability,extend,extend,47,"// zext, sext -> zext, because sext can't sign extend after zext",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:63,Testability,assert,assert,63,"// FIXME: this state can be merged with (1), but the following assert; // is useful to check the correcteness of the sequence due to semantic; // change of bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:63,Testability,assert,assert,63,"// FIXME: this state can be merged with (1), but the following assert; // is useful to check the correcteness of the sequence due to semantic; // change of bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:63,Testability,assert,assert,63,"// FIXME: this state can be merged with (2), but the following assert; // is useful to check the correcteness of the sequence due to semantic; // change of bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:34,Availability,error,error,34,// Cast combination can't happen (error in input). This is for all cases; // where the MidTy is not the same for the two cast instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:153,Testability,log,logic,153,"// Provide a way to get a ""cast"" where the cast opcode is inferred from the; // types and size of the operand. This, basically, is a parallel of the; // logic in the castIsValid function below. This axiom should hold:; // castIsValid( getCastOpcode(Val, Ty), Val, Ty); // should not assert in castIsValid. In other words, this produces a ""correct""; // casting opcode for the arguments passed to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:283,Testability,assert,assert,283,"// Provide a way to get a ""cast"" where the cast opcode is inferred from the; // types and size of the operand. This, basically, is a parallel of the; // logic in the castIsValid function below. This axiom should hold:; // castIsValid( getCastOpcode(Val, Ty), Val, Ty); // should not assert in castIsValid. In other words, this produces a ""correct""; // casting opcode for the arguments passed to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:398,Availability,redundant,redundant,398,//===----------------------------------------------------------------------===//; // CastInst SubClass Constructors; //===----------------------------------------------------------------------===//; /// Check that the construction parameters for a CastInst are correct. This; /// could be broken out into the separate constructors but it is useful to have; /// it in one place and to eliminate the redundant code for getting the sizes; /// of the types involved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:398,Safety,redund,redundant,398,//===----------------------------------------------------------------------===//; // CastInst SubClass Constructors; //===----------------------------------------------------------------------===//; /// Check that the construction parameters for a CastInst are correct. This; /// could be broken out into the separate constructors but it is useful to have; /// it in one place and to eliminate the redundant code for getting the sizes; /// of the types involved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:20,Availability,error,error,20,// This is an input error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:208,Energy Efficiency,efficient,efficient,208,"/// SwitchInst ctor - Create a new switch instruction, specifying a value to; /// switch on and a default destination. The number of additional cases can; /// be specified here to make memory allocation more efficient. This; /// constructor can also autoinsert before another instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:208,Energy Efficiency,efficient,efficient,208,"/// SwitchInst ctor - Create a new switch instruction, specifying a value to; /// switch on and a default destination. The number of additional cases can; /// be specified here to make memory allocation more efficient. This; /// constructor also autoinserts at the end of the specified BasicBlock.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp:50,Integrability,Wrap,Wrappers,50,"//===-- IntrinsicInst.cpp - Intrinsic Instruction Wrappers ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements methods that make it really easy to deal with intrinsic; // functions.; //; // All intrinsic function calls are instances of the call instruction, so these; // are all subclasses of the CallInst class. Note that none of these classes; // has state or virtual methods, which is an important part of this gross/neat; // hack working.; //; // In some cases, arguments to intrinsics need to be generic and are defined as; // type pointer to empty struct { }*. To access the real item of interest the; // cast instruction needs to be stripped away.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp:862,Security,access,access,862,"//===-- IntrinsicInst.cpp - Intrinsic Instruction Wrappers ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements methods that make it really easy to deal with intrinsic; // functions.; //; // All intrinsic function calls are instances of the call instruction, so these; // are all subclasses of the CallInst class. Note that none of these classes; // has state or virtual methods, which is an important part of this gross/neat; // hack working.; //; // In some cases, arguments to intrinsics need to be generic and are defined as; // type pointer to empty struct { }*. To access the real item of interest the; // cast instruction needs to be stripped away.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp:174,Modifiability,variab,variables,174,//===----------------------------------------------------------------------===//; /// DbgVariableIntrinsic - This is the common base class for debug info; /// intrinsics for variables.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp:54,Performance,load,load,54,/// \return the alignment of the pointer used by this load/store/gather or; /// scatter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp:40,Performance,load,load,40,"/// \return The pointer operand of this load,store, gather or scatter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp:28,Availability,mask,masked-off,28,// No vlen param - no lanes masked-off by it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp:217,Safety,detect,detected,217,"// Note that the VP intrinsic causes undefined behavior if the Explicit Vector; // Length parameter is strictly greater-than the number of vector elements of; // the operation. This function returns true when this is detected statically; // in the IR.; // Check whether ""W == vscale * EC.getKnownMinValue()""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:524,Integrability,interface,interface,524,"//===- IRBuilder.cpp - Builder for LLVM Instrs ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the IRBuilder class, which is used as a convenient way; // to create LLVM instructions with a consistent and simplified interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:513,Usability,simpl,simplified,513,"//===- IRBuilder.cpp - Builder for LLVM Instrs ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the IRBuilder class, which is used as a convenient way; // to create LLVM instructions with a consistent and simplified interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:43,Modifiability,variab,variable,43,"/// CreateGlobalString - Make a new global variable with an initializer that; /// has array of i8 type filled in with the nul terminated string value; /// specified. If Name is specified, it is the name of the global variable; /// created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:217,Modifiability,variab,variable,217,"/// CreateGlobalString - Make a new global variable with an initializer that; /// has array of i8 type filled in with the nul terminated string value; /// specified. If Name is specified, it is the name of the global variable; /// created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:23,Availability,Mask,Masked,23,/// Create a call to a Masked Load intrinsic.; /// \p Ty - vector type to load; /// \p Ptr - base pointer for the load; /// \p Alignment - alignment of the source location; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:180,Availability,Mask,Mask,180,/// Create a call to a Masked Load intrinsic.; /// \p Ty - vector type to load; /// \p Ptr - base pointer for the load; /// \p Alignment - alignment of the source location; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:337,Availability,mask,masked-off,337,/// Create a call to a Masked Load intrinsic.; /// \p Ty - vector type to load; /// \p Ptr - base pointer for the load; /// \p Alignment - alignment of the source location; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:407,Modifiability,variab,variable,407,/// Create a call to a Masked Load intrinsic.; /// \p Ty - vector type to load; /// \p Ptr - base pointer for the load; /// \p Alignment - alignment of the source location; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:30,Performance,Load,Load,30,/// Create a call to a Masked Load intrinsic.; /// \p Ty - vector type to load; /// \p Ptr - base pointer for the load; /// \p Alignment - alignment of the source location; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:74,Performance,load,load,74,/// Create a call to a Masked Load intrinsic.; /// \p Ty - vector type to load; /// \p Ptr - base pointer for the load; /// \p Alignment - alignment of the source location; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:114,Performance,load,load,114,/// Create a call to a Masked Load intrinsic.; /// \p Ty - vector type to load; /// \p Ptr - base pointer for the load; /// \p Alignment - alignment of the source location; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:255,Security,access,accessed,255,/// Create a call to a Masked Load intrinsic.; /// \p Ty - vector type to load; /// \p Ptr - base pointer for the load; /// \p Alignment - alignment of the source location; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:23,Availability,Mask,Masked,23,"/// Create a call to a Masked Store intrinsic.; /// \p Val - data to be stored,; /// \p Ptr - base pointer for the store; /// \p Alignment - alignment of the destination location; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:187,Availability,Mask,Mask,187,"/// Create a call to a Masked Store intrinsic.; /// \p Val - data to be stored,; /// \p Ptr - base pointer for the store; /// \p Alignment - alignment of the destination location; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:262,Security,access,accessed,262,"/// Create a call to a Masked Store intrinsic.; /// \p Val - data to be stored,; /// \p Ptr - base pointer for the store; /// \p Alignment - alignment of the destination location; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:23,Availability,Mask,Masked,23,"/// Create a call to a Masked intrinsic, with given intrinsic Id,; /// an array of operands - Ops, and an array of overloaded types -; /// OverloadedTypes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:23,Availability,Mask,Masked,23,/// Create a call to a Masked Gather intrinsic.; /// \p Ty - vector type to gather; /// \p Ptrs - vector of pointers for loading; /// \p Align - alignment for one element; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:179,Availability,Mask,Mask,179,/// Create a call to a Masked Gather intrinsic.; /// \p Ty - vector type to gather; /// \p Ptrs - vector of pointers for loading; /// \p Align - alignment for one element; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:336,Availability,mask,masked-off,336,/// Create a call to a Masked Gather intrinsic.; /// \p Ty - vector type to gather; /// \p Ptrs - vector of pointers for loading; /// \p Align - alignment for one element; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:406,Modifiability,variab,variable,406,/// Create a call to a Masked Gather intrinsic.; /// \p Ty - vector type to gather; /// \p Ptrs - vector of pointers for loading; /// \p Align - alignment for one element; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:121,Performance,load,loading,121,/// Create a call to a Masked Gather intrinsic.; /// \p Ty - vector type to gather; /// \p Ptrs - vector of pointers for loading; /// \p Align - alignment for one element; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:254,Security,access,accessed,254,/// Create a call to a Masked Gather intrinsic.; /// \p Ty - vector type to gather; /// \p Ptrs - vector of pointers for loading; /// \p Align - alignment for one element; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:23,Availability,Mask,Masked,23,"/// Create a call to a Masked Scatter intrinsic.; /// \p Data - data to be stored,; /// \p Ptrs - the vector of pointers, where the \p Data elements should be; /// stored; /// \p Align - alignment for one element; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:221,Availability,Mask,Mask,221,"/// Create a call to a Masked Scatter intrinsic.; /// \p Data - data to be stored,; /// \p Ptrs - the vector of pointers, where the \p Data elements should be; /// stored; /// \p Align - alignment for one element; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:296,Security,access,accessed,296,"/// Create a call to a Masked Scatter intrinsic.; /// \p Data - data to be stored,; /// \p Ptrs - the vector of pointers, where the \p Data elements should be; /// stored; /// \p Align - alignment for one element; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:21,Availability,Mask,Masked,21,/// Create a call to Masked Expand Load intrinsic; /// \p Ty - vector type to load; /// \p Ptr - base pointer for the load; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:131,Availability,Mask,Mask,131,/// Create a call to Masked Expand Load intrinsic; /// \p Ty - vector type to load; /// \p Ptr - base pointer for the load; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:288,Availability,mask,masked-off,288,/// Create a call to Masked Expand Load intrinsic; /// \p Ty - vector type to load; /// \p Ptr - base pointer for the load; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:358,Modifiability,variab,variable,358,/// Create a call to Masked Expand Load intrinsic; /// \p Ty - vector type to load; /// \p Ptr - base pointer for the load; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:35,Performance,Load,Load,35,/// Create a call to Masked Expand Load intrinsic; /// \p Ty - vector type to load; /// \p Ptr - base pointer for the load; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:78,Performance,load,load,78,/// Create a call to Masked Expand Load intrinsic; /// \p Ty - vector type to load; /// \p Ptr - base pointer for the load; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:118,Performance,load,load,118,/// Create a call to Masked Expand Load intrinsic; /// \p Ty - vector type to load; /// \p Ptr - base pointer for the load; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:206,Security,access,accessed,206,/// Create a call to Masked Expand Load intrinsic; /// \p Ty - vector type to load; /// \p Ptr - base pointer for the load; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:21,Availability,Mask,Masked,21,"/// Create a call to Masked Compress Store intrinsic; /// \p Val - data to be stored,; /// \p Ptr - base pointer for the store; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:135,Availability,Mask,Mask,135,"/// Create a call to Masked Compress Store intrinsic; /// \p Val - data to be stored,; /// \p Ptr - base pointer for the store; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:210,Security,access,accessed,210,"/// Create a call to Masked Compress Store intrinsic; /// \p Val - data to be stored,; /// \p Ptr - base pointer for the store; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:209,Safety,avoid,avoid,209,"// If it's a pass manager, don't emit a remark. (This hinges on the assumption; // that the only passes that return non-null with getAsPMDataManager are pass; // managers.) The reason we have to do this is to avoid emitting remarks for; // CGSCC passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:22,Deployability,update,updates,22,// Helper lambda that updates the changes to the size of some function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:3,Deployability,Update,Update,3,// Update the total module count.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:24,Deployability,update,update,24,"// We need to initially update all of the function sizes.; // If no function was passed in, then we're either a module pass or an; // CGSCC pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:3,Deployability,Update,Update,3,// Update the function size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:36,Energy Efficiency,schedul,scheduled,36,"/// run - Execute all of the passes scheduled for execution. Keep track of; /// whether any of the passes modifies the module, and if so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:36,Energy Efficiency,schedul,scheduled,36,"/// run - Execute all of the passes scheduled for execution. Keep track of; /// whether any of the passes modifies the module, and if so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:169,Integrability,interface,interface,169,/// Add RequiredPass into list of lower level passes required by pass P.; /// RequiredPass is run on the fly by Pass Manager when P requests it; /// through getAnalysis interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:36,Energy Efficiency,schedul,scheduled,36,"/// run - Execute all of the passes scheduled for execution. Keep track of; /// whether any of the passes modifies the module, and if so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:157,Energy Efficiency,schedul,scheduled,157,"//===----------------------------------------------------------------------===//; // PassManagerImpl implementation; //; /// run - Execute all of the passes scheduled for execution. Keep track of; /// whether any of the passes modifies the module, and if so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:3,Deployability,Update,Update,3,// Update the last users of passes that are required transitive by AP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:166,Energy Efficiency,reduce,reduce,166,"// Look up the analysis usage from the pass instance (different instances; // of the same pass can produce different results), but unique the; // resulting object to reduce memory usage. This helps to greatly reduce; // memory usage when we have many instances of only a few pass types; // (e.g. instcombine, simplifycfg, etc...) which tend to share a fixed set; // of dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:209,Energy Efficiency,reduce,reduce,209,"// Look up the analysis usage from the pass instance (different instances; // of the same pass can produce different results), but unique the; // resulting object to reduce memory usage. This helps to greatly reduce; // memory usage when we have many instances of only a few pass types; // (e.g. instcombine, simplifycfg, etc...) which tend to share a fixed set; // of dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:369,Integrability,depend,dependencies,369,"// Look up the analysis usage from the pass instance (different instances; // of the same pass can produce different results), but unique the; // resulting object to reduce memory usage. This helps to greatly reduce; // memory usage when we have many instances of only a few pass types; // (e.g. instcombine, simplifycfg, etc...) which tend to share a fixed set; // of dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:309,Usability,simpl,simplifycfg,309,"// Look up the analysis usage from the pass instance (different instances; // of the same pass can produce different results), but unique the; // resulting object to reduce memory usage. This helps to greatly reduce; // memory usage when we have many instances of only a few pass types; // (e.g. instcombine, simplifycfg, etc...) which tend to share a fixed set; // of dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:101,Deployability,Update,Update,101,/// Schedule pass P for execution. Make sure that passes required by; /// P are run before P is run. Update analysis info maintained by; /// the manager. Remove dead passes. This is a recursive function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:4,Energy Efficiency,Schedul,Schedule,4,/// Schedule pass P for execution. Make sure that passes required by; /// P are run before P is run. Update analysis info maintained by; /// the manager. Remove dead passes. This is a recursive function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:10,Energy Efficiency,Allocate,Allocate,10,"// TODO : Allocate function manager for this pass, other wise required set; // may be inserted into previous function manager; // Give pass a chance to prepare the stage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:38,Availability,avail,available,38,// If P is an analysis pass and it is available then do not; // generate the analysis again. Stale analysis info should not be; // available at this point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:131,Availability,avail,available,131,// If P is an analysis pass and it is available then do not; // generate the analysis again. Stale analysis info should not be; // available at this point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:14,Performance,cache,cached,14,// Remove any cached AnalysisUsage information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:3,Energy Efficiency,Schedul,Schedule,3,// Schedule analysis pass that is managed by the same pass manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:3,Energy Efficiency,Schedul,Schedule,3,// Schedule analysis pass that is managed by a new manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:99,Availability,avail,available,99,// Recheck analysis passes to ensure that required analyses that; // are already checked are still available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:10,Energy Efficiency,schedul,schedule,10,// Do not schedule this analysis. Lower level analysis; // passes are run on the fly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:31,Availability,avail,available,31,// Now all required passes are available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:38,Availability,avail,available,38,// Add the requested pass to the best available pass manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:16,Integrability,interface,interfaces,16,// Also add any interfaces implemented by the immutable pass to the map for; // fast lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:113,Modifiability,inherit,inheritance,113,"// Every class that derives from PMDataManager also derives from Pass; // (sometimes indirectly), but there's no inheritance relationship; // between PMDataManager and Pass, so we have to getAsPass to get; // from a PMDataManager* to a Pass*.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:128,Availability,Avail,AvailableAnalysis,128,//===----------------------------------------------------------------------===//; // PMDataManager implementation; /// Augement AvailableAnalysis by adding analysis made available by pass P.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:170,Availability,avail,available,170,//===----------------------------------------------------------------------===//; // PMDataManager implementation; /// Augement AvailableAnalysis by adding analysis made available by pass P.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:57,Integrability,interface,interfaces,57,// This pass is the current implementation of all of the interfaces it; // implements as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:24,Testability,assert,assertions,24,// Don't do this unless assertions are enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:9,Modifiability,inherit,inherited,9,// Check inherited analysis also. If P is not preserving analysis; // provided by parent manager then remove it here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:86,Availability,avail,available,86,"// Remove all interfaces this pass implements, for which it is also; // listed as the available implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:14,Integrability,interface,interfaces,14,"// Remove all interfaces this pass implements, for which it is also; // listed as the available implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:48,Availability,Avail,AvailableAnalysis,48,/// Add pass P into the PassVector. Update; /// AvailableAnalysis appropriately if ProcessAnalysis is true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:36,Deployability,Update,Update,36,/// Add pass P into the PassVector. Update; /// AvailableAnalysis appropriately if ProcessAnalysis is true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:52,Availability,avail,available,52,"// Now, take care of required analyses that are not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:45,Availability,avail,available,45,// Take a note of analysis required and made available by this pass.; // Remove the analysis not preserved by this pass,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:84,Availability,avail,available,84,/// Populate UP with analysis pass that are used or required by; /// pass P and are available. Populate RP_NotAvail with analysis; /// pass that are required by pass P but are not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:180,Availability,avail,available,180,/// Populate UP with analysis pass that are used or required by; /// pass P and are available. Populate RP_NotAvail with analysis; /// pass that are required by pass P but are not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:35,Availability,avail,available,35,// All Required analyses should be available to the pass as it runs! Here; // we fill in the AnalysisImpls member of the pass so that it can; // successfully use the getAnalysis() method to retrieve the; // implementations it needs.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:111,Testability,assert,assert,111,// This may be analysis pass that is initialized on the fly.; // If that is not the case then it will raise an assert when it is used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:12,Availability,Avail,AvailableAnalysis,12,// Check if AvailableAnalysis map has one entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:169,Integrability,interface,interface,169,/// Add RequiredPass into list of lower level passes required by pass P.; /// RequiredPass is run on the fly by Pass Manager when P requests it; /// through getAnalysis interface.; /// This should be handled by specific pass manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:36,Energy Efficiency,schedul,scheduled,36,"/// run - Execute all of the passes scheduled for execution. Keep; /// track of whether any of the passes modifies the function, and if; /// so, return true.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:81,Performance,cache,cache,81,"// namespace llvm; /// cleanup - After running all passes, clean up pass manager cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:30,Energy Efficiency,schedul,scheduled,30,"/// Execute all of the passes scheduled for execution by invoking; /// runOnFunction method. Keep track of whether any of the passes modifies; /// the function, and if so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:11,Modifiability,inherit,inherited,11,// Collect inherited analysis from Module level pass manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:39,Availability,redundant,redundant,39,// Store name outside of loop to avoid redundant calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:33,Safety,avoid,avoid,33,// Store name outside of loop to avoid redundant calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:39,Safety,redund,redundant,39,// Store name outside of loop to avoid redundant calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:3,Deployability,Update,Update,3,"// Update the size of the function, emit a remark, and update the size; // of the module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:55,Deployability,update,update,55,"// Update the size of the function, emit a remark, and update the size; // of the module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:145,Energy Efficiency,schedul,scheduled,145,"//===----------------------------------------------------------------------===//; // MPPassManager implementation; /// Execute all of the passes scheduled for execution by invoking; /// runOnModule method. Keep track of whether any of the passes modifies; /// the module, and if so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:3,Deployability,Update,Update,3,// Update the size of the module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:84,Deployability,release,releaseMemory,84,"// We don't know when is the last time an on-the-fly pass is run,; // so we need to releaseMemory / finalize here",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:169,Integrability,interface,interface,169,/// Add RequiredPass into list of lower level passes required by pass P.; /// RequiredPass is run on the fly by Pass Manager when P requests it; /// through getAnalysis interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:101,Availability,avail,available,101,// This should be guaranteed to add RequiredPass to the passmanager given; // that we checked for an available analysis above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:36,Energy Efficiency,schedul,scheduled,36,"/// run - Execute all of the passes scheduled for execution. Keep track of; /// whether any of the passes modifies the module, and if so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:171,Usability,clear,clear,171,// namespace llvm; //===----------------------------------------------------------------------===//; // PMStack implementation; //; // Pop Pass Manager from the stack and clear its analysis info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContext.cpp:422,Integrability,wrap,wrapper,422,"//===-- LLVMContext.cpp - Implement LLVMContext ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements LLVMContext, as a wrapper around the opaque; // class LLVMContextImpl.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContext.cpp:85,Availability,Recover,Recoverable,85,//===----------------------------------------------------------------------===//; // Recoverable Backend Errors; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContext.cpp:105,Availability,Error,Errors,105,//===----------------------------------------------------------------------===//; // Recoverable Backend Errors; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContext.cpp:85,Safety,Recover,Recoverable,85,//===----------------------------------------------------------------------===//; // Recoverable Backend Errors; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContext.cpp:3,Performance,Optimiz,Optimization,3,"// Optimization remarks are selective. They need to check whether the regexp; // pattern, passed via one of the -pass-remarks* flags, matches the name of; // the pass that is emitting the diagnostic. If there is no match, ignore the; // diagnostic and return.; //; // Also noisy remarks are only enabled if we have hotness information to sort; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContext.cpp:24,Integrability,message,message,24,"// Otherwise, print the message with a prefix based on the severity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp:18,Modifiability,variab,variable,18,// Check that any variable location records that fell off the end of a block; // when it's terminator was removed were eventually replaced. This assertion; // firing indicates that DPValues went missing during the lifetime of the; // LLVMContext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp:145,Testability,assert,assertion,145,// Check that any variable location records that fell off the end of a block; // when it's terminator was removed were eventually replaced. This assertion; // firing indicates that DPValues went missing during the lifetime of the; // LLVMContext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp:172,Safety,Avoid,Avoid,172,"// NOTE: We need to delete the contents of OwnedModules, but Module's dtor; // will call LLVMContextImpl::removeModule, thus invalidating iterators into; // the container. Avoid iterators during this operation:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp:69,Safety,avoid,avoid,69,// Drop references for MDNodes. Do this before Values get deleted to avoid; // unnecessary RAUW when nodes are still unresolved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp:49,Integrability,bridg,bridges,49,// Also drop references that come from the Value bridges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp:96,Energy Efficiency,efficient,efficiently,96,"// Do not untrack ValueAsMetadata references for DIArgLists, as they have; // already been more efficiently untracked above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp:35,Security,hash,hashing,35,"/// Make MDOperand transparent for hashing.; ///; /// This overload of an implementation detail of the hashing library makes; /// MDOperand hash to the same value as a \a Metadata pointer.; ///; /// Note that overloading \a hash_value() as follows:; ///; /// \code; /// size_t hash_value(const MDOperand &X) { return hash_value(X.get()); }; /// \endcode; ///; /// does not cause MDOperand to be transparent. In particular, a bare pointer; /// doesn't get hashed before it's combined, whereas \a MDOperand would.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp:103,Security,hash,hashing,103,"/// Make MDOperand transparent for hashing.; ///; /// This overload of an implementation detail of the hashing library makes; /// MDOperand hash to the same value as a \a Metadata pointer.; ///; /// Note that overloading \a hash_value() as follows:; ///; /// \code; /// size_t hash_value(const MDOperand &X) { return hash_value(X.get()); }; /// \endcode; ///; /// does not cause MDOperand to be transparent. In particular, a bare pointer; /// doesn't get hashed before it's combined, whereas \a MDOperand would.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp:140,Security,hash,hash,140,"/// Make MDOperand transparent for hashing.; ///; /// This overload of an implementation detail of the hashing library makes; /// MDOperand hash to the same value as a \a Metadata pointer.; ///; /// Note that overloading \a hash_value() as follows:; ///; /// \code; /// size_t hash_value(const MDOperand &X) { return hash_value(X.get()); }; /// \endcode; ///; /// does not cause MDOperand to be transparent. In particular, a bare pointer; /// doesn't get hashed before it's combined, whereas \a MDOperand would.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp:455,Security,hash,hashed,455,"/// Make MDOperand transparent for hashing.; ///; /// This overload of an implementation detail of the hashing library makes; /// MDOperand hash to the same value as a \a Metadata pointer.; ///; /// Note that overloading \a hash_value() as follows:; ///; /// \code; /// size_t hash_value(const MDOperand &X) { return hash_value(X.get()); }; /// \endcode; ///; /// does not cause MDOperand to be transparent. In particular, a bare pointer; /// doesn't get hashed before it's combined, whereas \a MDOperand would.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:18,Security,hash,hashing,18,/// Structure for hashing arbitrary MDNode operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:4,Deployability,Configurat,Configuration,4,/// Configuration point for MDNodeInfo::isEqual().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:4,Modifiability,Config,Configuration,4,/// Configuration point for MDNodeInfo::isEqual().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:71,Performance,perform,performance,71,"// Intentionally computes the hash on a subset of the operands for; // performance reason. The subset has to be significant enough to avoid; // collision ""most of the time"". There is no correctness issue in case of; // collision because of the full check above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:134,Safety,avoid,avoid,134,"// Intentionally computes the hash on a subset of the operands for; // performance reason. The subset has to be significant enough to avoid; // collision ""most of the time"". There is no correctness issue in case of; // collision because of the full check above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:30,Security,hash,hash,30,"// Intentionally computes the hash on a subset of the operands for; // performance reason. The subset has to be significant enough to avoid; // collision ""most of the time"". There is no correctness issue in case of; // collision because of the full check above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:48,Security,hash,hash,48,"// If this is a member inside an ODR type, only hash the type and the name.; // Otherwise the hash will be stronger than; // MDNodeSubsetEqualImpl::isODRMember().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:94,Security,hash,hash,94,"// If this is a member inside an ODR type, only hash the type and the name.; // Otherwise the hash will be stronger than; // MDNodeSubsetEqualImpl::isODRMember().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:71,Performance,perform,performance,71,"// Intentionally computes the hash on a subset of the operands for; // performance reason. The subset has to be significant enough to avoid; // collision ""most of the time"". There is no correctness issue in case of; // collision because of the full check above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:134,Safety,avoid,avoid,134,"// Intentionally computes the hash on a subset of the operands for; // performance reason. The subset has to be significant enough to avoid; // collision ""most of the time"". There is no correctness issue in case of; // collision because of the full check above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:30,Security,hash,hash,30,"// Intentionally computes the hash on a subset of the operands for; // performance reason. The subset has to be significant enough to avoid; // collision ""most of the time"". There is no correctness issue in case of; // collision because of the full check above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:71,Performance,perform,performance,71,"// Intentionally computes the hash on a subset of the operands for; // performance reason. The subset has to be significant enough to avoid; // collision ""most of the time"". There is no correctness issue in case of; // collision because of the full check above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:134,Safety,avoid,avoid,134,"// Intentionally computes the hash on a subset of the operands for; // performance reason. The subset has to be significant enough to avoid; // collision ""most of the time"". There is no correctness issue in case of; // collision because of the full check above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:30,Security,hash,hash,30,"// Intentionally computes the hash on a subset of the operands for; // performance reason. The subset has to be significant enough to avoid; // collision ""most of the time"". There is no correctness issue in case of; // collision because of the full check above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:53,Security,hash,hash,53,"// If this is a declaration inside an ODR type, only hash the type and the; // name. Otherwise the hash will be stronger than; // MDNodeSubsetEqualImpl::isDeclarationOfODRMember().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:99,Security,hash,hash,99,"// If this is a declaration inside an ODR type, only hash the type and the; // name. Otherwise the hash will be stronger than; // MDNodeSubsetEqualImpl::isDeclarationOfODRMember().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:71,Performance,perform,performance,71,"// Intentionally computes the hash on a subset of the operands for; // performance reason. The subset has to be significant enough to avoid; // collision ""most of the time"". There is no correctness issue in case of; // collision because of the full check above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:134,Safety,avoid,avoid,134,"// Intentionally computes the hash on a subset of the operands for; // performance reason. The subset has to be significant enough to avoid; // collision ""most of the time"". There is no correctness issue in case of; // collision because of the full check above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:30,Security,hash,hash,30,"// Intentionally computes the hash on a subset of the operands for; // performance reason. The subset has to be significant enough to avoid; // collision ""most of the time"". There is no correctness issue in case of; // collision because of the full check above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:81,Safety,avoid,avoid,81,"// Compare to the RHS.; // FIXME: We need to compare template parameters here to avoid incorrect; // collisions in mapMetadata when RF_ReuseAndMutateDistinctMDs and a; // ODR-DISubprogram has a non-ODR template parameter (i.e., a; // DICompositeType that does not have an identifier). Eventually we should; // decouple ODR logic from uniquing logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:323,Testability,log,logic,323,"// Compare to the RHS.; // FIXME: We need to compare template parameters here to avoid incorrect; // collisions in mapMetadata when RF_ReuseAndMutateDistinctMDs and a; // ODR-DISubprogram has a non-ODR template parameter (i.e., a; // DICompositeType that does not have an identifier). Eventually we should; // decouple ODR logic from uniquing logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:343,Testability,log,logic,343,"// Compare to the RHS.; // FIXME: We need to compare template parameters here to avoid incorrect; // collisions in mapMetadata when RF_ReuseAndMutateDistinctMDs and a; // ODR-DISubprogram has a non-ODR template parameter (i.e., a; // DICompositeType that does not have an identifier). Eventually we should; // decouple ODR logic from uniquing logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:208,Availability,error,errors,208,"// We do not use AlignInBits in hashing function here on purpose:; // in most cases this param for local variable is zero (for function param; // it is always zero). This leads to lots of hash collisions and errors on; // cases with lots of similar variables.; // clang/test/CodeGen/debug-info-257-args.c is an example of this problem,; // generated IR is random for each run and test fails with Align included.; // TODO: make hashing work fine with such situations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:105,Modifiability,variab,variable,105,"// We do not use AlignInBits in hashing function here on purpose:; // in most cases this param for local variable is zero (for function param; // it is always zero). This leads to lots of hash collisions and errors on; // cases with lots of similar variables.; // clang/test/CodeGen/debug-info-257-args.c is an example of this problem,; // generated IR is random for each run and test fails with Align included.; // TODO: make hashing work fine with such situations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:249,Modifiability,variab,variables,249,"// We do not use AlignInBits in hashing function here on purpose:; // in most cases this param for local variable is zero (for function param; // it is always zero). This leads to lots of hash collisions and errors on; // cases with lots of similar variables.; // clang/test/CodeGen/debug-info-257-args.c is an example of this problem,; // generated IR is random for each run and test fails with Align included.; // TODO: make hashing work fine with such situations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:32,Security,hash,hashing,32,"// We do not use AlignInBits in hashing function here on purpose:; // in most cases this param for local variable is zero (for function param; // it is always zero). This leads to lots of hash collisions and errors on; // cases with lots of similar variables.; // clang/test/CodeGen/debug-info-257-args.c is an example of this problem,; // generated IR is random for each run and test fails with Align included.; // TODO: make hashing work fine with such situations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:188,Security,hash,hash,188,"// We do not use AlignInBits in hashing function here on purpose:; // in most cases this param for local variable is zero (for function param; // it is always zero). This leads to lots of hash collisions and errors on; // cases with lots of similar variables.; // clang/test/CodeGen/debug-info-257-args.c is an example of this problem,; // generated IR is random for each run and test fails with Align included.; // TODO: make hashing work fine with such situations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:427,Security,hash,hashing,427,"// We do not use AlignInBits in hashing function here on purpose:; // in most cases this param for local variable is zero (for function param; // it is always zero). This leads to lots of hash collisions and errors on; // cases with lots of similar variables.; // clang/test/CodeGen/debug-info-257-args.c is an example of this problem,; // generated IR is random for each run and test fails with Align included.; // TODO: make hashing work fine with such situations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:270,Testability,test,test,270,"// We do not use AlignInBits in hashing function here on purpose:; // in most cases this param for local variable is zero (for function param; // it is always zero). This leads to lots of hash collisions and errors on; // cases with lots of similar variables.; // clang/test/CodeGen/debug-info-257-args.c is an example of this problem,; // generated IR is random for each run and test fails with Align included.; // TODO: make hashing work fine with such situations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:380,Testability,test,test,380,"// We do not use AlignInBits in hashing function here on purpose:; // in most cases this param for local variable is zero (for function param; // it is always zero). This leads to lots of hash collisions and errors on; // cases with lots of similar variables.; // clang/test/CodeGen/debug-info-257-args.c is an example of this problem,; // generated IR is random for each run and test fails with Align included.; // TODO: make hashing work fine with such situations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:208,Availability,error,errors,208,"// We do not use AlignInBits in hashing function here on purpose:; // in most cases this param for local variable is zero (for function param; // it is always zero). This leads to lots of hash collisions and errors on; // cases with lots of similar variables.; // clang/test/CodeGen/debug-info-257-args.c is an example of this problem,; // generated IR is random for each run and test fails with Align included.; // TODO: make hashing work fine with such situations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:105,Modifiability,variab,variable,105,"// We do not use AlignInBits in hashing function here on purpose:; // in most cases this param for local variable is zero (for function param; // it is always zero). This leads to lots of hash collisions and errors on; // cases with lots of similar variables.; // clang/test/CodeGen/debug-info-257-args.c is an example of this problem,; // generated IR is random for each run and test fails with Align included.; // TODO: make hashing work fine with such situations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:249,Modifiability,variab,variables,249,"// We do not use AlignInBits in hashing function here on purpose:; // in most cases this param for local variable is zero (for function param; // it is always zero). This leads to lots of hash collisions and errors on; // cases with lots of similar variables.; // clang/test/CodeGen/debug-info-257-args.c is an example of this problem,; // generated IR is random for each run and test fails with Align included.; // TODO: make hashing work fine with such situations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:32,Security,hash,hashing,32,"// We do not use AlignInBits in hashing function here on purpose:; // in most cases this param for local variable is zero (for function param; // it is always zero). This leads to lots of hash collisions and errors on; // cases with lots of similar variables.; // clang/test/CodeGen/debug-info-257-args.c is an example of this problem,; // generated IR is random for each run and test fails with Align included.; // TODO: make hashing work fine with such situations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:188,Security,hash,hash,188,"// We do not use AlignInBits in hashing function here on purpose:; // in most cases this param for local variable is zero (for function param; // it is always zero). This leads to lots of hash collisions and errors on; // cases with lots of similar variables.; // clang/test/CodeGen/debug-info-257-args.c is an example of this problem,; // generated IR is random for each run and test fails with Align included.; // TODO: make hashing work fine with such situations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:427,Security,hash,hashing,427,"// We do not use AlignInBits in hashing function here on purpose:; // in most cases this param for local variable is zero (for function param; // it is always zero). This leads to lots of hash collisions and errors on; // cases with lots of similar variables.; // clang/test/CodeGen/debug-info-257-args.c is an example of this problem,; // generated IR is random for each run and test fails with Align included.; // TODO: make hashing work fine with such situations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:270,Testability,test,test,270,"// We do not use AlignInBits in hashing function here on purpose:; // in most cases this param for local variable is zero (for function param; // it is always zero). This leads to lots of hash collisions and errors on; // cases with lots of similar variables.; // clang/test/CodeGen/debug-info-257-args.c is an example of this problem,; // generated IR is random for each run and test fails with Align included.; // TODO: make hashing work fine with such situations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:380,Testability,test,test,380,"// We do not use AlignInBits in hashing function here on purpose:; // in most cases this param for local variable is zero (for function param; // it is always zero). This leads to lots of hash collisions and errors on; // cases with lots of similar variables.; // clang/test/CodeGen/debug-info-257-args.c is an example of this problem,; // generated IR is random for each run and test fails with Align included.; // TODO: make hashing work fine with such situations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:31,Security,hash,hash,31,/// Using name and line to get hash value. It should already be mostly unique.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:93,Security,hash,hash,93,"// DIArgLists are not MDNodes, but we still want to unique them in a DenseSet; // based on a hash of their arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:176,Usability,clear,clear,176,"/// Appends all attachments for the global to \c Result, sorting by attachment; /// ID. Attachments with the same ID appear in insertion order. This function; /// does \em not clear \c Result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:433,Availability,avail,available,433,"/// The minimum hotness value a diagnostic needs in order to be included in; /// optimization diagnostics.; ///; /// The threshold is an Optional value, which maps to one of the 3 states:; /// 1). 0 => threshold disabled. All emarks will be printed.; /// 2). positive int => manual threshold by user. Remarks with hotness exceed; /// threshold will be printed.; /// 3). None => 'auto' threshold by user. The actual value is not; /// available at command line, but will be synced with; /// hotness threhold from profile summary during; /// compilation.; ///; /// State 1 and 2 are considered as terminal states. State transition is; /// only allowed from 3 to 2, when the threshold is first synced with profile; /// summary. This ensures that the threshold is set only once and stays; /// constant.; ///; /// If threshold option is not specified, it is disabled (0) by default.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:81,Performance,optimiz,optimization,81,"/// The minimum hotness value a diagnostic needs in order to be included in; /// optimization diagnostics.; ///; /// The threshold is an Optional value, which maps to one of the 3 states:; /// 1). 0 => threshold disabled. All emarks will be printed.; /// 2). positive int => manual threshold by user. Remarks with hotness exceed; /// threshold will be printed.; /// 3). None => 'auto' threshold by user. The actual value is not; /// available at command line, but will be synced with; /// hotness threhold from profile summary during; /// compilation.; ///; /// State 1 and 2 are considered as terminal states. State transition is; /// only allowed from 3 to 2, when the threshold is first synced with profile; /// summary. This ensures that the threshold is set only once and stays; /// constant.; ///; /// If threshold option is not specified, it is disabled (0) by default.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:105,Availability,toler,tolerate,105,/// The percentage of difference between profiling branch weights and; /// llvm.expect branch weights to tolerate when emiting MisExpect diagnostics,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:51,Performance,Optimiz,OptimizationRemarkEmitter,51,/// The specialized remark streamer used by LLVM's OptimizationRemarkEmitter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:102,Deployability,update,updateDIAssignIDMapping,102,/// Map DIAssignID -> Instructions with that attachment.; /// Managed by Instruction via Instruction::updateDIAssignIDMapping.; /// Query using the at:: functions defined in DebugInfo.h.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:22,Integrability,synchroniz,synchronization,22,/// A set of interned synchronization scopes. The StringMap maps; /// synchronization scope names to their respective synchronization scope IDs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:70,Integrability,synchroniz,synchronization,70,/// A set of interned synchronization scopes. The StringMap maps; /// synchronization scope names to their respective synchronization scope IDs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:118,Integrability,synchroniz,synchronization,118,/// A set of interned synchronization scopes. The StringMap maps; /// synchronization scope names to their respective synchronization scope IDs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:34,Integrability,synchroniz,synchronization,34,/// getOrInsertSyncScopeID - Maps synchronization scope name to; /// synchronization scope ID. Every synchronization scope registered with; /// LLVMContext has unique ID except pre-defined ones.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:69,Integrability,synchroniz,synchronization,69,/// getOrInsertSyncScopeID - Maps synchronization scope name to; /// synchronization scope ID. Every synchronization scope registered with; /// LLVMContext has unique ID except pre-defined ones.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:101,Integrability,synchroniz,synchronization,101,/// getOrInsertSyncScopeID - Maps synchronization scope name to; /// synchronization scope ID. Every synchronization scope registered with; /// LLVMContext has unique ID except pre-defined ones.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:72,Integrability,synchroniz,synchronization,72,/// getSyncScopeNames - Populates client supplied SmallVector with; /// synchronization scope names registered with LLVMContext. Synchronization; /// scope names are ordered by increasing synchronization scope IDs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:129,Integrability,Synchroniz,Synchronization,129,/// getSyncScopeNames - Populates client supplied SmallVector with; /// synchronization scope names registered with LLVMContext. Synchronization; /// scope names are ordered by increasing synchronization scope IDs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:188,Integrability,synchroniz,synchronization,188,/// getSyncScopeNames - Populates client supplied SmallVector with; /// synchronization scope names registered with LLVMContext. Synchronization; /// scope names are ordered by increasing synchronization scope IDs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:76,Performance,optimiz,optimizations,76,/// Access the object which can disable optional passes and individual; /// optimizations at compile time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:4,Security,Access,Access,4,/// Access the object which can disable optional passes and individual; /// optimizations at compile time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:163,Modifiability,extend,extend,163,/// Set the object which can disable optional passes and individual; /// optimizations at compile time.; ///; /// The lifetime of the object must be guaranteed to extend as long as the; /// LLVMContext is used by compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:73,Performance,optimiz,optimizations,73,/// Set the object which can disable optional passes and individual; /// optimizations at compile time.; ///; /// The lifetime of the object must be guaranteed to extend as long as the; /// LLVMContext is used by compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:113,Modifiability,variab,variable,113,"/// Mapping of blocks to collections of ""trailing"" DPValues. As part of the; /// ""RemoveDIs"" project, debug-info variable location records are going to; /// cease being instructions... which raises the problem of where should they; /// be recorded when we remove the terminator of a blocks, such as:; ///; /// %foo = add i32 0, 0; /// br label %bar; ///; /// If the branch is removed, a legitimate transient state while editing a; /// block, any debug-records between those two instructions will not have a; /// location. Each block thus records any DPValue records that ""trail"" in; /// such a way. These are stored in LLVMContext because typically LLVM only; /// edits a small number of blocks at a time, so there's no need to bloat; /// BasicBlock with such a data structure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMRemarkStreamer.cpp:17,Performance,optimiz,optimization,17,// Create LLVM's optimization remarks streamer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMRemarkStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMRemarkStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMRemarkStreamer.cpp:17,Performance,optimiz,optimization,17,// Create LLVM's optimization remarks streamer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/LLVMRemarkStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMRemarkStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Mangler.cpp:16,Usability,simpl,simple,16,"// If this is a simple string that doesn't need escaping, just append it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Mangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Mangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Mangler.cpp:40,Safety,safe,safe,40,// Check if the name needs quotes to be safe for the linker to interpret.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Mangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Mangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/MDBuilder.cpp:517,Integrability,interface,interface,517,"//===---- llvm/MDBuilder.cpp - Builder for LLVM metadata ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the MDBuilder class, which is used as a convenient way to; // create LLVM metadata with a consistent and simplified interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/MDBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/MDBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/MDBuilder.cpp:506,Usability,simpl,simplified,506,"//===---- llvm/MDBuilder.cpp - Builder for LLVM metadata ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the MDBuilder class, which is used as a convenient way to; // create LLVM metadata with a consistent and simplified interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/MDBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/MDBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/MDBuilder.cpp:71,Security,access,access,71,"/// Return metadata for a TBAA tag node with the given; /// base type, access type and offset relative to the base type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/MDBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/MDBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp:80,Deployability,upgrade,upgrades,80,"/// Canonicalize metadata arguments to intrinsics.; ///; /// To support bitcode upgrades (and assembly semantic sugar) for \a; /// MetadataAsValue, we need to canonicalize certain metadata.; ///; /// - nullptr is replaced by an empty MDNode.; /// - An MDNode with a single null operand is replaced by an empty MDNode.; /// - An MDNode whose only operand is a \a ConstantAsMetadata gets skipped.; ///; /// This maintains readability of bitcode from when metadata was a type of; /// value, and these bridges were unnecessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp:498,Integrability,bridg,bridges,498,"/// Canonicalize metadata arguments to intrinsics.; ///; /// To support bitcode upgrades (and assembly semantic sugar) for \a; /// MetadataAsValue, we need to canonicalize certain metadata.; ///; /// - nullptr is replaced by an empty MDNode.; /// - An MDNode with a single null operand is replaced by an empty MDNode.; /// - An MDNode whose only operand is a \a ConstantAsMetadata gets skipped.; ///; /// This maintains readability of bitcode from when metadata was a type of; /// value, and these bridges were unnecessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp:246,Integrability,depend,depends,246,"// Order DPValue users in reverse-creation order. Normal dbg.value users; // of MetadataAsValues are ordered by their UseList, i.e. reverse order of; // when they were added: we need to replicate that here. The structure of; // debug-info output depends on the ordering of intrinsics, thus we need; // to keep them consistent for comparisons sake.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp:21,Deployability,update,update,21,// Copy out uses and update value of Constant used by debug info metadata with undef below,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp:3,Deployability,Update,Update,3,// Update unowned tracking references directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp:181,Safety,avoid,avoid,181,"// Special handing of DIArgList is required in the RemoveDIs project, see; // commentry in DIArgList::handleChangedOperand for details. Hidden behind; // conditional compilation to avoid a compile time regression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp:3,Deployability,Update,Update,3,// Update MD in place (and update the map entry).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp:27,Deployability,update,update,27,// Update MD in place (and update the map entry).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp:116,Testability,Assert,Assert,116,//===----------------------------------------------------------------------===//; // MDNode implementation.; //; // Assert that the MDNode types will not be unaligned by the objects; // prepended to them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp:45,Usability,clear,clear,45,"// Still unresolved, so RAUW.; //; // First, clear out all operands to prevent any recursion (similar to; // dropAllReferences(), but we still need the use-list).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp:13,Security,hash,hash,13,// Reset the hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp:142,Usability,clear,clearer,142,"// Pass in both instructions and nodes. Instruction information (e.g.,; // instruction type) helps interpret profiles and make implementation clearer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp:64,Security,hash,hash,64,// Handle 'dbg' as a special case since it is not stored in the hash table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp:3,Deployability,Update,Update,3,// Update DIAssignID to Instruction(s) mapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp:177,Testability,assert,assert,177,"// The DIAssignID tracking infrastructure doesn't support RAUWing temporary; // nodes with DIAssignIDs. The cast_or_null below would also catch this, but; // having a dedicated assert helps make this obvious.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp:64,Security,hash,hash,64,// Handle 'dbg' as a special case since it is not stored in the hash table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp:372,Integrability,interface,interface,372,"// This RNG is guaranteed to produce the same random stream only; // when the Module ID and thus the input filename is the same. This; // might be problematic if the input filename extension changes; // (e.g. from .c to .bc or .ll).; //; // We could store this salt in NamedMetadata, but this would make; // the parameter non-const. This would unfortunately make this; // interface unusable by any Machine passes, since they only have a; // const reference to their IR Module. Alternatively we can always; // store salt metadata from the Module constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Module.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp:102,Security,access,access,102,"//===----------------------------------------------------------------------===//; // Methods for easy access to the functions in the module.; //; // getOrInsertFunction - Look up the specified function in the module symbol; // table. If it does not exist, add a prototype for the function and return; // it. This is nice because it allows most passes to get away with not handling; // the symbol table directly for this common task.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Module.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp:123,Modifiability,variab,variables,123,"//===----------------------------------------------------------------------===//; // Methods for easy access to the global variables in the module.; //; /// getGlobalVariable - Look up the specified global variable in the module; /// symbol table. If it does not exist, return null. The type argument; /// should be the underlying type of the global, i.e., it should not have; /// the top-level PointerType, which represents the address of the global.; /// If AllowLocal is set to true, this function will return types that; /// have an local. By default, these types are not returned.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Module.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp:206,Modifiability,variab,variable,206,"//===----------------------------------------------------------------------===//; // Methods for easy access to the global variables in the module.; //; /// getGlobalVariable - Look up the specified global variable in the module; /// symbol table. If it does not exist, return null. The type argument; /// should be the underlying type of the global, i.e., it should not have; /// the top-level PointerType, which represents the address of the global.; /// If AllowLocal is set to true, this function will return types that; /// have an local. By default, these types are not returned.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Module.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp:102,Security,access,access,102,"//===----------------------------------------------------------------------===//; // Methods for easy access to the global variables in the module.; //; /// getGlobalVariable - Look up the specified global variable in the module; /// symbol table. If it does not exist, return null. The type argument; /// should be the underlying type of the global, i.e., it should not have; /// the top-level PointerType, which represents the address of the global.; /// If AllowLocal is set to true, this function will return types that; /// have an local. By default, these types are not returned.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Module.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp:34,Modifiability,variab,variable,34,// Overload to construct a global variable using its constructor's defaults.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Module.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp:123,Modifiability,variab,variables,123,"//===----------------------------------------------------------------------===//; // Methods for easy access to the global variables in the module.; //; // getNamedAlias - Look up the specified global in the module symbol table.; // If it does not exist, return null.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Module.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp:102,Security,access,access,102,"//===----------------------------------------------------------------------===//; // Methods for easy access to the global variables in the module.; //; // getNamedAlias - Look up the specified global in the module symbol table.; // If it does not exist, return null.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Module.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp:110,Availability,failure,failures,110,// Check the operands of the MDNode before accessing the operands.; // The verifier will actually catch these failures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Module.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp:43,Security,access,accessing,43,// Check the operands of the MDNode before accessing the operands.; // The verifier will actually catch these failures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Module.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp:86,Performance,cache,cache,86,"// This might be slow if a whole population of intrinsics already existed, but; // we cache the values for later usage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Module.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp:90,Deployability,Update,Update,90,// It was a declaration for our prototype. This entry was allocated in the; // beginning. Update the count to match the existing declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Module.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp:58,Energy Efficiency,allocate,allocated,58,// It was a declaration for our prototype. This entry was allocated in the; // beginning. Update the count to match the existing declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Module.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp:69,Availability,reliab,reliably,69,"// The merge result of a non-PIC object and a PIC object can only be reliably; // used as a non-PIC object, so use the Min merge behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Module.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp:277,Availability,error,error,277,// Linking object files with different code models is undefined behavior; // because the compiler would have to generate additional code (to span; // longer jumps) if a larger code model is used with a smaller one.; // Therefore we will treat attempts to mix code models as an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Module.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:93,Security,validat,validate,93,// 1 bit: DisableSplitLTOUnit flag.; // Set on per module indexes. It is up to the client to validate; // the consistency of this flag across modules being linked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:69,Usability,GUID,GUID,69,// Collect for the given module the list of function it defines; // (GUID -> Summary).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:17,Modifiability,variab,variable,17,"// Ignore global variable, focus on functions",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:167,Modifiability,variab,variables,167,"// Do the access attribute and DSOLocal propagation in combined index.; // The goal of attribute propagation is internalization of readonly (RO); // or writeonly (WO) variables. To determine which variables are RO or WO; // and which are not we take following steps:; // - During analysis we speculatively assign readonly and writeonly; // attribute to all variables which can be internalized. When computing; // function summary we also assign readonly or writeonly attribute to a; // reference if function doesn't modify referenced variable (readonly); // or doesn't read it (writeonly).; //; // - After computing dead symbols in combined index we do the attribute; // and DSOLocal propagation. During this step we:; // a. clear RO and WO attributes from variables which are preserved or; // can't be imported; // b. clear RO and WO attributes from variables referenced by any global; // variable initializer; // c. clear RO attribute from variable referenced by a function when; // reference is not readonly; // d. clear WO attribute from variable referenced by a function when; // reference is not writeonly; // e. clear IsDSOLocal flag in every summary if any of them is false.; //; // Because of (c, d) we don't internalize variables read by function A; // and modified by function B.; //; // Internalization itself happens in the backend after import is finished; // See internalizeGVsAfterImport.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:197,Modifiability,variab,variables,197,"// Do the access attribute and DSOLocal propagation in combined index.; // The goal of attribute propagation is internalization of readonly (RO); // or writeonly (WO) variables. To determine which variables are RO or WO; // and which are not we take following steps:; // - During analysis we speculatively assign readonly and writeonly; // attribute to all variables which can be internalized. When computing; // function summary we also assign readonly or writeonly attribute to a; // reference if function doesn't modify referenced variable (readonly); // or doesn't read it (writeonly).; //; // - After computing dead symbols in combined index we do the attribute; // and DSOLocal propagation. During this step we:; // a. clear RO and WO attributes from variables which are preserved or; // can't be imported; // b. clear RO and WO attributes from variables referenced by any global; // variable initializer; // c. clear RO attribute from variable referenced by a function when; // reference is not readonly; // d. clear WO attribute from variable referenced by a function when; // reference is not writeonly; // e. clear IsDSOLocal flag in every summary if any of them is false.; //; // Because of (c, d) we don't internalize variables read by function A; // and modified by function B.; //; // Internalization itself happens in the backend after import is finished; // See internalizeGVsAfterImport.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:357,Modifiability,variab,variables,357,"// Do the access attribute and DSOLocal propagation in combined index.; // The goal of attribute propagation is internalization of readonly (RO); // or writeonly (WO) variables. To determine which variables are RO or WO; // and which are not we take following steps:; // - During analysis we speculatively assign readonly and writeonly; // attribute to all variables which can be internalized. When computing; // function summary we also assign readonly or writeonly attribute to a; // reference if function doesn't modify referenced variable (readonly); // or doesn't read it (writeonly).; //; // - After computing dead symbols in combined index we do the attribute; // and DSOLocal propagation. During this step we:; // a. clear RO and WO attributes from variables which are preserved or; // can't be imported; // b. clear RO and WO attributes from variables referenced by any global; // variable initializer; // c. clear RO attribute from variable referenced by a function when; // reference is not readonly; // d. clear WO attribute from variable referenced by a function when; // reference is not writeonly; // e. clear IsDSOLocal flag in every summary if any of them is false.; //; // Because of (c, d) we don't internalize variables read by function A; // and modified by function B.; //; // Internalization itself happens in the backend after import is finished; // See internalizeGVsAfterImport.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:534,Modifiability,variab,variable,534,"// Do the access attribute and DSOLocal propagation in combined index.; // The goal of attribute propagation is internalization of readonly (RO); // or writeonly (WO) variables. To determine which variables are RO or WO; // and which are not we take following steps:; // - During analysis we speculatively assign readonly and writeonly; // attribute to all variables which can be internalized. When computing; // function summary we also assign readonly or writeonly attribute to a; // reference if function doesn't modify referenced variable (readonly); // or doesn't read it (writeonly).; //; // - After computing dead symbols in combined index we do the attribute; // and DSOLocal propagation. During this step we:; // a. clear RO and WO attributes from variables which are preserved or; // can't be imported; // b. clear RO and WO attributes from variables referenced by any global; // variable initializer; // c. clear RO attribute from variable referenced by a function when; // reference is not readonly; // d. clear WO attribute from variable referenced by a function when; // reference is not writeonly; // e. clear IsDSOLocal flag in every summary if any of them is false.; //; // Because of (c, d) we don't internalize variables read by function A; // and modified by function B.; //; // Internalization itself happens in the backend after import is finished; // See internalizeGVsAfterImport.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:757,Modifiability,variab,variables,757,"// Do the access attribute and DSOLocal propagation in combined index.; // The goal of attribute propagation is internalization of readonly (RO); // or writeonly (WO) variables. To determine which variables are RO or WO; // and which are not we take following steps:; // - During analysis we speculatively assign readonly and writeonly; // attribute to all variables which can be internalized. When computing; // function summary we also assign readonly or writeonly attribute to a; // reference if function doesn't modify referenced variable (readonly); // or doesn't read it (writeonly).; //; // - After computing dead symbols in combined index we do the attribute; // and DSOLocal propagation. During this step we:; // a. clear RO and WO attributes from variables which are preserved or; // can't be imported; // b. clear RO and WO attributes from variables referenced by any global; // variable initializer; // c. clear RO attribute from variable referenced by a function when; // reference is not readonly; // d. clear WO attribute from variable referenced by a function when; // reference is not writeonly; // e. clear IsDSOLocal flag in every summary if any of them is false.; //; // Because of (c, d) we don't internalize variables read by function A; // and modified by function B.; //; // Internalization itself happens in the backend after import is finished; // See internalizeGVsAfterImport.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:851,Modifiability,variab,variables,851,"// Do the access attribute and DSOLocal propagation in combined index.; // The goal of attribute propagation is internalization of readonly (RO); // or writeonly (WO) variables. To determine which variables are RO or WO; // and which are not we take following steps:; // - During analysis we speculatively assign readonly and writeonly; // attribute to all variables which can be internalized. When computing; // function summary we also assign readonly or writeonly attribute to a; // reference if function doesn't modify referenced variable (readonly); // or doesn't read it (writeonly).; //; // - After computing dead symbols in combined index we do the attribute; // and DSOLocal propagation. During this step we:; // a. clear RO and WO attributes from variables which are preserved or; // can't be imported; // b. clear RO and WO attributes from variables referenced by any global; // variable initializer; // c. clear RO attribute from variable referenced by a function when; // reference is not readonly; // d. clear WO attribute from variable referenced by a function when; // reference is not writeonly; // e. clear IsDSOLocal flag in every summary if any of them is false.; //; // Because of (c, d) we don't internalize variables read by function A; // and modified by function B.; //; // Internalization itself happens in the backend after import is finished; // See internalizeGVsAfterImport.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:890,Modifiability,variab,variable,890,"// Do the access attribute and DSOLocal propagation in combined index.; // The goal of attribute propagation is internalization of readonly (RO); // or writeonly (WO) variables. To determine which variables are RO or WO; // and which are not we take following steps:; // - During analysis we speculatively assign readonly and writeonly; // attribute to all variables which can be internalized. When computing; // function summary we also assign readonly or writeonly attribute to a; // reference if function doesn't modify referenced variable (readonly); // or doesn't read it (writeonly).; //; // - After computing dead symbols in combined index we do the attribute; // and DSOLocal propagation. During this step we:; // a. clear RO and WO attributes from variables which are preserved or; // can't be imported; // b. clear RO and WO attributes from variables referenced by any global; // variable initializer; // c. clear RO attribute from variable referenced by a function when; // reference is not readonly; // d. clear WO attribute from variable referenced by a function when; // reference is not writeonly; // e. clear IsDSOLocal flag in every summary if any of them is false.; //; // Because of (c, d) we don't internalize variables read by function A; // and modified by function B.; //; // Internalization itself happens in the backend after import is finished; // See internalizeGVsAfterImport.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:942,Modifiability,variab,variable,942,"// Do the access attribute and DSOLocal propagation in combined index.; // The goal of attribute propagation is internalization of readonly (RO); // or writeonly (WO) variables. To determine which variables are RO or WO; // and which are not we take following steps:; // - During analysis we speculatively assign readonly and writeonly; // attribute to all variables which can be internalized. When computing; // function summary we also assign readonly or writeonly attribute to a; // reference if function doesn't modify referenced variable (readonly); // or doesn't read it (writeonly).; //; // - After computing dead symbols in combined index we do the attribute; // and DSOLocal propagation. During this step we:; // a. clear RO and WO attributes from variables which are preserved or; // can't be imported; // b. clear RO and WO attributes from variables referenced by any global; // variable initializer; // c. clear RO attribute from variable referenced by a function when; // reference is not readonly; // d. clear WO attribute from variable referenced by a function when; // reference is not writeonly; // e. clear IsDSOLocal flag in every summary if any of them is false.; //; // Because of (c, d) we don't internalize variables read by function A; // and modified by function B.; //; // Internalization itself happens in the backend after import is finished; // See internalizeGVsAfterImport.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:1042,Modifiability,variab,variable,1042,"// Do the access attribute and DSOLocal propagation in combined index.; // The goal of attribute propagation is internalization of readonly (RO); // or writeonly (WO) variables. To determine which variables are RO or WO; // and which are not we take following steps:; // - During analysis we speculatively assign readonly and writeonly; // attribute to all variables which can be internalized. When computing; // function summary we also assign readonly or writeonly attribute to a; // reference if function doesn't modify referenced variable (readonly); // or doesn't read it (writeonly).; //; // - After computing dead symbols in combined index we do the attribute; // and DSOLocal propagation. During this step we:; // a. clear RO and WO attributes from variables which are preserved or; // can't be imported; // b. clear RO and WO attributes from variables referenced by any global; // variable initializer; // c. clear RO attribute from variable referenced by a function when; // reference is not readonly; // d. clear WO attribute from variable referenced by a function when; // reference is not writeonly; // e. clear IsDSOLocal flag in every summary if any of them is false.; //; // Because of (c, d) we don't internalize variables read by function A; // and modified by function B.; //; // Internalization itself happens in the backend after import is finished; // See internalizeGVsAfterImport.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:1230,Modifiability,variab,variables,1230,"// Do the access attribute and DSOLocal propagation in combined index.; // The goal of attribute propagation is internalization of readonly (RO); // or writeonly (WO) variables. To determine which variables are RO or WO; // and which are not we take following steps:; // - During analysis we speculatively assign readonly and writeonly; // attribute to all variables which can be internalized. When computing; // function summary we also assign readonly or writeonly attribute to a; // reference if function doesn't modify referenced variable (readonly); // or doesn't read it (writeonly).; //; // - After computing dead symbols in combined index we do the attribute; // and DSOLocal propagation. During this step we:; // a. clear RO and WO attributes from variables which are preserved or; // can't be imported; // b. clear RO and WO attributes from variables referenced by any global; // variable initializer; // c. clear RO attribute from variable referenced by a function when; // reference is not readonly; // d. clear WO attribute from variable referenced by a function when; // reference is not writeonly; // e. clear IsDSOLocal flag in every summary if any of them is false.; //; // Because of (c, d) we don't internalize variables read by function A; // and modified by function B.; //; // Internalization itself happens in the backend after import is finished; // See internalizeGVsAfterImport.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:10,Security,access,access,10,"// Do the access attribute and DSOLocal propagation in combined index.; // The goal of attribute propagation is internalization of readonly (RO); // or writeonly (WO) variables. To determine which variables are RO or WO; // and which are not we take following steps:; // - During analysis we speculatively assign readonly and writeonly; // attribute to all variables which can be internalized. When computing; // function summary we also assign readonly or writeonly attribute to a; // reference if function doesn't modify referenced variable (readonly); // or doesn't read it (writeonly).; //; // - After computing dead symbols in combined index we do the attribute; // and DSOLocal propagation. During this step we:; // a. clear RO and WO attributes from variables which are preserved or; // can't be imported; // b. clear RO and WO attributes from variables referenced by any global; // variable initializer; // c. clear RO attribute from variable referenced by a function when; // reference is not readonly; // d. clear WO attribute from variable referenced by a function when; // reference is not writeonly; // e. clear IsDSOLocal flag in every summary if any of them is false.; //; // Because of (c, d) we don't internalize variables read by function A; // and modified by function B.; //; // Internalization itself happens in the backend after import is finished; // See internalizeGVsAfterImport.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:725,Usability,clear,clear,725,"// Do the access attribute and DSOLocal propagation in combined index.; // The goal of attribute propagation is internalization of readonly (RO); // or writeonly (WO) variables. To determine which variables are RO or WO; // and which are not we take following steps:; // - During analysis we speculatively assign readonly and writeonly; // attribute to all variables which can be internalized. When computing; // function summary we also assign readonly or writeonly attribute to a; // reference if function doesn't modify referenced variable (readonly); // or doesn't read it (writeonly).; //; // - After computing dead symbols in combined index we do the attribute; // and DSOLocal propagation. During this step we:; // a. clear RO and WO attributes from variables which are preserved or; // can't be imported; // b. clear RO and WO attributes from variables referenced by any global; // variable initializer; // c. clear RO attribute from variable referenced by a function when; // reference is not readonly; // d. clear WO attribute from variable referenced by a function when; // reference is not writeonly; // e. clear IsDSOLocal flag in every summary if any of them is false.; //; // Because of (c, d) we don't internalize variables read by function A; // and modified by function B.; //; // Internalization itself happens in the backend after import is finished; // See internalizeGVsAfterImport.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:819,Usability,clear,clear,819,"// Do the access attribute and DSOLocal propagation in combined index.; // The goal of attribute propagation is internalization of readonly (RO); // or writeonly (WO) variables. To determine which variables are RO or WO; // and which are not we take following steps:; // - During analysis we speculatively assign readonly and writeonly; // attribute to all variables which can be internalized. When computing; // function summary we also assign readonly or writeonly attribute to a; // reference if function doesn't modify referenced variable (readonly); // or doesn't read it (writeonly).; //; // - After computing dead symbols in combined index we do the attribute; // and DSOLocal propagation. During this step we:; // a. clear RO and WO attributes from variables which are preserved or; // can't be imported; // b. clear RO and WO attributes from variables referenced by any global; // variable initializer; // c. clear RO attribute from variable referenced by a function when; // reference is not readonly; // d. clear WO attribute from variable referenced by a function when; // reference is not writeonly; // e. clear IsDSOLocal flag in every summary if any of them is false.; //; // Because of (c, d) we don't internalize variables read by function A; // and modified by function B.; //; // Internalization itself happens in the backend after import is finished; // See internalizeGVsAfterImport.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:918,Usability,clear,clear,918,"// Do the access attribute and DSOLocal propagation in combined index.; // The goal of attribute propagation is internalization of readonly (RO); // or writeonly (WO) variables. To determine which variables are RO or WO; // and which are not we take following steps:; // - During analysis we speculatively assign readonly and writeonly; // attribute to all variables which can be internalized. When computing; // function summary we also assign readonly or writeonly attribute to a; // reference if function doesn't modify referenced variable (readonly); // or doesn't read it (writeonly).; //; // - After computing dead symbols in combined index we do the attribute; // and DSOLocal propagation. During this step we:; // a. clear RO and WO attributes from variables which are preserved or; // can't be imported; // b. clear RO and WO attributes from variables referenced by any global; // variable initializer; // c. clear RO attribute from variable referenced by a function when; // reference is not readonly; // d. clear WO attribute from variable referenced by a function when; // reference is not writeonly; // e. clear IsDSOLocal flag in every summary if any of them is false.; //; // Because of (c, d) we don't internalize variables read by function A; // and modified by function B.; //; // Internalization itself happens in the backend after import is finished; // See internalizeGVsAfterImport.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:1018,Usability,clear,clear,1018,"// Do the access attribute and DSOLocal propagation in combined index.; // The goal of attribute propagation is internalization of readonly (RO); // or writeonly (WO) variables. To determine which variables are RO or WO; // and which are not we take following steps:; // - During analysis we speculatively assign readonly and writeonly; // attribute to all variables which can be internalized. When computing; // function summary we also assign readonly or writeonly attribute to a; // reference if function doesn't modify referenced variable (readonly); // or doesn't read it (writeonly).; //; // - After computing dead symbols in combined index we do the attribute; // and DSOLocal propagation. During this step we:; // a. clear RO and WO attributes from variables which are preserved or; // can't be imported; // b. clear RO and WO attributes from variables referenced by any global; // variable initializer; // c. clear RO attribute from variable referenced by a function when; // reference is not readonly; // d. clear WO attribute from variable referenced by a function when; // reference is not writeonly; // e. clear IsDSOLocal flag in every summary if any of them is false.; //; // Because of (c, d) we don't internalize variables read by function A; // and modified by function B.; //; // Internalization itself happens in the backend after import is finished; // See internalizeGVsAfterImport.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:1119,Usability,clear,clear,1119,"// Do the access attribute and DSOLocal propagation in combined index.; // The goal of attribute propagation is internalization of readonly (RO); // or writeonly (WO) variables. To determine which variables are RO or WO; // and which are not we take following steps:; // - During analysis we speculatively assign readonly and writeonly; // attribute to all variables which can be internalized. When computing; // function summary we also assign readonly or writeonly attribute to a; // reference if function doesn't modify referenced variable (readonly); // or doesn't read it (writeonly).; //; // - After computing dead symbols in combined index we do the attribute; // and DSOLocal propagation. During this step we:; // a. clear RO and WO attributes from variables which are preserved or; // can't be imported; // b. clear RO and WO attributes from variables referenced by any global; // variable initializer; // c. clear RO attribute from variable referenced by a function when; // reference is not readonly; // d. clear WO attribute from variable referenced by a function when; // reference is not writeonly; // e. clear IsDSOLocal flag in every summary if any of them is false.; //; // Because of (c, d) we don't internalize variables read by function A; // and modified by function B.; //; // Internalization itself happens in the backend after import is finished; // See internalizeGVsAfterImport.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:371,Testability,assert,assert,371,// computeDeadSymbolsAndUpdateIndirectCalls should have marked all; // copies live. Note that it is possible that there is a GUID collision; // between internal symbols with the same name in different files of the; // same name but not enough distinguishing path. Because; // computeDeadSymbolsAndUpdateIndirectCalls should conservatively mark; // all copies live we can assert here that all are dead if any copy is; // dead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:125,Usability,GUID,GUID,125,// computeDeadSymbolsAndUpdateIndirectCalls should have marked all; // copies live. Note that it is possible that there is a GUID collision; // between internal symbols with the same name in different files of the; // same name but not enough distinguishing path. Because; // computeDeadSymbolsAndUpdateIndirectCalls should conservatively mark; // all copies live we can assert here that all are dead if any copy is; // dead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:10,Modifiability,variab,variable,10,"// Global variable can't be marked read/writeonly if it is not eligible; // to import since we need to ensure that all external references get; // a local (imported) copy. It also can't be marked read/writeonly if; // it or any alias (since alias points to the same memory) are preserved; // or notEligibleToImport, since either of those means there could be; // writes (or reads in case of writeonly) that are not visible (because; // preserved means it could have external to DSO writes or reads, and; // notEligibleToImport means it could have writes or reads via inline; // assembly leading it to be in the @llvm.*used).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:594,Availability,error,error,594,"// We don't analyze GV references during attribute propagation, so; // GV with non-trivial initializer can be marked either read or; // write-only.; // Importing definiton of readonly GV with non-trivial initializer; // allows us doing some extra optimizations (like converting indirect; // calls to direct).; // Definition of writeonly GV with non-trivial initializer should also; // be imported. Not doing so will result in:; // a) GV internalization in source module (because it's writeonly); // b) Importing of GV declaration to destination module as a result; // of promotion.; // c) Link error (external declaration with internal definition).; // However we do not promote objects referenced by writeonly GV; // initializer by means of converting it to 'zeroinitializer'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:247,Performance,optimiz,optimizations,247,"// We don't analyze GV references during attribute propagation, so; // GV with non-trivial initializer can be marked either read or; // write-only.; // Importing definiton of readonly GV with non-trivial initializer; // allows us doing some extra optimizations (like converting indirect; // calls to direct).; // Definition of writeonly GV with non-trivial initializer should also; // be imported. Not doing so will result in:; // a) GV internalization in source module (because it's writeonly); // b) Importing of GV declaration to destination module as a result; // of promotion.; // c) Link error (external declaration with internal definition).; // However we do not promote objects referenced by writeonly GV; // initializer by means of converting it to 'zeroinitializer'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:10,Modifiability,variab,variable,10,"// Global variable with non-trivial initializer can be imported; // if it's readonly. This gives us extra opportunities for constant; // folding and converting indirect calls to direct calls. We don't; // analyze GV references during attribute propagation, because we; // don't know yet if it is readonly or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:114,Deployability,update,update,114,// TODO: write a graphviz dumper for SCCs (see ModuleSummaryIndex::exportToDot); // then delete this function and update its tests,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:125,Testability,test,tests,125,// TODO: write a graphviz dumper for SCCs (see ModuleSummaryIndex::exportToDot); // then delete this function and update its tests,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:135,Modifiability,variab,variable,135,"// Write definition of external node, which doesn't have any; // specific module associated with it. Typically this is function; // or variable defined in native object or library.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:37,Usability,GUID,GUID,37,"// Get node identifier in form MXXX_<GUID>. The MXXX prefix is required,; // because we may have multiple linkonce functions summaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Operator.cpp:96,Safety,detect,detect,96,// External Analysis can return a result higher/lower than the value; // represents. We need to detect overflow/underflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Operator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Operator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Operator.cpp:3,Performance,Scalab,Scalable,3,// Scalable vectors are multiplied by a runtime constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Operator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Operator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Operator.cpp:18,Performance,scalab,scalable,18,// if the type is scalable and the constant is not zero (vscale * n * 0 =; // 0) bailout.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Operator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Operator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Operator.cpp:3,Performance,Scalab,Scalable,3,// Scalable vectors are multiplied by a runtime constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Operator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Operator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Operator.cpp:18,Performance,scalab,scalable,18,"// If the type is scalable and the constant is not zero (vscale * n * 0 =; // 0) bailout.; // TODO: If the runtime value is accessible at any point before DWARF; // emission, then we could potentially keep a forward reference to it; // in the debug value to be filled in later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Operator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Operator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Operator.cpp:124,Security,access,accessible,124,"// If the type is scalable and the constant is not zero (vscale * n * 0 =; // 0) bailout.; // TODO: If the runtime value is accessible at any point before DWARF; // emission, then we could potentially keep a forward reference to it; // in the debug value to be filled in later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Operator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Operator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/OptBisect.cpp:440,Performance,optimiz,optimizations,440,"//===- llvm/IR/OptBisect/Bisect.cpp - LLVM Bisect support -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file implements support for a bisecting optimizations based on a; /// command line option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/OptBisect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/OptBisect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Pass.cpp:200,Availability,error,error,200,"// This only gets called during static destruction, in which case the; // PassRegistry will have already been destroyed by llvm_shutdown(). So; // attempting to remove the registration listener is an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Pass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Pass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Pass.cpp:320,Integrability,depend,depend,320,"// end anonymous namespace; // setPreservesCFG - This function should be called to by the pass, iff they do; // not:; //; // 1. Add or remove basic blocks from the function; // 2. Modify terminator instructions in any way.; //; // This function annotates the AnalysisUsage info object to say that analyses; // that only depend on the CFG are preserved by this pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Pass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Pass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Pass.cpp:93,Integrability,depend,depend,93,"// Since this transformation doesn't modify the CFG, it preserves all analyses; // that only depend on the CFG (like dominators, loop info, etc...)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Pass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Pass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassInstrumentation.cpp:54,Integrability,interface,interface,54,"//===- PassInstrumentation.cpp - Pass Instrumentation interface -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file provides the implementation of PassInstrumentation class.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/PassInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassManager.cpp:297,Deployability,update,updated,297,"// This is still a valid proxy.; // If this proxy isn't marked as preserved, then even if the result remains; // valid, the key itself may no longer be valid, so we clear everything.; //; // Note that in order to preserve this proxy, a module pass must ensure that; // the FAM has been completely updated to handle the deletion of functions.; // Specifically, any FAM-cached results for those functions need to have been; // forcibly cleared. When preserved, this proxy will only invalidate results; // cached on functions *still in the module* at the end of the module pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/PassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassManager.cpp:368,Performance,cache,cached,368,"// This is still a valid proxy.; // If this proxy isn't marked as preserved, then even if the result remains; // valid, the key itself may no longer be valid, so we clear everything.; //; // Note that in order to preserve this proxy, a module pass must ensure that; // the FAM has been completely updated to handle the deletion of functions.; // Specifically, any FAM-cached results for those functions need to have been; // forcibly cleared. When preserved, this proxy will only invalidate results; // cached on functions *still in the module* at the end of the module pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/PassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassManager.cpp:503,Performance,cache,cached,503,"// This is still a valid proxy.; // If this proxy isn't marked as preserved, then even if the result remains; // valid, the key itself may no longer be valid, so we clear everything.; //; // Note that in order to preserve this proxy, a module pass must ensure that; // the FAM has been completely updated to handle the deletion of functions.; // Specifically, any FAM-cached results for those functions need to have been; // forcibly cleared. When preserved, this proxy will only invalidate results; // cached on functions *still in the module* at the end of the module pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/PassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassManager.cpp:165,Usability,clear,clear,165,"// This is still a valid proxy.; // If this proxy isn't marked as preserved, then even if the result remains; // valid, the key itself may no longer be valid, so we clear everything.; //; // Note that in order to preserve this proxy, a module pass must ensure that; // the FAM has been completely updated to handle the deletion of functions.; // Specifically, any FAM-cached results for those functions need to have been; // forcibly cleared. When preserved, this proxy will only invalidate results; // cached on functions *still in the module* at the end of the module pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/PassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassManager.cpp:434,Usability,clear,cleared,434,"// This is still a valid proxy.; // If this proxy isn't marked as preserved, then even if the result remains; // valid, the key itself may no longer be valid, so we clear everything.; //; // Note that in order to preserve this proxy, a module pass must ensure that; // the FAM has been completely updated to handle the deletion of functions.; // Specifically, any FAM-cached results for those functions need to have been; // forcibly cleared. When preserved, this proxy will only invalidate results; // cached on functions *still in the module* at the end of the module pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/PassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassManager.cpp:106,Integrability,contract,contract,106,"// We know that the function pass couldn't have invalidated any other; // function's analyses (that's the contract of a function pass), so; // directly handle the function analysis manager's invalidation here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/PassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassRegistry.cpp:510,Integrability,depend,dependency,510,"//===- PassRegistry.cpp - Pass Registration Implementation ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the PassRegistry, with which passes are registered on; // initialization, and supports the PassManager in dependency resolution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/PassRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassRegistry.cpp:85,Security,Access,Accessors,85,//===----------------------------------------------------------------------===//; // Accessors; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/PassRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassRegistry.cpp:22,Integrability,Interface,Interface,22,"// First reference to Interface, register it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/PassRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassRegistry.cpp:82,Integrability,interface,interface,82,// Make sure we keep track of the fact that the implementation implements; // the interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/PassRegistry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassRegistry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassTimingInfo.cpp:154,Integrability,interface,interface,154,//===----------------------------------------------------------------------===//; // Legacy pass manager's PassTimingInfo implementation; /// Provides an interface for collecting pass timing information.; ///; /// It was intended to be generic but now we decided to split; /// interfaces completely. This is now exclusively for legacy-pass-manager use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/PassTimingInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassTimingInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassTimingInfo.cpp:277,Integrability,interface,interfaces,277,//===----------------------------------------------------------------------===//; // Legacy pass manager's PassTimingInfo implementation; /// Provides an interface for collecting pass timing information.; ///; /// It was intended to be generic but now we decided to split; /// interfaces completely. This is now exclusively for legacy-pass-manager use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/PassTimingInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassTimingInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassTimingInfo.cpp:37,Deployability,release,release,37,/// Print out timing information and release timers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/PassTimingInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassTimingInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PrintPasses.cpp:1782,Availability,error,error,1782,"// Print out the IR after passes, similar to -print-after-all except that it; // only prints the IR after passes that change the IR. Those passes that do not; // make changes to the IR are reported as not making any changes. In addition,; // the initial IR is also reported. Other hidden options affect the output from; // this option. -filter-passes will limit the output to the named passes that; // actually change the IR and other passes are reported as filtered out. The; // specified passes will either be reported as making no changes (with no IR; // reported) or the changed IR will be reported. Also, the -filter-print-funcs; // and -print-module-scope options will do similar filtering based on function; // name, reporting changed IRs as functions(or modules if -print-module-scope is; // specified) for a particular function or indicating that the IR has been; // filtered out. The extra options can be combined, allowing only changed IRs; // for certain passes on certain functions to be reported in different formats,; // with the rest being reported as filtered out. The -print-before-changed; // option will print the IR as it was before each pass that changed it. The; // optional value of quiet will only report when the IR changes, suppressing all; // other messages, including the initial IR. The values ""diff"" and ""diff-quiet""; // will present the changes in a form similar to a patch, in either verbose or; // quiet mode, respectively. The lines that are removed and added are prefixed; // with '-' and '+', respectively. The -filter-print-funcs and -filter-passes; // can be used to filter the output. This reporter relies on the linux diff; // utility to do comparisons and insert the prefixes. For systems that do not; // have the necessary facilities, the error message will be shown in place of; // the expected output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/PrintPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PrintPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PrintPasses.cpp:1400,Deployability,patch,patch,1400,"// Print out the IR after passes, similar to -print-after-all except that it; // only prints the IR after passes that change the IR. Those passes that do not; // make changes to the IR are reported as not making any changes. In addition,; // the initial IR is also reported. Other hidden options affect the output from; // this option. -filter-passes will limit the output to the named passes that; // actually change the IR and other passes are reported as filtered out. The; // specified passes will either be reported as making no changes (with no IR; // reported) or the changed IR will be reported. Also, the -filter-print-funcs; // and -print-module-scope options will do similar filtering based on function; // name, reporting changed IRs as functions(or modules if -print-module-scope is; // specified) for a particular function or indicating that the IR has been; // filtered out. The extra options can be combined, allowing only changed IRs; // for certain passes on certain functions to be reported in different formats,; // with the rest being reported as filtered out. The -print-before-changed; // option will print the IR as it was before each pass that changed it. The; // optional value of quiet will only report when the IR changes, suppressing all; // other messages, including the initial IR. The values ""diff"" and ""diff-quiet""; // will present the changes in a form similar to a patch, in either verbose or; // quiet mode, respectively. The lines that are removed and added are prefixed; // with '-' and '+', respectively. The -filter-print-funcs and -filter-passes; // can be used to filter the output. This reporter relies on the linux diff; // utility to do comparisons and insert the prefixes. For systems that do not; // have the necessary facilities, the error message will be shown in place of; // the expected output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/PrintPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PrintPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PrintPasses.cpp:1277,Integrability,message,messages,1277,"// Print out the IR after passes, similar to -print-after-all except that it; // only prints the IR after passes that change the IR. Those passes that do not; // make changes to the IR are reported as not making any changes. In addition,; // the initial IR is also reported. Other hidden options affect the output from; // this option. -filter-passes will limit the output to the named passes that; // actually change the IR and other passes are reported as filtered out. The; // specified passes will either be reported as making no changes (with no IR; // reported) or the changed IR will be reported. Also, the -filter-print-funcs; // and -print-module-scope options will do similar filtering based on function; // name, reporting changed IRs as functions(or modules if -print-module-scope is; // specified) for a particular function or indicating that the IR has been; // filtered out. The extra options can be combined, allowing only changed IRs; // for certain passes on certain functions to be reported in different formats,; // with the rest being reported as filtered out. The -print-before-changed; // option will print the IR as it was before each pass that changed it. The; // optional value of quiet will only report when the IR changes, suppressing all; // other messages, including the initial IR. The values ""diff"" and ""diff-quiet""; // will present the changes in a form similar to a patch, in either verbose or; // quiet mode, respectively. The lines that are removed and added are prefixed; // with '-' and '+', respectively. The -filter-print-funcs and -filter-passes; // can be used to filter the output. This reporter relies on the linux diff; // utility to do comparisons and insert the prefixes. For systems that do not; // have the necessary facilities, the error message will be shown in place of; // the expected output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/PrintPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PrintPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PrintPasses.cpp:1788,Integrability,message,message,1788,"// Print out the IR after passes, similar to -print-after-all except that it; // only prints the IR after passes that change the IR. Those passes that do not; // make changes to the IR are reported as not making any changes. In addition,; // the initial IR is also reported. Other hidden options affect the output from; // this option. -filter-passes will limit the output to the named passes that; // actually change the IR and other passes are reported as filtered out. The; // specified passes will either be reported as making no changes (with no IR; // reported) or the changed IR will be reported. Also, the -filter-print-funcs; // and -print-module-scope options will do similar filtering based on function; // name, reporting changed IRs as functions(or modules if -print-module-scope is; // specified) for a particular function or indicating that the IR has been; // filtered out. The extra options can be combined, allowing only changed IRs; // for certain passes on certain functions to be reported in different formats,; // with the rest being reported as filtered out. The -print-before-changed; // option will print the IR as it was before each pass that changed it. The; // optional value of quiet will only report when the IR changes, suppressing all; // other messages, including the initial IR. The values ""diff"" and ""diff-quiet""; // will present the changes in a form similar to a patch, in either verbose or; // quiet mode, respectively. The lines that are removed and added are prefixed; // with '-' and '+', respectively. The -filter-print-funcs and -filter-passes; // can be used to filter the output. This reporter relies on the linux diff; // utility to do comparisons and insert the prefixes. For systems that do not; // have the necessary facilities, the error message will be shown in place of; // the expected output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/PrintPasses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PrintPasses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ProfDataUtils.cpp:297,Security,access,access,297,"// MD_prof nodes have the following layout; //; // In general:; // { String name, Array of i32 }; //; // In terms of Types:; // { MDString, [i32, i32, ...]}; //; // Concretely for Branch Weights; // { ""branch_weights"", [i32 1, i32 10000]}; //; // We maintain some constants here to ensure that we access the branch weights; // correctly, and can change the behavior in the future if the layout changes; // The index at which the weights vector starts",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ProfDataUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ProfDataUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ProfDataUtils.cpp:14,Integrability,rout,routine,14,// TODO: This routine may be simplified if MD_prof used an enum instead of a; // string to differentiate the types of MD_prof nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ProfDataUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ProfDataUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ProfDataUtils.cpp:29,Usability,simpl,simplified,29,// TODO: This routine may be simplified if MD_prof used an enum instead of a; // string to differentiate the types of MD_prof nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ProfDataUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ProfDataUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PseudoProbe.cpp:31,Safety,avoid,avoid,31,// Round small factors to 0 to avoid over-counting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/PseudoProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PseudoProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:8,Safety,Safe,SafepointIRVerifier,8,"//===-- SafepointIRVerifier.cpp - Verify gc.statepoint invariants ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Run a basic correctness check on the IR to ensure that Safepoints - if; // they've been inserted - were inserted correctly. In particular, look for use; // of non-relocated values after a safepoint. It's primary use is to check the; // correctness of safepoint insertion immediately after insertion, but it can; // also be used to verify that later transforms have not found a way to break; // safepoint semenatics.; //; // In its current form, this verify checks a property which is sufficient, but; // not neccessary for correctness. There are some cases where an unrelocated; // pointer can be used after the safepoint. Consider this example:; //; // a = ...; // b = ...; // (a',b') = safepoint(a,b); // c = cmp eq a b; // br c, ..., ....; //; // Because it is valid to reorder 'c' above the safepoint, this is legal. In; // practice, this is a somewhat uncommon transform, but CodeGenPrep does create; // idioms like this. The verifier knows about these cases and avoids reporting; // false positives.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:438,Safety,Safe,Safepoints,438,"//===-- SafepointIRVerifier.cpp - Verify gc.statepoint invariants ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Run a basic correctness check on the IR to ensure that Safepoints - if; // they've been inserted - were inserted correctly. In particular, look for use; // of non-relocated values after a safepoint. It's primary use is to check the; // correctness of safepoint insertion immediately after insertion, but it can; // also be used to verify that later transforms have not found a way to break; // safepoint semenatics.; //; // In its current form, this verify checks a property which is sufficient, but; // not neccessary for correctness. There are some cases where an unrelocated; // pointer can be used after the safepoint. Consider this example:; //; // a = ...; // b = ...; // (a',b') = safepoint(a,b); // c = cmp eq a b; // br c, ..., ....; //; // Because it is valid to reorder 'c' above the safepoint, this is legal. In; // practice, this is a somewhat uncommon transform, but CodeGenPrep does create; // idioms like this. The verifier knows about these cases and avoids reporting; // false positives.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:571,Safety,safe,safepoint,571,"//===-- SafepointIRVerifier.cpp - Verify gc.statepoint invariants ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Run a basic correctness check on the IR to ensure that Safepoints - if; // they've been inserted - were inserted correctly. In particular, look for use; // of non-relocated values after a safepoint. It's primary use is to check the; // correctness of safepoint insertion immediately after insertion, but it can; // also be used to verify that later transforms have not found a way to break; // safepoint semenatics.; //; // In its current form, this verify checks a property which is sufficient, but; // not neccessary for correctness. There are some cases where an unrelocated; // pointer can be used after the safepoint. Consider this example:; //; // a = ...; // b = ...; // (a',b') = safepoint(a,b); // c = cmp eq a b; // br c, ..., ....; //; // Because it is valid to reorder 'c' above the safepoint, this is legal. In; // practice, this is a somewhat uncommon transform, but CodeGenPrep does create; // idioms like this. The verifier knows about these cases and avoids reporting; // false positives.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:634,Safety,safe,safepoint,634,"//===-- SafepointIRVerifier.cpp - Verify gc.statepoint invariants ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Run a basic correctness check on the IR to ensure that Safepoints - if; // they've been inserted - were inserted correctly. In particular, look for use; // of non-relocated values after a safepoint. It's primary use is to check the; // correctness of safepoint insertion immediately after insertion, but it can; // also be used to verify that later transforms have not found a way to break; // safepoint semenatics.; //; // In its current form, this verify checks a property which is sufficient, but; // not neccessary for correctness. There are some cases where an unrelocated; // pointer can be used after the safepoint. Consider this example:; //; // a = ...; // b = ...; // (a',b') = safepoint(a,b); // c = cmp eq a b; // br c, ..., ....; //; // Because it is valid to reorder 'c' above the safepoint, this is legal. In; // practice, this is a somewhat uncommon transform, but CodeGenPrep does create; // idioms like this. The verifier knows about these cases and avoids reporting; // false positives.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:777,Safety,safe,safepoint,777,"//===-- SafepointIRVerifier.cpp - Verify gc.statepoint invariants ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Run a basic correctness check on the IR to ensure that Safepoints - if; // they've been inserted - were inserted correctly. In particular, look for use; // of non-relocated values after a safepoint. It's primary use is to check the; // correctness of safepoint insertion immediately after insertion, but it can; // also be used to verify that later transforms have not found a way to break; // safepoint semenatics.; //; // In its current form, this verify checks a property which is sufficient, but; // not neccessary for correctness. There are some cases where an unrelocated; // pointer can be used after the safepoint. Consider this example:; //; // a = ...; // b = ...; // (a',b') = safepoint(a,b); // c = cmp eq a b; // br c, ..., ....; //; // Because it is valid to reorder 'c' above the safepoint, this is legal. In; // practice, this is a somewhat uncommon transform, but CodeGenPrep does create; // idioms like this. The verifier knows about these cases and avoids reporting; // false positives.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:995,Safety,safe,safepoint,995,"//===-- SafepointIRVerifier.cpp - Verify gc.statepoint invariants ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Run a basic correctness check on the IR to ensure that Safepoints - if; // they've been inserted - were inserted correctly. In particular, look for use; // of non-relocated values after a safepoint. It's primary use is to check the; // correctness of safepoint insertion immediately after insertion, but it can; // also be used to verify that later transforms have not found a way to break; // safepoint semenatics.; //; // In its current form, this verify checks a property which is sufficient, but; // not neccessary for correctness. There are some cases where an unrelocated; // pointer can be used after the safepoint. Consider this example:; //; // a = ...; // b = ...; // (a',b') = safepoint(a,b); // c = cmp eq a b; // br c, ..., ....; //; // Because it is valid to reorder 'c' above the safepoint, this is legal. In; // practice, this is a somewhat uncommon transform, but CodeGenPrep does create; // idioms like this. The verifier knows about these cases and avoids reporting; // false positives.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:1071,Safety,safe,safepoint,1071,"//===-- SafepointIRVerifier.cpp - Verify gc.statepoint invariants ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Run a basic correctness check on the IR to ensure that Safepoints - if; // they've been inserted - were inserted correctly. In particular, look for use; // of non-relocated values after a safepoint. It's primary use is to check the; // correctness of safepoint insertion immediately after insertion, but it can; // also be used to verify that later transforms have not found a way to break; // safepoint semenatics.; //; // In its current form, this verify checks a property which is sufficient, but; // not neccessary for correctness. There are some cases where an unrelocated; // pointer can be used after the safepoint. Consider this example:; //; // a = ...; // b = ...; // (a',b') = safepoint(a,b); // c = cmp eq a b; // br c, ..., ....; //; // Because it is valid to reorder 'c' above the safepoint, this is legal. In; // practice, this is a somewhat uncommon transform, but CodeGenPrep does create; // idioms like this. The verifier knows about these cases and avoids reporting; // false positives.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:1178,Safety,safe,safepoint,1178,"//===-- SafepointIRVerifier.cpp - Verify gc.statepoint invariants ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Run a basic correctness check on the IR to ensure that Safepoints - if; // they've been inserted - were inserted correctly. In particular, look for use; // of non-relocated values after a safepoint. It's primary use is to check the; // correctness of safepoint insertion immediately after insertion, but it can; // also be used to verify that later transforms have not found a way to break; // safepoint semenatics.; //; // In its current form, this verify checks a property which is sufficient, but; // not neccessary for correctness. There are some cases where an unrelocated; // pointer can be used after the safepoint. Consider this example:; //; // a = ...; // b = ...; // (a',b') = safepoint(a,b); // c = cmp eq a b; // br c, ..., ....; //; // Because it is valid to reorder 'c' above the safepoint, this is legal. In; // practice, this is a somewhat uncommon transform, but CodeGenPrep does create; // idioms like this. The verifier knows about these cases and avoids reporting; // false positives.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:1351,Safety,avoid,avoids,1351,"//===-- SafepointIRVerifier.cpp - Verify gc.statepoint invariants ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Run a basic correctness check on the IR to ensure that Safepoints - if; // they've been inserted - were inserted correctly. In particular, look for use; // of non-relocated values after a safepoint. It's primary use is to check the; // correctness of safepoint insertion immediately after insertion, but it can; // also be used to verify that later transforms have not found a way to break; // safepoint semenatics.; //; // In its current form, this verify checks a property which is sufficient, but; // not neccessary for correctness. There are some cases where an unrelocated; // pointer can be used after the safepoint. Consider this example:; //; // a = ...; // b = ...; // (a',b') = safepoint(a,b); // c = cmp eq a b; // br c, ..., ....; //; // Because it is valid to reorder 'c' above the safepoint, this is legal. In; // practice, this is a somewhat uncommon transform, but CodeGenPrep does create; // idioms like this. The verifier knows about these cases and avoids reporting; // false positives.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:119,Integrability,message,message,119,"/// This option is used for writing test cases. Instead of crashing the program; /// when verification fails, report a message to the console (for FileCheck; /// usage) and continue execution as if nothing happened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:36,Testability,test,test,36,"/// This option is used for writing test cases. Instead of crashing the program; /// when verification fails, report a message to the console (for FileCheck; /// usage) and continue execution as if nothing happened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:300,Usability,Simpl,SimplifyCFG,300,"/// This CFG Deadness finds dead blocks and edges. Algorithm starts with a set; /// of blocks unreachable from entry then propagates deadness using foldable; /// conditional branches without modifying CFG. So GVN does but it changes CFG; /// by splitting critical edges. In most cases passes rely on SimplifyCFG to; /// clean up dead blocks, but in some cases, like verification or loop passes; /// it's not possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:7,Availability,down,down,7,// Top-down walk of the dominator tree,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:36,Performance,perform,perform,36,"// For conditional branches, we can perform simple conditional propagation on; // the condition value itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:44,Usability,simpl,simple,44,"// For conditional branches, we can perform simple conditional propagation on; // the condition value itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:151,Deployability,update,updated,151,"// For the sake of this example GC, we arbitrarily pick addrspace(1) as our; // GC managed heap. We know that a pointer into this heap needs to be; // updated and that no other pointer does.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:50,Availability,avail,availability,50,"/// The verifier algorithm is phrased in terms of availability. The set of; /// values ""available"" at a given point in the control flow graph is the set of; /// correctly relocated value at that point, and is a subset of the set of; /// definitions dominating that point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:88,Availability,avail,available,88,"/// The verifier algorithm is phrased in terms of availability. The set of; /// values ""available"" at a given point in the control flow graph is the set of; /// correctly relocated value at that point, and is a subset of the set of; /// definitions dominating that point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:17,Availability,avail,available,17,"// Set of values available coming in, before the phi nodes",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:17,Availability,avail,available,17,// Set of values available going out,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:3,Availability,Avail,AvailableOut,3,// AvailableOut minus AvailableIn.; // All elements are Instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:22,Availability,Avail,AvailableIn,22,// AvailableOut minus AvailableIn.; // All elements are Instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:52,Availability,Avail,AvailableIn,52,// True if this block contains a safepoint and thus AvailableIn does not; // contribute to AvailableOut.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:91,Availability,Avail,AvailableOut,91,// True if this block contains a safepoint and thus AvailableIn does not; // contribute to AvailableOut.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:33,Safety,safe,safepoint,33,// True if this block contains a safepoint and thus AvailableIn does not; // contribute to AvailableOut.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:427,Safety,safe,safely,427,"/// Builds BasicBlockState for each BB of the function.; /// It can traverse function for verification and provides all required; /// information.; ///; /// GC pointer may be in one of three states: relocated, unrelocated and; /// poisoned.; /// Relocated pointer may be used without any restrictions.; /// Unrelocated pointer cannot be dereferenced, passed as argument to any call; /// or returned. Unrelocated pointer may be safely compared against another; /// unrelocated pointer or against a pointer exclusively derived from null.; /// Poisoned pointers are produced when we somehow derive pointer from relocated; /// and unrelocated pointers (e.g. phi, select). This pointers may be safely; /// used in a very limited number of situations. Currently the only way to use; /// it is comparison against constant exclusively derived from null. All; /// limitations arise due to their undefined state: this pointers should be; /// treated as relocated and unrelocated simultaneously.; /// Rules of deriving:; /// R + U = P - that's where the poisoned pointers come from; /// P + X = P; /// U + U = U; /// R + R = R; /// X + C = X; /// Where ""+"" - any operation that somehow derive pointer, U - unrelocated,; /// R - relocated and P - poisoned, C - constant, X - U or R or P or C or; /// nothing (in case when ""+"" is unary operation).; /// Deriving of pointers by itself is always safe.; /// NOTE: when we are making decision on the status of instruction's result:; /// a) for phi we need to check status of each input *at the end of; /// corresponding predecessor BB*.; /// b) for other instructions we need to check status of each input *at the; /// current point*.; ///; /// FIXME: This works fairly well except one case; /// bb1:; /// p = *some GC-ptr def*; /// p1 = gep p, offset; /// / |; /// / |; /// bb2: |; /// safepoint |; /// \ |; /// \ |; /// bb3:; /// p2 = phi [p, bb2] [p1, bb1]; /// p3 = phi [p, bb2] [p, bb1]; /// here p and p1 is unrelocated; /// p2 and p3 is poisoned (though they sh",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:689,Safety,safe,safely,689,"/// Builds BasicBlockState for each BB of the function.; /// It can traverse function for verification and provides all required; /// information.; ///; /// GC pointer may be in one of three states: relocated, unrelocated and; /// poisoned.; /// Relocated pointer may be used without any restrictions.; /// Unrelocated pointer cannot be dereferenced, passed as argument to any call; /// or returned. Unrelocated pointer may be safely compared against another; /// unrelocated pointer or against a pointer exclusively derived from null.; /// Poisoned pointers are produced when we somehow derive pointer from relocated; /// and unrelocated pointers (e.g. phi, select). This pointers may be safely; /// used in a very limited number of situations. Currently the only way to use; /// it is comparison against constant exclusively derived from null. All; /// limitations arise due to their undefined state: this pointers should be; /// treated as relocated and unrelocated simultaneously.; /// Rules of deriving:; /// R + U = P - that's where the poisoned pointers come from; /// P + X = P; /// U + U = U; /// R + R = R; /// X + C = X; /// Where ""+"" - any operation that somehow derive pointer, U - unrelocated,; /// R - relocated and P - poisoned, C - constant, X - U or R or P or C or; /// nothing (in case when ""+"" is unary operation).; /// Deriving of pointers by itself is always safe.; /// NOTE: when we are making decision on the status of instruction's result:; /// a) for phi we need to check status of each input *at the end of; /// corresponding predecessor BB*.; /// b) for other instructions we need to check status of each input *at the; /// current point*.; ///; /// FIXME: This works fairly well except one case; /// bb1:; /// p = *some GC-ptr def*; /// p1 = gep p, offset; /// / |; /// / |; /// bb2: |; /// safepoint |; /// \ |; /// \ |; /// bb3:; /// p2 = phi [p, bb2] [p1, bb1]; /// p3 = phi [p, bb2] [p, bb1]; /// here p and p1 is unrelocated; /// p2 and p3 is poisoned (though they sh",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:1381,Safety,safe,safe,1381," argument to any call; /// or returned. Unrelocated pointer may be safely compared against another; /// unrelocated pointer or against a pointer exclusively derived from null.; /// Poisoned pointers are produced when we somehow derive pointer from relocated; /// and unrelocated pointers (e.g. phi, select). This pointers may be safely; /// used in a very limited number of situations. Currently the only way to use; /// it is comparison against constant exclusively derived from null. All; /// limitations arise due to their undefined state: this pointers should be; /// treated as relocated and unrelocated simultaneously.; /// Rules of deriving:; /// R + U = P - that's where the poisoned pointers come from; /// P + X = P; /// U + U = U; /// R + R = R; /// X + C = X; /// Where ""+"" - any operation that somehow derive pointer, U - unrelocated,; /// R - relocated and P - poisoned, C - constant, X - U or R or P or C or; /// nothing (in case when ""+"" is unary operation).; /// Deriving of pointers by itself is always safe.; /// NOTE: when we are making decision on the status of instruction's result:; /// a) for phi we need to check status of each input *at the end of; /// corresponding predecessor BB*.; /// b) for other instructions we need to check status of each input *at the; /// current point*.; ///; /// FIXME: This works fairly well except one case; /// bb1:; /// p = *some GC-ptr def*; /// p1 = gep p, offset; /// / |; /// / |; /// bb2: |; /// safepoint |; /// \ |; /// \ |; /// bb3:; /// p2 = phi [p, bb2] [p1, bb1]; /// p3 = phi [p, bb2] [p, bb1]; /// here p and p1 is unrelocated; /// p2 and p3 is poisoned (though they shouldn't be); ///; /// This leads to some weird results:; /// cmp eq p, p2 - illegal instruction (false-positive); /// cmp eq p1, p2 - illegal instruction (false-positive); /// cmp eq p, p3 - illegal instruction (false-positive); /// cmp eq p, p1 - ok; /// To fix this we need to introduce conception of generations and be able to; /// check if two values belo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:1820,Safety,safe,safepoint,1820,"d pointer or against a pointer exclusively derived from null.; /// Poisoned pointers are produced when we somehow derive pointer from relocated; /// and unrelocated pointers (e.g. phi, select). This pointers may be safely; /// used in a very limited number of situations. Currently the only way to use; /// it is comparison against constant exclusively derived from null. All; /// limitations arise due to their undefined state: this pointers should be; /// treated as relocated and unrelocated simultaneously.; /// Rules of deriving:; /// R + U = P - that's where the poisoned pointers come from; /// P + X = P; /// U + U = U; /// R + R = R; /// X + C = X; /// Where ""+"" - any operation that somehow derive pointer, U - unrelocated,; /// R - relocated and P - poisoned, C - constant, X - U or R or P or C or; /// nothing (in case when ""+"" is unary operation).; /// Deriving of pointers by itself is always safe.; /// NOTE: when we are making decision on the status of instruction's result:; /// a) for phi we need to check status of each input *at the end of; /// corresponding predecessor BB*.; /// b) for other instructions we need to check status of each input *at the; /// current point*.; ///; /// FIXME: This works fairly well except one case; /// bb1:; /// p = *some GC-ptr def*; /// p1 = gep p, offset; /// / |; /// / |; /// bb2: |; /// safepoint |; /// \ |; /// \ |; /// bb3:; /// p2 = phi [p, bb2] [p1, bb1]; /// p3 = phi [p, bb2] [p, bb1]; /// here p and p1 is unrelocated; /// p2 and p3 is poisoned (though they shouldn't be); ///; /// This leads to some weird results:; /// cmp eq p, p2 - illegal instruction (false-positive); /// cmp eq p1, p2 - illegal instruction (false-positive); /// cmp eq p, p3 - illegal instruction (false-positive); /// cmp eq p, p1 - ok; /// To fix this we need to introduce conception of generations and be able to; /// check if two values belong to one generation or not. This way p2 will be; /// considered to be unrelocated and no false alarm will happen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:48,Safety,safe,safely,48,// This set contains poisoned defs. They can be safely ignored during; // verification too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:43,Safety,safe,safely,43,/// Returns true if the instruction may be safely skipped during verification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:57,Availability,Avail,AvailableIn,57,/// Iterates over all BBs from BlockMap and recalculates AvailableIn/Out for; /// each of them until it converges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:84,Usability,simpl,simply,84,/// Gather all the definitions dominating the start of BB into Result. This is; /// simply the defs introduced by every dominating basic block and the; /// function arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:16,Availability,Avail,AvailableOut,16,"/// Compute the AvailableOut set for BB, based on the BasicBlockState BBS,; /// which is the BasicBlockState for BB.; /// ContributionChanged is set when the verifier runs for the first time; /// (in this case Contribution was changed from 'empty' to its initial state); /// or when Contribution of this BB was changed since last computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:53,Availability,avail,available,53,/// Model the effect of an instruction on the set of available values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:144,Safety,safe,safepoint,144,"/// It is a visitor for GCPtrTracker::verifyFunction. It decides if the; /// instruction (which uses heap reference) is legal or not, given our safepoint; /// semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:47,Energy Efficiency,Allocate,Allocate,47,// Calculate Contribution of each live BB.; // Allocate BB states for live blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:14,Availability,Avail,AvailableIn,14,// Initialize AvailableIn/Out sets of each BB using only information about; // dominating BBs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:61,Availability,Avail,AvailableIn,61,"// Simulate the flow of defs through the CFG and recalculate AvailableIn/Out; // sets of each BB until it converges. If any def is proved to be an; // unrelocated pointer, it will be removed from all BBSs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:51,Safety,safe,safe,51,// Poisoned defs are skipped since they are always safe by itself by; // definition (for details see comment to this class).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:50,Availability,error,error,50,// We need RPO here to a) report always the first error b) report errors in; // same order from run to run.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:66,Availability,error,errors,66,// We need RPO here to a) report always the first error b) report errors in; // same order from run to run.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:27,Availability,Avail,AvailableIn,27,// We destructively modify AvailableIn as we traverse the block instruction; // by instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:42,Availability,Avail,AvailableSet,42,// This instruction shouldn't be added to AvailableSet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:46,Availability,Avail,AvailableSet,46,// Model the effect of current instruction on AvailableSet to keep the set; // relevant at each point of BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:79,Performance,queue,queue,79,"// TODO: This order is suboptimal, it's better to replace it with priority; // queue where priority is RPO number of BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:26,Availability,Avail,AvailableIn,26,// This loop iterates the AvailableIn/Out sets until it converges.; // The AvailableIn and AvailableOut sets decrease as we iterate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:75,Availability,Avail,AvailableIn,75,// This loop iterates the AvailableIn/Out sets until it converges.; // The AvailableIn and AvailableOut sets decrease as we iterate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:91,Availability,Avail,AvailableOut,91,// This loop iterates the AvailableIn/Out sets until it converges.; // The AvailableIn and AvailableOut sets decrease as we iterate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:98,Availability,Avail,AvailableSet,98,// GEP/bitcast of unrelocated pointer is legal by itself but this def; // shouldn't appear in any AvailableSet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:82,Deployability,update,update,82,// Remove def of unrelocated pointer from Contribution of this BB and; // trigger update of all its successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:78,Deployability,update,update,78,"// Mark pointer as poisoned, remove its def from Contribution and trigger; // update of all successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:76,Availability,avail,available,76,"// If this block is 'Cleared', then nothing LiveIn to this block can be; // available after this block completes. Note: This turns out to be; // really important for reducing memory consuption of the initial available; // sets and thus peak memory usage by this verifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:208,Availability,avail,available,208,"// If this block is 'Cleared', then nothing LiveIn to this block can be; // available after this block completes. Note: This turns out to be; // really important for reducing memory consuption of the initial available; // sets and thus peak memory usage by this verifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:21,Usability,Clear,Cleared,21,"// If this block is 'Cleared', then nothing LiveIn to this block can be; // available after this block completes. Note: This turns out to be; // really important for reducing memory consuption of the initial available; // sets and thus peak memory usage by this verifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:3,Availability,Avail,AvailableOut,3,// AvailableOut will change only when Contribution changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:36,Availability,Avail,AvailableOut,36,"// Otherwise, we need to reduce the AvailableOut set by things which are no; // longer in our AvailableIn",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:94,Availability,Avail,AvailableIn,94,"// Otherwise, we need to reduce the AvailableOut set by things which are no; // longer in our AvailableIn",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:25,Energy Efficiency,reduce,reduce,25,"// Otherwise, we need to reduce the AvailableOut set by things which are no; // longer in our AvailableIn",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:166,Safety,safe,safepoint,166,"// Constant pointers (that are not exclusively null) may have; // meaning in different VMs, so we cannot reorder the compare; // against constant pointers before the safepoint. In other words,; // comparison of an unrelocated use against a non-null constant; // maybe invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:115,Safety,safe,safepoint,115,"// We now have all the information we need to decide if the use of a heap; // reference is legal or not, given our safepoint semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp:32,Security,Hash,Hashing,32,"//===-- StructuralHash.cpp - IR Hashing -------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp:30,Safety,detect,detect,30,"// Basic hashing mechanism to detect structural change to the IR, used to verify; // pass return status consistency with actual change. In addition to being used; // by the MergeFunctions pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp:9,Security,hash,hashing,9,"// Basic hashing mechanism to detect structural change to the IR, used to verify; // pass return status consistency with actual change. In addition to being used; // by the MergeFunctions pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp:149,Security,hash,hashing,149,"// This will produce different values on 32-bit and 64-bit systens as; // hash_combine returns a size_t. However, this is only used for; // detailed hashing which, in-tree, only needs to distinguish between; // differences in functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp:3,Security,Hash,Hashing,3,// Hashing the name will be deterministic as LLVM's hashing infrastructure; // has explicit support for hashing strings and will not simply hash; // the pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp:52,Security,hash,hashing,52,// Hashing the name will be deterministic as LLVM's hashing infrastructure; // has explicit support for hashing strings and will not simply hash; // the pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp:104,Security,hash,hashing,104,// Hashing the name will be deterministic as LLVM's hashing infrastructure; // has explicit support for hashing strings and will not simply hash; // the pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp:140,Security,hash,hash,140,// Hashing the name will be deterministic as LLVM's hashing infrastructure; // has explicit support for hashing strings and will not simply hash; // the pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp:133,Usability,simpl,simply,133,// Hashing the name will be deterministic as LLVM's hashing infrastructure; // has explicit support for hashing strings and will not simply hash; // the pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp:14,Security,hash,hash,14,"// A function hash is calculated by considering only the number of arguments; // and whether a function is varargs, the order of basic blocks (given by the; // successors of each basic block in depth first order), and the order of; // opcodes of each instruction within each of these basic blocks. This mirrors; // the strategy FunctionComparator::compare() uses to compare functions by; // walking the BBs in depth first order and comparing each instruction in; // sequence. Because this hash currently does not look at the operands, it is; // insensitive to things such as the target of calls and the constants used in; // the function, which makes it useful when possibly merging functions which; // are the same modulo constants and call targets.; //; // Note that different users of StructuralHash will want different behavior; // out of it (i.e., MergeFunctions will want something different from PM; // expensive checks for pass modification status). When modifying this; // function, most changes should be gated behind an option and enabled; // selectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp:489,Security,hash,hash,489,"// A function hash is calculated by considering only the number of arguments; // and whether a function is varargs, the order of basic blocks (given by the; // successors of each basic block in depth first order), and the order of; // opcodes of each instruction within each of these basic blocks. This mirrors; // the strategy FunctionComparator::compare() uses to compare functions by; // walking the BBs in depth first order and comparing each instruction in; // sequence. Because this hash currently does not look at the operands, it is; // insensitive to things such as the target of calls and the constants used in; // the function, which makes it useful when possibly merging functions which; // are the same modulo constants and call targets.; //; // Note that different users of StructuralHash will want different behavior; // out of it (i.e., MergeFunctions will want something different from PM; // expensive checks for pass modification status). When modifying this; // function, most changes should be gated behind an option and enabled; // selectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp:99,Security,hash,hash,99,"// Walk the blocks in the same order as; // FunctionComparator::cmpBasicBlocks(), accumulating the hash of the; // function ""structure."" (BB and opcode sequence)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp:116,Security,hash,hash,116,"// This random value acts as a block header, as otherwise the partition of; // opcodes into BBs wouldn't affect the hash, only the order of the; // opcodes",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SymbolTableListTraitsImpl.h:510,Safety,avoid,avoid,510,"//===-- llvm/SymbolTableListTraitsImpl.h - Implementation ------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the stickier parts of the SymbolTableListTraits class,; // and is explicitly instantiated where needed to avoid defining all this code; // in a widely used header.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SymbolTableListTraitsImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SymbolTableListTraitsImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SymbolTableListTraitsImpl.h:19,Deployability,update,update,19,// We only have to update symbol table entries if we are transferring the; // instructions to a different symtab object...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SymbolTableListTraitsImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SymbolTableListTraitsImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SymbolTableListTraitsImpl.h:65,Deployability,update,update,65,"// Just transferring between blocks in the same function, simply update the; // parent fields in the instructions...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SymbolTableListTraitsImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SymbolTableListTraitsImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SymbolTableListTraitsImpl.h:58,Usability,simpl,simply,58,"// Just transferring between blocks in the same function, simply update the; // parent fields in the instructions...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/SymbolTableListTraitsImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SymbolTableListTraitsImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:9,Safety,safe,safe,9,// It is safe to assume that the scalar types have a fixed size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:249,Deployability,update,update,249,"// Since we only want to allocate a fresh function type in case none is found; // and we don't want to perform two lookups (one for checking if existent and; // one for inserting the newly allocated one), here we instead lookup based on; // Key and update the reference to the function type in-place to a newly; // allocated one if not found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:25,Energy Efficiency,allocate,allocate,25,"// Since we only want to allocate a fresh function type in case none is found; // and we don't want to perform two lookups (one for checking if existent and; // one for inserting the newly allocated one), here we instead lookup based on; // Key and update the reference to the function type in-place to a newly; // allocated one if not found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:189,Energy Efficiency,allocate,allocated,189,"// Since we only want to allocate a fresh function type in case none is found; // and we don't want to perform two lookups (one for checking if existent and; // one for inserting the newly allocated one), here we instead lookup based on; // Key and update the reference to the function type in-place to a newly; // allocated one if not found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:315,Energy Efficiency,allocate,allocated,315,"// Since we only want to allocate a fresh function type in case none is found; // and we don't want to perform two lookups (one for checking if existent and; // one for inserting the newly allocated one), here we instead lookup based on; // Key and update the reference to the function type in-place to a newly; // allocated one if not found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:103,Performance,perform,perform,103,"// Since we only want to allocate a fresh function type in case none is found; // and we don't want to perform two lookups (one for checking if existent and; // one for inserting the newly allocated one), here we instead lookup based on; // Key and update the reference to the function type in-place to a newly; // allocated one if not found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:53,Deployability,update,update,53,// The function type was not found. Allocate one and update FunctionTypes; // in-place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:36,Energy Efficiency,Allocate,Allocate,36,// The function type was not found. Allocate one and update FunctionTypes; // in-place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:247,Deployability,update,update,247,"// Since we only want to allocate a fresh struct type in case none is found; // and we don't want to perform two lookups (one for checking if existent and; // one for inserting the newly allocated one), here we instead lookup based on; // Key and update the reference to the struct type in-place to a newly; // allocated one if not found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:25,Energy Efficiency,allocate,allocate,25,"// Since we only want to allocate a fresh struct type in case none is found; // and we don't want to perform two lookups (one for checking if existent and; // one for inserting the newly allocated one), here we instead lookup based on; // Key and update the reference to the struct type in-place to a newly; // allocated one if not found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:187,Energy Efficiency,allocate,allocated,187,"// Since we only want to allocate a fresh struct type in case none is found; // and we don't want to perform two lookups (one for checking if existent and; // one for inserting the newly allocated one), here we instead lookup based on; // Key and update the reference to the struct type in-place to a newly; // allocated one if not found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:311,Energy Efficiency,allocate,allocated,311,"// Since we only want to allocate a fresh struct type in case none is found; // and we don't want to perform two lookups (one for checking if existent and; // one for inserting the newly allocated one), here we instead lookup based on; // Key and update the reference to the struct type in-place to a newly; // allocated one if not found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:101,Performance,perform,perform,101,"// Since we only want to allocate a fresh struct type in case none is found; // and we don't want to perform two lookups (one for checking if existent and; // one for inserting the newly allocated one), here we instead lookup based on; // Key and update the reference to the struct type in-place to a newly; // allocated one if not found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:51,Deployability,update,update,51,// The struct type was not found. Allocate one and update AnonStructTypes; // in-place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:34,Energy Efficiency,Allocate,Allocate,34,// The struct type was not found. Allocate one and update AnonStructTypes; // in-place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:125,Performance,scalab,scalable,125,"// For structures that are opaque, return false but do not set the; // SCDB_NotContainsScalableVector flag since it may gain scalable vector type; // when it becomes non-opaque.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:316,Performance,scalab,scalable,316,"// Okay, our struct is sized if all of the elements are, but if one of the; // elements is opaque, the struct isn't sized *yet*, but may become sized in; // the future, so just bail out without caching.; // The ONLY special case inside a struct that is considered sized is when the; // elements are homogeneous of a scalable vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:28,Performance,scalab,scalable,28,"// If the struct contains a scalable vector type, don't consider it sized.; // This prevents it from being used in loads/stores/allocas/GEPs. The ONLY; // special case right now is a structure of homogenous scalable vector; // types and is handled by the if-statement before this for-loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:115,Performance,load,loads,115,"// If the struct contains a scalable vector type, don't consider it sized.; // This prevents it from being used in loads/stores/allocas/GEPs. The ONLY; // special case right now is a structure of homogenous scalable vector; // types and is handled by the if-statement before this for-loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:207,Performance,scalab,scalable,207,"// If the struct contains a scalable vector type, don't consider it sized.; // This prevents it from being used in loads/stores/allocas/GEPs. The ONLY; // special case right now is a structure of homogenous scalable vector; // types and is handled by the if-statement before this for-loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:85,Performance,Scalab,ScalableVectorType,85,//===----------------------------------------------------------------------===//; // ScalableVectorType Implementation; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:247,Deployability,update,update,247,"// Since we only want to allocate a fresh target type in case none is found; // and we don't want to perform two lookups (one for checking if existent and; // one for inserting the newly allocated one), here we instead lookup based on; // Key and update the reference to the target type in-place to a newly; // allocated one if not found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:25,Energy Efficiency,allocate,allocate,25,"// Since we only want to allocate a fresh target type in case none is found; // and we don't want to perform two lookups (one for checking if existent and; // one for inserting the newly allocated one), here we instead lookup based on; // Key and update the reference to the target type in-place to a newly; // allocated one if not found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:187,Energy Efficiency,allocate,allocated,187,"// Since we only want to allocate a fresh target type in case none is found; // and we don't want to perform two lookups (one for checking if existent and; // one for inserting the newly allocated one), here we instead lookup based on; // Key and update the reference to the target type in-place to a newly; // allocated one if not found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:311,Energy Efficiency,allocate,allocated,311,"// Since we only want to allocate a fresh target type in case none is found; // and we don't want to perform two lookups (one for checking if existent and; // one for inserting the newly allocated one), here we instead lookup based on; // Key and update the reference to the target type in-place to a newly; // allocated one if not found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:101,Performance,perform,perform,101,"// Since we only want to allocate a fresh target type in case none is found; // and we don't want to perform two lookups (one for checking if existent and; // one for inserting the newly allocated one), here we instead lookup based on; // Key and update the reference to the target type in-place to a newly; // allocated one if not found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:51,Deployability,update,update,51,// The target type was not found. Allocate one and update TargetExtTypes; // in-place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:34,Energy Efficiency,Allocate,Allocate,34,// The target type was not found. Allocate one and update TargetExtTypes; // in-place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/TypeFinder.cpp:25,Modifiability,variab,variables,25,// Get types from global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/TypeFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/TypeFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/User.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the array of Uses,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/User.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/User.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/User.cpp:59,Energy Efficiency,allocate,allocated,59,// This is a private struct used by `User` to track the co-allocated descriptor; // section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/User.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/User.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/User.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate space for a single Use*,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/User.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/User.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/User.cpp:222,Security,sanitiz,sanitization,222,"//===----------------------------------------------------------------------===//; // User operator delete Implementation; //===----------------------------------------------------------------------===//; // Repress memory sanitization, due to use-after-destroy by operator; // delete. Bug report 24578 identifies this issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/User.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/User.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/User.cpp:91,Energy Efficiency,allocate,allocated,91,"// Hung off uses use a single Use* before the User, while other subclasses; // use a Use[] allocated prior to the user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/User.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/User.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:361,Availability,down,downcasts,361,"// Only in -g mode...; // Check to make sure that there are no uses of this value that are still; // around when the value is destroyed. If there are, then we have a dangling; // reference and something is wrong. This code is here to print out where; // the value is still being referenced.; //; // Note that use_empty() cannot be called here, as it eventually downcasts; // 'this' to GlobalValue (derived class of Value), but GlobalValue has already; // been destructed, so accessing it is UB.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:475,Security,access,accessing,475,"// Only in -g mode...; // Check to make sure that there are no uses of this value that are still; // around when the value is destroyed. If there are, then we have a dangling; // reference and something is wrong. This code is here to print out where; // the value is still being referenced.; //; // Note that use_empty() cannot be called here, as it eventually downcasts; // 'this' to GlobalValue (derived class of Value), but GlobalValue has already; // been destructed, so accessing it is UB.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:27,Deployability,update,update,27,// Get the symbol table to update for this object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:22,Deployability,update,update,22,// No symbol table to update? Just do the change.; // NOTE: Could optimize for the case the name is shrinking to not deallocate; // then reallocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:66,Performance,optimiz,optimize,66,// No symbol table to update? Just do the change.; // NOTE: Could optimize for the case the name is shrinking to not deallocate; // then reallocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:15,Performance,optimiz,optimize,15,// NOTE: Could optimize for the case the name is shrinking to not deallocate; // then reallocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:53,Usability,clear,clear,53,"// We can't set a name on this value, but we need to clear V's name if; // it has one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:3,Usability,Clear,Clear,3,// Clear V's name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:32,Deployability,update,updates,32,"// FIXME: handleOperandChange() updates all the uses in a given Constant,; // not just the one passed to ShouldReplace",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:89,Integrability,rout,routine,89,// Like replaceAllUsesWith except it does not handle constants or basic blocks.; // This routine leaves uses within BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:96,Safety,detect,detect,96,// External Analysis can return a result higher/lower than the value; // represents. We need to detect overflow/underflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:70,Energy Efficiency,allocate,allocated,70,"// Cases that can simply never be deallocated; // *) Constants aren't allocated per se, thus not deallocated either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:18,Usability,simpl,simply,18,"// Cases that can simply never be deallocated; // *) Constants aren't allocated per se, thus not deallocated either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:318,Energy Efficiency,allocate,allocated,318,"// A pointer to an object in a function which neither frees, nor can arrange; // for another thread to free on its behalf, can not be freed in the scope; // of the function. Note that this logic is restricted to memory; // allocations in existance before the call; a nofree function *is* allowed; // to free memory it allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:189,Testability,log,logic,189,"// A pointer to an object in a function which neither frees, nor can arrange; // for another thread to free on its behalf, can not be freed in the scope; // of the function. Note that this logic is restricted to memory; // allocations in existance before the call; a nofree function *is* allowed; // to free memory it allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:81,Safety,safe,safepoints,81,"// With garbage collection, deallocation typically occurs solely at or after; // safepoints. If we're compiling for a collector which uses the; // gc.statepoint infrastructure, safepoints aren't explicitly present; // in the IR until after lowering from abstract to physical machine model.; // The collector could chose to mix explicit deallocation and gc'd objects; // which is why we need the explicit opt in on a per collector basis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:177,Safety,safe,safepoints,177,"// With garbage collection, deallocation typically occurs solely at or after; // safepoints. If we're compiling for a collector which uses the; // gc.statepoint infrastructure, safepoints aren't explicitly present; // in the IR until after lowering from abstract to physical machine model.; // The collector could chose to mix explicit deallocation and gc'd objects; // which is why we need the explicit opt in on a per collector basis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:135,Modifiability,Rewrite,RewriteStatepointsForGC,135,"// For the sake of this example GC, we arbitrarily pick addrspace(1) as; // our GC managed heap. This must match the same check in; // RewriteStatepointsForGC (and probably needs better factored.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:26,Safety,avoid,avoid,26,"// Strip pointer casts to avoid creating unnecessary ptrtoint expression; // if the only ""reduction"" is combining a bitcast + ptrtoint.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:163,Modifiability,variab,variable,163,"// Right now we handle the case when Ptr1/Ptr2 are both GEPs with an identical; // base. After that base, they may have some number of common (and; // potentially variable) indices. After that they handle some constant; // offset, which determines their offset from each other. At this point, we; // handle no other case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:176,Testability,Assert,AssertingVH,176,// We use a local ValueHandleBase as an iterator so that ValueHandles can add; // and remove themselves from the list without breaking our iteration. This; // is not really an AssertingVH; we just have to give ValueHandleBase a kind.; // Note that we deliberately do not the support the case when dropping a value; // handle results in a new value handle being permanently added to the list; // (as might occur in theory for CallbackVH's): the new value handle will not; // be processed and the checking code will mete out righteous punishment if; // the handle is still present once we have finished processing all the other; // value handles (it is fine to momentarily add then remove a value handle).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:39,Testability,assert,assertingVHs,39,"// All callbacks, weak references, and assertingVHs should be dropped by now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:12,Testability,Assert,Asserts,12,// Only in +Asserts mode...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:176,Testability,Assert,AssertingVH,176,// We use a local ValueHandleBase as an iterator so that; // ValueHandles can add and remove themselves from the list without; // breaking our iteration. This is not really an AssertingVH; we; // just have to give ValueHandleBase some kind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:3,Testability,Assert,Asserting,3,// Asserting and Weak handles do not follow RAUW implicitly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ValueSymbolTable.cpp:56,Energy Efficiency,allocate,allocate,56,"// The name is too already used, just free it so we can allocate a new name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/ValueSymbolTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ValueSymbolTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VectorBuilder.cpp:562,Integrability,interface,interface,562,"//===- VectorBuilder.cpp - Builder for VP Intrinsics ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the VectorBuilder class, which is used as a convenient; // way to create VP intrinsics as if they were LLVM instructions with a; // consistent and simplified interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VectorBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VectorBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VectorBuilder.cpp:551,Usability,simpl,simplified,551,"//===- VectorBuilder.cpp - Builder for VP Intrinsics ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the VectorBuilder class, which is used as a convenient; // way to create VP intrinsics as if they were LLVM instructions with a; // consistent and simplified interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VectorBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VectorBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VectorBuilder.cpp:15,Availability,mask,mask,15,// Whether the mask and vlen parameter are at the end of the parameter list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VectorBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VectorBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VectorBuilder.cpp:26,Availability,mask,mask,26,"// Fast path for trailing mask, vector length.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VectorBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VectorBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VectorBuilder.cpp:10,Availability,mask,mask,10,// Insert mask and evl operands in between the instruction operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VectorBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VectorBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:423,Integrability,interface,interface,423,"//===-- Verifier.cpp - Implement the Module Verifier -----------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the function verifier interface, that can be used for some; // basic correctness checking of input to the system.; //; // Note that this does not provide full `Java style' security and verifications,; // instead it just tries to ensure that code is well-formed.; //; // * Both of a binary operator's parameters are of the same type; // * Verify that the indices of mem access instructions match other operands; // * Verify that arithmetic and other things are only performed on first-class; // types. Verify that shifts & logicals only happen on integrals f.e.; // * All of the constants in a switch statement are of the correct type; // * The code is in valid SSA form; // * It should be illegal to put a label into any other type (like a structure); // or to return one. [except constant arrays!]; // * Only phi nodes can be self referential: 'add i32 %0, %0 ; <int>:0' is bad; // * PHI nodes must have an entry for each predecessor, with no extras.; // * PHI nodes must be the first thing in a basic block, all grouped together; // * All basic blocks should only end with terminator insts, not contain them; // * The entry node to a function must not have predecessors; // * All Instructions must be embedded into a basic block; // * Functions cannot take a void-typed parameter; // * Verify that a function's argument list agrees with it's declared type.; // * It is illegal to specify a name for a void value.; // * It is illegal to have a internal global value with no initializer; // * It is illegal to have a ret instruction that returns a value that does not; // agree with the function retu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:866,Performance,perform,performed,866,"//===-- Verifier.cpp - Implement the Module Verifier -----------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the function verifier interface, that can be used for some; // basic correctness checking of input to the system.; //; // Note that this does not provide full `Java style' security and verifications,; // instead it just tries to ensure that code is well-formed.; //; // * Both of a binary operator's parameters are of the same type; // * Verify that the indices of mem access instructions match other operands; // * Verify that arithmetic and other things are only performed on first-class; // types. Verify that shifts & logicals only happen on integrals f.e.; // * All of the constants in a switch statement are of the correct type; // * The code is in valid SSA form; // * It should be illegal to put a label into any other type (like a structure); // or to return one. [except constant arrays!]; // * Only phi nodes can be self referential: 'add i32 %0, %0 ; <int>:0' is bad; // * PHI nodes must have an entry for each predecessor, with no extras.; // * PHI nodes must be the first thing in a basic block, all grouped together; // * All basic blocks should only end with terminator insts, not contain them; // * The entry node to a function must not have predecessors; // * All Instructions must be embedded into a basic block; // * Functions cannot take a void-typed parameter; // * Verify that a function's argument list agrees with it's declared type.; // * It is illegal to specify a name for a void value.; // * It is illegal to have a internal global value with no initializer; // * It is illegal to have a ret instruction that returns a value that does not; // agree with the function retu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:573,Security,secur,security,573,"//===-- Verifier.cpp - Implement the Module Verifier -----------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the function verifier interface, that can be used for some; // basic correctness checking of input to the system.; //; // Note that this does not provide full `Java style' security and verifications,; // instead it just tries to ensure that code is well-formed.; //; // * Both of a binary operator's parameters are of the same type; // * Verify that the indices of mem access instructions match other operands; // * Verify that arithmetic and other things are only performed on first-class; // types. Verify that shifts & logicals only happen on integrals f.e.; // * All of the constants in a switch statement are of the correct type; // * The code is in valid SSA form; // * It should be illegal to put a label into any other type (like a structure); // or to return one. [except constant arrays!]; // * Only phi nodes can be self referential: 'add i32 %0, %0 ; <int>:0' is bad; // * PHI nodes must have an entry for each predecessor, with no extras.; // * PHI nodes must be the first thing in a basic block, all grouped together; // * All basic blocks should only end with terminator insts, not contain them; // * The entry node to a function must not have predecessors; // * All Instructions must be embedded into a basic block; // * Functions cannot take a void-typed parameter; // * Verify that a function's argument list agrees with it's declared type.; // * It is illegal to specify a name for a void value.; // * It is illegal to have a internal global value with no initializer; // * It is illegal to have a ret instruction that returns a value that does not; // agree with the function retu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:770,Security,access,access,770,"//===-- Verifier.cpp - Implement the Module Verifier -----------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the function verifier interface, that can be used for some; // basic correctness checking of input to the system.; //; // Note that this does not provide full `Java style' security and verifications,; // instead it just tries to ensure that code is well-formed.; //; // * Both of a binary operator's parameters are of the same type; // * Verify that the indices of mem access instructions match other operands; // * Verify that arithmetic and other things are only performed on first-class; // types. Verify that shifts & logicals only happen on integrals f.e.; // * All of the constants in a switch statement are of the correct type; // * The code is in valid SSA form; // * It should be illegal to put a label into any other type (like a structure); // or to return one. [except constant arrays!]; // * Only phi nodes can be self referential: 'add i32 %0, %0 ; <int>:0' is bad; // * PHI nodes must have an entry for each predecessor, with no extras.; // * PHI nodes must be the first thing in a basic block, all grouped together; // * All basic blocks should only end with terminator insts, not contain them; // * The entry node to a function must not have predecessors; // * All Instructions must be embedded into a basic block; // * Functions cannot take a void-typed parameter; // * Verify that a function's argument list agrees with it's declared type.; // * It is illegal to specify a name for a void value.; // * It is illegal to have a internal global value with no initializer; // * It is illegal to have a ret instruction that returns a value that does not; // agree with the function retu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:923,Testability,log,logicals,923,"//===-- Verifier.cpp - Implement the Module Verifier -----------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the function verifier interface, that can be used for some; // basic correctness checking of input to the system.; //; // Note that this does not provide full `Java style' security and verifications,; // instead it just tries to ensure that code is well-formed.; //; // * Both of a binary operator's parameters are of the same type; // * Verify that the indices of mem access instructions match other operands; // * Verify that arithmetic and other things are only performed on first-class; // types. Verify that shifts & logicals only happen on integrals f.e.; // * All of the constants in a switch statement are of the correct type; // * The code is in valid SSA form; // * It should be illegal to put a label into any other type (like a structure); // or to return one. [except constant arrays!]; // * Only phi nodes can be self referential: 'add i32 %0, %0 ; <int>:0' is bad; // * PHI nodes must have an entry for each predecessor, with no extras.; // * PHI nodes must be the first thing in a basic block, all grouped together; // * All basic blocks should only end with terminator insts, not contain them; // * The entry node to a function must not have predecessors; // * All Instructions must be embedded into a basic block; // * Functions cannot take a void-typed parameter; // * Verify that a function's argument list agrees with it's declared type.; // * It is illegal to specify a name for a void value.; // * It is illegal to have a internal global value with no initializer; // * It is illegal to have a ret instruction that returns a value that does not; // agree with the function retu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:2786,Testability,test,tested,2786,"shifts & logicals only happen on integrals f.e.; // * All of the constants in a switch statement are of the correct type; // * The code is in valid SSA form; // * It should be illegal to put a label into any other type (like a structure); // or to return one. [except constant arrays!]; // * Only phi nodes can be self referential: 'add i32 %0, %0 ; <int>:0' is bad; // * PHI nodes must have an entry for each predecessor, with no extras.; // * PHI nodes must be the first thing in a basic block, all grouped together; // * All basic blocks should only end with terminator insts, not contain them; // * The entry node to a function must not have predecessors; // * All Instructions must be embedded into a basic block; // * Functions cannot take a void-typed parameter; // * Verify that a function's argument list agrees with it's declared type.; // * It is illegal to specify a name for a void value.; // * It is illegal to have a internal global value with no initializer; // * It is illegal to have a ret instruction that returns a value that does not; // agree with the function return value type.; // * Function call argument types match the function prototype; // * A landing pad is defined by a landingpad instruction, and can be jumped to; // only by the unwind edge of an invoke instruction.; // * A landingpad instruction must be the first non-PHI instruction in the; // block.; // * Landingpad instructions must be in a function with a personality function.; // * Convergence control intrinsics are introduced in ConvergentOperations.rst.; // The applied restrictions are too numerous to list here.; // * The convergence entry intrinsic and the loop heart must be the first; // non-PHI instruction in their respective block. This does not conflict with; // the landing pads, since these two kinds cannot occur in the same block.; // * All other things that are tested by asserts spread about the code...; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:2796,Testability,assert,asserts,2796,"shifts & logicals only happen on integrals f.e.; // * All of the constants in a switch statement are of the correct type; // * The code is in valid SSA form; // * It should be illegal to put a label into any other type (like a structure); // or to return one. [except constant arrays!]; // * Only phi nodes can be self referential: 'add i32 %0, %0 ; <int>:0' is bad; // * PHI nodes must have an entry for each predecessor, with no extras.; // * PHI nodes must be the first thing in a basic block, all grouped together; // * All basic blocks should only end with terminator insts, not contain them; // * The entry node to a function must not have predecessors; // * All Instructions must be embedded into a basic block; // * Functions cannot take a void-typed parameter; // * Verify that a function's argument list agrees with it's declared type.; // * It is illegal to specify a name for a void value.; // * It is illegal to have a internal global value with no initializer; // * It is illegal to have a ret instruction that returns a value that does not; // agree with the function return value type.; // * Function call argument types match the function prototype; // * A landing pad is defined by a landingpad instruction, and can be jumped to; // only by the unwind edge of an invoke instruction.; // * A landingpad instruction must be the first non-PHI instruction in the; // block.; // * Landingpad instructions must be in a function with a personality function.; // * Convergence control intrinsics are introduced in ConvergentOperations.rst.; // The applied restrictions are too numerous to list here.; // * The convergence entry intrinsic and the loop heart must be the first; // non-PHI instruction in their respective block. This does not conflict with; // the landing pads, since these two kinds cannot occur in the same block.; // * All other things that are tested by asserts spread about the code...; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:30,Availability,recover,recovered,30,"/// Broken debug info can be ""recovered"" from by stripping the debug info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:30,Safety,recover,recovered,30,"/// Broken debug info can be ""recovered"" from by stripping the debug info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:45,Availability,error,error,45,/// Whether to treat broken debug info as an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:58,Integrability,message,message,58,"/// A check failed, so printout out the condition and the message.; ///; /// This provides a nice place to put a breakpoint if you want to see why; /// something is not correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:68,Integrability,Message,Message-only,68,/// A check failed (with values to print).; ///; /// This calls the Message-only version so that the above is easier to set a; /// breakpoint on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:129,Energy Efficiency,efficient,efficient,129,"/// When verifying a basic block, keep track of all of the; /// instructions we have seen so far.; ///; /// This allows us to do efficient dominance checks for the case when an; /// instruction has an operand that is an instruction in the same block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:119,Safety,detect,detect,119,"// Maps catchswitches and cleanuppads that unwind to siblings to the; // terminators that indicate the unwind, used to detect cycles therein.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:4,Performance,Cache,Cache,4,"/// Cache which blocks are in which funclet, if an EH funclet personality is; /// in use. Otherwise empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:4,Performance,Cache,Cache,4,/// Cache of constants visited in search of ConstantExprs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:4,Performance,Cache,Cache,4,/// Cache of declarations of the llvm.experimental.deoptimize.<ty> intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:4,Performance,Cache,Cache,4,/// Cache of attribute lists verified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:85,Safety,avoid,avoid,85,"// Verify that this GlobalValue is only used in this module.; // This map is used to avoid visiting uses twice. We can arrive at a user; // twice, if they have multiple operands. In particular for very large; // constant expressions, we can arrive at a particular user many times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:76,Availability,recover,recover,76,"// Now that we've visited every function, verify that we never asked to; // recover a frame index that wasn't escaped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:76,Safety,recover,recover,76,"// Now that we've visited every function, verify that we never asked to; // recover a frame index that wasn't escaped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:82,Availability,error,error,82,"// end anonymous namespace; /// We know that cond should be true, if not print an error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:88,Integrability,message,message,88,"// end anonymous namespace; /// We know that cond should be true, if not print an error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:77,Availability,error,error,77,"/// We know that a debug info condition should be true, if not print; /// an error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:83,Integrability,message,message,83,"/// We know that a debug info condition should be true, if not print; /// an error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:33,Availability,error,error,33,"// Don't worry about emitting an error for it not being an array,; // visitGlobalValue will complain on appending non-array.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:37,Modifiability,variab,variables,37,"// Scalable vectors cannot be global variables, since we don't know; // the runtime size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:3,Performance,Scalab,Scalable,3,"// Scalable vectors cannot be global variables, since we don't know; // the runtime size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:130,Performance,optimiz,optimization,130,"// Only visit each node once. Metadata can be mutually recursive, so this; // avoids infinite recursion here, as well as being an optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:78,Safety,avoid,avoids,78,"// Only visit each node once. Metadata can be mutually recursive, so this; // avoids infinite recursion here, as well as being an optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:130,Performance,optimiz,optimization,130,"// Only visit each node once. Metadata can be mutually recursive, so this; // avoids infinite recursion here, as well as being an optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:78,Safety,avoid,avoids,78,"// Only visit each node once. Metadata can be mutually recursive, so this; // avoids infinite recursion here, as well as being an optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:4,Safety,Detect,Detect,4,/// Detect mutually exclusive flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:24,Modifiability,variab,variables,24,// Checks common to all variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:28,Modifiability,variab,variable,28,// Check only if the global variable is not an extern,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:24,Modifiability,variab,variables,24,// Checks common to all variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:3,Security,Validat,Validate,3,// Validate that the requirements in the module are valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:95,Deployability,upgrade,upgraded,95,"// If the llvm.linker.options named metadata exists, we assume that the; // bitcode reader has upgraded the module flag. Otherwise the flag might; // have been created by a client directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:138,Availability,error,error,138,// VerifyParameterAttrs - Check the given attributes for an argument or return; // value of the specified type. The value V is printed in error messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:144,Integrability,message,messages,144,// VerifyParameterAttrs - Check the given attributes for an argument or return; // value of the specified type. The value V is printed in error messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:85,Availability,error,error,85,// Check parameter attributes against a function type.; // The value V is printed in error messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:91,Integrability,message,messages,91,// Check parameter attributes against a function type.; // The value V is printed in error messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:83,Integrability,wrap,wrapped,83,// Verify that the types of the call parameter arguments match; // the type of the wrapped callee.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:363,Performance,optimiz,optimizations,363,"// Note: It is legal for a single derived pointer to be listed multiple; // times. It's non-optimal, but it is legal. It can also happen after; // insertion if we strip a bitcast away.; // Note: It is really tempting to check that each base is relocated and; // that a derived pointer is never reused as a base pointer. This turns; // out to be problematic since optimizations run after safepoint insertion; // can recognize equality properties that the insertion logic doesn't know; // about. See example statepoint.ll in the verifier subdirectory",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:387,Safety,safe,safepoint,387,"// Note: It is legal for a single derived pointer to be listed multiple; // times. It's non-optimal, but it is legal. It can also happen after; // insertion if we strip a bitcast away.; // Note: It is really tempting to check that each base is relocated and; // that a derived pointer is never reused as a base pointer. This turns; // out to be problematic since optimizations run after safepoint insertion; // can recognize equality properties that the insertion logic doesn't know; // about. See example statepoint.ll in the verifier subdirectory",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:464,Testability,log,logic,464,"// Note: It is legal for a single derived pointer to be listed multiple; // times. It's non-optimal, but it is legal. It can also happen after; // insertion if we strip a bitcast away.; // Note: It is really tempting to check that each base is relocated and; // that a derived pointer is never reused as a base pointer. This turns; // out to be problematic since optimizations run after safepoint insertion; // can recognize equality properties that the insertion logic doesn't know; // about. See example statepoint.ll in the verifier subdirectory",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:25,Availability,error,error,25,// Found a cycle; report error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:50,Performance,load,loads,50,// Check that swifterror argument is only used by loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:71,Security,validat,validation,71,// Scope and SP could be the same MDNode and we don't want to skip; // validation in that case,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:77,Availability,error,errors,77,"// Configure the validate function to not fire assertions, instead print; // errors and return true if there's a problem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:3,Modifiability,Config,Configure,3,"// Configure the validate function to not fire assertions, instead print; // errors and return true if there's a problem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:17,Security,validat,validate,17,"// Configure the validate function to not fire assertions, instead print; // errors and return true if there's a problem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:47,Testability,assert,assertions,47,"// Configure the validate function to not fire assertions, instead print; // errors and return true if there's a problem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:115,Availability,error,error,115,"/// visitUserOp1 - User defined operators shouldn't live beyond the lifetime of; /// a pass, if any exist, it's an error.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:95,Testability,test,tested,95,"// Ensure that the PHI nodes are all grouped together at the top of the block.; // This can be tested by checking whether the instruction before this is; // either nonexistent (because this is begin()) or is a PHI node. If not,; // then there is some other instruction before a PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:42,Integrability,wrap,wrapped,42,// Statepoint intrinsic is vararg but the wrapped function may be not.; // Allow sret here and check the wrapped function in verifyStatepoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:105,Integrability,wrap,wrapped,105,// Statepoint intrinsic is vararg but the wrapped function may be not.; // Allow sret here and check the wrapped function in verifyStatepoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:146,Availability,Failure,Failure,146,"// Verify that each inlinable callsite of a debug-info-bearing function in a; // debug-info-bearing function has a debug location attached to it. Failure to; // do so causes assertion failures when the inliner sets up inline scope info; // (Interposable functions are not inlinable, neither are functions without; // definitions.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:184,Availability,failure,failures,184,"// Verify that each inlinable callsite of a debug-info-bearing function in a; // debug-info-bearing function has a debug location attached to it. Failure to; // do so causes assertion failures when the inliner sets up inline scope info; // (Interposable functions are not inlinable, neither are functions without; // definitions.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:174,Testability,assert,assertion,174,"// Verify that each inlinable callsite of a debug-info-bearing function in a; // debug-info-bearing function has a debug location attached to it. Failure to; // do so causes assertion failures when the inliner sets up inline scope info; // (Interposable functions are not inlinable, neither are functions without; // definitions.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:14,Testability,log,logical,14,// Check that logical operators are only used with integral operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:105,Availability,toler,tolerates,105,// ConstantRange asserts if the ranges are the same except for the min/max; // value. Leave the cases it tolerates for the empty range error below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:135,Availability,error,error,135,// ConstantRange asserts if the ranges are the same except for the min/max; // value. Leave the cases it tolerates for the empty range error below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:17,Testability,assert,asserts,17,// ConstantRange asserts if the ranges are the same except for the min/max; // value. Leave the cases it tolerates for the empty range error below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:47,Performance,load,loads,47,"// Check that swifterror value is only used by loads, stores, or as; // a swifterror argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:172,Usability,Simpl,SimplifyCFGOpt,172,"// We allow catchswitch unwind to caller to nest; // within an outer pad that unwinds somewhere else,; // because catchswitch doesn't have a nounwind variant.; // See e.g. SimplifyCFGOpt::SimplifyUnreachable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:188,Usability,Simpl,SimplifyUnreachable,188,"// We allow catchswitch unwind to caller to nest; // within an outer pad that unwinds somewhere else,; // because catchswitch doesn't have a nounwind variant.; // See e.g. SimplifyCFGOpt::SimplifyUnreachable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:288,Integrability,wrap,wrapping,288,"// Quick check whether the def has already been encountered in the same block.; // PHI nodes are not checked to prevent accepting preceding PHIs, because PHI; // uses are defined to happen on the incoming edge, not at the instruction.; //; // FIXME: If this operand is a MetadataAsValue (wrapping a LocalAsMetadata); // wrapping an SSA value, assert that we've already encountered it. See; // related FIXME in Mapper::mapLocalAsMetadata in ValueMapper.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:320,Integrability,wrap,wrapping,320,"// Quick check whether the def has already been encountered in the same block.; // PHI nodes are not checked to prevent accepting preceding PHIs, because PHI; // uses are defined to happen on the incoming edge, not at the instruction.; //; // FIXME: If this operand is a MetadataAsValue (wrapping a LocalAsMetadata); // wrapping an SSA value, assert that we've already encountered it. See; // related FIXME in Mapper::mapLocalAsMetadata in ValueMapper.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:343,Testability,assert,assert,343,"// Quick check whether the def has already been encountered in the same block.; // PHI nodes are not checked to prevent accepting preceding PHIs, because PHI; // uses are defined to happen on the incoming edge, not at the instruction.; //; // FIXME: If this operand is a MetadataAsValue (wrapping a LocalAsMetadata); // wrapping an SSA value, assert that we've already encountered it. See; // related FIXME in Mapper::mapLocalAsMetadata in ValueMapper.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:95,Security,hash,hash,95,// Call stack metadata should consist of a list of at least 1 constant int; // (representing a hash of the location).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:24,Security,access,access,24,// It must be either an access scope itself...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:19,Security,access,access,19,// ...or a list of access scopes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:166,Availability,error,error,166,"// Check that all uses of the instruction, if they are instructions; // themselves, actually have parent basic blocks. If the use is not an; // instruction, it is an error!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:34,Integrability,wrap,wrapped,34,// Check that result type matches wrapped callee.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:55,Safety,safe,safepoint,55,// Both the base and derived must be piped through the safepoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:113,Energy Efficiency,reduce,reduced,113,"// Unlike the other reductions, the first argument is a start value. The; // second argument is the vector to be reduced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:89,Performance,scalab,scalable,89,"// If this insertion is not the 'mixed' case where a fixed vector is; // inserted into a scalable vector, ensure that the insertion of the; // subvector does not overrun the parent vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:91,Performance,scalab,scalable,91,"// If this extraction is not the 'mixed' case where a fixed vector is; // extracted from a scalable vector, ensure that the extraction does not; // overrun the parent vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:41,Performance,cache,cache,41,// Run EH funclet coloring on-demand and cache results for other intrinsic; // calls in this function,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:120,Safety,avoid,avoiding,120,"/// Carefully grab the subprogram from a local scope.; ///; /// This carefully grabs the subprogram from a local scope, avoiding the; /// built-in assertions that would typically fire.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:147,Testability,assert,assertions,147,"/// Carefully grab the subprogram from a local scope.; ///; /// This carefully grabs the subprogram from a local scope, avoiding the; /// built-in assertions that would typically fire.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:72,Availability,error,error,72,"// If a non-metadata argument is passed in a metadata slot then the; // error will be caught earlier when the incorrect argument doesn't; // match the specification in the intrinsic call table. Thus, no; // argument type check is needed here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:18,Modifiability,variab,variables,18,// The scopes for variables and !dbg attachments must agree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:17,Availability,redundant,redundant,17,// This check is redundant with one in visitLocalVariable().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:17,Safety,redund,redundant,17,// This check is redundant with one in visitLocalVariable().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:18,Modifiability,variab,variables,18,// The scopes for variables and !dbg attachments must agree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:104,Modifiability,variab,variables,104,"// The frontend helps out GDB by emitting the members of local anonymous; // unions as artificial local variables with shared storage. When SROA splits; // the storage for artificial local variables that are smaller than the entire; // union, the overhang piece will be outside of the allotted space for the; // variable and this check fails.; // FIXME: Remove this check as soon as clang stops doing this; it hides bugs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:189,Modifiability,variab,variables,189,"// The frontend helps out GDB by emitting the members of local anonymous; // unions as artificial local variables with shared storage. When SROA splits; // the storage for artificial local variables that are smaller than the entire; // union, the overhang piece will be outside of the allotted space for the; // variable and this check fails.; // FIXME: Remove this check as soon as clang stops doing this; it hides bugs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:312,Modifiability,variab,variable,312,"// The frontend helps out GDB by emitting the members of local anonymous; // unions as artificial local variables with shared storage. When SROA splits; // the storage for artificial local variables that are smaller than the entire; // union, the overhang piece will be outside of the allotted space for the; // variable and this check fails.; // FIXME: Remove this check as soon as clang stops doing this; it hides bugs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:7,Performance,perform,performance,7,// For performance reasons only check non-inlined ones.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:106,Testability,assert,assertions,106,// Verify there are no duplicate function argument debug info entries.; // These will cause hard-to-debug assertions in the DWARF backend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:80,Energy Efficiency,adapt,adapted,80,// Only check the domination rule when requested. Once all passes have been; // adapted this option can go away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:80,Modifiability,adapt,adapted,80,// Only check the domination rule when requested. Once all passes have been; // adapted this option can go away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:131,Availability,error,error,131,// We are sorting on MDNode pointers here. For valid input IR this is ok.; // TODO: Sort on Metadata ID to avoid non-deterministic error messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:137,Integrability,message,messages,137,// We are sorting on MDNode pointers here. For valid input IR this is ok.; // TODO: Sort on Metadata ID to avoid non-deterministic error messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:107,Safety,avoid,avoid,107,// We are sorting on MDNode pointers here. For valid input IR this is ok.; // TODO: Sort on Metadata ID to avoid non-deterministic error messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:106,Integrability,interface,interfaces,106,//===----------------------------------------------------------------------===//; // Implement the public interfaces to this file...; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:48,Availability,failure,failure,48,// end anonymous namespace; /// Helper to issue failure from the TBAA verification,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:28,Security,access,accessed,28,// Scalar nodes can only be accessed at offset 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:67,Deployability,Update,Update,67,/// Returns the field node at the offset \p Offset in \p BaseNode. Update \p; /// Offset in place to be the offset within the field node returned.; ///; /// We assume we've okayed \p BaseNode via \c verifyTBAABaseNode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:70,Security,access,access,70,"// Scalar nodes have only one possible ""field"" -- their parent in the access; // hierarchy. Offset must be zero at this point, but our caller is supposed; // to check that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:13,Security,access,access,13,// Check the access size field.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:81,Availability,error,errors,81,"// If the base node is invalid in itself, then we've already printed all the; // errors we wanted to print.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:10,Availability,error,error,10,// Syntax error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:19,Availability,mask,mask,19,"/// Extracts the `<mask>` information from the mangled string, and; /// sets `IsMasked` accordingly. If successful, the <mask> token is removed; /// from the input string `MangledName`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:121,Availability,mask,mask,121,"/// Extracts the `<mask>` information from the mangled string, and; /// sets `IsMasked` accordingly. If successful, the <mask> token is removed; /// from the input string `MangledName`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:149,Performance,scalab,scalable,149,"/// Extract the `<vlen>` information from the mangled string, and; /// sets `ParsedVF` accordingly. A `<vlen> == ""x""` token is interpreted as a; /// scalable vector length and the boolean is set to true, otherwise a nonzero; /// unsigned integer will be directly used as a VF. On success, the `<vlen>`; /// token is removed from the input string `ParseString`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:19,Performance,scalab,scalable,19,// SVE is the only scalable ISA currently supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:34,Performance,scalab,scalable,34,"// We can't determine the VF of a scalable vector by looking at the vlen; // string (just 'x'), so say we successfully parsed it but return a 'true'; // for the scalable field with an invalid VF field so that we know to look; // up the actual VF based on element types from the parameters or return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:161,Performance,scalab,scalable,161,"// We can't determine the VF of a scalable vector by looking at the vlen; // string (just 'x'), so say we successfully parsed it but return a 'true'; // for the scalable field with an invalid VF field so that we know to look; // up the actual VF based on element types from the parameters or return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:319,Availability,error,error,319,"/// The function looks for the following strings at the beginning of; /// the input string `ParseString`:; ///; /// <token> <number>; ///; /// On success, it removes the parsed parameter from `ParseString`,; /// sets `PKind` to the correspondent enum value, sets `Pos` to; /// <number>, and return success. On a syntax error, it return a; /// parsing error. If nothing is parsed, it returns std::nullopt.; ///; /// The function expects <token> to be one of ""ls"", ""Rs"", ""Us"" or; /// ""Ls"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:351,Availability,error,error,351,"/// The function looks for the following strings at the beginning of; /// the input string `ParseString`:; ///; /// <token> <number>; ///; /// On success, it removes the parsed parameter from `ParseString`,; /// sets `PKind` to the correspondent enum value, sets `Pos` to; /// <number>, and return success. On a syntax error, it return a; /// parsing error. If nothing is parsed, it returns std::nullopt.; ///; /// The function expects <token> to be one of ""ls"", ""Rs"", ""Us"" or; /// ""Ls"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:378,Availability,error,error,378,"/// The function looks for the following string at the beginning of; /// the input string `ParseString`:; ///; /// <token> <number>; ///; /// <token> is one of ""ls"", ""Rs"", ""Us"" or ""Ls"".; ///; /// On success, it removes the parsed parameter from `ParseString`,; /// sets `PKind` to the correspondent enum value, sets `StepOrPos` to; /// <number>, and return success. On a syntax error, it return a; /// parsing error. If nothing is parsed, it returns std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:410,Availability,error,error,410,"/// The function looks for the following string at the beginning of; /// the input string `ParseString`:; ///; /// <token> <number>; ///; /// <token> is one of ""ls"", ""Rs"", ""Us"" or ""Ls"".; ///; /// On success, it removes the parsed parameter from `ParseString`,; /// sets `PKind` to the correspondent enum value, sets `StepOrPos` to; /// <number>, and return success. On a syntax error, it return a; /// parsing error. If nothing is parsed, it returns std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:332,Availability,error,error,332,"/// The function looks for the following strings at the beginning of; /// the input string `ParseString`:; ///; /// <token> {""n""} <number>; ///; /// On success, it removes the parsed parameter from `ParseString`,; /// sets `PKind` to the correspondent enum value, sets `LinearStep` to; /// <number>, and return success. On a syntax error, it return a; /// parsing error. If nothing is parsed, it returns std::nullopt.; ///; /// The function expects <token> to be one of ""l"", ""R"", ""U"" or; /// ""L"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:364,Availability,error,error,364,"/// The function looks for the following strings at the beginning of; /// the input string `ParseString`:; ///; /// <token> {""n""} <number>; ///; /// On success, it removes the parsed parameter from `ParseString`,; /// sets `PKind` to the correspondent enum value, sets `LinearStep` to; /// <number>, and return success. On a syntax error, it return a; /// parsing error. If nothing is parsed, it returns std::nullopt.; ///; /// The function expects <token> to be one of ""l"", ""R"", ""U"" or; /// ""L"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:348,Availability,error,error,348,"/// The function looks for the following strings at the beginning of; /// the input string `ParseString`:; ///; /// [""l"" | ""R"" | ""U"" | ""L""] {""n""} <number>; ///; /// On success, it removes the parsed parameter from `ParseString`,; /// sets `PKind` to the correspondent enum value, sets `LinearStep` to; /// <number>, and return success. On a syntax error, it return a; /// parsing error. If nothing is parsed, it returns std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:380,Availability,error,error,380,"/// The function looks for the following strings at the beginning of; /// the input string `ParseString`:; ///; /// [""l"" | ""R"" | ""U"" | ""L""] {""n""} <number>; ///; /// On success, it removes the parsed parameter from `ParseString`,; /// sets `PKind` to the correspondent enum value, sets `LinearStep` to; /// <number>, and return success. On a syntax error, it return a; /// parsing error. If nothing is parsed, it returns std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:336,Availability,error,error,336,"/// Looks into the <parameters> part of the mangled name in search; /// for valid paramaters at the beginning of the string; /// `ParseString`.; ///; /// On success, it removes the parsed parameter from `ParseString`,; /// sets `PKind` to the correspondent enum value, sets `StepOrPos`; /// accordingly, and return success. On a syntax error, it return a; /// parsing error. If nothing is parsed, it returns std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:368,Availability,error,error,368,"/// Looks into the <parameters> part of the mangled name in search; /// for valid paramaters at the beginning of the string; /// `ParseString`.; ///; /// On success, it removes the parsed parameter from `ParseString`,; /// sets `PKind` to the correspondent enum value, sets `StepOrPos`; /// accordingly, and return success. On a syntax error, it return a; /// parsing error. If nothing is parsed, it returns std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:380,Availability,error,error,380,"/// Looks into the <parameters> part of the mangled name in search; /// of a valid 'aligned' clause. The function should be invoked; /// after parsing a parameter via `tryParseParameter`.; ///; /// On success, it removes the parsed parameter from `ParseString`,; /// sets `PKind` to the correspondent enum value, sets `StepOrPos`; /// accordingly, and return success. On a syntax error, it return a; /// parsing error. If nothing is parsed, it returns std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:412,Availability,error,error,412,"/// Looks into the <parameters> part of the mangled name in search; /// of a valid 'aligned' clause. The function should be invoked; /// after parsing a parameter via `tryParseParameter`.; ///; /// On success, it removes the parsed parameter from `ParseString`,; /// sets `PKind` to the correspondent enum value, sets `StepOrPos`; /// accordingly, and return success. On a syntax error, it return a; /// parsing error. If nothing is parsed, it returns std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:136,Performance,scalab,scalable,136,"// Returns the 'natural' VF for a given scalar element type, based on the; // current architecture.; //; // For SVE (currently the only scalable architecture with a defined name; // mangling), we assume a minimum vector size of 128b and return a VF based on; // the number of elements of the given type which would fit in such a vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:55,Availability,mask,mask,55,// namespace; // Format of the ABI name:; // _ZGV<isa><mask><vlen><parameters>_<scalarname>[(<redirection>)],MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:109,Availability,mask,mask,109,"// Assume there is no custom name <redirection>, and therefore the; // vector name consists of; // _ZGV<isa><mask><vlen><parameters>_<scalarname>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:12,Availability,mask,mask,12,// Extract <mask>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:13,Modifiability,variab,variable,13,"// Parse the variable size, starting from <vlen>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:34,Availability,error,error,34,// Bail off if there is a parsing error in the parsing of the parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:33,Availability,error,error,33,// Bail off if there is a syntax error in the align token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:245,Performance,scalab,scalable,245,"// Figure out the number of lanes in vectors for this function variant. This; // is easy for fixed length, as the vlen encoding just gives us the value; // directly. However, if the vlen mangling indicated that this function; // variant expects scalable vectors we need to work it out based on the; // demangled parameter types and the scalar function signature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce MangledName to [(<redirection>)].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:3,Deployability,Update,Update,3,// Update the vector variant with the one specified by the user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:9,Availability,mask,mask,9,"// When <mask> is ""M"", we need to add a parameter that is used as; // global predicate for the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:3,Testability,Assert,Asserts,3,"// Asserts for parameters of type `VFParamKind::GlobalPredicate`, as; // prescribed by the Vector Function ABI specifications supported by; // this parser:; // 1. Uniqueness.; // 2. Must be the last in the parameter list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LineEditor/LineEditor.cpp:44,Usability,simpl,simply,44,"// If the common prefix is non-empty we can simply insert it. If there is a; // single completion, this will insert the full completion. If there is more; // than one, this might be enough information to jog the user's memory but if; // not the user can also hit tab again to see the completions because the; // common prefix will then be empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LineEditor/LineEditor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LineEditor/LineEditor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LineEditor/LineEditor.cpp:20,Usability,Simpl,Simple,20,// HAVE_LIBEDIT; // Simple fgets-based implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LineEditor/LineEditor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LineEditor/LineEditor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:62,Deployability,rolling,rolling,62,"// Oops, they aren't isomorphic. Just discard this request by rolling out; // any speculative mappings we've established.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:173,Performance,load,load,173,"// SrcTy and DstTy are recursively ismorphic. We clear names of SrcTy; // and all its descendants to lower amount of renaming in LLVM context; // Renaming occurs because we load all source modules to the same context; // and declaration with existing name gets renamed (i.e Foo -> Foo.42).; // As a result we may get several different types in the destination; // module, which are in fact the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:49,Usability,clear,clear,49,"// SrcTy and DstTy are recursively ismorphic. We clear names of SrcTy; // and all its descendants to lower amount of renaming in LLVM context; // Renaming occurs because we load all source modules to the same context; // and declaration with existing name gets renamed (i.e Foo -> Foo.42).; // As a result we may get several different types in the destination; // module, which are in fact the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:38,Usability,clear,clearly,38,// Two types with differing kinds are clearly not isomorphic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:27,Usability,clear,clearly,27,// Two identical types are clearly isomorphic. Remember this; // non-speculatively.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:109,Usability,usab,usable,109,"// If all of the element types mapped directly over and the type is not; // a named struct, then the type is usable as-is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:99,Performance,perform,performed,99,/// Set of globals with eagerly copied metadata that may require remapping.; /// This remapping is performed after metadata linking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:8,Availability,Error,Error,8,/// The Error encountered during materialization. We use an Optional here to; /// avoid needing to manage an unconsumed success value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:82,Safety,avoid,avoid,82,/// The Error encountered during materialization. We use an Optional here to; /// avoid needing to manage an unconsumed success value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:16,Availability,error,errors,16,/// Most of the errors produced by this module are inconvertible StringErrors.; /// This convenience function lets us return one of those more easily.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:4,Performance,Perform,Perform,4,"/// Perform ""replace all uses with"" operations. These work items need to be; /// performed as part of materialization, but we postpone them to happen after; /// materialization is done. The materializer called by ValueMapper is not; /// expected to delete constants, as ValueMapper is holding pointers to some; /// of them, but constant destruction may be indirectly triggered by RAUW.; /// Hence, the need to move this out of the materialization call chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:81,Performance,perform,performed,81,"/// Perform ""replace all uses with"" operations. These work items need to be; /// performed as part of materialization, but we postpone them to happen after; /// materialization is done. The materializer called by ValueMapper is not; /// expected to delete constants, as ValueMapper is holding pointers to some; /// of them, but constant destruction may be indirectly triggered by RAUW.; /// Hence, the need to move this out of the materialization call chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:4,Deployability,Update,Update,4,/// Update attributes while linking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:86,Energy Efficiency,schedul,scheduled,86,"// If the global is being linked for an indirect symbol, it may have already; // been scheduled to satisfy a regular symbol. Similarly, a global being linked; // for a regular symbol may have already been scheduled for an indirect; // symbol. Check for these cases by looking in the other value map and; // confirming the same value has been scheduled. If there is an entry in the; // ValueMap but the value is different, it means that the value already had a; // definition in the destination module (linkonce for instance), but we need a; // new definition for the indirect symbol (""New"" will be different).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:205,Energy Efficiency,schedul,scheduled,205,"// If the global is being linked for an indirect symbol, it may have already; // been scheduled to satisfy a regular symbol. Similarly, a global being linked; // for a regular symbol may have already been scheduled for an indirect; // symbol. Check for these cases by looking in the other value map and; // confirming the same value has been scheduled. If there is an entry in the; // ValueMap but the value is different, it means that the value already had a; // definition in the destination module (linkonce for instance), but we need a; // new definition for the indirect symbol (""New"" will be different).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:342,Energy Efficiency,schedul,scheduled,342,"// If the global is being linked for an indirect symbol, it may have already; // been scheduled to satisfy a regular symbol. Similarly, a global being linked; // for a regular symbol may have already been scheduled for an indirect; // symbol. Check for these cases by looking in the other value map and; // confirming the same value has been scheduled. If there is an entry in the; // ValueMap but the value is different, it means that the value already had a; // definition in the destination module (linkonce for instance), but we need a; // new definition for the indirect symbol (""New"" will be different).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:28,Modifiability,variab,variables,28,/// Loop through the global variables in the src module and merge them into the; /// dest module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:20,Performance,perform,performed,20,// No linking to be performed or linking from the source: simply create an; // identical version of the symbol over in the dest module... the; // initializer will be filled in later by LinkGlobalInits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:58,Usability,simpl,simply,58,// No linking to be performed or linking from the source: simply create an; // identical version of the symbol over in the dest module... the; // initializer will be filled in later by LinkGlobalInits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:32,Performance,perform,performed,32,"// If there is no linkage to be performed or we are linking from the source,; // bring SF over.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:32,Performance,perform,performed,32,"// If there is no linkage to be performed or we're linking from the source,; // bring over SGA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:23,Modifiability,variab,variables,23,// Metadata for global variables and function declarations is copied eagerly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:212,Performance,load,loaded,212,"/// Loop over all of the linked values to compute type mappings. For example,; /// if we link ""extern Foo *x"" and ""Foo *x = NULL"", then we have two struct; /// types 'Foo' but one got renamed when the module was loaded into the same; /// LLVMContext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:194,Performance,load,loaded,194,"// Incorporate types by name, scanning all the types in the source module.; // At this point, the destination module may have a type ""%foo = { i32 }"" for; // example. When the source module got loaded into the same LLVMContext, if; // it had the same type, it would have been renamed to ""%foo.42 = { i32 }"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:762,Modifiability,variab,variables,762,"// Don't use it if this actually came from the source module. They're in; // the same LLVMContext after all. Also don't use it unless the type is; // actually used in the destination module. This can happen in situations; // like this:; //; // Module A Module B; // -------- --------; // %Z = type { %A } %B = type { %C.1 }; // %A = type { %B.1, [7 x i8] } %C.1 = type { i8* }; // %B.1 = type { %C } %A.2 = type { %B.3, [5 x i8] }; // %C = type { i8* } %B.3 = type { %C.1 }; //; // When we link Module B with Module A, the '%B' in Module B is; // used. However, that would then use '%C.1'. But when we process '%C.1',; // we prefer to take the '%C' version. So we are then left with both; // '%C.1' and '%C' being used for the same types. This leads to some; // variables using one type and some using the other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:39,Modifiability,variab,variables,39,"/// If there were any appending global variables, link them together now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:19,Modifiability,variab,variables,19,// Check that both variables have compatible properties.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:15,Deployability,upgrade,upgrade,15,"// FIXME: This upgrade is done during linking to support the C API. Once the; // old form is deprecated, we should move this upgrade to; // llvm::UpgradeGlobalVariable() and simplify the logic here and in; // Mapper::mapAppendingVariable() in ValueMapper.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:125,Deployability,upgrade,upgrade,125,"// FIXME: This upgrade is done during linking to support the C API. Once the; // old form is deprecated, we should move this upgrade to; // llvm::UpgradeGlobalVariable() and simplify the logic here and in; // Mapper::mapAppendingVariable() in ValueMapper.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:146,Deployability,Upgrade,UpgradeGlobalVariable,146,"// FIXME: This upgrade is done during linking to support the C API. Once the; // old form is deprecated, we should move this upgrade to; // llvm::UpgradeGlobalVariable() and simplify the logic here and in; // Mapper::mapAppendingVariable() in ValueMapper.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:187,Testability,log,logic,187,"// FIXME: This upgrade is done during linking to support the C API. Once the; // old form is deprecated, we should move this upgrade to; // llvm::UpgradeGlobalVariable() and simplify the logic here and in; // Mapper::mapAppendingVariable() in ValueMapper.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:174,Usability,simpl,simplify,174,"// FIXME: This upgrade is done during linking to support the C API. Once the; // old form is deprecated, we should move this upgrade to; // llvm::UpgradeGlobalVariable() and simplify the logic here and in; // Mapper::mapAppendingVariable() in ValueMapper.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:25,Modifiability,variab,variable,25,// Create the new global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:38,Modifiability,variab,variables,38,// Replace any uses of the two global variables with uses of the new; // global.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:59,Performance,perform,performing,59,"// If we are done linking global value bodies (i.e. we are performing; // metadata linking), don't link in the global value due to this; // reference, simply map it to null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:151,Usability,simpl,simply,151,"// If we are done linking global value bodies (i.e. we are performing; // metadata linking), don't link in the global value due to this; // reference, simply map it to null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:151,Testability,assert,assertion,151,// Note: remangleIntrinsicFunction does not copy metadata and as such; // F should not occur in the set of objects with unmapped metadata.; // If this assertion fails then remangleIntrinsicFunction needs updating.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:256,Testability,assert,assert,256,"// Only create a bitcast if necessary. In particular, with; // DebugTypeODRUniquing we may reach metadata in the destination module; // containing a GV from the source module, in which case SGV will be; // the same as DGV and NewGV, and TypeMap.get() will assert since it; // assumes it is being invoked on a type in the source module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:3,Energy Efficiency,Schedul,Schedule,3,"// Schedule ""replace all uses with"" to happen after materializing is; // done. It is not safe to do it now, since ValueMapper may be holding; // pointers to constants that will get deleted if RAUW runs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:89,Safety,safe,safe,89,"// Schedule ""replace all uses with"" to happen after materializing is; // done. It is not safe to do it now, since ValueMapper may be holding; // pointers to constants that will get deleted if RAUW runs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:4,Deployability,Update,Update,4,/// Update the initializers in the Dest module now that all globals that may be; /// referenced are in Dest.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:64,Modifiability,variab,variable,64,"// The original definition (or at least its debug info - if the variable is; // internalized and optimized away) will remain in the source module, so; // there's no need to import them.; // If LLVM ever does more advanced optimizations on global variables; // (removing/localizing write operations, for instance) that can track; // through debug info, this decision may need to be revisited - but do so; // with care when it comes to debug info size. Emitting small CUs containing; // only a few imported entities into every destination module may be very; // size inefficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:246,Modifiability,variab,variables,246,"// The original definition (or at least its debug info - if the variable is; // internalized and optimized away) will remain in the source module, so; // there's no need to import them.; // If LLVM ever does more advanced optimizations on global variables; // (removing/localizing write operations, for instance) that can track; // through debug info, this decision may need to be revisited - but do so; // with care when it comes to debug info size. Emitting small CUs containing; // only a few imported entities into every destination module may be very; // size inefficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:97,Performance,optimiz,optimized,97,"// The original definition (or at least its debug info - if the variable is; // internalized and optimized away) will remain in the source module, so; // there's no need to import them.; // If LLVM ever does more advanced optimizations on global variables; // (removing/localizing write operations, for instance) that can track; // through debug info, this decision may need to be revisited - but do so; // with care when it comes to debug info size. Emitting small CUs containing; // only a few imported entities into every destination module may be very; // size inefficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:222,Performance,optimiz,optimizations,222,"// The original definition (or at least its debug info - if the variable is; // internalized and optimized away) will remain in the source module, so; // there's no need to import them.; // If LLVM ever does more advanced optimizations on global variables; // (removing/localizing write operations, for instance) that can track; // through debug info, this decision may need to be revisited - but do so; // with care when it comes to debug info size. Emitting small CUs containing; // only a few imported entities into every destination module may be very; // size inefficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:29,Deployability,update,updates,29,// Check for module flag for updates before do anything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:14,Performance,perform,perform,14,"// Otherwise, perform a merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:3,Deployability,Update,Update,3,// Update the destination flag to that of the source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:3,Performance,Perform,Perform,3,// Perform the merge for standard behavior types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:11,Availability,error,error,11,// Emit an error if the values differ.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:3,Modifiability,Inherit,Inherit,3,// Inherit the target data from the source module if the destination module; // doesn't have one already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp:172,Integrability,depend,dependency,172,/// Function that will perform the actual internalization. The reason for a; /// callback is that the linker cannot call internalizeModule without; /// creating a circular dependency between IPO and the linker.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp:23,Performance,perform,perform,23,/// Function that will perform the actual internalization. The reason for a; /// callback is that the linker cannot call internalizeModule without; /// creating a circular dependency between IPO and the linker.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp:36,Availability,error,error,36,/// Should we have mover and linker error diag info?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp:32,Availability,avail,available,32,// Use the comdat if it is only available in one of the modules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp:17,Modifiability,variab,variables,17,// Always import variables with appending linkage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp:9,Modifiability,variab,variable,9,"// For a variable in a comdat nodeduplicate, its initializer should be; // preserved (its content may be implicitly used by other members) even if; // symbol resolution does not pick it. Clone it into an unnamed private; // variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp:224,Modifiability,variab,variable,224,"// For a variable in a comdat nodeduplicate, its initializer should be; // preserved (its content may be implicitly used by other members) even if; // symbol resolution does not pick it. Clone it into an unnamed private; // variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp:20,Availability,Error,Errors,20,// FIXME: Propagate Errors through to the caller instead of emitting; // diagnostics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp:335,Availability,error,error,335,"//===----------------------------------------------------------------------===//; // LinkModules entrypoint.; //===----------------------------------------------------------------------===//; /// This function links two modules together, with the resulting Dest module; /// modified to be the composite of the two input modules. If an error occurs,; /// true is returned and ErrorMsg (if not null) is set to indicate the problem.; /// Upon failure, the Dest module could be in a modified state, and shouldn't be; /// relied on to be consistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp:375,Availability,Error,ErrorMsg,375,"//===----------------------------------------------------------------------===//; // LinkModules entrypoint.; //===----------------------------------------------------------------------===//; /// This function links two modules together, with the resulting Dest module; /// modified to be the composite of the two input modules. If an error occurs,; /// true is returned and ErrorMsg (if not null) is set to indicate the problem.; /// Upon failure, the Dest module could be in a modified state, and shouldn't be; /// relied on to be consistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp:440,Availability,failure,failure,440,"//===----------------------------------------------------------------------===//; // LinkModules entrypoint.; //===----------------------------------------------------------------------===//; /// This function links two modules together, with the resulting Dest module; /// modified to be the composite of the two input modules. If an error occurs,; /// true is returned and ErrorMsg (if not null) is set to indicate the problem.; /// Upon failure, the Dest module could be in a modified state, and shouldn't be; /// relied on to be consistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:31,Performance,Optimiz,Optimizer,31,"//===-LTO.cpp - LLVM Link Time Optimizer ----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements functions and classes used to support LTO.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:87,Integrability,interface,interfaces,87,/// Indicate we are linking with an allocator that supports hot/cold operator; /// new interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:40,Security,hash,hash,40,// namespace llvm; // Computes a unique hash for the Module considering the current list of; // export/import and other global analysis results.; // The hash is produced in \p Key.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:153,Security,hash,hash,153,// namespace llvm; // Computes a unique hash for the Module considering the current list of; // export/import and other global analysis results.; // The hash is produced in \p Key.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:22,Security,hash,hash,22,"// Compute the unique hash for this entry.; // This is based on the current compiler version, the module itself, the; // export list, the hash for every single module in the import list, the; // list of ResolvedODR for the module, and the list of preserved symbols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:138,Security,hash,hash,138,"// Compute the unique hash for this entry.; // This is based on the current compiler version, the module itself, the; // export list, the hash for every single module in the import list, the; // list of ResolvedODR for the module, and the list of preserved symbols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:32,Deployability,configurat,configuration,32,// Include the parts of the LTO configuration that affect code generation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:32,Modifiability,config,configuration,32,// Include the parts of the LTO configuration that affect code generation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:10,Security,Hash,Hash,10,"// FIXME: Hash more of Options. For now all clients initialize Options from; // command-line flags (which is unsupported in production), but may set; // RelaxELFRelocations. The clang driver can also pass FunctionSections,; // DataSections and DebuggerTuning via command line flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:15,Security,hash,hash,15,// Include the hash for the current module,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:33,Usability,GUID,GUIDs,33,// Sort the export list elements GUIDs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:15,Security,hash,hash,15,"// Include the hash for every module we import functions from. The set of; // imported symbols for each module may affect code generation and is; // sensitive to link order, so include that as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:22,Security,hash,hash,22,"// Order using module hash, to be both independent of module name and; // module order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:15,Security,hash,hash,15,// Include the hash for the resolved ODR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:15,Security,hash,hash,15,"// Include the hash for the linkage type to reflect internalization and weak; // resolution, and collect any used type identifier resolutions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:15,Security,hash,hash,15,// Include the hash for all type identifiers used by this module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:499,Integrability,rout,routines,499,"// We need to emit only one of these. The prevailing module will keep it,; // but turned into a weak, while the others will drop it when possible.; // This is both a compile-time optimization and a correctness; // transformation. This is necessary for correctness when we have exported; // a reference - we need to convert the linkonce to weak to; // ensure a copy is kept to satisfy the exported reference.; // FIXME: We may want to split the compile time and correctness; // aspects into separate routines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:179,Performance,optimiz,optimization,179,"// We need to emit only one of these. The prevailing module will keep it,; // but turned into a weak, while the others will drop it when possible.; // This is both a compile-time optimization and a correctness; // transformation. This is necessary for correctness when we have exported; // a reference - we need to convert the linkonce to weak to; // ensure a copy is kept to satisfy the exported reference.; // FIXME: We may want to split the compile time and correctness; // aspects into separate routines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:244,Availability,avail,available,244,"// The kept copy is eligible for auto-hiding (hidden visibility) if all; // copies were (i.e. they were all linkonce_odr global unnamed addr).; // If any copy is not (e.g. it was originally weak_odr), then the symbol; // must remain externally available (e.g. a weak_odr from an explicitly; // instantiated template). Additionally, if it is in the; // GUIDPreservedSymbols set, that means that it is visibile outside; // the summary (e.g. in a native object or a bitcode file without; // summary), and in that case we cannot hide it as it isn't possible to; // check all copies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:352,Usability,GUID,GUIDPreservedSymbols,352,"// The kept copy is eligible for auto-hiding (hidden visibility) if all; // copies were (i.e. they were all linkonce_odr global unnamed addr).; // If any copy is not (e.g. it was originally weak_odr), then the symbol; // must remain externally available (e.g. a weak_odr from an explicitly; // instantiated template). Additionally, if it is in the; // GUIDPreservedSymbols set, that means that it is visibile outside; // the summary (e.g. in a native object or a bitcode file without; // summary), and in that case we cannot hide it as it isn't possible to; // check all copies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:12,Performance,optimiz,optimize,12,// We won't optimize the globals that are referenced by an alias for now; // Ideally we should turn the alias into a global and duplicate the definition; // when needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:29,Modifiability,variab,variable,29,"// Non-exported function and variable definitions with a weak-for-linker; // linkage can be internalized in certain cases. The minimum legality; // requirements would be that they are not address taken to ensure that we; // don't break pointer equality checks, and that variables are either read-; // or write-only. For functions, this is the case if either all copies are; // [local_]unnamed_addr, or we can propagate reference edge attributes; // (which is how this is guaranteed for variables, when analyzing whether; // they are read or write-only).; //; // However, we only get to this code for weak-for-linkage values in one of; // two cases:; // 1) The prevailing copy is not in IR (it is in native code).; // 2) The prevailing copy in IR is not exported from its module.; // Additionally, at least for the new LTO API, case 2 will only happen if; // there is exactly one definition of the value (i.e. in exactly one; // module), as duplicate defs are result in the value being marked exported.; // Likely, users of the legacy LTO API are similar, however, currently there; // are llvm-lto based tests of the legacy LTO API that do not mark; // duplicate linkonce_odr copies as exported via the tool, so we need; // to handle that case below by checking the number of copies.; //; // Generally, we only want to internalize a weak-for-linker value in case; // 2, because in case 1 we cannot see how the value is used to know if it; // is read or write-only. We also don't want to bloat the binary with; // multiple internalized copies of non-prevailing linkonce/weak functions.; // Note if we don't internalize, we will convert non-prevailing copies to; // available_externally anyway, so that we drop them after inlining. The; // only reason to internalize such a function is if we indeed have a single; // copy, because internalizing it won't increase binary size, and enables; // use of inliner heuristics that are more aggressive in the face of a; // single call to a static (local). For var",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:270,Modifiability,variab,variables,270,"// Non-exported function and variable definitions with a weak-for-linker; // linkage can be internalized in certain cases. The minimum legality; // requirements would be that they are not address taken to ensure that we; // don't break pointer equality checks, and that variables are either read-; // or write-only. For functions, this is the case if either all copies are; // [local_]unnamed_addr, or we can propagate reference edge attributes; // (which is how this is guaranteed for variables, when analyzing whether; // they are read or write-only).; //; // However, we only get to this code for weak-for-linkage values in one of; // two cases:; // 1) The prevailing copy is not in IR (it is in native code).; // 2) The prevailing copy in IR is not exported from its module.; // Additionally, at least for the new LTO API, case 2 will only happen if; // there is exactly one definition of the value (i.e. in exactly one; // module), as duplicate defs are result in the value being marked exported.; // Likely, users of the legacy LTO API are similar, however, currently there; // are llvm-lto based tests of the legacy LTO API that do not mark; // duplicate linkonce_odr copies as exported via the tool, so we need; // to handle that case below by checking the number of copies.; //; // Generally, we only want to internalize a weak-for-linker value in case; // 2, because in case 1 we cannot see how the value is used to know if it; // is read or write-only. We also don't want to bloat the binary with; // multiple internalized copies of non-prevailing linkonce/weak functions.; // Note if we don't internalize, we will convert non-prevailing copies to; // available_externally anyway, so that we drop them after inlining. The; // only reason to internalize such a function is if we indeed have a single; // copy, because internalizing it won't increase binary size, and enables; // use of inliner heuristics that are more aggressive in the face of a; // single call to a static (local). For var",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:486,Modifiability,variab,variables,486,"// Non-exported function and variable definitions with a weak-for-linker; // linkage can be internalized in certain cases. The minimum legality; // requirements would be that they are not address taken to ensure that we; // don't break pointer equality checks, and that variables are either read-; // or write-only. For functions, this is the case if either all copies are; // [local_]unnamed_addr, or we can propagate reference edge attributes; // (which is how this is guaranteed for variables, when analyzing whether; // they are read or write-only).; //; // However, we only get to this code for weak-for-linkage values in one of; // two cases:; // 1) The prevailing copy is not in IR (it is in native code).; // 2) The prevailing copy in IR is not exported from its module.; // Additionally, at least for the new LTO API, case 2 will only happen if; // there is exactly one definition of the value (i.e. in exactly one; // module), as duplicate defs are result in the value being marked exported.; // Likely, users of the legacy LTO API are similar, however, currently there; // are llvm-lto based tests of the legacy LTO API that do not mark; // duplicate linkonce_odr copies as exported via the tool, so we need; // to handle that case below by checking the number of copies.; //; // Generally, we only want to internalize a weak-for-linker value in case; // 2, because in case 1 we cannot see how the value is used to know if it; // is read or write-only. We also don't want to bloat the binary with; // multiple internalized copies of non-prevailing linkonce/weak functions.; // Note if we don't internalize, we will convert non-prevailing copies to; // available_externally anyway, so that we drop them after inlining. The; // only reason to internalize such a function is if we indeed have a single; // copy, because internalizing it won't increase binary size, and enables; // use of inliner heuristics that are more aggressive in the face of a; // single call to a static (local). For var",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:1998,Modifiability,variab,variables,1998,"ariables, when analyzing whether; // they are read or write-only).; //; // However, we only get to this code for weak-for-linkage values in one of; // two cases:; // 1) The prevailing copy is not in IR (it is in native code).; // 2) The prevailing copy in IR is not exported from its module.; // Additionally, at least for the new LTO API, case 2 will only happen if; // there is exactly one definition of the value (i.e. in exactly one; // module), as duplicate defs are result in the value being marked exported.; // Likely, users of the legacy LTO API are similar, however, currently there; // are llvm-lto based tests of the legacy LTO API that do not mark; // duplicate linkonce_odr copies as exported via the tool, so we need; // to handle that case below by checking the number of copies.; //; // Generally, we only want to internalize a weak-for-linker value in case; // 2, because in case 1 we cannot see how the value is used to know if it; // is read or write-only. We also don't want to bloat the binary with; // multiple internalized copies of non-prevailing linkonce/weak functions.; // Note if we don't internalize, we will convert non-prevailing copies to; // available_externally anyway, so that we drop them after inlining. The; // only reason to internalize such a function is if we indeed have a single; // copy, because internalizing it won't increase binary size, and enables; // use of inliner heuristics that are more aggressive in the face of a; // single call to a static (local). For variables, internalizing a read or; // write only variable can enable more aggressive optimization. However, we; // already perform this elsewhere in the ThinLTO backend handling for; // read or write-only variables (processGlobalForThinLTO).; //; // Therefore, only internalize linkonce/weak if there is a single copy, that; // is prevailing in this IR module. We can do so aggressively, without; // requiring the address to be insignificant, or that a variable be read or; // write-only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:2048,Modifiability,variab,variable,2048,"ariables, when analyzing whether; // they are read or write-only).; //; // However, we only get to this code for weak-for-linkage values in one of; // two cases:; // 1) The prevailing copy is not in IR (it is in native code).; // 2) The prevailing copy in IR is not exported from its module.; // Additionally, at least for the new LTO API, case 2 will only happen if; // there is exactly one definition of the value (i.e. in exactly one; // module), as duplicate defs are result in the value being marked exported.; // Likely, users of the legacy LTO API are similar, however, currently there; // are llvm-lto based tests of the legacy LTO API that do not mark; // duplicate linkonce_odr copies as exported via the tool, so we need; // to handle that case below by checking the number of copies.; //; // Generally, we only want to internalize a weak-for-linker value in case; // 2, because in case 1 we cannot see how the value is used to know if it; // is read or write-only. We also don't want to bloat the binary with; // multiple internalized copies of non-prevailing linkonce/weak functions.; // Note if we don't internalize, we will convert non-prevailing copies to; // available_externally anyway, so that we drop them after inlining. The; // only reason to internalize such a function is if we indeed have a single; // copy, because internalizing it won't increase binary size, and enables; // use of inliner heuristics that are more aggressive in the face of a; // single call to a static (local). For variables, internalizing a read or; // write only variable can enable more aggressive optimization. However, we; // already perform this elsewhere in the ThinLTO backend handling for; // read or write-only variables (processGlobalForThinLTO).; //; // Therefore, only internalize linkonce/weak if there is a single copy, that; // is prevailing in this IR module. We can do so aggressively, without; // requiring the address to be insignificant, or that a variable be read or; // write-only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:2204,Modifiability,variab,variables,2204,"ariables, when analyzing whether; // they are read or write-only).; //; // However, we only get to this code for weak-for-linkage values in one of; // two cases:; // 1) The prevailing copy is not in IR (it is in native code).; // 2) The prevailing copy in IR is not exported from its module.; // Additionally, at least for the new LTO API, case 2 will only happen if; // there is exactly one definition of the value (i.e. in exactly one; // module), as duplicate defs are result in the value being marked exported.; // Likely, users of the legacy LTO API are similar, however, currently there; // are llvm-lto based tests of the legacy LTO API that do not mark; // duplicate linkonce_odr copies as exported via the tool, so we need; // to handle that case below by checking the number of copies.; //; // Generally, we only want to internalize a weak-for-linker value in case; // 2, because in case 1 we cannot see how the value is used to know if it; // is read or write-only. We also don't want to bloat the binary with; // multiple internalized copies of non-prevailing linkonce/weak functions.; // Note if we don't internalize, we will convert non-prevailing copies to; // available_externally anyway, so that we drop them after inlining. The; // only reason to internalize such a function is if we indeed have a single; // copy, because internalizing it won't increase binary size, and enables; // use of inliner heuristics that are more aggressive in the face of a; // single call to a static (local). For variables, internalizing a read or; // write only variable can enable more aggressive optimization. However, we; // already perform this elsewhere in the ThinLTO backend handling for; // read or write-only variables (processGlobalForThinLTO).; //; // Therefore, only internalize linkonce/weak if there is a single copy, that; // is prevailing in this IR module. We can do so aggressively, without; // requiring the address to be insignificant, or that a variable be read or; // write-only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:2452,Modifiability,variab,variable,2452,"ariables, when analyzing whether; // they are read or write-only).; //; // However, we only get to this code for weak-for-linkage values in one of; // two cases:; // 1) The prevailing copy is not in IR (it is in native code).; // 2) The prevailing copy in IR is not exported from its module.; // Additionally, at least for the new LTO API, case 2 will only happen if; // there is exactly one definition of the value (i.e. in exactly one; // module), as duplicate defs are result in the value being marked exported.; // Likely, users of the legacy LTO API are similar, however, currently there; // are llvm-lto based tests of the legacy LTO API that do not mark; // duplicate linkonce_odr copies as exported via the tool, so we need; // to handle that case below by checking the number of copies.; //; // Generally, we only want to internalize a weak-for-linker value in case; // 2, because in case 1 we cannot see how the value is used to know if it; // is read or write-only. We also don't want to bloat the binary with; // multiple internalized copies of non-prevailing linkonce/weak functions.; // Note if we don't internalize, we will convert non-prevailing copies to; // available_externally anyway, so that we drop them after inlining. The; // only reason to internalize such a function is if we indeed have a single; // copy, because internalizing it won't increase binary size, and enables; // use of inliner heuristics that are more aggressive in the face of a; // single call to a static (local). For variables, internalizing a read or; // write only variable can enable more aggressive optimization. However, we; // already perform this elsewhere in the ThinLTO backend handling for; // read or write-only variables (processGlobalForThinLTO).; //; // Therefore, only internalize linkonce/weak if there is a single copy, that; // is prevailing in this IR module. We can do so aggressively, without; // requiring the address to be insignificant, or that a variable be read or; // write-only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:2084,Performance,optimiz,optimization,2084,"ariables, when analyzing whether; // they are read or write-only).; //; // However, we only get to this code for weak-for-linkage values in one of; // two cases:; // 1) The prevailing copy is not in IR (it is in native code).; // 2) The prevailing copy in IR is not exported from its module.; // Additionally, at least for the new LTO API, case 2 will only happen if; // there is exactly one definition of the value (i.e. in exactly one; // module), as duplicate defs are result in the value being marked exported.; // Likely, users of the legacy LTO API are similar, however, currently there; // are llvm-lto based tests of the legacy LTO API that do not mark; // duplicate linkonce_odr copies as exported via the tool, so we need; // to handle that case below by checking the number of copies.; //; // Generally, we only want to internalize a weak-for-linker value in case; // 2, because in case 1 we cannot see how the value is used to know if it; // is read or write-only. We also don't want to bloat the binary with; // multiple internalized copies of non-prevailing linkonce/weak functions.; // Note if we don't internalize, we will convert non-prevailing copies to; // available_externally anyway, so that we drop them after inlining. The; // only reason to internalize such a function is if we indeed have a single; // copy, because internalizing it won't increase binary size, and enables; // use of inliner heuristics that are more aggressive in the face of a; // single call to a static (local). For variables, internalizing a read or; // write only variable can enable more aggressive optimization. However, we; // already perform this elsewhere in the ThinLTO backend handling for; // read or write-only variables (processGlobalForThinLTO).; //; // Therefore, only internalize linkonce/weak if there is a single copy, that; // is prevailing in this IR module. We can do so aggressively, without; // requiring the address to be insignificant, or that a variable be read or; // write-only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:2122,Performance,perform,perform,2122,"ariables, when analyzing whether; // they are read or write-only).; //; // However, we only get to this code for weak-for-linkage values in one of; // two cases:; // 1) The prevailing copy is not in IR (it is in native code).; // 2) The prevailing copy in IR is not exported from its module.; // Additionally, at least for the new LTO API, case 2 will only happen if; // there is exactly one definition of the value (i.e. in exactly one; // module), as duplicate defs are result in the value being marked exported.; // Likely, users of the legacy LTO API are similar, however, currently there; // are llvm-lto based tests of the legacy LTO API that do not mark; // duplicate linkonce_odr copies as exported via the tool, so we need; // to handle that case below by checking the number of copies.; //; // Generally, we only want to internalize a weak-for-linker value in case; // 2, because in case 1 we cannot see how the value is used to know if it; // is read or write-only. We also don't want to bloat the binary with; // multiple internalized copies of non-prevailing linkonce/weak functions.; // Note if we don't internalize, we will convert non-prevailing copies to; // available_externally anyway, so that we drop them after inlining. The; // only reason to internalize such a function is if we indeed have a single; // copy, because internalizing it won't increase binary size, and enables; // use of inliner heuristics that are more aggressive in the face of a; // single call to a static (local). For variables, internalizing a read or; // write only variable can enable more aggressive optimization. However, we; // already perform this elsewhere in the ThinLTO backend handling for; // read or write-only variables (processGlobalForThinLTO).; //; // Therefore, only internalize linkonce/weak if there is a single copy, that; // is prevailing in this IR module. We can do so aggressively, without; // requiring the address to be insignificant, or that a variable be read or; // write-only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:1103,Testability,test,tests,1103,"ty; // requirements would be that they are not address taken to ensure that we; // don't break pointer equality checks, and that variables are either read-; // or write-only. For functions, this is the case if either all copies are; // [local_]unnamed_addr, or we can propagate reference edge attributes; // (which is how this is guaranteed for variables, when analyzing whether; // they are read or write-only).; //; // However, we only get to this code for weak-for-linkage values in one of; // two cases:; // 1) The prevailing copy is not in IR (it is in native code).; // 2) The prevailing copy in IR is not exported from its module.; // Additionally, at least for the new LTO API, case 2 will only happen if; // there is exactly one definition of the value (i.e. in exactly one; // module), as duplicate defs are result in the value being marked exported.; // Likely, users of the legacy LTO API are similar, however, currently there; // are llvm-lto based tests of the legacy LTO API that do not mark; // duplicate linkonce_odr copies as exported via the tool, so we need; // to handle that case below by checking the number of copies.; //; // Generally, we only want to internalize a weak-for-linker value in case; // 2, because in case 1 we cannot see how the value is used to know if it; // is read or write-only. We also don't want to bloat the binary with; // multiple internalized copies of non-prevailing linkonce/weak functions.; // Note if we don't internalize, we will convert non-prevailing copies to; // available_externally anyway, so that we drop them after inlining. The; // only reason to internalize such a function is if we indeed have a single; // copy, because internalizing it won't increase binary size, and enables; // use of inliner heuristics that are more aggressive in the face of a; // single call to a static (local). For variables, internalizing a read or; // write only variable can enable more aggressive optimization. However, we; // already perform this elsewhe",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:3,Deployability,Update,Update,3,// Update the linkages in the given \p Index to mark exported values; // as external and non-exported values as internal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:609,Security,access,access,609,"// In rare occasion, the symbol used to initialize GlobalRes has a different; // IRName from the inspected Symbol. This can happen on macOS + iOS, when a; // symbol is referenced through its mangled name, say @""\01_symbol"" while; // the IRName is @symbol (the prefix underscore comes from MachO mangling).; // In that case, we have the same actual Symbol that can get two different; // GUID, leading to some invalid internalization. Workaround this by marking; // the GlobalRes external.; // FIXME: instead of this check, it would be desirable to compute GUIDs; // based on mangled name, but this requires an access to the Target Triple; // and would be relatively invasive on the codebase.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:386,Usability,GUID,GUID,386,"// In rare occasion, the symbol used to initialize GlobalRes has a different; // IRName from the inspected Symbol. This can happen on macOS + iOS, when a; // symbol is referenced through its mangled name, say @""\01_symbol"" while; // the IRName is @symbol (the prefix underscore comes from MachO mangling).; // In that case, we have the same actual Symbol that can get two different; // GUID, leading to some invalid internalization. Workaround this by marking; // the GlobalRes external.; // FIXME: instead of this check, it would be desirable to compute GUIDs; // based on mangled name, but this requires an access to the Target Triple; // and would be relatively invasive on the codebase.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:555,Usability,GUID,GUIDs,555,"// In rare occasion, the symbol used to initialize GlobalRes has a different; // IRName from the inspected Symbol. This can happen on macOS + iOS, when a; // symbol is referenced through its mangled name, say @""\01_symbol"" while; // the IRName is @symbol (the prefix underscore comes from MachO mangling).; // In that case, we have the same actual Symbol that can get two different; // GUID, leading to some invalid internalization. Workaround this by marking; // the GlobalRes external.; // FIXME: instead of this check, it would be desirable to compute GUIDs; // based on mangled name, but this requires an access to the Target Triple; // and would be relatively invasive on the codebase.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:96,Integrability,wrap,wrap,96,"// Set the partition to external if we know it is re-defined by the linker; // with -defsym or -wrap options, used elsewhere, e.g. it is visible to a; // regular object, is referenced from llvm.compiler.used/llvm.used, or was; // already recorded as being referenced from a different partition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:86,Availability,error,error,86,"// If only some modules were split, flag this in the index so that; // we can skip or error on optimizations that need consistently split; // modules (whole program devirt and lower type tests).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:95,Performance,optimiz,optimizations,95,"// If only some modules were split, flag this in the index so that; // we can skip or error on optimizations that need consistently split; // modules (whole program devirt and lower type tests).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:187,Testability,test,tests,187,"// If only some modules were split, flag this in the index so that; // we can skip or error on optimizations that need consistently split; // modules (whole program devirt and lower type tests).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:246,Availability,error,errors,246,"// Additionally need to drop all global values from the comdat to; // available_externally, to satisfy the COMDAT requirement that all members; // are discarded as a unit. The non-local linkage global values avoid; // duplicate definition linker errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:208,Safety,avoid,avoid,208,"// Additionally need to drop all global values from the comdat to; // available_externally, to satisfy the COMDAT requirement that all members; // are discarded as a unit. The non-local linkage global values avoid; // duplicate definition linker errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:179,Availability,error,errors,179,"// If cfi.functions is present and we are in regular LTO mode, LowerTypeTests; // will rename local functions in the merged module as ""<function name>.1"".; // This causes linking errors, since other parts of the module expect the; // original function name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:39,Integrability,wrap,wrap,39,"// For symbols re-defined with linker -wrap and -defsym options,; // set the linkage to weak to inhibit IPO. The linkage will be; // restored by the linker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:39,Integrability,wrap,wrap,39,// For linker redefined symbols (via --wrap or --defsym) we want to; // switch the linkage to `weak` to prevent IPOs from happening.; // Find the summary in the module for this very GV and record the new; // linkage so that we can switch it when we import the GV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:120,Performance,load,loads,120,"// If only some of the modules were split, we cannot correctly handle; // code that contains type tests or type checked loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:98,Testability,test,tests,98,"// If only some of the modules were split, we cannot correctly handle; // code that contains type tests or type checked loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:54,Performance,load,loads,54,// First check if there are type tests / type checked loads in the; // merged regular LTO module IR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:33,Testability,test,tests,33,// First check if there are type tests / type checked loads in the; // merged regular LTO module IR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:131,Integrability,interface,interfaces,131,"// TODO: Ideally this would be controlled automatically by detecting that we; // are linking with an allocator that supports these interfaces, rather than; // an internal option (which would still be needed for tests, however). For; // example, if the library exported a symbol like __malloc_hot_cold the linker; // could recognize that and set a flag in the lto::Config.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:364,Modifiability,Config,Config,364,"// TODO: Ideally this would be controlled automatically by detecting that we; // are linking with an allocator that supports these interfaces, rather than; // an internal option (which would still be needed for tests, however). For; // example, if the library exported a symbol like __malloc_hot_cold the linker; // could recognize that and set a flag in the lto::Config.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:59,Safety,detect,detecting,59,"// TODO: Ideally this would be controlled automatically by detecting that we; // are linking with an allocator that supports these interfaces, rather than; // an internal option (which would still be needed for tests, however). For; // example, if the library exported a symbol like __malloc_hot_cold the linker; // could recognize that and set a flag in the lto::Config.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:211,Testability,test,tests,211,"// TODO: Ideally this would be controlled automatically by detecting that we; // are linking with an allocator that supports these interfaces, rather than; // an internal option (which would still be needed for tests, however). For; // example, if the library exported a symbol like __malloc_hot_cold the linker; // could recognize that and set a flag in the lto::Config.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:75,Energy Efficiency,reduce,reduce,75,// This will reset the GlobalResolutions optional once done with it to; // reduce peak memory before importing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:138,Integrability,interface,interfaces,138,"// The profile matcher applies hotness attributes directly for allocations,; // and those will cause us to generate calls to the hot/cold interfaces; // unconditionally. If supports-hot-cold-new was not enabled in the LTO; // link then assume we don't want these calls (e.g. not linking with; // the appropriate library, or otherwise trying to disable this behavior).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:263,Deployability,update,update,263,"// Strip off all memprof metadata as it is no longer needed.; // Importantly, this avoids the addition of new memprof attributes; // after inlining propagation.; // TODO: If we support additional types of MemProf metadata beyond hot; // and cold, we will need to update the metadata based on the allocator; // APIs supported instead of completely stripping all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:83,Safety,avoid,avoids,83,"// Strip off all memprof metadata as it is no longer needed.; // Importantly, this avoids the addition of new memprof attributes; // after inlining propagation.; // TODO: If we support additional types of MemProf metadata beyond hot; // and cold, we will need to update the metadata based on the allocator; // APIs supported instead of completely stripping all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:9,Performance,optimiz,optimization,9,// Setup optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:65,Testability,test,tests,65,// Ensure we don't have inconsistently split LTO units with type tests.; // FIXME: this checks both LTO and ThinLTO. It happens to work as we take; // this path both cases but eventually this should be split into two and; // do the ThinLTO checks in `runThinLTO`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:29,Deployability,upgrade,upgrade,29,"// If validation is enabled, upgrade visibility only when all vtables; // have typeinfos.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:6,Security,validat,validation,6,"// If validation is enabled, upgrade visibility only when all vtables; // have typeinfos.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:15,Deployability,upgrade,upgrade,15,"// If allowed, upgrade public vcall visibility metadata to linkage unit; // visibility before whole program devirtualization in the optimizer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:132,Performance,optimiz,optimizer,132,"// If allowed, upgrade public vcall visibility metadata to linkage unit; // visibility before whole program devirtualization in the optimizer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:175,Availability,Avail,AvailableExternally,175,"// Symbols that are marked DLLImport or DLLExport should not be; // internalized, as they are either externally visible or referencing; // external symbols. Symbols that have AvailableExternally or Appending; // linkage might be used by future passes and should be kept as is.; // These linkages are seen in Unified regular LTO, because the process; // of creating split LTO units introduces symbols with that linkage into; // one of the created modules. Normally, only the ThinLTO backend would; // compile this module, but Unified Regular LTO processes both; // modules created by the splitting process as regular LTO modules.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:27,Integrability,interface,interface,27,/// This class defines the interface to the ThinLTO backend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:3,Performance,Cache,Cache,3,// Cache disabled or no entry for this module in the combined index or; // no module hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:85,Security,hash,hash,85,// Cache disabled or no entry for this module in the combined index or; // no module hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:21,Performance,cache,cached,21,"// The module may be cached, this helps handling it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:88,Safety,avoid,avoid,88,// WriteIndexesThinBackend should always return 1 to prevent module; // re-ordering and avoid non-determinism in the final link.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:60,Usability,GUID,GUID,60,// Collect for each module the list of function it defines (GUID ->; // Summary).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:29,Deployability,upgrade,upgrade,29,"// If validation is enabled, upgrade visibility only when all vtables; // have typeinfos.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:6,Security,validat,validation,6,"// If validation is enabled, upgrade visibility only when all vtables; // have typeinfos.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:70,Deployability,upgrade,upgraded,70,"// If we're validating, get the vtable symbols that should not be; // upgraded because they correspond to typeIDs outside of index-based; // WPD info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:12,Security,validat,validating,12,"// If we're validating, get the vtable symbols that should not be; // upgraded because they correspond to typeIDs outside of index-based; // WPD info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:15,Deployability,upgrade,upgrade,15,"// If allowed, upgrade public vcall visibility to linkage unit visibility in; // the summaries before whole program devirtualization below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:3,Performance,Perform,Perform,3,// Perform index-based WPD. This will return immediately if there are; // no index entries in the typeIdMetadata map (e.g. if we are instead; // performing IR-based WPD in hybrid regular/thin LTO mode).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:145,Performance,perform,performing,145,// Perform index-based WPD. This will return immediately if there are; // no index entries in the typeIdMetadata map (e.g. if we are instead; // performing IR-based WPD in hybrid regular/thin LTO mode).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:230,Safety,avoid,avoid,230,"// Figure out which symbols need to be internalized. This also needs to happen; // at -O0 because summary-based DCE is implemented using internalization, and; // we must apply DCE consistently with the full LTO module in order to avoid; // undefined references during the final link.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:96,Security,access,accesses,96,"// Reset the GlobalResolutions to deallocate the associated memory, as there; // are no further accesses. We specifically want to do this before computing; // cross module importing, which adds to peak memory via the computed import; // and export lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:3,Deployability,Update,Update,3,// Update local devirtualized targets that were exported by cross-module; // importing or by other devirtualizations marked in the ExportedGUIDs set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:101,Safety,avoid,avoid,101,"// When executing in parallel, process largest bitsize modules first to; // improve parallelism, and avoid starving the thread pool near the end.; // This saves about 15 sec on a 36-core machine while link `clang.exe` (out; // of 100 sec).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:137,Energy Efficiency,schedul,schedule,137,// Compute the ordering we will process the inputs: the rough heuristic here; // is to sort them per size so that the largest module get schedule as soon as; // possible. This is purely a compile-time optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:201,Performance,optimiz,optimization,201,// Compute the ordering we will process the inputs: the rough heuristic here; // is to sort them per size so that the largest module get schedule as soon as; // possible. This is purely a compile-time optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp:38,Performance,Optimiz,Optimizer,38,"//===-LTOBackend.cpp - LLVM Link Time Optimizer Backend -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ""backend"" phase of LTO, i.e. it performs; // optimization and code generation on a loaded module. It is generally used; // internally by the LTO class but can also be used independently, for example; // to implement a standalone ThinLTO backend.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp:440,Performance,perform,performs,440,"//===-LTOBackend.cpp - LLVM Link Time Optimizer Backend -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ""backend"" phase of LTO, i.e. it performs; // optimization and code generation on a loaded module. It is generally used; // internally by the LTO class but can also be used independently, for example; // to implement a standalone ThinLTO backend.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp:453,Performance,optimiz,optimization,453,"//===-LTOBackend.cpp - LLVM Link Time Optimizer Backend -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ""backend"" phase of LTO, i.e. it performs; // optimization and code generation on a loaded module. It is generally used; // internally by the LTO class but can also be used independently, for example; // to implement a standalone ThinLTO backend.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp:491,Performance,load,loaded,491,"//===-LTOBackend.cpp - LLVM Link Time Optimizer Backend -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ""backend"" phase of LTO, i.e. it performs; // optimization and code generation on a loaded module. It is generally used; // internally by the LTO class but can also be used independently, for example; // to implement a standalone ThinLTO backend.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp:61,Availability,error,error,61,"// Because -save-temps is a debugging feature, we report the error; // directly and exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp:61,Availability,error,error,61,"// Because -save-temps is a debugging feature, we report the error; // directly and exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp:23,Modifiability,plugin,plugins,23,// Load requested pass plugins and let them register pass builder callbacks,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp:3,Performance,Load,Load,3,// Load requested pass plugins and let them register pass builder callbacks,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp:21,Deployability,pipeline,pipeline,21,// Parse a custom AA pipeline if asked to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp:18,Deployability,pipeline,pipeline,18,// Parse a custom pipeline if asked to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp:174,Integrability,depend,dependencies,174,"// FIXME: the motivation for capturing post-merge bitcode and command line; // is replicating the compilation environment from bitcode, without needing; // to understand the dependencies (the functions to be imported). This; // assumes a clang - based invocation, case in which we have the command; // line.; // It's not very clear how the above motivation would map in the; // linker-based case, so we currently don't plumb the command line args in; // that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp:326,Usability,clear,clear,326,"// FIXME: the motivation for capturing post-merge bitcode and command line; // is replicating the compilation environment from bitcode, without needing; // to understand the dependencies (the functions to be imported). This; // assumes a clang - based invocation, case in which we have the command; // line.; // It's not very clear how the above motivation would map in the; // linker-based case, so we currently don't plumb the command line args in; // that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp:51,Performance,multi-thread,multi-thread,51,"// We want to clone the module in a new context to multi-thread the; // codegen. We do it by serializing partition modules to bitcode; // (while still on the main thread, in order to avoid data races) and; // spinning up new threads which deserialize the partitions into; // separate contexts.; // FIXME: Provide a more direct way to do this in LLVM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp:183,Safety,avoid,avoid,183,"// We want to clone the module in a new context to multi-thread the; // codegen. We do it by serializing partition modules to bitcode; // (while still on the main thread, in order to avoid data races) and; // spinning up new threads which deserialize the partitions into; // separate contexts.; // FIXME: Provide a more direct way to do this in LLVM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp:83,Modifiability,variab,variables,83,"// Because the inner lambda (which runs in a worker thread) captures our local; // variables, we need to wait for the worker threads to terminate before we; // can leave the function scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp:9,Performance,optimiz,optimization,9,// Setup optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp:56,Deployability,update,updated,56,// Do this after any importing so that imported code is updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp:10,Usability,simpl,simply,10,"// We can simply import the values mentioned in the combined index, since; // we should only invoke this using the individual indexes written out; // via a WriteIndexesThinBackend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp:44,Performance,Optimiz,Optimizer,44,"//===-LTOCodeGenerator.cpp - LLVM Link Time Optimizer ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Link Time Optimization library. This library is; // intended to be used by linker to optimize code at link time.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp:418,Performance,Optimiz,Optimization,418,"//===-LTOCodeGenerator.cpp - LLVM Link Time Optimizer ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Link Time Optimization library. This library is; // intended to be used by linker to optimize code at link time.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp:493,Performance,optimiz,optimize,493,"//===-LTOCodeGenerator.cpp - LLVM Link Time Optimizer ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Link Time Optimization library. This library is; // intended to be used by linker to optimize code at link time.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp:23,Modifiability,variab,variable,23,// Setup the LDR_CNTRL variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp:10,Availability,error,errors,10,// Handle errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp:124,Modifiability,plugin,plugin,124,"// If data-sections is not explicitly set or unset, set data-sections by; // default to match the behaviour of lld and gold plugin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp:3,Deployability,Update,Update,3,// Update the llvm.compiler_used globals to force preserving libcalls and; // symbols referenced from asm,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp:4,Performance,Optimiz,Optimize,4,/// Optimize merged modules using various IPO passes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp:238,Deployability,pipeline,pipeline,238,"// Currently there is no support for enabling whole program visibility via a; // linker option in the old LTO API, but this call allows it to be specified; // via the internal option. Must be done before WPD invoked via the optimizer; // pipeline run below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp:224,Performance,optimiz,optimizer,224,"// Currently there is no support for enabling whole program visibility via a; // linker option in the old LTO API, but this call allows it to be specified; // via the internal option. Must be done before WPD invoked via the optimizer; // pipeline run below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp:58,Integrability,interface,interface,58,// FIXME: These need linker information via a; // TBD new interface.; /*DynamicExportSymbols=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp:2,Security,Validat,ValidateAllVtablesHaveTypeInfos,2,/*ValidateAllVtablesHaveTypeInfos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp:94,Performance,optimiz,optimize,94,"// We always run the verifier once on the merged module. If it has already; // been called in optimize(), this call will return early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp:98,Testability,Assert,Assert,98,// If this method has been called it means someone has set up an external; // diagnostic handler. Assert on that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp:33,Testability,stub,stub,33,// Register the LTOCodeGenerator stub in the LLVMContext to forward the; // diagnostic to the external DiagHandler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp:39,Performance,Optimiz,Optimizer,39,"//===-- LTOModule.cpp - LLVM Link Time Optimizer --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Link Time Optimization library. This library is; // intended to be used by linker to optimize code at link time.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp:418,Performance,Optimiz,Optimization,418,"//===-- LTOModule.cpp - LLVM Link Time Optimizer --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Link Time Optimization library. This library is; // intended to be used by linker to optimize code at link time.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp:493,Performance,optimiz,optimize,493,"//===-- LTOModule.cpp - LLVM Link Time Optimizer --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Link Time Optimization library. This library is; // intended to be used by linker to optimize code at link time.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp:846,Availability,error,errors,846,"// Special case i386/ppc ObjC data structures in magic sections:; // The issue is that the old ObjC object format did some strange; // contortions to avoid real linker symbols. For instance, the; // ObjC class data structure is allocated statically in the executable; // that defines that class. That data structures contains a pointer to; // its superclass. But instead of just initializing that part of the; // struct to the address of its superclass, and letting the static and; // dynamic linkers do the rest, the runtime works by having that field; // instead point to a C-string that is the name of the superclass.; // At runtime the objc initialization updates that pointer and sets; // it to point to the actual super class. As far as the linker; // knows it is just a pointer to a string. But then someone wanted the; // linker to issue errors at build time if the superclass was not found.; // So they figured out a way in mach-o object format to use an absolute; // symbols (.objc_class_name_Foo = 0) and a floating reference; // (.reference .objc_class_name_Bar) to cause the linker into erroring when; // a class was missing.; // The following synthesizes the implicit .objc_* symbols for the linker; // from the ObjC data structures generated by the front end.; // special case if this data blob is an ObjC class definition",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp:1100,Availability,error,erroring,1100,"// Special case i386/ppc ObjC data structures in magic sections:; // The issue is that the old ObjC object format did some strange; // contortions to avoid real linker symbols. For instance, the; // ObjC class data structure is allocated statically in the executable; // that defines that class. That data structures contains a pointer to; // its superclass. But instead of just initializing that part of the; // struct to the address of its superclass, and letting the static and; // dynamic linkers do the rest, the runtime works by having that field; // instead point to a C-string that is the name of the superclass.; // At runtime the objc initialization updates that pointer and sets; // it to point to the actual super class. As far as the linker; // knows it is just a pointer to a string. But then someone wanted the; // linker to issue errors at build time if the superclass was not found.; // So they figured out a way in mach-o object format to use an absolute; // symbols (.objc_class_name_Foo = 0) and a floating reference; // (.reference .objc_class_name_Bar) to cause the linker into erroring when; // a class was missing.; // The following synthesizes the implicit .objc_* symbols for the linker; // from the ObjC data structures generated by the front end.; // special case if this data blob is an ObjC class definition",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp:660,Deployability,update,updates,660,"// Special case i386/ppc ObjC data structures in magic sections:; // The issue is that the old ObjC object format did some strange; // contortions to avoid real linker symbols. For instance, the; // ObjC class data structure is allocated statically in the executable; // that defines that class. That data structures contains a pointer to; // its superclass. But instead of just initializing that part of the; // struct to the address of its superclass, and letting the static and; // dynamic linkers do the rest, the runtime works by having that field; // instead point to a C-string that is the name of the superclass.; // At runtime the objc initialization updates that pointer and sets; // it to point to the actual super class. As far as the linker; // knows it is just a pointer to a string. But then someone wanted the; // linker to issue errors at build time if the superclass was not found.; // So they figured out a way in mach-o object format to use an absolute; // symbols (.objc_class_name_Foo = 0) and a floating reference; // (.reference .objc_class_name_Bar) to cause the linker into erroring when; // a class was missing.; // The following synthesizes the implicit .objc_* symbols for the linker; // from the ObjC data structures generated by the front end.; // special case if this data blob is an ObjC class definition",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp:228,Energy Efficiency,allocate,allocated,228,"// Special case i386/ppc ObjC data structures in magic sections:; // The issue is that the old ObjC object format did some strange; // contortions to avoid real linker symbols. For instance, the; // ObjC class data structure is allocated statically in the executable; // that defines that class. That data structures contains a pointer to; // its superclass. But instead of just initializing that part of the; // struct to the address of its superclass, and letting the static and; // dynamic linkers do the rest, the runtime works by having that field; // instead point to a C-string that is the name of the superclass.; // At runtime the objc initialization updates that pointer and sets; // it to point to the actual super class. As far as the linker; // knows it is just a pointer to a string. But then someone wanted the; // linker to issue errors at build time if the superclass was not found.; // So they figured out a way in mach-o object format to use an absolute; // symbols (.objc_class_name_Foo = 0) and a floating reference; // (.reference .objc_class_name_Bar) to cause the linker into erroring when; // a class was missing.; // The following synthesizes the implicit .objc_* symbols for the linker; // from the ObjC data structures generated by the front end.; // special case if this data blob is an ObjC class definition",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp:150,Safety,avoid,avoid,150,"// Special case i386/ppc ObjC data structures in magic sections:; // The issue is that the old ObjC object format did some strange; // contortions to avoid real linker symbols. For instance, the; // ObjC class data structure is allocated statically in the executable; // that defines that class. That data structures contains a pointer to; // its superclass. But instead of just initializing that part of the; // struct to the address of its superclass, and letting the static and; // dynamic linkers do the rest, the runtime works by having that field; // instead point to a C-string that is the name of the superclass.; // At runtime the objc initialization updates that pointer and sets; // it to point to the actual super class. As far as the linker; // knows it is just a pointer to a string. But then someone wanted the; // linker to issue errors at build time if the superclass was not found.; // So they figured out a way in mach-o object format to use an absolute; // symbols (.objc_class_name_Foo = 0) and a floating reference; // (.reference .objc_class_name_Bar) to cause the linker into erroring when; // a class was missing.; // The following synthesizes the implicit .objc_* symbols for the linker; // from the ObjC data structures generated by the front end.; // special case if this data blob is an ObjC class definition",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/SummaryBasedOptimizations.cpp:37,Performance,Optimiz,Optimizations,37,"//==-SummaryBasedOptimizations.cpp - Optimizations based on ThinLTO summary-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements optimizations that are based on the module summaries.; // These optimizations are performed during the thinlink phase of the; // compilation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/SummaryBasedOptimizations.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/SummaryBasedOptimizations.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/SummaryBasedOptimizations.cpp:404,Performance,optimiz,optimizations,404,"//==-SummaryBasedOptimizations.cpp - Optimizations based on ThinLTO summary-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements optimizations that are based on the module summaries.; // These optimizations are performed during the thinlink phase of the; // compilation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/SummaryBasedOptimizations.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/SummaryBasedOptimizations.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/SummaryBasedOptimizations.cpp:468,Performance,optimiz,optimizations,468,"//==-SummaryBasedOptimizations.cpp - Optimizations based on ThinLTO summary-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements optimizations that are based on the module summaries.; // These optimizations are performed during the thinlink phase of the; // compilation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/SummaryBasedOptimizations.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/SummaryBasedOptimizations.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/SummaryBasedOptimizations.cpp:486,Performance,perform,performed,486,"//==-SummaryBasedOptimizations.cpp - Optimizations based on ThinLTO summary-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements optimizations that are based on the module summaries.; // These optimizations are performed during the thinlink phase of the; // compilation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/SummaryBasedOptimizations.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/SummaryBasedOptimizations.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:48,Performance,Optimiz,Optimizer,48,"//===-ThinLTOCodeGenerator.cpp - LLVM Link Time Optimizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Thin Link Time Optimization library. This library is; // intended to be used by linker to optimize code at link time.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:423,Performance,Optimiz,Optimization,423,"//===-ThinLTOCodeGenerator.cpp - LLVM Link Time Optimizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Thin Link Time Optimization library. This library is; // intended to be used by linker to optimize code at link time.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:498,Performance,optimiz,optimize,498,"//===-ThinLTOCodeGenerator.cpp - LLVM Link Time Optimizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Thin Link Time Optimization library. This library is; // intended to be used by linker to optimize code at link time.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:24,Availability,avail,available,24,"// Default to using all available threads in the system, but using only one; // thred per core, as indicated by the usage of; // heavyweight_hardware_concurrency() below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:3,Usability,Simpl,Simple,3,// Simple helper to save temporary files for debug.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:19,Usability,GUID,GUID,19,"// Populate map of GUID to the prevailing copy for any multiply defined; // symbols. Currently assume first copy is prevailing, or any strong; // definition. Can be refined with Linker information in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:58,Usability,GUID,GUID,58,"// Convert the PreservedSymbols map from ""Name"" based to ""GUID"" based.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:95,Usability,GUID,GUID,95,// Iterate the symbols in the input file and if the input has preserved symbol; // compute the GUID for the symbol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:64,Performance,optimiz,optimization,64,"// If the bitcode files contain ARC code and were compiled with optimization,; // the ObjCARCContractPass must be run, so do it unconditionally here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:131,Integrability,interface,interface,131,"// Create a cache entry. This compute a unique hash for the Module considering; // the current list of export/import, and offer an interface to query to; // access the content in the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:12,Performance,cache,cache,12,"// Create a cache entry. This compute a unique hash for the Module considering; // the current list of export/import, and offer an interface to query to; // access the content in the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:183,Performance,cache,cache,183,"// Create a cache entry. This compute a unique hash for the Module considering; // the current list of export/import, and offer an interface to query to; // access the content in the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:47,Security,hash,hash,47,"// Create a cache entry. This compute a unique hash for the Module considering; // the current list of export/import, and offer an interface to query to; // access the content in the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:157,Security,access,access,157,"// Create a cache entry. This compute a unique hash for the Module considering; // the current list of export/import, and offer an interface to query to; // access the content in the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:54,Security,hash,hash,54,"// The module does not have an entry, it can't have a hash at all",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:6,Security,hash,hash,6,"// No hash entry, no caching!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:39,Performance,cache,cache,39,// This choice of file name allows the cache to be pruned (see pruneCache(); // in include/llvm/Support/CachePruning.h).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:104,Performance,Cache,CachePruning,104,// This choice of file name allows the cache to be pruned (see pruneCache(); // in include/llvm/Support/CachePruning.h).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:40,Performance,cache,cache,40,// Access the path to this entry in the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:3,Security,Access,Access,3,// Access the path to this entry in the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:7,Performance,load,loading,7,// Try loading the buffer for this cache entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:35,Performance,cache,cache,35,// Try loading the buffer for this cache entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:3,Performance,Cache,Cache,3,// Cache the Produced object file,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:20,Performance,optimiz,optimization,20,"// ""Benchmark""-like optimization: single-source case",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:4,Testability,Benchmark,Benchmark,4,"// ""Benchmark""-like optimization: single-source case",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:56,Deployability,update,updated,56,// Do this after any importing so that imported code is updated.; // See comment at call to updateVCallVisibilityInIndex() for why; // WholeProgramVisibilityEnabledInLTO is false.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:92,Deployability,update,updateVCallVisibilityInIndex,92,// Do this after any importing so that imported code is updated.; // See comment at call to updateVCallVisibilityInIndex() for why; // WholeProgramVisibilityEnabledInLTO is false.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:3,Modifiability,Config,Configured,3,"// Configured to stop before CodeGen, serialize the bitcode and return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:273,Performance,optimiz,optimization,273,"/// Resolve prevailing symbols. Record resolutions in the \p ResolvedODR map; /// for caching, and in the \p Index for application during the ThinLTO; /// backends. This is needed for correctness for exported symbols (ensure; /// at least one copy kept) and a compile-time optimization (to drop duplicate; /// copies when possible).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:42,Modifiability,Config,Config,42,// TODO Conf.VisibilityScheme can be lto::Config::ELF for ELF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:33,Availability,avail,available,33,// We have no symbols resolution available. And can't do any better now in the; // case where the prevailing symbol is in a native object. It can be refined; // with linker information in the future.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:82,Deployability,update,updated,82,/**; * Perform promotion and renaming of exported internal functions.; * Index is updated to reflect linkage changes from weak resolution.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:7,Performance,Perform,Perform,7,/**; * Perform promotion and renaming of exported internal functions.; * Index is updated to reflect linkage changes from weak resolution.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:60,Usability,GUID,GUID,60,// Collect for each module the list of function it defines (GUID -> Summary).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:52,Usability,GUID,GUID,52,// Convert the preserved symbols set from string to GUID,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:13,Usability,Clear,ClearDSOLocalOnDeclarations,13,// FIXME Set ClearDSOLocalOnDeclarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:2,Usability,Clear,ClearDSOLocalOnDeclarations,2,/*ClearDSOLocalOnDeclarations=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:7,Performance,Perform,Perform,7,/**; * Perform cross-module importing for the module identified by ModuleIdentifier.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:60,Usability,GUID,GUID,60,// Collect for each module the list of function it defines (GUID -> Summary).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:52,Usability,GUID,GUID,52,// Convert the preserved symbols set from string to GUID,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:13,Usability,Clear,ClearDSOLocalOnDeclarations,13,// FIXME Set ClearDSOLocalOnDeclarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:2,Usability,Clear,ClearDSOLocalOnDeclarations,2,/*ClearDSOLocalOnDeclarations=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:60,Usability,GUID,GUID,60,// Collect for each module the list of function it defines (GUID -> Summary).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:52,Usability,GUID,GUID,52,// Convert the preserved symbols set from string to GUID,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:60,Usability,GUID,GUID,60,// Collect for each module the list of function it defines (GUID -> Summary).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:52,Usability,GUID,GUID,52,// Convert the preserved symbols set from string to GUID,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:87,Deployability,update,updated,87,/**; * Perform internalization. Runs promote and internalization together.; * Index is updated to reflect linkage changes.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:7,Performance,Perform,Perform,7,/**; * Perform internalization. Runs promote and internalization together.; * Index is updated to reflect linkage changes.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:52,Usability,GUID,GUID,52,// Convert the preserved symbols set from string to GUID,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:60,Usability,GUID,GUID,60,// Collect for each module the list of function it defines (GUID -> Summary).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:13,Usability,Clear,ClearDSOLocalOnDeclarations,13,// FIXME Set ClearDSOLocalOnDeclarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:2,Usability,Clear,ClearDSOLocalOnDeclarations,2,/*ClearDSOLocalOnDeclarations=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:7,Performance,Perform,Perform,7,/**; * Perform post-importing ThinLTO optimizations.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:38,Performance,optimiz,optimizations,38,/**; * Perform post-importing ThinLTO optimizations.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:3,Performance,Optimiz,Optimize,3,// Optimize now,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:53,Performance,Cache,CacheEntryPath,53,"/// Write out the generated object file, either from CacheEntryPath or from; /// OutputBuffer, preferring hard-link when possible.; /// Returns the path to the generated file in SavedObjectsDirectoryPath.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:3,Performance,Cache,Cache,3,"// Cache is enabled, hard-link the entry (or copy if hard-link fails).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:143,Availability,down,down,143,"// Copy failed (could be because the CacheEntry was removed from the cache; // in the meantime by another process), fall back and try to write down the; // buffer to the output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:37,Performance,Cache,CacheEntry,37,"// Copy failed (could be because the CacheEntry was removed from the cache; // in the meantime by another process), fall back and try to write down the; // buffer to the output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:69,Performance,cache,cache,69,"// Copy failed (could be because the CacheEntry was removed from the cache; // in the meantime by another process), fall back and try to write down the; // buffer to the output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:6,Performance,cache,cache,6,"// No cache entry, just write out the buffer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:3,Performance,Perform,Perform,3,// Perform only parallel codegen and return.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:60,Usability,GUID,GUID,60,// Collect for each module the list of function it defines (GUID -> Summary).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:103,Security,hash,hash,103,"// Convert the preserved symbols set from string to GUID, this is needed for; // computing the caching hash and the internalization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:52,Usability,GUID,GUID,52,"// Convert the preserved symbols set from string to GUID, this is needed for; // computing the caching hash and the internalization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:54,Integrability,interface,interface,54,// FIXME: This needs linker information via a TBD new interface,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:58,Integrability,interface,interface,58,// FIXME: These need linker information via a; // TBD new interface.; /*DynamicExportSymbols=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:3,Performance,Perform,Perform,3,// Perform index-based WPD. This will return immediately if there are; // no index entries in the typeIdMetadata map (e.g. if we are instead; // performing IR-based WPD in hybrid regular/thin LTO mode).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:145,Performance,perform,performing,145,// Perform index-based WPD. This will return immediately if there are; // no index entries in the typeIdMetadata map (e.g. if we are instead; // performing IR-based WPD in hybrid regular/thin LTO mode).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:98,Performance,cache,cache,98,"// We use a std::map here to be able to have a defined ordering when; // producing a hash for the cache entry.; // FIXME: we should be able to compute the caching hash for the entry based; // on the index, and nuke this map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:85,Security,hash,hash,85,"// We use a std::map here to be able to have a defined ordering when; // producing a hash for the cache entry.; // FIXME: we should be able to compute the caching hash for the entry based; // on the index, and nuke this map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:163,Security,hash,hash,163,"// We use a std::map here to be able to have a defined ordering when; // producing a hash for the cache entry.; // FIXME: we should be able to compute the caching hash for the entry based; // on the index, and nuke this map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:130,Security,access,access,130,"// Make sure that every module has an entry in the ExportLists, ImportList,; // GVSummary and ResolvedODR maps to enable threaded access to these maps; // below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:12,Performance,optimiz,optimizer,12,// Parallel optimizer + codegen,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:21,Performance,cache,cached,21,"// The module may be cached, this helps handling it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:3,Performance,Cache,Cache,3,// Cache Hit!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:17,Performance,cache,cache,17,// Commit to the cache (if enabled),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:8,Performance,cache,cache,8,"// When cache is enabled, reload from the cache if possible.; // Releasing the buffer from the heap and reloading it from the; // cache file with mmap helps us to lower memory pressure.; // The freed memory can be used for the next input file.; // The final binary link will read from the VFS cache (hopefully!); // or from disk (if the memory pressure was too high).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:42,Performance,cache,cache,42,"// When cache is enabled, reload from the cache if possible.; // Releasing the buffer from the heap and reloading it from the; // cache file with mmap helps us to lower memory pressure.; // The freed memory can be used for the next input file.; // The final binary link will read from the VFS cache (hopefully!); // or from disk (if the memory pressure was too high).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:130,Performance,cache,cache,130,"// When cache is enabled, reload from the cache if possible.; // Releasing the buffer from the heap and reloading it from the; // cache file with mmap helps us to lower memory pressure.; // The freed memory can be used for the next input file.; // The final binary link will read from the VFS cache (hopefully!); // or from disk (if the memory pressure was too high).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:293,Performance,cache,cache,293,"// When cache is enabled, reload from the cache if possible.; // Releasing the buffer from the heap and reloading it from the; // cache file with mmap helps us to lower memory pressure.; // The freed memory can be used for the next input file.; // The final binary link will read from the VFS cache (hopefully!); // or from disk (if the memory pressure was too high).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:6,Availability,error,error,6,"// On error, keep the preexisting buffer and print a diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/UpdateCompilerUsed.cpp:41,Performance,Optimiz,Optimizer,41,"//==-LTOInternalize.cpp - LLVM Link Time Optimizer Internalization Utility -==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a helper to run the internalization part of LTO.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/UpdateCompilerUsed.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/UpdateCompilerUsed.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/UpdateCompilerUsed.cpp:168,Performance,optimiz,optimizations,168,// Collect names of runtime library functions. User-defined functions with the; // same names are added to llvm.compiler.used to prevent them from being; // deleted by optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/UpdateCompilerUsed.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/UpdateCompilerUsed.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/UpdateCompilerUsed.cpp:75,Availability,avail,available,75,"// TargetLowering has info on library calls that CodeGen expects to be; // available, both from the C runtime and compiler-rt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/UpdateCompilerUsed.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/UpdateCompilerUsed.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/UpdateCompilerUsed.cpp:191,Performance,optimiz,optimizations,191,"// Conservatively append user-supplied runtime library functions (supplied; // either directly, or via a function alias) to llvm.compiler.used. These; // could be internalized and deleted by optimizations like -globalopt,; // causing problems when later optimizations add new library calls (e.g.,; // llvm.memset => memset and printf => puts).; // Leave it to the linker to remove any dead code (e.g. with -dead_strip).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/UpdateCompilerUsed.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/UpdateCompilerUsed.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/UpdateCompilerUsed.cpp:254,Performance,optimiz,optimizations,254,"// Conservatively append user-supplied runtime library functions (supplied; // either directly, or via a function alias) to llvm.compiler.used. These; // could be internalized and deleted by optimizations like -globalopt,; // causing problems when later optimizations add new library calls (e.g.,; // llvm.memset => memset and printf => puts).; // Leave it to the linker to remove any dead code (e.g. with -dead_strip).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/LTO/UpdateCompilerUsed.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/UpdateCompilerUsed.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp:22,Integrability,wrap,wrappers,22,// TargetObjectWriter wrappers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp:59,Modifiability,inherit,inherit,59,"// For expressions like .set y, x+1, if y's size is unset, inherit from x.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp:290,Availability,error,error,290,"// We may end up with a situation when section symbol is technically; // defined, but should not be. That happens because we explicitly; // pre-create few .debug_* sections to have accessors.; // And if these sections were not really defined in the code, but were; // referenced, we simply error out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp:181,Security,access,accessors,181,"// We may end up with a situation when section symbol is technically; // defined, but should not be. That happens because we explicitly; // pre-create few .debug_* sections to have accessors.; // And if these sections were not really defined in the code, but were; // referenced, we simply error out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp:283,Usability,simpl,simply,283,"// We may end up with a situation when section symbol is technically; // defined, but should not be. That happens because we explicitly; // pre-create few .debug_* sections to have accessors.; // And if these sections were not really defined in the code, but were; // referenced, we simply error out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp:259,Performance,optimiz,optimizations,259,"// We record relocations by pushing to the end of a vector. Reverse the vector; // to get the relocations in the order they were created.; // In most cases that is not important, but it can be for special sections; // (.eh_frame) or specific relocations (TLS optimizations on SystemZ).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp:232,Deployability,patch,patch,232,"// These VariantKind cause the relocation to refer to something other than; // the symbol itself, like a linker generated table. Since the address of; // symbol is not relevant, we cannot replace the symbol with the; // section and patch the difference in the addend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp:151,Deployability,update,update,151,"// If the symbol is weak, it might be overridden by a symbol in another; // file. The relocation has to point to the symbol so that the linker; // can update it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp:103,Performance,load,loader,103,// Keep symbol type for a local ifunc because it may result in an IRELATIVE; // reloc that the dynamic loader will use to resolve the address at startup; // time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp:157,Testability,log,logical,157,"// The GOFFOstream is responsible to write the data into the fixed physical; // records of the format. A user of this class announces the start of a new; // logical record and the size of its content. While writing the content, the; // physical records are created for the data. Possible fill bytes at the end of; // a physical record are written automatically. In principle, the GOFFOstream; // is agnostic of the endianness of the content. However, it also supports; // writing data in big endian byte order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp:31,Testability,log,logical,31,"/// The remaining size of this logical record, including fill bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp:18,Testability,log,logical,18,/// The number of logical records emitted to far.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp:29,Testability,log,logical,29,/// The type of the current (logical) record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp:11,Energy Efficiency,allocate,allocated,11,"/// Static allocated buffer for the stream, used by the raw_ostream class. The; /// buffer is sized to hold the content of a physical record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp:39,Testability,log,logical,39,/// Fill the last physical record of a logical record with zero bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp:388,Testability,log,logical,388,// This function is called from the raw_ostream implementation if:; // - The internal buffer is full. Size is excactly the size of the buffer.; // - Data larger than the internal buffer is written. Size is a multiple of the; // buffer size.; // - flush() has been called. Size is at most the buffer size.; // The GOFFOstream implementation ensures that flush() is called before a new; // logical record begins. Therefore it is sufficient to check for a new block; // only once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp:40,Integrability,interface,interface,40,// Implementation of the MCObjectWriter interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp:99,Availability,avail,available,99,"// Reserved; // The record count is the number of logical records. In principle, this value; // is available as OS.logicalRecords(). However, some tools rely on this field; // being zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp:50,Testability,log,logical,50,"// Reserved; // The record count is the number of logical records. In principle, this value; // is available as OS.logicalRecords(). However, some tools rely on this field; // being zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp:115,Testability,log,logicalRecords,115,"// Reserved; // The record count is the number of logical records. In principle, this value; // is available as OS.logicalRecords(). However, some tools rely on this field; // being zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:16,Modifiability,variab,variable,16,"// If this is a variable, then recursively evaluate now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:46,Performance,load,load,46,/// writeSegmentLoadCommand - Write a segment load command.; ///; /// \param NumSections The number of sections in this segment.; /// \param SectionDataSize The total size of the sections.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:22,Deployability,update,update,22,// FIXME: Should this update Data as well?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:345,Availability,error,errors,345,"// This is the point where 'as' creates actual symbols for indirect symbols; // (in the following two passes). It would be easier for us to do this sooner; // when we see the attribute, but that makes getting the order in the symbol; // table much more complicated than it is worth.; //; // FIXME: Revisit this when the dust settles.; // Report errors for use of .indirect_symbol not in a symbol pointer section; // or stub section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:419,Testability,stub,stub,419,"// This is the point where 'as' creates actual symbols for indirect symbols; // (in the following two passes). It would be easier for us to do this sooner; // when we see the attribute, but that makes getting the order in the symbol; // table much more complicated than it is worth.; //; // FIXME: Revisit this when the dust settles.; // Report errors for use of .indirect_symbol not in a symbol pointer section; // or stub section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:40,Testability,stub,stubs,40,// Then lazy symbol pointers and symbol stubs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:7,Usability,simpl,simple,7,"// The simple (Darwin, except on x86_64) way of dealing with this was to; // assume that any reference to a temporary symbol *must* be a temporary; // symbol in the same atom, unless the sections differ. Therefore, any PCrel; // relocation to a temporary symbol (in the same section) is fully; // resolved. This also works in conjunction with absolutized .set, which; // requires the compiler to use .set to absolutize the differences between; // symbols which the compiler knows to be assembly time constants, so we; // don't need to worry about considering symbol differences fully resolved.; //; // If the file isn't using sub-sections-via-symbols, we can make the; // same assumptions about any symbol that we normally make about; // assembler locals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:57,Performance,load,load,57,"// The section data starts after the header, the segment load command (and; // section headers) and the symbol table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:11,Deployability,deploy,deployment,11,"// Add the deployment target version info load command size, if used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:42,Performance,load,load,42,"// Add the deployment target version info load command size, if used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:39,Performance,load,load,39,"// Add the target variant version info load command size, if used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:24,Performance,load,load,24,"// Add the data-in-code load command size, if used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:15,Performance,load,load,15,"// Add the loh load command size, if used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:24,Performance,load,load,24,"// Add the symbol table load command sizes, if used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:25,Performance,load,load,25,// Add the linker option load commands sizes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:84,Integrability,depend,dependent,84,// The section data is padded to pointer size bytes.; //; // FIXME: Is this machine dependent?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:50,Performance,load,load,50,"// Write the prolog, starting with the header and load command...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:56,Availability,avail,available,56,"// Write out the deployment target information, if it's available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:17,Deployability,deploy,deployment,17,"// Write out the deployment target information, if it's available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:26,Performance,load,load,26,"// Write the data-in-code load command, if used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:17,Performance,load,load,17,"// Write the loh load command, if used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:26,Performance,load,load,26,"// Write the symbol table load command, if used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:28,Performance,load,load,28,// Write the linker options load commands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmInfoXCOFF.cpp:37,Safety,avoid,avoid,37,// Use .vbyte for data definition to avoid directives that apply an implicit; // alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAsmInfoXCOFF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmInfoXCOFF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp:21,Integrability,Interface,Interface,21,/// @name MCStreamer Interface; /// @{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp:35,Integrability,depend,depends,35,"// .tbss sym, size, align; // This depends that the symbol has already been mangled from the original,; // e.g. _a.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp:92,Availability,down,down,92,"// We couldn't handle the requested integer size so we fallback by breaking; // the request down into several, smaller, integers.; // Since sizes greater or equal to ""Size"" are invalid, we use the greatest; // power of 2 that is less than ""Size"" as our largest piece of granularity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp:210,Energy Efficiency,power,power,210,"// We couldn't handle the requested integer size so we fallback by breaking; // the request down into several, smaller, integers.; // Since sizes greater or equal to ""Size"" are invalid, we use the greatest; // power of 2 that is less than ""Size"" as our largest piece of granularity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp:46,Energy Efficiency,power,power,46,// The size of our partial emission must be a power of two less than; // Size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp:37,Energy Efficiency,power,power,37,"// Some assemblers don't support non-power of two alignments, so we always; // emit alignments as a power of two if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp:100,Energy Efficiency,power,power,100,"// Some assemblers don't support non-power of two alignments, so we always; // emit alignments as a power of two if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp:7,Energy Efficiency,power,power,7,// Non-power of two alignment. This is not widely supported by assemblers.; // FIXME: Parameterize this based on MAI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp:86,Modifiability,Parameteriz,Parameterize,86,// Non-power of two alignment. This is not widely supported by assemblers.; // FIXME: Parameterize this based on MAI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp:3,Security,Validat,Validate,3,// Validate the directive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp:80,Availability,error,error,80,// Do nothing if no frame is open. MCStreamer should've already reported an; // error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp:32,Usability,GUID,GUIDmain,32,// Emit inline stack like; // @ GUIDmain:3 @ GUIDCaller:1 @ GUIDDirectCaller:11,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp:45,Usability,GUID,GUIDCaller,45,// Emit inline stack like; // @ GUIDmain:3 @ GUIDCaller:1 @ GUIDDirectCaller:11,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp:60,Usability,GUID,GUIDDirectCaller,60,// Emit inline stack like; // @ GUIDmain:3 @ GUIDCaller:1 @ GUIDDirectCaller:11,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp:287,Availability,error,errors,287,"// end anonymous namespace; // FIXME FIXME FIXME: There are number of places in this file where we convert; // what is a 64-bit assembler value used for computation into a value in the; // object file, which may truncate it. We should detect that truncation where; // invalid and report errors back.; /* *** */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp:235,Safety,detect,detect,235,"// end anonymous namespace; // FIXME FIXME FIXME: There are number of places in this file where we convert; // what is a 64-bit assembler value used for computation into a value in the; // object file, which may truncate it. We should detect that truncation where; // invalid and report errors back.; /* *** */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp:3,Performance,Cache,Cache,3,// Cache it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp:209,Availability,error,error,209,"// FIXME: This code has some duplication with recordRelocation. We should; // probably merge the two into a single callback that tries to evaluate a; // fixup and records a relocation if one is needed.; // On error claim to have completely evaluated the fixup, to prevent any; // further processing from being done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp:474,Performance,optimiz,optimize,474,"// If bundling is enabled and this fragment has instructions in it, it has to; // obey the bundling restrictions. With padding, we'll have:; //; //; // BundlePadding; // |||; // -------------------------------------; // Prev |##########| F |; // -------------------------------------; // ^; // |; // F->Offset; //; // The fragment's offset will point to after the padding, and its computed; // size won't include the padding.; //; // When the -mc-relax-all flag is used, we optimize bundling by writting the; // padding directly into fragments when the instructions are emitted inside; // the streamer. When the fragment is larger than the bundle size, we need to; // ensure that it's bundle aligned. This means that if we end up with; // multiple fragments, we must emit bundle padding between fragments.; //; // "".align N"" is an example of a directive that introduces multiple; // fragments. We could add a special case to handle "".align N"" by emitting; // within-fragment padding (which would produce less padding when N is less; // than the bundle size), but for now we don't.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp:8,Modifiability,variab,variable,8,// This variable (and its dummy usage) is to participate in the assert at; // the end of the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp:64,Testability,assert,assert,64,// This variable (and its dummy usage) is to participate in the assert at; // the end of the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp:15,Availability,error,error,15,"// FIXME: This error shouldn't actually occur (the front end should emit; // multiple .align directives to enforce the semantics it wants), but is; // severe enough that we want to report it. How to handle this?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp:43,Energy Efficiency,reduce,reduce,43,"// Duplicate V into Data as byte vector to reduce number of; // writes done. As such, do endian conversion here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp:64,Usability,simpl,simplifies,64,"// Create dummy fragments to eliminate any empty sections, this simplifies; // layout.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp:40,Integrability,depend,depend,40,"// Size of fragments in one section can depend on the size of fragments in; // another. If any fragment has changed size, we have to re-layout (and; // as a result possibly further relax) all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp:39,Performance,perform,perform,39,"// Allow the object writer a chance to perform post-layout binding (for; // example, to set the index fields in the symbol data).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp:106,Safety,avoid,avoid,106,"// FIXME-PERF: We could immediately lower out instructions if we can tell; // they are fully resolved, to avoid retesting on later passes.; // Relax the fragment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp:50,Energy Efficiency,allocate,allocated,50,// Return false if this function info was already allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp:19,Energy Efficiency,allocate,allocated,19,"// Mark this as an allocated normal function, and leave the rest alone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp:50,Energy Efficiency,allocate,allocated,50,// Return false if this function info was already allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp:35,Security,checksum,checksums,35,// Do nothing if there are no file checksums. Microsoft's linker rejects empty; // CodeView substreams.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp:128,Modifiability,variab,variable,128,// Emit an array of FileChecksum entries. We index into this table using the; // user-provided file number. Each entry may be a variable number of bytes; // determined by the checksum kind and size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp:175,Security,checksum,checksum,175,// Emit an array of FileChecksum entries. We index into this table using the; // user-provided file number. Each entry may be a variable number of bytes; // determined by the checksum kind and size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp:21,Security,checksum,checksum,21,"// One byte each for checksum size and kind, then align to 4 bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp:21,Security,checksum,checksum,21,// One byte each for checksum size and kind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp:15,Security,checksum,checksum,15,// There is no checksum. Therefore zero the next two fields and align; // back to 4 bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp:10,Security,checksum,checksum,10,"// Output checksum table offset of the given file number. It is possible that; // not all files have been registered yet, and so the offset cannot be; // calculated. In this case a symbol representing the offset is emitted, and; // the value of this symbol will be fixed up at a later time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp:3,Usability,Clear,Clear,3,// Clear old contents if we went through relaxation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp:94,Deployability,update,update,94,"// Skip this .cv_loc if we have an open range and this isn't a meaningful; // source location update. The current table format does not support column; // info, so we can skip updates for those.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp:176,Deployability,update,updates,176,"// Skip this .cv_loc if we have an open range and this isn't a meaningful; // source location update. The current table format does not support column; // info, so we can skip updates for those.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp:9,Availability,down,down,9,// Write down each range where the variable is defined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp:35,Modifiability,variab,variable,35,// Write down each range where the variable is defined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp:119,Modifiability,variab,variable,119,// Make space for a fixup that will eventually have a section relative; // relocation pointing at the offset where the variable becomes live.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp:38,Availability,down,down,38,// Fixup for section index.; // Write down the range's extent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp:29,Energy Efficiency,allocate,allocated,29,"// NOTE: The symbols are all allocated out of a bump pointer allocator,; // we don't need to free them here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp:187,Availability,error,error,187,"// We unique sections by their segment/section pair. The returned section; // may not have the same flags as the requested section, if so this should be; // diagnosed by the client as an error.; // Form the name to look up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp:38,Performance,Cache,CachedName,38,// QualName->getUnqualifiedName() and CachedName are the same except when; // CachedName contains invalid character(s) such as '$' for an XCOFF symbol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp:78,Performance,Cache,CachedName,78,// QualName->getUnqualifiedName() and CachedName are the same except when; // CachedName contains invalid character(s) such as '$' for an XCOFF symbol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp:154,Availability,alive,alive,154,// Grab the name from the StringMap. Since the Section is going to keep a; // copy of this StringRef we need to make sure the underlying string stays; // alive as long as we need it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp:162,Availability,error,error,162,"/// getDwarfFile - takes a file name and number to place in the dwarf file and; /// directory tables. If the file number has already been allocated it is an; /// error and zero is returned and the client reports the error, else the; /// allocated file number is returned. The file numbers may be in any order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp:216,Availability,error,error,216,"/// getDwarfFile - takes a file name and number to place in the dwarf file and; /// directory tables. If the file number has already been allocated it is an; /// error and zero is returned and the client reports the error, else the; /// allocated file number is returned. The file numbers may be in any order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp:138,Energy Efficiency,allocate,allocated,138,"/// getDwarfFile - takes a file name and number to place in the dwarf file and; /// directory tables. If the file number has already been allocated it is an; /// error and zero is returned and the client reports the error, else the; /// allocated file number is returned. The file numbers may be in any order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp:237,Energy Efficiency,allocate,allocated,237,"/// getDwarfFile - takes a file name and number to place in the dwarf file and; /// directory tables. If the file number has already been allocated it is an; /// error and zero is returned and the client reports the error, else the; /// allocated file number is returned. The file numbers may be in any order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp:53,Safety,avoid,avoid,53,"/// Remove empty sections from SectionsForRanges, to avoid generating; /// useless debug info for them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp:85,Availability,Error,Error,85,//===----------------------------------------------------------------------===//; // Error Reporting; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp:10,Usability,Simpl,Simplify,10,"// FIXME: Simplify these by combining InlineSrcMgr & SrcMgr.; // For MC-only execution, only SrcMgr is used;; // For non MC-only execution, InlineSrcMgr is only ctor'd if there is; // inline asm in the IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:21,Availability,error,error,21,"// TODO: report this error, but really only once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:3,Usability,clear,clear,3,// clear DwarfLocSeen saying the current .loc info is now used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:19,Integrability,rout,routine,19,//; // This helper routine returns an expression of End - Start - IntVal .; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:19,Integrability,rout,routine,19,//; // This helper routine returns an expression of Start + IntVal .; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:176,Security,checksum,checksums,176,"// The file format, which is the inline null-terminated filename and a; // directory index. We don't track file size/timestamp so don't emit them; // in the v5 table. Emit MD5 checksums and source if we have them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:131,Deployability,update,update,131,// maximum_operations_per_instruction; // For non-VLIW architectures this field is always 1.; // FIXME: VLIW architectures need to update this field accordingly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:59,Integrability,depend,depending,59,// Put out the directory and file tables. The formats vary depending on; // the version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:54,Security,checksum,checksum,54,"// Keep track of whether any or all files have an MD5 checksum.; // If any files have embedded source, they all must.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:63,Energy Efficiency,allocate,allocated,63,// File numbers start with 1 and/or after any file numbers; // allocated by inline-assembler .file directives.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:12,Availability,error,error,12,// It is an error to see the same number more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:14,Energy Efficiency,allocate,allocated,14,// return the allocated FileNumber.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:3,Safety,Avoid,Avoid,3,// Avoid overflow when addr_delta is large.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:62,Usability,simpl,simpler,62,"// If we only have one non-empty code section, we can use the simpler; // AT_low_pc and AT_high_pc attributes.; // Find the first (and only) non-empty text section",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:35,Availability,avail,available,35,// Emit the compact unwind info if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDXContainerWriter.cpp:33,Security,hash,hash,33,// Write 16-bytes of 0's for the hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCDXContainerWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDXContainerWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCELFStreamer.cpp:131,Availability,error,error-prone,131,"// For `.weak x; .global x`, GNU as sets the binding to STB_WEAK while we; // traditionally set the binding to STB_GLOBAL. This is error-prone, so we; // error on such cases. Note, we also disallow changed binding from .local.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCELFStreamer.cpp:154,Availability,error,error,154,"// For `.weak x; .global x`, GNU as sets the binding to STB_WEAK while we; // traditionally set the binding to STB_GLOBAL. This is error-prone, so we; // error on such cases. Note, we also disallow changed binding from .local.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCELFStreamer.cpp:128,Availability,error,error,128,"// For `.global x; .weak x`, both MC and GNU as set the binding to STB_WEAK.; // We emit a warning for now but may switch to an error in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCELFStreamer.cpp:131,Availability,error,error,131,"// A fragment can only have one Subtarget, and when bundling is enabled we; // sometimes need to use the same fragment. We give an error if there; // are conflicting Subtargets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCELFStreamer.cpp:3,Performance,Optimiz,Optimize,3,// Optimize memory usage by emitting the instruction to a; // MCCompactEncodedInstFragment when not in a bundle-locked group and; // there are no fixups registered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp:3,Usability,Clear,Clear,3,// Clear the symbol expr pointers to indicate we have folded these; // operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp:18,Availability,avail,available,18,"// When layout is available, we can generally compute the difference using the; // getSymbolOffset path, which also avoids the possible slow fragment walk.; // However, linker relaxation may cause incorrect fold of A-B if A and B are; // separated by a linker-relaxable instruction. If the section contains; // instructions and InSet is false (not expressions in directive like; // .size/.fill), disable the fast path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp:116,Safety,avoid,avoids,116,"// When layout is available, we can generally compute the difference using the; // getSymbolOffset path, which also avoids the possible slow fragment walk.; // However, linker relaxation may cause incorrect fold of A-B if A and B are; // separated by a linker-relaxable instruction. If the section contains; // instructions and InSet is false (not expressions in directive like; // .size/.fill), disable the fast path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp:84,Safety,avoid,avoid,84,// One of the symbol involved is part of a fragment being laid out. Quit now; // to avoid a self loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp:681,Availability,redundant,redundant,681,"/// Evaluate the result of an add between (conceptually) two MCValues.; ///; /// This routine conceptually attempts to construct an MCValue:; /// Result = (Result_A - Result_B + Result_Cst); /// from two MCValue's LHS and RHS where; /// Result = LHS + RHS; /// and; /// Result = (LHS_A - LHS_B + LHS_Cst) + (RHS_A - RHS_B + RHS_Cst).; ///; /// This routine attempts to aggressively fold the operands such that the result; /// is representable in an MCValue, but may not always succeed.; ///; /// \returns True on success, false if the result is not representable in an; /// MCValue.; /// NOTE: It is really important to have both the Asm and Layout arguments.; /// They might look redundant, but this function can be used before layout; /// is done (see the object streamer for example) and having the Asm argument; /// lets us avoid relaxations early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp:86,Integrability,rout,routine,86,"/// Evaluate the result of an add between (conceptually) two MCValues.; ///; /// This routine conceptually attempts to construct an MCValue:; /// Result = (Result_A - Result_B + Result_Cst); /// from two MCValue's LHS and RHS where; /// Result = LHS + RHS; /// and; /// Result = (LHS_A - LHS_B + LHS_Cst) + (RHS_A - RHS_B + RHS_Cst).; ///; /// This routine attempts to aggressively fold the operands such that the result; /// is representable in an MCValue, but may not always succeed.; ///; /// \returns True on success, false if the result is not representable in an; /// MCValue.; /// NOTE: It is really important to have both the Asm and Layout arguments.; /// They might look redundant, but this function can be used before layout; /// is done (see the object streamer for example) and having the Asm argument; /// lets us avoid relaxations early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp:349,Integrability,rout,routine,349,"/// Evaluate the result of an add between (conceptually) two MCValues.; ///; /// This routine conceptually attempts to construct an MCValue:; /// Result = (Result_A - Result_B + Result_Cst); /// from two MCValue's LHS and RHS where; /// Result = LHS + RHS; /// and; /// Result = (LHS_A - LHS_B + LHS_Cst) + (RHS_A - RHS_B + RHS_Cst).; ///; /// This routine attempts to aggressively fold the operands such that the result; /// is representable in an MCValue, but may not always succeed.; ///; /// \returns True on success, false if the result is not representable in an; /// MCValue.; /// NOTE: It is really important to have both the Asm and Layout arguments.; /// They might look redundant, but this function can be used before layout; /// is done (see the object streamer for example) and having the Asm argument; /// lets us avoid relaxations early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp:681,Safety,redund,redundant,681,"/// Evaluate the result of an add between (conceptually) two MCValues.; ///; /// This routine conceptually attempts to construct an MCValue:; /// Result = (Result_A - Result_B + Result_Cst); /// from two MCValue's LHS and RHS where; /// Result = LHS + RHS; /// and; /// Result = (LHS_A - LHS_B + LHS_Cst) + (RHS_A - RHS_B + RHS_Cst).; ///; /// This routine attempts to aggressively fold the operands such that the result; /// is representable in an MCValue, but may not always succeed.; ///; /// \returns True on success, false if the result is not representable in an; /// MCValue.; /// NOTE: It is really important to have both the Asm and Layout arguments.; /// They might look redundant, but this function can be used before layout; /// is done (see the object streamer for example) and having the Asm argument; /// lets us avoid relaxations early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp:828,Safety,avoid,avoid,828,"/// Evaluate the result of an add between (conceptually) two MCValues.; ///; /// This routine conceptually attempts to construct an MCValue:; /// Result = (Result_A - Result_B + Result_Cst); /// from two MCValue's LHS and RHS where; /// Result = LHS + RHS; /// and; /// Result = (LHS_A - LHS_B + LHS_Cst) + (RHS_A - RHS_B + RHS_Cst).; ///; /// This routine attempts to aggressively fold the operands such that the result; /// is representable in an MCValue, but may not always succeed.; ///; /// \returns True on success, false if the result is not representable in an; /// MCValue.; /// NOTE: It is really important to have both the Asm and Layout arguments.; /// They might look redundant, but this function can be used before layout; /// is done (see the object streamer for example) and having the Asm argument; /// lets us avoid relaxations early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp:15,Integrability,rout,routine,15,"// FIXME: This routine (and other evaluation parts) are *incredibly* sloppy; // about dealing with modifiers. This will ultimately bite us, one day.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp:37,Modifiability,variab,variable,37,// Evaluate recursively if this is a variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp:179,Availability,error,error,179,// FIXME: This is small hack. Given; // a = b + 4; // .long a; // the OS X assembler will completely drop the 4. We should probably; // include it in the relocation or produce an error if that is not; // possible.; // Allow constant expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp:12,Safety,avoid,avoids,12,// The cast avoids undefined behavior if the constant is INT64_MIN.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp:36,Safety,avoid,avoids,36,// Negate RHS and add.; // The cast avoids undefined behavior if the constant is INT64_MIN.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp:288,Availability,error,error,288,"// Handle division by zero. gas just emits a warning and keeps going,; // we try to be stricter.; // FIXME: Currently the caller of this function has no way to understand; // we're bailing out because of 'division by zero'. Therefore, it will; // emit a 'expected relocatable expression' error. It would be nice to; // change this code to emit a better diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp:37,Availability,avail,available,37,"// Fragment already valid, offset is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp:45,Modifiability,variab,variable,45,// Simple getSymbolOffset helper for the non-variable case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp:3,Usability,Simpl,Simple,3,// Simple getSymbolOffset helper for the non-variable case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp:14,Modifiability,variab,variable,14,"// If SD is a variable, evaluate it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp:150,Modifiability,variab,variables,150,"// FIXME: On most platforms, `Target`'s component symbols are labels from; // having been simplified during evaluation, but on Mach-O they can be; // variables due to PR19203. This, and the line below for `B` can be; // restored to call `getLabelOffset` when PR19203 is fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp:90,Usability,simpl,simplified,90,"// FIXME: On most platforms, `Target`'s component symbols are labels from; // having been simplified during evaluation, but on Mach-O they can be; // variables due to PR19203. This, and the line below for `B` can be; // restored to call `getLabelOffset` when PR19203 is fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp:477,Usability,simpl,simplicity,477,"// Three possibilities here:; //; // A) The fragment just happens to end at a bundle boundary, so we're good.; // B) The fragment ends before the current bundle boundary: pad it just; // enough to reach the boundary.; // C) The fragment ends after the current bundle boundary: pad it until it; // reaches the end of the next bundle boundary.; //; // Note: this code could be made shorter with some modulo trickery, but it's; // intentionally kept in its more explicit form for simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCInstPrinter.cpp:11,Testability,test,tests,11,"// Feature tests are special, they don't consume operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCInstPrinter.cpp:15,Testability,test,tests,15,"// For feature tests where just one feature is required in a list, set the; // predicate result bit to whether the expression will return true, and only; // return the real result at the end of list marker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCInstPrinter.cpp:3,Testability,Test,Test,3,// Test all conditions for this pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCMachOStreamer.cpp:21,Integrability,Interface,Interface,21,/// @name MCStreamer Interface; /// @{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCMachOStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCMachOStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCMachOStreamer.cpp:45,Usability,clear,cleared,45,"// This causes the reference type flag to be cleared. Darwin 'as' was ""trying""; // to clear the weak reference and weak definition bits too, but the; // implementation was buggy. For now we just try to match 'as', for; // diffability.; //; // FIXME: Cleanup this code, these bits should be emitted based on semantic; // properties, not on the order of definition, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCMachOStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCMachOStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCMachOStreamer.cpp:86,Usability,clear,clear,86,"// This causes the reference type flag to be cleared. Darwin 'as' was ""trying""; // to clear the weak reference and weak definition bits too, but the; // implementation was buggy. For now we just try to match 'as', for; // diffability.; //; // FIXME: Cleanup this code, these bits should be emitted based on semantic; // properties, not on the order of definition, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCMachOStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCMachOStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCMachOStreamer.cpp:20,Usability,clear,clears,20,"// This effectively clears the undefined lazy bit, in Darwin 'as', although; // it isn't very consistent because it implements this as part of symbol; // lookup.; //; // FIXME: Cleanup this code, these bits should be emitted based on semantic; // properties, not on the order of definition, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCMachOStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCMachOStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCMachOStreamer.cpp:377,Deployability,update,update,377,"// The AddrSig section uses a series of relocations to refer to the symbols that; // should be considered address-significant. The only interesting content of; // these relocations is their symbol; the type, length etc will be ignored by; // the linker. The reason we are not referring to the symbol indices directly is; // that those indices will be invalidated by tools that update the symbol table.; // Symbol relocations OTOH will have their indices updated by e.g. llvm-strip.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCMachOStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCMachOStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCMachOStreamer.cpp:454,Deployability,update,updated,454,"// The AddrSig section uses a series of relocations to refer to the symbols that; // should be considered address-significant. The only interesting content of; // these relocations is their symbol; the type, length etc will be ignored by; // the linker. The reason we are not referring to the symbol indices directly is; // that those indices will be invalidated by tools that update the symbol table.; // Symbol relocations OTOH will have their indices updated by e.g. llvm-strip.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCMachOStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCMachOStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCNullStreamer.cpp:21,Integrability,Interface,Interface,21,/// @name MCStreamer Interface; /// @{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCNullStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCNullStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectFileInfo.cpp:24,Energy Efficiency,power,powerpc,24,"// If the target is not powerpc, map the coal sections to the non-coal; // sections.; //; // ""__TEXT/__textcoal_nt"" => section ""__TEXT/__text""; // ""__TEXT/__const_coal"" => section ""__TEXT/__const""; // ""__DATA/__datacoal_nt"" => section ""__DATA/__data""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCObjectFileInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectFileInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp:60,Integrability,Interface,Interface,60,"//===- lib/MC/MCObjectStreamer.cpp - Object File MCStreamer Interface -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp:21,Performance,optimiz,optimization,21,"// As a compile-time optimization, avoid allocating and evaluating an MCExpr; // tree for (Hi - Lo) when Hi and Lo are offsets into the same fragment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp:35,Safety,avoid,avoid,35,"// As a compile-time optimization, avoid allocating and evaluating an MCExpr; // tree for (Hi - Lo) when Hi and Lo are offsets into the same fragment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp:3,Safety,Avoid,Avoid,3,// Avoid fixups when possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp:39,Safety,avoid,avoid,39,// We need to create a local symbol to avoid relocations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp:86,Performance,queue,queue,86,"// If there is a current fragment, mark the symbol as pointing into it.; // Otherwise queue the label and set its fragment pointer when we emit the; // next fragment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp:3,Security,Validat,Validate,3,// Validate the directive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp:3,Deployability,Update,Update,3,// Update the maximum alignment on the current section if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp:33,Availability,error,errors,33,// Emit now if we can for better errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp:32,Deployability,integrat,integrated,32,// TODO: add additional info to integrated assembler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp:32,Integrability,integrat,integrated,32,// TODO: add additional info to integrated assembler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp:3,Deployability,Update,Update,3,// Update any remaining pending labels with empty data fragments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp:12,Usability,GUID,GUID,12,// Emit the GUID of the split function that the sentinel probe represents.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp:55,Usability,GUID,GUID,55,"// When it comes here, the input look like:; // Probe: GUID of C, ...; // InlineStack: [88, A], [66, B]; // which means, Function A inlines function B at call site with a probe id of; // 88, and B inlines C at probe 66. The tri-tree expects a tree path like {[0,; // A], [88, B], [66, C]} to locate the tree node where the probe should be; // added. Note that the edge [0, A] means A is the top-level function we are; // emitting probes for.; // Make a [0, A] edge.; // An empty inline stack means the function that the probe originates from; // is a top-level function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp:59,Usability,GUID,GUID,59,// Make an edge by using the previous probe id and current GUID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp:26,Usability,GUID,GUID,26,// Emit probes grouped by GUID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp:8,Usability,Guid,Guid,8,// Emit Guid,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp:26,Usability,GUID,GUID,26,"// Emit probes grouped by GUID.; // Emit sorted descendant. InlineSite is unique for each pair, so there; // will be no ordering of Inlinee based on MCPseudoProbeInlineTree*",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp:160,Security,Hash,Hash,160,"// The pseudo_probe_desc section has a format like:; // .section .pseudo_probe_desc,"""",@progbits; // .quad -5182264717993193164 // GUID; // .quad 4294967295 // Hash; // .uleb 3 // Name size; // .ascii ""foo"" // Name; // .quad -2624081020897602054; // .quad 174696971957; // .uleb 34; // .ascii ""main""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp:131,Usability,GUID,GUID,131,"// The pseudo_probe_desc section has a format like:; // .section .pseudo_probe_desc,"""",@progbits; // .quad -5182264717993193164 // GUID; // .quad 4294967295 // Hash; // .uleb 3 // Name size; // .ascii ""foo"" // Name; // .quad -2624081020897602054; // .quad 174696971957; // .uleb 34; // .ascii ""main""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp:8,Usability,guid,guid,8,// Read guid,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp:58,Usability,GUID,GUID,58,"// For sentinel probe, the addr field actually stores the GUID of the; // split function. Convert it to the real address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp:141,Availability,down,downwards,141,// For now we assume all probe encoding should be either based on; // leading probe address or function start address.; // The scheme is for downwards compatibility.; // TODO: retire this scheme once compatibility is no longer an issue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp:468,Availability,down,down,468,"// Disabling the assert and returning first call probe seen so far.; // Subsequent call probes, if any, are ignored. Due to the the way; // .pseudo_probe section is decoded, probes of the same-named independent; // static functions are merged thus multiple call probes may be seen for a; // callsite. This should only happen to compiler-generated statics, with; // -funique-internal-linkage-names where user statics get unique names.; //; // TODO: re-enable or narrow down the assert to static functions only.; //; // assert(!CallProbe &&; // ""There should be only one call probe corresponding to address ""; // ""which is a callsite."");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp:17,Testability,assert,assert,17,"// Disabling the assert and returning first call probe seen so far.; // Subsequent call probes, if any, are ignored. Due to the the way; // .pseudo_probe section is decoded, probes of the same-named independent; // static functions are merged thus multiple call probes may be seen for a; // callsite. This should only happen to compiler-generated statics, with; // -funique-internal-linkage-names where user statics get unique names.; //; // TODO: re-enable or narrow down the assert to static functions only.; //; // assert(!CallProbe &&; // ""There should be only one call probe corresponding to address ""; // ""which is a callsite."");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp:477,Testability,assert,assert,477,"// Disabling the assert and returning first call probe seen so far.; // Subsequent call probes, if any, are ignored. Due to the the way; // .pseudo_probe section is decoded, probes of the same-named independent; // static functions are merged thus multiple call probes may be seen for a; // callsite. This should only happen to compiler-generated statics, with; // -funique-internal-linkage-names where user statics get unique names.; //; // TODO: re-enable or narrow down the assert to static functions only.; //; // assert(!CallProbe &&; // ""There should be only one call probe corresponding to address ""; // ""which is a callsite."");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp:518,Testability,assert,assert,518,"// Disabling the assert and returning first call probe seen so far.; // Subsequent call probes, if any, are ignored. Due to the the way; // .pseudo_probe section is decoded, probes of the same-named independent; // static functions are merged thus multiple call probes may be seen for a; // callsite. This should only happen to compiler-generated statics, with; // -funique-internal-linkage-names where user statics get unique names.; //; // TODO: re-enable or narrow down the assert to static functions only.; //; // assert(!CallProbe &&; // ""There should be only one call probe corresponding to address ""; // ""which is a callsite."");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSchedule.cpp:24,Energy Efficiency,Schedul,Scheduling,24,"//===- MCSchedule.cpp - Scheduling ------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the default scheduling model.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSchedule.cpp:413,Energy Efficiency,schedul,scheduling,413,"//===- MCSchedule.cpp - Scheduling ------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the default scheduling model.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSchedule.cpp:33,Performance,latency,latency,33,// Lookup the definition's write latency in SubtargetInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSchedule.cpp:37,Performance,latency,latency,37,// Early exit if we found an invalid latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSchedule.cpp:138,Energy Efficiency,schedul,schedule,138,"// If no throughput value was calculated, assume that we can execute at the; // maximum issue width scaled by number of micro-ops for the schedule class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSchedule.cpp:9,Performance,throughput,throughput,9,"// If no throughput value was calculated, assume that we can execute at the; // maximum issue width scaled by number of micro-ops for the schedule class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSection.cpp:111,Availability,down,downgrade,111,"// If any of the directives is an align_to_end directive, the whole nested; // group is align_to_end. So don't downgrade from align_to_end to just locked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp:136,Integrability,synchroniz,synchronized,136,/// SectionTypeDescriptors - These are strings that describe the various section; /// types. This *must* be kept in order with and stay synchronized with the; /// section type list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp:47,Testability,stub,stub,47,// used if section has no attributes but has a stub size,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp:8,Usability,clear,clear,8,"// Yep, clear it and print it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp:42,Testability,stub,stub,42,// S_SYMBOL_STUBS always require a symbol stub size specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp:63,Testability,stub,stub,63,"// Okay, we've parsed the section attributes, see if we have a stub size spec.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp:42,Testability,stub,stub,42,// S_SYMBOL_STUBS always require a symbol stub size specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp:16,Testability,stub,stub,16,"// If we have a stub size spec, we must have a sectiontype of S_SYMBOL_STUBS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp:15,Testability,stub,stub,15,// Convert the stub size from a string to an integer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSectionXCOFF.cpp:257,Security,access,accessible,257,"// Common symbols and local zero-initialized symbols for TLS and Non-TLS are; // eligible for .bss/.tbss csect, getKind().isThreadBSS() is used to cover; // TLS common and zero-initialized local symbols since linkage type (in the; // GlobalVariable) is not accessible in this class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSectionXCOFF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSectionXCOFF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSectionXCOFF.cpp:154,Modifiability,variab,variable,154,// Don't have to print a directive for switching to section for commons and; // zero-initialized TLS data. The '.comm' and '.lcomm' directives of the; // variable will create the needed csect.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSectionXCOFF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSectionXCOFF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp:50,Safety,avoid,avoids,50,/// EmitIntValue - Special case of EmitValue that avoids the client having to; /// pass in a MCExpr for constant integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp:64,Safety,avoid,avoids,64,/// EmitULEB128IntValue - Special case of EmitULEB128Value that avoids the; /// client having to pass in a MCExpr for constant integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp:64,Safety,avoid,avoids,64,/// EmitSLEB128IntValue - Special case of EmitSLEB128Value that avoids the; /// client having to pass in a MCExpr for constant integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp:10,Availability,Error,Error,10,// FIXME: Error if there is no matching cfi_remember_state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp:46,Performance,load,load,46,// Mac Catalyst always uses the build version load command.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp:43,Performance,load,load,43,// DriverKit always uses the build version load command.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp:38,Performance,load,load,38,// XROS always uses the build version load command.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSubtargetInfo.cpp:63,Usability,clear,clear,63,"/// For each feature that (transitively) implies this feature, clear it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSubtargetInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSubtargetInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSubtargetInfo.cpp:39,Usability,clear,clear,39,"// For each feature that implies this, clear it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSubtargetInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSubtargetInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSubtargetInfo.cpp:14,Modifiability,variab,variable,14,// the static variable ensures that the help information only gets; // printed once even though a target machine creates multiple subtargets,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSubtargetInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSubtargetInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSubtargetInfo.cpp:14,Modifiability,variab,variable,14,// the static variable ensures that the help information only gets; // printed once even though a target machine creates multiple subtargets,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSubtargetInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSubtargetInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSubtargetInfo.cpp:39,Usability,clear,clear,39,"// For each feature that implies this, clear it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSubtargetInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSubtargetInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSubtargetInfo.cpp:9,Availability,error,error,9,// Don't error if the user asked for help.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSubtargetInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSubtargetInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSymbol.cpp:66,Energy Efficiency,allocate,allocate,66,// We may need more space for a Name to account for alignment. So allocate; // space for the storage type and not the name pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSymbol.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSymbol.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSymbol.cpp:7,Safety,safe,safety,7,"// For safety, ensure that the alignment of a pointer is enough for an; // MCSymbol. This also ensures we don't need padding between the name and; // symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCSymbol.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSymbol.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp:3,Deployability,Update,Update,3,"// Update info about the previous instruction, for detecting if; // the next one can be made a UOP_SaveNext",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp:51,Safety,detect,detecting,51,"// Update info about the previous instruction, for detecting if; // the next one can be made a UOP_SaveNext",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp:156,Energy Efficiency,allocate,allocate,156,// Allocations this large can't be represented in packed unwind (and; // usually don't fit the canonical form anyway because we need to use; // __chkstk to allocate the stack space).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp:516,Safety,safe,safe,516,"// There's an inconsistency regarding packed unwind info with homed; // parameters; according to the documentation, the epilog shouldn't have; // the same corresponding nops (and thus, to set the H bit, we should; // require an epilog which isn't exactly symmetrical - we shouldn't accept; // an exact mirrored epilog for those cases), but in practice,; // RtlVirtualUnwind behaves as if it does expect the epilogue to contain; // the same nops. See https://github.com/llvm/llvm-project/issues/54879.; // To play it safe, don't produce packed unwind info with homed parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp:3,Usability,Clear,Clear,3,"// Clear the unwind codes in the EpilogMap, so that they don't get output; // in ARM64EmitUnwindInfoForSegment().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp:3,Usability,Clear,Clear,3,"// Clear the unwind codes in the EpilogMap, so that they don't get output; // in ARM64EmitUnwindInfoForSegment().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp:255,Testability,test,testing,255,"// If a segment has neither prolog nor epilog, ""With full .xdata record,; // Epilog Count = 1. Epilog Start Index points to end_c.""; // https://docs.microsoft.com/en-us/cpp/build/arm64-exception-handling#function-fragments; // TODO: We can remove this if testing shows zero epilog scope is ok with; // MS unwinder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp:3,Modifiability,Extend,Extended,3,"// Extended Code Words, Extended Epilog Count",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp:24,Modifiability,Extend,Extended,24,"// Extended Code Words, Extended Epilog Count",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp:364,Availability,error,error,364,"// FIXME: GetAbsDifference tries to compute the length of the function; // immediately, before the whole file is emitted, but in general; // that's impossible: the size in bytes of certain assembler directives; // like .align and .fill is not known until the whole file is parsed and; // relaxations are applied. Currently, GetAbsDifference fails with a fatal; // error in that case. (We mostly don't hit this because inline assembly; // specifying those directives is rare, and we don't normally try to; // align loops on AArch64.); //; // There are two potential approaches to delaying the computation. One,; // we could emit something like "".word (endfunc-beginfunc)/4+0x10800000"",; // as long as we have some conservative estimate we could use to prove; // that we don't need to split the unwind data. Emitting the constant; // is straightforward, but there's no existing code for estimating the; // size of the function.; //; // The other approach would be to use a dedicated, relaxable fragment,; // which could grow to accommodate splitting the unwind data if; // necessary. This is more straightforward, since it automatically works; // without any new infrastructure, and it's consistent with how we handle; // relaxation in other contexts. But it would require some refactoring; // to move parts of the pdata/xdata emission into the implementation of; // a fragment. We could probably continue to encode the unwind codes; // here, but we'd have to emit the pdata, the xdata header, and the; // epilogue scopes later, since they depend on whether the we need to; // split the unwind data.; //; // If this is fixed, remove code in AArch64ISelLowering.cpp that; // disables loop alignment on Windows.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp:1538,Integrability,depend,depend,1538,"// FIXME: GetAbsDifference tries to compute the length of the function; // immediately, before the whole file is emitted, but in general; // that's impossible: the size in bytes of certain assembler directives; // like .align and .fill is not known until the whole file is parsed and; // relaxations are applied. Currently, GetAbsDifference fails with a fatal; // error in that case. (We mostly don't hit this because inline assembly; // specifying those directives is rare, and we don't normally try to; // align loops on AArch64.); //; // There are two potential approaches to delaying the computation. One,; // we could emit something like "".word (endfunc-beginfunc)/4+0x10800000"",; // as long as we have some conservative estimate we could use to prove; // that we don't need to split the unwind data. Emitting the constant; // is straightforward, but there's no existing code for estimating the; // size of the function.; //; // The other approach would be to use a dedicated, relaxable fragment,; // which could grow to accommodate splitting the unwind data if; // necessary. This is more straightforward, since it automatically works; // without any new infrastructure, and it's consistent with how we handle; // relaxation in other contexts. But it would require some refactoring; // to move parts of the pdata/xdata emission into the implementation of; // a fragment. We could probably continue to encode the unwind codes; // here, but we'd have to emit the pdata, the xdata header, and the; // epilogue scopes later, since they depend on whether the we need to; // split the unwind data.; //; // If this is fixed, remove code in AArch64ISelLowering.cpp that; // disables loop alignment on Windows.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp:1276,Modifiability,refactor,refactoring,1276,"// FIXME: GetAbsDifference tries to compute the length of the function; // immediately, before the whole file is emitted, but in general; // that's impossible: the size in bytes of certain assembler directives; // like .align and .fill is not known until the whole file is parsed and; // relaxations are applied. Currently, GetAbsDifference fails with a fatal; // error in that case. (We mostly don't hit this because inline assembly; // specifying those directives is rare, and we don't normally try to; // align loops on AArch64.); //; // There are two potential approaches to delaying the computation. One,; // we could emit something like "".word (endfunc-beginfunc)/4+0x10800000"",; // as long as we have some conservative estimate we could use to prove; // that we don't need to split the unwind data. Emitting the constant; // is straightforward, but there's no existing code for estimating the; // size of the function.; //; // The other approach would be to use a dedicated, relaxable fragment,; // which could grow to accommodate splitting the unwind data if; // necessary. This is more straightforward, since it automatically works; // without any new infrastructure, and it's consistent with how we handle; // relaxation in other contexts. But it would require some refactoring; // to move parts of the pdata/xdata emission into the implementation of; // a fragment. We could probably continue to encode the unwind codes; // here, but we'd have to emit the pdata, the xdata header, and the; // epilogue scopes later, since they depend on whether the we need to; // split the unwind data.; //; // If this is fixed, remove code in AArch64ISelLowering.cpp that; // disables loop alignment on Windows.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp:3,Usability,Clear,Clear,3,// Clear prolog instructions after unwind info is emitted for all segments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp:220,Availability,toler,tolerate,220,"// Check if an epilog exists as a subset of the end of a prolog (backwards).; // An epilog may end with one out of three different end opcodes; if this; // is the first epilog that shares opcodes with the prolog, we can tolerate; // that this opcode differs (and the caller will update the prolog to use; // the same end opcode as the epilog). If another epilog already shares; // opcodes with the prolog, the ending opcode must be a strict match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp:279,Deployability,update,update,279,"// Check if an epilog exists as a subset of the end of a prolog (backwards).; // An epilog may end with one out of three different end opcodes; if this; // is the first epilog that shares opcodes with the prolog, we can tolerate; // that this opcode differs (and the caller will update the prolog to use; // the same end opcode as the epilog). If another epilog already shares; // opcodes with the prolog, the ending opcode must be a strict match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp:28,Availability,mask,mask,28,"// If we have chaining, the mask must have included r11.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp
