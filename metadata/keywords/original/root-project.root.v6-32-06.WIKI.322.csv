id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html534/guides/spectrum/Spectrum.html:53232,Energy Efficiency,power,power,53232," 5.8, 5.9, respectively. The achieved chi-square was 0.76732. Original spectrum. Fitted function. We have implemented the fitting function with matrix inversion based on Stiefel-Hestens method of the solution of the system of linear equations also for 2-dimensional data. The form of the function is as follows; char* Fit2Stiefel(float **source,; TSpectrumTwoDimFit* p,; int sizex,; int sizey);; This function fits the source spectrum. The calling program should fill in input parameters of the two_dim_fit structure The fitted parameters are written into structure pointed by two_dim_fit structure pointer and fitted data are written back into source spectrum.; Function parameters:. source pointer to the matrix of source spectrum; p pointer to the two_dim_fit structure pointer, see manual; sizex length x of source spectrum; sizey length y of source spectrum. The structure two_dim_fit is the same as in awmi function. The parameters power, fit_taylor are not applicable for this function; The results for small number of fitted parameters are the same as with awmi function. However it converges faster. The example for data given in Figure 5.6 (38 parameters) is presented in the following table:. # of iterations; Chi awmi; Chi-Stiefel. 1; 24.989; 10.415. 5; 20.546; 1.0553. 10; 6.256; 0.84383. 50; 1.0985; 0.64297. 100; 0.657; 1 0.64297. 500; 0.651; 94 0.64297. Again Stiefel-Hestens method converges faster. However its calculation is for this number of parameters approximately 3 times longer. For larger number of parameters the time needed to calculate the inversion grows with the cube of the number of fitted parameters. For example the fit of large number of parameters (2068) for data in Figure 5.8 using awmi algorithm lasted about 12 hours (using 450 MHz PC). The calculation using matrix inversion method is not realizable in reasonable time.; 6 TRANSFORMS; 6.1 1-DIMENSIONAL SPECTRA; Orthogonal transforms can be successfully used for the processing of nuclear spectra . They can b",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:62800,Energy Efficiency,efficient,efficient,62800,"tination data, its size should be sizex*sizey except for direct FOURIER, FOUR-WALSh, FOUR-HAAR. These need sizex*2*sizey length to store real and imaginary coefficients; sizex,sizey basic dimensions of source and dest spectra; type type of transform. TRANSFORM2_HAAR; TRANSFORM2_WALSH; TRANSFORM2_COS; TRANSFORM2_SIN; TRANSFORM2_FOURIER; TRANSFORM2_HARTLEY; TRANSFORM2_FOURIER_WALSH; TRANSFORM2_FOURIER_HAAR; TRANSFORM2_WALSH_HAAR; TRANSFORM2_COS_WALSH; TRANSFORM2_COS_HAAR; TRANSFORM2_SIN_WALSH; TRANSFORM2_SIN_HAAR. direction transform direction (forward, inverse); degree applies only for mixed transforms. An example of the 2-dimensional Cosine transform of data from Figure 5.6 is given in Figure 6.7. One can notice that the data are concentrated again around the beginning of the coordinate system. This allows to apply filtration, enhancement and compression techniques in the transform domain. 2-dimensional Cosine transform of data from Figure 5.6. In some cases when the spectrum is smooth the cosine transforms are very efficient. In Figures 6.8, 6.9 we show original spectrum and transformed coefficients using Cosine transform, respectively. Original spectrum. Transformed coefficients using Cosine transform. Analogously to 1-dimensional case we have implemented also the functions for zonal filtration, Gauss filtration and enhancement. The zonal filtration function using classic transforms has the form; char *Filter2Zonal(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int degree,; int xmin,; int xmax,; int ymin,; int ymax,; float filter-coeff);; This function transforms the source spectrum. The calling program should fill in input parameters. Then it sets transformed coefficients in the given region to the given filter_coeff and transforms it back Filtered data are written into dest spectrum.; Function parameters:. source pointer to the matrix of source spectrum, its size should be sizex*sizey; dest pointer to the matrix of destination data, its",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:17644,Integrability,depend,depending,17644,"tal spectrum with many identified peaks is given in Figure 3.2. 1-dimensional experimental spectrum with many identified peaks. However when we have noisy data the number of peaks can be enormous. One such an example is given in Figure 3.3. Therefore it can be useful to have possibility to set a threshold value and to consider only the peaks higher than this threshold (see Figure 3.4, only three peaks were identified, threshold=50.) The value in the center of the peak value[i] minus the average value in two symmetrically positioned channels (channels i-3*sigma, i+3*sigma) must be greater than threshold. Otherwise the peak is ignored. With noisy data the number of peaks can be enormous. Iwth threshold=50, only three peaks were identified. An alternative approach was proposed in [6].. The algorithm generates new invariant spectrum based on discrete Markov chains. In this spectrum the noise is suppressed, the spectrum is smoother than the original one. On the other hand it emphasizes peaks (depending on the averaging window). The example of the part of original noisy spectrum and Markov spectrum for window=3 is given in Figure 3.5 Then the peaks can found in Markov spectrum using standard above presented algorithm. Part of original noisy spectrum and Markov spectrum for window=3. The form of the generalized peak searching function is as follows.; Int-t Search1General(float *spectrum,; int size,; float sigma,; int threshold,; bool markov,; int aver-window);; This function searches for peaks in source spectrum. The number of found peaks and their positions are written into structure pointed by one_dim_peak structure pointer.; Function parameters:. spectrum pointer to the vector of source spectrum source spectrum is replaced by new spectrum calculated using Markov chains method.; size length of source spectrum; sigma sigma of searched peaks; threshold threshold value for selecting of peaks; markov logical variable, if it is true, first the source spectrum is replaced by ne",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:54843,Integrability,depend,depends,54843,"e time needed to calculate the inversion grows with the cube of the number of fitted parameters. For example the fit of large number of parameters (2068) for data in Figure 5.8 using awmi algorithm lasted about 12 hours (using 450 MHz PC). The calculation using matrix inversion method is not realizable in reasonable time.; 6 TRANSFORMS; 6.1 1-DIMENSIONAL SPECTRA; Orthogonal transforms can be successfully used for the processing of nuclear spectra . They can be used to remove high frequency noise, to increase signal-to-background ratio as well as to enhance low intensity components [14]. We have implemented also the function for the calculation of the commonly used orthogonal transforms. Haar; Walsh; Cos; Sin; Fourier; Hartley. Between these transform one can define so called generalized mixed transforms that are also implemented in the transform function. Fourier-Haar; Fourier-Walsh; Walsh-Haar; Cos-Walsh; Cos-Haar; Sin-Walsh; Sin-Haar. The suitability of the application of appropriate transform depends on the character of the data, i.e., on the shape of dominant components contained in the data. The form of the transform function is as follows:; char *Transform1(const float *source,; float *dest,; int size,; int type,; int direction,; int degree);; This function transforms the source spectrum. The calling program should fill in input parameters. Transformed data are written into dest spectrum.; Function parameters:. source pointer to the vector of source spectrum, its length should be equal to size parameter except for inverse FOURIER, FOUR-WALSH, FOUR-HAAR transform. These need 2*size length to supply real and imaginary coefficients.; dest pointer to the vector of dest data, its length should be equal to size parameter except for direct FOURIER, FOUR-WALSh, FOUR-HAAR. These need 2*size length to store real and imaginary coefficients; size basic length of source and dest spectra; type type of transform. TRANSFORM1_HAAR; TRANSFORM1_WALSH; TRANSFORM1_COS; TRANSFORM1_S",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:4511,Modifiability,variab,variable,4511,"mation of the Compton edges and decreasing clipping window. In the lower part of the Figure we present the background, which was added to the synthetic spectrum. One can observe good coincidence with the estimated background. The method of the estimation of Compton edge is described in detail in [3]. Synthetic spectrum with Compton edges. The generalized form of the algorithm is implemented in the function.; char *Background1General(float *spectrum,; int size,; int number_of_iterations,; int direction,; int filter_order,; bool compton);; The meaning of the parameters is as follows:. spectrum pointer to the vector of source spectrum; size length of spectrum vector; number_of_iterations maximal width of clipping window,; direction direction of change of clipping window. Possible values:. BACK1_INCREASING_WINDOW; BACK1_DECREASING_WINDOW. filter_order order of clipping filter. Possible values:. BACK1_ORDER2; BACK1_ORDER4; BACK1_ORDER6; BACK1_ORDER8. compton logical variable whether the estimation of Compton edge will be included. Possible values:. BACK1_EXCLUDE_COMPTON; BACK1_INCLUDE_COMPTON. 1.2 2-DIMENSIONAL SPECTRA; This basic background estimation function allows to separate useless spectrum information (2D-continuous background and coincidences of peaks with background in both dimensions) from peaks. It calculates background spectrum from source spectrum. The result is placed in the array pointed by spectrum pointer. On successful completion it returns 0. On error it returns pointer to the string describing error.; char *Background2(float **spectrum,; int sizex,; int sizey,; int number_of_iterations);; Function parameters:. spectrum pointer to the array of source spectrum; sizex x length of spectrum; sizey y length of spectrum; number_of_iterations width of the clipping window. In Figure 1.6 we present an example of 2-dimensional spectrum before background elimination. 2-dimensional spectrum before background elimination. Estimated background is shown in Figure 1.7",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:18574,Modifiability,variab,variable,18574,"um is smoother than the original one. On the other hand it emphasizes peaks (depending on the averaging window). The example of the part of original noisy spectrum and Markov spectrum for window=3 is given in Figure 3.5 Then the peaks can found in Markov spectrum using standard above presented algorithm. Part of original noisy spectrum and Markov spectrum for window=3. The form of the generalized peak searching function is as follows.; Int-t Search1General(float *spectrum,; int size,; float sigma,; int threshold,; bool markov,; int aver-window);; This function searches for peaks in source spectrum. The number of found peaks and their positions are written into structure pointed by one_dim_peak structure pointer.; Function parameters:. spectrum pointer to the vector of source spectrum source spectrum is replaced by new spectrum calculated using Markov chains method.; size length of source spectrum; sigma sigma of searched peaks; threshold threshold value for selecting of peaks; markov logical variable, if it is true, first the source spectrum is replaced by new spectrum calculated using Markov chains method.; aver_window averaging window used in calculation of Markov spectrum, applies only for markov variable is true. The methods of peak searching are sensitive to the sigma. Usually the sigma value is known beforehand. It also changes only slightly with the energy. We have investigated as well the robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10 (see Figure 3.6). Robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10. We applied peak searching algorithm based on Markov approach. We changed sigma in the interval from 1 to 10. The spectra for averaging windows 3, 5, 10 are shown in Figure 3.7. Spectra for averaging windows 3, 5, 10. When we applied peak searching function to the Markov spectrum averaged with the window=10, we obtained correct estimate of all 10 peak posit",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:18786,Modifiability,variab,variable,18786,"rum for window=3 is given in Figure 3.5 Then the peaks can found in Markov spectrum using standard above presented algorithm. Part of original noisy spectrum and Markov spectrum for window=3. The form of the generalized peak searching function is as follows.; Int-t Search1General(float *spectrum,; int size,; float sigma,; int threshold,; bool markov,; int aver-window);; This function searches for peaks in source spectrum. The number of found peaks and their positions are written into structure pointed by one_dim_peak structure pointer.; Function parameters:. spectrum pointer to the vector of source spectrum source spectrum is replaced by new spectrum calculated using Markov chains method.; size length of source spectrum; sigma sigma of searched peaks; threshold threshold value for selecting of peaks; markov logical variable, if it is true, first the source spectrum is replaced by new spectrum calculated using Markov chains method.; aver_window averaging window used in calculation of Markov spectrum, applies only for markov variable is true. The methods of peak searching are sensitive to the sigma. Usually the sigma value is known beforehand. It also changes only slightly with the energy. We have investigated as well the robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10 (see Figure 3.6). Robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10. We applied peak searching algorithm based on Markov approach. We changed sigma in the interval from 1 to 10. The spectra for averaging windows 3, 5, 10 are shown in Figure 3.7. Spectra for averaging windows 3, 5, 10. When we applied peak searching function to the Markov spectrum averaged with the window=10, we obtained correct estimate of all 10 peak positions for sigma=2,3,4,5,6,7,8. It was not the case when we made the same experiment with the original spectrum. For all sigmas some peaks were not discovered.; 3.2 2-DIMENSIONAL SP",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:21391,Modifiability,variab,variable,21391,"im_peak structure pointer.; Function parameters:. source pointer to the vector of source spectrum; sizex x length of source spectrum; sizey y length of source spectrum; sigma sigma of searched peaks. An example of the two-dimensional spectrum with the identified peaks is shown in Figure 3.8. Two-dimensional spectrum with the identified peaks. We have also generalized the peak searching function analogously to one dimensional data. The generalized peak searching function for two dimensional spectra has the form; Int-t Search2General(float **source,; int sizex,; int sizey,; double sigma,; int threshold,; bool markov,; int aver-window);; This function searches for peaks in source spectrum. The number of found peaks and their positions are written into structure pointed by two_dim_peak structure pointer.; Function parameters:. source pointer to the vector of source spectrum; sizex x length of source spectrum; sizey y length of source spectrum; sigma sigma of searched peaks; threshold threshold value for selection of peaks; markov logical variable, if it is true, first the source spectrum is replaced by new spectrum calculated using Markov chains method.; aver_window averaging window of searched peaks (applies only for Markov method). An example of experimental 2-dimensional spectrum is given in Figure 3.9. The number of peaks identified by the function now is 295. Experimental 2-dimensional spectrum. The function works even for very noisy data. In Figure 3.10 we present synthetic 2-dimensional spectrum with 5 peaks. The method should recognize what is real 2-dimensional peak and what is the crossing of two 1-dimensional ridges The Markov spectrum with averaging window=3 is given in Figure 3.11. One can observe that this spectrum is smoother than the original one. After applying the general peak searching function to the Markov spectrum with sigma=2, and threshold=600, we get correctly identified peaks. Synthetic 2-dimensional spectrum with 5 peaks. Markov spectrum with a",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:30101,Modifiability,extend,extended,30101,"ifferent chemical elements. The original spectrum before unfolding is given in Figure 4.7. The obtained coefficients after unfolding, i.e., the contents of the responses in the original spectrum is presented in the Figure 4.8. Original spectrum before unfolding. Contents of the responses in the original spectrum. Another example where we have used unfolding method is the decomposition of continuum of gamma-ray spectra. Using simulation and interpolation techniques we have synthesized the response matrix (size 3400x3400 channels) of Gammasphere spectrometer (Figure 4.9). Its detail is presented in Figure 4.10. The original spectrum of Co56 before and after continuum decomposition are presented in Figures 4.11, 4.12, respectively. Response matrix (size 3400x3400 channels) of Gammasphere spectrometer. Detail of Figure 4.9. Original spectrum of Co56 before continuum decomposition. Original spectrum of Co56 after continuum decomposition. 4.3 2-DIMENSIONAL SPECTRA; We have extended the method of Gold deconvolution also for 2-dimensional data. Again the goal of the deconvolution methods is to improve the resolution in the spectrum and to decompose multiplets. In detail the method of optimized 2-dimensional deconvolution is described in [8].; Mathematical formulation of 2-dimensional convolution system is as follows; \[ y(i_1,i_2) = \sum_{k_1=0}^{N_1-1}\sum_{k_2=0}^{N_2-1}h(i_1-k_1,i_2-k_2)x(k_1,k_2), i_1=0,1,2,...,N_1-1, i_2=0,1,2,...,N_2-1 \]; Assuming we know the output spectrum y and the response spectrum h,the task is to calculate the matrix x.; The basic function has the form; char *Deconvolution2(float **source,; const float **resp,; int sizex,; int sizey,; int niter);; This function calculates deconvolution from source spectrum according to response spectrum. The result is placed in the matrix pointed by source pointer.; Function parameters:. source pointer to the matrix of source spectrum; resp pointer to the matrix of response spectrum; sizex x length of source and",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:54387,Modifiability,enhance,enhance,54387,"with awmi function. However it converges faster. The example for data given in Figure 5.6 (38 parameters) is presented in the following table:. # of iterations; Chi awmi; Chi-Stiefel. 1; 24.989; 10.415. 5; 20.546; 1.0553. 10; 6.256; 0.84383. 50; 1.0985; 0.64297. 100; 0.657; 1 0.64297. 500; 0.651; 94 0.64297. Again Stiefel-Hestens method converges faster. However its calculation is for this number of parameters approximately 3 times longer. For larger number of parameters the time needed to calculate the inversion grows with the cube of the number of fitted parameters. For example the fit of large number of parameters (2068) for data in Figure 5.8 using awmi algorithm lasted about 12 hours (using 450 MHz PC). The calculation using matrix inversion method is not realizable in reasonable time.; 6 TRANSFORMS; 6.1 1-DIMENSIONAL SPECTRA; Orthogonal transforms can be successfully used for the processing of nuclear spectra . They can be used to remove high frequency noise, to increase signal-to-background ratio as well as to enhance low intensity components [14]. We have implemented also the function for the calculation of the commonly used orthogonal transforms. Haar; Walsh; Cos; Sin; Fourier; Hartley. Between these transform one can define so called generalized mixed transforms that are also implemented in the transform function. Fourier-Haar; Fourier-Walsh; Walsh-Haar; Cos-Walsh; Cos-Haar; Sin-Walsh; Sin-Haar. The suitability of the application of appropriate transform depends on the character of the data, i.e., on the shape of dominant components contained in the data. The form of the transform function is as follows:; char *Transform1(const float *source,; float *dest,; int size,; int type,; int direction,; int degree);; This function transforms the source spectrum. The calling program should fill in input parameters. Transformed data are written into dest spectrum.; Function parameters:. source pointer to the vector of source spectrum, its length should be equal to siz",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:56719,Modifiability,enhance,enhanced,56719,"; size basic length of source and dest spectra; type type of transform. TRANSFORM1_HAAR; TRANSFORM1_WALSH; TRANSFORM1_COS; TRANSFORM1_SIN; TRANSFORM1_FOURIER; TRANSFORM1_HARTLEY; TRANSFORM1_FOURIER_WALSH; TRANSFORM1_FOURIER_HAAR; TRANSFORM1_WALSH_HAAR; TRANSFORM1_COS_WALSH; TRANSFORM1_COS_HAAR; TRANSFORM1_SIN_WALSH; TRANSFORM1_SIN_HAAR. direction transform direction (forward, inverse). TRANSFORM1_FORWARD; TRANSFORM1_INVERSE. degree applies only for mixed transforms Let us illustrate the applications of the transform using an example. In Figure 6.1 we have spectrum with many peaks, complicated background and high level of noise. Spectrum with many peaks. In Figures. 6.2, 6.3, 6.4 we present this spectrum transformed using Haar, Walsh and Cosine transforms, respectively. Spectrum transformed using Haar transform. Spectrum transformed using Walsh transform. Spectrum transformed using Cosine transform. Haar transforms (Figure 6.2) creates clusters of data. These coefficients can be analyzed and then filtered, enhanced etc. On the other hand Walsh transform (Figure 6.3) concentrates the dominant components near to zero of the coordinate system. It is more suitable to process data of rectangular shape (e.g. in the field of digital signal processing). Finally Cosine transform concentrates in the best way the transform coefficients to the beginning of the coordinate system. From the point of view of the variance distribution it is sometimes called suboptimal. One can notice that approximately one half of the coefficients are negligible. This fact can be utilized to the compression purposes (in two or more dimensional data), filtering (smoothing) etc.; We have implemented several application functions utilizing the properties of the orthogonal transforms. Let us start with zonal filtration function. It has the form.; char *Filter1Zonal(const float *source,; float *dest,; int size,; int type,; int degree,; int xmin,; int xmax,; float filter-coeff);; This function transforms t",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:59221,Modifiability,enhance,enhance,59221,"SFORM1_SIN; TRANSFORM1_FOURIER; TRANSFORM1_HARTLEY; TRANSFORM1_FOURIER_WALSH; TRANSFORM1_FOURIER_HAAR; TRANSFORM1_WALSH_HAAR; TRANSFORM1_COS_WALSH; TRANSFORM1_COS_HAAR; TRANSFORM1_SIN_WALSH; TRANSFORM1_SIN_HAAR. degree applied only for mixed transforms; xmin low limit of filtered region; xmax high limit of filtered region; filter_coeff value which is set in filtered region. An example of the filtration using Cosine transform is given in the Figure 6.5. It illustrates a part of the spectrum from Figure 6.1 and two spectra after filtration preserving 2048 coefficients and 1536 coefficients. One can observe very good fidelity of the overall shape of both spectra with the original data. However some distortion can be observed in details of the second spectrum after filtration preserving only 1536 coefficients. The useful information in the transform domain can be compressed into one half of the original space. Filtration using Cosine transform. In the transform domain one can also enhance (multiply with the constant > 1) some regions. In this way one can change peak-to-background ratio. This function has the form; char *Enhance1(const float *source,; float *dest,; int size,; int type,; int degree,; int xmin,; int xmax,; float enhance-coeff);; This function transforms the source spectrum. The calling program should fill in input parameters. Then it multiplies transformed coefficients in the given region (xmin, xmax) by the given enhance_coeff and transforms it back Processed data are written into dest spectrum.; Function parameters:. source pointer to the vector of source spectrum, its length should be size; dest pointer to the vector of dest data, its length should be size; size basic length of source and dest spectra; type type of transform. TRANSFORM1_HAAR; TRANSFORM1_WALSH; TRANSFORM1_COS; TRANSFORM1_SIN; TRANSFORM1_FOURIER; TRANSFORM1_HARTLEY; TRANSFORM1_FOURIER_WALSH; TRANSFORM1_FOURIER_HAAR; TRANSFORM1_WALSH_HAAR; TRANSFORM1_COS_WALSH; TRANSFORM1_COS_HAAR; TRANSFO",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:59471,Modifiability,enhance,enhance-coeff,59471,"_SIN_HAAR. degree applied only for mixed transforms; xmin low limit of filtered region; xmax high limit of filtered region; filter_coeff value which is set in filtered region. An example of the filtration using Cosine transform is given in the Figure 6.5. It illustrates a part of the spectrum from Figure 6.1 and two spectra after filtration preserving 2048 coefficients and 1536 coefficients. One can observe very good fidelity of the overall shape of both spectra with the original data. However some distortion can be observed in details of the second spectrum after filtration preserving only 1536 coefficients. The useful information in the transform domain can be compressed into one half of the original space. Filtration using Cosine transform. In the transform domain one can also enhance (multiply with the constant > 1) some regions. In this way one can change peak-to-background ratio. This function has the form; char *Enhance1(const float *source,; float *dest,; int size,; int type,; int degree,; int xmin,; int xmax,; float enhance-coeff);; This function transforms the source spectrum. The calling program should fill in input parameters. Then it multiplies transformed coefficients in the given region (xmin, xmax) by the given enhance_coeff and transforms it back Processed data are written into dest spectrum.; Function parameters:. source pointer to the vector of source spectrum, its length should be size; dest pointer to the vector of dest data, its length should be size; size basic length of source and dest spectra; type type of transform. TRANSFORM1_HAAR; TRANSFORM1_WALSH; TRANSFORM1_COS; TRANSFORM1_SIN; TRANSFORM1_FOURIER; TRANSFORM1_HARTLEY; TRANSFORM1_FOURIER_WALSH; TRANSFORM1_FOURIER_HAAR; TRANSFORM1_WALSH_HAAR; TRANSFORM1_COS_WALSH; TRANSFORM1_COS_HAAR; TRANSFORM1_SIN_WALSH; TRANSFORM1_SIN_HAAR. degree applied only for mixed transforms; xmin low limit of filtered region; xmax high limit of filtered region; enhance_coeff value by which the filtered region is m",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:60456,Modifiability,enhance,enhancement,60456,"s the source spectrum. The calling program should fill in input parameters. Then it multiplies transformed coefficients in the given region (xmin, xmax) by the given enhance_coeff and transforms it back Processed data are written into dest spectrum.; Function parameters:. source pointer to the vector of source spectrum, its length should be size; dest pointer to the vector of dest data, its length should be size; size basic length of source and dest spectra; type type of transform. TRANSFORM1_HAAR; TRANSFORM1_WALSH; TRANSFORM1_COS; TRANSFORM1_SIN; TRANSFORM1_FOURIER; TRANSFORM1_HARTLEY; TRANSFORM1_FOURIER_WALSH; TRANSFORM1_FOURIER_HAAR; TRANSFORM1_WALSH_HAAR; TRANSFORM1_COS_WALSH; TRANSFORM1_COS_HAAR; TRANSFORM1_SIN_WALSH; TRANSFORM1_SIN_HAAR. degree applied only for mixed transforms; xmin low limit of filtered region; xmax high limit of filtered region; enhance_coeff value by which the filtered region is multiplied. An example of enhancement of the coefficients from region 380-800 by the constant 2 in the Cosine transform domain is given in the Figure 6.6. The determination of the region is a matter of analysis in the appropriate transform domain. We assumed that low frequency components are placed in the low coefficients. As it can be observed the enhancement changes the peak-to-background ratio. Enhancement of the coefficients from region 380-800 by the constant 2 in the Cosine transform domain. 6.2 2-DIMENSIONAL SPECTRA; Analogously to1-dimensional data we have implemented the transforms also for 2-dimensional data. Besides of the classic orthogonal transforms. Haar; Walsh; Cos; Sin; Fourier; Hartley; Fourier-Haar; Fourier-Walsh; Walsh-Haar; Cos-Walsh; Cos-Haar; Sin-Walsh; Sin-Haar. char *Transform2(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int direction,; int degree);; This function transforms the source spectrum. The calling program should fill in input parameters. Transformed data are written into dest spectrum.; Function paramet",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:60781,Modifiability,enhance,enhancement,60781,"ointer to the vector of source spectrum, its length should be size; dest pointer to the vector of dest data, its length should be size; size basic length of source and dest spectra; type type of transform. TRANSFORM1_HAAR; TRANSFORM1_WALSH; TRANSFORM1_COS; TRANSFORM1_SIN; TRANSFORM1_FOURIER; TRANSFORM1_HARTLEY; TRANSFORM1_FOURIER_WALSH; TRANSFORM1_FOURIER_HAAR; TRANSFORM1_WALSH_HAAR; TRANSFORM1_COS_WALSH; TRANSFORM1_COS_HAAR; TRANSFORM1_SIN_WALSH; TRANSFORM1_SIN_HAAR. degree applied only for mixed transforms; xmin low limit of filtered region; xmax high limit of filtered region; enhance_coeff value by which the filtered region is multiplied. An example of enhancement of the coefficients from region 380-800 by the constant 2 in the Cosine transform domain is given in the Figure 6.6. The determination of the region is a matter of analysis in the appropriate transform domain. We assumed that low frequency components are placed in the low coefficients. As it can be observed the enhancement changes the peak-to-background ratio. Enhancement of the coefficients from region 380-800 by the constant 2 in the Cosine transform domain. 6.2 2-DIMENSIONAL SPECTRA; Analogously to1-dimensional data we have implemented the transforms also for 2-dimensional data. Besides of the classic orthogonal transforms. Haar; Walsh; Cos; Sin; Fourier; Hartley; Fourier-Haar; Fourier-Walsh; Walsh-Haar; Cos-Walsh; Cos-Haar; Sin-Walsh; Sin-Haar. char *Transform2(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int direction,; int degree);; This function transforms the source spectrum. The calling program should fill in input parameters. Transformed data are written into dest spectrum.; Function parameters:. source pointer to the matrix of source spectrum, its size should be sizex*sizey except for inverse FOURIER, FOUR-WALSH, FOUR-HAAR transform. These need sizex*2*sizey length to supply real and imaginary coefficients.; dest pointer to the matrix of destination data, its size ",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:62607,Modifiability,enhance,enhancement,62607,"IER, FOUR-WALSH, FOUR-HAAR transform. These need sizex*2*sizey length to supply real and imaginary coefficients.; dest pointer to the matrix of destination data, its size should be sizex*sizey except for direct FOURIER, FOUR-WALSh, FOUR-HAAR. These need sizex*2*sizey length to store real and imaginary coefficients; sizex,sizey basic dimensions of source and dest spectra; type type of transform. TRANSFORM2_HAAR; TRANSFORM2_WALSH; TRANSFORM2_COS; TRANSFORM2_SIN; TRANSFORM2_FOURIER; TRANSFORM2_HARTLEY; TRANSFORM2_FOURIER_WALSH; TRANSFORM2_FOURIER_HAAR; TRANSFORM2_WALSH_HAAR; TRANSFORM2_COS_WALSH; TRANSFORM2_COS_HAAR; TRANSFORM2_SIN_WALSH; TRANSFORM2_SIN_HAAR. direction transform direction (forward, inverse); degree applies only for mixed transforms. An example of the 2-dimensional Cosine transform of data from Figure 5.6 is given in Figure 6.7. One can notice that the data are concentrated again around the beginning of the coordinate system. This allows to apply filtration, enhancement and compression techniques in the transform domain. 2-dimensional Cosine transform of data from Figure 5.6. In some cases when the spectrum is smooth the cosine transforms are very efficient. In Figures 6.8, 6.9 we show original spectrum and transformed coefficients using Cosine transform, respectively. Original spectrum. Transformed coefficients using Cosine transform. Analogously to 1-dimensional case we have implemented also the functions for zonal filtration, Gauss filtration and enhancement. The zonal filtration function using classic transforms has the form; char *Filter2Zonal(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int degree,; int xmin,; int xmax,; int ymin,; int ymax,; float filter-coeff);; This function transforms the source spectrum. The calling program should fill in input parameters. Then it sets transformed coefficients in the given region to the given filter_coeff and transforms it back Filtered data are written into dest spectrum.; Function",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:63108,Modifiability,enhance,enhancement,63108,"RANSFORM2_COS; TRANSFORM2_SIN; TRANSFORM2_FOURIER; TRANSFORM2_HARTLEY; TRANSFORM2_FOURIER_WALSH; TRANSFORM2_FOURIER_HAAR; TRANSFORM2_WALSH_HAAR; TRANSFORM2_COS_WALSH; TRANSFORM2_COS_HAAR; TRANSFORM2_SIN_WALSH; TRANSFORM2_SIN_HAAR. direction transform direction (forward, inverse); degree applies only for mixed transforms. An example of the 2-dimensional Cosine transform of data from Figure 5.6 is given in Figure 6.7. One can notice that the data are concentrated again around the beginning of the coordinate system. This allows to apply filtration, enhancement and compression techniques in the transform domain. 2-dimensional Cosine transform of data from Figure 5.6. In some cases when the spectrum is smooth the cosine transforms are very efficient. In Figures 6.8, 6.9 we show original spectrum and transformed coefficients using Cosine transform, respectively. Original spectrum. Transformed coefficients using Cosine transform. Analogously to 1-dimensional case we have implemented also the functions for zonal filtration, Gauss filtration and enhancement. The zonal filtration function using classic transforms has the form; char *Filter2Zonal(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int degree,; int xmin,; int xmax,; int ymin,; int ymax,; float filter-coeff);; This function transforms the source spectrum. The calling program should fill in input parameters. Then it sets transformed coefficients in the given region to the given filter_coeff and transforms it back Filtered data are written into dest spectrum.; Function parameters:. source pointer to the matrix of source spectrum, its size should be sizex*sizey; dest pointer to the matrix of destination data, its size should be sizex*sizey; sizex,sizey basic dimensions of source and dest spectra; type type of transform. TRANSFORM2_HAAR; TRANSFORM2_WALSH; TRANSFORM2_COS; TRANSFORM2_SIN; TRANSFORM2_FOURIER; TRANSFORM2_HARTLEY; TRANSFORM2_FOURIER_WALSH; TRANSFORM2_FOURIER_HAAR; TRANSFORM2_WALSH_HAA",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:64393,Modifiability,enhance,enhancement,64393,"e given filter_coeff and transforms it back Filtered data are written into dest spectrum.; Function parameters:. source pointer to the matrix of source spectrum, its size should be sizex*sizey; dest pointer to the matrix of destination data, its size should be sizex*sizey; sizex,sizey basic dimensions of source and dest spectra; type type of transform. TRANSFORM2_HAAR; TRANSFORM2_WALSH; TRANSFORM2_COS; TRANSFORM2_SIN; TRANSFORM2_FOURIER; TRANSFORM2_HARTLEY; TRANSFORM2_FOURIER_WALSH; TRANSFORM2_FOURIER_HAAR; TRANSFORM2_WALSH_HAAR; TRANSFORM2_COS_WALSH; TRANSFORM2_COS_HAAR; TRANSFORM2_SIN_WALSH; TRANSFORM2_SIN_HAAR. degree applies only for mixed transforms; xmin low limit x of filtered region; xmax high limit x of filtered region; ymin low limit y of filtered region; ymax high limit y of filtered region; filter_coeff value which is set in filtered region. The enhancement function using transforms has the form; char *Enhance2(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int degree,; int xmin,; int xmax,; int ymin,; int ymax,; float enhance-coeff);; This function transforms the source spectrum. The calling program should fill in input parameters. Then it multiplies transformed coefficients in the given region by the given enhance_coeff and transforms it back; Function parameters:. source pointer to the matrix of source spectrum, its size should be sizex*sizey; dest pointer to the matrix of destination data, its size should be sizex*sizey; sizex,sizey basic dimensions of source and dest spectra; type type of transform. TRANSFORM2_HAAR; TRANSFORM2_WALSH; TRANSFORM2_COS; TRANSFORM2_SIN; TRANSFORM2_FOURIER; TRANSFORM2_HARTLEY; TRANSFORM2_FOURIER_WALSH; TRANSFORM2_FOURIER_HAAR; TRANSFORM2_WALSH_HAAR; TRANSFORM2_COS_WALSH; TRANSFORM2_COS_HAAR; TRANSFORM2_SIN_WALSH; TRANSFORM2_SIN_HAAR. degree applies only for mixed transforms; xmin low limit x of filtered region; xmax high limit x of filtered region; ymin low limit y of filtered region; ymax high l",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:64596,Modifiability,enhance,enhance-coeff,64596,"e given filter_coeff and transforms it back Filtered data are written into dest spectrum.; Function parameters:. source pointer to the matrix of source spectrum, its size should be sizex*sizey; dest pointer to the matrix of destination data, its size should be sizex*sizey; sizex,sizey basic dimensions of source and dest spectra; type type of transform. TRANSFORM2_HAAR; TRANSFORM2_WALSH; TRANSFORM2_COS; TRANSFORM2_SIN; TRANSFORM2_FOURIER; TRANSFORM2_HARTLEY; TRANSFORM2_FOURIER_WALSH; TRANSFORM2_FOURIER_HAAR; TRANSFORM2_WALSH_HAAR; TRANSFORM2_COS_WALSH; TRANSFORM2_COS_HAAR; TRANSFORM2_SIN_WALSH; TRANSFORM2_SIN_HAAR. degree applies only for mixed transforms; xmin low limit x of filtered region; xmax high limit x of filtered region; ymin low limit y of filtered region; ymax high limit y of filtered region; filter_coeff value which is set in filtered region. The enhancement function using transforms has the form; char *Enhance2(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int degree,; int xmin,; int xmax,; int ymin,; int ymax,; float enhance-coeff);; This function transforms the source spectrum. The calling program should fill in input parameters. Then it multiplies transformed coefficients in the given region by the given enhance_coeff and transforms it back; Function parameters:. source pointer to the matrix of source spectrum, its size should be sizex*sizey; dest pointer to the matrix of destination data, its size should be sizex*sizey; sizex,sizey basic dimensions of source and dest spectra; type type of transform. TRANSFORM2_HAAR; TRANSFORM2_WALSH; TRANSFORM2_COS; TRANSFORM2_SIN; TRANSFORM2_FOURIER; TRANSFORM2_HARTLEY; TRANSFORM2_FOURIER_WALSH; TRANSFORM2_FOURIER_HAAR; TRANSFORM2_WALSH_HAAR; TRANSFORM2_COS_WALSH; TRANSFORM2_COS_HAAR; TRANSFORM2_SIN_WALSH; TRANSFORM2_SIN_HAAR. degree applies only for mixed transforms; xmin low limit x of filtered region; xmax high limit x of filtered region; ymin low limit y of filtered region; ymax high l",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:65550,Modifiability,enhance,enhance-coeff,65550,"e,; float **dest,; int sizex,; int sizey,; int type,; int degree,; int xmin,; int xmax,; int ymin,; int ymax,; float enhance-coeff);; This function transforms the source spectrum. The calling program should fill in input parameters. Then it multiplies transformed coefficients in the given region by the given enhance_coeff and transforms it back; Function parameters:. source pointer to the matrix of source spectrum, its size should be sizex*sizey; dest pointer to the matrix of destination data, its size should be sizex*sizey; sizex,sizey basic dimensions of source and dest spectra; type type of transform. TRANSFORM2_HAAR; TRANSFORM2_WALSH; TRANSFORM2_COS; TRANSFORM2_SIN; TRANSFORM2_FOURIER; TRANSFORM2_HARTLEY; TRANSFORM2_FOURIER_WALSH; TRANSFORM2_FOURIER_HAAR; TRANSFORM2_WALSH_HAAR; TRANSFORM2_COS_WALSH; TRANSFORM2_COS_HAAR; TRANSFORM2_SIN_WALSH; TRANSFORM2_SIN_HAAR. degree applies only for mixed transforms; xmin low limit x of filtered region; xmax high limit x of filtered region; ymin low limit y of filtered region; ymax high limit y of filtered region; enhance-coeff value which is set in filtered region. 7 VISUALIZATION; 7.1 1-DIMENSIONAL SPECTRA; The 1-dimensional visualization function displays spectrum (or part of it) on the Canvas of a form. Before calling the function one has to fill in one_dim_pic structure containing all parameters of the display. The function has the form; char *display1(struct one-dim-pic* p);; This function displays the source spectrum on Canvas. All parameters are grouped in one_dim_pic structure. Before calling display1 function the structure should be filled in and the address of one_dim_pic passed as parameter to display1 function. The meaning of appropriate parameters is apparent from description of one_dim_pic structure. The constants , which can be used for appropriate parameters are defined in procfunc.h header file.; struct one_dim_pic {. float *source; // spectrum to be displayed. TCanvas *Canvas; // Canvas where the spectrum wi",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:68786,Modifiability,variab,variables,68786,"ithm, hsv modulo color component [15]. int bar_thickness; // applies only for bar display mode; int bar_empty_flag; // (empty bars, full bars) applies only for bar display mode; int border_color; // color of background of the picture; int full_border; // decides whether background is painted; int raster_en_dis; // decides whether the axes and rasters are shown; int raster_long; // decides whether the rasters are drawn as long lines; int raster_color; // color of the rasters; char *raster_description_x; // x axis description; char *raster_description_y; // y axis description. int pen_color; // color of spectrum; int pen_dash; // style of pen; int pen_width; // width of line. int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_color; // color of channel marks. // auxiliary variables, transform coefficients, for internal use only; double mx;; double my;; double px;; double py;. // auxiliary internal variables, working place; double gbezx,gbezy;; TPoint bz[4];; };; The examples using different display parameters are shown in the next few Figures. Display mode -polyline, width of pen=3. Display mode- bars, shown channel marks. Display mode- steps, log scale, shown channel marks. Display mode -Bezier curve interpolation, shown channel marks. Display mode- rainbow bars, color algorithm (model) RGB, number of color levels=1024, pen width=3. Display mode-empty bars, color algorithm YIQ, number of color levels 2048. 7.2 2-DIMENSIONAL SPECTRA; The 2-dimensional visualization function displays spectrum (or part of it) on the Canvas of a form. Before calling the function one has to fill in two_dim_pic structure containing all parameters of the display. The function has the form; char *display2(struct two-dim-pic* p);; This function displays the source two dimensional spectrum on Canvas. All parameters are grou",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:68914,Modifiability,variab,variables,68914,"plies only for bar display mode; int border_color; // color of background of the picture; int full_border; // decides whether background is painted; int raster_en_dis; // decides whether the axes and rasters are shown; int raster_long; // decides whether the rasters are drawn as long lines; int raster_color; // color of the rasters; char *raster_description_x; // x axis description; char *raster_description_y; // y axis description. int pen_color; // color of spectrum; int pen_dash; // style of pen; int pen_width; // width of line. int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_color; // color of channel marks. // auxiliary variables, transform coefficients, for internal use only; double mx;; double my;; double px;; double py;. // auxiliary internal variables, working place; double gbezx,gbezy;; TPoint bz[4];; };; The examples using different display parameters are shown in the next few Figures. Display mode -polyline, width of pen=3. Display mode- bars, shown channel marks. Display mode- steps, log scale, shown channel marks. Display mode -Bezier curve interpolation, shown channel marks. Display mode- rainbow bars, color algorithm (model) RGB, number of color levels=1024, pen width=3. Display mode-empty bars, color algorithm YIQ, number of color levels 2048. 7.2 2-DIMENSIONAL SPECTRA; The 2-dimensional visualization function displays spectrum (or part of it) on the Canvas of a form. Before calling the function one has to fill in two_dim_pic structure containing all parameters of the display. The function has the form; char *display2(struct two-dim-pic* p);; This function displays the source two dimensional spectrum on Canvas. All parameters are grouped in two_dim_pic structure. Before calling display2 function the structure should be filled in and the address of two_dim_pic passed as paramet",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:74934,Modifiability,variab,variables,74934,"r_color; // color of background of the picture; int full_border; // decides whether background is painted; int raster_en_dis; // decides whether the rasters are shown; int raster_long; // decides whether the rasters are drawn as long lines; int raster_color; // color of the rasters; char *raster_description_x; // x axis description; char *raster_description_y; // y axis description; char *raster_description_z; // z axis description; int pen_color; // color of spectrum; int pen_dash; // style of pen; int pen_width; // width of line; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_color; // color of channel marks; int chanline_en_dis; // decides whether the channel lines (grid) are shown. // auxiliary variables, transformation coefficients for internal use only; double kx;; double ky;; double mxx;; double mxy;; double myx;; double myy;; double txx;; double txy;; double tyx;; double tyy;; double tyz;; double vx;; double vy;; double nu_sli;. // auxiliary internal variables, working place; double z,zeq,gbezx,gbezy,dxspline,dyspline;; int xt,yt,xs,ys,xe,ye,priamka,z_preset_value;; unsigned short obal[MAXIMUM_XSCREEN_RESOLUTION];; unsigned short obal_cont[MAXIMUM_XSCREEN_RESOLUTION];; TPoint bz[4];; };; The examples using different display parameters are shown in the next few Figures. Display mode-bars, pen width=2. Display mode-triangles, log scale. Display mode-contours. Display mode surface shading according to height. Display mode-surface shading according to light point. Display mode-surface shading according to height+light position with ratio 50:50, CMY color model. Display mode bars shaded according to height. Display mode- surface shading according to light position with shadows. Display mode- surface shading according to height with 10 levels of contours. Display mode- surface shading acco",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:75199,Modifiability,variab,variables,75199,"ription_x; // x axis description; char *raster_description_y; // y axis description; char *raster_description_z; // z axis description; int pen_color; // color of spectrum; int pen_dash; // style of pen; int pen_width; // width of line; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_color; // color of channel marks; int chanline_en_dis; // decides whether the channel lines (grid) are shown. // auxiliary variables, transformation coefficients for internal use only; double kx;; double ky;; double mxx;; double mxy;; double myx;; double myy;; double txx;; double txy;; double tyx;; double tyy;; double tyz;; double vx;; double vy;; double nu_sli;. // auxiliary internal variables, working place; double z,zeq,gbezx,gbezy,dxspline,dyspline;; int xt,yt,xs,ys,xe,ye,priamka,z_preset_value;; unsigned short obal[MAXIMUM_XSCREEN_RESOLUTION];; unsigned short obal_cont[MAXIMUM_XSCREEN_RESOLUTION];; TPoint bz[4];; };; The examples using different display parameters are shown in the next few Figures. Display mode-bars, pen width=2. Display mode-triangles, log scale. Display mode-contours. Display mode surface shading according to height. Display mode-surface shading according to light point. Display mode-surface shading according to height+light position with ratio 50:50, CMY color model. Display mode bars shaded according to height. Display mode- surface shading according to light position with shadows. Display mode- surface shading according to height with 10 levels of contours. Display mode- surface shading according to height, sqrt scale, channel marks and lines shown. Display mode- surface shading according to height-contours, rasters allowing to localize interesting parts are shown. References; [1] M. Morháč, J. Kliman, V. Matoušek, M. Veselský, I. Turzo.: Background elimination methods for multidimension",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:78365,Modifiability,enhance,enhancement,78365,"3), 431-434.; [4] M. Morháč, J. Kliman, V. Matoušek, M. Veselský, I. Turzo.:Identification of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000) 108-125.; [5] M.A. Mariscotti: A method for identification of peaks in the presence of background and its application to spectrum analysis. NIM 50 (1967), 309-320.; [6] Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376 (1996), 451.; [7] P. Bandžuch, M. Morháč, J. Krištiak: Study of the VanCitter and Gold iterative methods of deconvolutionand their application in the deconvolution of experimental spectra of positron annihilation, NIM A 384 (1997) 506-515.; [8] M. Morháč, J. Kliman, V. Matoušek, M. Veselský, I. Turzo.: Efficient one- and two-dimensional Gold deconvolution and its application to gamma-ray spectra decomposition. NIM, A401 (1997) 385-408.; [9] I. A. Slavic: Nonlinear least-squares fitting without matrix inversion applied to complex Gaussian spectra analysis. NIM 134 (1976) 285-289.; [10] B. Mihaila: Analysis of complex gamma spectra, Rom. Jorn. Phys., Vol. 39, No. 2, (1994), 139-148.; [11] T. Awaya: A new method for curve fitting to the data with low statistics not using chi-square method. NIM 165 (1979) 317-323.; [12] T. Hauschild, M. Jentschel: Comparison of maximum likelihood estimation and chi-square statistics applied to counting experiments. NIM A 457 (2001) 384-401.; [13] M. Morháč, J. Kliman, M. Jandel, Ľ. Krupa, V. Matoušek: Study of fitting algorithms applied to simultaneous analysis of large number of peaks in \(\gamma\)-ray spectra. Applied spectroscopy, Accepted for publication.; [14] C.V. Hampton, B. Lian, Wm. C. McHarris: Fast-Fourier-transform spectral enhancement techniques for gamma-ray spectroscopy. NIM A353 (1994) 280-284..; [15] D. Hearn, M. P. Baker: Computer Graphics, Prentice-Hall International, Inc., 1994. Institute of Physics, Slovak Academy of Sciences, Bratislava, Slovakia↩; Flerov Laboratory of Nuclear Reactions, JINR, Dubna, Russia↩. ",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:30314,Performance,optimiz,optimized,30314,"the Figure 4.8. Original spectrum before unfolding. Contents of the responses in the original spectrum. Another example where we have used unfolding method is the decomposition of continuum of gamma-ray spectra. Using simulation and interpolation techniques we have synthesized the response matrix (size 3400x3400 channels) of Gammasphere spectrometer (Figure 4.9). Its detail is presented in Figure 4.10. The original spectrum of Co56 before and after continuum decomposition are presented in Figures 4.11, 4.12, respectively. Response matrix (size 3400x3400 channels) of Gammasphere spectrometer. Detail of Figure 4.9. Original spectrum of Co56 before continuum decomposition. Original spectrum of Co56 after continuum decomposition. 4.3 2-DIMENSIONAL SPECTRA; We have extended the method of Gold deconvolution also for 2-dimensional data. Again the goal of the deconvolution methods is to improve the resolution in the spectrum and to decompose multiplets. In detail the method of optimized 2-dimensional deconvolution is described in [8].; Mathematical formulation of 2-dimensional convolution system is as follows; \[ y(i_1,i_2) = \sum_{k_1=0}^{N_1-1}\sum_{k_2=0}^{N_2-1}h(i_1-k_1,i_2-k_2)x(k_1,k_2), i_1=0,1,2,...,N_1-1, i_2=0,1,2,...,N_2-1 \]; Assuming we know the output spectrum y and the response spectrum h,the task is to calculate the matrix x.; The basic function has the form; char *Deconvolution2(float **source,; const float **resp,; int sizex,; int sizey,; int niter);; This function calculates deconvolution from source spectrum according to response spectrum. The result is placed in the matrix pointed by source pointer.; Function parameters:. source pointer to the matrix of source spectrum; resp pointer to the matrix of response spectrum; sizex x length of source and response spectra; sizey y length of source and response spectra; number_of_iterations for details see [8]. The example of 2-dimensional spectrum before deconvolution is presented in Figure 4.13. In the process ",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:35501,Performance,optimiz,optimized,35501,"rge blocks of data and large number of parameters.; The other one is based on calculation of the system of linear equations using Stiefel-Hestens method [10]. It converges faster than awmi algorithm, however it is not suitable to fit large number of parameters.; 5.1 1-DIMENSIONAL SPECTRA. the quantity to be minimized in the fitting procedure for one dimensional spectrum is defined as :. \[ \chi^2 = \frac{1}{N-M}\sum_{i=1}^{N}\frac{[y_i-f(i,a)]^2}{y_i} \]; where \(i\) is the channel in the fitted spectrum, \(N\) is the number of channels in the fitting subregion, \(M\) is the number of free parameters, \(y_i\) is the content of the i-th channel, \(a\) is a vector of the parameters being fitted and \(f(i,a)\) is a fitting or peak shape function.; Instead of the weighting coefficient \(y_i\) in the denominator of the above given formula one can use also the value of \(f(i,a)\). It is suitable for data with poorstatistics [11], [12].; The third statistic to be optimized, which is implemented in the fitting functions is Maximum Likelihood Method. It is of the choice of the user to select suitable statistic.. after differentiating \(\chi^2\) we obtain the following \(M\) simultaneous equations. \[ \sum_{i=1}^{N}; \frac{y_i-f(i,a^{(t)})}{y_i}; \frac{\partial f(i,a^t)}{\partial a_k}=; \sum_{j=1}^{M}\sum_{i=1}^{N}; \frac{\partial f(i,a^{(t)})}{\partial a_j}; \frac{\partial f(i,a^{(t)})}{\partial a_k}; \Delta a_j^{(t)} \]. in \(\gamma\)-ray spectra we have to fit together tens, hundreds of peaks simultaneously that represent sometimes thousands of parameters.; the calculation of the inversion matrix of such a size is practically impossible.; the awmi method is based on the assumption that off-diagonal terms in the matrix A are equal to zero. \[; \Delta a_{k}^{(t+1)} = \alpha^{(t)}; \frac{; \sum_{i=1}^{N} \frac{e_{i}^{(t)}}{y_i}\frac{\partial f(i,a^{(t)})}{\partial a_k}; }{; \sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}; }; \]; where th",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:36747,Performance,optimiz,optimize,36747,"{i=1}^{N}; \frac{y_i-f(i,a^{(t)})}{y_i}; \frac{\partial f(i,a^t)}{\partial a_k}=; \sum_{j=1}^{M}\sum_{i=1}^{N}; \frac{\partial f(i,a^{(t)})}{\partial a_j}; \frac{\partial f(i,a^{(t)})}{\partial a_k}; \Delta a_j^{(t)} \]. in \(\gamma\)-ray spectra we have to fit together tens, hundreds of peaks simultaneously that represent sometimes thousands of parameters.; the calculation of the inversion matrix of such a size is practically impossible.; the awmi method is based on the assumption that off-diagonal terms in the matrix A are equal to zero. \[; \Delta a_{k}^{(t+1)} = \alpha^{(t)}; \frac{; \sum_{i=1}^{N} \frac{e_{i}^{(t)}}{y_i}\frac{\partial f(i,a^{(t)})}{\partial a_k}; }{; \sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}; }; \]; where the error in the channel \(i\) is \(e_{i}^{(t)} = y_i-f(i,a^{(t)}); k=1,2,...,M\) and \(\alpha^{(t)}=1\) if the process is convergent or \(\alpha^{(t)}=0.5 \alpha^{(t-1)}\) if it is divergent. Another possibility is to optimize this coefficient.; the error of \(k\)-th parameter estimate is; \[; \Delta a_k^{(e)}=; \sqrt{\frac; {\sum_{i=1}^{N}\frac{e_i^2}{y_i}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}}; }; \]; algorithm with higher powers w=1,2,3…; \[; \Delta a_{k,w}^{(t+1)}=; \alpha^{(t)}; \frac; {\sum_{i=1}^{N} \frac{e_i}{y_i}\left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w-1}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w}\frac{1}{y_i}}; \]; we have implemented the nonsymmetrical semiempirical peak shape function.; it contains the symmetrical Gaussian as well as nonsymmetrical terms.; \[; f(i,a) =; \sum_{i=1}^{M} A(j); \left\{; exp\left[\frac{-(i-p(j))^2}{2\sigma^2}\right]; +\frac{1}{2}T.exp\left[\frac{(i-p(j))}{B\sigma}\right]; .erfc\left[\frac{(i-p(j))}{\sigma}+\frac{1}{2B}\right]; +\frac{1}{2}S.erfc\left[\frac{(i-p(j))}{\sigma}\right]; \right\}; \]; where \(T,S\) are relative amplitudes and \(B\) is a slop",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:39109,Performance,optimiz,optimization,39109,"rce,; TSpectrumOneDimFit *p,; int size);; This function fits the source spectrum. The calling program should fill in input parameters of the one_dim_fit structure The fitted parameters are written into structure pointed by one_dim_fit structure pointer and fitted data are written into source spectrum.; Function parameters:. source pointer to the vector of source spectrum; p pointer to the one_dim_fit structure pointer; size length of source spectrum. The one_dim_fit structure has the form:; class TSpectrumOneDimFit{. public:. int number_of_peaks; // input parameter, should be >0; int number_of_iterations; // input parameter, should be >0; int xmin; // first fitted channel; int xmax; // last fitted channel; double alpha; // convergence coefficient, input parameter, it should be; // positive number and <=1; double chi; // here the function returns resulting chi-square; int statistic_type; // type of statistics, possible values; // FIT1_OPTIM_CHI_COUNTS (chi square statistics with; // counts as weighting coefficients),; // FIT1_OPTIM_CHI_FUNC_VALUES (chi square statistics; // with function values as weighting coefficients); // FIT1_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values; // FIT1_ALPHA_HALVING,; // FIT1_ALPHA_OPTIMAL; int power; // possible values FIT1_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values; // FIT1_TAYLOR_ORDER_FIRST, FIT1_TAYLOR_ORDER_SECOND. double position_init[MAX_NUMBER_OF_PEAKS1]; // initial values of; // peaks positions, input parameters; double position_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values; // of fitted positions, output parameters; double position_err[MAX_NUMBER_OF_PEAKS1]; // position errors; bool fix_position[MAX_NUMBER_OF_PEAKS1]; // logical vector which allows to fix; // appropriate positions (not fit). However they; // are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks; // amplitudes",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:46327,Performance,optimiz,optimization,46327,"er to the matrix of source spectrum; p pointer to the two_dim_fit structure pointer, see manual; sizex length x of source spectrum; sizey length y of source spectrum. The two_dim_fit structure has the form; class TSpectrumTwoDimFit{. public:. int number_of_peaks; // input parameter, shoul be>0; int number_of_iterations; // input parameter, should be >0; int xmin; // first fitted channel in x direction; int xmax; // last fitted channel in x direction; int ymin; // first fitted channel in y direction; int ymax; // last fitted channel in y direction; double alpha; // convergence coefficient, input parameter, it should be positive; // number and <=1; double chi; // here the function returns resulting chi square; int statistic_type; // type of statistics, possible values; // FIT2_OPTIM_CHI_COUNTS (chi square statistics with; // counts as weighting coefficients),; // FIT2_OPTIM_CHI_FUNC_VALUES (chi square statistics; // with function values as weighting; // coefficients),FIT2_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values; // FIT2_ALPHA_HALVING, FIT2_ALPHA_OPTIMAL; int power; // possible values FIT21_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values; // FIT2_TAYLOR_ORDER_FIRST,; // FIT2_TAYLOR_ORDER_SECOND; double position_init_x[MAX_NUMBER_OF_PEAKS2]; // initial values of x; // positions of 2D peaks, input parameters; double position_calc_x[MAX_NUMBER_OF_PEAKS2]; // calculated values; // of fitted x positions of 2D peaks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate; // x positions of 2D peaks (not fit).; // However they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y; // positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values; /",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:4503,Testability,log,logical,4503,"mation of the Compton edges and decreasing clipping window. In the lower part of the Figure we present the background, which was added to the synthetic spectrum. One can observe good coincidence with the estimated background. The method of the estimation of Compton edge is described in detail in [3]. Synthetic spectrum with Compton edges. The generalized form of the algorithm is implemented in the function.; char *Background1General(float *spectrum,; int size,; int number_of_iterations,; int direction,; int filter_order,; bool compton);; The meaning of the parameters is as follows:. spectrum pointer to the vector of source spectrum; size length of spectrum vector; number_of_iterations maximal width of clipping window,; direction direction of change of clipping window. Possible values:. BACK1_INCREASING_WINDOW; BACK1_DECREASING_WINDOW. filter_order order of clipping filter. Possible values:. BACK1_ORDER2; BACK1_ORDER4; BACK1_ORDER6; BACK1_ORDER8. compton logical variable whether the estimation of Compton edge will be included. Possible values:. BACK1_EXCLUDE_COMPTON; BACK1_INCLUDE_COMPTON. 1.2 2-DIMENSIONAL SPECTRA; This basic background estimation function allows to separate useless spectrum information (2D-continuous background and coincidences of peaks with background in both dimensions) from peaks. It calculates background spectrum from source spectrum. The result is placed in the array pointed by spectrum pointer. On successful completion it returns 0. On error it returns pointer to the string describing error.; char *Background2(float **spectrum,; int sizex,; int sizey,; int number_of_iterations);; Function parameters:. spectrum pointer to the array of source spectrum; sizex x length of spectrum; sizey y length of spectrum; number_of_iterations width of the clipping window. In Figure 1.6 we present an example of 2-dimensional spectrum before background elimination. 2-dimensional spectrum before background elimination. Estimated background is shown in Figure 1.7",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:18566,Testability,log,logical,18566,"um is smoother than the original one. On the other hand it emphasizes peaks (depending on the averaging window). The example of the part of original noisy spectrum and Markov spectrum for window=3 is given in Figure 3.5 Then the peaks can found in Markov spectrum using standard above presented algorithm. Part of original noisy spectrum and Markov spectrum for window=3. The form of the generalized peak searching function is as follows.; Int-t Search1General(float *spectrum,; int size,; float sigma,; int threshold,; bool markov,; int aver-window);; This function searches for peaks in source spectrum. The number of found peaks and their positions are written into structure pointed by one_dim_peak structure pointer.; Function parameters:. spectrum pointer to the vector of source spectrum source spectrum is replaced by new spectrum calculated using Markov chains method.; size length of source spectrum; sigma sigma of searched peaks; threshold threshold value for selecting of peaks; markov logical variable, if it is true, first the source spectrum is replaced by new spectrum calculated using Markov chains method.; aver_window averaging window used in calculation of Markov spectrum, applies only for markov variable is true. The methods of peak searching are sensitive to the sigma. Usually the sigma value is known beforehand. It also changes only slightly with the energy. We have investigated as well the robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10 (see Figure 3.6). Robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10. We applied peak searching algorithm based on Markov approach. We changed sigma in the interval from 1 to 10. The spectra for averaging windows 3, 5, 10 are shown in Figure 3.7. Spectra for averaging windows 3, 5, 10. When we applied peak searching function to the Markov spectrum averaged with the window=10, we obtained correct estimate of all 10 peak posit",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:21383,Testability,log,logical,21383,"im_peak structure pointer.; Function parameters:. source pointer to the vector of source spectrum; sizex x length of source spectrum; sizey y length of source spectrum; sigma sigma of searched peaks. An example of the two-dimensional spectrum with the identified peaks is shown in Figure 3.8. Two-dimensional spectrum with the identified peaks. We have also generalized the peak searching function analogously to one dimensional data. The generalized peak searching function for two dimensional spectra has the form; Int-t Search2General(float **source,; int sizex,; int sizey,; double sigma,; int threshold,; bool markov,; int aver-window);; This function searches for peaks in source spectrum. The number of found peaks and their positions are written into structure pointed by two_dim_peak structure pointer.; Function parameters:. source pointer to the vector of source spectrum; sizex x length of source spectrum; sizey y length of source spectrum; sigma sigma of searched peaks; threshold threshold value for selection of peaks; markov logical variable, if it is true, first the source spectrum is replaced by new spectrum calculated using Markov chains method.; aver_window averaging window of searched peaks (applies only for Markov method). An example of experimental 2-dimensional spectrum is given in Figure 3.9. The number of peaks identified by the function now is 295. Experimental 2-dimensional spectrum. The function works even for very noisy data. In Figure 3.10 we present synthetic 2-dimensional spectrum with 5 peaks. The method should recognize what is real 2-dimensional peak and what is the crossing of two 1-dimensional ridges The Markov spectrum with averaging window=3 is given in Figure 3.11. One can observe that this spectrum is smoother than the original one. After applying the general peak searching function to the Markov spectrum with sigma=2, and threshold=600, we get correctly identified peaks. Synthetic 2-dimensional spectrum with 5 peaks. Markov spectrum with a",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:39711,Testability,log,logical,39711,"fitted channel; int xmax; // last fitted channel; double alpha; // convergence coefficient, input parameter, it should be; // positive number and <=1; double chi; // here the function returns resulting chi-square; int statistic_type; // type of statistics, possible values; // FIT1_OPTIM_CHI_COUNTS (chi square statistics with; // counts as weighting coefficients),; // FIT1_OPTIM_CHI_FUNC_VALUES (chi square statistics; // with function values as weighting coefficients); // FIT1_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values; // FIT1_ALPHA_HALVING,; // FIT1_ALPHA_OPTIMAL; int power; // possible values FIT1_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values; // FIT1_TAYLOR_ORDER_FIRST, FIT1_TAYLOR_ORDER_SECOND. double position_init[MAX_NUMBER_OF_PEAKS1]; // initial values of; // peaks positions, input parameters; double position_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values; // of fitted positions, output parameters; double position_err[MAX_NUMBER_OF_PEAKS1]; // position errors; bool fix_position[MAX_NUMBER_OF_PEAKS1]; // logical vector which allows to fix; // appropriate positions (not fit). However they; // are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks; // amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of; // fitted amplitudes, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS1]; // amplitude errors; bool fix_amp[MAX_NUMBER_OF_PEAKS1]i; // logical vector, which allows to fix; // appropriate amplitudes (not fit). However they; // are present in the estimated functional; double area[MAX_NUMBER_OF_PEAKS1]; // calculated areas of peaks; double area_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak areas. double sigma_init // sigma parameter, see peak shape function; double sigma_calc;; double sigma_err;; bool fix_sigma;; double t_init // t parameter, , see peak shape function; doub",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:40145,Testability,log,logical,40145,"stics; // with function values as weighting coefficients); // FIT1_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values; // FIT1_ALPHA_HALVING,; // FIT1_ALPHA_OPTIMAL; int power; // possible values FIT1_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values; // FIT1_TAYLOR_ORDER_FIRST, FIT1_TAYLOR_ORDER_SECOND. double position_init[MAX_NUMBER_OF_PEAKS1]; // initial values of; // peaks positions, input parameters; double position_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values; // of fitted positions, output parameters; double position_err[MAX_NUMBER_OF_PEAKS1]; // position errors; bool fix_position[MAX_NUMBER_OF_PEAKS1]; // logical vector which allows to fix; // appropriate positions (not fit). However they; // are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks; // amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of; // fitted amplitudes, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS1]; // amplitude errors; bool fix_amp[MAX_NUMBER_OF_PEAKS1]i; // logical vector, which allows to fix; // appropriate amplitudes (not fit). However they; // are present in the estimated functional; double area[MAX_NUMBER_OF_PEAKS1]; // calculated areas of peaks; double area_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak areas. double sigma_init // sigma parameter, see peak shape function; double sigma_calc;; double sigma_err;; bool fix_sigma;; double t_init // t parameter, , see peak shape function; double t_calc;; double t_err;; bool fix_t;; double b_init // b parameter, , see peak shape function; double b_calc;; double b_err;; bool fix_b;; double s_init; // s parameter, , see peak shape function; double s_calc;; double s_err;; bool fix_s;; double a0_init; // backgroud is estimated as a0+a1*x+a2*x*x; double a0_calc;; double a0_err;; bool fix_a0;; double a1_init;; double a1_calc;; double a1_err;; bool fix_a1;;",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:46974,Testability,log,logical,46974,"er to the matrix of source spectrum; p pointer to the two_dim_fit structure pointer, see manual; sizex length x of source spectrum; sizey length y of source spectrum. The two_dim_fit structure has the form; class TSpectrumTwoDimFit{. public:. int number_of_peaks; // input parameter, shoul be>0; int number_of_iterations; // input parameter, should be >0; int xmin; // first fitted channel in x direction; int xmax; // last fitted channel in x direction; int ymin; // first fitted channel in y direction; int ymax; // last fitted channel in y direction; double alpha; // convergence coefficient, input parameter, it should be positive; // number and <=1; double chi; // here the function returns resulting chi square; int statistic_type; // type of statistics, possible values; // FIT2_OPTIM_CHI_COUNTS (chi square statistics with; // counts as weighting coefficients),; // FIT2_OPTIM_CHI_FUNC_VALUES (chi square statistics; // with function values as weighting; // coefficients),FIT2_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values; // FIT2_ALPHA_HALVING, FIT2_ALPHA_OPTIMAL; int power; // possible values FIT21_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values; // FIT2_TAYLOR_ORDER_FIRST,; // FIT2_TAYLOR_ORDER_SECOND; double position_init_x[MAX_NUMBER_OF_PEAKS2]; // initial values of x; // positions of 2D peaks, input parameters; double position_calc_x[MAX_NUMBER_OF_PEAKS2]; // calculated values; // of fitted x positions of 2D peaks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate; // x positions of 2D peaks (not fit).; // However they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y; // positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values; /",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:47482,Testability,log,logical,47482,"pha_optim; // optimization of convergence coefficients, possible values; // FIT2_ALPHA_HALVING, FIT2_ALPHA_OPTIMAL; int power; // possible values FIT21_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values; // FIT2_TAYLOR_ORDER_FIRST,; // FIT2_TAYLOR_ORDER_SECOND; double position_init_x[MAX_NUMBER_OF_PEAKS2]; // initial values of x; // positions of 2D peaks, input parameters; double position_calc_x[MAX_NUMBER_OF_PEAKS2]; // calculated values; // of fitted x positions of 2D peaks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate; // x positions of 2D peaks (not fit).; // However they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y; // positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values; // of fitted y positions of 2D peaks, output parameters; double position_err_y[MAX_NUMBER_OF_PEAKS2]; // y position errors of 2D peaks; bool fix_position_y[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate; // y positions of 2D peaks (not fit).; // However they are present in the estimated functional; double position_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of x; // positions of 1D ridges, input parameters; double position_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of; // fitted x positions of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate; // x positions of 1D ridges (not fit).; // However they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y; // positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calcu",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:47997,Testability,log,logical,47997,"aks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate; // x positions of 2D peaks (not fit).; // However they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y; // positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values; // of fitted y positions of 2D peaks, output parameters; double position_err_y[MAX_NUMBER_OF_PEAKS2]; // y position errors of 2D peaks; bool fix_position_y[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate; // y positions of 2D peaks (not fit).; // However they are present in the estimated functional; double position_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of x; // positions of 1D ridges, input parameters; double position_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of; // fitted x positions of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate; // x positions of 1D ridges (not fit).; // However they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y; // positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values; // of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix; // appropriate y positions of 1D ridges (not fit).; // However they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks; // amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of; ",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:48513,Testability,log,logical,48513,"put parameters; double position_err_y[MAX_NUMBER_OF_PEAKS2]; // y position errors of 2D peaks; bool fix_position_y[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate; // y positions of 2D peaks (not fit).; // However they are present in the estimated functional; double position_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of x; // positions of 1D ridges, input parameters; double position_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of; // fitted x positions of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate; // x positions of 1D ridges (not fit).; // However they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y; // positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values; // of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix; // appropriate y positions of 1D ridges (not fit).; // However they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks; // amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of; // fitted amplitudes of 2D peaks, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 2D peaks; bool fix_amp[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows; // to fix appropriate amplitudes of 2D peaks (not fit).; // However they are present in the estimated functional; double amp_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D; // ridges amplitudes, input parameters; double amp_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of; // fitted amplitudes of 1D ridges, o",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:48988,Testability,log,logical,48988," of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate; // x positions of 1D ridges (not fit).; // However they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y; // positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values; // of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix; // appropriate y positions of 1D ridges (not fit).; // However they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks; // amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of; // fitted amplitudes of 2D peaks, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 2D peaks; bool fix_amp[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows; // to fix appropriate amplitudes of 2D peaks (not fit).; // However they are present in the estimated functional; double amp_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D; // ridges amplitudes, input parameters; double amp_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of; // fitted amplitudes of 1D ridges, output parameters; double amp_err_x1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which alloes to fix; // appropriate amplitudes of 1D ridges (not fit).; // However they are present in the estimated functional; double amp_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D; // ridges amplitudes, input parameters; double amp_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of; // fitted amplitudes of 1D ridges, output ",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:49476,Testability,log,logical,49476,"ed values; // of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix; // appropriate y positions of 1D ridges (not fit).; // However they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks; // amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of; // fitted amplitudes of 2D peaks, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 2D peaks; bool fix_amp[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows; // to fix appropriate amplitudes of 2D peaks (not fit).; // However they are present in the estimated functional; double amp_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D; // ridges amplitudes, input parameters; double amp_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of; // fitted amplitudes of 1D ridges, output parameters; double amp_err_x1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which alloes to fix; // appropriate amplitudes of 1D ridges (not fit).; // However they are present in the estimated functional; double amp_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D; // ridges amplitudes, input parameters; double amp_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of; // fitted amplitudes of 1D ridges, output parameters; double amp_err_y1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix; // appropriate amplitudes of 1D ridges (not fit).; // However they are present in the estimated functional; double volume[MAX_NUMBER_OF_PEAKS1]; // calculated volumes of peaks; double volume_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak volumes; double sigma_init_x; // sigma x parameter; double sigma_calc_x;; double",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:49965,Testability,log,logical,49965,"lculated values of; // fitted amplitudes of 2D peaks, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 2D peaks; bool fix_amp[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows; // to fix appropriate amplitudes of 2D peaks (not fit).; // However they are present in the estimated functional; double amp_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D; // ridges amplitudes, input parameters; double amp_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of; // fitted amplitudes of 1D ridges, output parameters; double amp_err_x1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which alloes to fix; // appropriate amplitudes of 1D ridges (not fit).; // However they are present in the estimated functional; double amp_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D; // ridges amplitudes, input parameters; double amp_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of; // fitted amplitudes of 1D ridges, output parameters; double amp_err_y1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix; // appropriate amplitudes of 1D ridges (not fit).; // However they are present in the estimated functional; double volume[MAX_NUMBER_OF_PEAKS1]; // calculated volumes of peaks; double volume_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak volumes; double sigma_init_x; // sigma x parameter; double sigma_calc_x;; double sigma_err_x;; bool fix_sigma_x;; double sigma_init_y; // sigma y parameter; double sigma_calc_y;; double sigma_err_y;; bool fix_sigma_y;; double ro_init; // correlation coefficient; double ro_calc;; double ro_err;; bool fix_ro;; double txy_init; // t parameter for 2D peaks; double txy_calc;; double txy_err;; bool fix_txy;; double sxy_init; // s parameter for 2D peaks; double sxy_calc;; double sxy_err;; bool fix_sxy;; double tx_init; // t parameter for 1D ridges (x direction); double ",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:67003,Testability,log,log,67003,"s is apparent from description of one_dim_pic structure. The constants , which can be used for appropriate parameters are defined in procfunc.h header file.; struct one_dim_pic {. float *source; // spectrum to be displayed. TCanvas *Canvas; // Canvas where the spectrum will be displayed. int size; // size of source spectrum; int xmin; // x-starting channel of spectrum; int xmax; // x-end channel of spectrum; int ymin; // base counts; int ymax; // count full scale. int bx1; // position of picture on Canvas, min x; int bx2; // position of picture on Canvas, max x; int by1; // position of picture on Canvas, min y; int by2; // position of picture on Canvas, max y. int display_mode; // spectrum display mode (points, polyline, bars, rainbow, steps, bezier); int y_scale; // y scale (linear, log, sqrt); int levels; // # of color levels for rainbow display mode, it does not apply; // for other display modes; float rainbow1_step; // determines the first color component step for neighbouring; // color levels, applies only for rainbow display mode; float rainbow2_step; // determines the second component color step for; // neighbouring color levels, applies only for rainbow display mode; float rainbow3_step; // determines the third component color step for; // neighbouring color levels, applies only for rainbow display mode. int color_alg; // applies only for rainbow display mode (rgb smooth algorithm, rgb; // modulo color component, cmy smooth algorithm, cmy modulo color; // component, cie smooth algorithm, cie modulo color component, yiq; // smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component [15]. int bar_thickness; // applies only for bar display mode; int bar_empty_flag; // (empty bars, full bars) applies only for bar display mode; int border_color; // color of background of the picture; int full_border; // decides whether background is painted; int raster_en_dis; // decides whether the axes and rasters are shown; int raster_lon",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:69165,Testability,log,log,69165,"es and rasters are shown; int raster_long; // decides whether the rasters are drawn as long lines; int raster_color; // color of the rasters; char *raster_description_x; // x axis description; char *raster_description_y; // y axis description. int pen_color; // color of spectrum; int pen_dash; // style of pen; int pen_width; // width of line. int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_color; // color of channel marks. // auxiliary variables, transform coefficients, for internal use only; double mx;; double my;; double px;; double py;. // auxiliary internal variables, working place; double gbezx,gbezy;; TPoint bz[4];; };; The examples using different display parameters are shown in the next few Figures. Display mode -polyline, width of pen=3. Display mode- bars, shown channel marks. Display mode- steps, log scale, shown channel marks. Display mode -Bezier curve interpolation, shown channel marks. Display mode- rainbow bars, color algorithm (model) RGB, number of color levels=1024, pen width=3. Display mode-empty bars, color algorithm YIQ, number of color levels 2048. 7.2 2-DIMENSIONAL SPECTRA; The 2-dimensional visualization function displays spectrum (or part of it) on the Canvas of a form. Before calling the function one has to fill in two_dim_pic structure containing all parameters of the display. The function has the form; char *display2(struct two-dim-pic* p);; This function displays the source two dimensional spectrum on Canvas. All parameters are grouped in two_dim_pic structure. Before calling display2 function the structure should be filled in and the address of two_dim_pic passed as parameter to display2 function. The meaning of appropriate parameters is apparent from description of one_dim_pic structure. The constants , which can be used for appropriate parameters are defined in",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:71387,Testability,log,log,71387," y-size of source spectrum; int xmin; // x-starting channel of spectrum; int xmax; // x-end channel of spectrum; int ymin; // y-starting channel of spectrum; int ymax; // y-end channel of spectrum; int zmin; // base counts; int zmax; // counts full scale; int bx1; // position of picture on Canvas, min x; int bx2; // position of picture on Canvas, max x; int by1; // position of picture on Canvas, min y; int by2; // position of picture on Canvas, max y; int mode_group; // display mode algorithm group (simple modes-; // PICTURE2_MODE_GROUP_SIMPLE, modes with shading; // according to light-PICTURE2_MODE_GROUP_LIGHT, modes with; // shading according to channels counts-; // PICTURE2_MODE_GROUP_HEIGHT, modes of combination of; // shading according to light and to channels counts-; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT); int display_mode; // spectrum display mode (points, grid, contours, bars, x_lines,; // y_lines, bars_x, bars_y, needles, surface, triangles); int z_scale; // z scale (linear, log, sqrt); int nodesx; // number of nodes in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighbouring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighbouring; // color levels, applies only for rainbowed displ",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:75580,Testability,log,log,75580,"idth of line; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_color; // color of channel marks; int chanline_en_dis; // decides whether the channel lines (grid) are shown. // auxiliary variables, transformation coefficients for internal use only; double kx;; double ky;; double mxx;; double mxy;; double myx;; double myy;; double txx;; double txy;; double tyx;; double tyy;; double tyz;; double vx;; double vy;; double nu_sli;. // auxiliary internal variables, working place; double z,zeq,gbezx,gbezy,dxspline,dyspline;; int xt,yt,xs,ys,xe,ye,priamka,z_preset_value;; unsigned short obal[MAXIMUM_XSCREEN_RESOLUTION];; unsigned short obal_cont[MAXIMUM_XSCREEN_RESOLUTION];; TPoint bz[4];; };; The examples using different display parameters are shown in the next few Figures. Display mode-bars, pen width=2. Display mode-triangles, log scale. Display mode-contours. Display mode surface shading according to height. Display mode-surface shading according to light point. Display mode-surface shading according to height+light position with ratio 50:50, CMY color model. Display mode bars shaded according to height. Display mode- surface shading according to light position with shadows. Display mode- surface shading according to height with 10 levels of contours. Display mode- surface shading according to height, sqrt scale, channel marks and lines shown. Display mode- surface shading according to height-contours, rasters allowing to localize interesting parts are shown. References; [1] M. Morháč, J. Kliman, V. Matoušek, M. Veselský, I. Turzo.: Background elimination methods for multidimensional gamma-ray spectra. NIM, A401 (1997) 113-132.; [2] C. G Ryan et al.: SNIP, a statistics-sensitive background treatment for the quantitative analysis of PIXE spectra in geoscience applications. NIM, B34 (1988), 396-402.; [",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:16471,Usability,simpl,simple,16471,"etail described in [4], [5]. It allows to identify automatically the peaks in a spectrum with the presence of the continuous background and statistical fluctuations - noise. The algorithm is based on smoothed second differences that are compared to its standard deviations. Therefore it is necessary to pass a parameter of sigma to the peak searching function. The algorithm is selective to the peaks with the given sigma. The form of the basic peak searching function is; Int-t Search1(const float *spectrum,; int size,; double sigma);; This function searches for peaks in source spectrum. The number of found peaks and their positions are written into structure pointed by one_dim_peak structure pointer.; Function parameters:. source pointer to the vector of source spectrum; p pointer to the one_dim_peak structure pointer; size length of source spectrum; sigma sigma of searched peaks. The structure one_dim_peak has the form:; struct one_dim_peak{; int number_of_peaks;; double position[MAX_NUMBER_OF_PEAKS1];; };; An example of simple one-dimensional spectrum with identified peaks is given in Figure 3.1. Simple one-dimensional spectrum with identified peaks. An example of 1-dimensional experimental spectrum with many identified peaks is given in Figure 3.2. 1-dimensional experimental spectrum with many identified peaks. However when we have noisy data the number of peaks can be enormous. One such an example is given in Figure 3.3. Therefore it can be useful to have possibility to set a threshold value and to consider only the peaks higher than this threshold (see Figure 3.4, only three peaks were identified, threshold=50.) The value in the center of the peak value[i] minus the average value in two symmetrically positioned channels (channels i-3*sigma, i+3*sigma) must be greater than threshold. Otherwise the peak is ignored. With noisy data the number of peaks can be enormous. Iwth threshold=50, only three peaks were identified. An alternative approach was proposed in [6].. T",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:41094,Usability,simpl,simple,41094," fit). However they; // are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks; // amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of; // fitted amplitudes, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS1]; // amplitude errors; bool fix_amp[MAX_NUMBER_OF_PEAKS1]i; // logical vector, which allows to fix; // appropriate amplitudes (not fit). However they; // are present in the estimated functional; double area[MAX_NUMBER_OF_PEAKS1]; // calculated areas of peaks; double area_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak areas. double sigma_init // sigma parameter, see peak shape function; double sigma_calc;; double sigma_err;; bool fix_sigma;; double t_init // t parameter, , see peak shape function; double t_calc;; double t_err;; bool fix_t;; double b_init // b parameter, , see peak shape function; double b_calc;; double b_err;; bool fix_b;; double s_init; // s parameter, , see peak shape function; double s_calc;; double s_err;; bool fix_s;; double a0_init; // backgroud is estimated as a0+a1*x+a2*x*x; double a0_calc;; double a0_err;; bool fix_a0;; double a1_init;; double a1_calc;; double a1_err;; bool fix_a1;; double a2_init;; double a2_calc;; double a2_err;; bool fix_a2;; };; As an example we present simple 1-dimensional synthetic spectrum with 5 peaks. The fit obtained using above given awmi fitting function is given in Figure 5.1. The chi-square achieved in this fit was 0.76873. The input value of the fit (positions of peaks and their amplitudes) were estimated using peak searching function. Fit obtained using above given awmi fitting function. Let us go to more complicated fit with lot of overlapping peaks Figure 5.2. The initial positions of peaks were determined from original data, using peak searching function. The fit is not very good, as there are some peaks missing. More complicated fit with lot of overlapping peaks. However to analyze the spectrum we can proce",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:70894,Usability,simpl,simple,70894,,MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:72022,Usability,simpl,simple,72022,"hading according to channels counts-; // PICTURE2_MODE_GROUP_HEIGHT, modes of combination of; // shading according to light and to channels counts-; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT); int display_mode; // spectrum display mode (points, grid, contours, bars, x_lines,; // y_lines, bars_x, bars_y, needles, surface, triangles); int z_scale; // z scale (linear, log, sqrt); int nodesx; // number of nodes in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighbouring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighbouring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighbouring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // dis",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:72223,Usability,simpl,simple,72223,"de; // spectrum display mode (points, grid, contours, bars, x_lines,; // y_lines, bars_x, bars_y, needles, surface, triangles); int z_scale; // z scale (linear, log, sqrt); int nodesx; // number of nodes in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighbouring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighbouring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighbouring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGH",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:72425,Usability,simpl,simple,72425,"s in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighbouring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighbouring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighbouring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT modes group; int xlight; // x position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int ylight; // y position of fictive light source, applies",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:72626,Usability,simpl,simple,72626,"ta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighbouring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighbouring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighbouring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT modes group; int xlight; // x position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int ylight; // y position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int zlight; // z position of fictive light source, applies only for rainbowed display; // modes with shading according to light; i",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:73012,Usability,simpl,simple,73012,"or; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighbouring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighbouring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighbouring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT modes group; int xlight; // x position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int ylight; // y position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int zlight; // z position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int shadow; // determines whether shadow will be drawn (no shadow, shadow),; // for rainbowed display modes with shading according to light; int shading; // determines whether the picture will shaded, smoothed (no shading,; // shading), for rainbowed display modes only; int bezier; // determines Bezier interpolation (applies only for simple display; // modes group for grid, x_lines, y",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/html534/guides/spectrum/Spectrum.html:73965,Usability,simpl,simple,73965,"color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT modes group; int xlight; // x position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int ylight; // y position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int zlight; // z position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int shadow; // determines whether shadow will be drawn (no shadow, shadow),; // for rainbowed display modes with shading according to light; int shading; // determines whether the picture will shaded, smoothed (no shading,; // shading), for rainbowed display modes only; int bezier; // determines Bezier interpolation (applies only for simple display; // modes group for grid, x_lines, y_lines display modes); int border_color; // color of background of the picture; int full_border; // decides whether background is painted; int raster_en_dis; // decides whether the rasters are shown; int raster_long; // decides whether the rasters are drawn as long lines; int raster_color; // color of the rasters; char *raster_description_x; // x axis description; char *raster_description_y; // y axis description; char *raster_description_z; // z axis description; int pen_color; // color of spectrum; int pen_dash; // style of pen; int pen_width; // width of line; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_color; // color of channel marks; int chanline_en_dis; // decides whether the channel lines (grid) are shown.",MatchSource.WIKI,root/html534/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:11897,Availability,avail,available,11897,"""/root.app/"">; AuthType Digest; AuthName ""root""; AuthDigestDomain ""/root.app/"" ""root""; AuthDigestProvider file; AuthUserFile ""/srv/auth/auth.txt""; Require valid-user; </Location>; 1.7.2 Configure fastcgi with lighttpd; An example of configuration file for lighttpd server is:; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); Be aware, that with lighttpd one should specify IP address of the host, where ROOT application is running. Address of the ROOT application will be following: http://lighttpd_host_name/root.app/. Example of authorization configuration for FastCGI connection:; auth.require = ( ""/root.app"" => (; ""method"" => ""digest"",; ""realm"" => ""root"",; ""require"" => ""valid-user""; ) ); 1.8 Integration with existing applications; In many practical cases no change of existing code is required. Opened files (and all objects inside), existing canvas and histograms are automatically scanned by the server and will be available to the users. If necessary, any object can be registered directly to the server with a THttpServer::Register() call.; Central point of integration - when and how THttpServer get access to data from a running application. By default it is done during the gSystem->ProcessEvents() call - THttpServer uses a synchronous timer which is activated every 100 ms. Such approach works perfectly when running macros in an interactive ROOT session.; If an application runs in compiled code and does not contain gSystem->ProcessEvents() calls, two method are available.; 1.8.1 Asynchronous timer; The first method is to configure an asynchronous timer for the server, like for example:; serv->SetTimer(100, kFALSE);; Then, the timer will be activated even without any gSystem->ProcessEvents() method call. The main advantage of such method is that the application code can be used without any modifications. But there is no control when access to the a",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:12454,Availability,avail,available,12454," Address of the ROOT application will be following: http://lighttpd_host_name/root.app/. Example of authorization configuration for FastCGI connection:; auth.require = ( ""/root.app"" => (; ""method"" => ""digest"",; ""realm"" => ""root"",; ""require"" => ""valid-user""; ) ); 1.8 Integration with existing applications; In many practical cases no change of existing code is required. Opened files (and all objects inside), existing canvas and histograms are automatically scanned by the server and will be available to the users. If necessary, any object can be registered directly to the server with a THttpServer::Register() call.; Central point of integration - when and how THttpServer get access to data from a running application. By default it is done during the gSystem->ProcessEvents() call - THttpServer uses a synchronous timer which is activated every 100 ms. Such approach works perfectly when running macros in an interactive ROOT session.; If an application runs in compiled code and does not contain gSystem->ProcessEvents() calls, two method are available.; 1.8.1 Asynchronous timer; The first method is to configure an asynchronous timer for the server, like for example:; serv->SetTimer(100, kFALSE);; Then, the timer will be activated even without any gSystem->ProcessEvents() method call. The main advantage of such method is that the application code can be used without any modifications. But there is no control when access to the application data is performed. It could happen just in-between of TH1::Fill() calls and an histogram object may be incomplete. Therefore such method is not recommended.; 1.8.2 Regular calls of THttpServer::ProcessRequests() method; The second method is preferable - one just inserts in the application regular calls of the THttpServer::ProcessRequests() method, like:; serv->ProcessRequests();; In such case, one can fully disable the timer of the server:; serv->SetTimer(0, kTRUE);; 1.9 Data access from command shell; The big advantage of the http protocol",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:22833,Availability,avail,available,22833,"oot.json\n"");; for (let n = 0; n < res.length; ++n) {; console.log('Requested element of type', res[n]._typename);; // draw('drawid', res[n], 'hist');; }; Here argument “multi” identifies, that server response should be parsed with parseMulti() function, which correctly interprets JSON code, produced by multi.json request. When sending such request to the server, one should provide list of objects names and not forget “?number=N” parameter in the request URL string.; 1.10 Using unix sockets; Starting from ROOT version 6.28, one can start server with unix socket. Just do:; Just call:; [root] new THttpServer(""socket:/tmp/root.socket""); Name of socket should be unique and not match any existing files.; Most easy way to access THttpServer running via unix socket is to configure ssh tunnel:; [shell] ssh -L 7654:/tmp/root.socket localhost; Once such tunnel is configured one can open following URL in web browser:; [shell] xdg-open http://localhost:7654; 1.11 Websockets supports; Websockets support available starting from ROOT v6.12. Minimal example provided in $ROOTSYS/tutorials/http/ws.C macro.; To work with websockets, subclass of THttpWSHandler should be created and registered to THttpServer:; #include ""THttpWSHandler.h"". class TUserHandler : public THttpWSHandler {; public:; TUserHandler(const char *name, const char *title) : THttpWSHandler(name, title) {}. // provide custom HTML page when open correspondent address; TString GetDefaultPageContent() override { return ""file:ws.htm""; }. Bool_t ProcessWS(THttpCallArg *arg) override;; };; Central method is TUserHandler::ProcessWS(THttpCallArg *arg), where four kinds of websockets events should be handled:. WS_CONNECT - clients attempts to create websockets, return false when refusing connection; WS_READY - connection is ready to use, wsid can be obtained with arg->GetWSId() calls; WS_DATA - new portion of data received by webcosket; WS_CLOSE - connection closed by the client, wsid is no longer valid. These kinds are coded as",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:3957,Deployability,update,updated,3957,"ra arguments for THttpServer itself:. Name; Description. readonly, ro; use server in read-only mode (default). readwrite, rw; use server in read-write mode. global; let scan global directories for canvases and files (default). noglobal; disable scan of global directories. basic_sniffer; use basic TRootSniffer without support of hist, gpad, graph, tree classes. Example:; new THttpServer(""http:8080;ro;noglobal""); 1.2 Registering objects; At any time, one could register other objects with the command:; TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);; One should specify sub-folder name, where objects will be registered. If sub-folder name does not starts with slash /, than top-name folder /Objects/ will be prepended. At any time one could unregister objects:; serv->Unregister(gr);; THttpServer does not take ownership over registered objects - they should be deleted by user.; If the objects content is changing in the application, one could enable monitoring flag in the browser - then objects view will be regularly updated.; 1.3 Accessing file system; THttpServer provides partial access to the files from file system. First of all, JSROOT scripts and files can be accessed via “jsrootsys/” path like “http://localhost:8080/jsrootsys/modules/core.mjs”. Files from ROOT install directory can be get via “rootsys/” path like “http://localhost:8080/rootsys/icons/about.xpm”. Also files from current directory where ROOT is running can be accessed via “currentdir/” path like “http://localhost:8080/currentdir/file.txt”.; If necessary, one can add custom path as well, using THttpServer::AddLocation method:; serv->AddLocation(""mydir/"", ""/home/user/specials"");; Then files from that directory could be addressed via URL like “http://localhost:8080/mydir/myfile.root”; 1.4 Command interface; THttpServer class provide simple interface to invoke command from web browser. One just register command like:; serv->RegisterCommand(""/DoSomething"", ""SomeFuncti",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:4211,Deployability,install,install,4211," Example:; new THttpServer(""http:8080;ro;noglobal""); 1.2 Registering objects; At any time, one could register other objects with the command:; TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);; One should specify sub-folder name, where objects will be registered. If sub-folder name does not starts with slash /, than top-name folder /Objects/ will be prepended. At any time one could unregister objects:; serv->Unregister(gr);; THttpServer does not take ownership over registered objects - they should be deleted by user.; If the objects content is changing in the application, one could enable monitoring flag in the browser - then objects view will be regularly updated.; 1.3 Accessing file system; THttpServer provides partial access to the files from file system. First of all, JSROOT scripts and files can be accessed via “jsrootsys/” path like “http://localhost:8080/jsrootsys/modules/core.mjs”. Files from ROOT install directory can be get via “rootsys/” path like “http://localhost:8080/rootsys/icons/about.xpm”. Also files from current directory where ROOT is running can be accessed via “currentdir/” path like “http://localhost:8080/currentdir/file.txt”.; If necessary, one can add custom path as well, using THttpServer::AddLocation method:; serv->AddLocation(""mydir/"", ""/home/user/specials"");; Then files from that directory could be addressed via URL like “http://localhost:8080/mydir/myfile.root”; 1.4 Command interface; THttpServer class provide simple interface to invoke command from web browser. One just register command like:; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"");; Element with name DoSomething will appear in the web browser and can be clicked. It will result in gROOT->ProcessLineSync(""SomeFunction()"") call.; One could configure argument(s) for the command. For that one should use %arg1, %arg2 and so on identifiers. Like:; serv->RegisterCommand(""/DoSomething"", ""SomeFunction(%arg1%,%arg2%)"");; User will be reque",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:9750,Deployability,configurat,configuration,9750,"s execution via ‘exe.json’ or ‘exe.bin’ requests. To allow such action, one could either grant generic access for all or one could allow to execute only special method:; serv->Restrict(""/Folder/histo1"", ""allow=all"");; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle"");; One could provide several options for the same item, separating them with ‘&’ sign:; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle&hide=guest"");; Complete list of supported options could be found in TRootSniffer:Restrict() method documentation.; 1.7 Using FastCGI interface; FastCGI is a protocol for interfacing interactive programs with a web server like Apache, lighttpd, Microsoft ISS and many others.; When starting THttpServer, one could specify:; serv = new THttpServer(""fastcgi:9000"");; In fact, the FastCGI interface can run in parallel to http server. One can just call:; serv = new THttpServer(""http:8080"");; serv->CreateEngine(""fastcgi:9000"");; One could specify a debug parameter to be able to adjust the FastCGI configuration on the web server:; serv->CreateEngine(""fastcgi:9000?debug=1"");; By default 10 threads are used to process FastCGI requests. This number can be changed with “thrds” url parameter:; serv->CreateEngine(""fastcgi:9000?thrds=20"");; If thrds=0 parameter specified, the only thread will be use to received and process all requests.; All user access will be ruled by the main web server. Authorized account names could be used to configure access restriction in THttpServer.; 1.7.1 Configure fastcgi with Apache2; Since Apache version 2.4 FastCGI is directly supported - there is no need to compile and install external modules any more. One only need to enable mod_proxy and mod_proxy_fcgi modules and add following line to Apache2 configuration file:; ProxyPass ""/root.app/"" ""fcgi://localhost:9000/"" enablereuse=on; More information can be found in FastCGI proxy docu. After restarting apache server one should be able to open address: http://apache_host_name/root.app/. There ar",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:10359,Deployability,install,install,10359,"ctive programs with a web server like Apache, lighttpd, Microsoft ISS and many others.; When starting THttpServer, one could specify:; serv = new THttpServer(""fastcgi:9000"");; In fact, the FastCGI interface can run in parallel to http server. One can just call:; serv = new THttpServer(""http:8080"");; serv->CreateEngine(""fastcgi:9000"");; One could specify a debug parameter to be able to adjust the FastCGI configuration on the web server:; serv->CreateEngine(""fastcgi:9000?debug=1"");; By default 10 threads are used to process FastCGI requests. This number can be changed with “thrds” url parameter:; serv->CreateEngine(""fastcgi:9000?thrds=20"");; If thrds=0 parameter specified, the only thread will be use to received and process all requests.; All user access will be ruled by the main web server. Authorized account names could be used to configure access restriction in THttpServer.; 1.7.1 Configure fastcgi with Apache2; Since Apache version 2.4 FastCGI is directly supported - there is no need to compile and install external modules any more. One only need to enable mod_proxy and mod_proxy_fcgi modules and add following line to Apache2 configuration file:; ProxyPass ""/root.app/"" ""fcgi://localhost:9000/"" enablereuse=on; More information can be found in FastCGI proxy docu. After restarting apache server one should be able to open address: http://apache_host_name/root.app/. There are many ways to configure user authentication in Apache. Example of digest auth for FastCGI server:; <Location ""/root.app/"">; AuthType Digest; AuthName ""root""; AuthDigestDomain ""/root.app/"" ""root""; AuthDigestProvider file; AuthUserFile ""/srv/auth/auth.txt""; Require valid-user; </Location>; 1.7.2 Configure fastcgi with lighttpd; An example of configuration file for lighttpd server is:; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); Be aware, that with lighttpd one should speci",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:10489,Deployability,configurat,configuration,10489,"e could specify:; serv = new THttpServer(""fastcgi:9000"");; In fact, the FastCGI interface can run in parallel to http server. One can just call:; serv = new THttpServer(""http:8080"");; serv->CreateEngine(""fastcgi:9000"");; One could specify a debug parameter to be able to adjust the FastCGI configuration on the web server:; serv->CreateEngine(""fastcgi:9000?debug=1"");; By default 10 threads are used to process FastCGI requests. This number can be changed with “thrds” url parameter:; serv->CreateEngine(""fastcgi:9000?thrds=20"");; If thrds=0 parameter specified, the only thread will be use to received and process all requests.; All user access will be ruled by the main web server. Authorized account names could be used to configure access restriction in THttpServer.; 1.7.1 Configure fastcgi with Apache2; Since Apache version 2.4 FastCGI is directly supported - there is no need to compile and install external modules any more. One only need to enable mod_proxy and mod_proxy_fcgi modules and add following line to Apache2 configuration file:; ProxyPass ""/root.app/"" ""fcgi://localhost:9000/"" enablereuse=on; More information can be found in FastCGI proxy docu. After restarting apache server one should be able to open address: http://apache_host_name/root.app/. There are many ways to configure user authentication in Apache. Example of digest auth for FastCGI server:; <Location ""/root.app/"">; AuthType Digest; AuthName ""root""; AuthDigestDomain ""/root.app/"" ""root""; AuthDigestProvider file; AuthUserFile ""/srv/auth/auth.txt""; Require valid-user; </Location>; 1.7.2 Configure fastcgi with lighttpd; An example of configuration file for lighttpd server is:; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); Be aware, that with lighttpd one should specify IP address of the host, where ROOT application is running. Address of the ROOT application will be following: http",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:11080,Deployability,configurat,configuration,11080,"quests.; All user access will be ruled by the main web server. Authorized account names could be used to configure access restriction in THttpServer.; 1.7.1 Configure fastcgi with Apache2; Since Apache version 2.4 FastCGI is directly supported - there is no need to compile and install external modules any more. One only need to enable mod_proxy and mod_proxy_fcgi modules and add following line to Apache2 configuration file:; ProxyPass ""/root.app/"" ""fcgi://localhost:9000/"" enablereuse=on; More information can be found in FastCGI proxy docu. After restarting apache server one should be able to open address: http://apache_host_name/root.app/. There are many ways to configure user authentication in Apache. Example of digest auth for FastCGI server:; <Location ""/root.app/"">; AuthType Digest; AuthName ""root""; AuthDigestDomain ""/root.app/"" ""root""; AuthDigestProvider file; AuthUserFile ""/srv/auth/auth.txt""; Require valid-user; </Location>; 1.7.2 Configure fastcgi with lighttpd; An example of configuration file for lighttpd server is:; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); Be aware, that with lighttpd one should specify IP address of the host, where ROOT application is running. Address of the ROOT application will be following: http://lighttpd_host_name/root.app/. Example of authorization configuration for FastCGI connection:; auth.require = ( ""/root.app"" => (; ""method"" => ""digest"",; ""realm"" => ""root"",; ""require"" => ""valid-user""; ) ); 1.8 Integration with existing applications; In many practical cases no change of existing code is required. Opened files (and all objects inside), existing canvas and histograms are automatically scanned by the server and will be available to the users. If necessary, any object can be registered directly to the server with a THttpServer::Register() call.; Central point of integration - when and how THttpServer ",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:11518,Deployability,configurat,configuration,11518,"app/"" ""fcgi://localhost:9000/"" enablereuse=on; More information can be found in FastCGI proxy docu. After restarting apache server one should be able to open address: http://apache_host_name/root.app/. There are many ways to configure user authentication in Apache. Example of digest auth for FastCGI server:; <Location ""/root.app/"">; AuthType Digest; AuthName ""root""; AuthDigestDomain ""/root.app/"" ""root""; AuthDigestProvider file; AuthUserFile ""/srv/auth/auth.txt""; Require valid-user; </Location>; 1.7.2 Configure fastcgi with lighttpd; An example of configuration file for lighttpd server is:; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); Be aware, that with lighttpd one should specify IP address of the host, where ROOT application is running. Address of the ROOT application will be following: http://lighttpd_host_name/root.app/. Example of authorization configuration for FastCGI connection:; auth.require = ( ""/root.app"" => (; ""method"" => ""digest"",; ""realm"" => ""root"",; ""require"" => ""valid-user""; ) ); 1.8 Integration with existing applications; In many practical cases no change of existing code is required. Opened files (and all objects inside), existing canvas and histograms are automatically scanned by the server and will be available to the users. If necessary, any object can be registered directly to the server with a THttpServer::Register() call.; Central point of integration - when and how THttpServer get access to data from a running application. By default it is done during the gSystem->ProcessEvents() call - THttpServer uses a synchronous timer which is activated every 100 ms. Such approach works perfectly when running macros in an interactive ROOT session.; If an application runs in compiled code and does not contain gSystem->ProcessEvents() calls, two method are available.; 1.8.1 Asynchronous timer; The first method is to configure an",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:12042,Deployability,integrat,integration,12042,"e of configuration file for lighttpd server is:; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); Be aware, that with lighttpd one should specify IP address of the host, where ROOT application is running. Address of the ROOT application will be following: http://lighttpd_host_name/root.app/. Example of authorization configuration for FastCGI connection:; auth.require = ( ""/root.app"" => (; ""method"" => ""digest"",; ""realm"" => ""root"",; ""require"" => ""valid-user""; ) ); 1.8 Integration with existing applications; In many practical cases no change of existing code is required. Opened files (and all objects inside), existing canvas and histograms are automatically scanned by the server and will be available to the users. If necessary, any object can be registered directly to the server with a THttpServer::Register() call.; Central point of integration - when and how THttpServer get access to data from a running application. By default it is done during the gSystem->ProcessEvents() call - THttpServer uses a synchronous timer which is activated every 100 ms. Such approach works perfectly when running macros in an interactive ROOT session.; If an application runs in compiled code and does not contain gSystem->ProcessEvents() calls, two method are available.; 1.8.1 Asynchronous timer; The first method is to configure an asynchronous timer for the server, like for example:; serv->SetTimer(100, kFALSE);; Then, the timer will be activated even without any gSystem->ProcessEvents() method call. The main advantage of such method is that the application code can be used without any modifications. But there is no control when access to the application data is performed. It could happen just in-between of TH1::Fill() calls and an histogram object may be incomplete. Therefore such method is not recommended.; 1.8.2 Regular calls of THttpServer::ProcessRequests() metho",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:3888,Energy Efficiency,monitor,monitoring,3888,"ra arguments for THttpServer itself:. Name; Description. readonly, ro; use server in read-only mode (default). readwrite, rw; use server in read-write mode. global; let scan global directories for canvases and files (default). noglobal; disable scan of global directories. basic_sniffer; use basic TRootSniffer without support of hist, gpad, graph, tree classes. Example:; new THttpServer(""http:8080;ro;noglobal""); 1.2 Registering objects; At any time, one could register other objects with the command:; TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);; One should specify sub-folder name, where objects will be registered. If sub-folder name does not starts with slash /, than top-name folder /Objects/ will be prepended. At any time one could unregister objects:; serv->Unregister(gr);; THttpServer does not take ownership over registered objects - they should be deleted by user.; If the objects content is changing in the application, one could enable monitoring flag in the browser - then objects view will be regularly updated.; 1.3 Accessing file system; THttpServer provides partial access to the files from file system. First of all, JSROOT scripts and files can be accessed via “jsrootsys/” path like “http://localhost:8080/jsrootsys/modules/core.mjs”. Files from ROOT install directory can be get via “rootsys/” path like “http://localhost:8080/rootsys/icons/about.xpm”. Also files from current directory where ROOT is running can be accessed via “currentdir/” path like “http://localhost:8080/currentdir/file.txt”.; If necessary, one can add custom path as well, using THttpServer::AddLocation method:; serv->AddLocation(""mydir/"", ""/home/user/specials"");; Then files from that directory could be addressed via URL like “http://localhost:8080/mydir/myfile.root”; 1.4 Command interface; THttpServer class provide simple interface to invoke command from web browser. One just register command like:; serv->RegisterCommand(""/DoSomething"", ""SomeFuncti",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:6265,Energy Efficiency,monitor,monitoring,6265," arguments values, when command element clicked in the browser. Example of the command which executes arbitrary string in application via ProcessLine looks like:; serv->RegisterCommand(""/Process"", ""%arg1%"");; When registering command, one could specify icon name which will be displayed with the command.; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"", ""rootsys/icons/ed_execute.png"");; In example usage of images from $ROOTSYS/icons directory is shown. One could prepend button; string to the icon name to let browser show command as extra button. In last case one could hide command element from elements list:; serv->Hide(""/DoSomething"");; One can find example of command interface usage in tutorials/http/httpcontrol.C macro.; 1.5 Customize user interface; JSROOT is used to implement UI for the THttpServer. Default webpage shows list of registered objects on the left side and drawing area on the right side - see example. JSROOT allows to configure different parameters via URL - like monitoring interval or name of displayed items item=Files/job1.root/hpxpy&opt=colz&monitoring=1000.; Some of such parameters can be configured already on the server:; serv->SetItemField(""/"", ""_monitoring"", ""1000""); // monitoring interval in ms; serv->SetItemField(""/"", ""_drawitem"", ""Files/job1.root/hpxpy""); // item to draw; serv->SetItemField(""/"", ""_drawopt"", ""colz"");; In such case URL parameters are not required - specified item will be displayed automatically when web page is opened. One also can configure to display several items at once. For that one also can configure layout of the drawing area:; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; serv->SetItemField(""/"", ""_drawopt"", ""[colz,hist]""); // options; One also can change appearance of hierarchy browser on the left side of the web page:; serv->SetItemField(""/"", ""_browser"", ""off""); // allowed ""fix"" (default),",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:6348,Energy Efficiency,monitor,monitoring,6348,"mand which executes arbitrary string in application via ProcessLine looks like:; serv->RegisterCommand(""/Process"", ""%arg1%"");; When registering command, one could specify icon name which will be displayed with the command.; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"", ""rootsys/icons/ed_execute.png"");; In example usage of images from $ROOTSYS/icons directory is shown. One could prepend button; string to the icon name to let browser show command as extra button. In last case one could hide command element from elements list:; serv->Hide(""/DoSomething"");; One can find example of command interface usage in tutorials/http/httpcontrol.C macro.; 1.5 Customize user interface; JSROOT is used to implement UI for the THttpServer. Default webpage shows list of registered objects on the left side and drawing area on the right side - see example. JSROOT allows to configure different parameters via URL - like monitoring interval or name of displayed items item=Files/job1.root/hpxpy&opt=colz&monitoring=1000.; Some of such parameters can be configured already on the server:; serv->SetItemField(""/"", ""_monitoring"", ""1000""); // monitoring interval in ms; serv->SetItemField(""/"", ""_drawitem"", ""Files/job1.root/hpxpy""); // item to draw; serv->SetItemField(""/"", ""_drawopt"", ""colz"");; In such case URL parameters are not required - specified item will be displayed automatically when web page is opened. One also can configure to display several items at once. For that one also can configure layout of the drawing area:; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; serv->SetItemField(""/"", ""_drawopt"", ""[colz,hist]""); // options; One also can change appearance of hierarchy browser on the left side of the web page:; serv->SetItemField(""/"", ""_browser"", ""off""); // allowed ""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // t",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:6483,Energy Efficiency,monitor,monitoring,6483,"""%arg1%"");; When registering command, one could specify icon name which will be displayed with the command.; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"", ""rootsys/icons/ed_execute.png"");; In example usage of images from $ROOTSYS/icons directory is shown. One could prepend button; string to the icon name to let browser show command as extra button. In last case one could hide command element from elements list:; serv->Hide(""/DoSomething"");; One can find example of command interface usage in tutorials/http/httpcontrol.C macro.; 1.5 Customize user interface; JSROOT is used to implement UI for the THttpServer. Default webpage shows list of registered objects on the left side and drawing area on the right side - see example. JSROOT allows to configure different parameters via URL - like monitoring interval or name of displayed items item=Files/job1.root/hpxpy&opt=colz&monitoring=1000.; Some of such parameters can be configured already on the server:; serv->SetItemField(""/"", ""_monitoring"", ""1000""); // monitoring interval in ms; serv->SetItemField(""/"", ""_drawitem"", ""Files/job1.root/hpxpy""); // item to draw; serv->SetItemField(""/"", ""_drawopt"", ""colz"");; In such case URL parameters are not required - specified item will be displayed automatically when web page is opened. One also can configure to display several items at once. For that one also can configure layout of the drawing area:; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; serv->SetItemField(""/"", ""_drawopt"", ""[colz,hist]""); // options; One also can change appearance of hierarchy browser on the left side of the web page:; serv->SetItemField(""/"", ""_browser"", ""off""); // allowed ""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // title of web page, shown when browser off; If necessary, one also can automatically open ROOT file when web page is o",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:15693,Energy Efficiency,reduce,reduce,15693," at once. multi.bin; perform several requests at once, return result in binary form. All data will be automatically zipped if ‘.gz’ extension is appended. Like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json.gz; If the access to the server is restricted with htdigest, it is recommended to use the curl program since only curl correctly implements such authentication method. The command will look like:; [shell] curl --user ""accout:password"" http://localhost:8080/Objects/subfolder/obj/root.json --digest -o root.json; 1.9.1 Objects data access in JSON format; Request root.json implemented with TBufferJSON class. TBufferJSON generates such object representation, which could be directly used in JSROOT for drawing. root.json request returns either complete object or just object member like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; The result will be: ""title"".; For the root.json request one could specify the ‘compact’ parameter, which allow to reduce the number of spaces and new lines without data lost. This parameter can have values from ‘0’ (no compression) till ‘3’ (no spaces and new lines at all). In addition, one can use simple compression algorithm for big arrays. If compact=‘10’, zero values in the begin and at the end of the array will be excluded. If compact=‘20’, similar values or large zero gaps in-between will be compressed. Such array compression support in JSROOT from version 4.8.2.; Usage of root.json request is about as efficient as binary root.bin request. Comparison of different request methods with TH2 histogram from hsimple.C shown in the table:. Request; Size. root.bin; 7672 bytes. root.bin.gz; 1582 bytes. root.json; 8570 bytes. root.json?compact=3; 6004 bytes. root.json?compact=23; 5216 bytes. root.json.gz?compact=23; 1855 bytes. One should remember that JSON representation always includes names of the data fields which are not present in the binary representation. Even then the size difference is ",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:16195,Energy Efficiency,efficient,efficient,16195,"root.json --digest -o root.json; 1.9.1 Objects data access in JSON format; Request root.json implemented with TBufferJSON class. TBufferJSON generates such object representation, which could be directly used in JSROOT for drawing. root.json request returns either complete object or just object member like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; The result will be: ""title"".; For the root.json request one could specify the ‘compact’ parameter, which allow to reduce the number of spaces and new lines without data lost. This parameter can have values from ‘0’ (no compression) till ‘3’ (no spaces and new lines at all). In addition, one can use simple compression algorithm for big arrays. If compact=‘10’, zero values in the begin and at the end of the array will be excluded. If compact=‘20’, similar values or large zero gaps in-between will be compressed. Such array compression support in JSROOT from version 4.8.2.; Usage of root.json request is about as efficient as binary root.bin request. Comparison of different request methods with TH2 histogram from hsimple.C shown in the table:. Request; Size. root.bin; 7672 bytes. root.bin.gz; 1582 bytes. root.json; 8570 bytes. root.json?compact=3; 6004 bytes. root.json?compact=23; 5216 bytes. root.json.gz?compact=23; 1855 bytes. One should remember that JSON representation always includes names of the data fields which are not present in the binary representation. Even then the size difference is negligible.; root.json used in JSROOT to request objects from THttpServer.; 1.9.2 Generating images out of objects; For the ROOT classes which are implementing Draw method (like TH1 or TGraph) one could produce images with requests: root.png, root.gif, root.jpeg. For example:; [shell] wget ""http://localhost:8080/Files/hsimple.root/hpx/root.png?w=500&h=500&opt=lego1"" -O lego1.png; For all such requests following parameters could be specified:. h - image height; w - image width; opt - draw options. 1.9.3",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:17248,Energy Efficiency,monitor,monitoring,17248," request methods with TH2 histogram from hsimple.C shown in the table:. Request; Size. root.bin; 7672 bytes. root.bin.gz; 1582 bytes. root.json; 8570 bytes. root.json?compact=3; 6004 bytes. root.json?compact=23; 5216 bytes. root.json.gz?compact=23; 1855 bytes. One should remember that JSON representation always includes names of the data fields which are not present in the binary representation. Even then the size difference is negligible.; root.json used in JSROOT to request objects from THttpServer.; 1.9.2 Generating images out of objects; For the ROOT classes which are implementing Draw method (like TH1 or TGraph) one could produce images with requests: root.png, root.gif, root.jpeg. For example:; [shell] wget ""http://localhost:8080/Files/hsimple.root/hpx/root.png?w=500&h=500&opt=lego1"" -O lego1.png; For all such requests following parameters could be specified:. h - image height; w - image width; opt - draw options. 1.9.3 Methods execution; By default THttpServer starts in monitoring (read-only) mode and therefore forbid any methods execution. One could specify read-write mode when server is started:; auto serv = new THttpServer(""http:8080;rw"");; Or one could disable read-only mode with the call:; serv->SetReadOnly(kFALSE);; Or one could allow access to the folder, object or specific object methods with:; serv->Restrict(""/Histograms"", ""allow=admin""); // allow full access for user with 'admin' account; serv->Restrict(""/Histograms/hist1"", ""allow=all""); // allow full access for all users; serv->Restrict(""/Histograms/hist1"", ""allow_method=Rebin""); // allow only Rebin method; ‘exe.json’ accepts following parameters:. method - name of method to execute; prototype - method prototype (see TClass::GetMethodWithPrototype for details); compact - compact parameter, used to compress return value; _ret_object_ - name of the object which should be returned as result of method execution (used together with remote TTree::Draw call). Example of retrieving object title:; [shell] wg",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:172,Integrability,interface,interface,172,". HTTP Server. HTTP Server; Sergey Linev. HTTP Server; 1 HTTP server in ROOT; 1.1 Starting the HTTP server; 1.2 Registering objects; 1.3 Accessing file system; 1.4 Command interface; 1.5 Customize user interface; 1.6 Configuring user access; 1.7 Using FastCGI interface; 1.8 Integration with existing applications; 1.9 Data access from command shell; 1.10 Using unix sockets; 1.11 Websockets supports. HTTP Server; *** Sergey Linev GSI, Darmstadt ***; 1 HTTP server in ROOT; The idea of THttpServer is to provide remote http access to running ROOT application and enable HTML/JavaScript user interface. Any registered object can be requested and displayed in the web browser. There are many benefits of such approach:. standard http interface to ROOT application; no any temporary ROOT files to access data; user interface running in all browsers. 1.1 Starting the HTTP server; To start the http server, at any time, create an instance of the THttpServer class like:; auto serv = new THttpServer(""http:8080"");; This will start a civetweb-based http server on the port 8080. Then one should be able to open the address http://localhost:8080 in any modern browser (Firefox, Chrome, Opera, Safari, IE11) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics.; There is a server snapshot of running macro tutorials/http/httpserver.C from ROOT tutorials.; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following URL parameters are supported:. Name; Description. thrds=N; number of threads used by the civetweb (default is 10). top=name; configure top name, visible in the web browser. auth_file=filename; authentication file name, created with htdigets utility. auth_domain=domain; authentication domain. loopback;",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:202,Integrability,interface,interface,202,". HTTP Server. HTTP Server; Sergey Linev. HTTP Server; 1 HTTP server in ROOT; 1.1 Starting the HTTP server; 1.2 Registering objects; 1.3 Accessing file system; 1.4 Command interface; 1.5 Customize user interface; 1.6 Configuring user access; 1.7 Using FastCGI interface; 1.8 Integration with existing applications; 1.9 Data access from command shell; 1.10 Using unix sockets; 1.11 Websockets supports. HTTP Server; *** Sergey Linev GSI, Darmstadt ***; 1 HTTP server in ROOT; The idea of THttpServer is to provide remote http access to running ROOT application and enable HTML/JavaScript user interface. Any registered object can be requested and displayed in the web browser. There are many benefits of such approach:. standard http interface to ROOT application; no any temporary ROOT files to access data; user interface running in all browsers. 1.1 Starting the HTTP server; To start the http server, at any time, create an instance of the THttpServer class like:; auto serv = new THttpServer(""http:8080"");; This will start a civetweb-based http server on the port 8080. Then one should be able to open the address http://localhost:8080 in any modern browser (Firefox, Chrome, Opera, Safari, IE11) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics.; There is a server snapshot of running macro tutorials/http/httpserver.C from ROOT tutorials.; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following URL parameters are supported:. Name; Description. thrds=N; number of threads used by the civetweb (default is 10). top=name; configure top name, visible in the web browser. auth_file=filename; authentication file name, created with htdigets utility. auth_domain=domain; authentication domain. loopback;",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:260,Integrability,interface,interface,260,". HTTP Server. HTTP Server; Sergey Linev. HTTP Server; 1 HTTP server in ROOT; 1.1 Starting the HTTP server; 1.2 Registering objects; 1.3 Accessing file system; 1.4 Command interface; 1.5 Customize user interface; 1.6 Configuring user access; 1.7 Using FastCGI interface; 1.8 Integration with existing applications; 1.9 Data access from command shell; 1.10 Using unix sockets; 1.11 Websockets supports. HTTP Server; *** Sergey Linev GSI, Darmstadt ***; 1 HTTP server in ROOT; The idea of THttpServer is to provide remote http access to running ROOT application and enable HTML/JavaScript user interface. Any registered object can be requested and displayed in the web browser. There are many benefits of such approach:. standard http interface to ROOT application; no any temporary ROOT files to access data; user interface running in all browsers. 1.1 Starting the HTTP server; To start the http server, at any time, create an instance of the THttpServer class like:; auto serv = new THttpServer(""http:8080"");; This will start a civetweb-based http server on the port 8080. Then one should be able to open the address http://localhost:8080 in any modern browser (Firefox, Chrome, Opera, Safari, IE11) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics.; There is a server snapshot of running macro tutorials/http/httpserver.C from ROOT tutorials.; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following URL parameters are supported:. Name; Description. thrds=N; number of threads used by the civetweb (default is 10). top=name; configure top name, visible in the web browser. auth_file=filename; authentication file name, created with htdigets utility. auth_domain=domain; authentication domain. loopback;",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:592,Integrability,interface,interface,592,". HTTP Server. HTTP Server; Sergey Linev. HTTP Server; 1 HTTP server in ROOT; 1.1 Starting the HTTP server; 1.2 Registering objects; 1.3 Accessing file system; 1.4 Command interface; 1.5 Customize user interface; 1.6 Configuring user access; 1.7 Using FastCGI interface; 1.8 Integration with existing applications; 1.9 Data access from command shell; 1.10 Using unix sockets; 1.11 Websockets supports. HTTP Server; *** Sergey Linev GSI, Darmstadt ***; 1 HTTP server in ROOT; The idea of THttpServer is to provide remote http access to running ROOT application and enable HTML/JavaScript user interface. Any registered object can be requested and displayed in the web browser. There are many benefits of such approach:. standard http interface to ROOT application; no any temporary ROOT files to access data; user interface running in all browsers. 1.1 Starting the HTTP server; To start the http server, at any time, create an instance of the THttpServer class like:; auto serv = new THttpServer(""http:8080"");; This will start a civetweb-based http server on the port 8080. Then one should be able to open the address http://localhost:8080 in any modern browser (Firefox, Chrome, Opera, Safari, IE11) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics.; There is a server snapshot of running macro tutorials/http/httpserver.C from ROOT tutorials.; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following URL parameters are supported:. Name; Description. thrds=N; number of threads used by the civetweb (default is 10). top=name; configure top name, visible in the web browser. auth_file=filename; authentication file name, created with htdigets utility. auth_domain=domain; authentication domain. loopback;",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:733,Integrability,interface,interface,733,". HTTP Server. HTTP Server; Sergey Linev. HTTP Server; 1 HTTP server in ROOT; 1.1 Starting the HTTP server; 1.2 Registering objects; 1.3 Accessing file system; 1.4 Command interface; 1.5 Customize user interface; 1.6 Configuring user access; 1.7 Using FastCGI interface; 1.8 Integration with existing applications; 1.9 Data access from command shell; 1.10 Using unix sockets; 1.11 Websockets supports. HTTP Server; *** Sergey Linev GSI, Darmstadt ***; 1 HTTP server in ROOT; The idea of THttpServer is to provide remote http access to running ROOT application and enable HTML/JavaScript user interface. Any registered object can be requested and displayed in the web browser. There are many benefits of such approach:. standard http interface to ROOT application; no any temporary ROOT files to access data; user interface running in all browsers. 1.1 Starting the HTTP server; To start the http server, at any time, create an instance of the THttpServer class like:; auto serv = new THttpServer(""http:8080"");; This will start a civetweb-based http server on the port 8080. Then one should be able to open the address http://localhost:8080 in any modern browser (Firefox, Chrome, Opera, Safari, IE11) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics.; There is a server snapshot of running macro tutorials/http/httpserver.C from ROOT tutorials.; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following URL parameters are supported:. Name; Description. thrds=N; number of threads used by the civetweb (default is 10). top=name; configure top name, visible in the web browser. auth_file=filename; authentication file name, created with htdigets utility. auth_domain=domain; authentication domain. loopback;",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:813,Integrability,interface,interface,813,". HTTP Server. HTTP Server; Sergey Linev. HTTP Server; 1 HTTP server in ROOT; 1.1 Starting the HTTP server; 1.2 Registering objects; 1.3 Accessing file system; 1.4 Command interface; 1.5 Customize user interface; 1.6 Configuring user access; 1.7 Using FastCGI interface; 1.8 Integration with existing applications; 1.9 Data access from command shell; 1.10 Using unix sockets; 1.11 Websockets supports. HTTP Server; *** Sergey Linev GSI, Darmstadt ***; 1 HTTP server in ROOT; The idea of THttpServer is to provide remote http access to running ROOT application and enable HTML/JavaScript user interface. Any registered object can be requested and displayed in the web browser. There are many benefits of such approach:. standard http interface to ROOT application; no any temporary ROOT files to access data; user interface running in all browsers. 1.1 Starting the HTTP server; To start the http server, at any time, create an instance of the THttpServer class like:; auto serv = new THttpServer(""http:8080"");; This will start a civetweb-based http server on the port 8080. Then one should be able to open the address http://localhost:8080 in any modern browser (Firefox, Chrome, Opera, Safari, IE11) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics.; There is a server snapshot of running macro tutorials/http/httpserver.C from ROOT tutorials.; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following URL parameters are supported:. Name; Description. thrds=N; number of threads used by the civetweb (default is 10). top=name; configure top name, visible in the web browser. auth_file=filename; authentication file name, created with htdigets utility. auth_domain=domain; authentication domain. loopback;",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:4718,Integrability,interface,interface,4718,"over registered objects - they should be deleted by user.; If the objects content is changing in the application, one could enable monitoring flag in the browser - then objects view will be regularly updated.; 1.3 Accessing file system; THttpServer provides partial access to the files from file system. First of all, JSROOT scripts and files can be accessed via “jsrootsys/” path like “http://localhost:8080/jsrootsys/modules/core.mjs”. Files from ROOT install directory can be get via “rootsys/” path like “http://localhost:8080/rootsys/icons/about.xpm”. Also files from current directory where ROOT is running can be accessed via “currentdir/” path like “http://localhost:8080/currentdir/file.txt”.; If necessary, one can add custom path as well, using THttpServer::AddLocation method:; serv->AddLocation(""mydir/"", ""/home/user/specials"");; Then files from that directory could be addressed via URL like “http://localhost:8080/mydir/myfile.root”; 1.4 Command interface; THttpServer class provide simple interface to invoke command from web browser. One just register command like:; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"");; Element with name DoSomething will appear in the web browser and can be clicked. It will result in gROOT->ProcessLineSync(""SomeFunction()"") call.; One could configure argument(s) for the command. For that one should use %arg1, %arg2 and so on identifiers. Like:; serv->RegisterCommand(""/DoSomething"", ""SomeFunction(%arg1%,%arg2%)"");; User will be requested to enter arguments values, when command element clicked in the browser. Example of the command which executes arbitrary string in application via ProcessLine looks like:; serv->RegisterCommand(""/Process"", ""%arg1%"");; When registering command, one could specify icon name which will be displayed with the command.; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"", ""rootsys/icons/ed_execute.png"");; In example usage of images from $ROOTSYS/icons directory is shown. One could prepend button; strin",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:4762,Integrability,interface,interface,4762,"over registered objects - they should be deleted by user.; If the objects content is changing in the application, one could enable monitoring flag in the browser - then objects view will be regularly updated.; 1.3 Accessing file system; THttpServer provides partial access to the files from file system. First of all, JSROOT scripts and files can be accessed via “jsrootsys/” path like “http://localhost:8080/jsrootsys/modules/core.mjs”. Files from ROOT install directory can be get via “rootsys/” path like “http://localhost:8080/rootsys/icons/about.xpm”. Also files from current directory where ROOT is running can be accessed via “currentdir/” path like “http://localhost:8080/currentdir/file.txt”.; If necessary, one can add custom path as well, using THttpServer::AddLocation method:; serv->AddLocation(""mydir/"", ""/home/user/specials"");; Then files from that directory could be addressed via URL like “http://localhost:8080/mydir/myfile.root”; 1.4 Command interface; THttpServer class provide simple interface to invoke command from web browser. One just register command like:; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"");; Element with name DoSomething will appear in the web browser and can be clicked. It will result in gROOT->ProcessLineSync(""SomeFunction()"") call.; One could configure argument(s) for the command. For that one should use %arg1, %arg2 and so on identifiers. Like:; serv->RegisterCommand(""/DoSomething"", ""SomeFunction(%arg1%,%arg2%)"");; User will be requested to enter arguments values, when command element clicked in the browser. Example of the command which executes arbitrary string in application via ProcessLine looks like:; serv->RegisterCommand(""/Process"", ""%arg1%"");; When registering command, one could specify icon name which will be displayed with the command.; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"", ""rootsys/icons/ed_execute.png"");; In example usage of images from $ROOTSYS/icons directory is shown. One could prepend button; strin",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:5948,Integrability,interface,interface,5948,"with name DoSomething will appear in the web browser and can be clicked. It will result in gROOT->ProcessLineSync(""SomeFunction()"") call.; One could configure argument(s) for the command. For that one should use %arg1, %arg2 and so on identifiers. Like:; serv->RegisterCommand(""/DoSomething"", ""SomeFunction(%arg1%,%arg2%)"");; User will be requested to enter arguments values, when command element clicked in the browser. Example of the command which executes arbitrary string in application via ProcessLine looks like:; serv->RegisterCommand(""/Process"", ""%arg1%"");; When registering command, one could specify icon name which will be displayed with the command.; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"", ""rootsys/icons/ed_execute.png"");; In example usage of images from $ROOTSYS/icons directory is shown. One could prepend button; string to the icon name to let browser show command as extra button. In last case one could hide command element from elements list:; serv->Hide(""/DoSomething"");; One can find example of command interface usage in tutorials/http/httpcontrol.C macro.; 1.5 Customize user interface; JSROOT is used to implement UI for the THttpServer. Default webpage shows list of registered objects on the left side and drawing area on the right side - see example. JSROOT allows to configure different parameters via URL - like monitoring interval or name of displayed items item=Files/job1.root/hpxpy&opt=colz&monitoring=1000.; Some of such parameters can be configured already on the server:; serv->SetItemField(""/"", ""_monitoring"", ""1000""); // monitoring interval in ms; serv->SetItemField(""/"", ""_drawitem"", ""Files/job1.root/hpxpy""); // item to draw; serv->SetItemField(""/"", ""_drawopt"", ""colz"");; In such case URL parameters are not required - specified item will be displayed automatically when web page is opened. One also can configure to display several items at once. For that one also can configure layout of the drawing area:; serv->SetItemField(""/"", ""_layout"", ",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:6023,Integrability,interface,interface,6023," One could configure argument(s) for the command. For that one should use %arg1, %arg2 and so on identifiers. Like:; serv->RegisterCommand(""/DoSomething"", ""SomeFunction(%arg1%,%arg2%)"");; User will be requested to enter arguments values, when command element clicked in the browser. Example of the command which executes arbitrary string in application via ProcessLine looks like:; serv->RegisterCommand(""/Process"", ""%arg1%"");; When registering command, one could specify icon name which will be displayed with the command.; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"", ""rootsys/icons/ed_execute.png"");; In example usage of images from $ROOTSYS/icons directory is shown. One could prepend button; string to the icon name to let browser show command as extra button. In last case one could hide command element from elements list:; serv->Hide(""/DoSomething"");; One can find example of command interface usage in tutorials/http/httpcontrol.C macro.; 1.5 Customize user interface; JSROOT is used to implement UI for the THttpServer. Default webpage shows list of registered objects on the left side and drawing area on the right side - see example. JSROOT allows to configure different parameters via URL - like monitoring interval or name of displayed items item=Files/job1.root/hpxpy&opt=colz&monitoring=1000.; Some of such parameters can be configured already on the server:; serv->SetItemField(""/"", ""_monitoring"", ""1000""); // monitoring interval in ms; serv->SetItemField(""/"", ""_drawitem"", ""Files/job1.root/hpxpy""); // item to draw; serv->SetItemField(""/"", ""_drawopt"", ""colz"");; In such case URL parameters are not required - specified item will be displayed automatically when web page is opened. One also can configure to display several items at once. For that one also can configure layout of the drawing area:; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; ser",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:8662,Integrability,protocol,protocol,8662,"// name of ROOT file to load; 1.6 Configuring user access; By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the htdigest utility.; [shell] htdigest -c .htdigest domain_name user_name; It is recommended not to use special symbols in domain or user names. Several users can be add to the “.htdigest” file. When starting the server, the following arguments should be specified:; auto serv = new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; After that, the web browser will automatically request to input a name/password for the domain “domain_name”; Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using THttpServer::Restrict() method.; For instance, one could hide complete folder from ‘guest’ account:; serv->Restrict(""/Folder"", ""hidden=guest"");; Or one could hide from all but ‘admin’ account:; serv->Restrict(""/Folder"", ""visible=admin"");; Hidden folders or objects can not be accessed via http protocol.; By default server runs in readonly mode and do not allow methods execution via ‘exe.json’ or ‘exe.bin’ requests. To allow such action, one could either grant generic access for all or one could allow to execute only special method:; serv->Restrict(""/Folder/histo1"", ""allow=all"");; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle"");; One could provide several options for the same item, separating them with ‘&’ sign:; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle&hide=guest"");; Complete list of supported options could be found in TRootSniffer:Restrict() method documentation.; 1.7 Using FastCGI interface; FastCGI is a protocol for interfacing interactive programs with a web server like Apache, lighttpd, Microsoft ISS and many others.; When starting THttpServer, one could specify:; serv = new THttpServer(""fastcgi:9000"");; In fact, the Fas",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:9288,Integrability,interface,interface,9288," hierarchy, using THttpServer::Restrict() method.; For instance, one could hide complete folder from ‘guest’ account:; serv->Restrict(""/Folder"", ""hidden=guest"");; Or one could hide from all but ‘admin’ account:; serv->Restrict(""/Folder"", ""visible=admin"");; Hidden folders or objects can not be accessed via http protocol.; By default server runs in readonly mode and do not allow methods execution via ‘exe.json’ or ‘exe.bin’ requests. To allow such action, one could either grant generic access for all or one could allow to execute only special method:; serv->Restrict(""/Folder/histo1"", ""allow=all"");; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle"");; One could provide several options for the same item, separating them with ‘&’ sign:; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle&hide=guest"");; Complete list of supported options could be found in TRootSniffer:Restrict() method documentation.; 1.7 Using FastCGI interface; FastCGI is a protocol for interfacing interactive programs with a web server like Apache, lighttpd, Microsoft ISS and many others.; When starting THttpServer, one could specify:; serv = new THttpServer(""fastcgi:9000"");; In fact, the FastCGI interface can run in parallel to http server. One can just call:; serv = new THttpServer(""http:8080"");; serv->CreateEngine(""fastcgi:9000"");; One could specify a debug parameter to be able to adjust the FastCGI configuration on the web server:; serv->CreateEngine(""fastcgi:9000?debug=1"");; By default 10 threads are used to process FastCGI requests. This number can be changed with “thrds” url parameter:; serv->CreateEngine(""fastcgi:9000?thrds=20"");; If thrds=0 parameter specified, the only thread will be use to received and process all requests.; All user access will be ruled by the main web server. Authorized account names could be used to configure access restriction in THttpServer.; 1.7.1 Configure fastcgi with Apache2; Since Apache version 2.4 FastCGI is directly supported - there is no need to comp",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:9312,Integrability,protocol,protocol,9312," hierarchy, using THttpServer::Restrict() method.; For instance, one could hide complete folder from ‘guest’ account:; serv->Restrict(""/Folder"", ""hidden=guest"");; Or one could hide from all but ‘admin’ account:; serv->Restrict(""/Folder"", ""visible=admin"");; Hidden folders or objects can not be accessed via http protocol.; By default server runs in readonly mode and do not allow methods execution via ‘exe.json’ or ‘exe.bin’ requests. To allow such action, one could either grant generic access for all or one could allow to execute only special method:; serv->Restrict(""/Folder/histo1"", ""allow=all"");; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle"");; One could provide several options for the same item, separating them with ‘&’ sign:; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle&hide=guest"");; Complete list of supported options could be found in TRootSniffer:Restrict() method documentation.; 1.7 Using FastCGI interface; FastCGI is a protocol for interfacing interactive programs with a web server like Apache, lighttpd, Microsoft ISS and many others.; When starting THttpServer, one could specify:; serv = new THttpServer(""fastcgi:9000"");; In fact, the FastCGI interface can run in parallel to http server. One can just call:; serv = new THttpServer(""http:8080"");; serv->CreateEngine(""fastcgi:9000"");; One could specify a debug parameter to be able to adjust the FastCGI configuration on the web server:; serv->CreateEngine(""fastcgi:9000?debug=1"");; By default 10 threads are used to process FastCGI requests. This number can be changed with “thrds” url parameter:; serv->CreateEngine(""fastcgi:9000?thrds=20"");; If thrds=0 parameter specified, the only thread will be use to received and process all requests.; All user access will be ruled by the main web server. Authorized account names could be used to configure access restriction in THttpServer.; 1.7.1 Configure fastcgi with Apache2; Since Apache version 2.4 FastCGI is directly supported - there is no need to comp",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:9540,Integrability,interface,interface,9540,"t"");; Or one could hide from all but ‘admin’ account:; serv->Restrict(""/Folder"", ""visible=admin"");; Hidden folders or objects can not be accessed via http protocol.; By default server runs in readonly mode and do not allow methods execution via ‘exe.json’ or ‘exe.bin’ requests. To allow such action, one could either grant generic access for all or one could allow to execute only special method:; serv->Restrict(""/Folder/histo1"", ""allow=all"");; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle"");; One could provide several options for the same item, separating them with ‘&’ sign:; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle&hide=guest"");; Complete list of supported options could be found in TRootSniffer:Restrict() method documentation.; 1.7 Using FastCGI interface; FastCGI is a protocol for interfacing interactive programs with a web server like Apache, lighttpd, Microsoft ISS and many others.; When starting THttpServer, one could specify:; serv = new THttpServer(""fastcgi:9000"");; In fact, the FastCGI interface can run in parallel to http server. One can just call:; serv = new THttpServer(""http:8080"");; serv->CreateEngine(""fastcgi:9000"");; One could specify a debug parameter to be able to adjust the FastCGI configuration on the web server:; serv->CreateEngine(""fastcgi:9000?debug=1"");; By default 10 threads are used to process FastCGI requests. This number can be changed with “thrds” url parameter:; serv->CreateEngine(""fastcgi:9000?thrds=20"");; If thrds=0 parameter specified, the only thread will be use to received and process all requests.; All user access will be ruled by the main web server. Authorized account names could be used to configure access restriction in THttpServer.; 1.7.1 Configure fastcgi with Apache2; Since Apache version 2.4 FastCGI is directly supported - there is no need to compile and install external modules any more. One only need to enable mod_proxy and mod_proxy_fcgi modules and add following line to Apache2 configuration file",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:12042,Integrability,integrat,integration,12042,"e of configuration file for lighttpd server is:; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); Be aware, that with lighttpd one should specify IP address of the host, where ROOT application is running. Address of the ROOT application will be following: http://lighttpd_host_name/root.app/. Example of authorization configuration for FastCGI connection:; auth.require = ( ""/root.app"" => (; ""method"" => ""digest"",; ""realm"" => ""root"",; ""require"" => ""valid-user""; ) ); 1.8 Integration with existing applications; In many practical cases no change of existing code is required. Opened files (and all objects inside), existing canvas and histograms are automatically scanned by the server and will be available to the users. If necessary, any object can be registered directly to the server with a THttpServer::Register() call.; Central point of integration - when and how THttpServer get access to data from a running application. By default it is done during the gSystem->ProcessEvents() call - THttpServer uses a synchronous timer which is activated every 100 ms. Such approach works perfectly when running macros in an interactive ROOT session.; If an application runs in compiled code and does not contain gSystem->ProcessEvents() calls, two method are available.; 1.8.1 Asynchronous timer; The first method is to configure an asynchronous timer for the server, like for example:; serv->SetTimer(100, kFALSE);; Then, the timer will be activated even without any gSystem->ProcessEvents() method call. The main advantage of such method is that the application code can be used without any modifications. But there is no control when access to the application data is performed. It could happen just in-between of TH1::Fill() calls and an histogram object may be incomplete. Therefore such method is not recommended.; 1.8.2 Regular calls of THttpServer::ProcessRequests() metho",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:13396,Integrability,protocol,protocol,13396,"tem->ProcessEvents() calls, two method are available.; 1.8.1 Asynchronous timer; The first method is to configure an asynchronous timer for the server, like for example:; serv->SetTimer(100, kFALSE);; Then, the timer will be activated even without any gSystem->ProcessEvents() method call. The main advantage of such method is that the application code can be used without any modifications. But there is no control when access to the application data is performed. It could happen just in-between of TH1::Fill() calls and an histogram object may be incomplete. Therefore such method is not recommended.; 1.8.2 Regular calls of THttpServer::ProcessRequests() method; The second method is preferable - one just inserts in the application regular calls of the THttpServer::ProcessRequests() method, like:; serv->ProcessRequests();; In such case, one can fully disable the timer of the server:; serv->SetTimer(0, kTRUE);; 1.9 Data access from command shell; The big advantage of the http protocol is that it is not only supported in web browsers, but also in many other applications. One could use http requests to directly access ROOT objects and data members from any kind of scripts.; If one starts a server and register an object like for example:; auto serv = new THttpServer(""http:8080"");; TNamed* n1 = new TNamed(""obj"", ""title"");; serv->Register(""subfolder"", n1);; One could request a JSON representation of such object with the command:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json; Then, its representation will look like:; {; ""_typename"" : ""TNamed"",; ""fUniqueID"" : 0,; ""fBits"" : 0,; ""fName"" : ""obj"",; ""fTitle"" : ""title""; }; The following requests can be performed:. Name; Description. root.bin; binary data produced by object streaming with TBufferFile. root.json; ROOT JSON representation for object and objects members. file.root; Creates TMemFile with the only object, from ROOT 6.32. root.xml; ROOT XML representation. root.png; PNG image (if object drawing implement",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:24115,Integrability,message,message,24115,"be created and registered to THttpServer:; #include ""THttpWSHandler.h"". class TUserHandler : public THttpWSHandler {; public:; TUserHandler(const char *name, const char *title) : THttpWSHandler(name, title) {}. // provide custom HTML page when open correspondent address; TString GetDefaultPageContent() override { return ""file:ws.htm""; }. Bool_t ProcessWS(THttpCallArg *arg) override;; };; Central method is TUserHandler::ProcessWS(THttpCallArg *arg), where four kinds of websockets events should be handled:. WS_CONNECT - clients attempts to create websockets, return false when refusing connection; WS_READY - connection is ready to use, wsid can be obtained with arg->GetWSId() calls; WS_DATA - new portion of data received by webcosket; WS_CLOSE - connection closed by the client, wsid is no longer valid. These kinds are coded as method name of THttpCallArg class and can be used like:; Bool_t TUserHandler::ProcessWS(THttpCallArg *arg); {; if (arg->IsMethod(""WS_CONNECT"")) {; return kTRUE; // accept all connections; }. if (arg->IsMethod(""WS_READY"")) {; SendCharStartWS(arg->GetWSId(), ""Init""); // immediately send message to the web socket; return kTRUE;; }. if (arg->IsMethod(""WS_CLOSE"")) {; return kTRUE; // just confirm connection; }. if (arg->IsMethod(""WS_DATA"")) {; TString str = arg->GetPostDataAsString();; printf(""Client msg: %s\n"", str.Data());; SendCharStarWS(arg->GetWSId(), ""Confirm"");; return kTRUE;; }. return kFALSE; // ignore all other kind of requests; }; Instance of TUserHandler should be registered to the THttpServer like:; THttpServer *serv = new THttpServer(""http:8080"");; TUserHandler *handler = new TUserHandler(""name1"",""title"");; serv->Register(handler);; After that web socket connection can be established with the address ws://host_name:8080/name1/root.websocket Example client code can be found in $ROOTSYS/tutorials/http/ws.htm file. Custom HTML page for websocket handler is specified with TUserHandler::GetDefaultPageContent() method returning ""file:ws.htm"". ",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:1824,Modifiability,config,configure,1824,"sers. 1.1 Starting the HTTP server; To start the http server, at any time, create an instance of the THttpServer class like:; auto serv = new THttpServer(""http:8080"");; This will start a civetweb-based http server on the port 8080. Then one should be able to open the address http://localhost:8080 in any modern browser (Firefox, Chrome, Opera, Safari, IE11) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics.; There is a server snapshot of running macro tutorials/http/httpserver.C from ROOT tutorials.; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following URL parameters are supported:. Name; Description. thrds=N; number of threads used by the civetweb (default is 10). top=name; configure top name, visible in the web browser. auth_file=filename; authentication file name, created with htdigets utility. auth_domain=domain; authentication domain. loopback; bind specified port to loopback 127.0.0.1 address. debug; enable debug mode, server returns html page with request info. websocket_timeout=tm; set web sockets timeout in seconds (default 300). websocket_disable; disable web sockets handling (default enabled). cors=domain; define value for CORS header “Access-Control-Allow-Origin” in server response. log=filename; configure civetweb log file. max_age=value; configures “Cache-Control: max_age=value” http header for all file-related requests, default 3600. nocache; try to fully disable cache control for file requests. winsymlinks=no; do not resolve symbolic links on file system (Windows only), default true. dirlisting=no; enable/disable directory listing for browsing filesystem (default no). If necessary, one could bind http server to specific IP address like:; new THttpServer(""htt",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:2368,Modifiability,config,configure,2368,"SROOT graphics.; There is a server snapshot of running macro tutorials/http/httpserver.C from ROOT tutorials.; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following URL parameters are supported:. Name; Description. thrds=N; number of threads used by the civetweb (default is 10). top=name; configure top name, visible in the web browser. auth_file=filename; authentication file name, created with htdigets utility. auth_domain=domain; authentication domain. loopback; bind specified port to loopback 127.0.0.1 address. debug; enable debug mode, server returns html page with request info. websocket_timeout=tm; set web sockets timeout in seconds (default 300). websocket_disable; disable web sockets handling (default enabled). cors=domain; define value for CORS header “Access-Control-Allow-Origin” in server response. log=filename; configure civetweb log file. max_age=value; configures “Cache-Control: max_age=value” http header for all file-related requests, default 3600. nocache; try to fully disable cache control for file requests. winsymlinks=no; do not resolve symbolic links on file system (Windows only), default true. dirlisting=no; enable/disable directory listing for browsing filesystem (default no). If necessary, one could bind http server to specific IP address like:; new THttpServer(""http:192.168.1.17:8080""); One also can provide extra arguments for THttpServer itself:. Name; Description. readonly, ro; use server in read-only mode (default). readwrite, rw; use server in read-write mode. global; let scan global directories for canvases and files (default). noglobal; disable scan of global directories. basic_sniffer; use basic TRootSniffer without support of hist, gpad, graph, tree classes. Example:; new THttpServer(""http:8080;ro;noglobal""); 1.2 Registering objects; At any time, one could register other objects ",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:2412,Modifiability,config,configures,2412,"pserver.C from ROOT tutorials.; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following URL parameters are supported:. Name; Description. thrds=N; number of threads used by the civetweb (default is 10). top=name; configure top name, visible in the web browser. auth_file=filename; authentication file name, created with htdigets utility. auth_domain=domain; authentication domain. loopback; bind specified port to loopback 127.0.0.1 address. debug; enable debug mode, server returns html page with request info. websocket_timeout=tm; set web sockets timeout in seconds (default 300). websocket_disable; disable web sockets handling (default enabled). cors=domain; define value for CORS header “Access-Control-Allow-Origin” in server response. log=filename; configure civetweb log file. max_age=value; configures “Cache-Control: max_age=value” http header for all file-related requests, default 3600. nocache; try to fully disable cache control for file requests. winsymlinks=no; do not resolve symbolic links on file system (Windows only), default true. dirlisting=no; enable/disable directory listing for browsing filesystem (default no). If necessary, one could bind http server to specific IP address like:; new THttpServer(""http:192.168.1.17:8080""); One also can provide extra arguments for THttpServer itself:. Name; Description. readonly, ro; use server in read-only mode (default). readwrite, rw; use server in read-write mode. global; let scan global directories for canvases and files (default). noglobal; disable scan of global directories. basic_sniffer; use basic TRootSniffer without support of hist, gpad, graph, tree classes. Example:; new THttpServer(""http:8080;ro;noglobal""); 1.2 Registering objects; At any time, one could register other objects with the command:; TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Re",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:5056,Modifiability,config,configure,5056," all, JSROOT scripts and files can be accessed via “jsrootsys/” path like “http://localhost:8080/jsrootsys/modules/core.mjs”. Files from ROOT install directory can be get via “rootsys/” path like “http://localhost:8080/rootsys/icons/about.xpm”. Also files from current directory where ROOT is running can be accessed via “currentdir/” path like “http://localhost:8080/currentdir/file.txt”.; If necessary, one can add custom path as well, using THttpServer::AddLocation method:; serv->AddLocation(""mydir/"", ""/home/user/specials"");; Then files from that directory could be addressed via URL like “http://localhost:8080/mydir/myfile.root”; 1.4 Command interface; THttpServer class provide simple interface to invoke command from web browser. One just register command like:; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"");; Element with name DoSomething will appear in the web browser and can be clicked. It will result in gROOT->ProcessLineSync(""SomeFunction()"") call.; One could configure argument(s) for the command. For that one should use %arg1, %arg2 and so on identifiers. Like:; serv->RegisterCommand(""/DoSomething"", ""SomeFunction(%arg1%,%arg2%)"");; User will be requested to enter arguments values, when command element clicked in the browser. Example of the command which executes arbitrary string in application via ProcessLine looks like:; serv->RegisterCommand(""/Process"", ""%arg1%"");; When registering command, one could specify icon name which will be displayed with the command.; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"", ""rootsys/icons/ed_execute.png"");; In example usage of images from $ROOTSYS/icons directory is shown. One could prepend button; string to the icon name to let browser show command as extra button. In last case one could hide command element from elements list:; serv->Hide(""/DoSomething"");; One can find example of command interface usage in tutorials/http/httpcontrol.C macro.; 1.5 Customize user interface; JSROOT is used to implement UI for ",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:6219,Modifiability,config,configure,6219," arguments values, when command element clicked in the browser. Example of the command which executes arbitrary string in application via ProcessLine looks like:; serv->RegisterCommand(""/Process"", ""%arg1%"");; When registering command, one could specify icon name which will be displayed with the command.; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"", ""rootsys/icons/ed_execute.png"");; In example usage of images from $ROOTSYS/icons directory is shown. One could prepend button; string to the icon name to let browser show command as extra button. In last case one could hide command element from elements list:; serv->Hide(""/DoSomething"");; One can find example of command interface usage in tutorials/http/httpcontrol.C macro.; 1.5 Customize user interface; JSROOT is used to implement UI for the THttpServer. Default webpage shows list of registered objects on the left side and drawing area on the right side - see example. JSROOT allows to configure different parameters via URL - like monitoring interval or name of displayed items item=Files/job1.root/hpxpy&opt=colz&monitoring=1000.; Some of such parameters can be configured already on the server:; serv->SetItemField(""/"", ""_monitoring"", ""1000""); // monitoring interval in ms; serv->SetItemField(""/"", ""_drawitem"", ""Files/job1.root/hpxpy""); // item to draw; serv->SetItemField(""/"", ""_drawopt"", ""colz"");; In such case URL parameters are not required - specified item will be displayed automatically when web page is opened. One also can configure to display several items at once. For that one also can configure layout of the drawing area:; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; serv->SetItemField(""/"", ""_drawopt"", ""[colz,hist]""); // options; One also can change appearance of hierarchy browser on the left side of the web page:; serv->SetItemField(""/"", ""_browser"", ""off""); // allowed ""fix"" (default),",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:6397,Modifiability,config,configured,6397,"""%arg1%"");; When registering command, one could specify icon name which will be displayed with the command.; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"", ""rootsys/icons/ed_execute.png"");; In example usage of images from $ROOTSYS/icons directory is shown. One could prepend button; string to the icon name to let browser show command as extra button. In last case one could hide command element from elements list:; serv->Hide(""/DoSomething"");; One can find example of command interface usage in tutorials/http/httpcontrol.C macro.; 1.5 Customize user interface; JSROOT is used to implement UI for the THttpServer. Default webpage shows list of registered objects on the left side and drawing area on the right side - see example. JSROOT allows to configure different parameters via URL - like monitoring interval or name of displayed items item=Files/job1.root/hpxpy&opt=colz&monitoring=1000.; Some of such parameters can be configured already on the server:; serv->SetItemField(""/"", ""_monitoring"", ""1000""); // monitoring interval in ms; serv->SetItemField(""/"", ""_drawitem"", ""Files/job1.root/hpxpy""); // item to draw; serv->SetItemField(""/"", ""_drawopt"", ""colz"");; In such case URL parameters are not required - specified item will be displayed automatically when web page is opened. One also can configure to display several items at once. For that one also can configure layout of the drawing area:; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; serv->SetItemField(""/"", ""_drawopt"", ""[colz,hist]""); // options; One also can change appearance of hierarchy browser on the left side of the web page:; serv->SetItemField(""/"", ""_browser"", ""off""); // allowed ""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // title of web page, shown when browser off; If necessary, one also can automatically open ROOT file when web page is o",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:6768,Modifiability,config,configure,6768,"t browser show command as extra button. In last case one could hide command element from elements list:; serv->Hide(""/DoSomething"");; One can find example of command interface usage in tutorials/http/httpcontrol.C macro.; 1.5 Customize user interface; JSROOT is used to implement UI for the THttpServer. Default webpage shows list of registered objects on the left side and drawing area on the right side - see example. JSROOT allows to configure different parameters via URL - like monitoring interval or name of displayed items item=Files/job1.root/hpxpy&opt=colz&monitoring=1000.; Some of such parameters can be configured already on the server:; serv->SetItemField(""/"", ""_monitoring"", ""1000""); // monitoring interval in ms; serv->SetItemField(""/"", ""_drawitem"", ""Files/job1.root/hpxpy""); // item to draw; serv->SetItemField(""/"", ""_drawopt"", ""colz"");; In such case URL parameters are not required - specified item will be displayed automatically when web page is opened. One also can configure to display several items at once. For that one also can configure layout of the drawing area:; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; serv->SetItemField(""/"", ""_drawopt"", ""[colz,hist]""); // options; One also can change appearance of hierarchy browser on the left side of the web page:; serv->SetItemField(""/"", ""_browser"", ""off""); // allowed ""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // title of web page, shown when browser off; If necessary, one also can automatically open ROOT file when web page is opened:; serv->SetItemField(""/"", ""_loadfile"", ""currentdir/hsimple.root""); // name of ROOT file to load; 1.6 Configuring user access; By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using th",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:6834,Modifiability,config,configure,6834,"mething"");; One can find example of command interface usage in tutorials/http/httpcontrol.C macro.; 1.5 Customize user interface; JSROOT is used to implement UI for the THttpServer. Default webpage shows list of registered objects on the left side and drawing area on the right side - see example. JSROOT allows to configure different parameters via URL - like monitoring interval or name of displayed items item=Files/job1.root/hpxpy&opt=colz&monitoring=1000.; Some of such parameters can be configured already on the server:; serv->SetItemField(""/"", ""_monitoring"", ""1000""); // monitoring interval in ms; serv->SetItemField(""/"", ""_drawitem"", ""Files/job1.root/hpxpy""); // item to draw; serv->SetItemField(""/"", ""_drawopt"", ""colz"");; In such case URL parameters are not required - specified item will be displayed automatically when web page is opened. One also can configure to display several items at once. For that one also can configure layout of the drawing area:; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; serv->SetItemField(""/"", ""_drawopt"", ""[colz,hist]""); // options; One also can change appearance of hierarchy browser on the left side of the web page:; serv->SetItemField(""/"", ""_browser"", ""off""); // allowed ""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // title of web page, shown when browser off; If necessary, one also can automatically open ROOT file when web page is opened:; serv->SetItemField(""/"", ""_loadfile"", ""currentdir/hsimple.root""); // name of ROOT file to load; 1.6 Configuring user access; By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the htdigest utility.; [shell] htdigest -c .htdigest domain_name user_name; It is recommended not to use special symbols in ",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:9750,Modifiability,config,configuration,9750,"s execution via ‘exe.json’ or ‘exe.bin’ requests. To allow such action, one could either grant generic access for all or one could allow to execute only special method:; serv->Restrict(""/Folder/histo1"", ""allow=all"");; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle"");; One could provide several options for the same item, separating them with ‘&’ sign:; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle&hide=guest"");; Complete list of supported options could be found in TRootSniffer:Restrict() method documentation.; 1.7 Using FastCGI interface; FastCGI is a protocol for interfacing interactive programs with a web server like Apache, lighttpd, Microsoft ISS and many others.; When starting THttpServer, one could specify:; serv = new THttpServer(""fastcgi:9000"");; In fact, the FastCGI interface can run in parallel to http server. One can just call:; serv = new THttpServer(""http:8080"");; serv->CreateEngine(""fastcgi:9000"");; One could specify a debug parameter to be able to adjust the FastCGI configuration on the web server:; serv->CreateEngine(""fastcgi:9000?debug=1"");; By default 10 threads are used to process FastCGI requests. This number can be changed with “thrds” url parameter:; serv->CreateEngine(""fastcgi:9000?thrds=20"");; If thrds=0 parameter specified, the only thread will be use to received and process all requests.; All user access will be ruled by the main web server. Authorized account names could be used to configure access restriction in THttpServer.; 1.7.1 Configure fastcgi with Apache2; Since Apache version 2.4 FastCGI is directly supported - there is no need to compile and install external modules any more. One only need to enable mod_proxy and mod_proxy_fcgi modules and add following line to Apache2 configuration file:; ProxyPass ""/root.app/"" ""fcgi://localhost:9000/"" enablereuse=on; More information can be found in FastCGI proxy docu. After restarting apache server one should be able to open address: http://apache_host_name/root.app/. There ar",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:10186,Modifiability,config,configure,10186," supported options could be found in TRootSniffer:Restrict() method documentation.; 1.7 Using FastCGI interface; FastCGI is a protocol for interfacing interactive programs with a web server like Apache, lighttpd, Microsoft ISS and many others.; When starting THttpServer, one could specify:; serv = new THttpServer(""fastcgi:9000"");; In fact, the FastCGI interface can run in parallel to http server. One can just call:; serv = new THttpServer(""http:8080"");; serv->CreateEngine(""fastcgi:9000"");; One could specify a debug parameter to be able to adjust the FastCGI configuration on the web server:; serv->CreateEngine(""fastcgi:9000?debug=1"");; By default 10 threads are used to process FastCGI requests. This number can be changed with “thrds” url parameter:; serv->CreateEngine(""fastcgi:9000?thrds=20"");; If thrds=0 parameter specified, the only thread will be use to received and process all requests.; All user access will be ruled by the main web server. Authorized account names could be used to configure access restriction in THttpServer.; 1.7.1 Configure fastcgi with Apache2; Since Apache version 2.4 FastCGI is directly supported - there is no need to compile and install external modules any more. One only need to enable mod_proxy and mod_proxy_fcgi modules and add following line to Apache2 configuration file:; ProxyPass ""/root.app/"" ""fcgi://localhost:9000/"" enablereuse=on; More information can be found in FastCGI proxy docu. After restarting apache server one should be able to open address: http://apache_host_name/root.app/. There are many ways to configure user authentication in Apache. Example of digest auth for FastCGI server:; <Location ""/root.app/"">; AuthType Digest; AuthName ""root""; AuthDigestDomain ""/root.app/"" ""root""; AuthDigestProvider file; AuthUserFile ""/srv/auth/auth.txt""; Require valid-user; </Location>; 1.7.2 Configure fastcgi with lighttpd; An example of configuration file for lighttpd server is:; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:10489,Modifiability,config,configuration,10489,"e could specify:; serv = new THttpServer(""fastcgi:9000"");; In fact, the FastCGI interface can run in parallel to http server. One can just call:; serv = new THttpServer(""http:8080"");; serv->CreateEngine(""fastcgi:9000"");; One could specify a debug parameter to be able to adjust the FastCGI configuration on the web server:; serv->CreateEngine(""fastcgi:9000?debug=1"");; By default 10 threads are used to process FastCGI requests. This number can be changed with “thrds” url parameter:; serv->CreateEngine(""fastcgi:9000?thrds=20"");; If thrds=0 parameter specified, the only thread will be use to received and process all requests.; All user access will be ruled by the main web server. Authorized account names could be used to configure access restriction in THttpServer.; 1.7.1 Configure fastcgi with Apache2; Since Apache version 2.4 FastCGI is directly supported - there is no need to compile and install external modules any more. One only need to enable mod_proxy and mod_proxy_fcgi modules and add following line to Apache2 configuration file:; ProxyPass ""/root.app/"" ""fcgi://localhost:9000/"" enablereuse=on; More information can be found in FastCGI proxy docu. After restarting apache server one should be able to open address: http://apache_host_name/root.app/. There are many ways to configure user authentication in Apache. Example of digest auth for FastCGI server:; <Location ""/root.app/"">; AuthType Digest; AuthName ""root""; AuthDigestDomain ""/root.app/"" ""root""; AuthDigestProvider file; AuthUserFile ""/srv/auth/auth.txt""; Require valid-user; </Location>; 1.7.2 Configure fastcgi with lighttpd; An example of configuration file for lighttpd server is:; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); Be aware, that with lighttpd one should specify IP address of the host, where ROOT application is running. Address of the ROOT application will be following: http",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:10752,Modifiability,config,configure,10752,"ion on the web server:; serv->CreateEngine(""fastcgi:9000?debug=1"");; By default 10 threads are used to process FastCGI requests. This number can be changed with “thrds” url parameter:; serv->CreateEngine(""fastcgi:9000?thrds=20"");; If thrds=0 parameter specified, the only thread will be use to received and process all requests.; All user access will be ruled by the main web server. Authorized account names could be used to configure access restriction in THttpServer.; 1.7.1 Configure fastcgi with Apache2; Since Apache version 2.4 FastCGI is directly supported - there is no need to compile and install external modules any more. One only need to enable mod_proxy and mod_proxy_fcgi modules and add following line to Apache2 configuration file:; ProxyPass ""/root.app/"" ""fcgi://localhost:9000/"" enablereuse=on; More information can be found in FastCGI proxy docu. After restarting apache server one should be able to open address: http://apache_host_name/root.app/. There are many ways to configure user authentication in Apache. Example of digest auth for FastCGI server:; <Location ""/root.app/"">; AuthType Digest; AuthName ""root""; AuthDigestDomain ""/root.app/"" ""root""; AuthDigestProvider file; AuthUserFile ""/srv/auth/auth.txt""; Require valid-user; </Location>; 1.7.2 Configure fastcgi with lighttpd; An example of configuration file for lighttpd server is:; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); Be aware, that with lighttpd one should specify IP address of the host, where ROOT application is running. Address of the ROOT application will be following: http://lighttpd_host_name/root.app/. Example of authorization configuration for FastCGI connection:; auth.require = ( ""/root.app"" => (; ""method"" => ""digest"",; ""realm"" => ""root"",; ""require"" => ""valid-user""; ) ); 1.8 Integration with existing applications; In many practical cases no change of existing cod",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:11080,Modifiability,config,configuration,11080,"quests.; All user access will be ruled by the main web server. Authorized account names could be used to configure access restriction in THttpServer.; 1.7.1 Configure fastcgi with Apache2; Since Apache version 2.4 FastCGI is directly supported - there is no need to compile and install external modules any more. One only need to enable mod_proxy and mod_proxy_fcgi modules and add following line to Apache2 configuration file:; ProxyPass ""/root.app/"" ""fcgi://localhost:9000/"" enablereuse=on; More information can be found in FastCGI proxy docu. After restarting apache server one should be able to open address: http://apache_host_name/root.app/. There are many ways to configure user authentication in Apache. Example of digest auth for FastCGI server:; <Location ""/root.app/"">; AuthType Digest; AuthName ""root""; AuthDigestDomain ""/root.app/"" ""root""; AuthDigestProvider file; AuthUserFile ""/srv/auth/auth.txt""; Require valid-user; </Location>; 1.7.2 Configure fastcgi with lighttpd; An example of configuration file for lighttpd server is:; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); Be aware, that with lighttpd one should specify IP address of the host, where ROOT application is running. Address of the ROOT application will be following: http://lighttpd_host_name/root.app/. Example of authorization configuration for FastCGI connection:; auth.require = ( ""/root.app"" => (; ""method"" => ""digest"",; ""realm"" => ""root"",; ""require"" => ""valid-user""; ) ); 1.8 Integration with existing applications; In many practical cases no change of existing code is required. Opened files (and all objects inside), existing canvas and histograms are automatically scanned by the server and will be available to the users. If necessary, any object can be registered directly to the server with a THttpServer::Register() call.; Central point of integration - when and how THttpServer ",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:11518,Modifiability,config,configuration,11518,"app/"" ""fcgi://localhost:9000/"" enablereuse=on; More information can be found in FastCGI proxy docu. After restarting apache server one should be able to open address: http://apache_host_name/root.app/. There are many ways to configure user authentication in Apache. Example of digest auth for FastCGI server:; <Location ""/root.app/"">; AuthType Digest; AuthName ""root""; AuthDigestDomain ""/root.app/"" ""root""; AuthDigestProvider file; AuthUserFile ""/srv/auth/auth.txt""; Require valid-user; </Location>; 1.7.2 Configure fastcgi with lighttpd; An example of configuration file for lighttpd server is:; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); Be aware, that with lighttpd one should specify IP address of the host, where ROOT application is running. Address of the ROOT application will be following: http://lighttpd_host_name/root.app/. Example of authorization configuration for FastCGI connection:; auth.require = ( ""/root.app"" => (; ""method"" => ""digest"",; ""realm"" => ""root"",; ""require"" => ""valid-user""; ) ); 1.8 Integration with existing applications; In many practical cases no change of existing code is required. Opened files (and all objects inside), existing canvas and histograms are automatically scanned by the server and will be available to the users. If necessary, any object can be registered directly to the server with a THttpServer::Register() call.; Central point of integration - when and how THttpServer get access to data from a running application. By default it is done during the gSystem->ProcessEvents() call - THttpServer uses a synchronous timer which is activated every 100 ms. Such approach works perfectly when running macros in an interactive ROOT session.; If an application runs in compiled code and does not contain gSystem->ProcessEvents() calls, two method are available.; 1.8.1 Asynchronous timer; The first method is to configure an",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:12515,Modifiability,config,configure,12515," => (; ""method"" => ""digest"",; ""realm"" => ""root"",; ""require"" => ""valid-user""; ) ); 1.8 Integration with existing applications; In many practical cases no change of existing code is required. Opened files (and all objects inside), existing canvas and histograms are automatically scanned by the server and will be available to the users. If necessary, any object can be registered directly to the server with a THttpServer::Register() call.; Central point of integration - when and how THttpServer get access to data from a running application. By default it is done during the gSystem->ProcessEvents() call - THttpServer uses a synchronous timer which is activated every 100 ms. Such approach works perfectly when running macros in an interactive ROOT session.; If an application runs in compiled code and does not contain gSystem->ProcessEvents() calls, two method are available.; 1.8.1 Asynchronous timer; The first method is to configure an asynchronous timer for the server, like for example:; serv->SetTimer(100, kFALSE);; Then, the timer will be activated even without any gSystem->ProcessEvents() method call. The main advantage of such method is that the application code can be used without any modifications. But there is no control when access to the application data is performed. It could happen just in-between of TH1::Fill() calls and an histogram object may be incomplete. Therefore such method is not recommended.; 1.8.2 Regular calls of THttpServer::ProcessRequests() method; The second method is preferable - one just inserts in the application regular calls of the THttpServer::ProcessRequests() method, like:; serv->ProcessRequests();; In such case, one can fully disable the timer of the server:; serv->SetTimer(0, kTRUE);; 1.9 Data access from command shell; The big advantage of the http protocol is that it is not only supported in web browsers, but also in many other applications. One could use http requests to directly access ROOT objects and data members from any kind of",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:22602,Modifiability,config,configure,22602,"is:; import { httpRequest, draw } from './jsrootsys/modules/core.mjs';; let res = await httpRequest(""your_server/multi.json?number=3"", ""multi"",; ""Files/job1.root/hpx/root.json\nFiles/job1.root/hpxpy/root.json\nFiles/job1.root/hprof/root.json\n"");; for (let n = 0; n < res.length; ++n) {; console.log('Requested element of type', res[n]._typename);; // draw('drawid', res[n], 'hist');; }; Here argument “multi” identifies, that server response should be parsed with parseMulti() function, which correctly interprets JSON code, produced by multi.json request. When sending such request to the server, one should provide list of objects names and not forget “?number=N” parameter in the request URL string.; 1.10 Using unix sockets; Starting from ROOT version 6.28, one can start server with unix socket. Just do:; Just call:; [root] new THttpServer(""socket:/tmp/root.socket""); Name of socket should be unique and not match any existing files.; Most easy way to access THttpServer running via unix socket is to configure ssh tunnel:; [shell] ssh -L 7654:/tmp/root.socket localhost; Once such tunnel is configured one can open following URL in web browser:; [shell] xdg-open http://localhost:7654; 1.11 Websockets supports; Websockets support available starting from ROOT v6.12. Minimal example provided in $ROOTSYS/tutorials/http/ws.C macro.; To work with websockets, subclass of THttpWSHandler should be created and registered to THttpServer:; #include ""THttpWSHandler.h"". class TUserHandler : public THttpWSHandler {; public:; TUserHandler(const char *name, const char *title) : THttpWSHandler(name, title) {}. // provide custom HTML page when open correspondent address; TString GetDefaultPageContent() override { return ""file:ws.htm""; }. Bool_t ProcessWS(THttpCallArg *arg) override;; };; Central method is TUserHandler::ProcessWS(THttpCallArg *arg), where four kinds of websockets events should be handled:. WS_CONNECT - clients attempts to create websockets, return false when refusing connection; ",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:22693,Modifiability,config,configured,22693,"er=3"", ""multi"",; ""Files/job1.root/hpx/root.json\nFiles/job1.root/hpxpy/root.json\nFiles/job1.root/hprof/root.json\n"");; for (let n = 0; n < res.length; ++n) {; console.log('Requested element of type', res[n]._typename);; // draw('drawid', res[n], 'hist');; }; Here argument “multi” identifies, that server response should be parsed with parseMulti() function, which correctly interprets JSON code, produced by multi.json request. When sending such request to the server, one should provide list of objects names and not forget “?number=N” parameter in the request URL string.; 1.10 Using unix sockets; Starting from ROOT version 6.28, one can start server with unix socket. Just do:; Just call:; [root] new THttpServer(""socket:/tmp/root.socket""); Name of socket should be unique and not match any existing files.; Most easy way to access THttpServer running via unix socket is to configure ssh tunnel:; [shell] ssh -L 7654:/tmp/root.socket localhost; Once such tunnel is configured one can open following URL in web browser:; [shell] xdg-open http://localhost:7654; 1.11 Websockets supports; Websockets support available starting from ROOT v6.12. Minimal example provided in $ROOTSYS/tutorials/http/ws.C macro.; To work with websockets, subclass of THttpWSHandler should be created and registered to THttpServer:; #include ""THttpWSHandler.h"". class TUserHandler : public THttpWSHandler {; public:; TUserHandler(const char *name, const char *title) : THttpWSHandler(name, title) {}. // provide custom HTML page when open correspondent address; TString GetDefaultPageContent() override { return ""file:ws.htm""; }. Bool_t ProcessWS(THttpCallArg *arg) override;; };; Central method is TUserHandler::ProcessWS(THttpCallArg *arg), where four kinds of websockets events should be handled:. WS_CONNECT - clients attempts to create websockets, return false when refusing connection; WS_READY - connection is ready to use, wsid can be obtained with arg->GetWSId() calls; WS_DATA - new portion of data received by",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:2541,Performance,cache,cache,2541,"ver. They could be add as additional URL parameters to the constructor arguments like:; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following URL parameters are supported:. Name; Description. thrds=N; number of threads used by the civetweb (default is 10). top=name; configure top name, visible in the web browser. auth_file=filename; authentication file name, created with htdigets utility. auth_domain=domain; authentication domain. loopback; bind specified port to loopback 127.0.0.1 address. debug; enable debug mode, server returns html page with request info. websocket_timeout=tm; set web sockets timeout in seconds (default 300). websocket_disable; disable web sockets handling (default enabled). cors=domain; define value for CORS header “Access-Control-Allow-Origin” in server response. log=filename; configure civetweb log file. max_age=value; configures “Cache-Control: max_age=value” http header for all file-related requests, default 3600. nocache; try to fully disable cache control for file requests. winsymlinks=no; do not resolve symbolic links on file system (Windows only), default true. dirlisting=no; enable/disable directory listing for browsing filesystem (default no). If necessary, one could bind http server to specific IP address like:; new THttpServer(""http:192.168.1.17:8080""); One also can provide extra arguments for THttpServer itself:. Name; Description. readonly, ro; use server in read-only mode (default). readwrite, rw; use server in read-write mode. global; let scan global directories for canvases and files (default). noglobal; disable scan of global directories. basic_sniffer; use basic TRootSniffer without support of hist, gpad, graph, tree classes. Example:; new THttpServer(""http:8080;ro;noglobal""); 1.2 Registering objects; At any time, one could register other objects with the command:; TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);; One should specify sub-folder name, where objects will b",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:7559,Performance,load,load,7559,"""Files/job1.root/hpxpy""); // item to draw; serv->SetItemField(""/"", ""_drawopt"", ""colz"");; In such case URL parameters are not required - specified item will be displayed automatically when web page is opened. One also can configure to display several items at once. For that one also can configure layout of the drawing area:; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; serv->SetItemField(""/"", ""_drawopt"", ""[colz,hist]""); // options; One also can change appearance of hierarchy browser on the left side of the web page:; serv->SetItemField(""/"", ""_browser"", ""off""); // allowed ""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // title of web page, shown when browser off; If necessary, one also can automatically open ROOT file when web page is opened:; serv->SetItemField(""/"", ""_loadfile"", ""currentdir/hsimple.root""); // name of ROOT file to load; 1.6 Configuring user access; By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the htdigest utility.; [shell] htdigest -c .htdigest domain_name user_name; It is recommended not to use special symbols in domain or user names. Several users can be add to the “.htdigest” file. When starting the server, the following arguments should be specified:; auto serv = new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; After that, the web browser will automatically request to input a name/password for the domain “domain_name”; Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using THttpServer::Restrict() method.; For instance, one could hide complete folder from ‘guest’ account:; serv->Restrict(""/Folder"", ""hidden=guest"");; Or one could hide from all but ‘ad",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:12866,Performance,perform,performed,12866,"grams are automatically scanned by the server and will be available to the users. If necessary, any object can be registered directly to the server with a THttpServer::Register() call.; Central point of integration - when and how THttpServer get access to data from a running application. By default it is done during the gSystem->ProcessEvents() call - THttpServer uses a synchronous timer which is activated every 100 ms. Such approach works perfectly when running macros in an interactive ROOT session.; If an application runs in compiled code and does not contain gSystem->ProcessEvents() calls, two method are available.; 1.8.1 Asynchronous timer; The first method is to configure an asynchronous timer for the server, like for example:; serv->SetTimer(100, kFALSE);; Then, the timer will be activated even without any gSystem->ProcessEvents() method call. The main advantage of such method is that the application code can be used without any modifications. But there is no control when access to the application data is performed. It could happen just in-between of TH1::Fill() calls and an histogram object may be incomplete. Therefore such method is not recommended.; 1.8.2 Regular calls of THttpServer::ProcessRequests() method; The second method is preferable - one just inserts in the application regular calls of the THttpServer::ProcessRequests() method, like:; serv->ProcessRequests();; In such case, one can fully disable the timer of the server:; serv->SetTimer(0, kTRUE);; 1.9 Data access from command shell; The big advantage of the http protocol is that it is not only supported in web browsers, but also in many other applications. One could use http requests to directly access ROOT objects and data members from any kind of scripts.; If one starts a server and register an object like for example:; auto serv = new THttpServer(""http:8080"");; TNamed* n1 = new TNamed(""obj"", ""title"");; serv->Register(""subfolder"", n1);; One could request a JSON representation of such object with",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:14095,Performance,perform,performed,14095,"ed.; 1.8.2 Regular calls of THttpServer::ProcessRequests() method; The second method is preferable - one just inserts in the application regular calls of the THttpServer::ProcessRequests() method, like:; serv->ProcessRequests();; In such case, one can fully disable the timer of the server:; serv->SetTimer(0, kTRUE);; 1.9 Data access from command shell; The big advantage of the http protocol is that it is not only supported in web browsers, but also in many other applications. One could use http requests to directly access ROOT objects and data members from any kind of scripts.; If one starts a server and register an object like for example:; auto serv = new THttpServer(""http:8080"");; TNamed* n1 = new TNamed(""obj"", ""title"");; serv->Register(""subfolder"", n1);; One could request a JSON representation of such object with the command:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json; Then, its representation will look like:; {; ""_typename"" : ""TNamed"",; ""fUniqueID"" : 0,; ""fBits"" : 0,; ""fName"" : ""obj"",; ""fTitle"" : ""title""; }; The following requests can be performed:. Name; Description. root.bin; binary data produced by object streaming with TBufferFile. root.json; ROOT JSON representation for object and objects members. file.root; Creates TMemFile with the only object, from ROOT 6.32. root.xml; ROOT XML representation. root.png; PNG image (if object drawing implemented). root.gif; GIF image. root.jpeg; JPEG image. exe.json; method execution in the object. exe.bin; method execution, return result in binary form. cmd.json; command execution. item.json; item (object) properties, specified on the server. multi.json; perform several requests at once. multi.bin; perform several requests at once, return result in binary form. All data will be automatically zipped if ‘.gz’ extension is appended. Like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json.gz; If the access to the server is restricted with htdigest, it is recommended to use the curl ",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:14663,Performance,perform,perform,14663," THttpServer(""http:8080"");; TNamed* n1 = new TNamed(""obj"", ""title"");; serv->Register(""subfolder"", n1);; One could request a JSON representation of such object with the command:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json; Then, its representation will look like:; {; ""_typename"" : ""TNamed"",; ""fUniqueID"" : 0,; ""fBits"" : 0,; ""fName"" : ""obj"",; ""fTitle"" : ""title""; }; The following requests can be performed:. Name; Description. root.bin; binary data produced by object streaming with TBufferFile. root.json; ROOT JSON representation for object and objects members. file.root; Creates TMemFile with the only object, from ROOT 6.32. root.xml; ROOT XML representation. root.png; PNG image (if object drawing implemented). root.gif; GIF image. root.jpeg; JPEG image. exe.json; method execution in the object. exe.bin; method execution, return result in binary form. cmd.json; command execution. item.json; item (object) properties, specified on the server. multi.json; perform several requests at once. multi.bin; perform several requests at once, return result in binary form. All data will be automatically zipped if ‘.gz’ extension is appended. Like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json.gz; If the access to the server is restricted with htdigest, it is recommended to use the curl program since only curl correctly implements such authentication method. The command will look like:; [shell] curl --user ""accout:password"" http://localhost:8080/Objects/subfolder/obj/root.json --digest -o root.json; 1.9.1 Objects data access in JSON format; Request root.json implemented with TBufferJSON class. TBufferJSON generates such object representation, which could be directly used in JSROOT for drawing. root.json request returns either complete object or just object member like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; The result will be: ""title"".; For the root.json request one could specify the ‘compact’ parameter,",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:14708,Performance,perform,perform,14708,"itle"");; serv->Register(""subfolder"", n1);; One could request a JSON representation of such object with the command:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json; Then, its representation will look like:; {; ""_typename"" : ""TNamed"",; ""fUniqueID"" : 0,; ""fBits"" : 0,; ""fName"" : ""obj"",; ""fTitle"" : ""title""; }; The following requests can be performed:. Name; Description. root.bin; binary data produced by object streaming with TBufferFile. root.json; ROOT JSON representation for object and objects members. file.root; Creates TMemFile with the only object, from ROOT 6.32. root.xml; ROOT XML representation. root.png; PNG image (if object drawing implemented). root.gif; GIF image. root.jpeg; JPEG image. exe.json; method execution in the object. exe.bin; method execution, return result in binary form. cmd.json; command execution. item.json; item (object) properties, specified on the server. multi.json; perform several requests at once. multi.bin; perform several requests at once, return result in binary form. All data will be automatically zipped if ‘.gz’ extension is appended. Like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json.gz; If the access to the server is restricted with htdigest, it is recommended to use the curl program since only curl correctly implements such authentication method. The command will look like:; [shell] curl --user ""accout:password"" http://localhost:8080/Objects/subfolder/obj/root.json --digest -o root.json; 1.9.1 Objects data access in JSON format; Request root.json implemented with TBufferJSON class. TBufferJSON generates such object representation, which could be directly used in JSROOT for drawing. root.json request returns either complete object or just object member like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; The result will be: ""title"".; For the root.json request one could specify the ‘compact’ parameter, which allow to reduce the number of spaces and new lines wi",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:2161,Safety,timeout,timeout,2161,"ser (Firefox, Chrome, Opera, Safari, IE11) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics.; There is a server snapshot of running macro tutorials/http/httpserver.C from ROOT tutorials.; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following URL parameters are supported:. Name; Description. thrds=N; number of threads used by the civetweb (default is 10). top=name; configure top name, visible in the web browser. auth_file=filename; authentication file name, created with htdigets utility. auth_domain=domain; authentication domain. loopback; bind specified port to loopback 127.0.0.1 address. debug; enable debug mode, server returns html page with request info. websocket_timeout=tm; set web sockets timeout in seconds (default 300). websocket_disable; disable web sockets handling (default enabled). cors=domain; define value for CORS header “Access-Control-Allow-Origin” in server response. log=filename; configure civetweb log file. max_age=value; configures “Cache-Control: max_age=value” http header for all file-related requests, default 3600. nocache; try to fully disable cache control for file requests. winsymlinks=no; do not resolve symbolic links on file system (Windows only), default true. dirlisting=no; enable/disable directory listing for browsing filesystem (default no). If necessary, one could bind http server to specific IP address like:; new THttpServer(""http:192.168.1.17:8080""); One also can provide extra arguments for THttpServer itself:. Name; Description. readonly, ro; use server in read-only mode (default). readwrite, rw; use server in read-write mode. global; let scan global directories for canvases and files (default). noglobal; disable scan of global directori",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:234,Security,access,access,234,". HTTP Server. HTTP Server; Sergey Linev. HTTP Server; 1 HTTP server in ROOT; 1.1 Starting the HTTP server; 1.2 Registering objects; 1.3 Accessing file system; 1.4 Command interface; 1.5 Customize user interface; 1.6 Configuring user access; 1.7 Using FastCGI interface; 1.8 Integration with existing applications; 1.9 Data access from command shell; 1.10 Using unix sockets; 1.11 Websockets supports. HTTP Server; *** Sergey Linev GSI, Darmstadt ***; 1 HTTP server in ROOT; The idea of THttpServer is to provide remote http access to running ROOT application and enable HTML/JavaScript user interface. Any registered object can be requested and displayed in the web browser. There are many benefits of such approach:. standard http interface to ROOT application; no any temporary ROOT files to access data; user interface running in all browsers. 1.1 Starting the HTTP server; To start the http server, at any time, create an instance of the THttpServer class like:; auto serv = new THttpServer(""http:8080"");; This will start a civetweb-based http server on the port 8080. Then one should be able to open the address http://localhost:8080 in any modern browser (Firefox, Chrome, Opera, Safari, IE11) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics.; There is a server snapshot of running macro tutorials/http/httpserver.C from ROOT tutorials.; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following URL parameters are supported:. Name; Description. thrds=N; number of threads used by the civetweb (default is 10). top=name; configure top name, visible in the web browser. auth_file=filename; authentication file name, created with htdigets utility. auth_domain=domain; authentication domain. loopback;",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:324,Security,access,access,324,". HTTP Server. HTTP Server; Sergey Linev. HTTP Server; 1 HTTP server in ROOT; 1.1 Starting the HTTP server; 1.2 Registering objects; 1.3 Accessing file system; 1.4 Command interface; 1.5 Customize user interface; 1.6 Configuring user access; 1.7 Using FastCGI interface; 1.8 Integration with existing applications; 1.9 Data access from command shell; 1.10 Using unix sockets; 1.11 Websockets supports. HTTP Server; *** Sergey Linev GSI, Darmstadt ***; 1 HTTP server in ROOT; The idea of THttpServer is to provide remote http access to running ROOT application and enable HTML/JavaScript user interface. Any registered object can be requested and displayed in the web browser. There are many benefits of such approach:. standard http interface to ROOT application; no any temporary ROOT files to access data; user interface running in all browsers. 1.1 Starting the HTTP server; To start the http server, at any time, create an instance of the THttpServer class like:; auto serv = new THttpServer(""http:8080"");; This will start a civetweb-based http server on the port 8080. Then one should be able to open the address http://localhost:8080 in any modern browser (Firefox, Chrome, Opera, Safari, IE11) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics.; There is a server snapshot of running macro tutorials/http/httpserver.C from ROOT tutorials.; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following URL parameters are supported:. Name; Description. thrds=N; number of threads used by the civetweb (default is 10). top=name; configure top name, visible in the web browser. auth_file=filename; authentication file name, created with htdigets utility. auth_domain=domain; authentication domain. loopback;",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:525,Security,access,access,525,". HTTP Server. HTTP Server; Sergey Linev. HTTP Server; 1 HTTP server in ROOT; 1.1 Starting the HTTP server; 1.2 Registering objects; 1.3 Accessing file system; 1.4 Command interface; 1.5 Customize user interface; 1.6 Configuring user access; 1.7 Using FastCGI interface; 1.8 Integration with existing applications; 1.9 Data access from command shell; 1.10 Using unix sockets; 1.11 Websockets supports. HTTP Server; *** Sergey Linev GSI, Darmstadt ***; 1 HTTP server in ROOT; The idea of THttpServer is to provide remote http access to running ROOT application and enable HTML/JavaScript user interface. Any registered object can be requested and displayed in the web browser. There are many benefits of such approach:. standard http interface to ROOT application; no any temporary ROOT files to access data; user interface running in all browsers. 1.1 Starting the HTTP server; To start the http server, at any time, create an instance of the THttpServer class like:; auto serv = new THttpServer(""http:8080"");; This will start a civetweb-based http server on the port 8080. Then one should be able to open the address http://localhost:8080 in any modern browser (Firefox, Chrome, Opera, Safari, IE11) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics.; There is a server snapshot of running macro tutorials/http/httpserver.C from ROOT tutorials.; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following URL parameters are supported:. Name; Description. thrds=N; number of threads used by the civetweb (default is 10). top=name; configure top name, visible in the web browser. auth_file=filename; authentication file name, created with htdigets utility. auth_domain=domain; authentication domain. loopback;",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:795,Security,access,access,795,". HTTP Server. HTTP Server; Sergey Linev. HTTP Server; 1 HTTP server in ROOT; 1.1 Starting the HTTP server; 1.2 Registering objects; 1.3 Accessing file system; 1.4 Command interface; 1.5 Customize user interface; 1.6 Configuring user access; 1.7 Using FastCGI interface; 1.8 Integration with existing applications; 1.9 Data access from command shell; 1.10 Using unix sockets; 1.11 Websockets supports. HTTP Server; *** Sergey Linev GSI, Darmstadt ***; 1 HTTP server in ROOT; The idea of THttpServer is to provide remote http access to running ROOT application and enable HTML/JavaScript user interface. Any registered object can be requested and displayed in the web browser. There are many benefits of such approach:. standard http interface to ROOT application; no any temporary ROOT files to access data; user interface running in all browsers. 1.1 Starting the HTTP server; To start the http server, at any time, create an instance of the THttpServer class like:; auto serv = new THttpServer(""http:8080"");; This will start a civetweb-based http server on the port 8080. Then one should be able to open the address http://localhost:8080 in any modern browser (Firefox, Chrome, Opera, Safari, IE11) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics.; There is a server snapshot of running macro tutorials/http/httpserver.C from ROOT tutorials.; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following URL parameters are supported:. Name; Description. thrds=N; number of threads used by the civetweb (default is 10). top=name; configure top name, visible in the web browser. auth_file=filename; authentication file name, created with htdigets utility. auth_domain=domain; authentication domain. loopback;",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:1271,Security,access,access,1271,"with existing applications; 1.9 Data access from command shell; 1.10 Using unix sockets; 1.11 Websockets supports. HTTP Server; *** Sergey Linev GSI, Darmstadt ***; 1 HTTP server in ROOT; The idea of THttpServer is to provide remote http access to running ROOT application and enable HTML/JavaScript user interface. Any registered object can be requested and displayed in the web browser. There are many benefits of such approach:. standard http interface to ROOT application; no any temporary ROOT files to access data; user interface running in all browsers. 1.1 Starting the HTTP server; To start the http server, at any time, create an instance of the THttpServer class like:; auto serv = new THttpServer(""http:8080"");; This will start a civetweb-based http server on the port 8080. Then one should be able to open the address http://localhost:8080 in any modern browser (Firefox, Chrome, Opera, Safari, IE11) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics.; There is a server snapshot of running macro tutorials/http/httpserver.C from ROOT tutorials.; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following URL parameters are supported:. Name; Description. thrds=N; number of threads used by the civetweb (default is 10). top=name; configure top name, visible in the web browser. auth_file=filename; authentication file name, created with htdigets utility. auth_domain=domain; authentication domain. loopback; bind specified port to loopback 127.0.0.1 address. debug; enable debug mode, server returns html page with request info. websocket_timeout=tm; set web sockets timeout in seconds (default 300). websocket_disable; disable web sockets handling (default enabled). cors=domain; define value ",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:1892,Security,authenticat,authentication,1892,"y time, create an instance of the THttpServer class like:; auto serv = new THttpServer(""http:8080"");; This will start a civetweb-based http server on the port 8080. Then one should be able to open the address http://localhost:8080 in any modern browser (Firefox, Chrome, Opera, Safari, IE11) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics.; There is a server snapshot of running macro tutorials/http/httpserver.C from ROOT tutorials.; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following URL parameters are supported:. Name; Description. thrds=N; number of threads used by the civetweb (default is 10). top=name; configure top name, visible in the web browser. auth_file=filename; authentication file name, created with htdigets utility. auth_domain=domain; authentication domain. loopback; bind specified port to loopback 127.0.0.1 address. debug; enable debug mode, server returns html page with request info. websocket_timeout=tm; set web sockets timeout in seconds (default 300). websocket_disable; disable web sockets handling (default enabled). cors=domain; define value for CORS header “Access-Control-Allow-Origin” in server response. log=filename; configure civetweb log file. max_age=value; configures “Cache-Control: max_age=value” http header for all file-related requests, default 3600. nocache; try to fully disable cache control for file requests. winsymlinks=no; do not resolve symbolic links on file system (Windows only), default true. dirlisting=no; enable/disable directory listing for browsing filesystem (default no). If necessary, one could bind http server to specific IP address like:; new THttpServer(""http:192.168.1.17:8080""); One also can provide extra arguments for THtt",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:1969,Security,authenticat,authentication,1969,"uto serv = new THttpServer(""http:8080"");; This will start a civetweb-based http server on the port 8080. Then one should be able to open the address http://localhost:8080 in any modern browser (Firefox, Chrome, Opera, Safari, IE11) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics.; There is a server snapshot of running macro tutorials/http/httpserver.C from ROOT tutorials.; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following URL parameters are supported:. Name; Description. thrds=N; number of threads used by the civetweb (default is 10). top=name; configure top name, visible in the web browser. auth_file=filename; authentication file name, created with htdigets utility. auth_domain=domain; authentication domain. loopback; bind specified port to loopback 127.0.0.1 address. debug; enable debug mode, server returns html page with request info. websocket_timeout=tm; set web sockets timeout in seconds (default 300). websocket_disable; disable web sockets handling (default enabled). cors=domain; define value for CORS header “Access-Control-Allow-Origin” in server response. log=filename; configure civetweb log file. max_age=value; configures “Cache-Control: max_age=value” http header for all file-related requests, default 3600. nocache; try to fully disable cache control for file requests. winsymlinks=no; do not resolve symbolic links on file system (Windows only), default true. dirlisting=no; enable/disable directory listing for browsing filesystem (default no). If necessary, one could bind http server to specific IP address like:; new THttpServer(""http:192.168.1.17:8080""); One also can provide extra arguments for THttpServer itself:. Name; Description. readonly, ro; use server",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:4023,Security,access,access,4023," use server in read-write mode. global; let scan global directories for canvases and files (default). noglobal; disable scan of global directories. basic_sniffer; use basic TRootSniffer without support of hist, gpad, graph, tree classes. Example:; new THttpServer(""http:8080;ro;noglobal""); 1.2 Registering objects; At any time, one could register other objects with the command:; TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);; One should specify sub-folder name, where objects will be registered. If sub-folder name does not starts with slash /, than top-name folder /Objects/ will be prepended. At any time one could unregister objects:; serv->Unregister(gr);; THttpServer does not take ownership over registered objects - they should be deleted by user.; If the objects content is changing in the application, one could enable monitoring flag in the browser - then objects view will be regularly updated.; 1.3 Accessing file system; THttpServer provides partial access to the files from file system. First of all, JSROOT scripts and files can be accessed via “jsrootsys/” path like “http://localhost:8080/jsrootsys/modules/core.mjs”. Files from ROOT install directory can be get via “rootsys/” path like “http://localhost:8080/rootsys/icons/about.xpm”. Also files from current directory where ROOT is running can be accessed via “currentdir/” path like “http://localhost:8080/currentdir/file.txt”.; If necessary, one can add custom path as well, using THttpServer::AddLocation method:; serv->AddLocation(""mydir/"", ""/home/user/specials"");; Then files from that directory could be addressed via URL like “http://localhost:8080/mydir/myfile.root”; 1.4 Command interface; THttpServer class provide simple interface to invoke command from web browser. One just register command like:; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"");; Element with name DoSomething will appear in the web browser and can be clicked. It will result in gROOT->ProcessLin",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:4107,Security,access,accessed,4107,"; disable scan of global directories. basic_sniffer; use basic TRootSniffer without support of hist, gpad, graph, tree classes. Example:; new THttpServer(""http:8080;ro;noglobal""); 1.2 Registering objects; At any time, one could register other objects with the command:; TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);; One should specify sub-folder name, where objects will be registered. If sub-folder name does not starts with slash /, than top-name folder /Objects/ will be prepended. At any time one could unregister objects:; serv->Unregister(gr);; THttpServer does not take ownership over registered objects - they should be deleted by user.; If the objects content is changing in the application, one could enable monitoring flag in the browser - then objects view will be regularly updated.; 1.3 Accessing file system; THttpServer provides partial access to the files from file system. First of all, JSROOT scripts and files can be accessed via “jsrootsys/” path like “http://localhost:8080/jsrootsys/modules/core.mjs”. Files from ROOT install directory can be get via “rootsys/” path like “http://localhost:8080/rootsys/icons/about.xpm”. Also files from current directory where ROOT is running can be accessed via “currentdir/” path like “http://localhost:8080/currentdir/file.txt”.; If necessary, one can add custom path as well, using THttpServer::AddLocation method:; serv->AddLocation(""mydir/"", ""/home/user/specials"");; Then files from that directory could be addressed via URL like “http://localhost:8080/mydir/myfile.root”; 1.4 Command interface; THttpServer class provide simple interface to invoke command from web browser. One just register command like:; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"");; Element with name DoSomething will appear in the web browser and can be clicked. It will result in gROOT->ProcessLineSync(""SomeFunction()"") call.; One could configure argument(s) for the command. For that one should use %arg1,",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:4377,Security,access,accessed,4377," command:; TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);; One should specify sub-folder name, where objects will be registered. If sub-folder name does not starts with slash /, than top-name folder /Objects/ will be prepended. At any time one could unregister objects:; serv->Unregister(gr);; THttpServer does not take ownership over registered objects - they should be deleted by user.; If the objects content is changing in the application, one could enable monitoring flag in the browser - then objects view will be regularly updated.; 1.3 Accessing file system; THttpServer provides partial access to the files from file system. First of all, JSROOT scripts and files can be accessed via “jsrootsys/” path like “http://localhost:8080/jsrootsys/modules/core.mjs”. Files from ROOT install directory can be get via “rootsys/” path like “http://localhost:8080/rootsys/icons/about.xpm”. Also files from current directory where ROOT is running can be accessed via “currentdir/” path like “http://localhost:8080/currentdir/file.txt”.; If necessary, one can add custom path as well, using THttpServer::AddLocation method:; serv->AddLocation(""mydir/"", ""/home/user/specials"");; Then files from that directory could be addressed via URL like “http://localhost:8080/mydir/myfile.root”; 1.4 Command interface; THttpServer class provide simple interface to invoke command from web browser. One just register command like:; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"");; Element with name DoSomething will appear in the web browser and can be clicked. It will result in gROOT->ProcessLineSync(""SomeFunction()"") call.; One could configure argument(s) for the command. For that one should use %arg1, %arg2 and so on identifiers. Like:; serv->RegisterCommand(""/DoSomething"", ""SomeFunction(%arg1%,%arg2%)"");; User will be requested to enter arguments values, when command element clicked in the browser. Example of the command which executes arbitrary string ",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:7586,Security,access,access,7586,"""/"", ""_drawopt"", ""colz"");; In such case URL parameters are not required - specified item will be displayed automatically when web page is opened. One also can configure to display several items at once. For that one also can configure layout of the drawing area:; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; serv->SetItemField(""/"", ""_drawopt"", ""[colz,hist]""); // options; One also can change appearance of hierarchy browser on the left side of the web page:; serv->SetItemField(""/"", ""_browser"", ""off""); // allowed ""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // title of web page, shown when browser off; If necessary, one also can automatically open ROOT file when web page is opened:; serv->SetItemField(""/"", ""_loadfile"", ""currentdir/hsimple.root""); // name of ROOT file to load; 1.6 Configuring user access; By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the htdigest utility.; [shell] htdigest -c .htdigest domain_name user_name; It is recommended not to use special symbols in domain or user names. Several users can be add to the “.htdigest” file. When starting the server, the following arguments should be specified:; auto serv = new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; After that, the web browser will automatically request to input a name/password for the domain “domain_name”; Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using THttpServer::Restrict() method.; For instance, one could hide complete folder from ‘guest’ account:; serv->Restrict(""/Folder"", ""hidden=guest"");; Or one could hide from all but ‘admin’ account:; serv->Restrict(""/Folder"", ""visible=admin"");; Hi",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:7644,Security,access,access,7644,"""/"", ""_drawopt"", ""colz"");; In such case URL parameters are not required - specified item will be displayed automatically when web page is opened. One also can configure to display several items at once. For that one also can configure layout of the drawing area:; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; serv->SetItemField(""/"", ""_drawopt"", ""[colz,hist]""); // options; One also can change appearance of hierarchy browser on the left side of the web page:; serv->SetItemField(""/"", ""_browser"", ""off""); // allowed ""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // title of web page, shown when browser off; If necessary, one also can automatically open ROOT file when web page is opened:; serv->SetItemField(""/"", ""_loadfile"", ""currentdir/hsimple.root""); // name of ROOT file to load; 1.6 Configuring user access; By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the htdigest utility.; [shell] htdigest -c .htdigest domain_name user_name; It is recommended not to use special symbols in domain or user names. Several users can be add to the “.htdigest” file. When starting the server, the following arguments should be specified:; auto serv = new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; After that, the web browser will automatically request to input a name/password for the domain “domain_name”; Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using THttpServer::Restrict() method.; For instance, one could hide complete folder from ‘guest’ account:; serv->Restrict(""/Folder"", ""hidden=guest"");; Or one could hide from all but ‘admin’ account:; serv->Restrict(""/Folder"", ""visible=admin"");; Hi",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:7675,Security,access,access,7675,"fied item will be displayed automatically when web page is opened. One also can configure to display several items at once. For that one also can configure layout of the drawing area:; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; serv->SetItemField(""/"", ""_drawopt"", ""[colz,hist]""); // options; One also can change appearance of hierarchy browser on the left side of the web page:; serv->SetItemField(""/"", ""_browser"", ""off""); // allowed ""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // title of web page, shown when browser off; If necessary, one also can automatically open ROOT file when web page is opened:; serv->SetItemField(""/"", ""_loadfile"", ""currentdir/hsimple.root""); // name of ROOT file to load; 1.6 Configuring user access; By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the htdigest utility.; [shell] htdigest -c .htdigest domain_name user_name; It is recommended not to use special symbols in domain or user names. Several users can be add to the “.htdigest” file. When starting the server, the following arguments should be specified:; auto serv = new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; After that, the web browser will automatically request to input a name/password for the domain “domain_name”; Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using THttpServer::Restrict() method.; For instance, one could hide complete folder from ‘guest’ account:; serv->Restrict(""/Folder"", ""hidden=guest"");; Or one could hide from all but ‘admin’ account:; serv->Restrict(""/Folder"", ""visible=admin"");; Hidden folders or objects can not be accessed via http protocol.; By default serv",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:7700,Security,authenticat,authenticated,7700,"fied item will be displayed automatically when web page is opened. One also can configure to display several items at once. For that one also can configure layout of the drawing area:; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; serv->SetItemField(""/"", ""_drawopt"", ""[colz,hist]""); // options; One also can change appearance of hierarchy browser on the left side of the web page:; serv->SetItemField(""/"", ""_browser"", ""off""); // allowed ""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // title of web page, shown when browser off; If necessary, one also can automatically open ROOT file when web page is opened:; serv->SetItemField(""/"", ""_loadfile"", ""currentdir/hsimple.root""); // name of ROOT file to load; 1.6 Configuring user access; By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the htdigest utility.; [shell] htdigest -c .htdigest domain_name user_name; It is recommended not to use special symbols in domain or user names. Several users can be add to the “.htdigest” file. When starting the server, the following arguments should be specified:; auto serv = new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; After that, the web browser will automatically request to input a name/password for the domain “domain_name”; Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using THttpServer::Restrict() method.; For instance, one could hide complete folder from ‘guest’ account:; serv->Restrict(""/Folder"", ""hidden=guest"");; Or one could hide from all but ‘admin’ account:; serv->Restrict(""/Folder"", ""visible=admin"");; Hidden folders or objects can not be accessed via http protocol.; By default serv",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:7760,Security,password,password,7760," can configure to display several items at once. For that one also can configure layout of the drawing area:; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; serv->SetItemField(""/"", ""_drawopt"", ""[colz,hist]""); // options; One also can change appearance of hierarchy browser on the left side of the web page:; serv->SetItemField(""/"", ""_browser"", ""off""); // allowed ""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // title of web page, shown when browser off; If necessary, one also can automatically open ROOT file when web page is opened:; serv->SetItemField(""/"", ""_loadfile"", ""currentdir/hsimple.root""); // name of ROOT file to load; 1.6 Configuring user access; By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the htdigest utility.; [shell] htdigest -c .htdigest domain_name user_name; It is recommended not to use special symbols in domain or user names. Several users can be add to the “.htdigest” file. When starting the server, the following arguments should be specified:; auto serv = new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; After that, the web browser will automatically request to input a name/password for the domain “domain_name”; Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using THttpServer::Restrict() method.; For instance, one could hide complete folder from ‘guest’ account:; serv->Restrict(""/Folder"", ""hidden=guest"");; Or one could hide from all but ‘admin’ account:; serv->Restrict(""/Folder"", ""visible=admin"");; Hidden folders or objects can not be accessed via http protocol.; By default server runs in readonly mode and do not allow methods execution via ‘exe.json’ o",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:8207,Security,password,password,8207,"""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // title of web page, shown when browser off; If necessary, one also can automatically open ROOT file when web page is opened:; serv->SetItemField(""/"", ""_loadfile"", ""currentdir/hsimple.root""); // name of ROOT file to load; 1.6 Configuring user access; By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the htdigest utility.; [shell] htdigest -c .htdigest domain_name user_name; It is recommended not to use special symbols in domain or user names. Several users can be add to the “.htdigest” file. When starting the server, the following arguments should be specified:; auto serv = new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; After that, the web browser will automatically request to input a name/password for the domain “domain_name”; Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using THttpServer::Restrict() method.; For instance, one could hide complete folder from ‘guest’ account:; serv->Restrict(""/Folder"", ""hidden=guest"");; Or one could hide from all but ‘admin’ account:; serv->Restrict(""/Folder"", ""visible=admin"");; Hidden folders or objects can not be accessed via http protocol.; By default server runs in readonly mode and do not allow methods execution via ‘exe.json’ or ‘exe.bin’ requests. To allow such action, one could either grant generic access for all or one could allow to execute only special method:; serv->Restrict(""/Folder/histo1"", ""allow=all"");; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle"");; One could provide several options for the same item, separating them with ‘&’ sign:; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle&hide=guest"");; Complete list of supported options could be found in TRootSniffer:Restrict() me",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:8255,Security,authoriz,authorized,8255,"""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // title of web page, shown when browser off; If necessary, one also can automatically open ROOT file when web page is opened:; serv->SetItemField(""/"", ""_loadfile"", ""currentdir/hsimple.root""); // name of ROOT file to load; 1.6 Configuring user access; By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the htdigest utility.; [shell] htdigest -c .htdigest domain_name user_name; It is recommended not to use special symbols in domain or user names. Several users can be add to the “.htdigest” file. When starting the server, the following arguments should be specified:; auto serv = new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; After that, the web browser will automatically request to input a name/password for the domain “domain_name”; Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using THttpServer::Restrict() method.; For instance, one could hide complete folder from ‘guest’ account:; serv->Restrict(""/Folder"", ""hidden=guest"");; Or one could hide from all but ‘admin’ account:; serv->Restrict(""/Folder"", ""visible=admin"");; Hidden folders or objects can not be accessed via http protocol.; By default server runs in readonly mode and do not allow methods execution via ‘exe.json’ or ‘exe.bin’ requests. To allow such action, one could either grant generic access for all or one could allow to execute only special method:; serv->Restrict(""/Folder/histo1"", ""allow=all"");; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle"");; One could provide several options for the same item, separating them with ‘&’ sign:; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle&hide=guest"");; Complete list of supported options could be found in TRootSniffer:Restrict() me",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:8305,Security,access,access,8305,"""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // title of web page, shown when browser off; If necessary, one also can automatically open ROOT file when web page is opened:; serv->SetItemField(""/"", ""_loadfile"", ""currentdir/hsimple.root""); // name of ROOT file to load; 1.6 Configuring user access; By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the htdigest utility.; [shell] htdigest -c .htdigest domain_name user_name; It is recommended not to use special symbols in domain or user names. Several users can be add to the “.htdigest” file. When starting the server, the following arguments should be specified:; auto serv = new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; After that, the web browser will automatically request to input a name/password for the domain “domain_name”; Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using THttpServer::Restrict() method.; For instance, one could hide complete folder from ‘guest’ account:; serv->Restrict(""/Folder"", ""hidden=guest"");; Or one could hide from all but ‘admin’ account:; serv->Restrict(""/Folder"", ""visible=admin"");; Hidden folders or objects can not be accessed via http protocol.; By default server runs in readonly mode and do not allow methods execution via ‘exe.json’ or ‘exe.bin’ requests. To allow such action, one could either grant generic access for all or one could allow to execute only special method:; serv->Restrict(""/Folder/histo1"", ""allow=all"");; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle"");; One could provide several options for the same item, separating them with ‘&’ sign:; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle&hide=guest"");; Complete list of supported options could be found in TRootSniffer:Restrict() me",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:8644,Security,access,accessed,8644,"// name of ROOT file to load; 1.6 Configuring user access; By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the htdigest utility.; [shell] htdigest -c .htdigest domain_name user_name; It is recommended not to use special symbols in domain or user names. Several users can be add to the “.htdigest” file. When starting the server, the following arguments should be specified:; auto serv = new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; After that, the web browser will automatically request to input a name/password for the domain “domain_name”; Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using THttpServer::Restrict() method.; For instance, one could hide complete folder from ‘guest’ account:; serv->Restrict(""/Folder"", ""hidden=guest"");; Or one could hide from all but ‘admin’ account:; serv->Restrict(""/Folder"", ""visible=admin"");; Hidden folders or objects can not be accessed via http protocol.; By default server runs in readonly mode and do not allow methods execution via ‘exe.json’ or ‘exe.bin’ requests. To allow such action, one could either grant generic access for all or one could allow to execute only special method:; serv->Restrict(""/Folder/histo1"", ""allow=all"");; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle"");; One could provide several options for the same item, separating them with ‘&’ sign:; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle&hide=guest"");; Complete list of supported options could be found in TRootSniffer:Restrict() method documentation.; 1.7 Using FastCGI interface; FastCGI is a protocol for interfacing interactive programs with a web server like Apache, lighttpd, Microsoft ISS and many others.; When starting THttpServer, one could specify:; serv = new THttpServer(""fastcgi:9000"");; In fact, the Fas",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:8839,Security,access,access,8839," should be specified:; auto serv = new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; After that, the web browser will automatically request to input a name/password for the domain “domain_name”; Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using THttpServer::Restrict() method.; For instance, one could hide complete folder from ‘guest’ account:; serv->Restrict(""/Folder"", ""hidden=guest"");; Or one could hide from all but ‘admin’ account:; serv->Restrict(""/Folder"", ""visible=admin"");; Hidden folders or objects can not be accessed via http protocol.; By default server runs in readonly mode and do not allow methods execution via ‘exe.json’ or ‘exe.bin’ requests. To allow such action, one could either grant generic access for all or one could allow to execute only special method:; serv->Restrict(""/Folder/histo1"", ""allow=all"");; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle"");; One could provide several options for the same item, separating them with ‘&’ sign:; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle&hide=guest"");; Complete list of supported options could be found in TRootSniffer:Restrict() method documentation.; 1.7 Using FastCGI interface; FastCGI is a protocol for interfacing interactive programs with a web server like Apache, lighttpd, Microsoft ISS and many others.; When starting THttpServer, one could specify:; serv = new THttpServer(""fastcgi:9000"");; In fact, the FastCGI interface can run in parallel to http server. One can just call:; serv = new THttpServer(""http:8080"");; serv->CreateEngine(""fastcgi:9000"");; One could specify a debug parameter to be able to adjust the FastCGI configuration on the web server:; serv->CreateEngine(""fastcgi:9000?debug=1"");; By default 10 threads are used to process FastCGI requests. This number can be changed with “thrds” url parameter:; serv->CreateEngine(""fastcgi:9000?thrds=20"");; If thrds=0 parameter specified, the ",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:10099,Security,access,access,10099,"/Folder/histo1"", ""allow_method=GetTitle&hide=guest"");; Complete list of supported options could be found in TRootSniffer:Restrict() method documentation.; 1.7 Using FastCGI interface; FastCGI is a protocol for interfacing interactive programs with a web server like Apache, lighttpd, Microsoft ISS and many others.; When starting THttpServer, one could specify:; serv = new THttpServer(""fastcgi:9000"");; In fact, the FastCGI interface can run in parallel to http server. One can just call:; serv = new THttpServer(""http:8080"");; serv->CreateEngine(""fastcgi:9000"");; One could specify a debug parameter to be able to adjust the FastCGI configuration on the web server:; serv->CreateEngine(""fastcgi:9000?debug=1"");; By default 10 threads are used to process FastCGI requests. This number can be changed with “thrds” url parameter:; serv->CreateEngine(""fastcgi:9000?thrds=20"");; If thrds=0 parameter specified, the only thread will be use to received and process all requests.; All user access will be ruled by the main web server. Authorized account names could be used to configure access restriction in THttpServer.; 1.7.1 Configure fastcgi with Apache2; Since Apache version 2.4 FastCGI is directly supported - there is no need to compile and install external modules any more. One only need to enable mod_proxy and mod_proxy_fcgi modules and add following line to Apache2 configuration file:; ProxyPass ""/root.app/"" ""fcgi://localhost:9000/"" enablereuse=on; More information can be found in FastCGI proxy docu. After restarting apache server one should be able to open address: http://apache_host_name/root.app/. There are many ways to configure user authentication in Apache. Example of digest auth for FastCGI server:; <Location ""/root.app/"">; AuthType Digest; AuthName ""root""; AuthDigestDomain ""/root.app/"" ""root""; AuthDigestProvider file; AuthUserFile ""/srv/auth/auth.txt""; Require valid-user; </Location>; 1.7.2 Configure fastcgi with lighttpd; An example of configuration file for lighttpd serv",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:10196,Security,access,access,10196," supported options could be found in TRootSniffer:Restrict() method documentation.; 1.7 Using FastCGI interface; FastCGI is a protocol for interfacing interactive programs with a web server like Apache, lighttpd, Microsoft ISS and many others.; When starting THttpServer, one could specify:; serv = new THttpServer(""fastcgi:9000"");; In fact, the FastCGI interface can run in parallel to http server. One can just call:; serv = new THttpServer(""http:8080"");; serv->CreateEngine(""fastcgi:9000"");; One could specify a debug parameter to be able to adjust the FastCGI configuration on the web server:; serv->CreateEngine(""fastcgi:9000?debug=1"");; By default 10 threads are used to process FastCGI requests. This number can be changed with “thrds” url parameter:; serv->CreateEngine(""fastcgi:9000?thrds=20"");; If thrds=0 parameter specified, the only thread will be use to received and process all requests.; All user access will be ruled by the main web server. Authorized account names could be used to configure access restriction in THttpServer.; 1.7.1 Configure fastcgi with Apache2; Since Apache version 2.4 FastCGI is directly supported - there is no need to compile and install external modules any more. One only need to enable mod_proxy and mod_proxy_fcgi modules and add following line to Apache2 configuration file:; ProxyPass ""/root.app/"" ""fcgi://localhost:9000/"" enablereuse=on; More information can be found in FastCGI proxy docu. After restarting apache server one should be able to open address: http://apache_host_name/root.app/. There are many ways to configure user authentication in Apache. Example of digest auth for FastCGI server:; <Location ""/root.app/"">; AuthType Digest; AuthName ""root""; AuthDigestDomain ""/root.app/"" ""root""; AuthDigestProvider file; AuthUserFile ""/srv/auth/auth.txt""; Require valid-user; </Location>; 1.7.2 Configure fastcgi with lighttpd; An example of configuration file for lighttpd server is:; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:10767,Security,authenticat,authentication,10767,"ion on the web server:; serv->CreateEngine(""fastcgi:9000?debug=1"");; By default 10 threads are used to process FastCGI requests. This number can be changed with “thrds” url parameter:; serv->CreateEngine(""fastcgi:9000?thrds=20"");; If thrds=0 parameter specified, the only thread will be use to received and process all requests.; All user access will be ruled by the main web server. Authorized account names could be used to configure access restriction in THttpServer.; 1.7.1 Configure fastcgi with Apache2; Since Apache version 2.4 FastCGI is directly supported - there is no need to compile and install external modules any more. One only need to enable mod_proxy and mod_proxy_fcgi modules and add following line to Apache2 configuration file:; ProxyPass ""/root.app/"" ""fcgi://localhost:9000/"" enablereuse=on; More information can be found in FastCGI proxy docu. After restarting apache server one should be able to open address: http://apache_host_name/root.app/. There are many ways to configure user authentication in Apache. Example of digest auth for FastCGI server:; <Location ""/root.app/"">; AuthType Digest; AuthName ""root""; AuthDigestDomain ""/root.app/"" ""root""; AuthDigestProvider file; AuthUserFile ""/srv/auth/auth.txt""; Require valid-user; </Location>; 1.7.2 Configure fastcgi with lighttpd; An example of configuration file for lighttpd server is:; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); Be aware, that with lighttpd one should specify IP address of the host, where ROOT application is running. Address of the ROOT application will be following: http://lighttpd_host_name/root.app/. Example of authorization configuration for FastCGI connection:; auth.require = ( ""/root.app"" => (; ""method"" => ""digest"",; ""realm"" => ""root"",; ""require"" => ""valid-user""; ) ); 1.8 Integration with existing applications; In many practical cases no change of existing cod",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:11504,Security,authoriz,authorization,11504,"app/"" ""fcgi://localhost:9000/"" enablereuse=on; More information can be found in FastCGI proxy docu. After restarting apache server one should be able to open address: http://apache_host_name/root.app/. There are many ways to configure user authentication in Apache. Example of digest auth for FastCGI server:; <Location ""/root.app/"">; AuthType Digest; AuthName ""root""; AuthDigestDomain ""/root.app/"" ""root""; AuthDigestProvider file; AuthUserFile ""/srv/auth/auth.txt""; Require valid-user; </Location>; 1.7.2 Configure fastcgi with lighttpd; An example of configuration file for lighttpd server is:; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); Be aware, that with lighttpd one should specify IP address of the host, where ROOT application is running. Address of the ROOT application will be following: http://lighttpd_host_name/root.app/. Example of authorization configuration for FastCGI connection:; auth.require = ( ""/root.app"" => (; ""method"" => ""digest"",; ""realm"" => ""root"",; ""require"" => ""valid-user""; ) ); 1.8 Integration with existing applications; In many practical cases no change of existing code is required. Opened files (and all objects inside), existing canvas and histograms are automatically scanned by the server and will be available to the users. If necessary, any object can be registered directly to the server with a THttpServer::Register() call.; Central point of integration - when and how THttpServer get access to data from a running application. By default it is done during the gSystem->ProcessEvents() call - THttpServer uses a synchronous timer which is activated every 100 ms. Such approach works perfectly when running macros in an interactive ROOT session.; If an application runs in compiled code and does not contain gSystem->ProcessEvents() calls, two method are available.; 1.8.1 Asynchronous timer; The first method is to configure an",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:12085,Security,access,access,12085,"e of configuration file for lighttpd server is:; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); Be aware, that with lighttpd one should specify IP address of the host, where ROOT application is running. Address of the ROOT application will be following: http://lighttpd_host_name/root.app/. Example of authorization configuration for FastCGI connection:; auth.require = ( ""/root.app"" => (; ""method"" => ""digest"",; ""realm"" => ""root"",; ""require"" => ""valid-user""; ) ); 1.8 Integration with existing applications; In many practical cases no change of existing code is required. Opened files (and all objects inside), existing canvas and histograms are automatically scanned by the server and will be available to the users. If necessary, any object can be registered directly to the server with a THttpServer::Register() call.; Central point of integration - when and how THttpServer get access to data from a running application. By default it is done during the gSystem->ProcessEvents() call - THttpServer uses a synchronous timer which is activated every 100 ms. Such approach works perfectly when running macros in an interactive ROOT session.; If an application runs in compiled code and does not contain gSystem->ProcessEvents() calls, two method are available.; 1.8.1 Asynchronous timer; The first method is to configure an asynchronous timer for the server, like for example:; serv->SetTimer(100, kFALSE);; Then, the timer will be activated even without any gSystem->ProcessEvents() method call. The main advantage of such method is that the application code can be used without any modifications. But there is no control when access to the application data is performed. It could happen just in-between of TH1::Fill() calls and an histogram object may be incomplete. Therefore such method is not recommended.; 1.8.2 Regular calls of THttpServer::ProcessRequests() metho",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:12832,Security,access,access,12832,"grams are automatically scanned by the server and will be available to the users. If necessary, any object can be registered directly to the server with a THttpServer::Register() call.; Central point of integration - when and how THttpServer get access to data from a running application. By default it is done during the gSystem->ProcessEvents() call - THttpServer uses a synchronous timer which is activated every 100 ms. Such approach works perfectly when running macros in an interactive ROOT session.; If an application runs in compiled code and does not contain gSystem->ProcessEvents() calls, two method are available.; 1.8.1 Asynchronous timer; The first method is to configure an asynchronous timer for the server, like for example:; serv->SetTimer(100, kFALSE);; Then, the timer will be activated even without any gSystem->ProcessEvents() method call. The main advantage of such method is that the application code can be used without any modifications. But there is no control when access to the application data is performed. It could happen just in-between of TH1::Fill() calls and an histogram object may be incomplete. Therefore such method is not recommended.; 1.8.2 Regular calls of THttpServer::ProcessRequests() method; The second method is preferable - one just inserts in the application regular calls of the THttpServer::ProcessRequests() method, like:; serv->ProcessRequests();; In such case, one can fully disable the timer of the server:; serv->SetTimer(0, kTRUE);; 1.9 Data access from command shell; The big advantage of the http protocol is that it is not only supported in web browsers, but also in many other applications. One could use http requests to directly access ROOT objects and data members from any kind of scripts.; If one starts a server and register an object like for example:; auto serv = new THttpServer(""http:8080"");; TNamed* n1 = new TNamed(""obj"", ""title"");; serv->Register(""subfolder"", n1);; One could request a JSON representation of such object with",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:13339,Security,access,access,13339,"tem->ProcessEvents() calls, two method are available.; 1.8.1 Asynchronous timer; The first method is to configure an asynchronous timer for the server, like for example:; serv->SetTimer(100, kFALSE);; Then, the timer will be activated even without any gSystem->ProcessEvents() method call. The main advantage of such method is that the application code can be used without any modifications. But there is no control when access to the application data is performed. It could happen just in-between of TH1::Fill() calls and an histogram object may be incomplete. Therefore such method is not recommended.; 1.8.2 Regular calls of THttpServer::ProcessRequests() method; The second method is preferable - one just inserts in the application regular calls of the THttpServer::ProcessRequests() method, like:; serv->ProcessRequests();; In such case, one can fully disable the timer of the server:; serv->SetTimer(0, kTRUE);; 1.9 Data access from command shell; The big advantage of the http protocol is that it is not only supported in web browsers, but also in many other applications. One could use http requests to directly access ROOT objects and data members from any kind of scripts.; If one starts a server and register an object like for example:; auto serv = new THttpServer(""http:8080"");; TNamed* n1 = new TNamed(""obj"", ""title"");; serv->Register(""subfolder"", n1);; One could request a JSON representation of such object with the command:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json; Then, its representation will look like:; {; ""_typename"" : ""TNamed"",; ""fUniqueID"" : 0,; ""fBits"" : 0,; ""fName"" : ""obj"",; ""fTitle"" : ""title""; }; The following requests can be performed:. Name; Description. root.bin; binary data produced by object streaming with TBufferFile. root.json; ROOT JSON representation for object and objects members. file.root; Creates TMemFile with the only object, from ROOT 6.32. root.xml; ROOT XML representation. root.png; PNG image (if object drawing implement",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:13532,Security,access,access,13532,"imer for the server, like for example:; serv->SetTimer(100, kFALSE);; Then, the timer will be activated even without any gSystem->ProcessEvents() method call. The main advantage of such method is that the application code can be used without any modifications. But there is no control when access to the application data is performed. It could happen just in-between of TH1::Fill() calls and an histogram object may be incomplete. Therefore such method is not recommended.; 1.8.2 Regular calls of THttpServer::ProcessRequests() method; The second method is preferable - one just inserts in the application regular calls of the THttpServer::ProcessRequests() method, like:; serv->ProcessRequests();; In such case, one can fully disable the timer of the server:; serv->SetTimer(0, kTRUE);; 1.9 Data access from command shell; The big advantage of the http protocol is that it is not only supported in web browsers, but also in many other applications. One could use http requests to directly access ROOT objects and data members from any kind of scripts.; If one starts a server and register an object like for example:; auto serv = new THttpServer(""http:8080"");; TNamed* n1 = new TNamed(""obj"", ""title"");; serv->Register(""subfolder"", n1);; One could request a JSON representation of such object with the command:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json; Then, its representation will look like:; {; ""_typename"" : ""TNamed"",; ""fUniqueID"" : 0,; ""fBits"" : 0,; ""fName"" : ""obj"",; ""fTitle"" : ""title""; }; The following requests can be performed:. Name; Description. root.bin; binary data produced by object streaming with TBufferFile. root.json; ROOT JSON representation for object and objects members. file.root; Creates TMemFile with the only object, from ROOT 6.32. root.xml; ROOT XML representation. root.png; PNG image (if object drawing implemented). root.gif; GIF image. root.jpeg; JPEG image. exe.json; method execution in the object. exe.bin; method execution, return result",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:14927,Security,access,access,14927,"eID"" : 0,; ""fBits"" : 0,; ""fName"" : ""obj"",; ""fTitle"" : ""title""; }; The following requests can be performed:. Name; Description. root.bin; binary data produced by object streaming with TBufferFile. root.json; ROOT JSON representation for object and objects members. file.root; Creates TMemFile with the only object, from ROOT 6.32. root.xml; ROOT XML representation. root.png; PNG image (if object drawing implemented). root.gif; GIF image. root.jpeg; JPEG image. exe.json; method execution in the object. exe.bin; method execution, return result in binary form. cmd.json; command execution. item.json; item (object) properties, specified on the server. multi.json; perform several requests at once. multi.bin; perform several requests at once, return result in binary form. All data will be automatically zipped if ‘.gz’ extension is appended. Like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json.gz; If the access to the server is restricted with htdigest, it is recommended to use the curl program since only curl correctly implements such authentication method. The command will look like:; [shell] curl --user ""accout:password"" http://localhost:8080/Objects/subfolder/obj/root.json --digest -o root.json; 1.9.1 Objects data access in JSON format; Request root.json implemented with TBufferJSON class. TBufferJSON generates such object representation, which could be directly used in JSROOT for drawing. root.json request returns either complete object or just object member like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; The result will be: ""title"".; For the root.json request one could specify the ‘compact’ parameter, which allow to reduce the number of spaces and new lines without data lost. This parameter can have values from ‘0’ (no compression) till ‘3’ (no spaces and new lines at all). In addition, one can use simple compression algorithm for big arrays. If compact=‘10’, zero values in the begin and at the end of the array will b",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:15061,Security,authenticat,authentication,15061,"eID"" : 0,; ""fBits"" : 0,; ""fName"" : ""obj"",; ""fTitle"" : ""title""; }; The following requests can be performed:. Name; Description. root.bin; binary data produced by object streaming with TBufferFile. root.json; ROOT JSON representation for object and objects members. file.root; Creates TMemFile with the only object, from ROOT 6.32. root.xml; ROOT XML representation. root.png; PNG image (if object drawing implemented). root.gif; GIF image. root.jpeg; JPEG image. exe.json; method execution in the object. exe.bin; method execution, return result in binary form. cmd.json; command execution. item.json; item (object) properties, specified on the server. multi.json; perform several requests at once. multi.bin; perform several requests at once, return result in binary form. All data will be automatically zipped if ‘.gz’ extension is appended. Like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json.gz; If the access to the server is restricted with htdigest, it is recommended to use the curl program since only curl correctly implements such authentication method. The command will look like:; [shell] curl --user ""accout:password"" http://localhost:8080/Objects/subfolder/obj/root.json --digest -o root.json; 1.9.1 Objects data access in JSON format; Request root.json implemented with TBufferJSON class. TBufferJSON generates such object representation, which could be directly used in JSROOT for drawing. root.json request returns either complete object or just object member like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; The result will be: ""title"".; For the root.json request one could specify the ‘compact’ parameter, which allow to reduce the number of spaces and new lines without data lost. This parameter can have values from ‘0’ (no compression) till ‘3’ (no spaces and new lines at all). In addition, one can use simple compression algorithm for big arrays. If compact=‘10’, zero values in the begin and at the end of the array will b",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:15141,Security,password,password,15141,"y data produced by object streaming with TBufferFile. root.json; ROOT JSON representation for object and objects members. file.root; Creates TMemFile with the only object, from ROOT 6.32. root.xml; ROOT XML representation. root.png; PNG image (if object drawing implemented). root.gif; GIF image. root.jpeg; JPEG image. exe.json; method execution in the object. exe.bin; method execution, return result in binary form. cmd.json; command execution. item.json; item (object) properties, specified on the server. multi.json; perform several requests at once. multi.bin; perform several requests at once, return result in binary form. All data will be automatically zipped if ‘.gz’ extension is appended. Like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json.gz; If the access to the server is restricted with htdigest, it is recommended to use the curl program since only curl correctly implements such authentication method. The command will look like:; [shell] curl --user ""accout:password"" http://localhost:8080/Objects/subfolder/obj/root.json --digest -o root.json; 1.9.1 Objects data access in JSON format; Request root.json implemented with TBufferJSON class. TBufferJSON generates such object representation, which could be directly used in JSROOT for drawing. root.json request returns either complete object or just object member like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; The result will be: ""title"".; For the root.json request one could specify the ‘compact’ parameter, which allow to reduce the number of spaces and new lines without data lost. This parameter can have values from ‘0’ (no compression) till ‘3’ (no spaces and new lines at all). In addition, one can use simple compression algorithm for big arrays. If compact=‘10’, zero values in the begin and at the end of the array will be excluded. If compact=‘20’, similar values or large zero gaps in-between will be compressed. Such array compression support in JSROOT from ve",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:15247,Security,access,access,15247,"bers. file.root; Creates TMemFile with the only object, from ROOT 6.32. root.xml; ROOT XML representation. root.png; PNG image (if object drawing implemented). root.gif; GIF image. root.jpeg; JPEG image. exe.json; method execution in the object. exe.bin; method execution, return result in binary form. cmd.json; command execution. item.json; item (object) properties, specified on the server. multi.json; perform several requests at once. multi.bin; perform several requests at once, return result in binary form. All data will be automatically zipped if ‘.gz’ extension is appended. Like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json.gz; If the access to the server is restricted with htdigest, it is recommended to use the curl program since only curl correctly implements such authentication method. The command will look like:; [shell] curl --user ""accout:password"" http://localhost:8080/Objects/subfolder/obj/root.json --digest -o root.json; 1.9.1 Objects data access in JSON format; Request root.json implemented with TBufferJSON class. TBufferJSON generates such object representation, which could be directly used in JSROOT for drawing. root.json request returns either complete object or just object member like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; The result will be: ""title"".; For the root.json request one could specify the ‘compact’ parameter, which allow to reduce the number of spaces and new lines without data lost. This parameter can have values from ‘0’ (no compression) till ‘3’ (no spaces and new lines at all). In addition, one can use simple compression algorithm for big arrays. If compact=‘10’, zero values in the begin and at the end of the array will be excluded. If compact=‘20’, similar values or large zero gaps in-between will be compressed. Such array compression support in JSROOT from version 4.8.2.; Usage of root.json request is about as efficient as binary root.bin request. Comparison of different r",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:17524,Security,access,access,17524,"data fields which are not present in the binary representation. Even then the size difference is negligible.; root.json used in JSROOT to request objects from THttpServer.; 1.9.2 Generating images out of objects; For the ROOT classes which are implementing Draw method (like TH1 or TGraph) one could produce images with requests: root.png, root.gif, root.jpeg. For example:; [shell] wget ""http://localhost:8080/Files/hsimple.root/hpx/root.png?w=500&h=500&opt=lego1"" -O lego1.png; For all such requests following parameters could be specified:. h - image height; w - image width; opt - draw options. 1.9.3 Methods execution; By default THttpServer starts in monitoring (read-only) mode and therefore forbid any methods execution. One could specify read-write mode when server is started:; auto serv = new THttpServer(""http:8080;rw"");; Or one could disable read-only mode with the call:; serv->SetReadOnly(kFALSE);; Or one could allow access to the folder, object or specific object methods with:; serv->Restrict(""/Histograms"", ""allow=admin""); // allow full access for user with 'admin' account; serv->Restrict(""/Histograms/hist1"", ""allow=all""); // allow full access for all users; serv->Restrict(""/Histograms/hist1"", ""allow_method=Rebin""); // allow only Rebin method; ‘exe.json’ accepts following parameters:. method - name of method to execute; prototype - method prototype (see TClass::GetMethodWithPrototype for details); compact - compact parameter, used to compress return value; _ret_object_ - name of the object which should be returned as result of method execution (used together with remote TTree::Draw call). Example of retrieving object title:; [shell] wget 'http://localhost:8080/Objects/subfolder/obj/exe.json?method=GetTitle' -O title.json; Example of TTree::Draw method execution:; [shell] wget 'http://localhost:8080/Files/job1.root/ntuple/exe.json?method=Draw&prototype=""Option_t*""&opt=""px:py>>h1""&_ret_object_=h1' -O exe.json; One also used exe.bin method - in this case results of ",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:17647,Security,access,access,17647,"data fields which are not present in the binary representation. Even then the size difference is negligible.; root.json used in JSROOT to request objects from THttpServer.; 1.9.2 Generating images out of objects; For the ROOT classes which are implementing Draw method (like TH1 or TGraph) one could produce images with requests: root.png, root.gif, root.jpeg. For example:; [shell] wget ""http://localhost:8080/Files/hsimple.root/hpx/root.png?w=500&h=500&opt=lego1"" -O lego1.png; For all such requests following parameters could be specified:. h - image height; w - image width; opt - draw options. 1.9.3 Methods execution; By default THttpServer starts in monitoring (read-only) mode and therefore forbid any methods execution. One could specify read-write mode when server is started:; auto serv = new THttpServer(""http:8080;rw"");; Or one could disable read-only mode with the call:; serv->SetReadOnly(kFALSE);; Or one could allow access to the folder, object or specific object methods with:; serv->Restrict(""/Histograms"", ""allow=admin""); // allow full access for user with 'admin' account; serv->Restrict(""/Histograms/hist1"", ""allow=all""); // allow full access for all users; serv->Restrict(""/Histograms/hist1"", ""allow_method=Rebin""); // allow only Rebin method; ‘exe.json’ accepts following parameters:. method - name of method to execute; prototype - method prototype (see TClass::GetMethodWithPrototype for details); compact - compact parameter, used to compress return value; _ret_object_ - name of the object which should be returned as result of method execution (used together with remote TTree::Draw call). Example of retrieving object title:; [shell] wget 'http://localhost:8080/Objects/subfolder/obj/exe.json?method=GetTitle' -O title.json; Example of TTree::Draw method execution:; [shell] wget 'http://localhost:8080/Files/job1.root/ntuple/exe.json?method=Draw&prototype=""Option_t*""&opt=""px:py>>h1""&_ret_object_=h1' -O exe.json; One also used exe.bin method - in this case results of ",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:17749,Security,access,access,17749,"data fields which are not present in the binary representation. Even then the size difference is negligible.; root.json used in JSROOT to request objects from THttpServer.; 1.9.2 Generating images out of objects; For the ROOT classes which are implementing Draw method (like TH1 or TGraph) one could produce images with requests: root.png, root.gif, root.jpeg. For example:; [shell] wget ""http://localhost:8080/Files/hsimple.root/hpx/root.png?w=500&h=500&opt=lego1"" -O lego1.png; For all such requests following parameters could be specified:. h - image height; w - image width; opt - draw options. 1.9.3 Methods execution; By default THttpServer starts in monitoring (read-only) mode and therefore forbid any methods execution. One could specify read-write mode when server is started:; auto serv = new THttpServer(""http:8080;rw"");; Or one could disable read-only mode with the call:; serv->SetReadOnly(kFALSE);; Or one could allow access to the folder, object or specific object methods with:; serv->Restrict(""/Histograms"", ""allow=admin""); // allow full access for user with 'admin' account; serv->Restrict(""/Histograms/hist1"", ""allow=all""); // allow full access for all users; serv->Restrict(""/Histograms/hist1"", ""allow_method=Rebin""); // allow only Rebin method; ‘exe.json’ accepts following parameters:. method - name of method to execute; prototype - method prototype (see TClass::GetMethodWithPrototype for details); compact - compact parameter, used to compress return value; _ret_object_ - name of the object which should be returned as result of method execution (used together with remote TTree::Draw call). Example of retrieving object title:; [shell] wget 'http://localhost:8080/Objects/subfolder/obj/exe.json?method=GetTitle' -O title.json; Example of TTree::Draw method execution:; [shell] wget 'http://localhost:8080/Files/job1.root/ntuple/exe.json?method=Draw&prototype=""Option_t*""&opt=""px:py>>h1""&_ret_object_=h1' -O exe.json; One also used exe.bin method - in this case results of ",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:22553,Security,access,access,22553,"is:; import { httpRequest, draw } from './jsrootsys/modules/core.mjs';; let res = await httpRequest(""your_server/multi.json?number=3"", ""multi"",; ""Files/job1.root/hpx/root.json\nFiles/job1.root/hpxpy/root.json\nFiles/job1.root/hprof/root.json\n"");; for (let n = 0; n < res.length; ++n) {; console.log('Requested element of type', res[n]._typename);; // draw('drawid', res[n], 'hist');; }; Here argument “multi” identifies, that server response should be parsed with parseMulti() function, which correctly interprets JSON code, produced by multi.json request. When sending such request to the server, one should provide list of objects names and not forget “?number=N” parameter in the request URL string.; 1.10 Using unix sockets; Starting from ROOT version 6.28, one can start server with unix socket. Just do:; Just call:; [root] new THttpServer(""socket:/tmp/root.socket""); Name of socket should be unique and not match any existing files.; Most easy way to access THttpServer running via unix socket is to configure ssh tunnel:; [shell] ssh -L 7654:/tmp/root.socket localhost; Once such tunnel is configured one can open following URL in web browser:; [shell] xdg-open http://localhost:7654; 1.11 Websockets supports; Websockets support available starting from ROOT v6.12. Minimal example provided in $ROOTSYS/tutorials/http/ws.C macro.; To work with websockets, subclass of THttpWSHandler should be created and registered to THttpServer:; #include ""THttpWSHandler.h"". class TUserHandler : public THttpWSHandler {; public:; TUserHandler(const char *name, const char *title) : THttpWSHandler(name, title) {}. // provide custom HTML page when open correspondent address; TString GetDefaultPageContent() override { return ""file:ws.htm""; }. Bool_t ProcessWS(THttpCallArg *arg) override;; };; Central method is TUserHandler::ProcessWS(THttpCallArg *arg), where four kinds of websockets events should be handled:. WS_CONNECT - clients attempts to create websockets, return false when refusing connection; ",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:2354,Testability,log,log,2354,"SROOT graphics.; There is a server snapshot of running macro tutorials/http/httpserver.C from ROOT tutorials.; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following URL parameters are supported:. Name; Description. thrds=N; number of threads used by the civetweb (default is 10). top=name; configure top name, visible in the web browser. auth_file=filename; authentication file name, created with htdigets utility. auth_domain=domain; authentication domain. loopback; bind specified port to loopback 127.0.0.1 address. debug; enable debug mode, server returns html page with request info. websocket_timeout=tm; set web sockets timeout in seconds (default 300). websocket_disable; disable web sockets handling (default enabled). cors=domain; define value for CORS header “Access-Control-Allow-Origin” in server response. log=filename; configure civetweb log file. max_age=value; configures “Cache-Control: max_age=value” http header for all file-related requests, default 3600. nocache; try to fully disable cache control for file requests. winsymlinks=no; do not resolve symbolic links on file system (Windows only), default true. dirlisting=no; enable/disable directory listing for browsing filesystem (default no). If necessary, one could bind http server to specific IP address like:; new THttpServer(""http:192.168.1.17:8080""); One also can provide extra arguments for THttpServer itself:. Name; Description. readonly, ro; use server in read-only mode (default). readwrite, rw; use server in read-write mode. global; let scan global directories for canvases and files (default). noglobal; disable scan of global directories. basic_sniffer; use basic TRootSniffer without support of hist, gpad, graph, tree classes. Example:; new THttpServer(""http:8080;ro;noglobal""); 1.2 Registering objects; At any time, one could register other objects ",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:2387,Testability,log,log,2387,"SROOT graphics.; There is a server snapshot of running macro tutorials/http/httpserver.C from ROOT tutorials.; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following URL parameters are supported:. Name; Description. thrds=N; number of threads used by the civetweb (default is 10). top=name; configure top name, visible in the web browser. auth_file=filename; authentication file name, created with htdigets utility. auth_domain=domain; authentication domain. loopback; bind specified port to loopback 127.0.0.1 address. debug; enable debug mode, server returns html page with request info. websocket_timeout=tm; set web sockets timeout in seconds (default 300). websocket_disable; disable web sockets handling (default enabled). cors=domain; define value for CORS header “Access-Control-Allow-Origin” in server response. log=filename; configure civetweb log file. max_age=value; configures “Cache-Control: max_age=value” http header for all file-related requests, default 3600. nocache; try to fully disable cache control for file requests. winsymlinks=no; do not resolve symbolic links on file system (Windows only), default true. dirlisting=no; enable/disable directory listing for browsing filesystem (default no). If necessary, one could bind http server to specific IP address like:; new THttpServer(""http:192.168.1.17:8080""); One also can provide extra arguments for THttpServer itself:. Name; Description. readonly, ro; use server in read-only mode (default). readwrite, rw; use server in read-write mode. global; let scan global directories for canvases and files (default). noglobal; disable scan of global directories. basic_sniffer; use basic TRootSniffer without support of hist, gpad, graph, tree classes. Example:; new THttpServer(""http:8080;ro;noglobal""); 1.2 Registering objects; At any time, one could register other objects ",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:21890,Testability,log,log,21890,"t (like root.json or exe.json). Result will be JSON array. For multi.bin any kind of requests can be used. It returns binary buffer with following content:; [size1 (little endian), 4 bytes] + [request1 result, size1 bytes]; [size2 (little endian), 4 bytes] + [request2 result, size2 bytes]; [size3 (little endian), 4 bytes] + [request3 result, size3 bytes]; While POST data in request used to transfer list of multiple requests, it is not possible to submit such kind of requests, which themselves require data from POST block.; To use multi.json request from the JavaScript, one should create special ‘POST’ HTTP request and properly parse it. JSROOT provides special method to do this:; import { httpRequest, draw } from './jsrootsys/modules/core.mjs';; let res = await httpRequest(""your_server/multi.json?number=3"", ""multi"",; ""Files/job1.root/hpx/root.json\nFiles/job1.root/hpxpy/root.json\nFiles/job1.root/hprof/root.json\n"");; for (let n = 0; n < res.length; ++n) {; console.log('Requested element of type', res[n]._typename);; // draw('drawid', res[n], 'hist');; }; Here argument “multi” identifies, that server response should be parsed with parseMulti() function, which correctly interprets JSON code, produced by multi.json request. When sending such request to the server, one should provide list of objects names and not forget “?number=N” parameter in the request URL string.; 1.10 Using unix sockets; Starting from ROOT version 6.28, one can start server with unix socket. Just do:; Just call:; [root] new THttpServer(""socket:/tmp/root.socket""); Name of socket should be unique and not match any existing files.; Most easy way to access THttpServer running via unix socket is to configure ssh tunnel:; [shell] ssh -L 7654:/tmp/root.socket localhost; Once such tunnel is configured one can open following URL in web browser:; [shell] xdg-open http://localhost:7654; 1.11 Websockets supports; Websockets support available starting from ROOT v6.12. Minimal example provided in $ROOTSYS/tuto",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:4755,Usability,simpl,simple,4755,"over registered objects - they should be deleted by user.; If the objects content is changing in the application, one could enable monitoring flag in the browser - then objects view will be regularly updated.; 1.3 Accessing file system; THttpServer provides partial access to the files from file system. First of all, JSROOT scripts and files can be accessed via “jsrootsys/” path like “http://localhost:8080/jsrootsys/modules/core.mjs”. Files from ROOT install directory can be get via “rootsys/” path like “http://localhost:8080/rootsys/icons/about.xpm”. Also files from current directory where ROOT is running can be accessed via “currentdir/” path like “http://localhost:8080/currentdir/file.txt”.; If necessary, one can add custom path as well, using THttpServer::AddLocation method:; serv->AddLocation(""mydir/"", ""/home/user/specials"");; Then files from that directory could be addressed via URL like “http://localhost:8080/mydir/myfile.root”; 1.4 Command interface; THttpServer class provide simple interface to invoke command from web browser. One just register command like:; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"");; Element with name DoSomething will appear in the web browser and can be clicked. It will result in gROOT->ProcessLineSync(""SomeFunction()"") call.; One could configure argument(s) for the command. For that one should use %arg1, %arg2 and so on identifiers. Like:; serv->RegisterCommand(""/DoSomething"", ""SomeFunction(%arg1%,%arg2%)"");; User will be requested to enter arguments values, when command element clicked in the browser. Example of the command which executes arbitrary string in application via ProcessLine looks like:; serv->RegisterCommand(""/Process"", ""%arg1%"");; When registering command, one could specify icon name which will be displayed with the command.; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"", ""rootsys/icons/ed_execute.png"");; In example usage of images from $ROOTSYS/icons directory is shown. One could prepend button; strin",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:15879,Usability,simpl,simple,15879,"cts/subfolder/obj/root.json.gz; If the access to the server is restricted with htdigest, it is recommended to use the curl program since only curl correctly implements such authentication method. The command will look like:; [shell] curl --user ""accout:password"" http://localhost:8080/Objects/subfolder/obj/root.json --digest -o root.json; 1.9.1 Objects data access in JSON format; Request root.json implemented with TBufferJSON class. TBufferJSON generates such object representation, which could be directly used in JSROOT for drawing. root.json request returns either complete object or just object member like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; The result will be: ""title"".; For the root.json request one could specify the ‘compact’ parameter, which allow to reduce the number of spaces and new lines without data lost. This parameter can have values from ‘0’ (no compression) till ‘3’ (no spaces and new lines at all). In addition, one can use simple compression algorithm for big arrays. If compact=‘10’, zero values in the begin and at the end of the array will be excluded. If compact=‘20’, similar values or large zero gaps in-between will be compressed. Such array compression support in JSROOT from version 4.8.2.; Usage of root.json request is about as efficient as binary root.bin request. Comparison of different request methods with TH2 histogram from hsimple.C shown in the table:. Request; Size. root.bin; 7672 bytes. root.bin.gz; 1582 bytes. root.json; 8570 bytes. root.json?compact=3; 6004 bytes. root.json?compact=23; 5216 bytes. root.json.gz?compact=23; 1855 bytes. One should remember that JSON representation always includes names of the data fields which are not present in the binary representation. Even then the size difference is negligible.; root.json used in JSROOT to request objects from THttpServer.; 1.9.2 Generating images out of objects; For the ROOT classes which are implementing Draw method (like TH1 or TGraph) one cou",MatchSource.WIKI,root/htmldoc/guides/HttpServer/HttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:937,Availability,down,download,937,"ript ROOT. JavaScript ROOT; Sergey Linev. JavaScript ROOT; 1 JavaScript ROOT; 1.1 Installing JSROOT; 1.2 Drawing objects in JSROOT; 1.3 Supported ROOT classes by JSROOT; 1.4 Superimposing draw objects; 1.5 TTree draw; 1.6 Geometry viewer; 1.7 Reading ROOT files from other servers; 1.8 Reading local ROOT files; 1.9 JSROOT with THttpServer; 1.10 Data monitoring with JSROOT; 1.11 JSROOT API. JavaScript ROOT; *** Sergey Linev GSI, Darmstadt ***; 1 JavaScript ROOT; The JSROOT project allows: - reading of binary and JSON ROOT files in JavaScript; - drawing of different ROOT classes in web browsers; - reading and drawing TTree data; - using in node.js.; 1.1 Installing JSROOT; In most practical cases it is not necessary to install JSROOT - it can be used directly from project web sites https://root.cern/js/ and https://jsroot.gsi.de/.; When required, there are following alternatives to install JSROOT on other web servers:. download and unpack provided packages (recommended); use npm package manager and invoke npm install jsroot; clone master branch from repository. 1.2 Drawing objects in JSROOT; The main page of the JSROOT project provides the possibility to interactively open ROOT files and draw objects like histogram or canvas.; To automate files loading and objects drawing, one can provide number of URL parameters in address string like:. file - name of the file, which will be automatically open with page loading; files - array of file names for loading; json - name of JSON file with stored ROOT object like histogram or canvas; item - item name to be displayed; opt - drawing option for the item; items - array of items name to be displayed; opts - array of drawing options for the items; expand - item name(s) to be expanded in the hierarchy browser; focus - item name to be focused on in the hierarchy browser; title - set browser title; dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; layout - can be ‘simple’, ‘flex’, ‘tabs",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:4362,Availability,avail,available,4362,"eation date, 3 - file modification date; utc - select timeZone to ‘UTC’; datex - X position of date; datey - Y position of date; optfile - plot file name on the canvas, 1 - file name, 2 - full file URL, 3 - object item name; opttitle - disable/enable drawing of object title in the canvas; nomenu - disable context menu; notouch - disable touch events handling; progress - switch progress display mode between ‘off’, ‘on’ and ‘modal’. For instance:. https://root.cern/js/latest/?file=../files/hsimple.root&item=hpx;1; https://root.cern/js/latest/?file=../files/hsimple.root&nobrowser&item=hpxpy;1&opt=colz; https://root.cern/js/latest/?file=../files/hsimple.root&noselect&layout=grid2x2&item=hprof;1. Following layouts are supported:. simple - available space used for single object (default); flex - creates as many frames as necessary, each can be individually moved/enlarged; tabs - tabs for each object drawing; gridNxM - fixed-size grid with NxM frames; vertN - N frames sorted in vertical direction (like gridi1xN); horizN - N frames sorted in horizontal direction (like gridiNx1); vert121 - 3 frames sorted in vertical direction, second frame divided on two sub-frames; horiz32_12 - 2 horizontal frames with 3 and 2 subframes, and 1/3 and 2/3 as relative size. When specifying files, items or opts parameters, array of strings could be provided like files=['file1.root','file2.root']. One could skip quotes when specifying elements names items=[file1.root/hpx,file2.root/hpy] or opts=['',colz].; As item name, URL to existing image can be provided like item=img:http://server/image.png. Such image will be just inserted in the existing layout. One could specify option ""scale"" to automatically scale image to available space.; Many examples of URL string usage can be found on JSROOT API examples page.; One can very easy integrate JSROOT graphic into arbitrary HTML pages using a iframe tag:; <iframe width=""700"" height=""400""; src=""https://root.cern/js/latest/?nobrowser&file=https://root.cern",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:5334,Availability,avail,available,5334,"=hprof;1. Following layouts are supported:. simple - available space used for single object (default); flex - creates as many frames as necessary, each can be individually moved/enlarged; tabs - tabs for each object drawing; gridNxM - fixed-size grid with NxM frames; vertN - N frames sorted in vertical direction (like gridi1xN); horizN - N frames sorted in horizontal direction (like gridiNx1); vert121 - 3 frames sorted in vertical direction, second frame divided on two sub-frames; horiz32_12 - 2 horizontal frames with 3 and 2 subframes, and 1/3 and 2/3 as relative size. When specifying files, items or opts parameters, array of strings could be provided like files=['file1.root','file2.root']. One could skip quotes when specifying elements names items=[file1.root/hpx,file2.root/hpy] or opts=['',colz].; As item name, URL to existing image can be provided like item=img:http://server/image.png. Such image will be just inserted in the existing layout. One could specify option ""scale"" to automatically scale image to available space.; Many examples of URL string usage can be found on JSROOT API examples page.; One can very easy integrate JSROOT graphic into arbitrary HTML pages using a iframe tag:; <iframe width=""700"" height=""400""; src=""https://root.cern/js/latest/?nobrowser&file=https://root.cern/js/files/hsimple.root&item=hpxpy&opt=colz"">; </iframe>; 1.3 Supported ROOT classes by JSROOT; List of supported classes and draw options:. TH1 : hist, p, p0, *, l, lf2, a, e, e0, e1, e1x0, e3, e4, lego, text, X+Y+; TH2 : scat, col, colz, box, box1, text, lego, arr, cont, cont1, cont2, cont3, cont4, surf, surf1, surf2, surf3, surf4, surf6, surf7, lego, lego0, lego1, lego2, lego3, lego4; TH2Poly : col, lego, europe, usa; TH3 : scat, box, box1; TProfile : dflt, e, e1, pe2, hist, text, texte; TProfile2D : example; THStack : example; TF1 : example; TF2 : example; TSpline : example; TGraph : dflt, L, P, *, B, RX, RY; TGraphErrors : dflt, l, lx, z, >, |>, ||, [], 0, 2, 3, 4, 5; TGraphAsy",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:21994,Availability,failure,failures,21994,"nitoring. With such approach, a ROOT-based application creates and regularly updates content of a ROOT file, which can be accessed via normal web server. From the browser side, JSROOT could regularly read the specified objects and update their drawings. But such solution has three major caveats.; First of all, one need to store the data of all objects, which only potentially could be displayed in the browser. In case of 10 objects it does not matter, but for 1000 or 100000 objects this will be a major performance penalty. With such big amount of data one will never achieve higher update rate.; The second problem is I/O. To read the first object from the ROOT file, one need to perform several (about 5) file-reading operations via http protocol. There is no http file locking mechanism (at least not for standard web servers), therefore there is no guarantee that the file content is not changed/replaced between consequent read operations. Therefore, one should expect frequent I/O failures while trying to monitor data from ROOT binary files. There is a workaround for the problem - one could load the file completely and exclude many partial I/O operations by this. To achieve this with JSROOT, one should add “+” sign at the end of the file name. Of course, it only could work for small files.; If somebody still wants to use monitoring of data from ROOT files, could try link like:. https://root.cern/js/latest/?nobrowser&file=../files/hsimple.root+&item=hpx;1&monitoring=2000. In this particular case, the histogram is not changing.; 1.11 JSROOT API; JSROOT can be used in arbitrary HTML pages to display data, produced with or without ROOT-based applications.; Many different examples of JSROOT API usage can be found on JSROOT API examples page.; 1.11.1 Import JSROOT functionality; Major JSROOT functions are located in main.mjs module and can be imported like:; <script type='module'>; import { openFile, draw } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = """,MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:26030,Availability,failure,failure,26030,"jsroot.js""></script>; <script>; // getting json string from somewhere; let obj = JSROOT.parse(root_json);; JSROOT.draw('plain', obj, 'colz');; </script>; 1.11.2 Use of JSON; It is strongly recommended to use JSON when communicating with ROOT application. THttpServer provides a JSON representation for every registered object with an url address like:; http://your_root_server:8080/Canvases/c1/root.json; Such JSON representation generated using the TBufferJSON class. One could create JSON file for any ROOT object directly, just writing in the code:; obj->SaveAs(""file.json"");; To access data from a remote web server, it is recommended to use the httpRequest method. For instance to receive object from a THttpServer server one could do:; import { httpRequest } from 'https://root.cern/js/latest/modules/main.mjs';; let obj = await httpRequest(""http://your_root_server:8080/Canvases/c1/root.json"", ""object""); console.log('Read object of type', obj._typename);; Function returns Promise, which provides parsed object (or Error in case of failure).; If JSON string was obtained by different method, it could be parsed with parse function:; import { parse } from 'https://root.cern/js/latest/modules/main.mjs';; let obj = parse(json_string);; 1.11.3 Objects drawing; After an object has been created, one can directly draw it. If HTML page has <div> element:; <div id=""drawing""></div>; One could use the draw function:; import { draw } from 'https://root.cern/js/latest/modules/main.mjs';; draw(""drawing"", obj, ""colz"");; The first argument is the id of the HTML div element, where drawing will be performed. The second argument is the object to draw and the third one is the drawing option.; Here is complete running example ans source code:; import { httpRequest, draw, redraw, resize, cleanup } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/th2ul.json.gz"";; let obj = await httpRequest(filename, 'object');; draw(""drawing"", obj, ""lego"");; In very ",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:34852,Availability,avail,available,34852,"re.ComponentContainer({ name : ""NavExample"" })]; }); ]; }).placeAt(""content"");; </script>; JSROOT uses https://openui5.hana.ondemand.com/1.128.0/ when no other source is specified.; There are small details when using OpenUI5 with THttpServer. First of all, location of JSROOT modules should be specified as /jsrootsys/modules/main.mjs. And then trying to access files from local disk, one should specify /currentdir/ folder:; jQuery.sap.registerModulePath(""NavExample"", ""/currentdir/"");; JSROOT provides example showing usage of JSROOT drawing in the OpenUI5, source code can be found in repository.; 1.11.10 Migration v6 -> v7. Core functionality should be imported from main.mjs module like:. import { create, parse, createHistogram, redraw } from 'https://root.cern/js/7.0.0/modules/main.mjs';. It is still possible to use JSRoot.core.js script, which provides very similar (but not identical!) functionality as with v6 via global JSROOT object; JSROOT.define() and JSROOT.require() functions only available after JSRoot.core.js loading; Support of require.js and openui5 loaders was removed; Global hierarchy painter JSROOT.hpainter no longer existing, one can use getHPainter function:. import { getHPainter } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let hpainter = getHPainter();. All math functions previously available via JSROOT.Math should be imported from base/math.mjs module:. import * as math from 'https://root.cern/js/7.0.0/modules/base/math.mjs';. Indication of batch mode JSROOT.batch_mode should be accessed via functions:. import { isBatchMode, setBatchMode } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let was_batch = isBatchMode();; if (!was_batch) setBatchMode(true);. JSROOT.extend() function was removed, use Object.assign() instead. 1.11.11 Migration v5 -> v6. Main script was renamed to JSRoot.core.js. Old JSRootCore.js was deprecated and removed in v6.2. All URL parameters for main script ignored now, to load JSROOT functionality one should use JS",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:35180,Availability,avail,available,35180,"s/main.mjs. And then trying to access files from local disk, one should specify /currentdir/ folder:; jQuery.sap.registerModulePath(""NavExample"", ""/currentdir/"");; JSROOT provides example showing usage of JSROOT drawing in the OpenUI5, source code can be found in repository.; 1.11.10 Migration v6 -> v7. Core functionality should be imported from main.mjs module like:. import { create, parse, createHistogram, redraw } from 'https://root.cern/js/7.0.0/modules/main.mjs';. It is still possible to use JSRoot.core.js script, which provides very similar (but not identical!) functionality as with v6 via global JSROOT object; JSROOT.define() and JSROOT.require() functions only available after JSRoot.core.js loading; Support of require.js and openui5 loaders was removed; Global hierarchy painter JSROOT.hpainter no longer existing, one can use getHPainter function:. import { getHPainter } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let hpainter = getHPainter();. All math functions previously available via JSROOT.Math should be imported from base/math.mjs module:. import * as math from 'https://root.cern/js/7.0.0/modules/base/math.mjs';. Indication of batch mode JSROOT.batch_mode should be accessed via functions:. import { isBatchMode, setBatchMode } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let was_batch = isBatchMode();; if (!was_batch) setBatchMode(true);. JSROOT.extend() function was removed, use Object.assign() instead. 1.11.11 Migration v5 -> v6. Main script was renamed to JSRoot.core.js. Old JSRootCore.js was deprecated and removed in v6.2. All URL parameters for main script ignored now, to load JSROOT functionality one should use JSROOT.require function. To create standard GUI, JSROOT.buildGUI function has to be used.; Instead of JSROOT.JSONR_unref() one can use JSROOT.parse(). If object is provided to JSROOT.parse() it just replaces all references which were introduced by TBufferJSON::ToJSON() method.; Instead of JSROOT.console() one should use cons",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:36235,Availability,error,error,36235," require.js and openui5 loaders was removed; Global hierarchy painter JSROOT.hpainter no longer existing, one can use getHPainter function:. import { getHPainter } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let hpainter = getHPainter();. All math functions previously available via JSROOT.Math should be imported from base/math.mjs module:. import * as math from 'https://root.cern/js/7.0.0/modules/base/math.mjs';. Indication of batch mode JSROOT.batch_mode should be accessed via functions:. import { isBatchMode, setBatchMode } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let was_batch = isBatchMode();; if (!was_batch) setBatchMode(true);. JSROOT.extend() function was removed, use Object.assign() instead. 1.11.11 Migration v5 -> v6. Main script was renamed to JSRoot.core.js. Old JSRootCore.js was deprecated and removed in v6.2. All URL parameters for main script ignored now, to load JSROOT functionality one should use JSROOT.require function. To create standard GUI, JSROOT.buildGUI function has to be used.; Instead of JSROOT.JSONR_unref() one can use JSROOT.parse(). If object is provided to JSROOT.parse() it just replaces all references which were introduced by TBufferJSON::ToJSON() method.; Instead of JSROOT.console() one should use console.log(). Instead of JSROOT.alert() one should use console.error().; Many settings were moved from JSROOT.gStyle to JSROOT.settings object. It was done to keep only TStyle-related members in JSROOT.gStyle.; Basic painter classes were renamed and made public:. JSROOT.TBasePainter -> JSROOT.BasePainter; JSROOT.TObjectPainter -> JSROOT.ObjectPainter. Internal ObjectPainter.DrawingReady api was deprecated. Draw function has to return Promise if object drawing postponed. As argument of returned promise object painter has to be used.; Many function names where adjusted to naming conventions. Like:. JSROOT.CreateHistogram -> JSROOT.createHistogram; JSROOT.CreateTGraph -> JSROOT.createTGraph; JSROOT.Create -> JSROOT.create. ",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:733,Deployability,install,install,733,". JavaScript ROOT. JavaScript ROOT; Sergey Linev. JavaScript ROOT; 1 JavaScript ROOT; 1.1 Installing JSROOT; 1.2 Drawing objects in JSROOT; 1.3 Supported ROOT classes by JSROOT; 1.4 Superimposing draw objects; 1.5 TTree draw; 1.6 Geometry viewer; 1.7 Reading ROOT files from other servers; 1.8 Reading local ROOT files; 1.9 JSROOT with THttpServer; 1.10 Data monitoring with JSROOT; 1.11 JSROOT API. JavaScript ROOT; *** Sergey Linev GSI, Darmstadt ***; 1 JavaScript ROOT; The JSROOT project allows: - reading of binary and JSON ROOT files in JavaScript; - drawing of different ROOT classes in web browsers; - reading and drawing TTree data; - using in node.js.; 1.1 Installing JSROOT; In most practical cases it is not necessary to install JSROOT - it can be used directly from project web sites https://root.cern/js/ and https://jsroot.gsi.de/.; When required, there are following alternatives to install JSROOT on other web servers:. download and unpack provided packages (recommended); use npm package manager and invoke npm install jsroot; clone master branch from repository. 1.2 Drawing objects in JSROOT; The main page of the JSROOT project provides the possibility to interactively open ROOT files and draw objects like histogram or canvas.; To automate files loading and objects drawing, one can provide number of URL parameters in address string like:. file - name of the file, which will be automatically open with page loading; files - array of file names for loading; json - name of JSON file with stored ROOT object like histogram or canvas; item - item name to be displayed; opt - drawing option for the item; items - array of items name to be displayed; opts - array of drawing options for the items; expand - item name(s) to be expanded in the hierarchy browser; focus - item name to be focused on in the hierarchy browser; title - set browser title; dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; layout - can be ‘simple’, ‘flex",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:899,Deployability,install,install,899,". JavaScript ROOT. JavaScript ROOT; Sergey Linev. JavaScript ROOT; 1 JavaScript ROOT; 1.1 Installing JSROOT; 1.2 Drawing objects in JSROOT; 1.3 Supported ROOT classes by JSROOT; 1.4 Superimposing draw objects; 1.5 TTree draw; 1.6 Geometry viewer; 1.7 Reading ROOT files from other servers; 1.8 Reading local ROOT files; 1.9 JSROOT with THttpServer; 1.10 Data monitoring with JSROOT; 1.11 JSROOT API. JavaScript ROOT; *** Sergey Linev GSI, Darmstadt ***; 1 JavaScript ROOT; The JSROOT project allows: - reading of binary and JSON ROOT files in JavaScript; - drawing of different ROOT classes in web browsers; - reading and drawing TTree data; - using in node.js.; 1.1 Installing JSROOT; In most practical cases it is not necessary to install JSROOT - it can be used directly from project web sites https://root.cern/js/ and https://jsroot.gsi.de/.; When required, there are following alternatives to install JSROOT on other web servers:. download and unpack provided packages (recommended); use npm package manager and invoke npm install jsroot; clone master branch from repository. 1.2 Drawing objects in JSROOT; The main page of the JSROOT project provides the possibility to interactively open ROOT files and draw objects like histogram or canvas.; To automate files loading and objects drawing, one can provide number of URL parameters in address string like:. file - name of the file, which will be automatically open with page loading; files - array of file names for loading; json - name of JSON file with stored ROOT object like histogram or canvas; item - item name to be displayed; opt - drawing option for the item; items - array of items name to be displayed; opts - array of drawing options for the items; expand - item name(s) to be expanded in the hierarchy browser; focus - item name to be focused on in the hierarchy browser; title - set browser title; dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; layout - can be ‘simple’, ‘flex",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:1029,Deployability,install,install,1029,"ript ROOT. JavaScript ROOT; Sergey Linev. JavaScript ROOT; 1 JavaScript ROOT; 1.1 Installing JSROOT; 1.2 Drawing objects in JSROOT; 1.3 Supported ROOT classes by JSROOT; 1.4 Superimposing draw objects; 1.5 TTree draw; 1.6 Geometry viewer; 1.7 Reading ROOT files from other servers; 1.8 Reading local ROOT files; 1.9 JSROOT with THttpServer; 1.10 Data monitoring with JSROOT; 1.11 JSROOT API. JavaScript ROOT; *** Sergey Linev GSI, Darmstadt ***; 1 JavaScript ROOT; The JSROOT project allows: - reading of binary and JSON ROOT files in JavaScript; - drawing of different ROOT classes in web browsers; - reading and drawing TTree data; - using in node.js.; 1.1 Installing JSROOT; In most practical cases it is not necessary to install JSROOT - it can be used directly from project web sites https://root.cern/js/ and https://jsroot.gsi.de/.; When required, there are following alternatives to install JSROOT on other web servers:. download and unpack provided packages (recommended); use npm package manager and invoke npm install jsroot; clone master branch from repository. 1.2 Drawing objects in JSROOT; The main page of the JSROOT project provides the possibility to interactively open ROOT files and draw objects like histogram or canvas.; To automate files loading and objects drawing, one can provide number of URL parameters in address string like:. file - name of the file, which will be automatically open with page loading; files - array of file names for loading; json - name of JSON file with stored ROOT object like histogram or canvas; item - item name to be displayed; opt - drawing option for the item; items - array of items name to be displayed; opts - array of drawing options for the items; expand - item name(s) to be expanded in the hierarchy browser; focus - item name to be focused on in the hierarchy browser; title - set browser title; dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; layout - can be ‘simple’, ‘flex’, ‘tabs",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:5447,Deployability,integrat,integrate,5447,"bs - tabs for each object drawing; gridNxM - fixed-size grid with NxM frames; vertN - N frames sorted in vertical direction (like gridi1xN); horizN - N frames sorted in horizontal direction (like gridiNx1); vert121 - 3 frames sorted in vertical direction, second frame divided on two sub-frames; horiz32_12 - 2 horizontal frames with 3 and 2 subframes, and 1/3 and 2/3 as relative size. When specifying files, items or opts parameters, array of strings could be provided like files=['file1.root','file2.root']. One could skip quotes when specifying elements names items=[file1.root/hpx,file2.root/hpy] or opts=['',colz].; As item name, URL to existing image can be provided like item=img:http://server/image.png. Such image will be just inserted in the existing layout. One could specify option ""scale"" to automatically scale image to available space.; Many examples of URL string usage can be found on JSROOT API examples page.; One can very easy integrate JSROOT graphic into arbitrary HTML pages using a iframe tag:; <iframe width=""700"" height=""400""; src=""https://root.cern/js/latest/?nobrowser&file=https://root.cern/js/files/hsimple.root&item=hpxpy&opt=colz"">; </iframe>; 1.3 Supported ROOT classes by JSROOT; List of supported classes and draw options:. TH1 : hist, p, p0, *, l, lf2, a, e, e0, e1, e1x0, e3, e4, lego, text, X+Y+; TH2 : scat, col, colz, box, box1, text, lego, arr, cont, cont1, cont2, cont3, cont4, surf, surf1, surf2, surf3, surf4, surf6, surf7, lego, lego0, lego1, lego2, lego3, lego4; TH2Poly : col, lego, europe, usa; TH3 : scat, box, box1; TProfile : dflt, e, e1, pe2, hist, text, texte; TProfile2D : example; THStack : example; TF1 : example; TF2 : example; TSpline : example; TGraph : dflt, L, P, *, B, RX, RY; TGraphErrors : dflt, l, lx, z, >, |>, ||, [], 0, 2, 3, 4, 5; TGraphAsymmErrors : dflt,; TGraphMultiErrors : docu, z and other from TGraphErrors; TGraphPolar : example; TMultiGraph : example, exclusion; TGraph2D : example; TEfficiency : docu; TLatex : example; ",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:12563,Deployability,configurat,configuration,12563,"mes as usual (normally ~10000 nodes and ~200000 elementary faces are shown) - all - try to display all geometry volumes (may lead to browser hanging) - maxnodesN - configure maximal number of rendered nodes (like maxnodes100K) - maxfacesN - configure maximal number of rendered faces (like maxfaces3M) - highlight - force highlighting of selected volume, normally activated for moderate-size geometries - nohighlight - disable volumes highlighting (can be activated via context menu) - hscene - enable highlight of extra objects like tracks or hits - hsceneonly - enable only highlight of extra objects like tracks or hits - nohscene - disable highlight of extra objects like tracks or hits - macro:name.C - invoke ROOT configuration macro - dflt - set default volumes colors as TGeoManager::DefaultColors() does - transpXY - set global transparency value (XY is number between 1 and 99) - zoomFACTOR - set initial zoom factor (FACTOR is integer value from 1 to 10000, default is 100) - rotyANGLE - set Y rotation angle in degrees (like roty10) - rotzANGLE - set Z rotation angle in degrees (like rotz20) - rotate - enable automatic rotation of the geometry - trzVALUE - set transformation along Z axis (like trz50) - trrVALUE - set radial transformation (like trr100) - ortho_camera - use THREE.OrthographicCamera without possibility to rotate it - ortho_camera_rotate - use THREE.OrthographicCamera and enable it rotation - ctrl - show control UI from the beginning - tracks - show tracks from TGeoManager - showtop - show top-level volume of TGeoManager (default off) - no_screen - let ignore kVisOnScreen bits for nodes visibility - dray - calculate rendering order using raytracing (extensive calculations) - dbox - use distance to nearest point from bounding box for rendering order (default) - dpnt - use distance to shape center as rendering order - dsize - use volume size as rendering order - ddflt - let three.js to calculate rendering order - comp - show left and right components of TGeo",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:17625,Deployability,install,install,17625,"ers; In principle, one could open any ROOT file placed in the web, providing the full URL to it like:. https://jsroot.gsi.de/latest/?file=https://root.cern/js/files/hsimple.root&item=hpx. But one should be aware of Same-origin policy, when the browser blocks requests to files from domains other than current web page. To enable CORS on Apache web server, hosting ROOT files, one should add following lines to .htaccess file:; <IfModule mod_headers.c>; <FilesMatch ""\.root"">; Header set Access-Control-Allow-Origin ""*""; Header set Access-Control-Allow-Headers ""range""; Header set Access-Control-Expose-Headers ""content-range,content-length,accept-ranges""; Header set Access-Control-Allow-Methods ""GET""; </FilesMatch>; </IfModule>; More details about configuring of CORS headers can be found here.; Alternative - enable CORS requests in the browser. It can be easily done with CORS Everywhere plugin for the Firefox browser or Allow CORS plugin for the Chrome browser.; Next solution - install JSROOT on the server hosting ROOT files. In such configuration JSROOT does not issue CORS requests, therefore server and browsers can be used with their default settings. A simplified variant of such solution - copy only the top index.htm file from JSROOT package and specify the full path to modules/gui.mjs script like:; <script type=""module"">; import { openFile, draw } from 'https://root.cern/js/latest/modules/gui.mjs';; // ...; </script>; In the main <div> element one can specify many custom parameters like one do it in URL string:; <div id=""simpleGUI"" path=""files/path"" files=""userfile1.root;subdir/usefile2.root"">; loading scripts ...; </div>; 1.8 Reading local ROOT files; JSROOT can read files from local file system using HTML5 FileReader functionality. Main limitation here - user should interactively select files for reading. There is button “…” on the main JSROOT page, which starts file selection dialog. If valid ROOT file is selected, JSROOT will be able to normally read content of such",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:17682,Deployability,configurat,configuration,17682,"ke:. https://jsroot.gsi.de/latest/?file=https://root.cern/js/files/hsimple.root&item=hpx. But one should be aware of Same-origin policy, when the browser blocks requests to files from domains other than current web page. To enable CORS on Apache web server, hosting ROOT files, one should add following lines to .htaccess file:; <IfModule mod_headers.c>; <FilesMatch ""\.root"">; Header set Access-Control-Allow-Origin ""*""; Header set Access-Control-Allow-Headers ""range""; Header set Access-Control-Expose-Headers ""content-range,content-length,accept-ranges""; Header set Access-Control-Allow-Methods ""GET""; </FilesMatch>; </IfModule>; More details about configuring of CORS headers can be found here.; Alternative - enable CORS requests in the browser. It can be easily done with CORS Everywhere plugin for the Firefox browser or Allow CORS plugin for the Chrome browser.; Next solution - install JSROOT on the server hosting ROOT files. In such configuration JSROOT does not issue CORS requests, therefore server and browsers can be used with their default settings. A simplified variant of such solution - copy only the top index.htm file from JSROOT package and specify the full path to modules/gui.mjs script like:; <script type=""module"">; import { openFile, draw } from 'https://root.cern/js/latest/modules/gui.mjs';; // ...; </script>; In the main <div> element one can specify many custom parameters like one do it in URL string:; <div id=""simpleGUI"" path=""files/path"" files=""userfile1.root;subdir/usefile2.root"">; loading scripts ...; </div>; 1.8 Reading local ROOT files; JSROOT can read files from local file system using HTML5 FileReader functionality. Main limitation here - user should interactively select files for reading. There is button “…” on the main JSROOT page, which starts file selection dialog. If valid ROOT file is selected, JSROOT will be able to normally read content of such file.; 1.9 JSROOT with THttpServer; THttpServer provides http access to objects from running ROOT",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:19827,Deployability,update,update,19827,"; The layout of the main page coming from THttpServer is very similar to normal JSROOT page. One could browse existing items and display them. A snapshot of running server can be seen on the demo page.; One could also specify similar URL parameters to configure the displayed items and drawing options.; It is also possible to display one single item from the THttpServer server like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz; 1.10 Data monitoring with JSROOT; 1.10.1 Monitoring with http server; The best possibility to organize the monitoring of data from a running application is to use THttpServer. In such case the client can always access the latest changes and request only the items currently displayed in the browser. To enable monitoring, one should activate the appropriate checkbox or provide monitoring parameter in the URL string like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hprof/draw.htm?monitoring=1000; The parameter value is the update interval in milliseconds.; 1.10.2 JSON file-based monitoring; Solid file-based monitoring (without integration of THttpServer into application) can be implemented in JSON format. There is the TBufferJSON class, which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing such functionality: https://root.cern/js/latest/demo/update_draw.htm. This demo page reads in cycle 20 json files and displays them.; If one has a web server which already provides such JSON file, one could specify the URL to this file like:; https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz; Here the same problem with Cross-Origin Request can appear. If the web server configurat",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:19933,Deployability,integrat,integration,19933,"tems and display them. A snapshot of running server can be seen on the demo page.; One could also specify similar URL parameters to configure the displayed items and drawing options.; It is also possible to display one single item from the THttpServer server like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz; 1.10 Data monitoring with JSROOT; 1.10.1 Monitoring with http server; The best possibility to organize the monitoring of data from a running application is to use THttpServer. In such case the client can always access the latest changes and request only the items currently displayed in the browser. To enable monitoring, one should activate the appropriate checkbox or provide monitoring parameter in the URL string like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hprof/draw.htm?monitoring=1000; The parameter value is the update interval in milliseconds.; 1.10.2 JSON file-based monitoring; Solid file-based monitoring (without integration of THttpServer into application) can be implemented in JSON format. There is the TBufferJSON class, which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing such functionality: https://root.cern/js/latest/demo/update_draw.htm. This demo page reads in cycle 20 json files and displays them.; If one has a web server which already provides such JSON file, one could specify the URL to this file like:; https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz; Here the same problem with Cross-Origin Request can appear. If the web server configuration cannot be changed, just copy JSROOT to the web server itself.; 1.10.3 Binary file-based monitoring (not recommended)",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:20809,Deployability,configurat,configuration,20809,"erval in milliseconds.; 1.10.2 JSON file-based monitoring; Solid file-based monitoring (without integration of THttpServer into application) can be implemented in JSON format. There is the TBufferJSON class, which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing such functionality: https://root.cern/js/latest/demo/update_draw.htm. This demo page reads in cycle 20 json files and displays them.; If one has a web server which already provides such JSON file, one could specify the URL to this file like:; https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz; Here the same problem with Cross-Origin Request can appear. If the web server configuration cannot be changed, just copy JSROOT to the web server itself.; 1.10.3 Binary file-based monitoring (not recommended); Theoretically, one could use binary ROOT files to implement monitoring. With such approach, a ROOT-based application creates and regularly updates content of a ROOT file, which can be accessed via normal web server. From the browser side, JSROOT could regularly read the specified objects and update their drawings. But such solution has three major caveats.; First of all, one need to store the data of all objects, which only potentially could be displayed in the browser. In case of 10 objects it does not matter, but for 1000 or 100000 objects this will be a major performance penalty. With such big amount of data one will never achieve higher update rate.; The second problem is I/O. To read the first object from the ROOT file, one need to perform several (about 5) file-reading operations via http protocol. There is no http file locking mechanism (at least not for standard web servers),",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:21080,Deployability,update,updates,21080," TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing such functionality: https://root.cern/js/latest/demo/update_draw.htm. This demo page reads in cycle 20 json files and displays them.; If one has a web server which already provides such JSON file, one could specify the URL to this file like:; https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz; Here the same problem with Cross-Origin Request can appear. If the web server configuration cannot be changed, just copy JSROOT to the web server itself.; 1.10.3 Binary file-based monitoring (not recommended); Theoretically, one could use binary ROOT files to implement monitoring. With such approach, a ROOT-based application creates and regularly updates content of a ROOT file, which can be accessed via normal web server. From the browser side, JSROOT could regularly read the specified objects and update their drawings. But such solution has three major caveats.; First of all, one need to store the data of all objects, which only potentially could be displayed in the browser. In case of 10 objects it does not matter, but for 1000 or 100000 objects this will be a major performance penalty. With such big amount of data one will never achieve higher update rate.; The second problem is I/O. To read the first object from the ROOT file, one need to perform several (about 5) file-reading operations via http protocol. There is no http file locking mechanism (at least not for standard web servers), therefore there is no guarantee that the file content is not changed/replaced between consequent read operations. Therefore, one should expect frequent I/O failures while trying to monitor data from ROOT binary files. There is a workaround for th",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:21234,Deployability,update,update,21234," such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing such functionality: https://root.cern/js/latest/demo/update_draw.htm. This demo page reads in cycle 20 json files and displays them.; If one has a web server which already provides such JSON file, one could specify the URL to this file like:; https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz; Here the same problem with Cross-Origin Request can appear. If the web server configuration cannot be changed, just copy JSROOT to the web server itself.; 1.10.3 Binary file-based monitoring (not recommended); Theoretically, one could use binary ROOT files to implement monitoring. With such approach, a ROOT-based application creates and regularly updates content of a ROOT file, which can be accessed via normal web server. From the browser side, JSROOT could regularly read the specified objects and update their drawings. But such solution has three major caveats.; First of all, one need to store the data of all objects, which only potentially could be displayed in the browser. In case of 10 objects it does not matter, but for 1000 or 100000 objects this will be a major performance penalty. With such big amount of data one will never achieve higher update rate.; The second problem is I/O. To read the first object from the ROOT file, one need to perform several (about 5) file-reading operations via http protocol. There is no http file locking mechanism (at least not for standard web servers), therefore there is no guarantee that the file content is not changed/replaced between consequent read operations. Therefore, one should expect frequent I/O failures while trying to monitor data from ROOT binary files. There is a workaround for the problem - one could load the file completely and exclude many partial I/O operations by this. To achieve this with JSROO",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:21590,Deployability,update,update,21590,"ovides such JSON file, one could specify the URL to this file like:; https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz; Here the same problem with Cross-Origin Request can appear. If the web server configuration cannot be changed, just copy JSROOT to the web server itself.; 1.10.3 Binary file-based monitoring (not recommended); Theoretically, one could use binary ROOT files to implement monitoring. With such approach, a ROOT-based application creates and regularly updates content of a ROOT file, which can be accessed via normal web server. From the browser side, JSROOT could regularly read the specified objects and update their drawings. But such solution has three major caveats.; First of all, one need to store the data of all objects, which only potentially could be displayed in the browser. In case of 10 objects it does not matter, but for 1000 or 100000 objects this will be a major performance penalty. With such big amount of data one will never achieve higher update rate.; The second problem is I/O. To read the first object from the ROOT file, one need to perform several (about 5) file-reading operations via http protocol. There is no http file locking mechanism (at least not for standard web servers), therefore there is no guarantee that the file content is not changed/replaced between consequent read operations. Therefore, one should expect frequent I/O failures while trying to monitor data from ROOT binary files. There is a workaround for the problem - one could load the file completely and exclude many partial I/O operations by this. To achieve this with JSROOT, one should add “+” sign at the end of the file name. Of course, it only could work for small files.; If somebody still wants to use monitoring of data from ROOT files, could try link like:. https://root.cern/js/latest/?nobrowser&file=../files/hsimple.root+&item=hpx;1&monitoring=2000. In this particular case, the histogram is not changing.; 1.11 JSROOT API",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:23261,Deployability,install,install,23261,", it only could work for small files.; If somebody still wants to use monitoring of data from ROOT files, could try link like:. https://root.cern/js/latest/?nobrowser&file=../files/hsimple.root+&item=hpx;1&monitoring=2000. In this particular case, the histogram is not changing.; 1.11 JSROOT API; JSROOT can be used in arbitrary HTML pages to display data, produced with or without ROOT-based applications.; Many different examples of JSROOT API usage can be found on JSROOT API examples page.; 1.11.1 Import JSROOT functionality; Major JSROOT functions are located in main.mjs module and can be imported like:; <script type='module'>; import { openFile, draw } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/hsimple.root"";; let file = await openFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; </script>; Here the default location https://root.cern/js/latest/ is specified. One always can install JSROOT on private web server. When JSROOT is used with THttpServer, the address looks like:; <script type='module'>; import { httpRequest, draw } from 'http://your_root_server:8080/jsrootsys/modules/main.mjs';; let obj = await httpRequest('http://your_root_server:8080/Objects/hist/root.json','object');; await draw('drawing', obj, 'hist');; </script>; Loading main module is enough to get public JSROOT functionality - reading files and drawing objects. One also can load some special components directly like:; <script type='module'>; import { HierarchyPainter } from 'https://root.cern/js/latest/modules/gui.mjs';. let h = new HierarchyPainter(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; After script loading one can configure different paramet",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:27254,Deployability,update,update,27254," element:; <div id=""drawing""></div>; One could use the draw function:; import { draw } from 'https://root.cern/js/latest/modules/main.mjs';; draw(""drawing"", obj, ""colz"");; The first argument is the id of the HTML div element, where drawing will be performed. The second argument is the object to draw and the third one is the drawing option.; Here is complete running example ans source code:; import { httpRequest, draw, redraw, resize, cleanup } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/th2ul.json.gz"";; let obj = await httpRequest(filename, 'object');; draw(""drawing"", obj, ""lego"");; In very seldom cases one need to access painter object, created in draw() function. This can be done via handling Promise results like:; let painter = await draw(""drawing"", obj, ""colz"");; console.log('Object type in painter', painter.getClassName());; One is also able to update the drawing with a new version of the object:; // after some interval request object again; redraw(""drawing"", obj2, ""colz"");; The redraw function will call draw if the drawing was not performed before.; In the case when changing of HTML layout leads to resize of element with JSROOT drawing, one should call resize() to let JSROOT adjust drawing size. One should do:; resize(""drawing"");; As second argument one could specify exact size for draw elements like:; resize(""drawing"", { width: 500, height: 200 });; To correctly cleanup JSROOT drawings from HTML element, one should call:; cleanup(""drawing"");; 1.11.4 File API; JSROOT defines the TFile class, which can be used to access binary ROOT files. One should always remember that all I/O operations are asynchronous in JSROOT. Therefore promises are used to retrieve results when the I/O operation is completed. For example, reading an object from a file and displaying it will look like:; import { openFile, draw } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/hsimple.root",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:31951,Deployability,install,install,31951,"r of meshes in three.js model (default 1000); doubleside - use double-side material (default only front side is set); wireframe - show wireframe for created object (default - off); dflt_colors - assign default ROOT colors for the volumes. When transparent volumes appeared in the model, one could use produceRenderOrder() function to correctly set rendering order. It should be used as:; import { produceRenderOrder } from './path_to_jsroot/modules/geom/TGeoPainter.mjs';; produceRenderOrder(scene, camera.position, 'box');; Following methods can be applied: “box”, “pnt”, “size”, “ray” and “dflt”. See more info in draw options description for TGeo classes.; Here is running example and source code.; 1.11.7 Custom user class; There is code example how custom user class can be implemented. It shows usage of different draw options for the class and ability to access sub-elements of the object using specialized expand function.; 1.11.8 Use with Node.js; To install latest JSROOT release, just do:; [shell] npm install jsroot; To use in the Node.js scripts, one should add following line:; import { httpRequest, makeSVG } from 'jsroot';; Using JSROOT functionality, one can open binary ROOT files (local and remote), parse ROOT JSON, create SVG output. For example, to create SVG image with lego plot, one should do:; import { openFile, makeSVG } from 'jsroot';; import { writeFileSync } from 'fs';. let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let obj = await file.readObject(""hpx;1"");; let svg = await makeSVG({ object: obj, option: ""lego2"", width: 1200, height: 800 });; writeFileSync(""lego2.svg"", svg);; It is also possible to convert any JavaScript object into ROOT JSON string, using toJSON() function. Like:; import { toJSON, openFile, makeSVG } from 'jsroot';; import { writeFileSync } from 'fs';. let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let obj = await file.readObject(""hpx;1"");; let json = await toJSON(obj);; writrFileSync(""hpxpy.j",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:31973,Deployability,release,release,31973,"r of meshes in three.js model (default 1000); doubleside - use double-side material (default only front side is set); wireframe - show wireframe for created object (default - off); dflt_colors - assign default ROOT colors for the volumes. When transparent volumes appeared in the model, one could use produceRenderOrder() function to correctly set rendering order. It should be used as:; import { produceRenderOrder } from './path_to_jsroot/modules/geom/TGeoPainter.mjs';; produceRenderOrder(scene, camera.position, 'box');; Following methods can be applied: “box”, “pnt”, “size”, “ray” and “dflt”. See more info in draw options description for TGeo classes.; Here is running example and source code.; 1.11.7 Custom user class; There is code example how custom user class can be implemented. It shows usage of different draw options for the class and ability to access sub-elements of the object using specialized expand function.; 1.11.8 Use with Node.js; To install latest JSROOT release, just do:; [shell] npm install jsroot; To use in the Node.js scripts, one should add following line:; import { httpRequest, makeSVG } from 'jsroot';; Using JSROOT functionality, one can open binary ROOT files (local and remote), parse ROOT JSON, create SVG output. For example, to create SVG image with lego plot, one should do:; import { openFile, makeSVG } from 'jsroot';; import { writeFileSync } from 'fs';. let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let obj = await file.readObject(""hpx;1"");; let svg = await makeSVG({ object: obj, option: ""lego2"", width: 1200, height: 800 });; writeFileSync(""lego2.svg"", svg);; It is also possible to convert any JavaScript object into ROOT JSON string, using toJSON() function. Like:; import { toJSON, openFile, makeSVG } from 'jsroot';; import { writeFileSync } from 'fs';. let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let obj = await file.readObject(""hpx;1"");; let json = await toJSON(obj);; writrFileSync(""hpxpy.j",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:32004,Deployability,install,install,32004,"r of meshes in three.js model (default 1000); doubleside - use double-side material (default only front side is set); wireframe - show wireframe for created object (default - off); dflt_colors - assign default ROOT colors for the volumes. When transparent volumes appeared in the model, one could use produceRenderOrder() function to correctly set rendering order. It should be used as:; import { produceRenderOrder } from './path_to_jsroot/modules/geom/TGeoPainter.mjs';; produceRenderOrder(scene, camera.position, 'box');; Following methods can be applied: “box”, “pnt”, “size”, “ray” and “dflt”. See more info in draw options description for TGeo classes.; Here is running example and source code.; 1.11.7 Custom user class; There is code example how custom user class can be implemented. It shows usage of different draw options for the class and ability to access sub-elements of the object using specialized expand function.; 1.11.8 Use with Node.js; To install latest JSROOT release, just do:; [shell] npm install jsroot; To use in the Node.js scripts, one should add following line:; import { httpRequest, makeSVG } from 'jsroot';; Using JSROOT functionality, one can open binary ROOT files (local and remote), parse ROOT JSON, create SVG output. For example, to create SVG image with lego plot, one should do:; import { openFile, makeSVG } from 'jsroot';; import { writeFileSync } from 'fs';. let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let obj = await file.readObject(""hpx;1"");; let svg = await makeSVG({ object: obj, option: ""lego2"", width: 1200, height: 800 });; writeFileSync(""lego2.svg"", svg);; It is also possible to convert any JavaScript object into ROOT JSON string, using toJSON() function. Like:; import { toJSON, openFile, makeSVG } from 'jsroot';; import { writeFileSync } from 'fs';. let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let obj = await file.readObject(""hpx;1"");; let json = await toJSON(obj);; writrFileSync(""hpxpy.j",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:359,Energy Efficiency,monitor,monitoring,359,". JavaScript ROOT. JavaScript ROOT; Sergey Linev. JavaScript ROOT; 1 JavaScript ROOT; 1.1 Installing JSROOT; 1.2 Drawing objects in JSROOT; 1.3 Supported ROOT classes by JSROOT; 1.4 Superimposing draw objects; 1.5 TTree draw; 1.6 Geometry viewer; 1.7 Reading ROOT files from other servers; 1.8 Reading local ROOT files; 1.9 JSROOT with THttpServer; 1.10 Data monitoring with JSROOT; 1.11 JSROOT API. JavaScript ROOT; *** Sergey Linev GSI, Darmstadt ***; 1 JavaScript ROOT; The JSROOT project allows: - reading of binary and JSON ROOT files in JavaScript; - drawing of different ROOT classes in web browsers; - reading and drawing TTree data; - using in node.js.; 1.1 Installing JSROOT; In most practical cases it is not necessary to install JSROOT - it can be used directly from project web sites https://root.cern/js/ and https://jsroot.gsi.de/.; When required, there are following alternatives to install JSROOT on other web servers:. download and unpack provided packages (recommended); use npm package manager and invoke npm install jsroot; clone master branch from repository. 1.2 Drawing objects in JSROOT; The main page of the JSROOT project provides the possibility to interactively open ROOT files and draw objects like histogram or canvas.; To automate files loading and objects drawing, one can provide number of URL parameters in address string like:. file - name of the file, which will be automatically open with page loading; files - array of file names for loading; json - name of JSON file with stored ROOT object like histogram or canvas; item - item name to be displayed; opt - drawing option for the item; items - array of items name to be displayed; opts - array of drawing options for the items; expand - item name(s) to be expanded in the hierarchy browser; focus - item name to be focused on in the hierarchy browser; title - set browser title; dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; layout - can be ‘simple’, ‘flex",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:10496,Energy Efficiency,monitor,monitor,10496,"laced into brackets):. opt=px:py::(pz>5?2:1). It is possible to “dump” content of any branch (by default - first 10 entries):. item=ntuple/px&opt=dump. Or one could dump values produced with draw expression (also first 10 entries by default):. opt=px:py::pz>>dump. Working with array indexes is supported. By default, all elements in array are used for the drawing. One could specify index for any array dimension (-1 means last element in the array). For instance, dump last element from event.fTracks array:. opt=event.fTracks[-1].fBits>>dump. For any array or collection kind one could extract its size with expression:. opt=event.fTracks.@size. At the end of expression one can add several parameters with the syntax:; <draw_expession>;par1name:par1value;par2name:par2value; Following parameters are supported: - “first” - id of the first entry to process - “entries” - number of entries to process - “monitor” - periodically show intermediate draw results (interval in milliseconds) - “maxrange” - maximal number of ranges in single HTTP request - “accum” - number of accumulated values before creating histogram - “htype” - last letter in histogram type like “I”, “F”, “D”, “S”, “L”, “C” - “hbins” - number of bins on each histogram axis - “drawopt” - drawing option for produced histogram - “graph” - draw into TGraph object; Example - opt=event.fTracks[].fTriggerBits;entries:1000;first:200;maxrange:25; 1.6 Geometry viewer; JSROOT implements display of TGeo objects like:. file=rootgeom.root&item=simple1; file=building.root&item=geom&opt=z. Following classes are supported by geometry viewer: - TGeoVolume - TGeoNode - TGeoManager (master volume will be displayed) - TEveGeoShapeExtract (used in EVE); Following draw options could be specified (separated by semicolon or ‘;’): - axis - draw axis coordinates - z - set z axis direction up (normally y axis is up and x looks in user direction) - clipx/clipy/clipz - enable correspondent clipping panel - clip or clipxyz - enable all three clip",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:15993,Energy Efficiency,power,power,15993,"e(""HALL"")->SetTransparency(30); gGeoManager->GetVolume(""HALL"")->SetLineColor(5); gGeoManager->GetVolume(""ALIC"")->Draw(""ogl""). All other will be ignored.; Example of major LHC detectors: * ALICE: full * ATLAS: full, cryo, sctt * CMS: cmse, calo * LHCb: full; Other detectors examples: * HADES: full, preselected * BABAR: full, emca * STAR: full, svtt * D0: full * NA47: full * BRAHMS: full * SLD: full; Together with geometry one could display tracks (TEveTrack) and hits (TEvePointSet, TPolyMarker3D) objects. Either one do it interactively by drag and drop, or superimpose drawing with + sign like:. item=simple_alice.json.gz+tracks_hits.root/tracks+tracks_hits.root/hits. There is a problem of correct rendering of transparent volumes. To solve problem in general is very expensive (in terms of computing power), therefore several approximation solution can be applied: * dpnt: distance from camera view to the volume center used as rendering order * dbox: distance to nearest point from bonding box used as rendering order (default) * dsize: volume size is used as rendering order, can be used for centered volumes with many shells around * dray: use raycasting to sort volumes in order they appear along rays, coming out of camera point * ddflt: default three.js method for rendering transparent volumes For different geometries different methods can be applied. In any case, all opaque volumes rendered first.; 1.7 Reading ROOT files from other servers; In principle, one could open any ROOT file placed in the web, providing the full URL to it like:. https://jsroot.gsi.de/latest/?file=https://root.cern/js/files/hsimple.root&item=hpx. But one should be aware of Same-origin policy, when the browser blocks requests to files from domains other than current web page. To enable CORS on Apache web server, hosting ROOT files, one should add following lines to .htaccess file:; <IfModule mod_headers.c>; <FilesMatch ""\.root"">; Header set Access-Control-Allow-Origin ""*""; Header set Access-Control-A",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:19297,Energy Efficiency,monitor,monitoring,19297,"OOT files; JSROOT can read files from local file system using HTML5 FileReader functionality. Main limitation here - user should interactively select files for reading. There is button “…” on the main JSROOT page, which starts file selection dialog. If valid ROOT file is selected, JSROOT will be able to normally read content of such file.; 1.9 JSROOT with THttpServer; THttpServer provides http access to objects from running ROOT application. JSROOT is used to implement the user interface in the web browsers.; The layout of the main page coming from THttpServer is very similar to normal JSROOT page. One could browse existing items and display them. A snapshot of running server can be seen on the demo page.; One could also specify similar URL parameters to configure the displayed items and drawing options.; It is also possible to display one single item from the THttpServer server like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz; 1.10 Data monitoring with JSROOT; 1.10.1 Monitoring with http server; The best possibility to organize the monitoring of data from a running application is to use THttpServer. In such case the client can always access the latest changes and request only the items currently displayed in the browser. To enable monitoring, one should activate the appropriate checkbox or provide monitoring parameter in the URL string like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hprof/draw.htm?monitoring=1000; The parameter value is the update interval in milliseconds.; 1.10.2 JSON file-based monitoring; Solid file-based monitoring (without integration of THttpServer into application) can be implemented in JSON format. There is the TBufferJSON class, which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read su",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:19394,Energy Efficiency,monitor,monitoring,19394,"lity. Main limitation here - user should interactively select files for reading. There is button “…” on the main JSROOT page, which starts file selection dialog. If valid ROOT file is selected, JSROOT will be able to normally read content of such file.; 1.9 JSROOT with THttpServer; THttpServer provides http access to objects from running ROOT application. JSROOT is used to implement the user interface in the web browsers.; The layout of the main page coming from THttpServer is very similar to normal JSROOT page. One could browse existing items and display them. A snapshot of running server can be seen on the demo page.; One could also specify similar URL parameters to configure the displayed items and drawing options.; It is also possible to display one single item from the THttpServer server like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz; 1.10 Data monitoring with JSROOT; 1.10.1 Monitoring with http server; The best possibility to organize the monitoring of data from a running application is to use THttpServer. In such case the client can always access the latest changes and request only the items currently displayed in the browser. To enable monitoring, one should activate the appropriate checkbox or provide monitoring parameter in the URL string like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hprof/draw.htm?monitoring=1000; The parameter value is the update interval in milliseconds.; 1.10.2 JSON file-based monitoring; Solid file-based monitoring (without integration of THttpServer into application) can be implemented in JSON format. There is the TBufferJSON class, which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing su",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:19597,Energy Efficiency,monitor,monitoring,19597,"OOT with THttpServer; THttpServer provides http access to objects from running ROOT application. JSROOT is used to implement the user interface in the web browsers.; The layout of the main page coming from THttpServer is very similar to normal JSROOT page. One could browse existing items and display them. A snapshot of running server can be seen on the demo page.; One could also specify similar URL parameters to configure the displayed items and drawing options.; It is also possible to display one single item from the THttpServer server like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz; 1.10 Data monitoring with JSROOT; 1.10.1 Monitoring with http server; The best possibility to organize the monitoring of data from a running application is to use THttpServer. In such case the client can always access the latest changes and request only the items currently displayed in the browser. To enable monitoring, one should activate the appropriate checkbox or provide monitoring parameter in the URL string like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hprof/draw.htm?monitoring=1000; The parameter value is the update interval in milliseconds.; 1.10.2 JSON file-based monitoring; Solid file-based monitoring (without integration of THttpServer into application) can be implemented in JSON format. There is the TBufferJSON class, which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing such functionality: https://root.cern/js/latest/demo/update_draw.htm. This demo page reads in cycle 20 json files and displays them.; If one has a web server which already provides such JSON file, one could specify the URL to this file like:; https://root.cern/js",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:19665,Energy Efficiency,monitor,monitoring,19665,"OOT with THttpServer; THttpServer provides http access to objects from running ROOT application. JSROOT is used to implement the user interface in the web browsers.; The layout of the main page coming from THttpServer is very similar to normal JSROOT page. One could browse existing items and display them. A snapshot of running server can be seen on the demo page.; One could also specify similar URL parameters to configure the displayed items and drawing options.; It is also possible to display one single item from the THttpServer server like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz; 1.10 Data monitoring with JSROOT; 1.10.1 Monitoring with http server; The best possibility to organize the monitoring of data from a running application is to use THttpServer. In such case the client can always access the latest changes and request only the items currently displayed in the browser. To enable monitoring, one should activate the appropriate checkbox or provide monitoring parameter in the URL string like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hprof/draw.htm?monitoring=1000; The parameter value is the update interval in milliseconds.; 1.10.2 JSON file-based monitoring; Solid file-based monitoring (without integration of THttpServer into application) can be implemented in JSON format. There is the TBufferJSON class, which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing such functionality: https://root.cern/js/latest/demo/update_draw.htm. This demo page reads in cycle 20 json files and displays them.; If one has a web server which already provides such JSON file, one could specify the URL to this file like:; https://root.cern/js",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:19783,Energy Efficiency,monitor,monitoring,19783,"; The layout of the main page coming from THttpServer is very similar to normal JSROOT page. One could browse existing items and display them. A snapshot of running server can be seen on the demo page.; One could also specify similar URL parameters to configure the displayed items and drawing options.; It is also possible to display one single item from the THttpServer server like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz; 1.10 Data monitoring with JSROOT; 1.10.1 Monitoring with http server; The best possibility to organize the monitoring of data from a running application is to use THttpServer. In such case the client can always access the latest changes and request only the items currently displayed in the browser. To enable monitoring, one should activate the appropriate checkbox or provide monitoring parameter in the URL string like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hprof/draw.htm?monitoring=1000; The parameter value is the update interval in milliseconds.; 1.10.2 JSON file-based monitoring; Solid file-based monitoring (without integration of THttpServer into application) can be implemented in JSON format. There is the TBufferJSON class, which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing such functionality: https://root.cern/js/latest/demo/update_draw.htm. This demo page reads in cycle 20 json files and displays them.; If one has a web server which already provides such JSON file, one could specify the URL to this file like:; https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz; Here the same problem with Cross-Origin Request can appear. If the web server configurat",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:19884,Energy Efficiency,monitor,monitoring,19884,"tems and display them. A snapshot of running server can be seen on the demo page.; One could also specify similar URL parameters to configure the displayed items and drawing options.; It is also possible to display one single item from the THttpServer server like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz; 1.10 Data monitoring with JSROOT; 1.10.1 Monitoring with http server; The best possibility to organize the monitoring of data from a running application is to use THttpServer. In such case the client can always access the latest changes and request only the items currently displayed in the browser. To enable monitoring, one should activate the appropriate checkbox or provide monitoring parameter in the URL string like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hprof/draw.htm?monitoring=1000; The parameter value is the update interval in milliseconds.; 1.10.2 JSON file-based monitoring; Solid file-based monitoring (without integration of THttpServer into application) can be implemented in JSON format. There is the TBufferJSON class, which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing such functionality: https://root.cern/js/latest/demo/update_draw.htm. This demo page reads in cycle 20 json files and displays them.; If one has a web server which already provides such JSON file, one could specify the URL to this file like:; https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz; Here the same problem with Cross-Origin Request can appear. If the web server configuration cannot be changed, just copy JSROOT to the web server itself.; 1.10.3 Binary file-based monitoring (not recommended)",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:19913,Energy Efficiency,monitor,monitoring,19913,"tems and display them. A snapshot of running server can be seen on the demo page.; One could also specify similar URL parameters to configure the displayed items and drawing options.; It is also possible to display one single item from the THttpServer server like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz; 1.10 Data monitoring with JSROOT; 1.10.1 Monitoring with http server; The best possibility to organize the monitoring of data from a running application is to use THttpServer. In such case the client can always access the latest changes and request only the items currently displayed in the browser. To enable monitoring, one should activate the appropriate checkbox or provide monitoring parameter in the URL string like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hprof/draw.htm?monitoring=1000; The parameter value is the update interval in milliseconds.; 1.10.2 JSON file-based monitoring; Solid file-based monitoring (without integration of THttpServer into application) can be implemented in JSON format. There is the TBufferJSON class, which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing such functionality: https://root.cern/js/latest/demo/update_draw.htm. This demo page reads in cycle 20 json files and displays them.; If one has a web server which already provides such JSON file, one could specify the URL to this file like:; https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz; Here the same problem with Cross-Origin Request can appear. If the web server configuration cannot be changed, just copy JSROOT to the web server itself.; 1.10.3 Binary file-based monitoring (not recommended)",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:20911,Energy Efficiency,monitor,monitoring,20911,"tpServer into application) can be implemented in JSON format. There is the TBufferJSON class, which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing such functionality: https://root.cern/js/latest/demo/update_draw.htm. This demo page reads in cycle 20 json files and displays them.; If one has a web server which already provides such JSON file, one could specify the URL to this file like:; https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz; Here the same problem with Cross-Origin Request can appear. If the web server configuration cannot be changed, just copy JSROOT to the web server itself.; 1.10.3 Binary file-based monitoring (not recommended); Theoretically, one could use binary ROOT files to implement monitoring. With such approach, a ROOT-based application creates and regularly updates content of a ROOT file, which can be accessed via normal web server. From the browser side, JSROOT could regularly read the specified objects and update their drawings. But such solution has three major caveats.; First of all, one need to store the data of all objects, which only potentially could be displayed in the browser. In case of 10 objects it does not matter, but for 1000 or 100000 objects this will be a major performance penalty. With such big amount of data one will never achieve higher update rate.; The second problem is I/O. To read the first object from the ROOT file, one need to perform several (about 5) file-reading operations via http protocol. There is no http file locking mechanism (at least not for standard web servers), therefore there is no guarantee that the file content is not changed/replaced between consequent read operations. ",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:21001,Energy Efficiency,monitor,monitoring,21001,"tpServer into application) can be implemented in JSON format. There is the TBufferJSON class, which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing such functionality: https://root.cern/js/latest/demo/update_draw.htm. This demo page reads in cycle 20 json files and displays them.; If one has a web server which already provides such JSON file, one could specify the URL to this file like:; https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz; Here the same problem with Cross-Origin Request can appear. If the web server configuration cannot be changed, just copy JSROOT to the web server itself.; 1.10.3 Binary file-based monitoring (not recommended); Theoretically, one could use binary ROOT files to implement monitoring. With such approach, a ROOT-based application creates and regularly updates content of a ROOT file, which can be accessed via normal web server. From the browser side, JSROOT could regularly read the specified objects and update their drawings. But such solution has three major caveats.; First of all, one need to store the data of all objects, which only potentially could be displayed in the browser. In case of 10 objects it does not matter, but for 1000 or 100000 objects this will be a major performance penalty. With such big amount of data one will never achieve higher update rate.; The second problem is I/O. To read the first object from the ROOT file, one need to perform several (about 5) file-reading operations via http protocol. There is no http file locking mechanism (at least not for standard web servers), therefore there is no guarantee that the file content is not changed/replaced between consequent read operations. ",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:22019,Energy Efficiency,monitor,monitor,22019,"nitoring. With such approach, a ROOT-based application creates and regularly updates content of a ROOT file, which can be accessed via normal web server. From the browser side, JSROOT could regularly read the specified objects and update their drawings. But such solution has three major caveats.; First of all, one need to store the data of all objects, which only potentially could be displayed in the browser. In case of 10 objects it does not matter, but for 1000 or 100000 objects this will be a major performance penalty. With such big amount of data one will never achieve higher update rate.; The second problem is I/O. To read the first object from the ROOT file, one need to perform several (about 5) file-reading operations via http protocol. There is no http file locking mechanism (at least not for standard web servers), therefore there is no guarantee that the file content is not changed/replaced between consequent read operations. Therefore, one should expect frequent I/O failures while trying to monitor data from ROOT binary files. There is a workaround for the problem - one could load the file completely and exclude many partial I/O operations by this. To achieve this with JSROOT, one should add “+” sign at the end of the file name. Of course, it only could work for small files.; If somebody still wants to use monitoring of data from ROOT files, could try link like:. https://root.cern/js/latest/?nobrowser&file=../files/hsimple.root+&item=hpx;1&monitoring=2000. In this particular case, the histogram is not changing.; 1.11 JSROOT API; JSROOT can be used in arbitrary HTML pages to display data, produced with or without ROOT-based applications.; Many different examples of JSROOT API usage can be found on JSROOT API examples page.; 1.11.1 Import JSROOT functionality; Major JSROOT functions are located in main.mjs module and can be imported like:; <script type='module'>; import { openFile, draw } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = """,MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:22341,Energy Efficiency,monitor,monitoring,22341,"cts, which only potentially could be displayed in the browser. In case of 10 objects it does not matter, but for 1000 or 100000 objects this will be a major performance penalty. With such big amount of data one will never achieve higher update rate.; The second problem is I/O. To read the first object from the ROOT file, one need to perform several (about 5) file-reading operations via http protocol. There is no http file locking mechanism (at least not for standard web servers), therefore there is no guarantee that the file content is not changed/replaced between consequent read operations. Therefore, one should expect frequent I/O failures while trying to monitor data from ROOT binary files. There is a workaround for the problem - one could load the file completely and exclude many partial I/O operations by this. To achieve this with JSROOT, one should add “+” sign at the end of the file name. Of course, it only could work for small files.; If somebody still wants to use monitoring of data from ROOT files, could try link like:. https://root.cern/js/latest/?nobrowser&file=../files/hsimple.root+&item=hpx;1&monitoring=2000. In this particular case, the histogram is not changing.; 1.11 JSROOT API; JSROOT can be used in arbitrary HTML pages to display data, produced with or without ROOT-based applications.; Many different examples of JSROOT API usage can be found on JSROOT API examples page.; 1.11.1 Import JSROOT functionality; Major JSROOT functions are located in main.mjs module and can be imported like:; <script type='module'>; import { openFile, draw } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/hsimple.root"";; let file = await openFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; </script>; Here the default location https://root.cern/js/latest/ is specified. One always can install JSROOT on private web server. When JSROOT is used with THttpServer, the address look",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:22477,Energy Efficiency,monitor,monitoring,22477,"0000 objects this will be a major performance penalty. With such big amount of data one will never achieve higher update rate.; The second problem is I/O. To read the first object from the ROOT file, one need to perform several (about 5) file-reading operations via http protocol. There is no http file locking mechanism (at least not for standard web servers), therefore there is no guarantee that the file content is not changed/replaced between consequent read operations. Therefore, one should expect frequent I/O failures while trying to monitor data from ROOT binary files. There is a workaround for the problem - one could load the file completely and exclude many partial I/O operations by this. To achieve this with JSROOT, one should add “+” sign at the end of the file name. Of course, it only could work for small files.; If somebody still wants to use monitoring of data from ROOT files, could try link like:. https://root.cern/js/latest/?nobrowser&file=../files/hsimple.root+&item=hpx;1&monitoring=2000. In this particular case, the histogram is not changing.; 1.11 JSROOT API; JSROOT can be used in arbitrary HTML pages to display data, produced with or without ROOT-based applications.; Many different examples of JSROOT API usage can be found on JSROOT API examples page.; 1.11.1 Import JSROOT functionality; Major JSROOT functions are located in main.mjs module and can be imported like:; <script type='module'>; import { openFile, draw } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/hsimple.root"";; let file = await openFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; </script>; Here the default location https://root.cern/js/latest/ is specified. One always can install JSROOT on private web server. When JSROOT is used with THttpServer, the address looks like:; <script type='module'>; import { httpRequest, draw } from 'http://your_root_server:8080/jsrootsys/modules/main.mjs'",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:2346,Integrability,inject,inject,2346,"anvas.; To automate files loading and objects drawing, one can provide number of URL parameters in address string like:. file - name of the file, which will be automatically open with page loading; files - array of file names for loading; json - name of JSON file with stored ROOT object like histogram or canvas; item - item name to be displayed; opt - drawing option for the item; items - array of items name to be displayed; opts - array of drawing options for the items; expand - item name(s) to be expanded in the hierarchy browser; focus - item name to be focused on in the hierarchy browser; title - set browser title; dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; layout - can be ‘simple’, ‘flex’, ‘tabs’, ‘gridNxM’, ‘horizNMK’, ‘vertNMK’; browser - layout of the browser ‘fix’ (default), ‘float’, ‘no’ (hidden), ‘off’ (fully disabled); nobrowser - do not display file browser (same as browser=no); float - display floating browser (same as browser=float); status - configure status line ‘no’ (default), ‘off’ (completely disable), ‘size’; inject - name of extra JavaScript to load, see several examples in demo/ subdir; optimize - drawing optimization 0:off, 1:only large histograms (default), 2:always; palette - id of default color palette, 51..121 - new ROOT6 palette (default 57); interactive - enable/disable interactive functions 0 - disable all, 1 - enable all; noselect - hide file-selection part in the browser (only when file name is specified); mathjax - use MathJax for latex output; latex - ‘off’, ‘symbols’, ‘normal’, ‘mathjax’, ‘alwaysmath’ control of TLatex processor; style - name of TStyle object to define global JSROOT style; toolbar - show canvas tool buttons ‘off’, ‘on’ and ‘popup’, ‘left’ or ‘right’ for position, ‘vert’ for vertical; divsize - fixed size in pixels for main div element like &dvisize=1500x800; canvsize - default canvas size in pixels like &canvsize=1200x800; optstat - settings for stat box, def",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:5447,Integrability,integrat,integrate,5447,"bs - tabs for each object drawing; gridNxM - fixed-size grid with NxM frames; vertN - N frames sorted in vertical direction (like gridi1xN); horizN - N frames sorted in horizontal direction (like gridiNx1); vert121 - 3 frames sorted in vertical direction, second frame divided on two sub-frames; horiz32_12 - 2 horizontal frames with 3 and 2 subframes, and 1/3 and 2/3 as relative size. When specifying files, items or opts parameters, array of strings could be provided like files=['file1.root','file2.root']. One could skip quotes when specifying elements names items=[file1.root/hpx,file2.root/hpy] or opts=['',colz].; As item name, URL to existing image can be provided like item=img:http://server/image.png. Such image will be just inserted in the existing layout. One could specify option ""scale"" to automatically scale image to available space.; Many examples of URL string usage can be found on JSROOT API examples page.; One can very easy integrate JSROOT graphic into arbitrary HTML pages using a iframe tag:; <iframe width=""700"" height=""400""; src=""https://root.cern/js/latest/?nobrowser&file=https://root.cern/js/files/hsimple.root&item=hpxpy&opt=colz"">; </iframe>; 1.3 Supported ROOT classes by JSROOT; List of supported classes and draw options:. TH1 : hist, p, p0, *, l, lf2, a, e, e0, e1, e1x0, e3, e4, lego, text, X+Y+; TH2 : scat, col, colz, box, box1, text, lego, arr, cont, cont1, cont2, cont3, cont4, surf, surf1, surf2, surf3, surf4, surf6, surf7, lego, lego0, lego1, lego2, lego3, lego4; TH2Poly : col, lego, europe, usa; TH3 : scat, box, box1; TProfile : dflt, e, e1, pe2, hist, text, texte; TProfile2D : example; THStack : example; TF1 : example; TF2 : example; TSpline : example; TGraph : dflt, L, P, *, B, RX, RY; TGraphErrors : dflt, l, lx, z, >, |>, ||, [], 0, 2, 3, 4, 5; TGraphAsymmErrors : dflt,; TGraphMultiErrors : docu, z and other from TGraphErrors; TGraphPolar : example; TMultiGraph : example, exclusion; TGraph2D : example; TEfficiency : docu; TLatex : example; ",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:18789,Integrability,interface,interface,18789," default settings. A simplified variant of such solution - copy only the top index.htm file from JSROOT package and specify the full path to modules/gui.mjs script like:; <script type=""module"">; import { openFile, draw } from 'https://root.cern/js/latest/modules/gui.mjs';; // ...; </script>; In the main <div> element one can specify many custom parameters like one do it in URL string:; <div id=""simpleGUI"" path=""files/path"" files=""userfile1.root;subdir/usefile2.root"">; loading scripts ...; </div>; 1.8 Reading local ROOT files; JSROOT can read files from local file system using HTML5 FileReader functionality. Main limitation here - user should interactively select files for reading. There is button “…” on the main JSROOT page, which starts file selection dialog. If valid ROOT file is selected, JSROOT will be able to normally read content of such file.; 1.9 JSROOT with THttpServer; THttpServer provides http access to objects from running ROOT application. JSROOT is used to implement the user interface in the web browsers.; The layout of the main page coming from THttpServer is very similar to normal JSROOT page. One could browse existing items and display them. A snapshot of running server can be seen on the demo page.; One could also specify similar URL parameters to configure the displayed items and drawing options.; It is also possible to display one single item from the THttpServer server like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz; 1.10 Data monitoring with JSROOT; 1.10.1 Monitoring with http server; The best possibility to organize the monitoring of data from a running application is to use THttpServer. In such case the client can always access the latest changes and request only the items currently displayed in the browser. To enable monitoring, one should activate the appropriate checkbox or provide monitoring parameter in the URL string like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hprof/draw.htm?mo",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:19933,Integrability,integrat,integration,19933,"tems and display them. A snapshot of running server can be seen on the demo page.; One could also specify similar URL parameters to configure the displayed items and drawing options.; It is also possible to display one single item from the THttpServer server like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz; 1.10 Data monitoring with JSROOT; 1.10.1 Monitoring with http server; The best possibility to organize the monitoring of data from a running application is to use THttpServer. In such case the client can always access the latest changes and request only the items currently displayed in the browser. To enable monitoring, one should activate the appropriate checkbox or provide monitoring parameter in the URL string like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hprof/draw.htm?monitoring=1000; The parameter value is the update interval in milliseconds.; 1.10.2 JSON file-based monitoring; Solid file-based monitoring (without integration of THttpServer into application) can be implemented in JSON format. There is the TBufferJSON class, which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing such functionality: https://root.cern/js/latest/demo/update_draw.htm. This demo page reads in cycle 20 json files and displays them.; If one has a web server which already provides such JSON file, one could specify the URL to this file like:; https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz; Here the same problem with Cross-Origin Request can appear. If the web server configuration cannot be changed, just copy JSROOT to the web server itself.; 1.10.3 Binary file-based monitoring (not recommended)",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:21747,Integrability,protocol,protocol,21747,"ttpserver.C/Canvases/c1/root.json.gz; Here the same problem with Cross-Origin Request can appear. If the web server configuration cannot be changed, just copy JSROOT to the web server itself.; 1.10.3 Binary file-based monitoring (not recommended); Theoretically, one could use binary ROOT files to implement monitoring. With such approach, a ROOT-based application creates and regularly updates content of a ROOT file, which can be accessed via normal web server. From the browser side, JSROOT could regularly read the specified objects and update their drawings. But such solution has three major caveats.; First of all, one need to store the data of all objects, which only potentially could be displayed in the browser. In case of 10 objects it does not matter, but for 1000 or 100000 objects this will be a major performance penalty. With such big amount of data one will never achieve higher update rate.; The second problem is I/O. To read the first object from the ROOT file, one need to perform several (about 5) file-reading operations via http protocol. There is no http file locking mechanism (at least not for standard web servers), therefore there is no guarantee that the file content is not changed/replaced between consequent read operations. Therefore, one should expect frequent I/O failures while trying to monitor data from ROOT binary files. There is a workaround for the problem - one could load the file completely and exclude many partial I/O operations by this. To achieve this with JSROOT, one should add “+” sign at the end of the file name. Of course, it only could work for small files.; If somebody still wants to use monitoring of data from ROOT files, could try link like:. https://root.cern/js/latest/?nobrowser&file=../files/hsimple.root+&item=hpx;1&monitoring=2000. In this particular case, the histogram is not changing.; 1.11 JSROOT API; JSROOT can be used in arbitrary HTML pages to display data, produced with or without ROOT-based applications.; Many different",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:2272,Modifiability,config,configure,2272,"anvas.; To automate files loading and objects drawing, one can provide number of URL parameters in address string like:. file - name of the file, which will be automatically open with page loading; files - array of file names for loading; json - name of JSON file with stored ROOT object like histogram or canvas; item - item name to be displayed; opt - drawing option for the item; items - array of items name to be displayed; opts - array of drawing options for the items; expand - item name(s) to be expanded in the hierarchy browser; focus - item name to be focused on in the hierarchy browser; title - set browser title; dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; layout - can be ‘simple’, ‘flex’, ‘tabs’, ‘gridNxM’, ‘horizNMK’, ‘vertNMK’; browser - layout of the browser ‘fix’ (default), ‘float’, ‘no’ (hidden), ‘off’ (fully disabled); nobrowser - do not display file browser (same as browser=no); float - display floating browser (same as browser=float); status - configure status line ‘no’ (default), ‘off’ (completely disable), ‘size’; inject - name of extra JavaScript to load, see several examples in demo/ subdir; optimize - drawing optimization 0:off, 1:only large histograms (default), 2:always; palette - id of default color palette, 51..121 - new ROOT6 palette (default 57); interactive - enable/disable interactive functions 0 - disable all, 1 - enable all; noselect - hide file-selection part in the browser (only when file name is specified); mathjax - use MathJax for latex output; latex - ‘off’, ‘symbols’, ‘normal’, ‘mathjax’, ‘alwaysmath’ control of TLatex processor; style - name of TStyle object to define global JSROOT style; toolbar - show canvas tool buttons ‘off’, ‘on’ and ‘popup’, ‘left’ or ‘right’ for position, ‘vert’ for vertical; divsize - fixed size in pixels for main div element like &dvisize=1500x800; canvsize - default canvas size in pixels like &canvsize=1200x800; optstat - settings for stat box, def",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:8685,Modifiability,config,configure,8685,"TCanvas; nocolors - ignore colors list stored with TCanvas; lcolors - use only locally colors list stored with TCanvas; nomargins - clear frame margins. 1.4 Superimposing draw objects; In the URL string one could use “+” sign to specify objects superposition:. item=hpx+hprof. With similar syntax one could specify individual draw options for superimposed objects. item=hpx+hprof&opt=logy+hist. Here “logy” option will be used for “hpx1” item and “hist” option for “hprof;1” item.; While draw option can include “+” sign itself, for superposition one could specify arrays of items and draw options like:. item=[hpx;1,hprof;1]&opt=[logy,hist]. 1.5 TTree draw; JSROOT provides possibility to display TTree data, using TTree::Draw syntax:. opt=px; opt=px:py; opt=px:py:pz. It is also possible to use branch by id number specifying name like “br_0”, “br_1” and so on:. opt=br_0:br_1. Histogram ranges and binning defined after reading first 1000 entries from the tree. Like in ROOT, one could configure histogram binning and range directly:. opt=px:py>>h(50,-5,5,50,-5,5). One and two dimensional draw expressions can be resulted into TGraph object, using “>>Graph” as output:. opt=px:py>>Graph. For any integer value one can accumulate histogram with value bits distribution, specifying as output “>>bits(16)” or “>>bits”:. opt=event.fTracks.fBits>>bits. There is special handling of TBits objects:. opt=event.fTriggerBits. It is allowed to use different expressions with branch values:. opt=px+py:px-py. Such expression can include arithmetical operations and all methods, provided in JavaScript Math class:. opt=Math.abs(px+py). In the expression one could use “Entry\("" and ""Entries\)” variables.; One also could specify cut condition, separating it with “::” from the rest draw expression like:. opt=px:py::pz>5. Contrary to the normal ROOT, JSROOT allows to use “(expr?res1:res2)” operator (placed into brackets):. opt=px:py::(pz>5?2:1). It is possible to “dump” content of any branch (by default - ",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:9382,Modifiability,variab,variables,9382,"ROOT provides possibility to display TTree data, using TTree::Draw syntax:. opt=px; opt=px:py; opt=px:py:pz. It is also possible to use branch by id number specifying name like “br_0”, “br_1” and so on:. opt=br_0:br_1. Histogram ranges and binning defined after reading first 1000 entries from the tree. Like in ROOT, one could configure histogram binning and range directly:. opt=px:py>>h(50,-5,5,50,-5,5). One and two dimensional draw expressions can be resulted into TGraph object, using “>>Graph” as output:. opt=px:py>>Graph. For any integer value one can accumulate histogram with value bits distribution, specifying as output “>>bits(16)” or “>>bits”:. opt=event.fTracks.fBits>>bits. There is special handling of TBits objects:. opt=event.fTriggerBits. It is allowed to use different expressions with branch values:. opt=px+py:px-py. Such expression can include arithmetical operations and all methods, provided in JavaScript Math class:. opt=Math.abs(px+py). In the expression one could use “Entry\("" and ""Entries\)” variables.; One also could specify cut condition, separating it with “::” from the rest draw expression like:. opt=px:py::pz>5. Contrary to the normal ROOT, JSROOT allows to use “(expr?res1:res2)” operator (placed into brackets):. opt=px:py::(pz>5?2:1). It is possible to “dump” content of any branch (by default - first 10 entries):. item=ntuple/px&opt=dump. Or one could dump values produced with draw expression (also first 10 entries by default):. opt=px:py::pz>>dump. Working with array indexes is supported. By default, all elements in array are used for the drawing. One could specify index for any array dimension (-1 means last element in the array). For instance, dump last element from event.fTracks array:. opt=event.fTracks[-1].fBits>>dump. For any array or collection kind one could extract its size with expression:. opt=event.fTracks.@size. At the end of expression one can add several parameters with the syntax:; <draw_expession>;par1name:par1value;par2name:",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:12007,Modifiability,config,configure,12007,"t” - drawing option for produced histogram - “graph” - draw into TGraph object; Example - opt=event.fTracks[].fTriggerBits;entries:1000;first:200;maxrange:25; 1.6 Geometry viewer; JSROOT implements display of TGeo objects like:. file=rootgeom.root&item=simple1; file=building.root&item=geom&opt=z. Following classes are supported by geometry viewer: - TGeoVolume - TGeoNode - TGeoManager (master volume will be displayed) - TEveGeoShapeExtract (used in EVE); Following draw options could be specified (separated by semicolon or ‘;’): - axis - draw axis coordinates - z - set z axis direction up (normally y axis is up and x looks in user direction) - clipx/clipy/clipz - enable correspondent clipping panel - clip or clipxyz - enable all three clipping panels - ssao - enable Smooth Lighting Shader (or Screen Space Ambient Occlusion) - wire - instead of filled surfaces only wireframe will be drawn - vislvlN - maximal hierarchy depth of visible nodes (like vislvl6) - moreN - show N times more volumes as usual (normally ~10000 nodes and ~200000 elementary faces are shown) - all - try to display all geometry volumes (may lead to browser hanging) - maxnodesN - configure maximal number of rendered nodes (like maxnodes100K) - maxfacesN - configure maximal number of rendered faces (like maxfaces3M) - highlight - force highlighting of selected volume, normally activated for moderate-size geometries - nohighlight - disable volumes highlighting (can be activated via context menu) - hscene - enable highlight of extra objects like tracks or hits - hsceneonly - enable only highlight of extra objects like tracks or hits - nohscene - disable highlight of extra objects like tracks or hits - macro:name.C - invoke ROOT configuration macro - dflt - set default volumes colors as TGeoManager::DefaultColors() does - transpXY - set global transparency value (XY is number between 1 and 99) - zoomFACTOR - set initial zoom factor (FACTOR is integer value from 1 to 10000, default is 100) - rotyANGLE - se",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:12084,Modifiability,config,configure,12084,"t” - drawing option for produced histogram - “graph” - draw into TGraph object; Example - opt=event.fTracks[].fTriggerBits;entries:1000;first:200;maxrange:25; 1.6 Geometry viewer; JSROOT implements display of TGeo objects like:. file=rootgeom.root&item=simple1; file=building.root&item=geom&opt=z. Following classes are supported by geometry viewer: - TGeoVolume - TGeoNode - TGeoManager (master volume will be displayed) - TEveGeoShapeExtract (used in EVE); Following draw options could be specified (separated by semicolon or ‘;’): - axis - draw axis coordinates - z - set z axis direction up (normally y axis is up and x looks in user direction) - clipx/clipy/clipz - enable correspondent clipping panel - clip or clipxyz - enable all three clipping panels - ssao - enable Smooth Lighting Shader (or Screen Space Ambient Occlusion) - wire - instead of filled surfaces only wireframe will be drawn - vislvlN - maximal hierarchy depth of visible nodes (like vislvl6) - moreN - show N times more volumes as usual (normally ~10000 nodes and ~200000 elementary faces are shown) - all - try to display all geometry volumes (may lead to browser hanging) - maxnodesN - configure maximal number of rendered nodes (like maxnodes100K) - maxfacesN - configure maximal number of rendered faces (like maxfaces3M) - highlight - force highlighting of selected volume, normally activated for moderate-size geometries - nohighlight - disable volumes highlighting (can be activated via context menu) - hscene - enable highlight of extra objects like tracks or hits - hsceneonly - enable only highlight of extra objects like tracks or hits - nohscene - disable highlight of extra objects like tracks or hits - macro:name.C - invoke ROOT configuration macro - dflt - set default volumes colors as TGeoManager::DefaultColors() does - transpXY - set global transparency value (XY is number between 1 and 99) - zoomFACTOR - set initial zoom factor (FACTOR is integer value from 1 to 10000, default is 100) - rotyANGLE - se",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:12563,Modifiability,config,configuration,12563,"mes as usual (normally ~10000 nodes and ~200000 elementary faces are shown) - all - try to display all geometry volumes (may lead to browser hanging) - maxnodesN - configure maximal number of rendered nodes (like maxnodes100K) - maxfacesN - configure maximal number of rendered faces (like maxfaces3M) - highlight - force highlighting of selected volume, normally activated for moderate-size geometries - nohighlight - disable volumes highlighting (can be activated via context menu) - hscene - enable highlight of extra objects like tracks or hits - hsceneonly - enable only highlight of extra objects like tracks or hits - nohscene - disable highlight of extra objects like tracks or hits - macro:name.C - invoke ROOT configuration macro - dflt - set default volumes colors as TGeoManager::DefaultColors() does - transpXY - set global transparency value (XY is number between 1 and 99) - zoomFACTOR - set initial zoom factor (FACTOR is integer value from 1 to 10000, default is 100) - rotyANGLE - set Y rotation angle in degrees (like roty10) - rotzANGLE - set Z rotation angle in degrees (like rotz20) - rotate - enable automatic rotation of the geometry - trzVALUE - set transformation along Z axis (like trz50) - trrVALUE - set radial transformation (like trr100) - ortho_camera - use THREE.OrthographicCamera without possibility to rotate it - ortho_camera_rotate - use THREE.OrthographicCamera and enable it rotation - ctrl - show control UI from the beginning - tracks - show tracks from TGeoManager - showtop - show top-level volume of TGeoManager (default off) - no_screen - let ignore kVisOnScreen bits for nodes visibility - dray - calculate rendering order using raytracing (extensive calculations) - dbox - use distance to nearest point from bounding box for rendering order (default) - dpnt - use distance to shape center as rendering order - dsize - use volume size as rendering order - ddflt - let three.js to calculate rendering order - comp - show left and right components of TGeo",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:14535,Modifiability,config,configure,14535,"st point from bounding box for rendering order (default) - dpnt - use distance to shape center as rendering order - dsize - use volume size as rendering order - ddflt - let three.js to calculate rendering order - comp - show left and right components of TGeoCompositeShape - compx - show all sub-components of TGeoCompositeShape; In the URL string several global settings can be changed:. geosegm - grads per segment is cylindrical shapes, default is 6; geocomp - compress results of composite shape production, default is true. It is possible to display only part of geometry model. For instance, one could select sub-item like:. file=rootgeom.root&item=simple1/TOP/REPLICA_1. Or one can use simple selection syntax (work only with first-level volumes):. item=simple1&opt=-bar1-bar2. Syntax uses ‘+’ sign to enable visibility flag of specified volume and ‘-’ sign to disable visibility. One could use wildcard symbol like ’+TUBE1*’.; Another way to configure visibility flags is usage of ROOT macros, which typically looks like:; {; TGeoManager::Import(""http://root.cern/files/alice2.root"");; gGeoManager->DefaultColors();; // gGeoManager->SetVisLevel(4);; gGeoManager->GetVolume(""HALL"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCC"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCA"")->InvisibleAll();; // ...; gGeoManager->GetVolume(""ALIC"")->Draw(""ogl"");; new TBrowser;; }; Example of such macro can be found in root tutorials.; From provided macro only following calls will be executed in JSROOT:. gGeoManager->DefaultColors(); gGeoManager->GetVolume(""HALL"")->InvisibleAll(); gGeoManager->GetVolume(""HALL"")->SetTransparency(30); gGeoManager->GetVolume(""HALL"")->SetLineColor(5); gGeoManager->GetVolume(""ALIC"")->Draw(""ogl""). All other will be ignored.; Example of major LHC detectors: * ALICE: full * ATLAS: full, cryo, sctt * CMS: cmse, calo * LHCb: full; Other detectors examples: * HADES: full, preselected * BABAR: full, emca * STAR: full, svtt * D0: full * NA47: full * BRAHMS: full * SLD: ful",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:17390,Modifiability,config,configuring,17390,"an be used for centered volumes with many shells around * dray: use raycasting to sort volumes in order they appear along rays, coming out of camera point * ddflt: default three.js method for rendering transparent volumes For different geometries different methods can be applied. In any case, all opaque volumes rendered first.; 1.7 Reading ROOT files from other servers; In principle, one could open any ROOT file placed in the web, providing the full URL to it like:. https://jsroot.gsi.de/latest/?file=https://root.cern/js/files/hsimple.root&item=hpx. But one should be aware of Same-origin policy, when the browser blocks requests to files from domains other than current web page. To enable CORS on Apache web server, hosting ROOT files, one should add following lines to .htaccess file:; <IfModule mod_headers.c>; <FilesMatch ""\.root"">; Header set Access-Control-Allow-Origin ""*""; Header set Access-Control-Allow-Headers ""range""; Header set Access-Control-Expose-Headers ""content-range,content-length,accept-ranges""; Header set Access-Control-Allow-Methods ""GET""; </FilesMatch>; </IfModule>; More details about configuring of CORS headers can be found here.; Alternative - enable CORS requests in the browser. It can be easily done with CORS Everywhere plugin for the Firefox browser or Allow CORS plugin for the Chrome browser.; Next solution - install JSROOT on the server hosting ROOT files. In such configuration JSROOT does not issue CORS requests, therefore server and browsers can be used with their default settings. A simplified variant of such solution - copy only the top index.htm file from JSROOT package and specify the full path to modules/gui.mjs script like:; <script type=""module"">; import { openFile, draw } from 'https://root.cern/js/latest/modules/gui.mjs';; // ...; </script>; In the main <div> element one can specify many custom parameters like one do it in URL string:; <div id=""simpleGUI"" path=""files/path"" files=""userfile1.root;subdir/usefile2.root"">; loading script",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:17532,Modifiability,plugin,plugin,17532,"lied. In any case, all opaque volumes rendered first.; 1.7 Reading ROOT files from other servers; In principle, one could open any ROOT file placed in the web, providing the full URL to it like:. https://jsroot.gsi.de/latest/?file=https://root.cern/js/files/hsimple.root&item=hpx. But one should be aware of Same-origin policy, when the browser blocks requests to files from domains other than current web page. To enable CORS on Apache web server, hosting ROOT files, one should add following lines to .htaccess file:; <IfModule mod_headers.c>; <FilesMatch ""\.root"">; Header set Access-Control-Allow-Origin ""*""; Header set Access-Control-Allow-Headers ""range""; Header set Access-Control-Expose-Headers ""content-range,content-length,accept-ranges""; Header set Access-Control-Allow-Methods ""GET""; </FilesMatch>; </IfModule>; More details about configuring of CORS headers can be found here.; Alternative - enable CORS requests in the browser. It can be easily done with CORS Everywhere plugin for the Firefox browser or Allow CORS plugin for the Chrome browser.; Next solution - install JSROOT on the server hosting ROOT files. In such configuration JSROOT does not issue CORS requests, therefore server and browsers can be used with their default settings. A simplified variant of such solution - copy only the top index.htm file from JSROOT package and specify the full path to modules/gui.mjs script like:; <script type=""module"">; import { openFile, draw } from 'https://root.cern/js/latest/modules/gui.mjs';; // ...; </script>; In the main <div> element one can specify many custom parameters like one do it in URL string:; <div id=""simpleGUI"" path=""files/path"" files=""userfile1.root;subdir/usefile2.root"">; loading scripts ...; </div>; 1.8 Reading local ROOT files; JSROOT can read files from local file system using HTML5 FileReader functionality. Main limitation here - user should interactively select files for reading. There is button “…” on the main JSROOT page, which starts file selection ",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:17577,Modifiability,plugin,plugin,17577,"lied. In any case, all opaque volumes rendered first.; 1.7 Reading ROOT files from other servers; In principle, one could open any ROOT file placed in the web, providing the full URL to it like:. https://jsroot.gsi.de/latest/?file=https://root.cern/js/files/hsimple.root&item=hpx. But one should be aware of Same-origin policy, when the browser blocks requests to files from domains other than current web page. To enable CORS on Apache web server, hosting ROOT files, one should add following lines to .htaccess file:; <IfModule mod_headers.c>; <FilesMatch ""\.root"">; Header set Access-Control-Allow-Origin ""*""; Header set Access-Control-Allow-Headers ""range""; Header set Access-Control-Expose-Headers ""content-range,content-length,accept-ranges""; Header set Access-Control-Allow-Methods ""GET""; </FilesMatch>; </IfModule>; More details about configuring of CORS headers can be found here.; Alternative - enable CORS requests in the browser. It can be easily done with CORS Everywhere plugin for the Firefox browser or Allow CORS plugin for the Chrome browser.; Next solution - install JSROOT on the server hosting ROOT files. In such configuration JSROOT does not issue CORS requests, therefore server and browsers can be used with their default settings. A simplified variant of such solution - copy only the top index.htm file from JSROOT package and specify the full path to modules/gui.mjs script like:; <script type=""module"">; import { openFile, draw } from 'https://root.cern/js/latest/modules/gui.mjs';; // ...; </script>; In the main <div> element one can specify many custom parameters like one do it in URL string:; <div id=""simpleGUI"" path=""files/path"" files=""userfile1.root;subdir/usefile2.root"">; loading scripts ...; </div>; 1.8 Reading local ROOT files; JSROOT can read files from local file system using HTML5 FileReader functionality. Main limitation here - user should interactively select files for reading. There is button “…” on the main JSROOT page, which starts file selection ",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:17682,Modifiability,config,configuration,17682,"ke:. https://jsroot.gsi.de/latest/?file=https://root.cern/js/files/hsimple.root&item=hpx. But one should be aware of Same-origin policy, when the browser blocks requests to files from domains other than current web page. To enable CORS on Apache web server, hosting ROOT files, one should add following lines to .htaccess file:; <IfModule mod_headers.c>; <FilesMatch ""\.root"">; Header set Access-Control-Allow-Origin ""*""; Header set Access-Control-Allow-Headers ""range""; Header set Access-Control-Expose-Headers ""content-range,content-length,accept-ranges""; Header set Access-Control-Allow-Methods ""GET""; </FilesMatch>; </IfModule>; More details about configuring of CORS headers can be found here.; Alternative - enable CORS requests in the browser. It can be easily done with CORS Everywhere plugin for the Firefox browser or Allow CORS plugin for the Chrome browser.; Next solution - install JSROOT on the server hosting ROOT files. In such configuration JSROOT does not issue CORS requests, therefore server and browsers can be used with their default settings. A simplified variant of such solution - copy only the top index.htm file from JSROOT package and specify the full path to modules/gui.mjs script like:; <script type=""module"">; import { openFile, draw } from 'https://root.cern/js/latest/modules/gui.mjs';; // ...; </script>; In the main <div> element one can specify many custom parameters like one do it in URL string:; <div id=""simpleGUI"" path=""files/path"" files=""userfile1.root;subdir/usefile2.root"">; loading scripts ...; </div>; 1.8 Reading local ROOT files; JSROOT can read files from local file system using HTML5 FileReader functionality. Main limitation here - user should interactively select files for reading. There is button “…” on the main JSROOT page, which starts file selection dialog. If valid ROOT file is selected, JSROOT will be able to normally read content of such file.; 1.9 JSROOT with THttpServer; THttpServer provides http access to objects from running ROOT",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:19071,Modifiability,config,configure,19071,"cript>; In the main <div> element one can specify many custom parameters like one do it in URL string:; <div id=""simpleGUI"" path=""files/path"" files=""userfile1.root;subdir/usefile2.root"">; loading scripts ...; </div>; 1.8 Reading local ROOT files; JSROOT can read files from local file system using HTML5 FileReader functionality. Main limitation here - user should interactively select files for reading. There is button “…” on the main JSROOT page, which starts file selection dialog. If valid ROOT file is selected, JSROOT will be able to normally read content of such file.; 1.9 JSROOT with THttpServer; THttpServer provides http access to objects from running ROOT application. JSROOT is used to implement the user interface in the web browsers.; The layout of the main page coming from THttpServer is very similar to normal JSROOT page. One could browse existing items and display them. A snapshot of running server can be seen on the demo page.; One could also specify similar URL parameters to configure the displayed items and drawing options.; It is also possible to display one single item from the THttpServer server like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz; 1.10 Data monitoring with JSROOT; 1.10.1 Monitoring with http server; The best possibility to organize the monitoring of data from a running application is to use THttpServer. In such case the client can always access the latest changes and request only the items currently displayed in the browser. To enable monitoring, one should activate the appropriate checkbox or provide monitoring parameter in the URL string like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hprof/draw.htm?monitoring=1000; The parameter value is the update interval in milliseconds.; 1.10.2 JSON file-based monitoring; Solid file-based monitoring (without integration of THttpServer into application) can be implemented in JSON format. There is the TBufferJSON class, which is capable to conver",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:20809,Modifiability,config,configuration,20809,"erval in milliseconds.; 1.10.2 JSON file-based monitoring; Solid file-based monitoring (without integration of THttpServer into application) can be implemented in JSON format. There is the TBufferJSON class, which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing such functionality: https://root.cern/js/latest/demo/update_draw.htm. This demo page reads in cycle 20 json files and displays them.; If one has a web server which already provides such JSON file, one could specify the URL to this file like:; https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz; Here the same problem with Cross-Origin Request can appear. If the web server configuration cannot be changed, just copy JSROOT to the web server itself.; 1.10.3 Binary file-based monitoring (not recommended); Theoretically, one could use binary ROOT files to implement monitoring. With such approach, a ROOT-based application creates and regularly updates content of a ROOT file, which can be accessed via normal web server. From the browser side, JSROOT could regularly read the specified objects and update their drawings. But such solution has three major caveats.; First of all, one need to store the data of all objects, which only potentially could be displayed in the browser. In case of 10 objects it does not matter, but for 1000 or 100000 objects this will be a major performance penalty. With such big amount of data one will never achieve higher update rate.; The second problem is I/O. To read the first object from the ROOT file, one need to perform several (about 5) file-reading operations via http protocol. There is no http file locking mechanism (at least not for standard web servers),",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:23945,Modifiability,config,configure,23945,"ename = ""https://root.cern/js/files/hsimple.root"";; let file = await openFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; </script>; Here the default location https://root.cern/js/latest/ is specified. One always can install JSROOT on private web server. When JSROOT is used with THttpServer, the address looks like:; <script type='module'>; import { httpRequest, draw } from 'http://your_root_server:8080/jsrootsys/modules/main.mjs';; let obj = await httpRequest('http://your_root_server:8080/Objects/hist/root.json','object');; await draw('drawing', obj, 'hist');; </script>; Loading main module is enough to get public JSROOT functionality - reading files and drawing objects. One also can load some special components directly like:; <script type='module'>; import { HierarchyPainter } from 'https://root.cern/js/latest/modules/gui.mjs';. let h = new HierarchyPainter(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; After script loading one can configure different parameters in gStyle object. It is instance of the TStyle object and behaves like gStyle variable in ROOT. For instance, to change stat format using to display value in stats box:; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; There is also settings object which contains all other JSROOT settings. For instance, one can configure custom format for different axes:; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; One also can use build/jsroot.js bundle to load all functionality at one and access it via JSROOT global handle:; <script src=""https://root.cern/js/latest/build/jsroo",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:24245,Modifiability,config,configure,24245,"specified. One always can install JSROOT on private web server. When JSROOT is used with THttpServer, the address looks like:; <script type='module'>; import { httpRequest, draw } from 'http://your_root_server:8080/jsrootsys/modules/main.mjs';; let obj = await httpRequest('http://your_root_server:8080/Objects/hist/root.json','object');; await draw('drawing', obj, 'hist');; </script>; Loading main module is enough to get public JSROOT functionality - reading files and drawing objects. One also can load some special components directly like:; <script type='module'>; import { HierarchyPainter } from 'https://root.cern/js/latest/modules/gui.mjs';. let h = new HierarchyPainter(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; After script loading one can configure different parameters in gStyle object. It is instance of the TStyle object and behaves like gStyle variable in ROOT. For instance, to change stat format using to display value in stats box:; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; There is also settings object which contains all other JSROOT settings. For instance, one can configure custom format for different axes:; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; One also can use build/jsroot.js bundle to load all functionality at one and access it via JSROOT global handle:; <script src=""https://root.cern/js/latest/build/jsroot.js""></script>; <script>; // getting json string from somewhere; let obj = JSROOT.parse(root_json);; JSROOT.draw('plain', obj, 'colz');; </script>; 1.11.2 Use of JSON; It is strongly recommended to use JSON when communicating with ROOT app",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:24354,Modifiability,variab,variable,24354,"ver, the address looks like:; <script type='module'>; import { httpRequest, draw } from 'http://your_root_server:8080/jsrootsys/modules/main.mjs';; let obj = await httpRequest('http://your_root_server:8080/Objects/hist/root.json','object');; await draw('drawing', obj, 'hist');; </script>; Loading main module is enough to get public JSROOT functionality - reading files and drawing objects. One also can load some special components directly like:; <script type='module'>; import { HierarchyPainter } from 'https://root.cern/js/latest/modules/gui.mjs';. let h = new HierarchyPainter(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; After script loading one can configure different parameters in gStyle object. It is instance of the TStyle object and behaves like gStyle variable in ROOT. For instance, to change stat format using to display value in stats box:; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; There is also settings object which contains all other JSROOT settings. For instance, one can configure custom format for different axes:; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; One also can use build/jsroot.js bundle to load all functionality at one and access it via JSROOT global handle:; <script src=""https://root.cern/js/latest/build/jsroot.js""></script>; <script>; // getting json string from somewhere; let obj = JSROOT.parse(root_json);; JSROOT.draw('plain', obj, 'colz');; </script>; 1.11.2 Use of JSON; It is strongly recommended to use JSON when communicating with ROOT application. THttpServer provides a JSON representation for every registered object with an url addr",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:24642,Modifiability,config,configure,24642," functionality - reading files and drawing objects. One also can load some special components directly like:; <script type='module'>; import { HierarchyPainter } from 'https://root.cern/js/latest/modules/gui.mjs';. let h = new HierarchyPainter(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; After script loading one can configure different parameters in gStyle object. It is instance of the TStyle object and behaves like gStyle variable in ROOT. For instance, to change stat format using to display value in stats box:; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; There is also settings object which contains all other JSROOT settings. For instance, one can configure custom format for different axes:; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; One also can use build/jsroot.js bundle to load all functionality at one and access it via JSROOT global handle:; <script src=""https://root.cern/js/latest/build/jsroot.js""></script>; <script>; // getting json string from somewhere; let obj = JSROOT.parse(root_json);; JSROOT.draw('plain', obj, 'colz');; </script>; 1.11.2 Use of JSON; It is strongly recommended to use JSON when communicating with ROOT application. THttpServer provides a JSON representation for every registered object with an url address like:; http://your_root_server:8080/Canvases/c1/root.json; Such JSON representation generated using the TBufferJSON class. One could create JSON file for any ROOT object directly, just writing in the code:; obj->SaveAs(""file.json"");; To access data from a remote web server, it is recommended to use the httpRequest method. For instance ",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:35572,Modifiability,extend,extend,35572," } from 'https://root.cern/js/7.0.0/modules/main.mjs';. It is still possible to use JSRoot.core.js script, which provides very similar (but not identical!) functionality as with v6 via global JSROOT object; JSROOT.define() and JSROOT.require() functions only available after JSRoot.core.js loading; Support of require.js and openui5 loaders was removed; Global hierarchy painter JSROOT.hpainter no longer existing, one can use getHPainter function:. import { getHPainter } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let hpainter = getHPainter();. All math functions previously available via JSROOT.Math should be imported from base/math.mjs module:. import * as math from 'https://root.cern/js/7.0.0/modules/base/math.mjs';. Indication of batch mode JSROOT.batch_mode should be accessed via functions:. import { isBatchMode, setBatchMode } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let was_batch = isBatchMode();; if (!was_batch) setBatchMode(true);. JSROOT.extend() function was removed, use Object.assign() instead. 1.11.11 Migration v5 -> v6. Main script was renamed to JSRoot.core.js. Old JSRootCore.js was deprecated and removed in v6.2. All URL parameters for main script ignored now, to load JSROOT functionality one should use JSROOT.require function. To create standard GUI, JSROOT.buildGUI function has to be used.; Instead of JSROOT.JSONR_unref() one can use JSROOT.parse(). If object is provided to JSROOT.parse() it just replaces all references which were introduced by TBufferJSON::ToJSON() method.; Instead of JSROOT.console() one should use console.log(). Instead of JSROOT.alert() one should use console.error().; Many settings were moved from JSROOT.gStyle to JSROOT.settings object. It was done to keep only TStyle-related members in JSROOT.gStyle.; Basic painter classes were renamed and made public:. JSROOT.TBasePainter -> JSROOT.BasePainter; JSROOT.TObjectPainter -> JSROOT.ObjectPainter. Internal ObjectPainter.DrawingReady api was deprecated. Draw functi",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:1269,Performance,load,loading,1269,"l ROOT files; 1.9 JSROOT with THttpServer; 1.10 Data monitoring with JSROOT; 1.11 JSROOT API. JavaScript ROOT; *** Sergey Linev GSI, Darmstadt ***; 1 JavaScript ROOT; The JSROOT project allows: - reading of binary and JSON ROOT files in JavaScript; - drawing of different ROOT classes in web browsers; - reading and drawing TTree data; - using in node.js.; 1.1 Installing JSROOT; In most practical cases it is not necessary to install JSROOT - it can be used directly from project web sites https://root.cern/js/ and https://jsroot.gsi.de/.; When required, there are following alternatives to install JSROOT on other web servers:. download and unpack provided packages (recommended); use npm package manager and invoke npm install jsroot; clone master branch from repository. 1.2 Drawing objects in JSROOT; The main page of the JSROOT project provides the possibility to interactively open ROOT files and draw objects like histogram or canvas.; To automate files loading and objects drawing, one can provide number of URL parameters in address string like:. file - name of the file, which will be automatically open with page loading; files - array of file names for loading; json - name of JSON file with stored ROOT object like histogram or canvas; item - item name to be displayed; opt - drawing option for the item; items - array of items name to be displayed; opts - array of drawing options for the items; expand - item name(s) to be expanded in the hierarchy browser; focus - item name to be focused on in the hierarchy browser; title - set browser title; dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; layout - can be ‘simple’, ‘flex’, ‘tabs’, ‘gridNxM’, ‘horizNMK’, ‘vertNMK’; browser - layout of the browser ‘fix’ (default), ‘float’, ‘no’ (hidden), ‘off’ (fully disabled); nobrowser - do not display file browser (same as browser=no); float - display floating browser (same as browser=float); status - configure status line ‘no’ (defaul",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:1432,Performance,load,loading,1432,"g in node.js.; 1.1 Installing JSROOT; In most practical cases it is not necessary to install JSROOT - it can be used directly from project web sites https://root.cern/js/ and https://jsroot.gsi.de/.; When required, there are following alternatives to install JSROOT on other web servers:. download and unpack provided packages (recommended); use npm package manager and invoke npm install jsroot; clone master branch from repository. 1.2 Drawing objects in JSROOT; The main page of the JSROOT project provides the possibility to interactively open ROOT files and draw objects like histogram or canvas.; To automate files loading and objects drawing, one can provide number of URL parameters in address string like:. file - name of the file, which will be automatically open with page loading; files - array of file names for loading; json - name of JSON file with stored ROOT object like histogram or canvas; item - item name to be displayed; opt - drawing option for the item; items - array of items name to be displayed; opts - array of drawing options for the items; expand - item name(s) to be expanded in the hierarchy browser; focus - item name to be focused on in the hierarchy browser; title - set browser title; dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; layout - can be ‘simple’, ‘flex’, ‘tabs’, ‘gridNxM’, ‘horizNMK’, ‘vertNMK’; browser - layout of the browser ‘fix’ (default), ‘float’, ‘no’ (hidden), ‘off’ (fully disabled); nobrowser - do not display file browser (same as browser=no); float - display floating browser (same as browser=float); status - configure status line ‘no’ (default), ‘off’ (completely disable), ‘size’; inject - name of extra JavaScript to load, see several examples in demo/ subdir; optimize - drawing optimization 0:off, 1:only large histograms (default), 2:always; palette - id of default color palette, 51..121 - new ROOT6 palette (default 57); interactive - enable/disable interactive functions 0 - di",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:1473,Performance,load,loading,1473,"g in node.js.; 1.1 Installing JSROOT; In most practical cases it is not necessary to install JSROOT - it can be used directly from project web sites https://root.cern/js/ and https://jsroot.gsi.de/.; When required, there are following alternatives to install JSROOT on other web servers:. download and unpack provided packages (recommended); use npm package manager and invoke npm install jsroot; clone master branch from repository. 1.2 Drawing objects in JSROOT; The main page of the JSROOT project provides the possibility to interactively open ROOT files and draw objects like histogram or canvas.; To automate files loading and objects drawing, one can provide number of URL parameters in address string like:. file - name of the file, which will be automatically open with page loading; files - array of file names for loading; json - name of JSON file with stored ROOT object like histogram or canvas; item - item name to be displayed; opt - drawing option for the item; items - array of items name to be displayed; opts - array of drawing options for the items; expand - item name(s) to be expanded in the hierarchy browser; focus - item name to be focused on in the hierarchy browser; title - set browser title; dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; layout - can be ‘simple’, ‘flex’, ‘tabs’, ‘gridNxM’, ‘horizNMK’, ‘vertNMK’; browser - layout of the browser ‘fix’ (default), ‘float’, ‘no’ (hidden), ‘off’ (fully disabled); nobrowser - do not display file browser (same as browser=no); float - display floating browser (same as browser=float); status - configure status line ‘no’ (default), ‘off’ (completely disable), ‘size’; inject - name of extra JavaScript to load, see several examples in demo/ subdir; optimize - drawing optimization 0:off, 1:only large histograms (default), 2:always; palette - id of default color palette, 51..121 - new ROOT6 palette (default 57); interactive - enable/disable interactive functions 0 - di",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:2383,Performance,load,load,2383,"anvas.; To automate files loading and objects drawing, one can provide number of URL parameters in address string like:. file - name of the file, which will be automatically open with page loading; files - array of file names for loading; json - name of JSON file with stored ROOT object like histogram or canvas; item - item name to be displayed; opt - drawing option for the item; items - array of items name to be displayed; opts - array of drawing options for the items; expand - item name(s) to be expanded in the hierarchy browser; focus - item name to be focused on in the hierarchy browser; title - set browser title; dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; layout - can be ‘simple’, ‘flex’, ‘tabs’, ‘gridNxM’, ‘horizNMK’, ‘vertNMK’; browser - layout of the browser ‘fix’ (default), ‘float’, ‘no’ (hidden), ‘off’ (fully disabled); nobrowser - do not display file browser (same as browser=no); float - display floating browser (same as browser=float); status - configure status line ‘no’ (default), ‘off’ (completely disable), ‘size’; inject - name of extra JavaScript to load, see several examples in demo/ subdir; optimize - drawing optimization 0:off, 1:only large histograms (default), 2:always; palette - id of default color palette, 51..121 - new ROOT6 palette (default 57); interactive - enable/disable interactive functions 0 - disable all, 1 - enable all; noselect - hide file-selection part in the browser (only when file name is specified); mathjax - use MathJax for latex output; latex - ‘off’, ‘symbols’, ‘normal’, ‘mathjax’, ‘alwaysmath’ control of TLatex processor; style - name of TStyle object to define global JSROOT style; toolbar - show canvas tool buttons ‘off’, ‘on’ and ‘popup’, ‘left’ or ‘right’ for position, ‘vert’ for vertical; divsize - fixed size in pixels for main div element like &dvisize=1500x800; canvsize - default canvas size in pixels like &canvsize=1200x800; optstat - settings for stat box, def",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:2427,Performance,optimiz,optimize,2427,"anvas.; To automate files loading and objects drawing, one can provide number of URL parameters in address string like:. file - name of the file, which will be automatically open with page loading; files - array of file names for loading; json - name of JSON file with stored ROOT object like histogram or canvas; item - item name to be displayed; opt - drawing option for the item; items - array of items name to be displayed; opts - array of drawing options for the items; expand - item name(s) to be expanded in the hierarchy browser; focus - item name to be focused on in the hierarchy browser; title - set browser title; dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; layout - can be ‘simple’, ‘flex’, ‘tabs’, ‘gridNxM’, ‘horizNMK’, ‘vertNMK’; browser - layout of the browser ‘fix’ (default), ‘float’, ‘no’ (hidden), ‘off’ (fully disabled); nobrowser - do not display file browser (same as browser=no); float - display floating browser (same as browser=float); status - configure status line ‘no’ (default), ‘off’ (completely disable), ‘size’; inject - name of extra JavaScript to load, see several examples in demo/ subdir; optimize - drawing optimization 0:off, 1:only large histograms (default), 2:always; palette - id of default color palette, 51..121 - new ROOT6 palette (default 57); interactive - enable/disable interactive functions 0 - disable all, 1 - enable all; noselect - hide file-selection part in the browser (only when file name is specified); mathjax - use MathJax for latex output; latex - ‘off’, ‘symbols’, ‘normal’, ‘mathjax’, ‘alwaysmath’ control of TLatex processor; style - name of TStyle object to define global JSROOT style; toolbar - show canvas tool buttons ‘off’, ‘on’ and ‘popup’, ‘left’ or ‘right’ for position, ‘vert’ for vertical; divsize - fixed size in pixels for main div element like &dvisize=1500x800; canvsize - default canvas size in pixels like &canvsize=1200x800; optstat - settings for stat box, def",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:2446,Performance,optimiz,optimization,2446,"anvas.; To automate files loading and objects drawing, one can provide number of URL parameters in address string like:. file - name of the file, which will be automatically open with page loading; files - array of file names for loading; json - name of JSON file with stored ROOT object like histogram or canvas; item - item name to be displayed; opt - drawing option for the item; items - array of items name to be displayed; opts - array of drawing options for the items; expand - item name(s) to be expanded in the hierarchy browser; focus - item name to be focused on in the hierarchy browser; title - set browser title; dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; layout - can be ‘simple’, ‘flex’, ‘tabs’, ‘gridNxM’, ‘horizNMK’, ‘vertNMK’; browser - layout of the browser ‘fix’ (default), ‘float’, ‘no’ (hidden), ‘off’ (fully disabled); nobrowser - do not display file browser (same as browser=no); float - display floating browser (same as browser=float); status - configure status line ‘no’ (default), ‘off’ (completely disable), ‘size’; inject - name of extra JavaScript to load, see several examples in demo/ subdir; optimize - drawing optimization 0:off, 1:only large histograms (default), 2:always; palette - id of default color palette, 51..121 - new ROOT6 palette (default 57); interactive - enable/disable interactive functions 0 - disable all, 1 - enable all; noselect - hide file-selection part in the browser (only when file name is specified); mathjax - use MathJax for latex output; latex - ‘off’, ‘symbols’, ‘normal’, ‘mathjax’, ‘alwaysmath’ control of TLatex processor; style - name of TStyle object to define global JSROOT style; toolbar - show canvas tool buttons ‘off’, ‘on’ and ‘popup’, ‘left’ or ‘right’ for position, ‘vert’ for vertical; divsize - fixed size in pixels for main div element like &dvisize=1500x800; canvsize - default canvas size in pixels like &canvsize=1200x800; optstat - settings for stat box, def",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:18258,Performance,load,loading,18258,"ge,content-length,accept-ranges""; Header set Access-Control-Allow-Methods ""GET""; </FilesMatch>; </IfModule>; More details about configuring of CORS headers can be found here.; Alternative - enable CORS requests in the browser. It can be easily done with CORS Everywhere plugin for the Firefox browser or Allow CORS plugin for the Chrome browser.; Next solution - install JSROOT on the server hosting ROOT files. In such configuration JSROOT does not issue CORS requests, therefore server and browsers can be used with their default settings. A simplified variant of such solution - copy only the top index.htm file from JSROOT package and specify the full path to modules/gui.mjs script like:; <script type=""module"">; import { openFile, draw } from 'https://root.cern/js/latest/modules/gui.mjs';; // ...; </script>; In the main <div> element one can specify many custom parameters like one do it in URL string:; <div id=""simpleGUI"" path=""files/path"" files=""userfile1.root;subdir/usefile2.root"">; loading scripts ...; </div>; 1.8 Reading local ROOT files; JSROOT can read files from local file system using HTML5 FileReader functionality. Main limitation here - user should interactively select files for reading. There is button “…” on the main JSROOT page, which starts file selection dialog. If valid ROOT file is selected, JSROOT will be able to normally read content of such file.; 1.9 JSROOT with THttpServer; THttpServer provides http access to objects from running ROOT application. JSROOT is used to implement the user interface in the web browsers.; The layout of the main page coming from THttpServer is very similar to normal JSROOT page. One could browse existing items and display them. A snapshot of running server can be seen on the demo page.; One could also specify similar URL parameters to configure the displayed items and drawing options.; It is also possible to display one single item from the THttpServer server like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/h",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:21510,Performance,perform,performance,21510,"page reads in cycle 20 json files and displays them.; If one has a web server which already provides such JSON file, one could specify the URL to this file like:; https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz; Here the same problem with Cross-Origin Request can appear. If the web server configuration cannot be changed, just copy JSROOT to the web server itself.; 1.10.3 Binary file-based monitoring (not recommended); Theoretically, one could use binary ROOT files to implement monitoring. With such approach, a ROOT-based application creates and regularly updates content of a ROOT file, which can be accessed via normal web server. From the browser side, JSROOT could regularly read the specified objects and update their drawings. But such solution has three major caveats.; First of all, one need to store the data of all objects, which only potentially could be displayed in the browser. In case of 10 objects it does not matter, but for 1000 or 100000 objects this will be a major performance penalty. With such big amount of data one will never achieve higher update rate.; The second problem is I/O. To read the first object from the ROOT file, one need to perform several (about 5) file-reading operations via http protocol. There is no http file locking mechanism (at least not for standard web servers), therefore there is no guarantee that the file content is not changed/replaced between consequent read operations. Therefore, one should expect frequent I/O failures while trying to monitor data from ROOT binary files. There is a workaround for the problem - one could load the file completely and exclude many partial I/O operations by this. To achieve this with JSROOT, one should add “+” sign at the end of the file name. Of course, it only could work for small files.; If somebody still wants to use monitoring of data from ROOT files, could try link like:. https://root.cern/js/latest/?nobrowser&file=../files/hsimple.root+&item=hp",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:21688,Performance,perform,perform,21688,"ttpserver.C/Canvases/c1/root.json.gz; Here the same problem with Cross-Origin Request can appear. If the web server configuration cannot be changed, just copy JSROOT to the web server itself.; 1.10.3 Binary file-based monitoring (not recommended); Theoretically, one could use binary ROOT files to implement monitoring. With such approach, a ROOT-based application creates and regularly updates content of a ROOT file, which can be accessed via normal web server. From the browser side, JSROOT could regularly read the specified objects and update their drawings. But such solution has three major caveats.; First of all, one need to store the data of all objects, which only potentially could be displayed in the browser. In case of 10 objects it does not matter, but for 1000 or 100000 objects this will be a major performance penalty. With such big amount of data one will never achieve higher update rate.; The second problem is I/O. To read the first object from the ROOT file, one need to perform several (about 5) file-reading operations via http protocol. There is no http file locking mechanism (at least not for standard web servers), therefore there is no guarantee that the file content is not changed/replaced between consequent read operations. Therefore, one should expect frequent I/O failures while trying to monitor data from ROOT binary files. There is a workaround for the problem - one could load the file completely and exclude many partial I/O operations by this. To achieve this with JSROOT, one should add “+” sign at the end of the file name. Of course, it only could work for small files.; If somebody still wants to use monitoring of data from ROOT files, could try link like:. https://root.cern/js/latest/?nobrowser&file=../files/hsimple.root+&item=hpx;1&monitoring=2000. In this particular case, the histogram is not changing.; 1.11 JSROOT API; JSROOT can be used in arbitrary HTML pages to display data, produced with or without ROOT-based applications.; Many different",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:22106,Performance,load,load,22106," can be accessed via normal web server. From the browser side, JSROOT could regularly read the specified objects and update their drawings. But such solution has three major caveats.; First of all, one need to store the data of all objects, which only potentially could be displayed in the browser. In case of 10 objects it does not matter, but for 1000 or 100000 objects this will be a major performance penalty. With such big amount of data one will never achieve higher update rate.; The second problem is I/O. To read the first object from the ROOT file, one need to perform several (about 5) file-reading operations via http protocol. There is no http file locking mechanism (at least not for standard web servers), therefore there is no guarantee that the file content is not changed/replaced between consequent read operations. Therefore, one should expect frequent I/O failures while trying to monitor data from ROOT binary files. There is a workaround for the problem - one could load the file completely and exclude many partial I/O operations by this. To achieve this with JSROOT, one should add “+” sign at the end of the file name. Of course, it only could work for small files.; If somebody still wants to use monitoring of data from ROOT files, could try link like:. https://root.cern/js/latest/?nobrowser&file=../files/hsimple.root+&item=hpx;1&monitoring=2000. In this particular case, the histogram is not changing.; 1.11 JSROOT API; JSROOT can be used in arbitrary HTML pages to display data, produced with or without ROOT-based applications.; Many different examples of JSROOT API usage can be found on JSROOT API examples page.; 1.11.1 Import JSROOT functionality; Major JSROOT functions are located in main.mjs module and can be imported like:; <script type='module'>; import { openFile, draw } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/hsimple.root"";; let file = await openFile(filename);; let obj = await file.readObject(""",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:23737,Performance,load,load,23737,"unctionality; Major JSROOT functions are located in main.mjs module and can be imported like:; <script type='module'>; import { openFile, draw } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/hsimple.root"";; let file = await openFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; </script>; Here the default location https://root.cern/js/latest/ is specified. One always can install JSROOT on private web server. When JSROOT is used with THttpServer, the address looks like:; <script type='module'>; import { httpRequest, draw } from 'http://your_root_server:8080/jsrootsys/modules/main.mjs';; let obj = await httpRequest('http://your_root_server:8080/Objects/hist/root.json','object');; await draw('drawing', obj, 'hist');; </script>; Loading main module is enough to get public JSROOT functionality - reading files and drawing objects. One also can load some special components directly like:; <script type='module'>; import { HierarchyPainter } from 'https://root.cern/js/latest/modules/gui.mjs';. let h = new HierarchyPainter(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; After script loading one can configure different parameters in gStyle object. It is instance of the TStyle object and behaves like gStyle variable in ROOT. For instance, to change stat format using to display value in stats box:; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; There is also settings object which contains all other JSROOT settings. For instance, one can configure custom format for different axes:; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:24229,Performance,load,loading,24229,"specified. One always can install JSROOT on private web server. When JSROOT is used with THttpServer, the address looks like:; <script type='module'>; import { httpRequest, draw } from 'http://your_root_server:8080/jsrootsys/modules/main.mjs';; let obj = await httpRequest('http://your_root_server:8080/Objects/hist/root.json','object');; await draw('drawing', obj, 'hist');; </script>; Loading main module is enough to get public JSROOT functionality - reading files and drawing objects. One also can load some special components directly like:; <script type='module'>; import { HierarchyPainter } from 'https://root.cern/js/latest/modules/gui.mjs';. let h = new HierarchyPainter(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; After script loading one can configure different parameters in gStyle object. It is instance of the TStyle object and behaves like gStyle variable in ROOT. For instance, to change stat format using to display value in stats box:; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; There is also settings object which contains all other JSROOT settings. For instance, one can configure custom format for different axes:; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; One also can use build/jsroot.js bundle to load all functionality at one and access it via JSROOT global handle:; <script src=""https://root.cern/js/latest/build/jsroot.js""></script>; <script>; // getting json string from somewhere; let obj = JSROOT.parse(root_json);; JSROOT.draw('plain', obj, 'colz');; </script>; 1.11.2 Use of JSON; It is strongly recommended to use JSON when communicating with ROOT app",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:24872,Performance,load,load,24872,"r(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; After script loading one can configure different parameters in gStyle object. It is instance of the TStyle object and behaves like gStyle variable in ROOT. For instance, to change stat format using to display value in stats box:; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; There is also settings object which contains all other JSROOT settings. For instance, one can configure custom format for different axes:; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; One also can use build/jsroot.js bundle to load all functionality at one and access it via JSROOT global handle:; <script src=""https://root.cern/js/latest/build/jsroot.js""></script>; <script>; // getting json string from somewhere; let obj = JSROOT.parse(root_json);; JSROOT.draw('plain', obj, 'colz');; </script>; 1.11.2 Use of JSON; It is strongly recommended to use JSON when communicating with ROOT application. THttpServer provides a JSON representation for every registered object with an url address like:; http://your_root_server:8080/Canvases/c1/root.json; Such JSON representation generated using the TBufferJSON class. One could create JSON file for any ROOT object directly, just writing in the code:; obj->SaveAs(""file.json"");; To access data from a remote web server, it is recommended to use the httpRequest method. For instance to receive object from a THttpServer server one could do:; import { httpRequest } from 'https://root.cern/js/latest/modules/main.mjs';; let obj = await httpRequest(""http://your_root_server:8080/Canvases/c1/root.json"", ""object""); console.log(",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:26587,Performance,perform,performed,26587," code:; obj->SaveAs(""file.json"");; To access data from a remote web server, it is recommended to use the httpRequest method. For instance to receive object from a THttpServer server one could do:; import { httpRequest } from 'https://root.cern/js/latest/modules/main.mjs';; let obj = await httpRequest(""http://your_root_server:8080/Canvases/c1/root.json"", ""object""); console.log('Read object of type', obj._typename);; Function returns Promise, which provides parsed object (or Error in case of failure).; If JSON string was obtained by different method, it could be parsed with parse function:; import { parse } from 'https://root.cern/js/latest/modules/main.mjs';; let obj = parse(json_string);; 1.11.3 Objects drawing; After an object has been created, one can directly draw it. If HTML page has <div> element:; <div id=""drawing""></div>; One could use the draw function:; import { draw } from 'https://root.cern/js/latest/modules/main.mjs';; draw(""drawing"", obj, ""colz"");; The first argument is the id of the HTML div element, where drawing will be performed. The second argument is the object to draw and the third one is the drawing option.; Here is complete running example ans source code:; import { httpRequest, draw, redraw, resize, cleanup } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/th2ul.json.gz"";; let obj = await httpRequest(filename, 'object');; draw(""drawing"", obj, ""lego"");; In very seldom cases one need to access painter object, created in draw() function. This can be done via handling Promise results like:; let painter = await draw(""drawing"", obj, ""colz"");; console.log('Object type in painter', painter.getClassName());; One is also able to update the drawing with a new version of the object:; // after some interval request object again; redraw(""drawing"", obj2, ""colz"");; The redraw function will call draw if the drawing was not performed before.; In the case when changing of HTML layout leads to resize of element wit",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:27445,Performance,perform,performed,27445," element:; <div id=""drawing""></div>; One could use the draw function:; import { draw } from 'https://root.cern/js/latest/modules/main.mjs';; draw(""drawing"", obj, ""colz"");; The first argument is the id of the HTML div element, where drawing will be performed. The second argument is the object to draw and the third one is the drawing option.; Here is complete running example ans source code:; import { httpRequest, draw, redraw, resize, cleanup } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/th2ul.json.gz"";; let obj = await httpRequest(filename, 'object');; draw(""drawing"", obj, ""lego"");; In very seldom cases one need to access painter object, created in draw() function. This can be done via handling Promise results like:; let painter = await draw(""drawing"", obj, ""colz"");; console.log('Object type in painter', painter.getClassName());; One is also able to update the drawing with a new version of the object:; // after some interval request object again; redraw(""drawing"", obj2, ""colz"");; The redraw function will call draw if the drawing was not performed before.; In the case when changing of HTML layout leads to resize of element with JSROOT drawing, one should call resize() to let JSROOT adjust drawing size. One should do:; resize(""drawing"");; As second argument one could specify exact size for draw elements like:; resize(""drawing"", { width: 500, height: 200 });; To correctly cleanup JSROOT drawings from HTML element, one should call:; cleanup(""drawing"");; 1.11.4 File API; JSROOT defines the TFile class, which can be used to access binary ROOT files. One should always remember that all I/O operations are asynchronous in JSROOT. Therefore promises are used to retrieve results when the I/O operation is completed. For example, reading an object from a file and displaying it will look like:; import { openFile, draw } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/hsimple.root",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:28593,Performance,perform,performed,28593,"ng size. One should do:; resize(""drawing"");; As second argument one could specify exact size for draw elements like:; resize(""drawing"", { width: 500, height: 200 });; To correctly cleanup JSROOT drawings from HTML element, one should call:; cleanup(""drawing"");; 1.11.4 File API; JSROOT defines the TFile class, which can be used to access binary ROOT files. One should always remember that all I/O operations are asynchronous in JSROOT. Therefore promises are used to retrieve results when the I/O operation is completed. For example, reading an object from a file and displaying it will look like:; import { openFile, draw } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/hsimple.root"";; let file = await openFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; console.log('drawing completed');; Here is running example and source code; 1.11.5 TTree API; Simple TTree::Draw operation can be performed with following code:; import { openFile } from 'https://root.cern/js/latest/modules/io.mjs';; import { draw } from 'https://root.cern/js/latest/modules/draw.mjs';; let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let tree = await file.readObject(""ntuple;1"");; draw(""drawing"", tree, ""px:py::pz>5"");; To get access to selected branches, one should use TSelector class:; import { openFile } from 'https://root.cern/js/latest/modules/io.mjs';; import { draw } from 'https://root.cern/js/latest/modules/draw.mjs';; import { TSelector, treeProcess } from 'https://root.cern/js/latest/modules/tree.mjs';. let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let tree = await file.readObject(""ntuple;1"");; let selector = new TSelector();. selector.AddBranch(""px"");; selector.AddBranch(""py"");. let cnt = 0, sumpx = 0, sumpy = 0;. selector.Begin = function() {; // function called before reading of TTree starts; }. selector.Process = function() {; // function called for",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:33541,Performance,load,load,33541,"0, height: 800 });; writeFileSync(""lego2.svg"", svg);; It is also possible to convert any JavaScript object into ROOT JSON string, using toJSON() function. Like:; import { toJSON, openFile, makeSVG } from 'jsroot';; import { writeFileSync } from 'fs';. let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let obj = await file.readObject(""hpx;1"");; let json = await toJSON(obj);; writrFileSync(""hpxpy.json"", json);; Such JSON string could be parsed by any other JSROOT-based application.; When WebGL rendering is used (lego plots or TGeo drawing), on the Linux one need to have DISPLAY correctly set to make it working. To run JSROOT on headless machine, one have to use xvfb-run utility, see also here:; [shell] xvfb-run -s ""-ac -screen 0 1280x1024x24"" node geomsvg.js; 1.11.9 Use with OpenUI5; OpenUI5 is a web toolkit for developers to ease and speed up the development of full-blown HTML5 web applications. JSROOT provides loadOpenui5 function to load supported OpenUI5:; <script type=""module"">; import { loadOpenui5 } from 'path_to_jsroot/modules/main.mjs';; let sap = await loadOpenui5();; sap.registerModulePath(""NavExample"", ""./"");; new sap.m.App ({; pages: [; new sap.m.Page({; title: ""Nav Container"",; enableScrolling : true,; content: [ new sap.ui.core.ComponentContainer({ name : ""NavExample"" })]; }); ]; }).placeAt(""content"");; </script>; JSROOT uses https://openui5.hana.ondemand.com/1.128.0/ when no other source is specified.; There are small details when using OpenUI5 with THttpServer. First of all, location of JSROOT modules should be specified as /jsrootsys/modules/main.mjs. And then trying to access files from local disk, one should specify /currentdir/ folder:; jQuery.sap.registerModulePath(""NavExample"", ""/currentdir/"");; JSROOT provides example showing usage of JSROOT drawing in the OpenUI5, source code can be found in repository.; 1.11.10 Migration v6 -> v7. Core functionality should be imported from main.mjs module like:. import { create, parse, crea",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:34883,Performance,load,loading,34883,"})]; }); ]; }).placeAt(""content"");; </script>; JSROOT uses https://openui5.hana.ondemand.com/1.128.0/ when no other source is specified.; There are small details when using OpenUI5 with THttpServer. First of all, location of JSROOT modules should be specified as /jsrootsys/modules/main.mjs. And then trying to access files from local disk, one should specify /currentdir/ folder:; jQuery.sap.registerModulePath(""NavExample"", ""/currentdir/"");; JSROOT provides example showing usage of JSROOT drawing in the OpenUI5, source code can be found in repository.; 1.11.10 Migration v6 -> v7. Core functionality should be imported from main.mjs module like:. import { create, parse, createHistogram, redraw } from 'https://root.cern/js/7.0.0/modules/main.mjs';. It is still possible to use JSRoot.core.js script, which provides very similar (but not identical!) functionality as with v6 via global JSROOT object; JSROOT.define() and JSROOT.require() functions only available after JSRoot.core.js loading; Support of require.js and openui5 loaders was removed; Global hierarchy painter JSROOT.hpainter no longer existing, one can use getHPainter function:. import { getHPainter } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let hpainter = getHPainter();. All math functions previously available via JSROOT.Math should be imported from base/math.mjs module:. import * as math from 'https://root.cern/js/7.0.0/modules/base/math.mjs';. Indication of batch mode JSROOT.batch_mode should be accessed via functions:. import { isBatchMode, setBatchMode } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let was_batch = isBatchMode();; if (!was_batch) setBatchMode(true);. JSROOT.extend() function was removed, use Object.assign() instead. 1.11.11 Migration v5 -> v6. Main script was renamed to JSRoot.core.js. Old JSRootCore.js was deprecated and removed in v6.2. All URL parameters for main script ignored now, to load JSROOT functionality one should use JSROOT.require function. To create standard GUI",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:34926,Performance,load,loaders,34926,"OOT uses https://openui5.hana.ondemand.com/1.128.0/ when no other source is specified.; There are small details when using OpenUI5 with THttpServer. First of all, location of JSROOT modules should be specified as /jsrootsys/modules/main.mjs. And then trying to access files from local disk, one should specify /currentdir/ folder:; jQuery.sap.registerModulePath(""NavExample"", ""/currentdir/"");; JSROOT provides example showing usage of JSROOT drawing in the OpenUI5, source code can be found in repository.; 1.11.10 Migration v6 -> v7. Core functionality should be imported from main.mjs module like:. import { create, parse, createHistogram, redraw } from 'https://root.cern/js/7.0.0/modules/main.mjs';. It is still possible to use JSRoot.core.js script, which provides very similar (but not identical!) functionality as with v6 via global JSROOT object; JSROOT.define() and JSROOT.require() functions only available after JSRoot.core.js loading; Support of require.js and openui5 loaders was removed; Global hierarchy painter JSROOT.hpainter no longer existing, one can use getHPainter function:. import { getHPainter } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let hpainter = getHPainter();. All math functions previously available via JSROOT.Math should be imported from base/math.mjs module:. import * as math from 'https://root.cern/js/7.0.0/modules/base/math.mjs';. Indication of batch mode JSROOT.batch_mode should be accessed via functions:. import { isBatchMode, setBatchMode } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let was_batch = isBatchMode();; if (!was_batch) setBatchMode(true);. JSROOT.extend() function was removed, use Object.assign() instead. 1.11.11 Migration v5 -> v6. Main script was renamed to JSRoot.core.js. Old JSRootCore.js was deprecated and removed in v6.2. All URL parameters for main script ignored now, to load JSROOT functionality one should use JSROOT.require function. To create standard GUI, JSROOT.buildGUI function has to be used.; Inste",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:35808,Performance,load,load,35808,".define() and JSROOT.require() functions only available after JSRoot.core.js loading; Support of require.js and openui5 loaders was removed; Global hierarchy painter JSROOT.hpainter no longer existing, one can use getHPainter function:. import { getHPainter } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let hpainter = getHPainter();. All math functions previously available via JSROOT.Math should be imported from base/math.mjs module:. import * as math from 'https://root.cern/js/7.0.0/modules/base/math.mjs';. Indication of batch mode JSROOT.batch_mode should be accessed via functions:. import { isBatchMode, setBatchMode } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let was_batch = isBatchMode();; if (!was_batch) setBatchMode(true);. JSROOT.extend() function was removed, use Object.assign() instead. 1.11.11 Migration v5 -> v6. Main script was renamed to JSRoot.core.js. Old JSRootCore.js was deprecated and removed in v6.2. All URL parameters for main script ignored now, to load JSROOT functionality one should use JSROOT.require function. To create standard GUI, JSROOT.buildGUI function has to be used.; Instead of JSROOT.JSONR_unref() one can use JSROOT.parse(). If object is provided to JSROOT.parse() it just replaces all references which were introduced by TBufferJSON::ToJSON() method.; Instead of JSROOT.console() one should use console.log(). Instead of JSROOT.alert() one should use console.error().; Many settings were moved from JSROOT.gStyle to JSROOT.settings object. It was done to keep only TStyle-related members in JSROOT.gStyle.; Basic painter classes were renamed and made public:. JSROOT.TBasePainter -> JSROOT.BasePainter; JSROOT.TObjectPainter -> JSROOT.ObjectPainter. Internal ObjectPainter.DrawingReady api was deprecated. Draw function has to return Promise if object drawing postponed. As argument of returned promise object painter has to be used.; Many function names where adjusted to naming conventions. Like:. JSROOT.CreateHistogram -> JSRO",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:15361,Safety,detect,detectors,15361,"’.; Another way to configure visibility flags is usage of ROOT macros, which typically looks like:; {; TGeoManager::Import(""http://root.cern/files/alice2.root"");; gGeoManager->DefaultColors();; // gGeoManager->SetVisLevel(4);; gGeoManager->GetVolume(""HALL"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCC"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCA"")->InvisibleAll();; // ...; gGeoManager->GetVolume(""ALIC"")->Draw(""ogl"");; new TBrowser;; }; Example of such macro can be found in root tutorials.; From provided macro only following calls will be executed in JSROOT:. gGeoManager->DefaultColors(); gGeoManager->GetVolume(""HALL"")->InvisibleAll(); gGeoManager->GetVolume(""HALL"")->SetTransparency(30); gGeoManager->GetVolume(""HALL"")->SetLineColor(5); gGeoManager->GetVolume(""ALIC"")->Draw(""ogl""). All other will be ignored.; Example of major LHC detectors: * ALICE: full * ATLAS: full, cryo, sctt * CMS: cmse, calo * LHCb: full; Other detectors examples: * HADES: full, preselected * BABAR: full, emca * STAR: full, svtt * D0: full * NA47: full * BRAHMS: full * SLD: full; Together with geometry one could display tracks (TEveTrack) and hits (TEvePointSet, TPolyMarker3D) objects. Either one do it interactively by drag and drop, or superimpose drawing with + sign like:. item=simple_alice.json.gz+tracks_hits.root/tracks+tracks_hits.root/hits. There is a problem of correct rendering of transparent volumes. To solve problem in general is very expensive (in terms of computing power), therefore several approximation solution can be applied: * dpnt: distance from camera view to the volume center used as rendering order * dbox: distance to nearest point from bonding box used as rendering order (default) * dsize: volume size is used as rendering order, can be used for centered volumes with many shells around * dray: use raycasting to sort volumes in order they appear along rays, coming out of camera point * ddflt: default three.js method for rendering transparent volumes For different geometrie",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:15450,Safety,detect,detectors,15450,"’.; Another way to configure visibility flags is usage of ROOT macros, which typically looks like:; {; TGeoManager::Import(""http://root.cern/files/alice2.root"");; gGeoManager->DefaultColors();; // gGeoManager->SetVisLevel(4);; gGeoManager->GetVolume(""HALL"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCC"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCA"")->InvisibleAll();; // ...; gGeoManager->GetVolume(""ALIC"")->Draw(""ogl"");; new TBrowser;; }; Example of such macro can be found in root tutorials.; From provided macro only following calls will be executed in JSROOT:. gGeoManager->DefaultColors(); gGeoManager->GetVolume(""HALL"")->InvisibleAll(); gGeoManager->GetVolume(""HALL"")->SetTransparency(30); gGeoManager->GetVolume(""HALL"")->SetLineColor(5); gGeoManager->GetVolume(""ALIC"")->Draw(""ogl""). All other will be ignored.; Example of major LHC detectors: * ALICE: full * ATLAS: full, cryo, sctt * CMS: cmse, calo * LHCb: full; Other detectors examples: * HADES: full, preselected * BABAR: full, emca * STAR: full, svtt * D0: full * NA47: full * BRAHMS: full * SLD: full; Together with geometry one could display tracks (TEveTrack) and hits (TEvePointSet, TPolyMarker3D) objects. Either one do it interactively by drag and drop, or superimpose drawing with + sign like:. item=simple_alice.json.gz+tracks_hits.root/tracks+tracks_hits.root/hits. There is a problem of correct rendering of transparent volumes. To solve problem in general is very expensive (in terms of computing power), therefore several approximation solution can be applied: * dpnt: distance from camera view to the volume center used as rendering order * dbox: distance to nearest point from bonding box used as rendering order (default) * dsize: volume size is used as rendering order, can be used for centered volumes with many shells around * dray: use raycasting to sort volumes in order they appear along rays, coming out of camera point * ddflt: default three.js method for rendering transparent volumes For different geometrie",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:2346,Security,inject,inject,2346,"anvas.; To automate files loading and objects drawing, one can provide number of URL parameters in address string like:. file - name of the file, which will be automatically open with page loading; files - array of file names for loading; json - name of JSON file with stored ROOT object like histogram or canvas; item - item name to be displayed; opt - drawing option for the item; items - array of items name to be displayed; opts - array of drawing options for the items; expand - item name(s) to be expanded in the hierarchy browser; focus - item name to be focused on in the hierarchy browser; title - set browser title; dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; layout - can be ‘simple’, ‘flex’, ‘tabs’, ‘gridNxM’, ‘horizNMK’, ‘vertNMK’; browser - layout of the browser ‘fix’ (default), ‘float’, ‘no’ (hidden), ‘off’ (fully disabled); nobrowser - do not display file browser (same as browser=no); float - display floating browser (same as browser=float); status - configure status line ‘no’ (default), ‘off’ (completely disable), ‘size’; inject - name of extra JavaScript to load, see several examples in demo/ subdir; optimize - drawing optimization 0:off, 1:only large histograms (default), 2:always; palette - id of default color palette, 51..121 - new ROOT6 palette (default 57); interactive - enable/disable interactive functions 0 - disable all, 1 - enable all; noselect - hide file-selection part in the browser (only when file name is specified); mathjax - use MathJax for latex output; latex - ‘off’, ‘symbols’, ‘normal’, ‘mathjax’, ‘alwaysmath’ control of TLatex processor; style - name of TStyle object to define global JSROOT style; toolbar - show canvas tool buttons ‘off’, ‘on’ and ‘popup’, ‘left’ or ‘right’ for position, ‘vert’ for vertical; divsize - fixed size in pixels for main div element like &dvisize=1500x800; canvsize - default canvas size in pixels like &canvsize=1200x800; optstat - settings for stat box, def",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:18703,Security,access,access,18703,"OT does not issue CORS requests, therefore server and browsers can be used with their default settings. A simplified variant of such solution - copy only the top index.htm file from JSROOT package and specify the full path to modules/gui.mjs script like:; <script type=""module"">; import { openFile, draw } from 'https://root.cern/js/latest/modules/gui.mjs';; // ...; </script>; In the main <div> element one can specify many custom parameters like one do it in URL string:; <div id=""simpleGUI"" path=""files/path"" files=""userfile1.root;subdir/usefile2.root"">; loading scripts ...; </div>; 1.8 Reading local ROOT files; JSROOT can read files from local file system using HTML5 FileReader functionality. Main limitation here - user should interactively select files for reading. There is button “…” on the main JSROOT page, which starts file selection dialog. If valid ROOT file is selected, JSROOT will be able to normally read content of such file.; 1.9 JSROOT with THttpServer; THttpServer provides http access to objects from running ROOT application. JSROOT is used to implement the user interface in the web browsers.; The layout of the main page coming from THttpServer is very similar to normal JSROOT page. One could browse existing items and display them. A snapshot of running server can be seen on the demo page.; One could also specify similar URL parameters to configure the displayed items and drawing options.; It is also possible to display one single item from the THttpServer server like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz; 1.10 Data monitoring with JSROOT; 1.10.1 Monitoring with http server; The best possibility to organize the monitoring of data from a running application is to use THttpServer. In such case the client can always access the latest changes and request only the items currently displayed in the browser. To enable monitoring, one should activate the appropriate checkbox or provide monitoring parameter in the URL stri",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:19498,Security,access,access,19498,"h starts file selection dialog. If valid ROOT file is selected, JSROOT will be able to normally read content of such file.; 1.9 JSROOT with THttpServer; THttpServer provides http access to objects from running ROOT application. JSROOT is used to implement the user interface in the web browsers.; The layout of the main page coming from THttpServer is very similar to normal JSROOT page. One could browse existing items and display them. A snapshot of running server can be seen on the demo page.; One could also specify similar URL parameters to configure the displayed items and drawing options.; It is also possible to display one single item from the THttpServer server like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz; 1.10 Data monitoring with JSROOT; 1.10.1 Monitoring with http server; The best possibility to organize the monitoring of data from a running application is to use THttpServer. In such case the client can always access the latest changes and request only the items currently displayed in the browser. To enable monitoring, one should activate the appropriate checkbox or provide monitoring parameter in the URL string like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hprof/draw.htm?monitoring=1000; The parameter value is the update interval in milliseconds.; 1.10.2 JSON file-based monitoring; Solid file-based monitoring (without integration of THttpServer into application) can be implemented in JSON format. There is the TBufferJSON class, which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing such functionality: https://root.cern/js/latest/demo/update_draw.htm. This demo page reads in cycle 20 json files and displays them.",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:20247,Security,access,accessed,20247,"erver like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz; 1.10 Data monitoring with JSROOT; 1.10.1 Monitoring with http server; The best possibility to organize the monitoring of data from a running application is to use THttpServer. In such case the client can always access the latest changes and request only the items currently displayed in the browser. To enable monitoring, one should activate the appropriate checkbox or provide monitoring parameter in the URL string like:; https://root.cern/js/latest/httpserver.C/Files/job1.root/hprof/draw.htm?monitoring=1000; The parameter value is the update interval in milliseconds.; 1.10.2 JSON file-based monitoring; Solid file-based monitoring (without integration of THttpServer into application) can be implemented in JSON format. There is the TBufferJSON class, which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing such functionality: https://root.cern/js/latest/demo/update_draw.htm. This demo page reads in cycle 20 json files and displays them.; If one has a web server which already provides such JSON file, one could specify the URL to this file like:; https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz; Here the same problem with Cross-Origin Request can appear. If the web server configuration cannot be changed, just copy JSROOT to the web server itself.; 1.10.3 Binary file-based monitoring (not recommended); Theoretically, one could use binary ROOT files to implement monitoring. With such approach, a ROOT-based application creates and regularly updates content of a ROOT file, which can be accessed via normal web server. From the browser side, JSROOT could ",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:21125,Security,access,accessed,21125," TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing such functionality: https://root.cern/js/latest/demo/update_draw.htm. This demo page reads in cycle 20 json files and displays them.; If one has a web server which already provides such JSON file, one could specify the URL to this file like:; https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz; Here the same problem with Cross-Origin Request can appear. If the web server configuration cannot be changed, just copy JSROOT to the web server itself.; 1.10.3 Binary file-based monitoring (not recommended); Theoretically, one could use binary ROOT files to implement monitoring. With such approach, a ROOT-based application creates and regularly updates content of a ROOT file, which can be accessed via normal web server. From the browser side, JSROOT could regularly read the specified objects and update their drawings. But such solution has three major caveats.; First of all, one need to store the data of all objects, which only potentially could be displayed in the browser. In case of 10 objects it does not matter, but for 1000 or 100000 objects this will be a major performance penalty. With such big amount of data one will never achieve higher update rate.; The second problem is I/O. To read the first object from the ROOT file, one need to perform several (about 5) file-reading operations via http protocol. There is no http file locking mechanism (at least not for standard web servers), therefore there is no guarantee that the file content is not changed/replaced between consequent read operations. Therefore, one should expect frequent I/O failures while trying to monitor data from ROOT binary files. There is a workaround for th",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:24906,Security,access,access,24906,"r(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; After script loading one can configure different parameters in gStyle object. It is instance of the TStyle object and behaves like gStyle variable in ROOT. For instance, to change stat format using to display value in stats box:; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; There is also settings object which contains all other JSROOT settings. For instance, one can configure custom format for different axes:; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; One also can use build/jsroot.js bundle to load all functionality at one and access it via JSROOT global handle:; <script src=""https://root.cern/js/latest/build/jsroot.js""></script>; <script>; // getting json string from somewhere; let obj = JSROOT.parse(root_json);; JSROOT.draw('plain', obj, 'colz');; </script>; 1.11.2 Use of JSON; It is strongly recommended to use JSON when communicating with ROOT application. THttpServer provides a JSON representation for every registered object with an url address like:; http://your_root_server:8080/Canvases/c1/root.json; Such JSON representation generated using the TBufferJSON class. One could create JSON file for any ROOT object directly, just writing in the code:; obj->SaveAs(""file.json"");; To access data from a remote web server, it is recommended to use the httpRequest method. For instance to receive object from a THttpServer server one could do:; import { httpRequest } from 'https://root.cern/js/latest/modules/main.mjs';; let obj = await httpRequest(""http://your_root_server:8080/Canvases/c1/root.json"", ""object""); console.log(",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:25573,Security,access,access,25573,"settings. For instance, one can configure custom format for different axes:; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; One also can use build/jsroot.js bundle to load all functionality at one and access it via JSROOT global handle:; <script src=""https://root.cern/js/latest/build/jsroot.js""></script>; <script>; // getting json string from somewhere; let obj = JSROOT.parse(root_json);; JSROOT.draw('plain', obj, 'colz');; </script>; 1.11.2 Use of JSON; It is strongly recommended to use JSON when communicating with ROOT application. THttpServer provides a JSON representation for every registered object with an url address like:; http://your_root_server:8080/Canvases/c1/root.json; Such JSON representation generated using the TBufferJSON class. One could create JSON file for any ROOT object directly, just writing in the code:; obj->SaveAs(""file.json"");; To access data from a remote web server, it is recommended to use the httpRequest method. For instance to receive object from a THttpServer server one could do:; import { httpRequest } from 'https://root.cern/js/latest/modules/main.mjs';; let obj = await httpRequest(""http://your_root_server:8080/Canvases/c1/root.json"", ""object""); console.log('Read object of type', obj._typename);; Function returns Promise, which provides parsed object (or Error in case of failure).; If JSON string was obtained by different method, it could be parsed with parse function:; import { parse } from 'https://root.cern/js/latest/modules/main.mjs';; let obj = parse(json_string);; 1.11.3 Objects drawing; After an object has been created, one can directly draw it. If HTML page has <div> element:; <div id=""drawing""></div>; One could use the draw function:; import { draw } from 'https://root.cern/js/latest/modules/main.mjs';; draw(""drawing"", obj, ""colz"");; The first argument is the id of the HTML div element, where drawing will be performed. The second a",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:27015,Security,access,access,27015,"which provides parsed object (or Error in case of failure).; If JSON string was obtained by different method, it could be parsed with parse function:; import { parse } from 'https://root.cern/js/latest/modules/main.mjs';; let obj = parse(json_string);; 1.11.3 Objects drawing; After an object has been created, one can directly draw it. If HTML page has <div> element:; <div id=""drawing""></div>; One could use the draw function:; import { draw } from 'https://root.cern/js/latest/modules/main.mjs';; draw(""drawing"", obj, ""colz"");; The first argument is the id of the HTML div element, where drawing will be performed. The second argument is the object to draw and the third one is the drawing option.; Here is complete running example ans source code:; import { httpRequest, draw, redraw, resize, cleanup } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/th2ul.json.gz"";; let obj = await httpRequest(filename, 'object');; draw(""drawing"", obj, ""lego"");; In very seldom cases one need to access painter object, created in draw() function. This can be done via handling Promise results like:; let painter = await draw(""drawing"", obj, ""colz"");; console.log('Object type in painter', painter.getClassName());; One is also able to update the drawing with a new version of the object:; // after some interval request object again; redraw(""drawing"", obj2, ""colz"");; The redraw function will call draw if the drawing was not performed before.; In the case when changing of HTML layout leads to resize of element with JSROOT drawing, one should call resize() to let JSROOT adjust drawing size. One should do:; resize(""drawing"");; As second argument one could specify exact size for draw elements like:; resize(""drawing"", { width: 500, height: 200 });; To correctly cleanup JSROOT drawings from HTML element, one should call:; cleanup(""drawing"");; 1.11.4 File API; JSROOT defines the TFile class, which can be used to access binary ROOT files. One should always ",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:27936,Security,access,access,27936," httpRequest(filename, 'object');; draw(""drawing"", obj, ""lego"");; In very seldom cases one need to access painter object, created in draw() function. This can be done via handling Promise results like:; let painter = await draw(""drawing"", obj, ""colz"");; console.log('Object type in painter', painter.getClassName());; One is also able to update the drawing with a new version of the object:; // after some interval request object again; redraw(""drawing"", obj2, ""colz"");; The redraw function will call draw if the drawing was not performed before.; In the case when changing of HTML layout leads to resize of element with JSROOT drawing, one should call resize() to let JSROOT adjust drawing size. One should do:; resize(""drawing"");; As second argument one could specify exact size for draw elements like:; resize(""drawing"", { width: 500, height: 200 });; To correctly cleanup JSROOT drawings from HTML element, one should call:; cleanup(""drawing"");; 1.11.4 File API; JSROOT defines the TFile class, which can be used to access binary ROOT files. One should always remember that all I/O operations are asynchronous in JSROOT. Therefore promises are used to retrieve results when the I/O operation is completed. For example, reading an object from a file and displaying it will look like:; import { openFile, draw } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/hsimple.root"";; let file = await openFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; console.log('drawing completed');; Here is running example and source code; 1.11.5 TTree API; Simple TTree::Draw operation can be performed with following code:; import { openFile } from 'https://root.cern/js/latest/modules/io.mjs';; import { draw } from 'https://root.cern/js/latest/modules/draw.mjs';; let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let tree = await file.readObject(""ntuple;1"");; draw(""drawing"", tree, ""px:py::p",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:28931,Security,access,access,28931,"ary ROOT files. One should always remember that all I/O operations are asynchronous in JSROOT. Therefore promises are used to retrieve results when the I/O operation is completed. For example, reading an object from a file and displaying it will look like:; import { openFile, draw } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/hsimple.root"";; let file = await openFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; console.log('drawing completed');; Here is running example and source code; 1.11.5 TTree API; Simple TTree::Draw operation can be performed with following code:; import { openFile } from 'https://root.cern/js/latest/modules/io.mjs';; import { draw } from 'https://root.cern/js/latest/modules/draw.mjs';; let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let tree = await file.readObject(""ntuple;1"");; draw(""drawing"", tree, ""px:py::pz>5"");; To get access to selected branches, one should use TSelector class:; import { openFile } from 'https://root.cern/js/latest/modules/io.mjs';; import { draw } from 'https://root.cern/js/latest/modules/draw.mjs';; import { TSelector, treeProcess } from 'https://root.cern/js/latest/modules/tree.mjs';. let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let tree = await file.readObject(""ntuple;1"");; let selector = new TSelector();. selector.AddBranch(""px"");; selector.AddBranch(""py"");. let cnt = 0, sumpx = 0, sumpy = 0;. selector.Begin = function() {; // function called before reading of TTree starts; }. selector.Process = function() {; // function called for every entry; sumpx += this.tgtobj.px;; sumpy += this.tgtobj.py;; cnt++;; }. selector.Terminate = function(res) {; if (!res || (cnt === 0)) return;; let meanpx = sumpx/cnt, meanpy = sumpy/cnt;; console.log(`Results meanpx = ${meanpx} meanpy = ${meanpy}`);; }. await treeProcess(tree, selector);; Here is running example and source code; This ",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:30161,Security,access,accessed,30161,"ss } from 'https://root.cern/js/latest/modules/tree.mjs';. let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let tree = await file.readObject(""ntuple;1"");; let selector = new TSelector();. selector.AddBranch(""px"");; selector.AddBranch(""py"");. let cnt = 0, sumpx = 0, sumpy = 0;. selector.Begin = function() {; // function called before reading of TTree starts; }. selector.Process = function() {; // function called for every entry; sumpx += this.tgtobj.px;; sumpy += this.tgtobj.py;; cnt++;; }. selector.Terminate = function(res) {; if (!res || (cnt === 0)) return;; let meanpx = sumpx/cnt, meanpy = sumpy/cnt;; console.log(`Results meanpx = ${meanpx} meanpy = ${meanpy}`);; }. await treeProcess(tree, selector);; Here is running example and source code; This examples shows how read TTree from binary file and create TSelector object. Logically it is similar to original TSelector class - for every read entry TSelector::Process() method is called. Selected branches can be accessed from tgtobj data member. At the end of tree reading TSelector::Terminate() method will be called.; As third parameter of treeProcess() function one could provide object with arguments; let args = { numentries: 1000, firstentry: 500 };; treeProcess(tree, selector, args);; 1.11.6 TGeo API; Any supported TGeo object can be drawn directly with normal draw() function.; If necessary, one can create three.js model for supported object directly and use such model separately. This can be done with the function:; import { build } from './path_to_jsroot/modules/geom/TGeoPainter.mjs';; let opt = { numfaces: 100000 };; let obj3d = build(obj, opt);; scene.add( obj3d );; Following options can be specified:. numfaces - approximate maximal number of faces in three.js model (default 100000); numnodes - approximate maximal number of meshes in three.js model (default 1000); doubleside - use double-side material (default only front side is set); wireframe - show wireframe for created object (default -",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:31853,Security,access,access,31853,"s can be specified:. numfaces - approximate maximal number of faces in three.js model (default 100000); numnodes - approximate maximal number of meshes in three.js model (default 1000); doubleside - use double-side material (default only front side is set); wireframe - show wireframe for created object (default - off); dflt_colors - assign default ROOT colors for the volumes. When transparent volumes appeared in the model, one could use produceRenderOrder() function to correctly set rendering order. It should be used as:; import { produceRenderOrder } from './path_to_jsroot/modules/geom/TGeoPainter.mjs';; produceRenderOrder(scene, camera.position, 'box');; Following methods can be applied: “box”, “pnt”, “size”, “ray” and “dflt”. See more info in draw options description for TGeo classes.; Here is running example and source code.; 1.11.7 Custom user class; There is code example how custom user class can be implemented. It shows usage of different draw options for the class and ability to access sub-elements of the object using specialized expand function.; 1.11.8 Use with Node.js; To install latest JSROOT release, just do:; [shell] npm install jsroot; To use in the Node.js scripts, one should add following line:; import { httpRequest, makeSVG } from 'jsroot';; Using JSROOT functionality, one can open binary ROOT files (local and remote), parse ROOT JSON, create SVG output. For example, to create SVG image with lego plot, one should do:; import { openFile, makeSVG } from 'jsroot';; import { writeFileSync } from 'fs';. let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let obj = await file.readObject(""hpx;1"");; let svg = await makeSVG({ object: obj, option: ""lego2"", width: 1200, height: 800 });; writeFileSync(""lego2.svg"", svg);; It is also possible to convert any JavaScript object into ROOT JSON string, using toJSON() function. Like:; import { toJSON, openFile, makeSVG } from 'jsroot';; import { writeFileSync } from 'fs';. let file = await openFile(""",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:34206,Security,access,access,34206," machine, one have to use xvfb-run utility, see also here:; [shell] xvfb-run -s ""-ac -screen 0 1280x1024x24"" node geomsvg.js; 1.11.9 Use with OpenUI5; OpenUI5 is a web toolkit for developers to ease and speed up the development of full-blown HTML5 web applications. JSROOT provides loadOpenui5 function to load supported OpenUI5:; <script type=""module"">; import { loadOpenui5 } from 'path_to_jsroot/modules/main.mjs';; let sap = await loadOpenui5();; sap.registerModulePath(""NavExample"", ""./"");; new sap.m.App ({; pages: [; new sap.m.Page({; title: ""Nav Container"",; enableScrolling : true,; content: [ new sap.ui.core.ComponentContainer({ name : ""NavExample"" })]; }); ]; }).placeAt(""content"");; </script>; JSROOT uses https://openui5.hana.ondemand.com/1.128.0/ when no other source is specified.; There are small details when using OpenUI5 with THttpServer. First of all, location of JSROOT modules should be specified as /jsrootsys/modules/main.mjs. And then trying to access files from local disk, one should specify /currentdir/ folder:; jQuery.sap.registerModulePath(""NavExample"", ""/currentdir/"");; JSROOT provides example showing usage of JSROOT drawing in the OpenUI5, source code can be found in repository.; 1.11.10 Migration v6 -> v7. Core functionality should be imported from main.mjs module like:. import { create, parse, createHistogram, redraw } from 'https://root.cern/js/7.0.0/modules/main.mjs';. It is still possible to use JSRoot.core.js script, which provides very similar (but not identical!) functionality as with v6 via global JSROOT object; JSROOT.define() and JSROOT.require() functions only available after JSRoot.core.js loading; Support of require.js and openui5 loaders was removed; Global hierarchy painter JSROOT.hpainter no longer existing, one can use getHPainter function:. import { getHPainter } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let hpainter = getHPainter();. All math functions previously available via JSROOT.Math should be imported from base/",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:35381,Security,access,accessed,35381,"ROOT drawing in the OpenUI5, source code can be found in repository.; 1.11.10 Migration v6 -> v7. Core functionality should be imported from main.mjs module like:. import { create, parse, createHistogram, redraw } from 'https://root.cern/js/7.0.0/modules/main.mjs';. It is still possible to use JSRoot.core.js script, which provides very similar (but not identical!) functionality as with v6 via global JSROOT object; JSROOT.define() and JSROOT.require() functions only available after JSRoot.core.js loading; Support of require.js and openui5 loaders was removed; Global hierarchy painter JSROOT.hpainter no longer existing, one can use getHPainter function:. import { getHPainter } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let hpainter = getHPainter();. All math functions previously available via JSROOT.Math should be imported from base/math.mjs module:. import * as math from 'https://root.cern/js/7.0.0/modules/base/math.mjs';. Indication of batch mode JSROOT.batch_mode should be accessed via functions:. import { isBatchMode, setBatchMode } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let was_batch = isBatchMode();; if (!was_batch) setBatchMode(true);. JSROOT.extend() function was removed, use Object.assign() instead. 1.11.11 Migration v5 -> v6. Main script was renamed to JSRoot.core.js. Old JSRootCore.js was deprecated and removed in v6.2. All URL parameters for main script ignored now, to load JSROOT functionality one should use JSROOT.require function. To create standard GUI, JSROOT.buildGUI function has to be used.; Instead of JSROOT.JSONR_unref() one can use JSROOT.parse(). If object is provided to JSROOT.parse() it just replaces all references which were introduced by TBufferJSON::ToJSON() method.; Instead of JSROOT.console() one should use console.log(). Instead of JSROOT.alert() one should use console.error().; Many settings were moved from JSROOT.gStyle to JSROOT.settings object. It was done to keep only TStyle-related members in JSROOT.gStyle.; ",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:6900,Testability,log,logx,6900,"aphErrors; TGraphPolar : example; TMultiGraph : example, exclusion; TGraph2D : example; TEfficiency : docu; TLatex : example; TMathText : example; TCanvas : example; TPad : example; TRatioPlot : example; TLegend : example; TTree : single-branch draw; TPolyLine : dflt; TGaxis : dflt; TEllipse : dflt; TArrow : dflt; TPolyMarker3D: dflt. More examples of supported classes can be found on: https://root.cern/js/latest/examples.htm; There are special JSROOT draw options which only can be used with for TCanvas or TPad objects:. logx - enable log10 scale for X axis; logy - enable log10 scale for Y axis; logz - enable log10 scale for Z axis; log - enable log10 scale for X,Y,Z axes; log2x - enable log2 scale for X axis; log2y - enable log2 scale for Y axis; log2z - enable log2 scale for Z axis; log2 - enable log2 scale for X,Y,Z axes; gridx - enable grid for X axis; gridy - enable grid for X axis; grid - enable grid for X and Y axes; tickx - enable ticks for X axis; ticky - enable ticks for X axis; tick - enable ticks for X and Y axes; rx - reverse X axis; ry - reverse Y axis; rotate - rotate frame; fixframe - disable interactive moving of the frame; nozoomx - disable zooming on X axis; nozoomy - disable zooming on Y axis; cpXY - create palette XY for the canvas like cp50; nopalette - ignore palette stored with TCanvas; nocolors - ignore colors list stored with TCanvas; lcolors - use only locally colors list stored with TCanvas; nomargins - clear frame margins. 1.4 Superimposing draw objects; In the URL string one could use “+” sign to specify objects superposition:. item=hpx+hprof. With similar syntax one could specify individual draw options for superimposed objects. item=hpx+hprof&opt=logy+hist. Here “logy” option will be used for “hpx1” item and “hist” option for “hprof;1” item.; While draw option can include “+” sign itself, for superposition one could specify arrays of items and draw options like:. item=[hpx;1,hprof;1]&opt=[logy,hist]. 1.5 TTree draw; JSROOT provides pos",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:6938,Testability,log,logy,6938,"aphErrors; TGraphPolar : example; TMultiGraph : example, exclusion; TGraph2D : example; TEfficiency : docu; TLatex : example; TMathText : example; TCanvas : example; TPad : example; TRatioPlot : example; TLegend : example; TTree : single-branch draw; TPolyLine : dflt; TGaxis : dflt; TEllipse : dflt; TArrow : dflt; TPolyMarker3D: dflt. More examples of supported classes can be found on: https://root.cern/js/latest/examples.htm; There are special JSROOT draw options which only can be used with for TCanvas or TPad objects:. logx - enable log10 scale for X axis; logy - enable log10 scale for Y axis; logz - enable log10 scale for Z axis; log - enable log10 scale for X,Y,Z axes; log2x - enable log2 scale for X axis; log2y - enable log2 scale for Y axis; log2z - enable log2 scale for Z axis; log2 - enable log2 scale for X,Y,Z axes; gridx - enable grid for X axis; gridy - enable grid for X axis; grid - enable grid for X and Y axes; tickx - enable ticks for X axis; ticky - enable ticks for X axis; tick - enable ticks for X and Y axes; rx - reverse X axis; ry - reverse Y axis; rotate - rotate frame; fixframe - disable interactive moving of the frame; nozoomx - disable zooming on X axis; nozoomy - disable zooming on Y axis; cpXY - create palette XY for the canvas like cp50; nopalette - ignore palette stored with TCanvas; nocolors - ignore colors list stored with TCanvas; lcolors - use only locally colors list stored with TCanvas; nomargins - clear frame margins. 1.4 Superimposing draw objects; In the URL string one could use “+” sign to specify objects superposition:. item=hpx+hprof. With similar syntax one could specify individual draw options for superimposed objects. item=hpx+hprof&opt=logy+hist. Here “logy” option will be used for “hpx1” item and “hist” option for “hprof;1” item.; While draw option can include “+” sign itself, for superposition one could specify arrays of items and draw options like:. item=[hpx;1,hprof;1]&opt=[logy,hist]. 1.5 TTree draw; JSROOT provides pos",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:6976,Testability,log,logz,6976,"aphErrors; TGraphPolar : example; TMultiGraph : example, exclusion; TGraph2D : example; TEfficiency : docu; TLatex : example; TMathText : example; TCanvas : example; TPad : example; TRatioPlot : example; TLegend : example; TTree : single-branch draw; TPolyLine : dflt; TGaxis : dflt; TEllipse : dflt; TArrow : dflt; TPolyMarker3D: dflt. More examples of supported classes can be found on: https://root.cern/js/latest/examples.htm; There are special JSROOT draw options which only can be used with for TCanvas or TPad objects:. logx - enable log10 scale for X axis; logy - enable log10 scale for Y axis; logz - enable log10 scale for Z axis; log - enable log10 scale for X,Y,Z axes; log2x - enable log2 scale for X axis; log2y - enable log2 scale for Y axis; log2z - enable log2 scale for Z axis; log2 - enable log2 scale for X,Y,Z axes; gridx - enable grid for X axis; gridy - enable grid for X axis; grid - enable grid for X and Y axes; tickx - enable ticks for X axis; ticky - enable ticks for X axis; tick - enable ticks for X and Y axes; rx - reverse X axis; ry - reverse Y axis; rotate - rotate frame; fixframe - disable interactive moving of the frame; nozoomx - disable zooming on X axis; nozoomy - disable zooming on Y axis; cpXY - create palette XY for the canvas like cp50; nopalette - ignore palette stored with TCanvas; nocolors - ignore colors list stored with TCanvas; lcolors - use only locally colors list stored with TCanvas; nomargins - clear frame margins. 1.4 Superimposing draw objects; In the URL string one could use “+” sign to specify objects superposition:. item=hpx+hprof. With similar syntax one could specify individual draw options for superimposed objects. item=hpx+hprof&opt=logy+hist. Here “logy” option will be used for “hpx1” item and “hist” option for “hprof;1” item.; While draw option can include “+” sign itself, for superposition one could specify arrays of items and draw options like:. item=[hpx;1,hprof;1]&opt=[logy,hist]. 1.5 TTree draw; JSROOT provides pos",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:7014,Testability,log,log,7014,"aphErrors; TGraphPolar : example; TMultiGraph : example, exclusion; TGraph2D : example; TEfficiency : docu; TLatex : example; TMathText : example; TCanvas : example; TPad : example; TRatioPlot : example; TLegend : example; TTree : single-branch draw; TPolyLine : dflt; TGaxis : dflt; TEllipse : dflt; TArrow : dflt; TPolyMarker3D: dflt. More examples of supported classes can be found on: https://root.cern/js/latest/examples.htm; There are special JSROOT draw options which only can be used with for TCanvas or TPad objects:. logx - enable log10 scale for X axis; logy - enable log10 scale for Y axis; logz - enable log10 scale for Z axis; log - enable log10 scale for X,Y,Z axes; log2x - enable log2 scale for X axis; log2y - enable log2 scale for Y axis; log2z - enable log2 scale for Z axis; log2 - enable log2 scale for X,Y,Z axes; gridx - enable grid for X axis; gridy - enable grid for X axis; grid - enable grid for X and Y axes; tickx - enable ticks for X axis; ticky - enable ticks for X axis; tick - enable ticks for X and Y axes; rx - reverse X axis; ry - reverse Y axis; rotate - rotate frame; fixframe - disable interactive moving of the frame; nozoomx - disable zooming on X axis; nozoomy - disable zooming on Y axis; cpXY - create palette XY for the canvas like cp50; nopalette - ignore palette stored with TCanvas; nocolors - ignore colors list stored with TCanvas; lcolors - use only locally colors list stored with TCanvas; nomargins - clear frame margins. 1.4 Superimposing draw objects; In the URL string one could use “+” sign to specify objects superposition:. item=hpx+hprof. With similar syntax one could specify individual draw options for superimposed objects. item=hpx+hprof&opt=logy+hist. Here “logy” option will be used for “hpx1” item and “hist” option for “hprof;1” item.; While draw option can include “+” sign itself, for superposition one could specify arrays of items and draw options like:. item=[hpx;1,hprof;1]&opt=[logy,hist]. 1.5 TTree draw; JSROOT provides pos",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:8080,Testability,log,logy,8080,"scale for X axis; log2y - enable log2 scale for Y axis; log2z - enable log2 scale for Z axis; log2 - enable log2 scale for X,Y,Z axes; gridx - enable grid for X axis; gridy - enable grid for X axis; grid - enable grid for X and Y axes; tickx - enable ticks for X axis; ticky - enable ticks for X axis; tick - enable ticks for X and Y axes; rx - reverse X axis; ry - reverse Y axis; rotate - rotate frame; fixframe - disable interactive moving of the frame; nozoomx - disable zooming on X axis; nozoomy - disable zooming on Y axis; cpXY - create palette XY for the canvas like cp50; nopalette - ignore palette stored with TCanvas; nocolors - ignore colors list stored with TCanvas; lcolors - use only locally colors list stored with TCanvas; nomargins - clear frame margins. 1.4 Superimposing draw objects; In the URL string one could use “+” sign to specify objects superposition:. item=hpx+hprof. With similar syntax one could specify individual draw options for superimposed objects. item=hpx+hprof&opt=logy+hist. Here “logy” option will be used for “hpx1” item and “hist” option for “hprof;1” item.; While draw option can include “+” sign itself, for superposition one could specify arrays of items and draw options like:. item=[hpx;1,hprof;1]&opt=[logy,hist]. 1.5 TTree draw; JSROOT provides possibility to display TTree data, using TTree::Draw syntax:. opt=px; opt=px:py; opt=px:py:pz. It is also possible to use branch by id number specifying name like “br_0”, “br_1” and so on:. opt=br_0:br_1. Histogram ranges and binning defined after reading first 1000 entries from the tree. Like in ROOT, one could configure histogram binning and range directly:. opt=px:py>>h(50,-5,5,50,-5,5). One and two dimensional draw expressions can be resulted into TGraph object, using “>>Graph” as output:. opt=px:py>>Graph. For any integer value one can accumulate histogram with value bits distribution, specifying as output “>>bits(16)” or “>>bits”:. opt=event.fTracks.fBits>>bits. There is special handling o",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:8097,Testability,log,logy,8097,"g2z - enable log2 scale for Z axis; log2 - enable log2 scale for X,Y,Z axes; gridx - enable grid for X axis; gridy - enable grid for X axis; grid - enable grid for X and Y axes; tickx - enable ticks for X axis; ticky - enable ticks for X axis; tick - enable ticks for X and Y axes; rx - reverse X axis; ry - reverse Y axis; rotate - rotate frame; fixframe - disable interactive moving of the frame; nozoomx - disable zooming on X axis; nozoomy - disable zooming on Y axis; cpXY - create palette XY for the canvas like cp50; nopalette - ignore palette stored with TCanvas; nocolors - ignore colors list stored with TCanvas; lcolors - use only locally colors list stored with TCanvas; nomargins - clear frame margins. 1.4 Superimposing draw objects; In the URL string one could use “+” sign to specify objects superposition:. item=hpx+hprof. With similar syntax one could specify individual draw options for superimposed objects. item=hpx+hprof&opt=logy+hist. Here “logy” option will be used for “hpx1” item and “hist” option for “hprof;1” item.; While draw option can include “+” sign itself, for superposition one could specify arrays of items and draw options like:. item=[hpx;1,hprof;1]&opt=[logy,hist]. 1.5 TTree draw; JSROOT provides possibility to display TTree data, using TTree::Draw syntax:. opt=px; opt=px:py; opt=px:py:pz. It is also possible to use branch by id number specifying name like “br_0”, “br_1” and so on:. opt=br_0:br_1. Histogram ranges and binning defined after reading first 1000 entries from the tree. Like in ROOT, one could configure histogram binning and range directly:. opt=px:py>>h(50,-5,5,50,-5,5). One and two dimensional draw expressions can be resulted into TGraph object, using “>>Graph” as output:. opt=px:py>>Graph. For any integer value one can accumulate histogram with value bits distribution, specifying as output “>>bits(16)” or “>>bits”:. opt=event.fTracks.fBits>>bits. There is special handling of TBits objects:. opt=event.fTriggerBits. It is allowed to",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:8327,Testability,log,logy,8327,"enable ticks for X axis; ticky - enable ticks for X axis; tick - enable ticks for X and Y axes; rx - reverse X axis; ry - reverse Y axis; rotate - rotate frame; fixframe - disable interactive moving of the frame; nozoomx - disable zooming on X axis; nozoomy - disable zooming on Y axis; cpXY - create palette XY for the canvas like cp50; nopalette - ignore palette stored with TCanvas; nocolors - ignore colors list stored with TCanvas; lcolors - use only locally colors list stored with TCanvas; nomargins - clear frame margins. 1.4 Superimposing draw objects; In the URL string one could use “+” sign to specify objects superposition:. item=hpx+hprof. With similar syntax one could specify individual draw options for superimposed objects. item=hpx+hprof&opt=logy+hist. Here “logy” option will be used for “hpx1” item and “hist” option for “hprof;1” item.; While draw option can include “+” sign itself, for superposition one could specify arrays of items and draw options like:. item=[hpx;1,hprof;1]&opt=[logy,hist]. 1.5 TTree draw; JSROOT provides possibility to display TTree data, using TTree::Draw syntax:. opt=px; opt=px:py; opt=px:py:pz. It is also possible to use branch by id number specifying name like “br_0”, “br_1” and so on:. opt=br_0:br_1. Histogram ranges and binning defined after reading first 1000 entries from the tree. Like in ROOT, one could configure histogram binning and range directly:. opt=px:py>>h(50,-5,5,50,-5,5). One and two dimensional draw expressions can be resulted into TGraph object, using “>>Graph” as output:. opt=px:py>>Graph. For any integer value one can accumulate histogram with value bits distribution, specifying as output “>>bits(16)” or “>>bits”:. opt=event.fTracks.fBits>>bits. There is special handling of TBits objects:. opt=event.fTriggerBits. It is allowed to use different expressions with branch values:. opt=px+py:px-py. Such expression can include arithmetical operations and all methods, provided in JavaScript Math class:. opt=Math.abs(px+",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:25910,Testability,log,log,25910,"T global handle:; <script src=""https://root.cern/js/latest/build/jsroot.js""></script>; <script>; // getting json string from somewhere; let obj = JSROOT.parse(root_json);; JSROOT.draw('plain', obj, 'colz');; </script>; 1.11.2 Use of JSON; It is strongly recommended to use JSON when communicating with ROOT application. THttpServer provides a JSON representation for every registered object with an url address like:; http://your_root_server:8080/Canvases/c1/root.json; Such JSON representation generated using the TBufferJSON class. One could create JSON file for any ROOT object directly, just writing in the code:; obj->SaveAs(""file.json"");; To access data from a remote web server, it is recommended to use the httpRequest method. For instance to receive object from a THttpServer server one could do:; import { httpRequest } from 'https://root.cern/js/latest/modules/main.mjs';; let obj = await httpRequest(""http://your_root_server:8080/Canvases/c1/root.json"", ""object""); console.log('Read object of type', obj._typename);; Function returns Promise, which provides parsed object (or Error in case of failure).; If JSON string was obtained by different method, it could be parsed with parse function:; import { parse } from 'https://root.cern/js/latest/modules/main.mjs';; let obj = parse(json_string);; 1.11.3 Objects drawing; After an object has been created, one can directly draw it. If HTML page has <div> element:; <div id=""drawing""></div>; One could use the draw function:; import { draw } from 'https://root.cern/js/latest/modules/main.mjs';; draw(""drawing"", obj, ""colz"");; The first argument is the id of the HTML div element, where drawing will be performed. The second argument is the object to draw and the third one is the drawing option.; Here is complete running example ans source code:; import { httpRequest, draw, redraw, resize, cleanup } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/th2ul.json.gz"";; let obj = await httpReque",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:27178,Testability,log,log,27178,"s';; let obj = parse(json_string);; 1.11.3 Objects drawing; After an object has been created, one can directly draw it. If HTML page has <div> element:; <div id=""drawing""></div>; One could use the draw function:; import { draw } from 'https://root.cern/js/latest/modules/main.mjs';; draw(""drawing"", obj, ""colz"");; The first argument is the id of the HTML div element, where drawing will be performed. The second argument is the object to draw and the third one is the drawing option.; Here is complete running example ans source code:; import { httpRequest, draw, redraw, resize, cleanup } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/th2ul.json.gz"";; let obj = await httpRequest(filename, 'object');; draw(""drawing"", obj, ""lego"");; In very seldom cases one need to access painter object, created in draw() function. This can be done via handling Promise results like:; let painter = await draw(""drawing"", obj, ""colz"");; console.log('Object type in painter', painter.getClassName());; One is also able to update the drawing with a new version of the object:; // after some interval request object again; redraw(""drawing"", obj2, ""colz"");; The redraw function will call draw if the drawing was not performed before.; In the case when changing of HTML layout leads to resize of element with JSROOT drawing, one should call resize() to let JSROOT adjust drawing size. One should do:; resize(""drawing"");; As second argument one could specify exact size for draw elements like:; resize(""drawing"", { width: 500, height: 200 });; To correctly cleanup JSROOT drawings from HTML element, one should call:; cleanup(""drawing"");; 1.11.4 File API; JSROOT defines the TFile class, which can be used to access binary ROOT files. One should always remember that all I/O operations are asynchronous in JSROOT. Therefore promises are used to retrieve results when the I/O operation is completed. For example, reading an object from a file and displaying it will look ",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:28471,Testability,log,log,28471,"eads to resize of element with JSROOT drawing, one should call resize() to let JSROOT adjust drawing size. One should do:; resize(""drawing"");; As second argument one could specify exact size for draw elements like:; resize(""drawing"", { width: 500, height: 200 });; To correctly cleanup JSROOT drawings from HTML element, one should call:; cleanup(""drawing"");; 1.11.4 File API; JSROOT defines the TFile class, which can be used to access binary ROOT files. One should always remember that all I/O operations are asynchronous in JSROOT. Therefore promises are used to retrieve results when the I/O operation is completed. For example, reading an object from a file and displaying it will look like:; import { openFile, draw } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/hsimple.root"";; let file = await openFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; console.log('drawing completed');; Here is running example and source code; 1.11.5 TTree API; Simple TTree::Draw operation can be performed with following code:; import { openFile } from 'https://root.cern/js/latest/modules/io.mjs';; import { draw } from 'https://root.cern/js/latest/modules/draw.mjs';; let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let tree = await file.readObject(""ntuple;1"");; draw(""drawing"", tree, ""px:py::pz>5"");; To get access to selected branches, one should use TSelector class:; import { openFile } from 'https://root.cern/js/latest/modules/io.mjs';; import { draw } from 'https://root.cern/js/latest/modules/draw.mjs';; import { TSelector, treeProcess } from 'https://root.cern/js/latest/modules/tree.mjs';. let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let tree = await file.readObject(""ntuple;1"");; let selector = new TSelector();. selector.AddBranch(""px"");; selector.AddBranch(""py"");. let cnt = 0, sumpx = 0, sumpy = 0;. selector.Begin = function() {; // function",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:29806,Testability,log,log,29806,");; let tree = await file.readObject(""ntuple;1"");; draw(""drawing"", tree, ""px:py::pz>5"");; To get access to selected branches, one should use TSelector class:; import { openFile } from 'https://root.cern/js/latest/modules/io.mjs';; import { draw } from 'https://root.cern/js/latest/modules/draw.mjs';; import { TSelector, treeProcess } from 'https://root.cern/js/latest/modules/tree.mjs';. let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let tree = await file.readObject(""ntuple;1"");; let selector = new TSelector();. selector.AddBranch(""px"");; selector.AddBranch(""py"");. let cnt = 0, sumpx = 0, sumpy = 0;. selector.Begin = function() {; // function called before reading of TTree starts; }. selector.Process = function() {; // function called for every entry; sumpx += this.tgtobj.px;; sumpy += this.tgtobj.py;; cnt++;; }. selector.Terminate = function(res) {; if (!res || (cnt === 0)) return;; let meanpx = sumpx/cnt, meanpy = sumpy/cnt;; console.log(`Results meanpx = ${meanpx} meanpy = ${meanpy}`);; }. await treeProcess(tree, selector);; Here is running example and source code; This examples shows how read TTree from binary file and create TSelector object. Logically it is similar to original TSelector class - for every read entry TSelector::Process() method is called. Selected branches can be accessed from tgtobj data member. At the end of tree reading TSelector::Terminate() method will be called.; As third parameter of treeProcess() function one could provide object with arguments; let args = { numentries: 1000, firstentry: 500 };; treeProcess(tree, selector, args);; 1.11.6 TGeo API; Any supported TGeo object can be drawn directly with normal draw() function.; If necessary, one can create three.js model for supported object directly and use such model separately. This can be done with the function:; import { build } from './path_to_jsroot/modules/geom/TGeoPainter.mjs';; let opt = { numfaces: 100000 };; let obj3d = build(obj, opt);; scene.add( obj3d );; ",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:36179,Testability,log,log,36179," require.js and openui5 loaders was removed; Global hierarchy painter JSROOT.hpainter no longer existing, one can use getHPainter function:. import { getHPainter } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let hpainter = getHPainter();. All math functions previously available via JSROOT.Math should be imported from base/math.mjs module:. import * as math from 'https://root.cern/js/7.0.0/modules/base/math.mjs';. Indication of batch mode JSROOT.batch_mode should be accessed via functions:. import { isBatchMode, setBatchMode } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let was_batch = isBatchMode();; if (!was_batch) setBatchMode(true);. JSROOT.extend() function was removed, use Object.assign() instead. 1.11.11 Migration v5 -> v6. Main script was renamed to JSRoot.core.js. Old JSRootCore.js was deprecated and removed in v6.2. All URL parameters for main script ignored now, to load JSROOT functionality one should use JSROOT.require function. To create standard GUI, JSROOT.buildGUI function has to be used.; Instead of JSROOT.JSONR_unref() one can use JSROOT.parse(). If object is provided to JSROOT.parse() it just replaces all references which were introduced by TBufferJSON::ToJSON() method.; Instead of JSROOT.console() one should use console.log(). Instead of JSROOT.alert() one should use console.error().; Many settings were moved from JSROOT.gStyle to JSROOT.settings object. It was done to keep only TStyle-related members in JSROOT.gStyle.; Basic painter classes were renamed and made public:. JSROOT.TBasePainter -> JSROOT.BasePainter; JSROOT.TObjectPainter -> JSROOT.ObjectPainter. Internal ObjectPainter.DrawingReady api was deprecated. Draw function has to return Promise if object drawing postponed. As argument of returned promise object painter has to be used.; Many function names where adjusted to naming conventions. Like:. JSROOT.CreateHistogram -> JSROOT.createHistogram; JSROOT.CreateTGraph -> JSROOT.createTGraph; JSROOT.Create -> JSROOT.create. ",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:1987,Usability,simpl,simple,1987,"anvas.; To automate files loading and objects drawing, one can provide number of URL parameters in address string like:. file - name of the file, which will be automatically open with page loading; files - array of file names for loading; json - name of JSON file with stored ROOT object like histogram or canvas; item - item name to be displayed; opt - drawing option for the item; items - array of items name to be displayed; opts - array of drawing options for the items; expand - item name(s) to be expanded in the hierarchy browser; focus - item name to be focused on in the hierarchy browser; title - set browser title; dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; layout - can be ‘simple’, ‘flex’, ‘tabs’, ‘gridNxM’, ‘horizNMK’, ‘vertNMK’; browser - layout of the browser ‘fix’ (default), ‘float’, ‘no’ (hidden), ‘off’ (fully disabled); nobrowser - do not display file browser (same as browser=no); float - display floating browser (same as browser=float); status - configure status line ‘no’ (default), ‘off’ (completely disable), ‘size’; inject - name of extra JavaScript to load, see several examples in demo/ subdir; optimize - drawing optimization 0:off, 1:only large histograms (default), 2:always; palette - id of default color palette, 51..121 - new ROOT6 palette (default 57); interactive - enable/disable interactive functions 0 - disable all, 1 - enable all; noselect - hide file-selection part in the browser (only when file name is specified); mathjax - use MathJax for latex output; latex - ‘off’, ‘symbols’, ‘normal’, ‘mathjax’, ‘alwaysmath’ control of TLatex processor; style - name of TStyle object to define global JSROOT style; toolbar - show canvas tool buttons ‘off’, ‘on’ and ‘popup’, ‘left’ or ‘right’ for position, ‘vert’ for vertical; divsize - fixed size in pixels for main div element like &dvisize=1500x800; canvsize - default canvas size in pixels like &canvsize=1200x800; optstat - settings for stat box, def",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:4353,Usability,simpl,simple,4353,"eation date, 3 - file modification date; utc - select timeZone to ‘UTC’; datex - X position of date; datey - Y position of date; optfile - plot file name on the canvas, 1 - file name, 2 - full file URL, 3 - object item name; opttitle - disable/enable drawing of object title in the canvas; nomenu - disable context menu; notouch - disable touch events handling; progress - switch progress display mode between ‘off’, ‘on’ and ‘modal’. For instance:. https://root.cern/js/latest/?file=../files/hsimple.root&item=hpx;1; https://root.cern/js/latest/?file=../files/hsimple.root&nobrowser&item=hpxpy;1&opt=colz; https://root.cern/js/latest/?file=../files/hsimple.root&noselect&layout=grid2x2&item=hprof;1. Following layouts are supported:. simple - available space used for single object (default); flex - creates as many frames as necessary, each can be individually moved/enlarged; tabs - tabs for each object drawing; gridNxM - fixed-size grid with NxM frames; vertN - N frames sorted in vertical direction (like gridi1xN); horizN - N frames sorted in horizontal direction (like gridiNx1); vert121 - 3 frames sorted in vertical direction, second frame divided on two sub-frames; horiz32_12 - 2 horizontal frames with 3 and 2 subframes, and 1/3 and 2/3 as relative size. When specifying files, items or opts parameters, array of strings could be provided like files=['file1.root','file2.root']. One could skip quotes when specifying elements names items=[file1.root/hpx,file2.root/hpy] or opts=['',colz].; As item name, URL to existing image can be provided like item=img:http://server/image.png. Such image will be just inserted in the existing layout. One could specify option ""scale"" to automatically scale image to available space.; Many examples of URL string usage can be found on JSROOT API examples page.; One can very easy integrate JSROOT graphic into arbitrary HTML pages using a iframe tag:; <iframe width=""700"" height=""400""; src=""https://root.cern/js/latest/?nobrowser&file=https://root.cern",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:7828,Usability,clear,clear,7828,"aphErrors; TGraphPolar : example; TMultiGraph : example, exclusion; TGraph2D : example; TEfficiency : docu; TLatex : example; TMathText : example; TCanvas : example; TPad : example; TRatioPlot : example; TLegend : example; TTree : single-branch draw; TPolyLine : dflt; TGaxis : dflt; TEllipse : dflt; TArrow : dflt; TPolyMarker3D: dflt. More examples of supported classes can be found on: https://root.cern/js/latest/examples.htm; There are special JSROOT draw options which only can be used with for TCanvas or TPad objects:. logx - enable log10 scale for X axis; logy - enable log10 scale for Y axis; logz - enable log10 scale for Z axis; log - enable log10 scale for X,Y,Z axes; log2x - enable log2 scale for X axis; log2y - enable log2 scale for Y axis; log2z - enable log2 scale for Z axis; log2 - enable log2 scale for X,Y,Z axes; gridx - enable grid for X axis; gridy - enable grid for X axis; grid - enable grid for X and Y axes; tickx - enable ticks for X axis; ticky - enable ticks for X axis; tick - enable ticks for X and Y axes; rx - reverse X axis; ry - reverse Y axis; rotate - rotate frame; fixframe - disable interactive moving of the frame; nozoomx - disable zooming on X axis; nozoomy - disable zooming on Y axis; cpXY - create palette XY for the canvas like cp50; nopalette - ignore palette stored with TCanvas; nocolors - ignore colors list stored with TCanvas; lcolors - use only locally colors list stored with TCanvas; nomargins - clear frame margins. 1.4 Superimposing draw objects; In the URL string one could use “+” sign to specify objects superposition:. item=hpx+hprof. With similar syntax one could specify individual draw options for superimposed objects. item=hpx+hprof&opt=logy+hist. Here “logy” option will be used for “hpx1” item and “hist” option for “hprof;1” item.; While draw option can include “+” sign itself, for superposition one could specify arrays of items and draw options like:. item=[hpx;1,hprof;1]&opt=[logy,hist]. 1.5 TTree draw; JSROOT provides pos",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:14278,Usability,simpl,simple,14278,"beginning - tracks - show tracks from TGeoManager - showtop - show top-level volume of TGeoManager (default off) - no_screen - let ignore kVisOnScreen bits for nodes visibility - dray - calculate rendering order using raytracing (extensive calculations) - dbox - use distance to nearest point from bounding box for rendering order (default) - dpnt - use distance to shape center as rendering order - dsize - use volume size as rendering order - ddflt - let three.js to calculate rendering order - comp - show left and right components of TGeoCompositeShape - compx - show all sub-components of TGeoCompositeShape; In the URL string several global settings can be changed:. geosegm - grads per segment is cylindrical shapes, default is 6; geocomp - compress results of composite shape production, default is true. It is possible to display only part of geometry model. For instance, one could select sub-item like:. file=rootgeom.root&item=simple1/TOP/REPLICA_1. Or one can use simple selection syntax (work only with first-level volumes):. item=simple1&opt=-bar1-bar2. Syntax uses ‘+’ sign to enable visibility flag of specified volume and ‘-’ sign to disable visibility. One could use wildcard symbol like ’+TUBE1*’.; Another way to configure visibility flags is usage of ROOT macros, which typically looks like:; {; TGeoManager::Import(""http://root.cern/files/alice2.root"");; gGeoManager->DefaultColors();; // gGeoManager->SetVisLevel(4);; gGeoManager->GetVolume(""HALL"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCC"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCA"")->InvisibleAll();; // ...; gGeoManager->GetVolume(""ALIC"")->Draw(""ogl"");; new TBrowser;; }; Example of such macro can be found in root tutorials.; From provided macro only following calls will be executed in JSROOT:. gGeoManager->DefaultColors(); gGeoManager->GetVolume(""HALL"")->InvisibleAll(); gGeoManager->GetVolume(""HALL"")->SetTransparency(30); gGeoManager->GetVolume(""HALL"")->SetLineColor(5); gGeoManager->GetVolume(""ALIC"")->Dr",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:17806,Usability,simpl,simplified,17806," should be aware of Same-origin policy, when the browser blocks requests to files from domains other than current web page. To enable CORS on Apache web server, hosting ROOT files, one should add following lines to .htaccess file:; <IfModule mod_headers.c>; <FilesMatch ""\.root"">; Header set Access-Control-Allow-Origin ""*""; Header set Access-Control-Allow-Headers ""range""; Header set Access-Control-Expose-Headers ""content-range,content-length,accept-ranges""; Header set Access-Control-Allow-Methods ""GET""; </FilesMatch>; </IfModule>; More details about configuring of CORS headers can be found here.; Alternative - enable CORS requests in the browser. It can be easily done with CORS Everywhere plugin for the Firefox browser or Allow CORS plugin for the Chrome browser.; Next solution - install JSROOT on the server hosting ROOT files. In such configuration JSROOT does not issue CORS requests, therefore server and browsers can be used with their default settings. A simplified variant of such solution - copy only the top index.htm file from JSROOT package and specify the full path to modules/gui.mjs script like:; <script type=""module"">; import { openFile, draw } from 'https://root.cern/js/latest/modules/gui.mjs';; // ...; </script>; In the main <div> element one can specify many custom parameters like one do it in URL string:; <div id=""simpleGUI"" path=""files/path"" files=""userfile1.root;subdir/usefile2.root"">; loading scripts ...; </div>; 1.8 Reading local ROOT files; JSROOT can read files from local file system using HTML5 FileReader functionality. Main limitation here - user should interactively select files for reading. There is button “…” on the main JSROOT page, which starts file selection dialog. If valid ROOT file is selected, JSROOT will be able to normally read content of such file.; 1.9 JSROOT with THttpServer; THttpServer provides http access to objects from running ROOT application. JSROOT is used to implement the user interface in the web browsers.; The layout of t",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:18183,Usability,simpl,simpleGUI,18183,"-Origin ""*""; Header set Access-Control-Allow-Headers ""range""; Header set Access-Control-Expose-Headers ""content-range,content-length,accept-ranges""; Header set Access-Control-Allow-Methods ""GET""; </FilesMatch>; </IfModule>; More details about configuring of CORS headers can be found here.; Alternative - enable CORS requests in the browser. It can be easily done with CORS Everywhere plugin for the Firefox browser or Allow CORS plugin for the Chrome browser.; Next solution - install JSROOT on the server hosting ROOT files. In such configuration JSROOT does not issue CORS requests, therefore server and browsers can be used with their default settings. A simplified variant of such solution - copy only the top index.htm file from JSROOT package and specify the full path to modules/gui.mjs script like:; <script type=""module"">; import { openFile, draw } from 'https://root.cern/js/latest/modules/gui.mjs';; // ...; </script>; In the main <div> element one can specify many custom parameters like one do it in URL string:; <div id=""simpleGUI"" path=""files/path"" files=""userfile1.root;subdir/usefile2.root"">; loading scripts ...; </div>; 1.8 Reading local ROOT files; JSROOT can read files from local file system using HTML5 FileReader functionality. Main limitation here - user should interactively select files for reading. There is button “…” on the main JSROOT page, which starts file selection dialog. If valid ROOT file is selected, JSROOT will be able to normally read content of such file.; 1.9 JSROOT with THttpServer; THttpServer provides http access to objects from running ROOT application. JSROOT is used to implement the user interface in the web browsers.; The layout of the main page coming from THttpServer is very similar to normal JSROOT page. One could browse existing items and display them. A snapshot of running server can be seen on the demo page.; One could also specify similar URL parameters to configure the displayed items and drawing options.; It is also possible to d",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:23956,Usability,simpl,simple,23956,"ename = ""https://root.cern/js/files/hsimple.root"";; let file = await openFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; </script>; Here the default location https://root.cern/js/latest/ is specified. One always can install JSROOT on private web server. When JSROOT is used with THttpServer, the address looks like:; <script type='module'>; import { httpRequest, draw } from 'http://your_root_server:8080/jsrootsys/modules/main.mjs';; let obj = await httpRequest('http://your_root_server:8080/Objects/hist/root.json','object');; await draw('drawing', obj, 'hist');; </script>; Loading main module is enough to get public JSROOT functionality - reading files and drawing objects. One also can load some special components directly like:; <script type='module'>; import { HierarchyPainter } from 'https://root.cern/js/latest/modules/gui.mjs';. let h = new HierarchyPainter(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; After script loading one can configure different parameters in gStyle object. It is instance of the TStyle object and behaves like gStyle variable in ROOT. For instance, to change stat format using to display value in stats box:; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; There is also settings object which contains all other JSROOT settings. For instance, one can configure custom format for different axes:; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; One also can use build/jsroot.js bundle to load all functionality at one and access it via JSROOT global handle:; <script src=""https://root.cern/js/latest/build/jsroo",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:24060,Usability,simpl,simple,24060,"enFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; </script>; Here the default location https://root.cern/js/latest/ is specified. One always can install JSROOT on private web server. When JSROOT is used with THttpServer, the address looks like:; <script type='module'>; import { httpRequest, draw } from 'http://your_root_server:8080/jsrootsys/modules/main.mjs';; let obj = await httpRequest('http://your_root_server:8080/Objects/hist/root.json','object');; await draw('drawing', obj, 'hist');; </script>; Loading main module is enough to get public JSROOT functionality - reading files and drawing objects. One also can load some special components directly like:; <script type='module'>; import { HierarchyPainter } from 'https://root.cern/js/latest/modules/gui.mjs';. let h = new HierarchyPainter(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; After script loading one can configure different parameters in gStyle object. It is instance of the TStyle object and behaves like gStyle variable in ROOT. For instance, to change stat format using to display value in stats box:; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; There is also settings object which contains all other JSROOT settings. For instance, one can configure custom format for different axes:; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; One also can use build/jsroot.js bundle to load all functionality at one and access it via JSROOT global handle:; <script src=""https://root.cern/js/latest/build/jsroot.js""></script>; <script>; // getting json string from somewhere; let o",MatchSource.WIKI,root/htmldoc/guides/JSROOT/JSROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:319,Availability,error,errors,319,". Minuit 2. Minuit 2; Fred JAMES and Matthias WINKLER. Minuit 2; 1 Foreword; 1.1 What M is intended to do; 1.2 What M is not intended to do; 1.3 Further remarks. 2 Introduction: M basic concepts; 2.1 The organization of M; 2.2 Design aspects of M in; 2.3 Internal and external parameters; 2.4 M strategy; 2.5 Parameter errors. 3 M installation; 3.1 M releases; 3.2 Install M using autoconf/make; 3.3 CVS code repository; 3.4 Create a tar.gz from CVS; 3.5 M versions; 3.6 Interference with other packages; 3.7 Floating-point precision. 4 How to use M; 4.1 The \(\mbox{FCN}\) Function; 4.2 M parameters; 4.3 Input to M; 4.4 Running a M minimization; 4.5 The output from minimization. 5 M application programming interface (API); 5.1 FunctionMinimum; 5.2 MnContours; 5.3 MnEigen; 5.4 MnHesse; 5.5 MnMachinePrecision; 5.6 MnMigrad and VariableMetricMinimizer; 5.7 MnMinimize and CombinedMinimizer; 5.8 MnMinos; 5.9 MnPlot; 5.10 MnScan and ScanMinimizer; 5.11 MnSimplex and SimplexMinimizer; 5.12 MnStrategy; 5.13 MnUserCovariance; 5.14 MnUserParameters; 5.15 MnUserParameterState; 5.16 MnPrint.h. 6 How to get the right answer from M; 6.1 Which minimizer to use; 6.2 Floating point precision; 6.3 Parameter limits; 6.4 Fixing and releasing parameters; 6.5 Interpretation of parameter errors; 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; 6.7 Additional trouble–shooting. 7 A complete example; 7.1 The user’s \(\mbox{FCN}\); 7.2 The user’s main program. Minuit 2; *** Fred JAMES and Matthias WINKLER CERN, Geneva ***; 1 Foreword; 1.1 What M is intended to do; M is conceived as a tool to find the minimum value of a multi-parameter function (the “\(\mbox{FCN}\)”) and analyze the shape of the function around the minimum. The principal application is foreseen for statistical analysis, working on chisquare or log-likelihood functions, to compute the best-fit parameter values and uncertainties, including correlations between the parameters. It is especially suited to handle difficult ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:1280,Availability,error,errors,1280,"ternal parameters; 2.4 M strategy; 2.5 Parameter errors. 3 M installation; 3.1 M releases; 3.2 Install M using autoconf/make; 3.3 CVS code repository; 3.4 Create a tar.gz from CVS; 3.5 M versions; 3.6 Interference with other packages; 3.7 Floating-point precision. 4 How to use M; 4.1 The \(\mbox{FCN}\) Function; 4.2 M parameters; 4.3 Input to M; 4.4 Running a M minimization; 4.5 The output from minimization. 5 M application programming interface (API); 5.1 FunctionMinimum; 5.2 MnContours; 5.3 MnEigen; 5.4 MnHesse; 5.5 MnMachinePrecision; 5.6 MnMigrad and VariableMetricMinimizer; 5.7 MnMinimize and CombinedMinimizer; 5.8 MnMinos; 5.9 MnPlot; 5.10 MnScan and ScanMinimizer; 5.11 MnSimplex and SimplexMinimizer; 5.12 MnStrategy; 5.13 MnUserCovariance; 5.14 MnUserParameters; 5.15 MnUserParameterState; 5.16 MnPrint.h. 6 How to get the right answer from M; 6.1 Which minimizer to use; 6.2 Floating point precision; 6.3 Parameter limits; 6.4 Fixing and releasing parameters; 6.5 Interpretation of parameter errors; 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; 6.7 Additional trouble–shooting. 7 A complete example; 7.1 The user’s \(\mbox{FCN}\); 7.2 The user’s main program. Minuit 2; *** Fred JAMES and Matthias WINKLER CERN, Geneva ***; 1 Foreword; 1.1 What M is intended to do; M is conceived as a tool to find the minimum value of a multi-parameter function (the “\(\mbox{FCN}\)”) and analyze the shape of the function around the minimum. The principal application is foreseen for statistical analysis, working on chisquare or log-likelihood functions, to compute the best-fit parameter values and uncertainties, including correlations between the parameters. It is especially suited to handle difficult problems, including those which may require guidance in order to find the correct solution.; 1.2 What M is not intended to do; Although M will of course solve easy problems faster than complicated ones, it is not intended for the repeated solution of identically parame",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:8655,Availability,error,error,8655,"transformation:. Squeeze out all parameters that are not variable.; Transform all variable parameters with limits, so that the transformed parameter can vary without limits. (See the next section for details concerning this transformation.) Because this transformation is non-linear, it is recommended to avoid putting limits on parameters where they are not needed. As an example, suppose that the user has defined the following parameters:. Parameter 0, constant.; Parameter 1, freely variable.; Parameter 2, variable with limits.; Parameter 3, constant.; Parameter 4, freely variable. Then the internal parameter list would be as follows:. Internal parameter 0 = external parameter 1.; Internal parameter 1 = external parameter 2, transformed appropriately.; Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters is 5, and the number of internal parameters is 3. This is the number which determines, for example, the size of the error matrix of the parameters, since only variable parameters have errors.; An important feature of M is that parameters are allowed to change types during the M minimization and analysis of a \(\mbox{FCN}\) function. Several applications in M have methods available to make variable parameters fixed and vice-versa; to impose, change, or remove limits from variable parameters; and even to define completely new parameters at any time during a run. In addition, some M applications (notably the \(\mbox{MINOS}\) error analysis) cause one or more variable parameters to be temporarily fixed during the calculation. Therefore, the correspondence between external and internal parameter lists is in general a dynamic one, and the number of internal parameters is not necessarily constant.; For more details about parameter interaction see [api:parameters].; 2.3.1 The transformation for parameters with limits; [intro:limits]; For variable parameters with double sided limits \(a\) (lower) and \(b\) (uppe",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:8723,Availability,error,errors,8723,"transformation:. Squeeze out all parameters that are not variable.; Transform all variable parameters with limits, so that the transformed parameter can vary without limits. (See the next section for details concerning this transformation.) Because this transformation is non-linear, it is recommended to avoid putting limits on parameters where they are not needed. As an example, suppose that the user has defined the following parameters:. Parameter 0, constant.; Parameter 1, freely variable.; Parameter 2, variable with limits.; Parameter 3, constant.; Parameter 4, freely variable. Then the internal parameter list would be as follows:. Internal parameter 0 = external parameter 1.; Internal parameter 1 = external parameter 2, transformed appropriately.; Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters is 5, and the number of internal parameters is 3. This is the number which determines, for example, the size of the error matrix of the parameters, since only variable parameters have errors.; An important feature of M is that parameters are allowed to change types during the M minimization and analysis of a \(\mbox{FCN}\) function. Several applications in M have methods available to make variable parameters fixed and vice-versa; to impose, change, or remove limits from variable parameters; and even to define completely new parameters at any time during a run. In addition, some M applications (notably the \(\mbox{MINOS}\) error analysis) cause one or more variable parameters to be temporarily fixed during the calculation. Therefore, the correspondence between external and internal parameter lists is in general a dynamic one, and the number of internal parameters is not necessarily constant.; For more details about parameter interaction see [api:parameters].; 2.3.1 The transformation for parameters with limits; [intro:limits]; For variable parameters with double sided limits \(a\) (lower) and \(b\) (uppe",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:8913,Availability,avail,available,8913,"arameters where they are not needed. As an example, suppose that the user has defined the following parameters:. Parameter 0, constant.; Parameter 1, freely variable.; Parameter 2, variable with limits.; Parameter 3, constant.; Parameter 4, freely variable. Then the internal parameter list would be as follows:. Internal parameter 0 = external parameter 1.; Internal parameter 1 = external parameter 2, transformed appropriately.; Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters is 5, and the number of internal parameters is 3. This is the number which determines, for example, the size of the error matrix of the parameters, since only variable parameters have errors.; An important feature of M is that parameters are allowed to change types during the M minimization and analysis of a \(\mbox{FCN}\) function. Several applications in M have methods available to make variable parameters fixed and vice-versa; to impose, change, or remove limits from variable parameters; and even to define completely new parameters at any time during a run. In addition, some M applications (notably the \(\mbox{MINOS}\) error analysis) cause one or more variable parameters to be temporarily fixed during the calculation. Therefore, the correspondence between external and internal parameter lists is in general a dynamic one, and the number of internal parameters is not necessarily constant.; For more details about parameter interaction see [api:parameters].; 2.3.1 The transformation for parameters with limits; [intro:limits]; For variable parameters with double sided limits \(a\) (lower) and \(b\) (upper), M uses the following transformation:; \[\begin{aligned}; P_{\mathrm{int}} &=& \arcsin; \left( 2\: \frac{ P_{\mathrm{ext}}-a}{ b-a} - 1 \right) \\; P_{\mathrm{ext}} &=& a + \frac{ b - a}{ 2}; \left( \sin P_{\mathrm{int}} + 1 \right) \end{aligned}\]; so that the internal value \(P_{\mathrm{int}}\) can take on any value, while ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:9169,Availability,error,error,9169,"its.; Parameter 3, constant.; Parameter 4, freely variable. Then the internal parameter list would be as follows:. Internal parameter 0 = external parameter 1.; Internal parameter 1 = external parameter 2, transformed appropriately.; Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters is 5, and the number of internal parameters is 3. This is the number which determines, for example, the size of the error matrix of the parameters, since only variable parameters have errors.; An important feature of M is that parameters are allowed to change types during the M minimization and analysis of a \(\mbox{FCN}\) function. Several applications in M have methods available to make variable parameters fixed and vice-versa; to impose, change, or remove limits from variable parameters; and even to define completely new parameters at any time during a run. In addition, some M applications (notably the \(\mbox{MINOS}\) error analysis) cause one or more variable parameters to be temporarily fixed during the calculation. Therefore, the correspondence between external and internal parameter lists is in general a dynamic one, and the number of internal parameters is not necessarily constant.; For more details about parameter interaction see [api:parameters].; 2.3.1 The transformation for parameters with limits; [intro:limits]; For variable parameters with double sided limits \(a\) (lower) and \(b\) (upper), M uses the following transformation:; \[\begin{aligned}; P_{\mathrm{int}} &=& \arcsin; \left( 2\: \frac{ P_{\mathrm{ext}}-a}{ b-a} - 1 \right) \\; P_{\mathrm{ext}} &=& a + \frac{ b - a}{ 2}; \left( \sin P_{\mathrm{int}} + 1 \right) \end{aligned}\]; so that the internal value \(P_{\mathrm{int}}\) can take on any value, while the external value \(P_{\mathrm{ext}}\) can take on values only between the lower limit \(a\) and the upper limit \(b\). Since the transformation is necessarily non-linear, it would transform a nice ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:10376,Availability,down,down,10376,"; For more details about parameter interaction see [api:parameters].; 2.3.1 The transformation for parameters with limits; [intro:limits]; For variable parameters with double sided limits \(a\) (lower) and \(b\) (upper), M uses the following transformation:; \[\begin{aligned}; P_{\mathrm{int}} &=& \arcsin; \left( 2\: \frac{ P_{\mathrm{ext}}-a}{ b-a} - 1 \right) \\; P_{\mathrm{ext}} &=& a + \frac{ b - a}{ 2}; \left( \sin P_{\mathrm{int}} + 1 \right) \end{aligned}\]; so that the internal value \(P_{\mathrm{int}}\) can take on any value, while the external value \(P_{\mathrm{ext}}\) can take on values only between the lower limit \(a\) and the upper limit \(b\). Since the transformation is necessarily non-linear, it would transform a nice linear problem into a nasty non-linear one, which is the reason why limits should be avoided if not necessary. In addition, the transformation does require some computer time, so it slows down the computation a little bit, and more importantly, it introduces additional numerical inaccuracy into the problem in addition to what is introduced in the numerical calculation of the \(\mbox{FCN}\) value. The effects of non-linearity and numerical roundoff both become more important as the external value gets closer to one of the limits (expressed as the distance to nearest limit divided by distance between limits). The user must therefore be aware of the fact that, for example, if they put limits of \((0,10^{10})\) on a parameter, then the values \(0.0\) and \(1.0\) will be indistinguishable to the accuracy of most machines.; For this purpose single sided limits on parameters are provided by M , with their transformation being:; Lower bound \(a\):; \[\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(P_{\mathrm{ext}} - a + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& a - 1 + \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}\]; Upper bound \(b\):; \[\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(b - P_{\mathrm{ext}} + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& b + 1 - \",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:11545,Availability,error,error,11545,"me computer time, so it slows down the computation a little bit, and more importantly, it introduces additional numerical inaccuracy into the problem in addition to what is introduced in the numerical calculation of the \(\mbox{FCN}\) value. The effects of non-linearity and numerical roundoff both become more important as the external value gets closer to one of the limits (expressed as the distance to nearest limit divided by distance between limits). The user must therefore be aware of the fact that, for example, if they put limits of \((0,10^{10})\) on a parameter, then the values \(0.0\) and \(1.0\) will be indistinguishable to the accuracy of most machines.; For this purpose single sided limits on parameters are provided by M , with their transformation being:; Lower bound \(a\):; \[\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(P_{\mathrm{ext}} - a + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& a - 1 + \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}\]; Upper bound \(b\):; \[\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(b - P_{\mathrm{ext}} + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& b + 1 - \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}\]; The transformation of course also affects the parameter error matrix, so M does a transformation of the error matrix (and the “parabolic” parameter errors) when there are parameter limits. Users should however realize that the transformation is only a linear approximation, and that it cannot give a meaningful result if one or more parameters is very close to a limit, where \(\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0\). Therefore, it is recommended that:. Limits on variable parameters should be used only when needed in order to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits. Further discussion of the effects of parameter limits may be found in the",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:11593,Availability,error,error,11593,"me computer time, so it slows down the computation a little bit, and more importantly, it introduces additional numerical inaccuracy into the problem in addition to what is introduced in the numerical calculation of the \(\mbox{FCN}\) value. The effects of non-linearity and numerical roundoff both become more important as the external value gets closer to one of the limits (expressed as the distance to nearest limit divided by distance between limits). The user must therefore be aware of the fact that, for example, if they put limits of \((0,10^{10})\) on a parameter, then the values \(0.0\) and \(1.0\) will be indistinguishable to the accuracy of most machines.; For this purpose single sided limits on parameters are provided by M , with their transformation being:; Lower bound \(a\):; \[\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(P_{\mathrm{ext}} - a + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& a - 1 + \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}\]; Upper bound \(b\):; \[\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(b - P_{\mathrm{ext}} + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& b + 1 - \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}\]; The transformation of course also affects the parameter error matrix, so M does a transformation of the error matrix (and the “parabolic” parameter errors) when there are parameter limits. Users should however realize that the transformation is only a linear approximation, and that it cannot give a meaningful result if one or more parameters is very close to a limit, where \(\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0\). Therefore, it is recommended that:. Limits on variable parameters should be used only when needed in order to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits. Further discussion of the effects of parameter limits may be found in the",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:11637,Availability,error,errors,11637,"me computer time, so it slows down the computation a little bit, and more importantly, it introduces additional numerical inaccuracy into the problem in addition to what is introduced in the numerical calculation of the \(\mbox{FCN}\) value. The effects of non-linearity and numerical roundoff both become more important as the external value gets closer to one of the limits (expressed as the distance to nearest limit divided by distance between limits). The user must therefore be aware of the fact that, for example, if they put limits of \((0,10^{10})\) on a parameter, then the values \(0.0\) and \(1.0\) will be indistinguishable to the accuracy of most machines.; For this purpose single sided limits on parameters are provided by M , with their transformation being:; Lower bound \(a\):; \[\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(P_{\mathrm{ext}} - a + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& a - 1 + \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}\]; Upper bound \(b\):; \[\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(b - P_{\mathrm{ext}} + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& b + 1 - \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}\]; The transformation of course also affects the parameter error matrix, so M does a transformation of the error matrix (and the “parabolic” parameter errors) when there are parameter limits. Users should however realize that the transformation is only a linear approximation, and that it cannot give a meaningful result if one or more parameters is very close to a limit, where \(\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0\). Therefore, it is recommended that:. Limits on variable parameters should be used only when needed in order to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits. Further discussion of the effects of parameter limits may be found in the",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:12243,Availability,error,error,12243,"\sqrt{(P_{\mathrm{ext}} - a + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& a - 1 + \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}\]; Upper bound \(b\):; \[\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(b - P_{\mathrm{ext}} + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& b + 1 - \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}\]; The transformation of course also affects the parameter error matrix, so M does a transformation of the error matrix (and the “parabolic” parameter errors) when there are parameter limits. Users should however realize that the transformation is only a linear approximation, and that it cannot give a meaningful result if one or more parameters is very close to a limit, where \(\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0\). Therefore, it is recommended that:. Limits on variable parameters should be used only when needed in order to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits. Further discussion of the effects of parameter limits may be found in the last chapter.; 2.4 M strategy; At many places in the analysis of the \(\mbox{FCN}\) (the user provided function), M must decide whether to be “safe” and waste a few function calls in order to know where it is, or to be “fast” and attempt to get the requested results with the fewest possible calls at a certain risk of not obtaining the precision desired by the user. In order to allow the user to influence these decisions, there is a M class MnStrategy (see [api:strategy]) which the user can use to put different settings. In the current release, this MnStrategy can be instantiated with three different minimization quality levels for low (0), medium (1) and high (2) quality. Default settings for iteration cycles and tolerances are initialized then. The default setting is set for medium quality. Value 0 (low) indicates to M that i",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:13071,Availability,toler,tolerances,13071," from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits. Further discussion of the effects of parameter limits may be found in the last chapter.; 2.4 M strategy; At many places in the analysis of the \(\mbox{FCN}\) (the user provided function), M must decide whether to be “safe” and waste a few function calls in order to know where it is, or to be “fast” and attempt to get the requested results with the fewest possible calls at a certain risk of not obtaining the precision desired by the user. In order to allow the user to influence these decisions, there is a M class MnStrategy (see [api:strategy]) which the user can use to put different settings. In the current release, this MnStrategy can be instantiated with three different minimization quality levels for low (0), medium (1) and high (2) quality. Default settings for iteration cycles and tolerances are initialized then. The default setting is set for medium quality. Value 0 (low) indicates to M that it should economize function calls; it is intended for cases where there are many variable parameters and/or the function takes a long time to calculate and/or the user is not interested in very precise values for parameter errors. On the other hand, value 2 (high) indicates that M is allowed to waste function calls in order to be sure that all values are precise; it is intended for cases where the function is evaluated in a relatively short time and/or where the parameter errors must be calculated reliably. In addition all constants set in MnStrategy can be changed individually by the user, e.g. the number of iteration cycles in the numerical gradient.; 2.5 Parameter errors; M is usually used to find the “best” values of a set of parameters, where “best” is defined as those values which minimize a given function, \(\mbox{FCN}\). The width of the function minimum, or m",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:13409,Availability,error,errors,13409,"iscussion of the effects of parameter limits may be found in the last chapter.; 2.4 M strategy; At many places in the analysis of the \(\mbox{FCN}\) (the user provided function), M must decide whether to be “safe” and waste a few function calls in order to know where it is, or to be “fast” and attempt to get the requested results with the fewest possible calls at a certain risk of not obtaining the precision desired by the user. In order to allow the user to influence these decisions, there is a M class MnStrategy (see [api:strategy]) which the user can use to put different settings. In the current release, this MnStrategy can be instantiated with three different minimization quality levels for low (0), medium (1) and high (2) quality. Default settings for iteration cycles and tolerances are initialized then. The default setting is set for medium quality. Value 0 (low) indicates to M that it should economize function calls; it is intended for cases where there are many variable parameters and/or the function takes a long time to calculate and/or the user is not interested in very precise values for parameter errors. On the other hand, value 2 (high) indicates that M is allowed to waste function calls in order to be sure that all values are precise; it is intended for cases where the function is evaluated in a relatively short time and/or where the parameter errors must be calculated reliably. In addition all constants set in MnStrategy can be changed individually by the user, e.g. the number of iteration cycles in the numerical gradient.; 2.5 Parameter errors; M is usually used to find the “best” values of a set of parameters, where “best” is defined as those values which minimize a given function, \(\mbox{FCN}\). The width of the function minimum, or more generally, the shape of the function in some neighbourhood of the minimum, gives information about the uncertainty in the best parameter values, often called by physicists the parameter errors. An important featur",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:13663,Availability,error,errors,13663," or to be “fast” and attempt to get the requested results with the fewest possible calls at a certain risk of not obtaining the precision desired by the user. In order to allow the user to influence these decisions, there is a M class MnStrategy (see [api:strategy]) which the user can use to put different settings. In the current release, this MnStrategy can be instantiated with three different minimization quality levels for low (0), medium (1) and high (2) quality. Default settings for iteration cycles and tolerances are initialized then. The default setting is set for medium quality. Value 0 (low) indicates to M that it should economize function calls; it is intended for cases where there are many variable parameters and/or the function takes a long time to calculate and/or the user is not interested in very precise values for parameter errors. On the other hand, value 2 (high) indicates that M is allowed to waste function calls in order to be sure that all values are precise; it is intended for cases where the function is evaluated in a relatively short time and/or where the parameter errors must be calculated reliably. In addition all constants set in MnStrategy can be changed individually by the user, e.g. the number of iteration cycles in the numerical gradient.; 2.5 Parameter errors; M is usually used to find the “best” values of a set of parameters, where “best” is defined as those values which minimize a given function, \(\mbox{FCN}\). The width of the function minimum, or more generally, the shape of the function in some neighbourhood of the minimum, gives information about the uncertainty in the best parameter values, often called by physicists the parameter errors. An important feature of M is that it offers several tools to analyze the parameter errors.; 2.5.1 \(\mbox{FCN}\) normalization and the error definition; Whatever method is used to calculate the parameter errors, they will depend on the overall (multiplicative) normalization of \(\mbox{FCN}\),",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:13689,Availability,reliab,reliably,13689," or to be “fast” and attempt to get the requested results with the fewest possible calls at a certain risk of not obtaining the precision desired by the user. In order to allow the user to influence these decisions, there is a M class MnStrategy (see [api:strategy]) which the user can use to put different settings. In the current release, this MnStrategy can be instantiated with three different minimization quality levels for low (0), medium (1) and high (2) quality. Default settings for iteration cycles and tolerances are initialized then. The default setting is set for medium quality. Value 0 (low) indicates to M that it should economize function calls; it is intended for cases where there are many variable parameters and/or the function takes a long time to calculate and/or the user is not interested in very precise values for parameter errors. On the other hand, value 2 (high) indicates that M is allowed to waste function calls in order to be sure that all values are precise; it is intended for cases where the function is evaluated in a relatively short time and/or where the parameter errors must be calculated reliably. In addition all constants set in MnStrategy can be changed individually by the user, e.g. the number of iteration cycles in the numerical gradient.; 2.5 Parameter errors; M is usually used to find the “best” values of a set of parameters, where “best” is defined as those values which minimize a given function, \(\mbox{FCN}\). The width of the function minimum, or more generally, the shape of the function in some neighbourhood of the minimum, gives information about the uncertainty in the best parameter values, often called by physicists the parameter errors. An important feature of M is that it offers several tools to analyze the parameter errors.; 2.5.1 \(\mbox{FCN}\) normalization and the error definition; Whatever method is used to calculate the parameter errors, they will depend on the overall (multiplicative) normalization of \(\mbox{FCN}\),",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:13862,Availability,error,errors,13862," three different minimization quality levels for low (0), medium (1) and high (2) quality. Default settings for iteration cycles and tolerances are initialized then. The default setting is set for medium quality. Value 0 (low) indicates to M that it should economize function calls; it is intended for cases where there are many variable parameters and/or the function takes a long time to calculate and/or the user is not interested in very precise values for parameter errors. On the other hand, value 2 (high) indicates that M is allowed to waste function calls in order to be sure that all values are precise; it is intended for cases where the function is evaluated in a relatively short time and/or where the parameter errors must be calculated reliably. In addition all constants set in MnStrategy can be changed individually by the user, e.g. the number of iteration cycles in the numerical gradient.; 2.5 Parameter errors; M is usually used to find the “best” values of a set of parameters, where “best” is defined as those values which minimize a given function, \(\mbox{FCN}\). The width of the function minimum, or more generally, the shape of the function in some neighbourhood of the minimum, gives information about the uncertainty in the best parameter values, often called by physicists the parameter errors. An important feature of M is that it offers several tools to analyze the parameter errors.; 2.5.1 \(\mbox{FCN}\) normalization and the error definition; Whatever method is used to calculate the parameter errors, they will depend on the overall (multiplicative) normalization of \(\mbox{FCN}\), in the sense that if the value of \(\mbox{FCN}\) is everywhere multiplied by a constant \(\beta\), then the errors will be decreased by a factor \(\sqrt{\beta}\). Additive constants do not change the parameter errors, but may imply a different goodness-of-fit confidence level.; Assuming that the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:14256,Availability,error,errors,14256,"ality. Value 0 (low) indicates to M that it should economize function calls; it is intended for cases where there are many variable parameters and/or the function takes a long time to calculate and/or the user is not interested in very precise values for parameter errors. On the other hand, value 2 (high) indicates that M is allowed to waste function calls in order to be sure that all values are precise; it is intended for cases where the function is evaluated in a relatively short time and/or where the parameter errors must be calculated reliably. In addition all constants set in MnStrategy can be changed individually by the user, e.g. the number of iteration cycles in the numerical gradient.; 2.5 Parameter errors; M is usually used to find the “best” values of a set of parameters, where “best” is defined as those values which minimize a given function, \(\mbox{FCN}\). The width of the function minimum, or more generally, the shape of the function in some neighbourhood of the minimum, gives information about the uncertainty in the best parameter values, often called by physicists the parameter errors. An important feature of M is that it offers several tools to analyze the parameter errors.; 2.5.1 \(\mbox{FCN}\) normalization and the error definition; Whatever method is used to calculate the parameter errors, they will depend on the overall (multiplicative) normalization of \(\mbox{FCN}\), in the sense that if the value of \(\mbox{FCN}\) is everywhere multiplied by a constant \(\beta\), then the errors will be decreased by a factor \(\sqrt{\beta}\). Additive constants do not change the parameter errors, but may imply a different goodness-of-fit confidence level.; Assuming that the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they are interested in parameter errors, the user can change the error definition which allows them to define what they means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be ca",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:14347,Availability,error,errors,14347,"akes a long time to calculate and/or the user is not interested in very precise values for parameter errors. On the other hand, value 2 (high) indicates that M is allowed to waste function calls in order to be sure that all values are precise; it is intended for cases where the function is evaluated in a relatively short time and/or where the parameter errors must be calculated reliably. In addition all constants set in MnStrategy can be changed individually by the user, e.g. the number of iteration cycles in the numerical gradient.; 2.5 Parameter errors; M is usually used to find the “best” values of a set of parameters, where “best” is defined as those values which minimize a given function, \(\mbox{FCN}\). The width of the function minimum, or more generally, the shape of the function in some neighbourhood of the minimum, gives information about the uncertainty in the best parameter values, often called by physicists the parameter errors. An important feature of M is that it offers several tools to analyze the parameter errors.; 2.5.1 \(\mbox{FCN}\) normalization and the error definition; Whatever method is used to calculate the parameter errors, they will depend on the overall (multiplicative) normalization of \(\mbox{FCN}\), in the sense that if the value of \(\mbox{FCN}\) is everywhere multiplied by a constant \(\beta\), then the errors will be decreased by a factor \(\sqrt{\beta}\). Additive constants do not change the parameter errors, but may imply a different goodness-of-fit confidence level.; Assuming that the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they are interested in parameter errors, the user can change the error definition which allows them to define what they means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one “error”. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-de",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:14399,Availability,error,error,14399,"re precise; it is intended for cases where the function is evaluated in a relatively short time and/or where the parameter errors must be calculated reliably. In addition all constants set in MnStrategy can be changed individually by the user, e.g. the number of iteration cycles in the numerical gradient.; 2.5 Parameter errors; M is usually used to find the “best” values of a set of parameters, where “best” is defined as those values which minimize a given function, \(\mbox{FCN}\). The width of the function minimum, or more generally, the shape of the function in some neighbourhood of the minimum, gives information about the uncertainty in the best parameter values, often called by physicists the parameter errors. An important feature of M is that it offers several tools to analyze the parameter errors.; 2.5.1 \(\mbox{FCN}\) normalization and the error definition; Whatever method is used to calculate the parameter errors, they will depend on the overall (multiplicative) normalization of \(\mbox{FCN}\), in the sense that if the value of \(\mbox{FCN}\) is everywhere multiplied by a constant \(\beta\), then the errors will be decreased by a factor \(\sqrt{\beta}\). Additive constants do not change the parameter errors, but may imply a different goodness-of-fit confidence level.; Assuming that the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they are interested in parameter errors, the user can change the error definition which allows them to define what they means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one “error”. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-deviation errors, then the error definition (return value of the FCNBase::up() method, see [howto:errordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FC",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:14468,Availability,error,errors,14468,"re precise; it is intended for cases where the function is evaluated in a relatively short time and/or where the parameter errors must be calculated reliably. In addition all constants set in MnStrategy can be changed individually by the user, e.g. the number of iteration cycles in the numerical gradient.; 2.5 Parameter errors; M is usually used to find the “best” values of a set of parameters, where “best” is defined as those values which minimize a given function, \(\mbox{FCN}\). The width of the function minimum, or more generally, the shape of the function in some neighbourhood of the minimum, gives information about the uncertainty in the best parameter values, often called by physicists the parameter errors. An important feature of M is that it offers several tools to analyze the parameter errors.; 2.5.1 \(\mbox{FCN}\) normalization and the error definition; Whatever method is used to calculate the parameter errors, they will depend on the overall (multiplicative) normalization of \(\mbox{FCN}\), in the sense that if the value of \(\mbox{FCN}\) is everywhere multiplied by a constant \(\beta\), then the errors will be decreased by a factor \(\sqrt{\beta}\). Additive constants do not change the parameter errors, but may imply a different goodness-of-fit confidence level.; Assuming that the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they are interested in parameter errors, the user can change the error definition which allows them to define what they means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one “error”. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-deviation errors, then the error definition (return value of the FCNBase::up() method, see [howto:errordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FC",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:14666,Availability,error,errors,14666,"re precise; it is intended for cases where the function is evaluated in a relatively short time and/or where the parameter errors must be calculated reliably. In addition all constants set in MnStrategy can be changed individually by the user, e.g. the number of iteration cycles in the numerical gradient.; 2.5 Parameter errors; M is usually used to find the “best” values of a set of parameters, where “best” is defined as those values which minimize a given function, \(\mbox{FCN}\). The width of the function minimum, or more generally, the shape of the function in some neighbourhood of the minimum, gives information about the uncertainty in the best parameter values, often called by physicists the parameter errors. An important feature of M is that it offers several tools to analyze the parameter errors.; 2.5.1 \(\mbox{FCN}\) normalization and the error definition; Whatever method is used to calculate the parameter errors, they will depend on the overall (multiplicative) normalization of \(\mbox{FCN}\), in the sense that if the value of \(\mbox{FCN}\) is everywhere multiplied by a constant \(\beta\), then the errors will be decreased by a factor \(\sqrt{\beta}\). Additive constants do not change the parameter errors, but may imply a different goodness-of-fit confidence level.; Assuming that the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they are interested in parameter errors, the user can change the error definition which allows them to define what they means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one “error”. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-deviation errors, then the error definition (return value of the FCNBase::up() method, see [howto:errordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FC",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:14768,Availability,error,errors,14768," user, e.g. the number of iteration cycles in the numerical gradient.; 2.5 Parameter errors; M is usually used to find the “best” values of a set of parameters, where “best” is defined as those values which minimize a given function, \(\mbox{FCN}\). The width of the function minimum, or more generally, the shape of the function in some neighbourhood of the minimum, gives information about the uncertainty in the best parameter values, often called by physicists the parameter errors. An important feature of M is that it offers several tools to analyze the parameter errors.; 2.5.1 \(\mbox{FCN}\) normalization and the error definition; Whatever method is used to calculate the parameter errors, they will depend on the overall (multiplicative) normalization of \(\mbox{FCN}\), in the sense that if the value of \(\mbox{FCN}\) is everywhere multiplied by a constant \(\beta\), then the errors will be decreased by a factor \(\sqrt{\beta}\). Additive constants do not change the parameter errors, but may imply a different goodness-of-fit confidence level.; Assuming that the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they are interested in parameter errors, the user can change the error definition which allows them to define what they means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one “error”. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-deviation errors, then the error definition (return value of the FCNBase::up() method, see [howto:errordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FCNBase::up() to return is \(0.5\). If the \(\mbox{FCN}\) is a chisquare, but the user wants two-standard-deviation errors, then FCNBase::up() should return \(= 4.0\), etc.; Note that in the usual case where M is being used to perform a fit",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:14967,Availability,error,errors,14967,"\mbox{FCN}\). The width of the function minimum, or more generally, the shape of the function in some neighbourhood of the minimum, gives information about the uncertainty in the best parameter values, often called by physicists the parameter errors. An important feature of M is that it offers several tools to analyze the parameter errors.; 2.5.1 \(\mbox{FCN}\) normalization and the error definition; Whatever method is used to calculate the parameter errors, they will depend on the overall (multiplicative) normalization of \(\mbox{FCN}\), in the sense that if the value of \(\mbox{FCN}\) is everywhere multiplied by a constant \(\beta\), then the errors will be decreased by a factor \(\sqrt{\beta}\). Additive constants do not change the parameter errors, but may imply a different goodness-of-fit confidence level.; Assuming that the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they are interested in parameter errors, the user can change the error definition which allows them to define what they means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one “error”. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-deviation errors, then the error definition (return value of the FCNBase::up() method, see [howto:errordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FCNBase::up() to return is \(0.5\). If the \(\mbox{FCN}\) is a chisquare, but the user wants two-standard-deviation errors, then FCNBase::up() should return \(= 4.0\), etc.; Note that in the usual case where M is being used to perform a fit to some experimental data, the parameter errors will be proportional to the uncertainty in the data, and therefore meaningful parameter errors cannot be obtained unless the measurement errors of the data are known. In the common case ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:14999,Availability,error,error,14999,"\mbox{FCN}\). The width of the function minimum, or more generally, the shape of the function in some neighbourhood of the minimum, gives information about the uncertainty in the best parameter values, often called by physicists the parameter errors. An important feature of M is that it offers several tools to analyze the parameter errors.; 2.5.1 \(\mbox{FCN}\) normalization and the error definition; Whatever method is used to calculate the parameter errors, they will depend on the overall (multiplicative) normalization of \(\mbox{FCN}\), in the sense that if the value of \(\mbox{FCN}\) is everywhere multiplied by a constant \(\beta\), then the errors will be decreased by a factor \(\sqrt{\beta}\). Additive constants do not change the parameter errors, but may imply a different goodness-of-fit confidence level.; Assuming that the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they are interested in parameter errors, the user can change the error definition which allows them to define what they means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one “error”. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-deviation errors, then the error definition (return value of the FCNBase::up() method, see [howto:errordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FCNBase::up() to return is \(0.5\). If the \(\mbox{FCN}\) is a chisquare, but the user wants two-standard-deviation errors, then FCNBase::up() should return \(= 4.0\), etc.; Note that in the usual case where M is being used to perform a fit to some experimental data, the parameter errors will be proportional to the uncertainty in the data, and therefore meaningful parameter errors cannot be obtained unless the measurement errors of the data are known. In the common case ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:15068,Availability,error,error,15068,"\mbox{FCN}\). The width of the function minimum, or more generally, the shape of the function in some neighbourhood of the minimum, gives information about the uncertainty in the best parameter values, often called by physicists the parameter errors. An important feature of M is that it offers several tools to analyze the parameter errors.; 2.5.1 \(\mbox{FCN}\) normalization and the error definition; Whatever method is used to calculate the parameter errors, they will depend on the overall (multiplicative) normalization of \(\mbox{FCN}\), in the sense that if the value of \(\mbox{FCN}\) is everywhere multiplied by a constant \(\beta\), then the errors will be decreased by a factor \(\sqrt{\beta}\). Additive constants do not change the parameter errors, but may imply a different goodness-of-fit confidence level.; Assuming that the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they are interested in parameter errors, the user can change the error definition which allows them to define what they means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one “error”. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-deviation errors, then the error definition (return value of the FCNBase::up() method, see [howto:errordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FCNBase::up() to return is \(0.5\). If the \(\mbox{FCN}\) is a chisquare, but the user wants two-standard-deviation errors, then FCNBase::up() should return \(= 4.0\), etc.; Note that in the usual case where M is being used to perform a fit to some experimental data, the parameter errors will be proportional to the uncertainty in the data, and therefore meaningful parameter errors cannot be obtained unless the measurement errors of the data are known. In the common case ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:15184,Availability,error,error,15184,"\mbox{FCN}\). The width of the function minimum, or more generally, the shape of the function in some neighbourhood of the minimum, gives information about the uncertainty in the best parameter values, often called by physicists the parameter errors. An important feature of M is that it offers several tools to analyze the parameter errors.; 2.5.1 \(\mbox{FCN}\) normalization and the error definition; Whatever method is used to calculate the parameter errors, they will depend on the overall (multiplicative) normalization of \(\mbox{FCN}\), in the sense that if the value of \(\mbox{FCN}\) is everywhere multiplied by a constant \(\beta\), then the errors will be decreased by a factor \(\sqrt{\beta}\). Additive constants do not change the parameter errors, but may imply a different goodness-of-fit confidence level.; Assuming that the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they are interested in parameter errors, the user can change the error definition which allows them to define what they means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one “error”. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-deviation errors, then the error definition (return value of the FCNBase::up() method, see [howto:errordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FCNBase::up() to return is \(0.5\). If the \(\mbox{FCN}\) is a chisquare, but the user wants two-standard-deviation errors, then FCNBase::up() should return \(= 4.0\), etc.; Note that in the usual case where M is being used to perform a fit to some experimental data, the parameter errors will be proportional to the uncertainty in the data, and therefore meaningful parameter errors cannot be obtained unless the measurement errors of the data are known. In the common case ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:15317,Availability,error,errors,15317,"veral tools to analyze the parameter errors.; 2.5.1 \(\mbox{FCN}\) normalization and the error definition; Whatever method is used to calculate the parameter errors, they will depend on the overall (multiplicative) normalization of \(\mbox{FCN}\), in the sense that if the value of \(\mbox{FCN}\) is everywhere multiplied by a constant \(\beta\), then the errors will be decreased by a factor \(\sqrt{\beta}\). Additive constants do not change the parameter errors, but may imply a different goodness-of-fit confidence level.; Assuming that the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they are interested in parameter errors, the user can change the error definition which allows them to define what they means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one “error”. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-deviation errors, then the error definition (return value of the FCNBase::up() method, see [howto:errordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FCNBase::up() to return is \(0.5\). If the \(\mbox{FCN}\) is a chisquare, but the user wants two-standard-deviation errors, then FCNBase::up() should return \(= 4.0\), etc.; Note that in the usual case where M is being used to perform a fit to some experimental data, the parameter errors will be proportional to the uncertainty in the data, and therefore meaningful parameter errors cannot be obtained unless the measurement errors of the data are known. In the common case of a least-squares fit, \(\mbox{FCN}\) is usually defined as a chisquare:; \[\chi^2 (\alpha) = \sum_{i=1}^{n} (\frac{f(x_i,\alpha) - m_i)^2}{\sigma_i^2}\]; where \(\alpha\) is the vector of free parameters being fitted, and the \(\sigma_i\) are the uncertainties in the individual measurements \(m_",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:15334,Availability,error,error,15334,"veral tools to analyze the parameter errors.; 2.5.1 \(\mbox{FCN}\) normalization and the error definition; Whatever method is used to calculate the parameter errors, they will depend on the overall (multiplicative) normalization of \(\mbox{FCN}\), in the sense that if the value of \(\mbox{FCN}\) is everywhere multiplied by a constant \(\beta\), then the errors will be decreased by a factor \(\sqrt{\beta}\). Additive constants do not change the parameter errors, but may imply a different goodness-of-fit confidence level.; Assuming that the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they are interested in parameter errors, the user can change the error definition which allows them to define what they means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one “error”. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-deviation errors, then the error definition (return value of the FCNBase::up() method, see [howto:errordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FCNBase::up() to return is \(0.5\). If the \(\mbox{FCN}\) is a chisquare, but the user wants two-standard-deviation errors, then FCNBase::up() should return \(= 4.0\), etc.; Note that in the usual case where M is being used to perform a fit to some experimental data, the parameter errors will be proportional to the uncertainty in the data, and therefore meaningful parameter errors cannot be obtained unless the measurement errors of the data are known. In the common case of a least-squares fit, \(\mbox{FCN}\) is usually defined as a chisquare:; \[\chi^2 (\alpha) = \sum_{i=1}^{n} (\frac{f(x_i,\alpha) - m_i)^2}{\sigma_i^2}\]; where \(\alpha\) is the vector of free parameters being fitted, and the \(\sigma_i\) are the uncertainties in the individual measurements \(m_",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:15405,Availability,error,errordef,15405,"veral tools to analyze the parameter errors.; 2.5.1 \(\mbox{FCN}\) normalization and the error definition; Whatever method is used to calculate the parameter errors, they will depend on the overall (multiplicative) normalization of \(\mbox{FCN}\), in the sense that if the value of \(\mbox{FCN}\) is everywhere multiplied by a constant \(\beta\), then the errors will be decreased by a factor \(\sqrt{\beta}\). Additive constants do not change the parameter errors, but may imply a different goodness-of-fit confidence level.; Assuming that the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they are interested in parameter errors, the user can change the error definition which allows them to define what they means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one “error”. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-deviation errors, then the error definition (return value of the FCNBase::up() method, see [howto:errordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FCNBase::up() to return is \(0.5\). If the \(\mbox{FCN}\) is a chisquare, but the user wants two-standard-deviation errors, then FCNBase::up() should return \(= 4.0\), etc.; Note that in the usual case where M is being used to perform a fit to some experimental data, the parameter errors will be proportional to the uncertainty in the data, and therefore meaningful parameter errors cannot be obtained unless the measurement errors of the data are known. In the common case of a least-squares fit, \(\mbox{FCN}\) is usually defined as a chisquare:; \[\chi^2 (\alpha) = \sum_{i=1}^{n} (\frac{f(x_i,\alpha) - m_i)^2}{\sigma_i^2}\]; where \(\alpha\) is the vector of free parameters being fitted, and the \(\sigma_i\) are the uncertainties in the individual measurements \(m_",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:15654,Availability,error,errors,15654,"constant \(\beta\), then the errors will be decreased by a factor \(\sqrt{\beta}\). Additive constants do not change the parameter errors, but may imply a different goodness-of-fit confidence level.; Assuming that the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they are interested in parameter errors, the user can change the error definition which allows them to define what they means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one “error”. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-deviation errors, then the error definition (return value of the FCNBase::up() method, see [howto:errordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FCNBase::up() to return is \(0.5\). If the \(\mbox{FCN}\) is a chisquare, but the user wants two-standard-deviation errors, then FCNBase::up() should return \(= 4.0\), etc.; Note that in the usual case where M is being used to perform a fit to some experimental data, the parameter errors will be proportional to the uncertainty in the data, and therefore meaningful parameter errors cannot be obtained unless the measurement errors of the data are known. In the common case of a least-squares fit, \(\mbox{FCN}\) is usually defined as a chisquare:; \[\chi^2 (\alpha) = \sum_{i=1}^{n} (\frac{f(x_i,\alpha) - m_i)^2}{\sigma_i^2}\]; where \(\alpha\) is the vector of free parameters being fitted, and the \(\sigma_i\) are the uncertainties in the individual measurements \(m_i\). If these uncertainties are not known, and are simply left out of the calculation, then the fit may still have meaning, but not the quantitative values of the resulting parameter errors. (Only the relative errors of different parameters with respect to each other may be meaningful.); If the \(\sigma_i\) are all overestim",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:15820,Availability,error,errors,15820,"the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they are interested in parameter errors, the user can change the error definition which allows them to define what they means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one “error”. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-deviation errors, then the error definition (return value of the FCNBase::up() method, see [howto:errordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FCNBase::up() to return is \(0.5\). If the \(\mbox{FCN}\) is a chisquare, but the user wants two-standard-deviation errors, then FCNBase::up() should return \(= 4.0\), etc.; Note that in the usual case where M is being used to perform a fit to some experimental data, the parameter errors will be proportional to the uncertainty in the data, and therefore meaningful parameter errors cannot be obtained unless the measurement errors of the data are known. In the common case of a least-squares fit, \(\mbox{FCN}\) is usually defined as a chisquare:; \[\chi^2 (\alpha) = \sum_{i=1}^{n} (\frac{f(x_i,\alpha) - m_i)^2}{\sigma_i^2}\]; where \(\alpha\) is the vector of free parameters being fitted, and the \(\sigma_i\) are the uncertainties in the individual measurements \(m_i\). If these uncertainties are not known, and are simply left out of the calculation, then the fit may still have meaning, but not the quantitative values of the resulting parameter errors. (Only the relative errors of different parameters with respect to each other may be meaningful.); If the \(\sigma_i\) are all overestimated by a factor \(\beta\), then the resulting parameter errors from the fit will be overestimated by the same factor \(\beta\).; 2.5.2 The error matrix; The M processors \(\mbox{MIGRAD}\) (MnMigrad, see [api:migrad",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:15915,Availability,error,errors,15915,"the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they are interested in parameter errors, the user can change the error definition which allows them to define what they means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one “error”. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-deviation errors, then the error definition (return value of the FCNBase::up() method, see [howto:errordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FCNBase::up() to return is \(0.5\). If the \(\mbox{FCN}\) is a chisquare, but the user wants two-standard-deviation errors, then FCNBase::up() should return \(= 4.0\), etc.; Note that in the usual case where M is being used to perform a fit to some experimental data, the parameter errors will be proportional to the uncertainty in the data, and therefore meaningful parameter errors cannot be obtained unless the measurement errors of the data are known. In the common case of a least-squares fit, \(\mbox{FCN}\) is usually defined as a chisquare:; \[\chi^2 (\alpha) = \sum_{i=1}^{n} (\frac{f(x_i,\alpha) - m_i)^2}{\sigma_i^2}\]; where \(\alpha\) is the vector of free parameters being fitted, and the \(\sigma_i\) are the uncertainties in the individual measurements \(m_i\). If these uncertainties are not known, and are simply left out of the calculation, then the fit may still have meaning, but not the quantitative values of the resulting parameter errors. (Only the relative errors of different parameters with respect to each other may be meaningful.); If the \(\sigma_i\) are all overestimated by a factor \(\beta\), then the resulting parameter errors from the fit will be overestimated by the same factor \(\beta\).; 2.5.2 The error matrix; The M processors \(\mbox{MIGRAD}\) (MnMigrad, see [api:migrad",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:15964,Availability,error,errors,15964,"the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they are interested in parameter errors, the user can change the error definition which allows them to define what they means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one “error”. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-deviation errors, then the error definition (return value of the FCNBase::up() method, see [howto:errordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FCNBase::up() to return is \(0.5\). If the \(\mbox{FCN}\) is a chisquare, but the user wants two-standard-deviation errors, then FCNBase::up() should return \(= 4.0\), etc.; Note that in the usual case where M is being used to perform a fit to some experimental data, the parameter errors will be proportional to the uncertainty in the data, and therefore meaningful parameter errors cannot be obtained unless the measurement errors of the data are known. In the common case of a least-squares fit, \(\mbox{FCN}\) is usually defined as a chisquare:; \[\chi^2 (\alpha) = \sum_{i=1}^{n} (\frac{f(x_i,\alpha) - m_i)^2}{\sigma_i^2}\]; where \(\alpha\) is the vector of free parameters being fitted, and the \(\sigma_i\) are the uncertainties in the individual measurements \(m_i\). If these uncertainties are not known, and are simply left out of the calculation, then the fit may still have meaning, but not the quantitative values of the resulting parameter errors. (Only the relative errors of different parameters with respect to each other may be meaningful.); If the \(\sigma_i\) are all overestimated by a factor \(\beta\), then the resulting parameter errors from the fit will be overestimated by the same factor \(\beta\).; 2.5.2 The error matrix; The M processors \(\mbox{MIGRAD}\) (MnMigrad, see [api:migrad",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:16494,Availability,error,errors,16494,"ordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FCNBase::up() to return is \(0.5\). If the \(\mbox{FCN}\) is a chisquare, but the user wants two-standard-deviation errors, then FCNBase::up() should return \(= 4.0\), etc.; Note that in the usual case where M is being used to perform a fit to some experimental data, the parameter errors will be proportional to the uncertainty in the data, and therefore meaningful parameter errors cannot be obtained unless the measurement errors of the data are known. In the common case of a least-squares fit, \(\mbox{FCN}\) is usually defined as a chisquare:; \[\chi^2 (\alpha) = \sum_{i=1}^{n} (\frac{f(x_i,\alpha) - m_i)^2}{\sigma_i^2}\]; where \(\alpha\) is the vector of free parameters being fitted, and the \(\sigma_i\) are the uncertainties in the individual measurements \(m_i\). If these uncertainties are not known, and are simply left out of the calculation, then the fit may still have meaning, but not the quantitative values of the resulting parameter errors. (Only the relative errors of different parameters with respect to each other may be meaningful.); If the \(\sigma_i\) are all overestimated by a factor \(\beta\), then the resulting parameter errors from the fit will be overestimated by the same factor \(\beta\).; 2.5.2 The error matrix; The M processors \(\mbox{MIGRAD}\) (MnMigrad, see [api:migrad]) and HESSE (MnHesse, see [api:hesse]) (normally) produce an error matrix. This matrix is twice the inverse of the matrix of second derivatives of the \(\mbox{FCN}\), transformed if necessary into external coordinate space2, and multiplied by FCNBase::up(). Therefore, errors based on the M error matrix take account of all the parameter correlations, but not the non-linearities. That is, from the error matrix alone, two-standard-deviation errors are always exactly twice as big as one-standard-deviation errors.; When the error matrix has been calculat",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:16521,Availability,error,errors,16521,"() to return is \(0.5\). If the \(\mbox{FCN}\) is a chisquare, but the user wants two-standard-deviation errors, then FCNBase::up() should return \(= 4.0\), etc.; Note that in the usual case where M is being used to perform a fit to some experimental data, the parameter errors will be proportional to the uncertainty in the data, and therefore meaningful parameter errors cannot be obtained unless the measurement errors of the data are known. In the common case of a least-squares fit, \(\mbox{FCN}\) is usually defined as a chisquare:; \[\chi^2 (\alpha) = \sum_{i=1}^{n} (\frac{f(x_i,\alpha) - m_i)^2}{\sigma_i^2}\]; where \(\alpha\) is the vector of free parameters being fitted, and the \(\sigma_i\) are the uncertainties in the individual measurements \(m_i\). If these uncertainties are not known, and are simply left out of the calculation, then the fit may still have meaning, but not the quantitative values of the resulting parameter errors. (Only the relative errors of different parameters with respect to each other may be meaningful.); If the \(\sigma_i\) are all overestimated by a factor \(\beta\), then the resulting parameter errors from the fit will be overestimated by the same factor \(\beta\).; 2.5.2 The error matrix; The M processors \(\mbox{MIGRAD}\) (MnMigrad, see [api:migrad]) and HESSE (MnHesse, see [api:hesse]) (normally) produce an error matrix. This matrix is twice the inverse of the matrix of second derivatives of the \(\mbox{FCN}\), transformed if necessary into external coordinate space2, and multiplied by FCNBase::up(). Therefore, errors based on the M error matrix take account of all the parameter correlations, but not the non-linearities. That is, from the error matrix alone, two-standard-deviation errors are always exactly twice as big as one-standard-deviation errors.; When the error matrix has been calculated (for example by the successful execution of \(\mbox{MIGRAD}\) (MnMigrad::operator(), see [api:migradop]) or HESSE (MnHesse::operator())) t",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:16694,Availability,error,errors,16694,"should return \(= 4.0\), etc.; Note that in the usual case where M is being used to perform a fit to some experimental data, the parameter errors will be proportional to the uncertainty in the data, and therefore meaningful parameter errors cannot be obtained unless the measurement errors of the data are known. In the common case of a least-squares fit, \(\mbox{FCN}\) is usually defined as a chisquare:; \[\chi^2 (\alpha) = \sum_{i=1}^{n} (\frac{f(x_i,\alpha) - m_i)^2}{\sigma_i^2}\]; where \(\alpha\) is the vector of free parameters being fitted, and the \(\sigma_i\) are the uncertainties in the individual measurements \(m_i\). If these uncertainties are not known, and are simply left out of the calculation, then the fit may still have meaning, but not the quantitative values of the resulting parameter errors. (Only the relative errors of different parameters with respect to each other may be meaningful.); If the \(\sigma_i\) are all overestimated by a factor \(\beta\), then the resulting parameter errors from the fit will be overestimated by the same factor \(\beta\).; 2.5.2 The error matrix; The M processors \(\mbox{MIGRAD}\) (MnMigrad, see [api:migrad]) and HESSE (MnHesse, see [api:hesse]) (normally) produce an error matrix. This matrix is twice the inverse of the matrix of second derivatives of the \(\mbox{FCN}\), transformed if necessary into external coordinate space2, and multiplied by FCNBase::up(). Therefore, errors based on the M error matrix take account of all the parameter correlations, but not the non-linearities. That is, from the error matrix alone, two-standard-deviation errors are always exactly twice as big as one-standard-deviation errors.; When the error matrix has been calculated (for example by the successful execution of \(\mbox{MIGRAD}\) (MnMigrad::operator(), see [api:migradop]) or HESSE (MnHesse::operator())) then the parameter errors printed by M are the square roots of the diagonal elements of this matrix. The covariance or the correlatio",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:16777,Availability,error,error,16777,"o the uncertainty in the data, and therefore meaningful parameter errors cannot be obtained unless the measurement errors of the data are known. In the common case of a least-squares fit, \(\mbox{FCN}\) is usually defined as a chisquare:; \[\chi^2 (\alpha) = \sum_{i=1}^{n} (\frac{f(x_i,\alpha) - m_i)^2}{\sigma_i^2}\]; where \(\alpha\) is the vector of free parameters being fitted, and the \(\sigma_i\) are the uncertainties in the individual measurements \(m_i\). If these uncertainties are not known, and are simply left out of the calculation, then the fit may still have meaning, but not the quantitative values of the resulting parameter errors. (Only the relative errors of different parameters with respect to each other may be meaningful.); If the \(\sigma_i\) are all overestimated by a factor \(\beta\), then the resulting parameter errors from the fit will be overestimated by the same factor \(\beta\).; 2.5.2 The error matrix; The M processors \(\mbox{MIGRAD}\) (MnMigrad, see [api:migrad]) and HESSE (MnHesse, see [api:hesse]) (normally) produce an error matrix. This matrix is twice the inverse of the matrix of second derivatives of the \(\mbox{FCN}\), transformed if necessary into external coordinate space2, and multiplied by FCNBase::up(). Therefore, errors based on the M error matrix take account of all the parameter correlations, but not the non-linearities. That is, from the error matrix alone, two-standard-deviation errors are always exactly twice as big as one-standard-deviation errors.; When the error matrix has been calculated (for example by the successful execution of \(\mbox{MIGRAD}\) (MnMigrad::operator(), see [api:migradop]) or HESSE (MnHesse::operator())) then the parameter errors printed by M are the square roots of the diagonal elements of this matrix. The covariance or the correlations can be printed and shown via std::cout as the ostream operator operator\(<<\) is overloaded. The eigenvalues of the error matrix can be calculated using MnEigen, whi",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:16914,Availability,error,error,16914,"o the uncertainty in the data, and therefore meaningful parameter errors cannot be obtained unless the measurement errors of the data are known. In the common case of a least-squares fit, \(\mbox{FCN}\) is usually defined as a chisquare:; \[\chi^2 (\alpha) = \sum_{i=1}^{n} (\frac{f(x_i,\alpha) - m_i)^2}{\sigma_i^2}\]; where \(\alpha\) is the vector of free parameters being fitted, and the \(\sigma_i\) are the uncertainties in the individual measurements \(m_i\). If these uncertainties are not known, and are simply left out of the calculation, then the fit may still have meaning, but not the quantitative values of the resulting parameter errors. (Only the relative errors of different parameters with respect to each other may be meaningful.); If the \(\sigma_i\) are all overestimated by a factor \(\beta\), then the resulting parameter errors from the fit will be overestimated by the same factor \(\beta\).; 2.5.2 The error matrix; The M processors \(\mbox{MIGRAD}\) (MnMigrad, see [api:migrad]) and HESSE (MnHesse, see [api:hesse]) (normally) produce an error matrix. This matrix is twice the inverse of the matrix of second derivatives of the \(\mbox{FCN}\), transformed if necessary into external coordinate space2, and multiplied by FCNBase::up(). Therefore, errors based on the M error matrix take account of all the parameter correlations, but not the non-linearities. That is, from the error matrix alone, two-standard-deviation errors are always exactly twice as big as one-standard-deviation errors.; When the error matrix has been calculated (for example by the successful execution of \(\mbox{MIGRAD}\) (MnMigrad::operator(), see [api:migradop]) or HESSE (MnHesse::operator())) then the parameter errors printed by M are the square roots of the diagonal elements of this matrix. The covariance or the correlations can be printed and shown via std::cout as the ostream operator operator\(<<\) is overloaded. The eigenvalues of the error matrix can be calculated using MnEigen, whi",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:17122,Availability,error,errors,17122,"ere \(\alpha\) is the vector of free parameters being fitted, and the \(\sigma_i\) are the uncertainties in the individual measurements \(m_i\). If these uncertainties are not known, and are simply left out of the calculation, then the fit may still have meaning, but not the quantitative values of the resulting parameter errors. (Only the relative errors of different parameters with respect to each other may be meaningful.); If the \(\sigma_i\) are all overestimated by a factor \(\beta\), then the resulting parameter errors from the fit will be overestimated by the same factor \(\beta\).; 2.5.2 The error matrix; The M processors \(\mbox{MIGRAD}\) (MnMigrad, see [api:migrad]) and HESSE (MnHesse, see [api:hesse]) (normally) produce an error matrix. This matrix is twice the inverse of the matrix of second derivatives of the \(\mbox{FCN}\), transformed if necessary into external coordinate space2, and multiplied by FCNBase::up(). Therefore, errors based on the M error matrix take account of all the parameter correlations, but not the non-linearities. That is, from the error matrix alone, two-standard-deviation errors are always exactly twice as big as one-standard-deviation errors.; When the error matrix has been calculated (for example by the successful execution of \(\mbox{MIGRAD}\) (MnMigrad::operator(), see [api:migradop]) or HESSE (MnHesse::operator())) then the parameter errors printed by M are the square roots of the diagonal elements of this matrix. The covariance or the correlations can be printed and shown via std::cout as the ostream operator operator\(<<\) is overloaded. The eigenvalues of the error matrix can be calculated using MnEigen, which should all be positive if the matrix is positive-definite (see below on \(\mbox{MIGRAD}\) and positive-definiteness).; The effect of correlations on the individual parameter errors can be seen as follows. When parameter \(\mbox{n}\) is fixed (e.g. via the method MnMigrad::fix(n)), M inverts the error matrix, removes th",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:17144,Availability,error,error,17144,"ere \(\alpha\) is the vector of free parameters being fitted, and the \(\sigma_i\) are the uncertainties in the individual measurements \(m_i\). If these uncertainties are not known, and are simply left out of the calculation, then the fit may still have meaning, but not the quantitative values of the resulting parameter errors. (Only the relative errors of different parameters with respect to each other may be meaningful.); If the \(\sigma_i\) are all overestimated by a factor \(\beta\), then the resulting parameter errors from the fit will be overestimated by the same factor \(\beta\).; 2.5.2 The error matrix; The M processors \(\mbox{MIGRAD}\) (MnMigrad, see [api:migrad]) and HESSE (MnHesse, see [api:hesse]) (normally) produce an error matrix. This matrix is twice the inverse of the matrix of second derivatives of the \(\mbox{FCN}\), transformed if necessary into external coordinate space2, and multiplied by FCNBase::up(). Therefore, errors based on the M error matrix take account of all the parameter correlations, but not the non-linearities. That is, from the error matrix alone, two-standard-deviation errors are always exactly twice as big as one-standard-deviation errors.; When the error matrix has been calculated (for example by the successful execution of \(\mbox{MIGRAD}\) (MnMigrad::operator(), see [api:migradop]) or HESSE (MnHesse::operator())) then the parameter errors printed by M are the square roots of the diagonal elements of this matrix. The covariance or the correlations can be printed and shown via std::cout as the ostream operator operator\(<<\) is overloaded. The eigenvalues of the error matrix can be calculated using MnEigen, which should all be positive if the matrix is positive-definite (see below on \(\mbox{MIGRAD}\) and positive-definiteness).; The effect of correlations on the individual parameter errors can be seen as follows. When parameter \(\mbox{n}\) is fixed (e.g. via the method MnMigrad::fix(n)), M inverts the error matrix, removes th",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:17252,Availability,error,error,17252,"ements \(m_i\). If these uncertainties are not known, and are simply left out of the calculation, then the fit may still have meaning, but not the quantitative values of the resulting parameter errors. (Only the relative errors of different parameters with respect to each other may be meaningful.); If the \(\sigma_i\) are all overestimated by a factor \(\beta\), then the resulting parameter errors from the fit will be overestimated by the same factor \(\beta\).; 2.5.2 The error matrix; The M processors \(\mbox{MIGRAD}\) (MnMigrad, see [api:migrad]) and HESSE (MnHesse, see [api:hesse]) (normally) produce an error matrix. This matrix is twice the inverse of the matrix of second derivatives of the \(\mbox{FCN}\), transformed if necessary into external coordinate space2, and multiplied by FCNBase::up(). Therefore, errors based on the M error matrix take account of all the parameter correlations, but not the non-linearities. That is, from the error matrix alone, two-standard-deviation errors are always exactly twice as big as one-standard-deviation errors.; When the error matrix has been calculated (for example by the successful execution of \(\mbox{MIGRAD}\) (MnMigrad::operator(), see [api:migradop]) or HESSE (MnHesse::operator())) then the parameter errors printed by M are the square roots of the diagonal elements of this matrix. The covariance or the correlations can be printed and shown via std::cout as the ostream operator operator\(<<\) is overloaded. The eigenvalues of the error matrix can be calculated using MnEigen, which should all be positive if the matrix is positive-definite (see below on \(\mbox{MIGRAD}\) and positive-definiteness).; The effect of correlations on the individual parameter errors can be seen as follows. When parameter \(\mbox{n}\) is fixed (e.g. via the method MnMigrad::fix(n)), M inverts the error matrix, removes the row and column corresponding to parameter \(\mbox{n}\), and re-inverts the result. The effect on the errors of the other param",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:17295,Availability,error,errors,17295,"ements \(m_i\). If these uncertainties are not known, and are simply left out of the calculation, then the fit may still have meaning, but not the quantitative values of the resulting parameter errors. (Only the relative errors of different parameters with respect to each other may be meaningful.); If the \(\sigma_i\) are all overestimated by a factor \(\beta\), then the resulting parameter errors from the fit will be overestimated by the same factor \(\beta\).; 2.5.2 The error matrix; The M processors \(\mbox{MIGRAD}\) (MnMigrad, see [api:migrad]) and HESSE (MnHesse, see [api:hesse]) (normally) produce an error matrix. This matrix is twice the inverse of the matrix of second derivatives of the \(\mbox{FCN}\), transformed if necessary into external coordinate space2, and multiplied by FCNBase::up(). Therefore, errors based on the M error matrix take account of all the parameter correlations, but not the non-linearities. That is, from the error matrix alone, two-standard-deviation errors are always exactly twice as big as one-standard-deviation errors.; When the error matrix has been calculated (for example by the successful execution of \(\mbox{MIGRAD}\) (MnMigrad::operator(), see [api:migradop]) or HESSE (MnHesse::operator())) then the parameter errors printed by M are the square roots of the diagonal elements of this matrix. The covariance or the correlations can be printed and shown via std::cout as the ostream operator operator\(<<\) is overloaded. The eigenvalues of the error matrix can be calculated using MnEigen, which should all be positive if the matrix is positive-definite (see below on \(\mbox{MIGRAD}\) and positive-definiteness).; The effect of correlations on the individual parameter errors can be seen as follows. When parameter \(\mbox{n}\) is fixed (e.g. via the method MnMigrad::fix(n)), M inverts the error matrix, removes the row and column corresponding to parameter \(\mbox{n}\), and re-inverts the result. The effect on the errors of the other param",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:17360,Availability,error,errors,17360,"ements \(m_i\). If these uncertainties are not known, and are simply left out of the calculation, then the fit may still have meaning, but not the quantitative values of the resulting parameter errors. (Only the relative errors of different parameters with respect to each other may be meaningful.); If the \(\sigma_i\) are all overestimated by a factor \(\beta\), then the resulting parameter errors from the fit will be overestimated by the same factor \(\beta\).; 2.5.2 The error matrix; The M processors \(\mbox{MIGRAD}\) (MnMigrad, see [api:migrad]) and HESSE (MnHesse, see [api:hesse]) (normally) produce an error matrix. This matrix is twice the inverse of the matrix of second derivatives of the \(\mbox{FCN}\), transformed if necessary into external coordinate space2, and multiplied by FCNBase::up(). Therefore, errors based on the M error matrix take account of all the parameter correlations, but not the non-linearities. That is, from the error matrix alone, two-standard-deviation errors are always exactly twice as big as one-standard-deviation errors.; When the error matrix has been calculated (for example by the successful execution of \(\mbox{MIGRAD}\) (MnMigrad::operator(), see [api:migradop]) or HESSE (MnHesse::operator())) then the parameter errors printed by M are the square roots of the diagonal elements of this matrix. The covariance or the correlations can be printed and shown via std::cout as the ostream operator operator\(<<\) is overloaded. The eigenvalues of the error matrix can be calculated using MnEigen, which should all be positive if the matrix is positive-definite (see below on \(\mbox{MIGRAD}\) and positive-definiteness).; The effect of correlations on the individual parameter errors can be seen as follows. When parameter \(\mbox{n}\) is fixed (e.g. via the method MnMigrad::fix(n)), M inverts the error matrix, removes the row and column corresponding to parameter \(\mbox{n}\), and re-inverts the result. The effect on the errors of the other param",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:17378,Availability,error,error,17378," the relative errors of different parameters with respect to each other may be meaningful.); If the \(\sigma_i\) are all overestimated by a factor \(\beta\), then the resulting parameter errors from the fit will be overestimated by the same factor \(\beta\).; 2.5.2 The error matrix; The M processors \(\mbox{MIGRAD}\) (MnMigrad, see [api:migrad]) and HESSE (MnHesse, see [api:hesse]) (normally) produce an error matrix. This matrix is twice the inverse of the matrix of second derivatives of the \(\mbox{FCN}\), transformed if necessary into external coordinate space2, and multiplied by FCNBase::up(). Therefore, errors based on the M error matrix take account of all the parameter correlations, but not the non-linearities. That is, from the error matrix alone, two-standard-deviation errors are always exactly twice as big as one-standard-deviation errors.; When the error matrix has been calculated (for example by the successful execution of \(\mbox{MIGRAD}\) (MnMigrad::operator(), see [api:migradop]) or HESSE (MnHesse::operator())) then the parameter errors printed by M are the square roots of the diagonal elements of this matrix. The covariance or the correlations can be printed and shown via std::cout as the ostream operator operator\(<<\) is overloaded. The eigenvalues of the error matrix can be calculated using MnEigen, which should all be positive if the matrix is positive-definite (see below on \(\mbox{MIGRAD}\) and positive-definiteness).; The effect of correlations on the individual parameter errors can be seen as follows. When parameter \(\mbox{n}\) is fixed (e.g. via the method MnMigrad::fix(n)), M inverts the error matrix, removes the row and column corresponding to parameter \(\mbox{n}\), and re-inverts the result. The effect on the errors of the other parameters will in general be to make them smaller, since the component due to the uncertainty in parameter \(\mbox{n}\) has now been removed. (In the limit that a given parameter is uncorrelated with parameter \(",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:17567,Availability,error,errors,17567," the relative errors of different parameters with respect to each other may be meaningful.); If the \(\sigma_i\) are all overestimated by a factor \(\beta\), then the resulting parameter errors from the fit will be overestimated by the same factor \(\beta\).; 2.5.2 The error matrix; The M processors \(\mbox{MIGRAD}\) (MnMigrad, see [api:migrad]) and HESSE (MnHesse, see [api:hesse]) (normally) produce an error matrix. This matrix is twice the inverse of the matrix of second derivatives of the \(\mbox{FCN}\), transformed if necessary into external coordinate space2, and multiplied by FCNBase::up(). Therefore, errors based on the M error matrix take account of all the parameter correlations, but not the non-linearities. That is, from the error matrix alone, two-standard-deviation errors are always exactly twice as big as one-standard-deviation errors.; When the error matrix has been calculated (for example by the successful execution of \(\mbox{MIGRAD}\) (MnMigrad::operator(), see [api:migradop]) or HESSE (MnHesse::operator())) then the parameter errors printed by M are the square roots of the diagonal elements of this matrix. The covariance or the correlations can be printed and shown via std::cout as the ostream operator operator\(<<\) is overloaded. The eigenvalues of the error matrix can be calculated using MnEigen, which should all be positive if the matrix is positive-definite (see below on \(\mbox{MIGRAD}\) and positive-definiteness).; The effect of correlations on the individual parameter errors can be seen as follows. When parameter \(\mbox{n}\) is fixed (e.g. via the method MnMigrad::fix(n)), M inverts the error matrix, removes the row and column corresponding to parameter \(\mbox{n}\), and re-inverts the result. The effect on the errors of the other parameters will in general be to make them smaller, since the component due to the uncertainty in parameter \(\mbox{n}\) has now been removed. (In the limit that a given parameter is uncorrelated with parameter \(",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:17800,Availability,error,error,17800,"e, see [api:hesse]) (normally) produce an error matrix. This matrix is twice the inverse of the matrix of second derivatives of the \(\mbox{FCN}\), transformed if necessary into external coordinate space2, and multiplied by FCNBase::up(). Therefore, errors based on the M error matrix take account of all the parameter correlations, but not the non-linearities. That is, from the error matrix alone, two-standard-deviation errors are always exactly twice as big as one-standard-deviation errors.; When the error matrix has been calculated (for example by the successful execution of \(\mbox{MIGRAD}\) (MnMigrad::operator(), see [api:migradop]) or HESSE (MnHesse::operator())) then the parameter errors printed by M are the square roots of the diagonal elements of this matrix. The covariance or the correlations can be printed and shown via std::cout as the ostream operator operator\(<<\) is overloaded. The eigenvalues of the error matrix can be calculated using MnEigen, which should all be positive if the matrix is positive-definite (see below on \(\mbox{MIGRAD}\) and positive-definiteness).; The effect of correlations on the individual parameter errors can be seen as follows. When parameter \(\mbox{n}\) is fixed (e.g. via the method MnMigrad::fix(n)), M inverts the error matrix, removes the row and column corresponding to parameter \(\mbox{n}\), and re-inverts the result. The effect on the errors of the other parameters will in general be to make them smaller, since the component due to the uncertainty in parameter \(\mbox{n}\) has now been removed. (In the limit that a given parameter is uncorrelated with parameter \(\mbox{n}\), its error will not change when parameter \(\mbox{n}\) is fixed.) However the procedure is not reversible, since M forgets the original error matrix, so if parameter \(\mbox{n}\) is then released (e.g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MIN",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:18026,Availability,error,errors,18026,"FCN}\), transformed if necessary into external coordinate space2, and multiplied by FCNBase::up(). Therefore, errors based on the M error matrix take account of all the parameter correlations, but not the non-linearities. That is, from the error matrix alone, two-standard-deviation errors are always exactly twice as big as one-standard-deviation errors.; When the error matrix has been calculated (for example by the successful execution of \(\mbox{MIGRAD}\) (MnMigrad::operator(), see [api:migradop]) or HESSE (MnHesse::operator())) then the parameter errors printed by M are the square roots of the diagonal elements of this matrix. The covariance or the correlations can be printed and shown via std::cout as the ostream operator operator\(<<\) is overloaded. The eigenvalues of the error matrix can be calculated using MnEigen, which should all be positive if the matrix is positive-definite (see below on \(\mbox{MIGRAD}\) and positive-definiteness).; The effect of correlations on the individual parameter errors can be seen as follows. When parameter \(\mbox{n}\) is fixed (e.g. via the method MnMigrad::fix(n)), M inverts the error matrix, removes the row and column corresponding to parameter \(\mbox{n}\), and re-inverts the result. The effect on the errors of the other parameters will in general be to make them smaller, since the component due to the uncertainty in parameter \(\mbox{n}\) has now been removed. (In the limit that a given parameter is uncorrelated with parameter \(\mbox{n}\), its error will not change when parameter \(\mbox{n}\) is fixed.) However the procedure is not reversible, since M forgets the original error matrix, so if parameter \(\mbox{n}\) is then released (e.g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally avail",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:18148,Availability,error,error,18148,"the parameter correlations, but not the non-linearities. That is, from the error matrix alone, two-standard-deviation errors are always exactly twice as big as one-standard-deviation errors.; When the error matrix has been calculated (for example by the successful execution of \(\mbox{MIGRAD}\) (MnMigrad::operator(), see [api:migradop]) or HESSE (MnHesse::operator())) then the parameter errors printed by M are the square roots of the diagonal elements of this matrix. The covariance or the correlations can be printed and shown via std::cout as the ostream operator operator\(<<\) is overloaded. The eigenvalues of the error matrix can be calculated using MnEigen, which should all be positive if the matrix is positive-definite (see below on \(\mbox{MIGRAD}\) and positive-definiteness).; The effect of correlations on the individual parameter errors can be seen as follows. When parameter \(\mbox{n}\) is fixed (e.g. via the method MnMigrad::fix(n)), M inverts the error matrix, removes the row and column corresponding to parameter \(\mbox{n}\), and re-inverts the result. The effect on the errors of the other parameters will in general be to make them smaller, since the component due to the uncertainty in parameter \(\mbox{n}\) has now been removed. (In the limit that a given parameter is uncorrelated with parameter \(\mbox{n}\), its error will not change when parameter \(\mbox{n}\) is fixed.) However the procedure is not reversible, since M forgets the original error matrix, so if parameter \(\mbox{n}\) is then released (e.g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally available program to calculate parameter errors taking into account both parameter correlations and non-linearities. The \(\mbox{MINOS}\) error intervals are in general a",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:18275,Availability,error,errors,18275,"ard-deviation errors.; When the error matrix has been calculated (for example by the successful execution of \(\mbox{MIGRAD}\) (MnMigrad::operator(), see [api:migradop]) or HESSE (MnHesse::operator())) then the parameter errors printed by M are the square roots of the diagonal elements of this matrix. The covariance or the correlations can be printed and shown via std::cout as the ostream operator operator\(<<\) is overloaded. The eigenvalues of the error matrix can be calculated using MnEigen, which should all be positive if the matrix is positive-definite (see below on \(\mbox{MIGRAD}\) and positive-definiteness).; The effect of correlations on the individual parameter errors can be seen as follows. When parameter \(\mbox{n}\) is fixed (e.g. via the method MnMigrad::fix(n)), M inverts the error matrix, removes the row and column corresponding to parameter \(\mbox{n}\), and re-inverts the result. The effect on the errors of the other parameters will in general be to make them smaller, since the component due to the uncertainty in parameter \(\mbox{n}\) has now been removed. (In the limit that a given parameter is uncorrelated with parameter \(\mbox{n}\), its error will not change when parameter \(\mbox{n}\) is fixed.) However the procedure is not reversible, since M forgets the original error matrix, so if parameter \(\mbox{n}\) is then released (e.g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally available program to calculate parameter errors taking into account both parameter correlations and non-linearities. The \(\mbox{MINOS}\) error intervals are in general asymmetric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate aft",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:18524,Availability,error,error,18524,"dop]) or HESSE (MnHesse::operator())) then the parameter errors printed by M are the square roots of the diagonal elements of this matrix. The covariance or the correlations can be printed and shown via std::cout as the ostream operator operator\(<<\) is overloaded. The eigenvalues of the error matrix can be calculated using MnEigen, which should all be positive if the matrix is positive-definite (see below on \(\mbox{MIGRAD}\) and positive-definiteness).; The effect of correlations on the individual parameter errors can be seen as follows. When parameter \(\mbox{n}\) is fixed (e.g. via the method MnMigrad::fix(n)), M inverts the error matrix, removes the row and column corresponding to parameter \(\mbox{n}\), and re-inverts the result. The effect on the errors of the other parameters will in general be to make them smaller, since the component due to the uncertainty in parameter \(\mbox{n}\) has now been removed. (In the limit that a given parameter is uncorrelated with parameter \(\mbox{n}\), its error will not change when parameter \(\mbox{n}\) is fixed.) However the procedure is not reversible, since M forgets the original error matrix, so if parameter \(\mbox{n}\) is then released (e.g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally available program to calculate parameter errors taking into account both parameter correlations and non-linearities. The \(\mbox{MINOS}\) error intervals are in general asymmetric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate after a good minimum has already been found, and the error matrix has been calculated, so the \(\mbox{MINOS}\) error analysis will normally follow a \(\mbox{MIGRAD}\)",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:18655,Availability,error,error,18655,"he covariance or the correlations can be printed and shown via std::cout as the ostream operator operator\(<<\) is overloaded. The eigenvalues of the error matrix can be calculated using MnEigen, which should all be positive if the matrix is positive-definite (see below on \(\mbox{MIGRAD}\) and positive-definiteness).; The effect of correlations on the individual parameter errors can be seen as follows. When parameter \(\mbox{n}\) is fixed (e.g. via the method MnMigrad::fix(n)), M inverts the error matrix, removes the row and column corresponding to parameter \(\mbox{n}\), and re-inverts the result. The effect on the errors of the other parameters will in general be to make them smaller, since the component due to the uncertainty in parameter \(\mbox{n}\) has now been removed. (In the limit that a given parameter is uncorrelated with parameter \(\mbox{n}\), its error will not change when parameter \(\mbox{n}\) is fixed.) However the procedure is not reversible, since M forgets the original error matrix, so if parameter \(\mbox{n}\) is then released (e.g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally available program to calculate parameter errors taking into account both parameter correlations and non-linearities. The \(\mbox{MINOS}\) error intervals are in general asymmetric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate after a good minimum has already been found, and the error matrix has been calculated, so the \(\mbox{MINOS}\) error analysis will normally follow a \(\mbox{MIGRAD}\) minimization. The \(\mbox{MINOS}\) error for a given parameter is defined as the change in the value of that parameter which causes \({\disp",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:18763,Availability,error,error,18763,"alues of the error matrix can be calculated using MnEigen, which should all be positive if the matrix is positive-definite (see below on \(\mbox{MIGRAD}\) and positive-definiteness).; The effect of correlations on the individual parameter errors can be seen as follows. When parameter \(\mbox{n}\) is fixed (e.g. via the method MnMigrad::fix(n)), M inverts the error matrix, removes the row and column corresponding to parameter \(\mbox{n}\), and re-inverts the result. The effect on the errors of the other parameters will in general be to make them smaller, since the component due to the uncertainty in parameter \(\mbox{n}\) has now been removed. (In the limit that a given parameter is uncorrelated with parameter \(\mbox{n}\), its error will not change when parameter \(\mbox{n}\) is fixed.) However the procedure is not reversible, since M forgets the original error matrix, so if parameter \(\mbox{n}\) is then released (e.g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally available program to calculate parameter errors taking into account both parameter correlations and non-linearities. The \(\mbox{MINOS}\) error intervals are in general asymmetric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate after a good minimum has already been found, and the error matrix has been calculated, so the \(\mbox{MINOS}\) error analysis will normally follow a \(\mbox{MIGRAD}\) minimization. The \(\mbox{MINOS}\) error for a given parameter is defined as the change in the value of that parameter which causes \({\displaystyle F'}\) to increase by the amount FCNBase::up(), where \({\displaystyle F'}\) is the minimum of \(\mbox{FCN}\) with respect to al",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:18879,Availability,error,errors,18879,"tions on the individual parameter errors can be seen as follows. When parameter \(\mbox{n}\) is fixed (e.g. via the method MnMigrad::fix(n)), M inverts the error matrix, removes the row and column corresponding to parameter \(\mbox{n}\), and re-inverts the result. The effect on the errors of the other parameters will in general be to make them smaller, since the component due to the uncertainty in parameter \(\mbox{n}\) has now been removed. (In the limit that a given parameter is uncorrelated with parameter \(\mbox{n}\), its error will not change when parameter \(\mbox{n}\) is fixed.) However the procedure is not reversible, since M forgets the original error matrix, so if parameter \(\mbox{n}\) is then released (e.g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally available program to calculate parameter errors taking into account both parameter correlations and non-linearities. The \(\mbox{MINOS}\) error intervals are in general asymmetric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate after a good minimum has already been found, and the error matrix has been calculated, so the \(\mbox{MINOS}\) error analysis will normally follow a \(\mbox{MIGRAD}\) minimization. The \(\mbox{MINOS}\) error for a given parameter is defined as the change in the value of that parameter which causes \({\displaystyle F'}\) to increase by the amount FCNBase::up(), where \({\displaystyle F'}\) is the minimum of \(\mbox{FCN}\) with respect to all other free parameters, and FCNBase::up() is the return value of the error definition specified by the user (default = 1.).; The algorithm for finding the positive and negative \(\mbox{MINOS}\) errors for",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:19008,Availability,avail,available,19008,"tions on the individual parameter errors can be seen as follows. When parameter \(\mbox{n}\) is fixed (e.g. via the method MnMigrad::fix(n)), M inverts the error matrix, removes the row and column corresponding to parameter \(\mbox{n}\), and re-inverts the result. The effect on the errors of the other parameters will in general be to make them smaller, since the component due to the uncertainty in parameter \(\mbox{n}\) has now been removed. (In the limit that a given parameter is uncorrelated with parameter \(\mbox{n}\), its error will not change when parameter \(\mbox{n}\) is fixed.) However the procedure is not reversible, since M forgets the original error matrix, so if parameter \(\mbox{n}\) is then released (e.g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally available program to calculate parameter errors taking into account both parameter correlations and non-linearities. The \(\mbox{MINOS}\) error intervals are in general asymmetric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate after a good minimum has already been found, and the error matrix has been calculated, so the \(\mbox{MINOS}\) error analysis will normally follow a \(\mbox{MIGRAD}\) minimization. The \(\mbox{MINOS}\) error for a given parameter is defined as the change in the value of that parameter which causes \({\displaystyle F'}\) to increase by the amount FCNBase::up(), where \({\displaystyle F'}\) is the minimum of \(\mbox{FCN}\) with respect to all other free parameters, and FCNBase::up() is the return value of the error definition specified by the user (default = 1.).; The algorithm for finding the positive and negative \(\mbox{MINOS}\) errors for",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:19049,Availability,error,errors,19049,"tions on the individual parameter errors can be seen as follows. When parameter \(\mbox{n}\) is fixed (e.g. via the method MnMigrad::fix(n)), M inverts the error matrix, removes the row and column corresponding to parameter \(\mbox{n}\), and re-inverts the result. The effect on the errors of the other parameters will in general be to make them smaller, since the component due to the uncertainty in parameter \(\mbox{n}\) has now been removed. (In the limit that a given parameter is uncorrelated with parameter \(\mbox{n}\), its error will not change when parameter \(\mbox{n}\) is fixed.) However the procedure is not reversible, since M forgets the original error matrix, so if parameter \(\mbox{n}\) is then released (e.g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally available program to calculate parameter errors taking into account both parameter correlations and non-linearities. The \(\mbox{MINOS}\) error intervals are in general asymmetric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate after a good minimum has already been found, and the error matrix has been calculated, so the \(\mbox{MINOS}\) error analysis will normally follow a \(\mbox{MIGRAD}\) minimization. The \(\mbox{MINOS}\) error for a given parameter is defined as the change in the value of that parameter which causes \({\displaystyle F'}\) to increase by the amount FCNBase::up(), where \({\displaystyle F'}\) is the minimum of \(\mbox{FCN}\) with respect to all other free parameters, and FCNBase::up() is the return value of the error definition specified by the user (default = 1.).; The algorithm for finding the positive and negative \(\mbox{MINOS}\) errors for",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:19146,Availability,error,error,19146,"\(\mbox{n}\), and re-inverts the result. The effect on the errors of the other parameters will in general be to make them smaller, since the component due to the uncertainty in parameter \(\mbox{n}\) has now been removed. (In the limit that a given parameter is uncorrelated with parameter \(\mbox{n}\), its error will not change when parameter \(\mbox{n}\) is fixed.) However the procedure is not reversible, since M forgets the original error matrix, so if parameter \(\mbox{n}\) is then released (e.g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally available program to calculate parameter errors taking into account both parameter correlations and non-linearities. The \(\mbox{MINOS}\) error intervals are in general asymmetric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate after a good minimum has already been found, and the error matrix has been calculated, so the \(\mbox{MINOS}\) error analysis will normally follow a \(\mbox{MIGRAD}\) minimization. The \(\mbox{MINOS}\) error for a given parameter is defined as the change in the value of that parameter which causes \({\displaystyle F'}\) to increase by the amount FCNBase::up(), where \({\displaystyle F'}\) is the minimum of \(\mbox{FCN}\) with respect to all other free parameters, and FCNBase::up() is the return value of the error definition specified by the user (default = 1.).; The algorithm for finding the positive and negative \(\mbox{MINOS}\) errors for parameter \(\mbox{n}\) consists of varying parameter \(\mbox{n}\), each time minimizing \(\mbox{FCN}\) with respect to all the other \(\mbox{npar - 1}\) variable parameters, to find numerically the two values of parameter \",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:19397,Availability,error,error,19397,"has now been removed. (In the limit that a given parameter is uncorrelated with parameter \(\mbox{n}\), its error will not change when parameter \(\mbox{n}\) is fixed.) However the procedure is not reversible, since M forgets the original error matrix, so if parameter \(\mbox{n}\) is then released (e.g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally available program to calculate parameter errors taking into account both parameter correlations and non-linearities. The \(\mbox{MINOS}\) error intervals are in general asymmetric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate after a good minimum has already been found, and the error matrix has been calculated, so the \(\mbox{MINOS}\) error analysis will normally follow a \(\mbox{MIGRAD}\) minimization. The \(\mbox{MINOS}\) error for a given parameter is defined as the change in the value of that parameter which causes \({\displaystyle F'}\) to increase by the amount FCNBase::up(), where \({\displaystyle F'}\) is the minimum of \(\mbox{FCN}\) with respect to all other free parameters, and FCNBase::up() is the return value of the error definition specified by the user (default = 1.).; The algorithm for finding the positive and negative \(\mbox{MINOS}\) errors for parameter \(\mbox{n}\) consists of varying parameter \(\mbox{n}\), each time minimizing \(\mbox{FCN}\) with respect to all the other \(\mbox{npar - 1}\) variable parameters, to find numerically the two values of parameter \(\mbox{n}\) for which the minimum of \(\mbox{FCN}\) takes on the values \(\displaystyle F_{\mathrm{min}} + \mbox{up}\), where \(\displaystyle F_{\mathrm{min}}\) is the minimum of \(\mbox{FCN}\) with r",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:19455,Availability,error,error,19455,"has now been removed. (In the limit that a given parameter is uncorrelated with parameter \(\mbox{n}\), its error will not change when parameter \(\mbox{n}\) is fixed.) However the procedure is not reversible, since M forgets the original error matrix, so if parameter \(\mbox{n}\) is then released (e.g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally available program to calculate parameter errors taking into account both parameter correlations and non-linearities. The \(\mbox{MINOS}\) error intervals are in general asymmetric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate after a good minimum has already been found, and the error matrix has been calculated, so the \(\mbox{MINOS}\) error analysis will normally follow a \(\mbox{MIGRAD}\) minimization. The \(\mbox{MINOS}\) error for a given parameter is defined as the change in the value of that parameter which causes \({\displaystyle F'}\) to increase by the amount FCNBase::up(), where \({\displaystyle F'}\) is the minimum of \(\mbox{FCN}\) with respect to all other free parameters, and FCNBase::up() is the return value of the error definition specified by the user (default = 1.).; The algorithm for finding the positive and negative \(\mbox{MINOS}\) errors for parameter \(\mbox{n}\) consists of varying parameter \(\mbox{n}\), each time minimizing \(\mbox{FCN}\) with respect to all the other \(\mbox{npar - 1}\) variable parameters, to find numerically the two values of parameter \(\mbox{n}\) for which the minimum of \(\mbox{FCN}\) takes on the values \(\displaystyle F_{\mathrm{min}} + \mbox{up}\), where \(\displaystyle F_{\mathrm{min}}\) is the minimum of \(\mbox{FCN}\) with r",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:19546,Availability,error,error,19546,"e.g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally available program to calculate parameter errors taking into account both parameter correlations and non-linearities. The \(\mbox{MINOS}\) error intervals are in general asymmetric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate after a good minimum has already been found, and the error matrix has been calculated, so the \(\mbox{MINOS}\) error analysis will normally follow a \(\mbox{MIGRAD}\) minimization. The \(\mbox{MINOS}\) error for a given parameter is defined as the change in the value of that parameter which causes \({\displaystyle F'}\) to increase by the amount FCNBase::up(), where \({\displaystyle F'}\) is the minimum of \(\mbox{FCN}\) with respect to all other free parameters, and FCNBase::up() is the return value of the error definition specified by the user (default = 1.).; The algorithm for finding the positive and negative \(\mbox{MINOS}\) errors for parameter \(\mbox{n}\) consists of varying parameter \(\mbox{n}\), each time minimizing \(\mbox{FCN}\) with respect to all the other \(\mbox{npar - 1}\) variable parameters, to find numerically the two values of parameter \(\mbox{n}\) for which the minimum of \(\mbox{FCN}\) takes on the values \(\displaystyle F_{\mathrm{min}} + \mbox{up}\), where \(\displaystyle F_{\mathrm{min}}\) is the minimum of \(\mbox{FCN}\) with respect to all \(\mbox{npar}\) parameters. In order to make the procedure as fast as possible, \(\mbox{MINOS}\) uses the error matrix to predict the values of all parameters at the various sub-minima which it will have to find in the course of the calculation, and in the limit that the problem is near",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:19857,Availability,error,error,19857,"e.g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally available program to calculate parameter errors taking into account both parameter correlations and non-linearities. The \(\mbox{MINOS}\) error intervals are in general asymmetric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate after a good minimum has already been found, and the error matrix has been calculated, so the \(\mbox{MINOS}\) error analysis will normally follow a \(\mbox{MIGRAD}\) minimization. The \(\mbox{MINOS}\) error for a given parameter is defined as the change in the value of that parameter which causes \({\displaystyle F'}\) to increase by the amount FCNBase::up(), where \({\displaystyle F'}\) is the minimum of \(\mbox{FCN}\) with respect to all other free parameters, and FCNBase::up() is the return value of the error definition specified by the user (default = 1.).; The algorithm for finding the positive and negative \(\mbox{MINOS}\) errors for parameter \(\mbox{n}\) consists of varying parameter \(\mbox{n}\), each time minimizing \(\mbox{FCN}\) with respect to all the other \(\mbox{npar - 1}\) variable parameters, to find numerically the two values of parameter \(\mbox{n}\) for which the minimum of \(\mbox{FCN}\) takes on the values \(\displaystyle F_{\mathrm{min}} + \mbox{up}\), where \(\displaystyle F_{\mathrm{min}}\) is the minimum of \(\mbox{FCN}\) with respect to all \(\mbox{npar}\) parameters. In order to make the procedure as fast as possible, \(\mbox{MINOS}\) uses the error matrix to predict the values of all parameters at the various sub-minima which it will have to find in the course of the calculation, and in the limit that the problem is near",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:19982,Availability,error,errors,19982,"ric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate after a good minimum has already been found, and the error matrix has been calculated, so the \(\mbox{MINOS}\) error analysis will normally follow a \(\mbox{MIGRAD}\) minimization. The \(\mbox{MINOS}\) error for a given parameter is defined as the change in the value of that parameter which causes \({\displaystyle F'}\) to increase by the amount FCNBase::up(), where \({\displaystyle F'}\) is the minimum of \(\mbox{FCN}\) with respect to all other free parameters, and FCNBase::up() is the return value of the error definition specified by the user (default = 1.).; The algorithm for finding the positive and negative \(\mbox{MINOS}\) errors for parameter \(\mbox{n}\) consists of varying parameter \(\mbox{n}\), each time minimizing \(\mbox{FCN}\) with respect to all the other \(\mbox{npar - 1}\) variable parameters, to find numerically the two values of parameter \(\mbox{n}\) for which the minimum of \(\mbox{FCN}\) takes on the values \(\displaystyle F_{\mathrm{min}} + \mbox{up}\), where \(\displaystyle F_{\mathrm{min}}\) is the minimum of \(\mbox{FCN}\) with respect to all \(\mbox{npar}\) parameters. In order to make the procedure as fast as possible, \(\mbox{MINOS}\) uses the error matrix to predict the values of all parameters at the various sub-minima which it will have to find in the course of the calculation, and in the limit that the problem is nearly linear, the predictions of \(\mbox{MINOS}\) will be nearly exact, requiring very few iterations. On the other hand, when the problem is very non-linear (i.e., \(\mbox{FCN}\) is far from a quadratic function of its parameters), is precisely the situation when \(\mbox{MINOS}\) is needed in order to indicate the correct parameter errors.; 2.5.4 \(\mbox{CONTOURS}\) plotting; M offers a procedure for finding \(\mbox{FCN}\) \(\mbox{CONTOURS}\) (provided via the clas",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:20536,Availability,error,error,20536,"causes \({\displaystyle F'}\) to increase by the amount FCNBase::up(), where \({\displaystyle F'}\) is the minimum of \(\mbox{FCN}\) with respect to all other free parameters, and FCNBase::up() is the return value of the error definition specified by the user (default = 1.).; The algorithm for finding the positive and negative \(\mbox{MINOS}\) errors for parameter \(\mbox{n}\) consists of varying parameter \(\mbox{n}\), each time minimizing \(\mbox{FCN}\) with respect to all the other \(\mbox{npar - 1}\) variable parameters, to find numerically the two values of parameter \(\mbox{n}\) for which the minimum of \(\mbox{FCN}\) takes on the values \(\displaystyle F_{\mathrm{min}} + \mbox{up}\), where \(\displaystyle F_{\mathrm{min}}\) is the minimum of \(\mbox{FCN}\) with respect to all \(\mbox{npar}\) parameters. In order to make the procedure as fast as possible, \(\mbox{MINOS}\) uses the error matrix to predict the values of all parameters at the various sub-minima which it will have to find in the course of the calculation, and in the limit that the problem is nearly linear, the predictions of \(\mbox{MINOS}\) will be nearly exact, requiring very few iterations. On the other hand, when the problem is very non-linear (i.e., \(\mbox{FCN}\) is far from a quadratic function of its parameters), is precisely the situation when \(\mbox{MINOS}\) is needed in order to indicate the correct parameter errors.; 2.5.4 \(\mbox{CONTOURS}\) plotting; M offers a procedure for finding \(\mbox{FCN}\) \(\mbox{CONTOURS}\) (provided via the class MnContours, see [api:contours]).; The contour calculated by MnContours::operator() is dynamic, in the sense that it represents the minimum of \(\mbox{FCN}\) with respect to all the other \(\mbox{npar - 2}\) parameters (if any). In statistical terms, this means that MnContours takes account of the correlations between the two parameters being plotted, and all the other variable parameters, using a procedure analogous to that of \(\mbox{MINOS}\). (I",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:21049,Availability,error,errors,21049,"(\mbox{MINOS}\) errors for parameter \(\mbox{n}\) consists of varying parameter \(\mbox{n}\), each time minimizing \(\mbox{FCN}\) with respect to all the other \(\mbox{npar - 1}\) variable parameters, to find numerically the two values of parameter \(\mbox{n}\) for which the minimum of \(\mbox{FCN}\) takes on the values \(\displaystyle F_{\mathrm{min}} + \mbox{up}\), where \(\displaystyle F_{\mathrm{min}}\) is the minimum of \(\mbox{FCN}\) with respect to all \(\mbox{npar}\) parameters. In order to make the procedure as fast as possible, \(\mbox{MINOS}\) uses the error matrix to predict the values of all parameters at the various sub-minima which it will have to find in the course of the calculation, and in the limit that the problem is nearly linear, the predictions of \(\mbox{MINOS}\) will be nearly exact, requiring very few iterations. On the other hand, when the problem is very non-linear (i.e., \(\mbox{FCN}\) is far from a quadratic function of its parameters), is precisely the situation when \(\mbox{MINOS}\) is needed in order to indicate the correct parameter errors.; 2.5.4 \(\mbox{CONTOURS}\) plotting; M offers a procedure for finding \(\mbox{FCN}\) \(\mbox{CONTOURS}\) (provided via the class MnContours, see [api:contours]).; The contour calculated by MnContours::operator() is dynamic, in the sense that it represents the minimum of \(\mbox{FCN}\) with respect to all the other \(\mbox{npar - 2}\) parameters (if any). In statistical terms, this means that MnContours takes account of the correlations between the two parameters being plotted, and all the other variable parameters, using a procedure analogous to that of \(\mbox{MINOS}\). (If this feature is not wanted, then the other parameters must be fixed before calling \(\mbox{CONTOURS}\).) MnContours provides the actual coordinates of the points around the contour, suitable for plotting with a graphics routine or by hand (using MnPlot, see [api:plot]). The points are given in counter-clockwise order around th",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:22336,Availability,error,errors,22336," In statistical terms, this means that MnContours takes account of the correlations between the two parameters being plotted, and all the other variable parameters, using a procedure analogous to that of \(\mbox{MINOS}\). (If this feature is not wanted, then the other parameters must be fixed before calling \(\mbox{CONTOURS}\).) MnContours provides the actual coordinates of the points around the contour, suitable for plotting with a graphics routine or by hand (using MnPlot, see [api:plot]). The points are given in counter-clockwise order around the contour. Only one contour is calculated per command, and the level is \(\displaystyle F_{\mathrm{min}} + \mbox{up}\). where \(\mbox{up}\) is the return value of FCNBase::up() specified by the user (usually 1.0 by default). The number of points to be calculated is chosen by the user (default is 20). As a by-product, \(\mbox{CONTOURS}\) provides the \(\mbox{MINOS}\) errors of the two parameters in question, since these are just the extreme points of the contour (use the MnContours::contour(…) method in order to get the points of the contour and the ones of the \(\mbox{MINOS}\) errors). MnContours::operator() returns a std::vector\(<\)std::pair\(<\)double,double\(> >\) of (x,y) points. Using MnPlot::operator() will generate a text graphics plot in the terminal.; 3 M installation; 3.1 M releases; To follow the current release process the user is referred to the M homepage @bib-C++MINUIT.; M was re–implemented in from 2002–2004, but the functionality is largely compatible with the one of the version. The usage is different in the sense that the re–write from to was done by its signification and not literally (with minor exceptions). Applications such as \(\mbox{MIGRAD}\) have a corresponding class MnMigrad, M “commands” became classes or methods of classes according to their purpose. Users familiar with the version of M , who have not yet used releases from the version, should however read this manual, in order to adapt to the",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:22551,Availability,error,errors,22551," In statistical terms, this means that MnContours takes account of the correlations between the two parameters being plotted, and all the other variable parameters, using a procedure analogous to that of \(\mbox{MINOS}\). (If this feature is not wanted, then the other parameters must be fixed before calling \(\mbox{CONTOURS}\).) MnContours provides the actual coordinates of the points around the contour, suitable for plotting with a graphics routine or by hand (using MnPlot, see [api:plot]). The points are given in counter-clockwise order around the contour. Only one contour is calculated per command, and the level is \(\displaystyle F_{\mathrm{min}} + \mbox{up}\). where \(\mbox{up}\) is the return value of FCNBase::up() specified by the user (usually 1.0 by default). The number of points to be calculated is chosen by the user (default is 20). As a by-product, \(\mbox{CONTOURS}\) provides the \(\mbox{MINOS}\) errors of the two parameters in question, since these are just the extreme points of the contour (use the MnContours::contour(…) method in order to get the points of the contour and the ones of the \(\mbox{MINOS}\) errors). MnContours::operator() returns a std::vector\(<\)std::pair\(<\)double,double\(> >\) of (x,y) points. Using MnPlot::operator() will generate a text graphics plot in the terminal.; 3 M installation; 3.1 M releases; To follow the current release process the user is referred to the M homepage @bib-C++MINUIT.; M was re–implemented in from 2002–2004, but the functionality is largely compatible with the one of the version. The usage is different in the sense that the re–write from to was done by its signification and not literally (with minor exceptions). Applications such as \(\mbox{MIGRAD}\) have a corresponding class MnMigrad, M “commands” became classes or methods of classes according to their purpose. Users familiar with the version of M , who have not yet used releases from the version, should however read this manual, in order to adapt to the",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:23590,Availability,down,downloading,23590,"tor\(<\)std::pair\(<\)double,double\(> >\) of (x,y) points. Using MnPlot::operator() will generate a text graphics plot in the terminal.; 3 M installation; 3.1 M releases; To follow the current release process the user is referred to the M homepage @bib-C++MINUIT.; M was re–implemented in from 2002–2004, but the functionality is largely compatible with the one of the version. The usage is different in the sense that the re–write from to was done by its signification and not literally (with minor exceptions). Applications such as \(\mbox{MIGRAD}\) have a corresponding class MnMigrad, M “commands” became classes or methods of classes according to their purpose. Users familiar with the version of M , who have not yet used releases from the version, should however read this manual, in order to adapt to the changes as well as to discover the new features and easier ways of using old features.; 3.2 Install M using autoconf/make; For each release of M a tar.gz file is provided for downloading from the M homepage @bib-C++MINUIT. For non-UNIX platforms please refer to the M homepage.; The necessary steps to follow are:. download the tar.gz by clicking on it from the release page; unzip it:; $ unzip Minuit-x.x.x.tar.gz; untar it:; $ tar xvf Minuit-x.x.x.tar; step down to the created Minuit-x.x.x directory:; $ cd Minuit-x.x.x/; run the “configure” script:; $ ./configure; run “make” to compile the source code:; $ make; run “make check” to create the executable example:; $ make check; run the executable example:; $ tests/MnTutorial/Quad4FMain.C. The output should look like that:; Minuit did successfully converge. # of function calls: 74; minimum function value: 1.12392e-09; minimum edm: 1.12392e-09; minimum internal state vector: LAVector parameters:. -1.82079e-05; -1.20794e-05; 6.22382e-06; -3.0465e-05. minimum internal covariance matrix: LASymMatrix parameters:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. # ext. || name || typ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:23730,Availability,down,download,23730," 3 M installation; 3.1 M releases; To follow the current release process the user is referred to the M homepage @bib-C++MINUIT.; M was re–implemented in from 2002–2004, but the functionality is largely compatible with the one of the version. The usage is different in the sense that the re–write from to was done by its signification and not literally (with minor exceptions). Applications such as \(\mbox{MIGRAD}\) have a corresponding class MnMigrad, M “commands” became classes or methods of classes according to their purpose. Users familiar with the version of M , who have not yet used releases from the version, should however read this manual, in order to adapt to the changes as well as to discover the new features and easier ways of using old features.; 3.2 Install M using autoconf/make; For each release of M a tar.gz file is provided for downloading from the M homepage @bib-C++MINUIT. For non-UNIX platforms please refer to the M homepage.; The necessary steps to follow are:. download the tar.gz by clicking on it from the release page; unzip it:; $ unzip Minuit-x.x.x.tar.gz; untar it:; $ tar xvf Minuit-x.x.x.tar; step down to the created Minuit-x.x.x directory:; $ cd Minuit-x.x.x/; run the “configure” script:; $ ./configure; run “make” to compile the source code:; $ make; run “make check” to create the executable example:; $ make check; run the executable example:; $ tests/MnTutorial/Quad4FMain.C. The output should look like that:; Minuit did successfully converge. # of function calls: 74; minimum function value: 1.12392e-09; minimum edm: 1.12392e-09; minimum internal state vector: LAVector parameters:. -1.82079e-05; -1.20794e-05; 6.22382e-06; -3.0465e-05. minimum internal covariance matrix: LASymMatrix parameters:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. # ext. || name || type || value || error +/-. 0 || x || free ||-1.821e-05 || 2; 1 || y || free ||-1.208e-05 || 2.236; 2 || z || free || 6.224e-06 || 2.449; 3",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:23875,Availability,down,down,23875,"ted in from 2002–2004, but the functionality is largely compatible with the one of the version. The usage is different in the sense that the re–write from to was done by its signification and not literally (with minor exceptions). Applications such as \(\mbox{MIGRAD}\) have a corresponding class MnMigrad, M “commands” became classes or methods of classes according to their purpose. Users familiar with the version of M , who have not yet used releases from the version, should however read this manual, in order to adapt to the changes as well as to discover the new features and easier ways of using old features.; 3.2 Install M using autoconf/make; For each release of M a tar.gz file is provided for downloading from the M homepage @bib-C++MINUIT. For non-UNIX platforms please refer to the M homepage.; The necessary steps to follow are:. download the tar.gz by clicking on it from the release page; unzip it:; $ unzip Minuit-x.x.x.tar.gz; untar it:; $ tar xvf Minuit-x.x.x.tar; step down to the created Minuit-x.x.x directory:; $ cd Minuit-x.x.x/; run the “configure” script:; $ ./configure; run “make” to compile the source code:; $ make; run “make check” to create the executable example:; $ make check; run the executable example:; $ tests/MnTutorial/Quad4FMain.C. The output should look like that:; Minuit did successfully converge. # of function calls: 74; minimum function value: 1.12392e-09; minimum edm: 1.12392e-09; minimum internal state vector: LAVector parameters:. -1.82079e-05; -1.20794e-05; 6.22382e-06; -3.0465e-05. minimum internal covariance matrix: LASymMatrix parameters:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. # ext. || name || type || value || error +/-. 0 || x || free ||-1.821e-05 || 2; 1 || y || free ||-1.208e-05 || 2.236; 2 || z || free || 6.224e-06 || 2.449; 3 || w || free ||-3.047e-05 || 1. MnUserCovariance:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1.",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:24616,Availability,error,error,24616," the M homepage @bib-C++MINUIT. For non-UNIX platforms please refer to the M homepage.; The necessary steps to follow are:. download the tar.gz by clicking on it from the release page; unzip it:; $ unzip Minuit-x.x.x.tar.gz; untar it:; $ tar xvf Minuit-x.x.x.tar; step down to the created Minuit-x.x.x directory:; $ cd Minuit-x.x.x/; run the “configure” script:; $ ./configure; run “make” to compile the source code:; $ make; run “make check” to create the executable example:; $ make check; run the executable example:; $ tests/MnTutorial/Quad4FMain.C. The output should look like that:; Minuit did successfully converge. # of function calls: 74; minimum function value: 1.12392e-09; minimum edm: 1.12392e-09; minimum internal state vector: LAVector parameters:. -1.82079e-05; -1.20794e-05; 6.22382e-06; -3.0465e-05. minimum internal covariance matrix: LASymMatrix parameters:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. # ext. || name || type || value || error +/-. 0 || x || free ||-1.821e-05 || 2; 1 || y || free ||-1.208e-05 || 2.236; 2 || z || free || 6.224e-06 || 2.449; 3 || w || free ||-3.047e-05 || 1. MnUserCovariance:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. MnUserCovariance parameter correlations:. 1 0.223607 0.408248 1.35011e-18; 0.223607 1 0.547723 8.39663e-18; 0.408248 0.547723 1 9.36796e-18; 1.35011e-18 8.39663e-18 9.36796e-18 1. MnGlobalCorrelationCoeff:. 0.408248; 0.547723; 0.621261; 0; 3.3 CVS code repository; How to check out (–in) code from the CVS code repository is described at the M homepage @bib-C++MINUIT. To get the source code from the CVS repository one needs to do:; Kerberos IV authorization:; $ setenv CVSROOT :kserver:SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs co MathLibs/Minuit; Anonymous read-only access (if it’s enabled by the librarian, see details):; $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login; (Logging in to :pserver:a",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:28661,Availability,error,errors,28661,"efault. Optionally the user can select a different way of dynamically allocating memory in the class StackAllacator for M , in which case (and after an entire recompilation of the whole library) the thread safety is lost.; 3.7 Floating-point precision; [install:epsmac]; M is entirely based on double precision. The actual floating point precision of double precision (32–bit or 64–bit) is platform dependent and can even vary on the same platform, depending on whether a floating point number is read from memory a CPU register.; The argument of the user’s implementation of FCNBase::operator() is therefore a std:vector\(<\)double\(>\). M expects that the calculations inside \(\mbox{FCN}\) will be performed approximately to the same accuracy.; The accuracy M expects is called machine precision (MnMachinePrecision, see [api:epsmac]) and can be printed on demand using std::cout. If the user fools M by making internal \(\mbox{FCN}\) computations in single precision, M will interpret roundoff noise as significant and will usually either fail to find a minimum, or give incorrect values for the parameter errors.; It is therefore recommended to make sure that all computations in \(\mbox{FCN}\), as well as all methods and functions called by \(\mbox{FCN}\), are done in double precision. If for some reason the computations cannot be done to a precision comparable with that expected by M , the user must inform M of this situation with setting a different machine precision via the MnMachinePrecision::setPrecision(double) method.; With reduced precision, the user may find that certain features sensitive to first and second differences (\(\mbox{HESSE}\), \(\mbox{MINOS}\), \(\mbox{CONTOURS}\)) do not work properly, in which case the calculations must be performed in higher precision.; 4 How to use M; [howto:howto]; 4.1 The \(\mbox{FCN}\) Function; [howto:fcn]; The user must always implement a derived class of FCNBase (the “\(\mbox{FCN}\)”) which calculates the function value to be mini",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:30699,Availability,error,errordef,30699," this package.; The name of the user’s class to implement the FCNBase interface may be chosen freely (in documentation we give it the generic name \(\mbox{FCN}\)).; 4.1.1 FCNBase::operator()(const std::vector\(<\)double\(>\)&); The meaning of the vector of parameters std::vector\(<\)double\(>\) in the argument of FCNBase::operator() are of course defined by the user, who uses the values of those parameters to calculate their function value. The order and the position of these parameters is strictly the one specified by the user when supplying the starting values for minimization.; The starting values must be specified by the user, either via an std::vector\(<\)double\(>\) or the MnUserParameters (see [api:parameters]) supplied as input to the M minimizers such as VariableMetricMinimizer or MnMigrad (see [api:migrad]). Later values are determined by M as it searches for the minimum or performs whatever analysis is requested by the user.; 4.1.2 FCNBase::up(); [howto:errordef] Returns the value of \(\mbox{up}\) (default value \(= 1.\)), defining parameter errors. M defines parameter errors as the change in parameter value required to change the function value by \(\mbox{up}\). Normally, for chisquared fits \(\mbox{up = 1}\), and for negative log likelihood, \(\mbox{up = 0.5}\).; 4.1.3 \(\mbox{FCN}\) function with gradient; By default first derivatives are calculated numerically by M . In case the user wants to supply their own gradient calculator (e.g. analytical derivatives), they need to implement the FCNGradientBase interface. The size of the output vector is the same as of the input one. The same is true for the position of the elements (first derivative of the function with respect to the \(n_\mathrm{th}\) variable has index \(n\) in the output vector).; 4.2 M parameters; Interaction with the parameters of the function are essential both for M and the user. Different interfaces are provided, depending on the level of interaction.; 4.2.1 Minimal required interface;",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:30789,Availability,error,errors,30789,"e FCNBase interface may be chosen freely (in documentation we give it the generic name \(\mbox{FCN}\)).; 4.1.1 FCNBase::operator()(const std::vector\(<\)double\(>\)&); The meaning of the vector of parameters std::vector\(<\)double\(>\) in the argument of FCNBase::operator() are of course defined by the user, who uses the values of those parameters to calculate their function value. The order and the position of these parameters is strictly the one specified by the user when supplying the starting values for minimization.; The starting values must be specified by the user, either via an std::vector\(<\)double\(>\) or the MnUserParameters (see [api:parameters]) supplied as input to the M minimizers such as VariableMetricMinimizer or MnMigrad (see [api:migrad]). Later values are determined by M as it searches for the minimum or performs whatever analysis is requested by the user.; 4.1.2 FCNBase::up(); [howto:errordef] Returns the value of \(\mbox{up}\) (default value \(= 1.\)), defining parameter errors. M defines parameter errors as the change in parameter value required to change the function value by \(\mbox{up}\). Normally, for chisquared fits \(\mbox{up = 1}\), and for negative log likelihood, \(\mbox{up = 0.5}\).; 4.1.3 \(\mbox{FCN}\) function with gradient; By default first derivatives are calculated numerically by M . In case the user wants to supply their own gradient calculator (e.g. analytical derivatives), they need to implement the FCNGradientBase interface. The size of the output vector is the same as of the input one. The same is true for the position of the elements (first derivative of the function with respect to the \(n_\mathrm{th}\) variable has index \(n\) in the output vector).; 4.2 M parameters; Interaction with the parameters of the function are essential both for M and the user. Different interfaces are provided, depending on the level of interaction.; 4.2.1 Minimal required interface; Starting values of parameters and uncertainties can be provi",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:30817,Availability,error,errors,30817,"generic name \(\mbox{FCN}\)).; 4.1.1 FCNBase::operator()(const std::vector\(<\)double\(>\)&); The meaning of the vector of parameters std::vector\(<\)double\(>\) in the argument of FCNBase::operator() are of course defined by the user, who uses the values of those parameters to calculate their function value. The order and the position of these parameters is strictly the one specified by the user when supplying the starting values for minimization.; The starting values must be specified by the user, either via an std::vector\(<\)double\(>\) or the MnUserParameters (see [api:parameters]) supplied as input to the M minimizers such as VariableMetricMinimizer or MnMigrad (see [api:migrad]). Later values are determined by M as it searches for the minimum or performs whatever analysis is requested by the user.; 4.1.2 FCNBase::up(); [howto:errordef] Returns the value of \(\mbox{up}\) (default value \(= 1.\)), defining parameter errors. M defines parameter errors as the change in parameter value required to change the function value by \(\mbox{up}\). Normally, for chisquared fits \(\mbox{up = 1}\), and for negative log likelihood, \(\mbox{up = 0.5}\).; 4.1.3 \(\mbox{FCN}\) function with gradient; By default first derivatives are calculated numerically by M . In case the user wants to supply their own gradient calculator (e.g. analytical derivatives), they need to implement the FCNGradientBase interface. The size of the output vector is the same as of the input one. The same is true for the position of the elements (first derivative of the function with respect to the \(n_\mathrm{th}\) variable has index \(n\) in the output vector).; 4.2 M parameters; Interaction with the parameters of the function are essential both for M and the user. Different interfaces are provided, depending on the level of interaction.; 4.2.1 Minimal required interface; Starting values of parameters and uncertainties can be provided to M by the user via std::vector\(<\)double\(>\) vector containers. A",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:34455,Availability,avail,available,34455,"meters and uncertainties or a more functional one provided by M . If the user wants to interact with the parameters before minimization (fixing, adding/removing limits), the minimal required interface cannot be used.; 4.3.1 What the user must supply; The user must supply to M. a valid implementation of the FCNBase base class; parameters with their starting values; expected uncertainties on the parameters. The input parameters can be simply defined via an std::vector\(<\)double\(>\), which means that all parameters are variables. If the user wants fix a parameter or put limits on it before minimization, they have to instantiate a MnUserParameters object and then add parameters one by one, giving them a name, value, uncertainty. Once all parameters are added to MnUserParameters, they can fix a parameter or put limits on another one before handing them over to Minuit for minimization.; 4.3.2 What the user can supply; Optionally the user can supply their own gradient calculator by implementing the FCNGradientBase interface or supply a full covariance matrix for input if one is available. The covariance matrix can be supplied in form of a std::vector\(<\)double\(>\) in packed storage format (upper triangular), or in a more user-friendly way by using the interface provided by the MnUserCovariance.; 4.4 Running a M minimization; Two use cases are addressed for minimization:. The user just wants the function to be minimized in one go.; The user wants to minimize the \(\mbox{FCN}\) in several minimization steps, re-using the result of the preceeding minimization in the next step and change parameters in between (fix/release/put limits on them, etc.). How M minimizations can be performed is shown in [example:main].; 4.4.1 Direct usage of minimizers; Minimizers such as the VariableMetricMinimizer are designed as state-less minimization engines, which means that they do not depend on the current function and its parameters. Any \(\mbox{FCN}\) function can be minimized with the ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:36669,Availability,error,error,36669,"interaction of the user between two minimization steps will make use of the result of the preceeding minimization in an optimal way. The interface for parameters (see [api:parameters], [api:covariance] and [api:state]) is forwardedin MnMigrad.; 4.4.3 Subsequent minimizations; M takes care that all information is treated in an optimal and correct way if the user interacts with the parameters between two minimizations. MnMigrad retains the result of the last minimization and uses this as input for the next step. Between two minimization requests to MnMigrad the user can fix or release parameters, put limits on them or remove limits from them. Each instance of a MnMigrad object maintains its own state and one can have multiple instances of MnMigrad objects.; 4.4.4 M fails to find a minimum; If M fails to find a minimum, the user is notified by a warning message issued by M when running into troubles. Problems can be:. a bug in M; an error in the \(\mbox{FCN}\); a highly difficult problem (usually strong correlations among parameters); floating–point precision. 4.5 The output from minimization; 4.5.1 The FunctionMinimum; The output of the minimizers is the FunctionMinimum. The FunctionMinimum contains the result of the minimization in both internal parameter representation and external parameter representation.; 4.5.2 User representable format: MnUserParameterState; On request, the result of the minimization is transformed into a user representable format for parameters and errors, the MnUserParameterState.; 4.5.3 Access values, errors, covariance; The result can be accessed via methods like MnUserParameterState::value(unsigned int n) and MnUserParameterState::error(unsigned int n), where \(n\) is the index of the parameter in the list of parameters defined by the user.; 4.5.4 Printout of the result; The FunctionMinimum can be printed on the output simply via std::cout. It will print both the internal and external state, that is parameters, errors and the covariance matr",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:37220,Availability,error,errors,37220,"etains the result of the last minimization and uses this as input for the next step. Between two minimization requests to MnMigrad the user can fix or release parameters, put limits on them or remove limits from them. Each instance of a MnMigrad object maintains its own state and one can have multiple instances of MnMigrad objects.; 4.4.4 M fails to find a minimum; If M fails to find a minimum, the user is notified by a warning message issued by M when running into troubles. Problems can be:. a bug in M; an error in the \(\mbox{FCN}\); a highly difficult problem (usually strong correlations among parameters); floating–point precision. 4.5 The output from minimization; 4.5.1 The FunctionMinimum; The output of the minimizers is the FunctionMinimum. The FunctionMinimum contains the result of the minimization in both internal parameter representation and external parameter representation.; 4.5.2 User representable format: MnUserParameterState; On request, the result of the minimization is transformed into a user representable format for parameters and errors, the MnUserParameterState.; 4.5.3 Access values, errors, covariance; The result can be accessed via methods like MnUserParameterState::value(unsigned int n) and MnUserParameterState::error(unsigned int n), where \(n\) is the index of the parameter in the list of parameters defined by the user.; 4.5.4 Printout of the result; The FunctionMinimum can be printed on the output simply via std::cout. It will print both the internal and external state, that is parameters, errors and the covariance matrix (if available). It also tells the user if M did converge or not by issuing an appropriate message. If a covariance matrix is available, the global correlation coefficients are printed as well.; 4.5.5 Global correlation coefficients; The global correlation coefficient for parameter \(n\) is a number between zero and one which gives the correlation between parameter \(n\) and that linear combination of all other parameters wh",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:37276,Availability,error,errors,37276," a MnMigrad object maintains its own state and one can have multiple instances of MnMigrad objects.; 4.4.4 M fails to find a minimum; If M fails to find a minimum, the user is notified by a warning message issued by M when running into troubles. Problems can be:. a bug in M; an error in the \(\mbox{FCN}\); a highly difficult problem (usually strong correlations among parameters); floating–point precision. 4.5 The output from minimization; 4.5.1 The FunctionMinimum; The output of the minimizers is the FunctionMinimum. The FunctionMinimum contains the result of the minimization in both internal parameter representation and external parameter representation.; 4.5.2 User representable format: MnUserParameterState; On request, the result of the minimization is transformed into a user representable format for parameters and errors, the MnUserParameterState.; 4.5.3 Access values, errors, covariance; The result can be accessed via methods like MnUserParameterState::value(unsigned int n) and MnUserParameterState::error(unsigned int n), where \(n\) is the index of the parameter in the list of parameters defined by the user.; 4.5.4 Printout of the result; The FunctionMinimum can be printed on the output simply via std::cout. It will print both the internal and external state, that is parameters, errors and the covariance matrix (if available). It also tells the user if M did converge or not by issuing an appropriate message. If a covariance matrix is available, the global correlation coefficients are printed as well.; 4.5.5 Global correlation coefficients; The global correlation coefficient for parameter \(n\) is a number between zero and one which gives the correlation between parameter \(n\) and that linear combination of all other parameters which is most strongly correlated with \(n\).; 5 M application programming interface (API); [api:api]; 5.1 FunctionMinimum; [api:fm] The FunctionMinimum is the output of the minimizers and contains the minimization result. The state at ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:37410,Availability,error,error,37410," a MnMigrad object maintains its own state and one can have multiple instances of MnMigrad objects.; 4.4.4 M fails to find a minimum; If M fails to find a minimum, the user is notified by a warning message issued by M when running into troubles. Problems can be:. a bug in M; an error in the \(\mbox{FCN}\); a highly difficult problem (usually strong correlations among parameters); floating–point precision. 4.5 The output from minimization; 4.5.1 The FunctionMinimum; The output of the minimizers is the FunctionMinimum. The FunctionMinimum contains the result of the minimization in both internal parameter representation and external parameter representation.; 4.5.2 User representable format: MnUserParameterState; On request, the result of the minimization is transformed into a user representable format for parameters and errors, the MnUserParameterState.; 4.5.3 Access values, errors, covariance; The result can be accessed via methods like MnUserParameterState::value(unsigned int n) and MnUserParameterState::error(unsigned int n), where \(n\) is the index of the parameter in the list of parameters defined by the user.; 4.5.4 Printout of the result; The FunctionMinimum can be printed on the output simply via std::cout. It will print both the internal and external state, that is parameters, errors and the covariance matrix (if available). It also tells the user if M did converge or not by issuing an appropriate message. If a covariance matrix is available, the global correlation coefficients are printed as well.; 4.5.5 Global correlation coefficients; The global correlation coefficient for parameter \(n\) is a number between zero and one which gives the correlation between parameter \(n\) and that linear combination of all other parameters which is most strongly correlated with \(n\).; 5 M application programming interface (API); [api:api]; 5.1 FunctionMinimum; [api:fm] The FunctionMinimum is the output of the minimizers and contains the minimization result. The state at ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:37696,Availability,error,errors,37696,"(\mbox{FCN}\); a highly difficult problem (usually strong correlations among parameters); floating–point precision. 4.5 The output from minimization; 4.5.1 The FunctionMinimum; The output of the minimizers is the FunctionMinimum. The FunctionMinimum contains the result of the minimization in both internal parameter representation and external parameter representation.; 4.5.2 User representable format: MnUserParameterState; On request, the result of the minimization is transformed into a user representable format for parameters and errors, the MnUserParameterState.; 4.5.3 Access values, errors, covariance; The result can be accessed via methods like MnUserParameterState::value(unsigned int n) and MnUserParameterState::error(unsigned int n), where \(n\) is the index of the parameter in the list of parameters defined by the user.; 4.5.4 Printout of the result; The FunctionMinimum can be printed on the output simply via std::cout. It will print both the internal and external state, that is parameters, errors and the covariance matrix (if available). It also tells the user if M did converge or not by issuing an appropriate message. If a covariance matrix is available, the global correlation coefficients are printed as well.; 4.5.5 Global correlation coefficients; The global correlation coefficient for parameter \(n\) is a number between zero and one which gives the correlation between parameter \(n\) and that linear combination of all other parameters which is most strongly correlated with \(n\).; 5 M application programming interface (API); [api:api]; 5.1 FunctionMinimum; [api:fm] The FunctionMinimum is the output of the minimizers and contains the minimization result. The state at the minimum is available both in internal and external representations. For the external representations the return methods. FunctionMinimum::userState(),; FunctionMinimum::userParameters() and; FunctionMinimum::userCovariance(). are provided. These can be used as new input to a new minimizati",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:37733,Availability,avail,available,37733,"(\mbox{FCN}\); a highly difficult problem (usually strong correlations among parameters); floating–point precision. 4.5 The output from minimization; 4.5.1 The FunctionMinimum; The output of the minimizers is the FunctionMinimum. The FunctionMinimum contains the result of the minimization in both internal parameter representation and external parameter representation.; 4.5.2 User representable format: MnUserParameterState; On request, the result of the minimization is transformed into a user representable format for parameters and errors, the MnUserParameterState.; 4.5.3 Access values, errors, covariance; The result can be accessed via methods like MnUserParameterState::value(unsigned int n) and MnUserParameterState::error(unsigned int n), where \(n\) is the index of the parameter in the list of parameters defined by the user.; 4.5.4 Printout of the result; The FunctionMinimum can be printed on the output simply via std::cout. It will print both the internal and external state, that is parameters, errors and the covariance matrix (if available). It also tells the user if M did converge or not by issuing an appropriate message. If a covariance matrix is available, the global correlation coefficients are printed as well.; 4.5.5 Global correlation coefficients; The global correlation coefficient for parameter \(n\) is a number between zero and one which gives the correlation between parameter \(n\) and that linear combination of all other parameters which is most strongly correlated with \(n\).; 5 M application programming interface (API); [api:api]; 5.1 FunctionMinimum; [api:fm] The FunctionMinimum is the output of the minimizers and contains the minimization result. The state at the minimum is available both in internal and external representations. For the external representations the return methods. FunctionMinimum::userState(),; FunctionMinimum::userParameters() and; FunctionMinimum::userCovariance(). are provided. These can be used as new input to a new minimizati",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:37854,Availability,avail,available,37854,"the minimizers is the FunctionMinimum. The FunctionMinimum contains the result of the minimization in both internal parameter representation and external parameter representation.; 4.5.2 User representable format: MnUserParameterState; On request, the result of the minimization is transformed into a user representable format for parameters and errors, the MnUserParameterState.; 4.5.3 Access values, errors, covariance; The result can be accessed via methods like MnUserParameterState::value(unsigned int n) and MnUserParameterState::error(unsigned int n), where \(n\) is the index of the parameter in the list of parameters defined by the user.; 4.5.4 Printout of the result; The FunctionMinimum can be printed on the output simply via std::cout. It will print both the internal and external state, that is parameters, errors and the covariance matrix (if available). It also tells the user if M did converge or not by issuing an appropriate message. If a covariance matrix is available, the global correlation coefficients are printed as well.; 4.5.5 Global correlation coefficients; The global correlation coefficient for parameter \(n\) is a number between zero and one which gives the correlation between parameter \(n\) and that linear combination of all other parameters which is most strongly correlated with \(n\).; 5 M application programming interface (API); [api:api]; 5.1 FunctionMinimum; [api:fm] The FunctionMinimum is the output of the minimizers and contains the minimization result. The state at the minimum is available both in internal and external representations. For the external representations the return methods. FunctionMinimum::userState(),; FunctionMinimum::userParameters() and; FunctionMinimum::userCovariance(). are provided. These can be used as new input to a new minimization after some manipulation. The parameters and/or the FunctionMinimum can be printed using std::cout.; 5.1.1 isValid(); In general, if the method bool FunctionMinimum::isValid() returns “tru",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:38405,Availability,avail,available,38405,"signed int n), where \(n\) is the index of the parameter in the list of parameters defined by the user.; 4.5.4 Printout of the result; The FunctionMinimum can be printed on the output simply via std::cout. It will print both the internal and external state, that is parameters, errors and the covariance matrix (if available). It also tells the user if M did converge or not by issuing an appropriate message. If a covariance matrix is available, the global correlation coefficients are printed as well.; 4.5.5 Global correlation coefficients; The global correlation coefficient for parameter \(n\) is a number between zero and one which gives the correlation between parameter \(n\) and that linear combination of all other parameters which is most strongly correlated with \(n\).; 5 M application programming interface (API); [api:api]; 5.1 FunctionMinimum; [api:fm] The FunctionMinimum is the output of the minimizers and contains the minimization result. The state at the minimum is available both in internal and external representations. For the external representations the return methods. FunctionMinimum::userState(),; FunctionMinimum::userParameters() and; FunctionMinimum::userCovariance(). are provided. These can be used as new input to a new minimization after some manipulation. The parameters and/or the FunctionMinimum can be printed using std::cout.; 5.1.1 isValid(); In general, if the method bool FunctionMinimum::isValid() returns “true”, the minimizer did find a minimum without running into troubles. However, in some cases it may happen that a minimum cannot be found, then the return value will be “false”. Reasons for the minimization to fail are. the number of allowed function calls has been exhausted; the minimizer could not improve the values of the parameters (and knowing that it has not converged yet); a problem with the calculation of the covariance matrix. Additional methods for the analysis of the state at the minimum are provided.; 5.1.2 fval(), edm(), nfcn();",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:40533,Availability,error,error,40533,"the minimum EDM and unsigned int FunctionMinimum::nfcn() returns the total number of function calls during the minimization.; 5.2 MnContours; [api:contours]; 5.2.1 MnContours(const FCNBase&, const FunctionMinimum&); Construct an MnContours object from the user’s FCN and a valid FunctionMinimum. Additional constructors for user specific MnStrategy settings are provided.; 5.2.2 operator(); The method MnContours::operator()(unsigned int parx, unsigned int pary, unsigned int npoints = 20) const calculates one function contour of \(\mbox{FCN}\) with respect to parameters \(\mbox{parx}\) and \(\mbox{pary}\). The return value is a std::vector\(<\)std::pair\(<\)double,double\(>\) \(>\) of (x,y) points. \(\mbox{FCN}\) minimized always with respect to all other \(\mbox{n - 2}\) variable parameters (if any). M will try to find \(\mbox{npoints}\) points on the contour (default 20). To calculate more than one contour, the user needs to set the error definition [howto:errordef] in its \(\mbox{FCN}\) to the appropriate value for the desired confidence level and call the method MnContours::operator() for each contour.; 5.2.3 contour(…); MnContours::contour(unsigned int parx, unsigned int pary, unsigned int npoints = 20) causes a \(\mbox{CONTOURS}\) error analysis and returns the result in form of ContoursError. As a by-product ContoursError keeps the MinosError information of parameters \(\mbox{parx}\) and \(\mbox{pary}\). The result ContoursError can be easily printed using std::cout.; 5.3 MnEigen; [api:eigen] MnEigen calculates and the eigenvalues of the user covariance matrix MnUserCovariance.; 5.3.1 MnEigen(); MnEigen is instantiated via default constructor.; 5.3.2 operator(); operator()(const MnUserCovariance&) const will perform the calculation of the eigenvalues of the covariance matrix and return the result in form of a std::vector<double>. The eigenvalues are ordered from the smallest first to the largest eigenvalue.; 5.4 MnHesse; [api:hesse]; With MnHesse the user can inst",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:40557,Availability,error,errordef,40557,"the minimum EDM and unsigned int FunctionMinimum::nfcn() returns the total number of function calls during the minimization.; 5.2 MnContours; [api:contours]; 5.2.1 MnContours(const FCNBase&, const FunctionMinimum&); Construct an MnContours object from the user’s FCN and a valid FunctionMinimum. Additional constructors for user specific MnStrategy settings are provided.; 5.2.2 operator(); The method MnContours::operator()(unsigned int parx, unsigned int pary, unsigned int npoints = 20) const calculates one function contour of \(\mbox{FCN}\) with respect to parameters \(\mbox{parx}\) and \(\mbox{pary}\). The return value is a std::vector\(<\)std::pair\(<\)double,double\(>\) \(>\) of (x,y) points. \(\mbox{FCN}\) minimized always with respect to all other \(\mbox{n - 2}\) variable parameters (if any). M will try to find \(\mbox{npoints}\) points on the contour (default 20). To calculate more than one contour, the user needs to set the error definition [howto:errordef] in its \(\mbox{FCN}\) to the appropriate value for the desired confidence level and call the method MnContours::operator() for each contour.; 5.2.3 contour(…); MnContours::contour(unsigned int parx, unsigned int pary, unsigned int npoints = 20) causes a \(\mbox{CONTOURS}\) error analysis and returns the result in form of ContoursError. As a by-product ContoursError keeps the MinosError information of parameters \(\mbox{parx}\) and \(\mbox{pary}\). The result ContoursError can be easily printed using std::cout.; 5.3 MnEigen; [api:eigen] MnEigen calculates and the eigenvalues of the user covariance matrix MnUserCovariance.; 5.3.1 MnEigen(); MnEigen is instantiated via default constructor.; 5.3.2 operator(); operator()(const MnUserCovariance&) const will perform the calculation of the eigenvalues of the covariance matrix and return the result in form of a std::vector<double>. The eigenvalues are ordered from the smallest first to the largest eigenvalue.; 5.4 MnHesse; [api:hesse]; With MnHesse the user can inst",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:40841,Availability,error,error,40841,"truct an MnContours object from the user’s FCN and a valid FunctionMinimum. Additional constructors for user specific MnStrategy settings are provided.; 5.2.2 operator(); The method MnContours::operator()(unsigned int parx, unsigned int pary, unsigned int npoints = 20) const calculates one function contour of \(\mbox{FCN}\) with respect to parameters \(\mbox{parx}\) and \(\mbox{pary}\). The return value is a std::vector\(<\)std::pair\(<\)double,double\(>\) \(>\) of (x,y) points. \(\mbox{FCN}\) minimized always with respect to all other \(\mbox{n - 2}\) variable parameters (if any). M will try to find \(\mbox{npoints}\) points on the contour (default 20). To calculate more than one contour, the user needs to set the error definition [howto:errordef] in its \(\mbox{FCN}\) to the appropriate value for the desired confidence level and call the method MnContours::operator() for each contour.; 5.2.3 contour(…); MnContours::contour(unsigned int parx, unsigned int pary, unsigned int npoints = 20) causes a \(\mbox{CONTOURS}\) error analysis and returns the result in form of ContoursError. As a by-product ContoursError keeps the MinosError information of parameters \(\mbox{parx}\) and \(\mbox{pary}\). The result ContoursError can be easily printed using std::cout.; 5.3 MnEigen; [api:eigen] MnEigen calculates and the eigenvalues of the user covariance matrix MnUserCovariance.; 5.3.1 MnEigen(); MnEigen is instantiated via default constructor.; 5.3.2 operator(); operator()(const MnUserCovariance&) const will perform the calculation of the eigenvalues of the covariance matrix and return the result in form of a std::vector<double>. The eigenvalues are ordered from the smallest first to the largest eigenvalue.; 5.4 MnHesse; [api:hesse]; With MnHesse the user can instructs M to calculate, by finite differences, the Hessian or error matrix. That is, it calculates the full matrix of second derivatives of the function with respect to the currently variable parameters, and inverts it.; 5",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:41649,Availability,error,error,41649,"propriate value for the desired confidence level and call the method MnContours::operator() for each contour.; 5.2.3 contour(…); MnContours::contour(unsigned int parx, unsigned int pary, unsigned int npoints = 20) causes a \(\mbox{CONTOURS}\) error analysis and returns the result in form of ContoursError. As a by-product ContoursError keeps the MinosError information of parameters \(\mbox{parx}\) and \(\mbox{pary}\). The result ContoursError can be easily printed using std::cout.; 5.3 MnEigen; [api:eigen] MnEigen calculates and the eigenvalues of the user covariance matrix MnUserCovariance.; 5.3.1 MnEigen(); MnEigen is instantiated via default constructor.; 5.3.2 operator(); operator()(const MnUserCovariance&) const will perform the calculation of the eigenvalues of the covariance matrix and return the result in form of a std::vector<double>. The eigenvalues are ordered from the smallest first to the largest eigenvalue.; 5.4 MnHesse; [api:hesse]; With MnHesse the user can instructs M to calculate, by finite differences, the Hessian or error matrix. That is, it calculates the full matrix of second derivatives of the function with respect to the currently variable parameters, and inverts it.; 5.4.1 MnHesse(); The default constructor of MnHesse() will use default settings of MnStrategy. Other constructors with user specific MnStrategy settings are provided as well.; 5.4.2 operator(); The MnHesse::operator() is overloaded both for internal (M ) and external (user) parameters. External parameters can be specified as std::vector\(<\)double\(>\) or as MnUserParameters. The return value is always a MnUserParameterState.; The optional argument \(\mbox{maxcalls}\) specifies the (approximate) maximum number of function calls after which the calculation will be stopped.; 5.5 MnMachinePrecision; [api:epsmac]; 5.5.1 MnMachinePrecision(); M determines the nominal precision itself in the default constructor MnMachinePrecision().; 5.5.2 setPrecision(double eps); Informs M that the re",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:43617,Availability,error,error,43617," is \(\mbox{eps}\). The method can be used to override M ’s own determination, when the user knows that the \(\mbox{FCN}\) function value is not calculated to the nominal machine accuracy. Typical values of \(\mbox{eps}\) are between \(10^{-5}\) and \(10^{-14}\).; 5.6 MnMigrad and VariableMetricMinimizer; [api:migrad]; MnMigrad provides minimization of the function by the method of \(\mbox{MIGRAD}\), the most efficient and complete single method, recommended for general functions (see also [api:minimize]), and the functionality for parameters interaction. It also retains the result from the last minimization in case the user may want to do subsequent minimization steps with parameter interactions in between the minimization requests. The minimization is done by the VariableMetricMinimizer. Minimization of the function can be done by directly using the VariableMetricMinimizer if no parameters interaction is required. The minimization produces as a by-product the error matrix of the parameters, which is usually reliable unless warning messages are produced.; 5.6.1 MnMigrad(const FCNBase&, const std::vector\(<\)double\(>\)&, const std::vector\(<\)double\(>\)&, unsigned int); Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.6.2 MnMigrad(const FCNBase&, const MnUserParameters&, unsigned int); Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.6.3 MnMigrad(const FCNBase&, const MnUserParameterState&, const MnStrategy&); Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.6.4 operator(); [api:migradop] MnMigrad::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. The optional argument \(\mbox{maxfcn}\) specifies the (approximate) maximum numb",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:43666,Availability,reliab,reliable,43666," is \(\mbox{eps}\). The method can be used to override M ’s own determination, when the user knows that the \(\mbox{FCN}\) function value is not calculated to the nominal machine accuracy. Typical values of \(\mbox{eps}\) are between \(10^{-5}\) and \(10^{-14}\).; 5.6 MnMigrad and VariableMetricMinimizer; [api:migrad]; MnMigrad provides minimization of the function by the method of \(\mbox{MIGRAD}\), the most efficient and complete single method, recommended for general functions (see also [api:minimize]), and the functionality for parameters interaction. It also retains the result from the last minimization in case the user may want to do subsequent minimization steps with parameter interactions in between the minimization requests. The minimization is done by the VariableMetricMinimizer. Minimization of the function can be done by directly using the VariableMetricMinimizer if no parameters interaction is required. The minimization produces as a by-product the error matrix of the parameters, which is usually reliable unless warning messages are produced.; 5.6.1 MnMigrad(const FCNBase&, const std::vector\(<\)double\(>\)&, const std::vector\(<\)double\(>\)&, unsigned int); Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.6.2 MnMigrad(const FCNBase&, const MnUserParameters&, unsigned int); Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.6.3 MnMigrad(const FCNBase&, const MnUserParameterState&, const MnStrategy&); Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.6.4 operator(); [api:migradop] MnMigrad::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. The optional argument \(\mbox{maxfcn}\) specifies the (approximate) maximum numb",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:44455,Availability,toler,tolerance,44455,"on can be done by directly using the VariableMetricMinimizer if no parameters interaction is required. The minimization produces as a by-product the error matrix of the parameters, which is usually reliable unless warning messages are produced.; 5.6.1 MnMigrad(const FCNBase&, const std::vector\(<\)double\(>\)&, const std::vector\(<\)double\(>\)&, unsigned int); Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.6.2 MnMigrad(const FCNBase&, const MnUserParameters&, unsigned int); Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.6.3 MnMigrad(const FCNBase&, const MnUserParameterState&, const MnStrategy&); Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.6.4 operator(); [api:migradop] MnMigrad::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. The optional argument \(\mbox{maxfcn}\) specifies the (approximate) maximum number of function calls after which the calculation will be stopped even if it has not yet converged. The optional argument \(\mbox{tolerance}\) specifies the required tolerance on the function value at the minimum. The default \(\mbox{tolerance}\) value is \(0.1\), and the minimization will stop when the estimated vertical distance to the minimum (\(\mbox{EDM}\)) is less than \(0.001*\)\(\mbox{tolerance}\)\(*\)\(\mbox{up}\) (see [howto:errordef]).; 5.6.5 Parameter interaction; MnMigrad retains the result after each minimization (MnUserParameterStae, see [api:state]) and forwards the interface.; 5.6.6 VariableMetricMinimizer(); The VariableMetricMinimizer is instantiated using default constructor.; 5.6.7 minimize(const FCNBase&, …); The VariableMetricMinimizer provides several overloaded methods minimize with return val",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:44770,Availability,toler,tolerance,44770,"or\(<\)double\(>\)&, unsigned int); Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.6.2 MnMigrad(const FCNBase&, const MnUserParameters&, unsigned int); Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.6.3 MnMigrad(const FCNBase&, const MnUserParameterState&, const MnStrategy&); Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.6.4 operator(); [api:migradop] MnMigrad::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. The optional argument \(\mbox{maxfcn}\) specifies the (approximate) maximum number of function calls after which the calculation will be stopped even if it has not yet converged. The optional argument \(\mbox{tolerance}\) specifies the required tolerance on the function value at the minimum. The default \(\mbox{tolerance}\) value is \(0.1\), and the minimization will stop when the estimated vertical distance to the minimum (\(\mbox{EDM}\)) is less than \(0.001*\)\(\mbox{tolerance}\)\(*\)\(\mbox{up}\) (see [howto:errordef]).; 5.6.5 Parameter interaction; MnMigrad retains the result after each minimization (MnUserParameterStae, see [api:state]) and forwards the interface.; 5.6.6 VariableMetricMinimizer(); The VariableMetricMinimizer is instantiated using default constructor.; 5.6.7 minimize(const FCNBase&, …); The VariableMetricMinimizer provides several overloaded methods minimize with return value FunctionMinimum. Together with the user \(\mbox{FCN}\) (either an implementation of FCNBase or FCNGradientBase) the user has to give as input the parameters with starting values in one of the defined formats (std::vector\(<\)double\(>\), MnUserParameters or MnUserParameterState).; 5.7 MnMinimize and CombinedMinimizer; [api",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:44806,Availability,toler,tolerance,44806,"or\(<\)double\(>\)&, unsigned int); Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.6.2 MnMigrad(const FCNBase&, const MnUserParameters&, unsigned int); Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.6.3 MnMigrad(const FCNBase&, const MnUserParameterState&, const MnStrategy&); Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.6.4 operator(); [api:migradop] MnMigrad::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. The optional argument \(\mbox{maxfcn}\) specifies the (approximate) maximum number of function calls after which the calculation will be stopped even if it has not yet converged. The optional argument \(\mbox{tolerance}\) specifies the required tolerance on the function value at the minimum. The default \(\mbox{tolerance}\) value is \(0.1\), and the minimization will stop when the estimated vertical distance to the minimum (\(\mbox{EDM}\)) is less than \(0.001*\)\(\mbox{tolerance}\)\(*\)\(\mbox{up}\) (see [howto:errordef]).; 5.6.5 Parameter interaction; MnMigrad retains the result after each minimization (MnUserParameterStae, see [api:state]) and forwards the interface.; 5.6.6 VariableMetricMinimizer(); The VariableMetricMinimizer is instantiated using default constructor.; 5.6.7 minimize(const FCNBase&, …); The VariableMetricMinimizer provides several overloaded methods minimize with return value FunctionMinimum. Together with the user \(\mbox{FCN}\) (either an implementation of FCNBase or FCNGradientBase) the user has to give as input the parameters with starting values in one of the defined formats (std::vector\(<\)double\(>\), MnUserParameters or MnUserParameterState).; 5.7 MnMinimize and CombinedMinimizer; [api",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:44874,Availability,toler,tolerance,44874,"ce: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.6.2 MnMigrad(const FCNBase&, const MnUserParameters&, unsigned int); Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.6.3 MnMigrad(const FCNBase&, const MnUserParameterState&, const MnStrategy&); Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.6.4 operator(); [api:migradop] MnMigrad::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. The optional argument \(\mbox{maxfcn}\) specifies the (approximate) maximum number of function calls after which the calculation will be stopped even if it has not yet converged. The optional argument \(\mbox{tolerance}\) specifies the required tolerance on the function value at the minimum. The default \(\mbox{tolerance}\) value is \(0.1\), and the minimization will stop when the estimated vertical distance to the minimum (\(\mbox{EDM}\)) is less than \(0.001*\)\(\mbox{tolerance}\)\(*\)\(\mbox{up}\) (see [howto:errordef]).; 5.6.5 Parameter interaction; MnMigrad retains the result after each minimization (MnUserParameterStae, see [api:state]) and forwards the interface.; 5.6.6 VariableMetricMinimizer(); The VariableMetricMinimizer is instantiated using default constructor.; 5.6.7 minimize(const FCNBase&, …); The VariableMetricMinimizer provides several overloaded methods minimize with return value FunctionMinimum. Together with the user \(\mbox{FCN}\) (either an implementation of FCNBase or FCNGradientBase) the user has to give as input the parameters with starting values in one of the defined formats (std::vector\(<\)double\(>\), MnUserParameters or MnUserParameterState).; 5.7 MnMinimize and CombinedMinimizer; [api:minimize]; Causes minimization of the function by the method of \(\mbox{MIGRAD}\",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:45036,Availability,toler,tolerance,45036,"ameters&, unsigned int); Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.6.3 MnMigrad(const FCNBase&, const MnUserParameterState&, const MnStrategy&); Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.6.4 operator(); [api:migradop] MnMigrad::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. The optional argument \(\mbox{maxfcn}\) specifies the (approximate) maximum number of function calls after which the calculation will be stopped even if it has not yet converged. The optional argument \(\mbox{tolerance}\) specifies the required tolerance on the function value at the minimum. The default \(\mbox{tolerance}\) value is \(0.1\), and the minimization will stop when the estimated vertical distance to the minimum (\(\mbox{EDM}\)) is less than \(0.001*\)\(\mbox{tolerance}\)\(*\)\(\mbox{up}\) (see [howto:errordef]).; 5.6.5 Parameter interaction; MnMigrad retains the result after each minimization (MnUserParameterStae, see [api:state]) and forwards the interface.; 5.6.6 VariableMetricMinimizer(); The VariableMetricMinimizer is instantiated using default constructor.; 5.6.7 minimize(const FCNBase&, …); The VariableMetricMinimizer provides several overloaded methods minimize with return value FunctionMinimum. Together with the user \(\mbox{FCN}\) (either an implementation of FCNBase or FCNGradientBase) the user has to give as input the parameters with starting values in one of the defined formats (std::vector\(<\)double\(>\), MnUserParameters or MnUserParameterState).; 5.7 MnMinimize and CombinedMinimizer; [api:minimize]; Causes minimization of the function by the method of \(\mbox{MIGRAD}\), as does the MnMigrad class, but switches to the \(\mbox{SIMPLEX}\) method if \(\mbox{MIGRAD}\) fails to converge. Constructor arguments, methods arguments and names of methods ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:45079,Availability,error,errordef,45079,"ameters&, unsigned int); Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.6.3 MnMigrad(const FCNBase&, const MnUserParameterState&, const MnStrategy&); Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.6.4 operator(); [api:migradop] MnMigrad::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. The optional argument \(\mbox{maxfcn}\) specifies the (approximate) maximum number of function calls after which the calculation will be stopped even if it has not yet converged. The optional argument \(\mbox{tolerance}\) specifies the required tolerance on the function value at the minimum. The default \(\mbox{tolerance}\) value is \(0.1\), and the minimization will stop when the estimated vertical distance to the minimum (\(\mbox{EDM}\)) is less than \(0.001*\)\(\mbox{tolerance}\)\(*\)\(\mbox{up}\) (see [howto:errordef]).; 5.6.5 Parameter interaction; MnMigrad retains the result after each minimization (MnUserParameterStae, see [api:state]) and forwards the interface.; 5.6.6 VariableMetricMinimizer(); The VariableMetricMinimizer is instantiated using default constructor.; 5.6.7 minimize(const FCNBase&, …); The VariableMetricMinimizer provides several overloaded methods minimize with return value FunctionMinimum. Together with the user \(\mbox{FCN}\) (either an implementation of FCNBase or FCNGradientBase) the user has to give as input the parameters with starting values in one of the defined formats (std::vector\(<\)double\(>\), MnUserParameters or MnUserParameterState).; 5.7 MnMinimize and CombinedMinimizer; [api:minimize]; Causes minimization of the function by the method of \(\mbox{MIGRAD}\), as does the MnMigrad class, but switches to the \(\mbox{SIMPLEX}\) method if \(\mbox{MIGRAD}\) fails to converge. Constructor arguments, methods arguments and names of methods ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:46199,Availability,error,error,46199," and forwards the interface.; 5.6.6 VariableMetricMinimizer(); The VariableMetricMinimizer is instantiated using default constructor.; 5.6.7 minimize(const FCNBase&, …); The VariableMetricMinimizer provides several overloaded methods minimize with return value FunctionMinimum. Together with the user \(\mbox{FCN}\) (either an implementation of FCNBase or FCNGradientBase) the user has to give as input the parameters with starting values in one of the defined formats (std::vector\(<\)double\(>\), MnUserParameters or MnUserParameterState).; 5.7 MnMinimize and CombinedMinimizer; [api:minimize]; Causes minimization of the function by the method of \(\mbox{MIGRAD}\), as does the MnMigrad class, but switches to the \(\mbox{SIMPLEX}\) method if \(\mbox{MIGRAD}\) fails to converge. Constructor arguments, methods arguments and names of methods are the same as for MnMigrad or MnSimplex and VariableMetricMinimizer or SimplexMinimizer.; 5.8 MnMinos; [api:minos] Causes a \(\mbox{MINOS}\) error analysis to be performed on the parameter whose number is specified. \(\mbox{MINOS}\) errors may be expensive to calculate, but are very reliable since they take account of non-linearities in the problem as well as parameter correlations, and are in general asymmetric. The optional argument \(\mbox{maxcalls}\) specifies the (approximate) maximum number of function calls per parameter requested, after which the calculation will be stopped for that parameter.; 5.8.1 MnMinos(const FCNBase&, const FunctionMinimum&); Construct an MnMinos object from the user’s \(\mbox{FCN}\) and a valid FunctionMinimum. Additional constructors for user specific MnStrategy settings are provided.; 5.8.2 operator(); MnMinos::operator()(unsigned int n, unsigned int maxcalls) causes a \(\mbox{MINOS}\) error analysis for external parameter \(\mbox{n}\). The return value is a std::pair\(<\)double,double\(>\) with the lower and upper bounds of parameter \(\mbox{n}\).; 5.8.3 minos(unsigned int n, unsigned int maxcalls); Mn",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:46291,Availability,error,errors,46291,"e&, …); The VariableMetricMinimizer provides several overloaded methods minimize with return value FunctionMinimum. Together with the user \(\mbox{FCN}\) (either an implementation of FCNBase or FCNGradientBase) the user has to give as input the parameters with starting values in one of the defined formats (std::vector\(<\)double\(>\), MnUserParameters or MnUserParameterState).; 5.7 MnMinimize and CombinedMinimizer; [api:minimize]; Causes minimization of the function by the method of \(\mbox{MIGRAD}\), as does the MnMigrad class, but switches to the \(\mbox{SIMPLEX}\) method if \(\mbox{MIGRAD}\) fails to converge. Constructor arguments, methods arguments and names of methods are the same as for MnMigrad or MnSimplex and VariableMetricMinimizer or SimplexMinimizer.; 5.8 MnMinos; [api:minos] Causes a \(\mbox{MINOS}\) error analysis to be performed on the parameter whose number is specified. \(\mbox{MINOS}\) errors may be expensive to calculate, but are very reliable since they take account of non-linearities in the problem as well as parameter correlations, and are in general asymmetric. The optional argument \(\mbox{maxcalls}\) specifies the (approximate) maximum number of function calls per parameter requested, after which the calculation will be stopped for that parameter.; 5.8.1 MnMinos(const FCNBase&, const FunctionMinimum&); Construct an MnMinos object from the user’s \(\mbox{FCN}\) and a valid FunctionMinimum. Additional constructors for user specific MnStrategy settings are provided.; 5.8.2 operator(); MnMinos::operator()(unsigned int n, unsigned int maxcalls) causes a \(\mbox{MINOS}\) error analysis for external parameter \(\mbox{n}\). The return value is a std::pair\(<\)double,double\(>\) with the lower and upper bounds of parameter \(\mbox{n}\).; 5.8.3 minos(unsigned int n, unsigned int maxcalls); MnMinos::minos(unsigned int n, unsigned int maxcalls) causes a \(\mbox{MINOS}\) error analysis for external parameter \(\mbox{n}\) and returns a MinosError with the",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:46342,Availability,reliab,reliable,46342,"e&, …); The VariableMetricMinimizer provides several overloaded methods minimize with return value FunctionMinimum. Together with the user \(\mbox{FCN}\) (either an implementation of FCNBase or FCNGradientBase) the user has to give as input the parameters with starting values in one of the defined formats (std::vector\(<\)double\(>\), MnUserParameters or MnUserParameterState).; 5.7 MnMinimize and CombinedMinimizer; [api:minimize]; Causes minimization of the function by the method of \(\mbox{MIGRAD}\), as does the MnMigrad class, but switches to the \(\mbox{SIMPLEX}\) method if \(\mbox{MIGRAD}\) fails to converge. Constructor arguments, methods arguments and names of methods are the same as for MnMigrad or MnSimplex and VariableMetricMinimizer or SimplexMinimizer.; 5.8 MnMinos; [api:minos] Causes a \(\mbox{MINOS}\) error analysis to be performed on the parameter whose number is specified. \(\mbox{MINOS}\) errors may be expensive to calculate, but are very reliable since they take account of non-linearities in the problem as well as parameter correlations, and are in general asymmetric. The optional argument \(\mbox{maxcalls}\) specifies the (approximate) maximum number of function calls per parameter requested, after which the calculation will be stopped for that parameter.; 5.8.1 MnMinos(const FCNBase&, const FunctionMinimum&); Construct an MnMinos object from the user’s \(\mbox{FCN}\) and a valid FunctionMinimum. Additional constructors for user specific MnStrategy settings are provided.; 5.8.2 operator(); MnMinos::operator()(unsigned int n, unsigned int maxcalls) causes a \(\mbox{MINOS}\) error analysis for external parameter \(\mbox{n}\). The return value is a std::pair\(<\)double,double\(>\) with the lower and upper bounds of parameter \(\mbox{n}\).; 5.8.3 minos(unsigned int n, unsigned int maxcalls); MnMinos::minos(unsigned int n, unsigned int maxcalls) causes a \(\mbox{MINOS}\) error analysis for external parameter \(\mbox{n}\) and returns a MinosError with the",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:46991,Availability,error,error,46991,"GRAD}\) fails to converge. Constructor arguments, methods arguments and names of methods are the same as for MnMigrad or MnSimplex and VariableMetricMinimizer or SimplexMinimizer.; 5.8 MnMinos; [api:minos] Causes a \(\mbox{MINOS}\) error analysis to be performed on the parameter whose number is specified. \(\mbox{MINOS}\) errors may be expensive to calculate, but are very reliable since they take account of non-linearities in the problem as well as parameter correlations, and are in general asymmetric. The optional argument \(\mbox{maxcalls}\) specifies the (approximate) maximum number of function calls per parameter requested, after which the calculation will be stopped for that parameter.; 5.8.1 MnMinos(const FCNBase&, const FunctionMinimum&); Construct an MnMinos object from the user’s \(\mbox{FCN}\) and a valid FunctionMinimum. Additional constructors for user specific MnStrategy settings are provided.; 5.8.2 operator(); MnMinos::operator()(unsigned int n, unsigned int maxcalls) causes a \(\mbox{MINOS}\) error analysis for external parameter \(\mbox{n}\). The return value is a std::pair\(<\)double,double\(>\) with the lower and upper bounds of parameter \(\mbox{n}\).; 5.8.3 minos(unsigned int n, unsigned int maxcalls); MnMinos::minos(unsigned int n, unsigned int maxcalls) causes a \(\mbox{MINOS}\) error analysis for external parameter \(\mbox{n}\) and returns a MinosError with the lower and upper bounds of parameter \(\mbox{n}\) and additional information in case that one bound could not be found. The result MinosError can be easily printed using std::cout.; 5.8.4 Other methods; Additional methods exist to ask for one side of \(\mbox{MINOS}\) errors only.; 5.9 MnPlot; [api:plot] MnPlot prints the result of \(\mbox{CONTOURS}\) or \(\mbox{SCAN}\) on a text terminal.; 5.9.1 MnPlot(); The default constructor initializes default settings for the text window size.; 5.9.2 operator(); MnPlot::operator()(const std::vector\(<\)std::pair\(<\)double,double\(>\) \(>\)&) prin",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:47290,Availability,error,error,47290,", but are very reliable since they take account of non-linearities in the problem as well as parameter correlations, and are in general asymmetric. The optional argument \(\mbox{maxcalls}\) specifies the (approximate) maximum number of function calls per parameter requested, after which the calculation will be stopped for that parameter.; 5.8.1 MnMinos(const FCNBase&, const FunctionMinimum&); Construct an MnMinos object from the user’s \(\mbox{FCN}\) and a valid FunctionMinimum. Additional constructors for user specific MnStrategy settings are provided.; 5.8.2 operator(); MnMinos::operator()(unsigned int n, unsigned int maxcalls) causes a \(\mbox{MINOS}\) error analysis for external parameter \(\mbox{n}\). The return value is a std::pair\(<\)double,double\(>\) with the lower and upper bounds of parameter \(\mbox{n}\).; 5.8.3 minos(unsigned int n, unsigned int maxcalls); MnMinos::minos(unsigned int n, unsigned int maxcalls) causes a \(\mbox{MINOS}\) error analysis for external parameter \(\mbox{n}\) and returns a MinosError with the lower and upper bounds of parameter \(\mbox{n}\) and additional information in case that one bound could not be found. The result MinosError can be easily printed using std::cout.; 5.8.4 Other methods; Additional methods exist to ask for one side of \(\mbox{MINOS}\) errors only.; 5.9 MnPlot; [api:plot] MnPlot prints the result of \(\mbox{CONTOURS}\) or \(\mbox{SCAN}\) on a text terminal.; 5.9.1 MnPlot(); The default constructor initializes default settings for the text window size.; 5.9.2 operator(); MnPlot::operator()(const std::vector\(<\)std::pair\(<\)double,double\(>\) \(>\)&) prints a vector of (x,y) points on the text terminal. operator()(double xmin, double ymin, const std::vector\(<\)std::pair\(<\)double,double\(>\) \(>\)&) prints in addition the coordinates of the (x,y) values at the minimum.; 5.10 MnScan and ScanMinimizer; [api:scan]; MnScan scans the value of the user function by varying one parameter. It is sometimes useful for",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:47642,Availability,error,errors,47642,"r which the calculation will be stopped for that parameter.; 5.8.1 MnMinos(const FCNBase&, const FunctionMinimum&); Construct an MnMinos object from the user’s \(\mbox{FCN}\) and a valid FunctionMinimum. Additional constructors for user specific MnStrategy settings are provided.; 5.8.2 operator(); MnMinos::operator()(unsigned int n, unsigned int maxcalls) causes a \(\mbox{MINOS}\) error analysis for external parameter \(\mbox{n}\). The return value is a std::pair\(<\)double,double\(>\) with the lower and upper bounds of parameter \(\mbox{n}\).; 5.8.3 minos(unsigned int n, unsigned int maxcalls); MnMinos::minos(unsigned int n, unsigned int maxcalls) causes a \(\mbox{MINOS}\) error analysis for external parameter \(\mbox{n}\) and returns a MinosError with the lower and upper bounds of parameter \(\mbox{n}\) and additional information in case that one bound could not be found. The result MinosError can be easily printed using std::cout.; 5.8.4 Other methods; Additional methods exist to ask for one side of \(\mbox{MINOS}\) errors only.; 5.9 MnPlot; [api:plot] MnPlot prints the result of \(\mbox{CONTOURS}\) or \(\mbox{SCAN}\) on a text terminal.; 5.9.1 MnPlot(); The default constructor initializes default settings for the text window size.; 5.9.2 operator(); MnPlot::operator()(const std::vector\(<\)std::pair\(<\)double,double\(>\) \(>\)&) prints a vector of (x,y) points on the text terminal. operator()(double xmin, double ymin, const std::vector\(<\)std::pair\(<\)double,double\(>\) \(>\)&) prints in addition the coordinates of the (x,y) values at the minimum.; 5.10 MnScan and ScanMinimizer; [api:scan]; MnScan scans the value of the user function by varying one parameter. It is sometimes useful for debugging the user function or finding a reasonable starting point. Constructor arguments, methods arguments and names of methods are the same as for MnMigrad and VariableMetricMinimizer.; 5.10.1 scan(unsigned int par, unsigned int npoint, double low, double high); Scans the va",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:50987,Availability,toler,tolerance,50987,"y the SimplexMinimizer. Minimization of the function can be done by directly using the SimplexMinimizer if no parameters interaction is required. As \(\mbox{SIMPLEX}\) is a stepping method it does not produce a covariance matrix.; 5.11.1 MnSimplex(const FCNBase&, const std::vector\(<\)double\(>\)&,. const std::vector\(<\)double\(>\)&, unsigned int) ###; Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.11.2 MnSimplex(const FCNBase&, const MnUserParameters&,. unsigned int) ###; Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.11.3 MnSimplex(const FCNBase&, const MnUserParameterState&,. const MnStrategy&) ###; Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.11.4 operator(); MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. Minimization terminates either when the function has been called (approximately) \(\mbox{maxfcn}\) times, or when the estimated vertical distance to minimum (\(\mbox{EDM}\)) is less than \(\mbox{tolerance*up}\). The default value of \(\mbox{tolerance}\) is \(\mbox{0.1}\). (see [howto:errordef]).; 5.11.5 Parameter interaction; MnSimplex retains the result after each minimization (MnUserParameterStae, see [api:state]) and forwards the interface for parameter interaction.; 5.11.6 SimplexMinimizer(); The SimplexMinimizer() is instantiated using default constructor.; 5.11.7 minimize(const FCNBase&, …); The SimplexMinimizer provides several overloaded methods minimize with return value FunctionMinimum. Together with the user \(\mbox{FCN}\) (either an implementation of FCNBase or FCNGradientBase) the user has to give as input the parameters with starting values in one of the defined formats (std::vector\(<\)d",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:51288,Availability,toler,tolerance,51288," does not produce a covariance matrix.; 5.11.1 MnSimplex(const FCNBase&, const std::vector\(<\)double\(>\)&,. const std::vector\(<\)double\(>\)&, unsigned int) ###; Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.11.2 MnSimplex(const FCNBase&, const MnUserParameters&,. unsigned int) ###; Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.11.3 MnSimplex(const FCNBase&, const MnUserParameterState&,. const MnStrategy&) ###; Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.11.4 operator(); MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. Minimization terminates either when the function has been called (approximately) \(\mbox{maxfcn}\) times, or when the estimated vertical distance to minimum (\(\mbox{EDM}\)) is less than \(\mbox{tolerance*up}\). The default value of \(\mbox{tolerance}\) is \(\mbox{0.1}\). (see [howto:errordef]).; 5.11.5 Parameter interaction; MnSimplex retains the result after each minimization (MnUserParameterStae, see [api:state]) and forwards the interface for parameter interaction.; 5.11.6 SimplexMinimizer(); The SimplexMinimizer() is instantiated using default constructor.; 5.11.7 minimize(const FCNBase&, …); The SimplexMinimizer provides several overloaded methods minimize with return value FunctionMinimum. Together with the user \(\mbox{FCN}\) (either an implementation of FCNBase or FCNGradientBase) the user has to give as input the parameters with starting values in one of the defined formats (std::vector\(<\)double\(>\), MnUserParameters or MnUserParameterState).; 5.12 MnStrategy; [api:strategy] Sets the strategy to be used in calculating first and second derivatives and in certain minimization m",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:51334,Availability,toler,tolerance,51334,"uble\(>\)&, unsigned int) ###; Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.11.2 MnSimplex(const FCNBase&, const MnUserParameters&,. unsigned int) ###; Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.11.3 MnSimplex(const FCNBase&, const MnUserParameterState&,. const MnStrategy&) ###; Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.11.4 operator(); MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. Minimization terminates either when the function has been called (approximately) \(\mbox{maxfcn}\) times, or when the estimated vertical distance to minimum (\(\mbox{EDM}\)) is less than \(\mbox{tolerance*up}\). The default value of \(\mbox{tolerance}\) is \(\mbox{0.1}\). (see [howto:errordef]).; 5.11.5 Parameter interaction; MnSimplex retains the result after each minimization (MnUserParameterStae, see [api:state]) and forwards the interface for parameter interaction.; 5.11.6 SimplexMinimizer(); The SimplexMinimizer() is instantiated using default constructor.; 5.11.7 minimize(const FCNBase&, …); The SimplexMinimizer provides several overloaded methods minimize with return value FunctionMinimum. Together with the user \(\mbox{FCN}\) (either an implementation of FCNBase or FCNGradientBase) the user has to give as input the parameters with starting values in one of the defined formats (std::vector\(<\)double\(>\), MnUserParameters or MnUserParameterState).; 5.12 MnStrategy; [api:strategy] Sets the strategy to be used in calculating first and second derivatives and in certain minimization methods. In general, low values of \(\mbox{level}\) mean fewer function calls and high values mean more reliable minimization. Currentl",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:51378,Availability,error,errordef,51378,"r the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.11.2 MnSimplex(const FCNBase&, const MnUserParameters&,. unsigned int) ###; Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.11.3 MnSimplex(const FCNBase&, const MnUserParameterState&,. const MnStrategy&) ###; Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.11.4 operator(); MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. Minimization terminates either when the function has been called (approximately) \(\mbox{maxfcn}\) times, or when the estimated vertical distance to minimum (\(\mbox{EDM}\)) is less than \(\mbox{tolerance*up}\). The default value of \(\mbox{tolerance}\) is \(\mbox{0.1}\). (see [howto:errordef]).; 5.11.5 Parameter interaction; MnSimplex retains the result after each minimization (MnUserParameterStae, see [api:state]) and forwards the interface for parameter interaction.; 5.11.6 SimplexMinimizer(); The SimplexMinimizer() is instantiated using default constructor.; 5.11.7 minimize(const FCNBase&, …); The SimplexMinimizer provides several overloaded methods minimize with return value FunctionMinimum. Together with the user \(\mbox{FCN}\) (either an implementation of FCNBase or FCNGradientBase) the user has to give as input the parameters with starting values in one of the defined formats (std::vector\(<\)double\(>\), MnUserParameters or MnUserParameterState).; 5.12 MnStrategy; [api:strategy] Sets the strategy to be used in calculating first and second derivatives and in certain minimization methods. In general, low values of \(\mbox{level}\) mean fewer function calls and high values mean more reliable minimization. Currently allowed values are 0 (low), 1 (default), an",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:52301,Availability,reliab,reliable,52301,")) is less than \(\mbox{tolerance*up}\). The default value of \(\mbox{tolerance}\) is \(\mbox{0.1}\). (see [howto:errordef]).; 5.11.5 Parameter interaction; MnSimplex retains the result after each minimization (MnUserParameterStae, see [api:state]) and forwards the interface for parameter interaction.; 5.11.6 SimplexMinimizer(); The SimplexMinimizer() is instantiated using default constructor.; 5.11.7 minimize(const FCNBase&, …); The SimplexMinimizer provides several overloaded methods minimize with return value FunctionMinimum. Together with the user \(\mbox{FCN}\) (either an implementation of FCNBase or FCNGradientBase) the user has to give as input the parameters with starting values in one of the defined formats (std::vector\(<\)double\(>\), MnUserParameters or MnUserParameterState).; 5.12 MnStrategy; [api:strategy] Sets the strategy to be used in calculating first and second derivatives and in certain minimization methods. In general, low values of \(\mbox{level}\) mean fewer function calls and high values mean more reliable minimization. Currently allowed values are 0 (low), 1 (default), and 2 (high).; 5.12.1 MnStrategy(); Default constructor, sets all settings according to \(\mbox{level}\)$ = 1.$; 5.12.2 MnStrategy(unsigned int level); Explicit constructor for predefined settings of desired \(\mbox{level}\) 0 (low), 1 (default), or 2 (high).; 5.12.3 setLowStrategy(), setMediumStrategy(), setHighStrategy(); Methods to set specific strategy level.; 5.12.4 Other methods; In addition, methods for individual settings such as setGradientNCycles() are provided.; 5.13 MnUserCovariance; [api:covariance] MnUserCovariance is the external covariance matrix designed for the interaction of the user. The result of the minimization (internal covariance matrix) is converted into the user representable format. It can also be used as input prior to the minimization. The size of the covariance matrix is according to the number of variable parameters (free and limited).; 5.13.1 M",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:55661,Availability,error,error,55661,", double, double) for adding a free variable parameter; add(const char*, double, double, double, double) for adding a variable parameter with limits (lower and upper); add(const char*, double) for adding a constant parameter. When adding parameters, M assigns indices to each parameter which will be the same as in the std::vector\(<\)double\(>\) in the FCNBase::operator(). That means the first parameter the user adds gets index 0, the second index 1, and so on. When calculating the function value inside FCN, M will call FCNBase::operator() with the elements at their positions.; 5.14.2 setValue(…); [api:setvalue] setValue(unsigned int parno, double value) or setValue(const char* name, double value) set the value of parameter \(\mbox{parno}\) or with name \(\mbox{name}\) to \(\mbox{ value}\). The parameter in question may be variable, fixed, or constant, but must be defined.; 5.14.3 setError(…); [api:seterror] setError(unsigned int parno, double error) or setError(const char* name, double error) set the error (sigma) of parameter \(\mbox{parno}\) or with name \(\mbox{name}\) to \(\mbox{value}\).; 5.14.4 fix(…); [api:fix] fix(unsigned int parno) or fix(const char* name) fixes parameter \(\mbox{parno}\) or with name \(\mbox{name}\).; 5.14.5 release(…); [api:release] release(unsigned int parno) or release(const char* name) releases a previously fixed parameter \(\mbox{parno}\) or with name \(\mbox{name}\).; 5.14.6 setLimits(…); [api:setlimits] setLimits(unsigned int n, double low, double up) or setLimits(const char* name, double low, double up) sets the lower and upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\).; However, if \(\mbox{low}\) is equal to \(\mbox{up}\), an error condition results.; 5.14.7 setUpperLimit(…); [api:setupperlimits] setUpperLimit(unsigned int n, double up) or setUpperLimit(const char* name, double up) sets the upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have a lower limit.; 5.14.8 se",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:55705,Availability,error,error,55705,", double, double) for adding a free variable parameter; add(const char*, double, double, double, double) for adding a variable parameter with limits (lower and upper); add(const char*, double) for adding a constant parameter. When adding parameters, M assigns indices to each parameter which will be the same as in the std::vector\(<\)double\(>\) in the FCNBase::operator(). That means the first parameter the user adds gets index 0, the second index 1, and so on. When calculating the function value inside FCN, M will call FCNBase::operator() with the elements at their positions.; 5.14.2 setValue(…); [api:setvalue] setValue(unsigned int parno, double value) or setValue(const char* name, double value) set the value of parameter \(\mbox{parno}\) or with name \(\mbox{name}\) to \(\mbox{ value}\). The parameter in question may be variable, fixed, or constant, but must be defined.; 5.14.3 setError(…); [api:seterror] setError(unsigned int parno, double error) or setError(const char* name, double error) set the error (sigma) of parameter \(\mbox{parno}\) or with name \(\mbox{name}\) to \(\mbox{value}\).; 5.14.4 fix(…); [api:fix] fix(unsigned int parno) or fix(const char* name) fixes parameter \(\mbox{parno}\) or with name \(\mbox{name}\).; 5.14.5 release(…); [api:release] release(unsigned int parno) or release(const char* name) releases a previously fixed parameter \(\mbox{parno}\) or with name \(\mbox{name}\).; 5.14.6 setLimits(…); [api:setlimits] setLimits(unsigned int n, double low, double up) or setLimits(const char* name, double low, double up) sets the lower and upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\).; However, if \(\mbox{low}\) is equal to \(\mbox{up}\), an error condition results.; 5.14.7 setUpperLimit(…); [api:setupperlimits] setUpperLimit(unsigned int n, double up) or setUpperLimit(const char* name, double up) sets the upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have a lower limit.; 5.14.8 se",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:55720,Availability,error,error,55720,", double, double) for adding a free variable parameter; add(const char*, double, double, double, double) for adding a variable parameter with limits (lower and upper); add(const char*, double) for adding a constant parameter. When adding parameters, M assigns indices to each parameter which will be the same as in the std::vector\(<\)double\(>\) in the FCNBase::operator(). That means the first parameter the user adds gets index 0, the second index 1, and so on. When calculating the function value inside FCN, M will call FCNBase::operator() with the elements at their positions.; 5.14.2 setValue(…); [api:setvalue] setValue(unsigned int parno, double value) or setValue(const char* name, double value) set the value of parameter \(\mbox{parno}\) or with name \(\mbox{name}\) to \(\mbox{ value}\). The parameter in question may be variable, fixed, or constant, but must be defined.; 5.14.3 setError(…); [api:seterror] setError(unsigned int parno, double error) or setError(const char* name, double error) set the error (sigma) of parameter \(\mbox{parno}\) or with name \(\mbox{name}\) to \(\mbox{value}\).; 5.14.4 fix(…); [api:fix] fix(unsigned int parno) or fix(const char* name) fixes parameter \(\mbox{parno}\) or with name \(\mbox{name}\).; 5.14.5 release(…); [api:release] release(unsigned int parno) or release(const char* name) releases a previously fixed parameter \(\mbox{parno}\) or with name \(\mbox{name}\).; 5.14.6 setLimits(…); [api:setlimits] setLimits(unsigned int n, double low, double up) or setLimits(const char* name, double low, double up) sets the lower and upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\).; However, if \(\mbox{low}\) is equal to \(\mbox{up}\), an error condition results.; 5.14.7 setUpperLimit(…); [api:setupperlimits] setUpperLimit(unsigned int n, double up) or setUpperLimit(const char* name, double up) sets the upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have a lower limit.; 5.14.8 se",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:56414,Availability,error,error,56414,"double value) set the value of parameter \(\mbox{parno}\) or with name \(\mbox{name}\) to \(\mbox{ value}\). The parameter in question may be variable, fixed, or constant, but must be defined.; 5.14.3 setError(…); [api:seterror] setError(unsigned int parno, double error) or setError(const char* name, double error) set the error (sigma) of parameter \(\mbox{parno}\) or with name \(\mbox{name}\) to \(\mbox{value}\).; 5.14.4 fix(…); [api:fix] fix(unsigned int parno) or fix(const char* name) fixes parameter \(\mbox{parno}\) or with name \(\mbox{name}\).; 5.14.5 release(…); [api:release] release(unsigned int parno) or release(const char* name) releases a previously fixed parameter \(\mbox{parno}\) or with name \(\mbox{name}\).; 5.14.6 setLimits(…); [api:setlimits] setLimits(unsigned int n, double low, double up) or setLimits(const char* name, double low, double up) sets the lower and upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\).; However, if \(\mbox{low}\) is equal to \(\mbox{up}\), an error condition results.; 5.14.7 setUpperLimit(…); [api:setupperlimits] setUpperLimit(unsigned int n, double up) or setUpperLimit(const char* name, double up) sets the upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have a lower limit.; 5.14.8 setLowerLimit(…); [api:setlowerlimits] setLowerLimit(unsigned int n, double low) or setLowerLimit(const char* name, double low) sets the lower bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have an upper limit.; 5.14.9 removeLimits(…); [api:removelimits] removeLimits(unsigned int n) or removeLimits(const char* name) removes all possible limits on parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameter can then vary in both directions without any bounds.; 5.14.10 value(…); value(unsigned int n) or value(const char* name) return the current value of parameter \(\mbox{n}\) or with name \(\mbox{name}\).; 5.14.11 error(…); error(unsigned int ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:57368,Availability,error,error,57368,"4.7 setUpperLimit(…); [api:setupperlimits] setUpperLimit(unsigned int n, double up) or setUpperLimit(const char* name, double up) sets the upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have a lower limit.; 5.14.8 setLowerLimit(…); [api:setlowerlimits] setLowerLimit(unsigned int n, double low) or setLowerLimit(const char* name, double low) sets the lower bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have an upper limit.; 5.14.9 removeLimits(…); [api:removelimits] removeLimits(unsigned int n) or removeLimits(const char* name) removes all possible limits on parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameter can then vary in both directions without any bounds.; 5.14.10 value(…); value(unsigned int n) or value(const char* name) return the current value of parameter \(\mbox{n}\) or with name \(\mbox{name}\).; 5.14.11 error(…); error(unsigned int n) or error(const char* name) return the current uncertainty (error) of parameter \(\mbox{n}\) or with name \(\mbox{ name}\).; 5.14.12 index(…); index(const char* name) returns the index (current position) of the parameter with name \(\mbox{ name}\) in the list of defined parameters. The index is the same as for the calculation of the function value in the user’s FCN (FCNBase::operator()).; 5.14.13 name(…); name(unsigned int n) returns the name of the parameter with index \(n\).; 5.15 MnUserParameterState; [api:state] The class MnUserParameterState contains the MnUserParameters and the MnUserCovariance. It can be created on input by the user, or by M itself as user representable format of the result of the minimization.; 5.15.1 MnUserParameterState(const std::vector\(<\)double\(>\)&,. const std::vector\(<\)double\(>\)&) ###; Construct a state from starting values specified via std::vector\(<\)double\(>\). No covariance is available.; 5.15.2 MnUserParameterState(const MnUserParameters&); Construct a state from starting values specif",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:57378,Availability,error,error,57378,"4.7 setUpperLimit(…); [api:setupperlimits] setUpperLimit(unsigned int n, double up) or setUpperLimit(const char* name, double up) sets the upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have a lower limit.; 5.14.8 setLowerLimit(…); [api:setlowerlimits] setLowerLimit(unsigned int n, double low) or setLowerLimit(const char* name, double low) sets the lower bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have an upper limit.; 5.14.9 removeLimits(…); [api:removelimits] removeLimits(unsigned int n) or removeLimits(const char* name) removes all possible limits on parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameter can then vary in both directions without any bounds.; 5.14.10 value(…); value(unsigned int n) or value(const char* name) return the current value of parameter \(\mbox{n}\) or with name \(\mbox{name}\).; 5.14.11 error(…); error(unsigned int n) or error(const char* name) return the current uncertainty (error) of parameter \(\mbox{n}\) or with name \(\mbox{ name}\).; 5.14.12 index(…); index(const char* name) returns the index (current position) of the parameter with name \(\mbox{ name}\) in the list of defined parameters. The index is the same as for the calculation of the function value in the user’s FCN (FCNBase::operator()).; 5.14.13 name(…); name(unsigned int n) returns the name of the parameter with index \(n\).; 5.15 MnUserParameterState; [api:state] The class MnUserParameterState contains the MnUserParameters and the MnUserCovariance. It can be created on input by the user, or by M itself as user representable format of the result of the minimization.; 5.15.1 MnUserParameterState(const std::vector\(<\)double\(>\)&,. const std::vector\(<\)double\(>\)&) ###; Construct a state from starting values specified via std::vector\(<\)double\(>\). No covariance is available.; 5.15.2 MnUserParameterState(const MnUserParameters&); Construct a state from starting values specif",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:57403,Availability,error,error,57403,"4.7 setUpperLimit(…); [api:setupperlimits] setUpperLimit(unsigned int n, double up) or setUpperLimit(const char* name, double up) sets the upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have a lower limit.; 5.14.8 setLowerLimit(…); [api:setlowerlimits] setLowerLimit(unsigned int n, double low) or setLowerLimit(const char* name, double low) sets the lower bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have an upper limit.; 5.14.9 removeLimits(…); [api:removelimits] removeLimits(unsigned int n) or removeLimits(const char* name) removes all possible limits on parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameter can then vary in both directions without any bounds.; 5.14.10 value(…); value(unsigned int n) or value(const char* name) return the current value of parameter \(\mbox{n}\) or with name \(\mbox{name}\).; 5.14.11 error(…); error(unsigned int n) or error(const char* name) return the current uncertainty (error) of parameter \(\mbox{n}\) or with name \(\mbox{ name}\).; 5.14.12 index(…); index(const char* name) returns the index (current position) of the parameter with name \(\mbox{ name}\) in the list of defined parameters. The index is the same as for the calculation of the function value in the user’s FCN (FCNBase::operator()).; 5.14.13 name(…); name(unsigned int n) returns the name of the parameter with index \(n\).; 5.15 MnUserParameterState; [api:state] The class MnUserParameterState contains the MnUserParameters and the MnUserCovariance. It can be created on input by the user, or by M itself as user representable format of the result of the minimization.; 5.15.1 MnUserParameterState(const std::vector\(<\)double\(>\)&,. const std::vector\(<\)double\(>\)&) ###; Construct a state from starting values specified via std::vector\(<\)double\(>\). No covariance is available.; 5.15.2 MnUserParameterState(const MnUserParameters&); Construct a state from starting values specif",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:57459,Availability,error,error,57459,"4.7 setUpperLimit(…); [api:setupperlimits] setUpperLimit(unsigned int n, double up) or setUpperLimit(const char* name, double up) sets the upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have a lower limit.; 5.14.8 setLowerLimit(…); [api:setlowerlimits] setLowerLimit(unsigned int n, double low) or setLowerLimit(const char* name, double low) sets the lower bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have an upper limit.; 5.14.9 removeLimits(…); [api:removelimits] removeLimits(unsigned int n) or removeLimits(const char* name) removes all possible limits on parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameter can then vary in both directions without any bounds.; 5.14.10 value(…); value(unsigned int n) or value(const char* name) return the current value of parameter \(\mbox{n}\) or with name \(\mbox{name}\).; 5.14.11 error(…); error(unsigned int n) or error(const char* name) return the current uncertainty (error) of parameter \(\mbox{n}\) or with name \(\mbox{ name}\).; 5.14.12 index(…); index(const char* name) returns the index (current position) of the parameter with name \(\mbox{ name}\) in the list of defined parameters. The index is the same as for the calculation of the function value in the user’s FCN (FCNBase::operator()).; 5.14.13 name(…); name(unsigned int n) returns the name of the parameter with index \(n\).; 5.15 MnUserParameterState; [api:state] The class MnUserParameterState contains the MnUserParameters and the MnUserCovariance. It can be created on input by the user, or by M itself as user representable format of the result of the minimization.; 5.15.1 MnUserParameterState(const std::vector\(<\)double\(>\)&,. const std::vector\(<\)double\(>\)&) ###; Construct a state from starting values specified via std::vector\(<\)double\(>\). No covariance is available.; 5.15.2 MnUserParameterState(const MnUserParameters&); Construct a state from starting values specif",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:58333,Availability,avail,available,58333,"or with name \(\mbox{name}\).; 5.14.11 error(…); error(unsigned int n) or error(const char* name) return the current uncertainty (error) of parameter \(\mbox{n}\) or with name \(\mbox{ name}\).; 5.14.12 index(…); index(const char* name) returns the index (current position) of the parameter with name \(\mbox{ name}\) in the list of defined parameters. The index is the same as for the calculation of the function value in the user’s FCN (FCNBase::operator()).; 5.14.13 name(…); name(unsigned int n) returns the name of the parameter with index \(n\).; 5.15 MnUserParameterState; [api:state] The class MnUserParameterState contains the MnUserParameters and the MnUserCovariance. It can be created on input by the user, or by M itself as user representable format of the result of the minimization.; 5.15.1 MnUserParameterState(const std::vector\(<\)double\(>\)&,. const std::vector\(<\)double\(>\)&) ###; Construct a state from starting values specified via std::vector\(<\)double\(>\). No covariance is available.; 5.15.2 MnUserParameterState(const MnUserParameters&); Construct a state from starting values specified via MnUserParameters. No covariance is available.; 5.15.3 MnUserParameterState(const MnUserParameters&,. const MnUserCovariance&) ###; Construct a state from starting values specified via MnUserParameters and MnUserCovariance.; 5.15.4 parameters(); The method parameters() returns a const reference to the MnUserParameters data member.; 5.15.5 covariance(); The method covariance() returns a const reference to the MnUserCovariance data member.; 5.15.6 globalCC(); The method globalCC() returns a const reference to the MnGlobalCorrelationCoeff data member.; 5.15.7 MnUserParameterState::isValid() and. MnUserParameterState::hasCovariance() ###; isValid() returns true if the state is valid, false if not. hasCovariance returns true if the state has a valid covariance, false otherwise.; 5.15.8 MnUserParameterState::fval(), MnUserParameterState::edm(),. MnUserParameterState::nfcn",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:58487,Availability,avail,available,58487,"box{n}\) or with name \(\mbox{ name}\).; 5.14.12 index(…); index(const char* name) returns the index (current position) of the parameter with name \(\mbox{ name}\) in the list of defined parameters. The index is the same as for the calculation of the function value in the user’s FCN (FCNBase::operator()).; 5.14.13 name(…); name(unsigned int n) returns the name of the parameter with index \(n\).; 5.15 MnUserParameterState; [api:state] The class MnUserParameterState contains the MnUserParameters and the MnUserCovariance. It can be created on input by the user, or by M itself as user representable format of the result of the minimization.; 5.15.1 MnUserParameterState(const std::vector\(<\)double\(>\)&,. const std::vector\(<\)double\(>\)&) ###; Construct a state from starting values specified via std::vector\(<\)double\(>\). No covariance is available.; 5.15.2 MnUserParameterState(const MnUserParameters&); Construct a state from starting values specified via MnUserParameters. No covariance is available.; 5.15.3 MnUserParameterState(const MnUserParameters&,. const MnUserCovariance&) ###; Construct a state from starting values specified via MnUserParameters and MnUserCovariance.; 5.15.4 parameters(); The method parameters() returns a const reference to the MnUserParameters data member.; 5.15.5 covariance(); The method covariance() returns a const reference to the MnUserCovariance data member.; 5.15.6 globalCC(); The method globalCC() returns a const reference to the MnGlobalCorrelationCoeff data member.; 5.15.7 MnUserParameterState::isValid() and. MnUserParameterState::hasCovariance() ###; isValid() returns true if the state is valid, false if not. hasCovariance returns true if the state has a valid covariance, false otherwise.; 5.15.8 MnUserParameterState::fval(), MnUserParameterState::edm(),. MnUserParameterState::nfcn() ###; After minimization:. fval() returns the function value at the minimum; edm() returns the expected vertical distance to the minimum EDM; nfcn() ret",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:60800,Availability,error,errors,60800,"State), the function value, the expected distance to the minimum and the number of function calls.; 5.16.2 operator\(<<\)(std::ostream&, const MnUserParameters&); Prints out the MnUserParameters.; 5.16.3 operator\(<<\)(std::ostream&, const MnUserCovariance&); Prints out the MnUserCovariance.; 5.16.4 operator\(<<\)(std::ostream&, const MnGlobalCorrelationCoeff&); Prints out the MnGlobalCorrelationCoeff.; 5.16.5 operator\(<<\)(std::ostream&, const MnUserParameterState&); Prints out the whole MnUserParameterState: MnUserParameters, MnUserCovariance and MnGlobalCorrelationCoeff.; 5.16.6 operator\(<<\)(std::ostream&, const MinosError&); Prints out the MinosError of a given parameter.; 5.16.7 operator\(<<\)(std::ostream&, const ContoursErros&); Prints out the MinosError of the two parameters and plots a line printer graphic of the contours on the output terminal.; 6 How to get the right answer from M; The goal of M — to be able to minimize and analyze parameter errors for all possible user functions with any number of variable parameters — is of course impossible to realise, even in principle, in a finite amount of time. In practice, some assumptions must be made about the behaviour of the function in order to avoid evaluating it at all possible points. In this chapter we give some hints on how the user can help M to make the right assumptions.; 6.1 Which minimizer to use; One of the historically interesting advantages of M is that it was probably the first minimization program to offer the user a choice of several minimization algorithms. This could be taken as a reflection of the fact that none of the algorithms known at that time were good enough to be universal, so users were encouraged to find the one that worked best for them. Since then, algorithms have improved considerably, but M still offers several, mostly so that old users will not feel cheated, but also to help the occasional user who does manage to defeat the best algorithms. M currently offers four applicati",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:62339,Availability,reliab,reliable,62339,"oice of several minimization algorithms. This could be taken as a reflection of the fact that none of the algorithms known at that time were good enough to be universal, so users were encouraged to find the one that worked best for them. Since then, algorithms have improved considerably, but M still offers several, mostly so that old users will not feel cheated, but also to help the occasional user who does manage to defeat the best algorithms. M currently offers four applications which can be used to find a smaller function value, in addition to \(\mbox{MINOS}\), which will retain a smaller function value if it stumbles on one unexpectedly. The objects which can be used to minimize are:; 6.1.1 \(\mbox{MIGRAD}\); This is the best minimizer for nearly all functions. It is a variable-metric method with inexact line search, a stable metric updating scheme, and checks for positive-definiteness. It will run faster if you instantiate it with a low–level MnStrategy and will be more reliable if you instantiate it with a high–level MnStrategy (although the latter option may not help much). Its main weakness is that it depends heavily on knowledge of the first derivatives, and fails miserably if they are very inaccurate. If first derivatives are a problem, they can be calculated analytically inside \(\mbox{FCN}\) (see [howto:fcn]) or if this is not feasible, the user can try to improve the accuracy of M ’s numerical approximation by adjusting values of MnMachinePrecision and/or MnStrategy (see [api:epsmac] and [api:strategy]).; 6.1.2 \(\mbox{MINIMIZE}\); This is equivalent to \(\mbox{MIGRAD}\), except that if \(\mbox{MIGRAD}\) fails, it reverts to \(\mbox{SIMPLEX}\) and then calls \(\mbox{MIGRAD}\) again.; 6.1.3 \(\mbox{SCAN}\); This is not intended to minimize, and just scans the function, one parameter at a time. It does however retain the best value after each scan, so it does some sort of highly primitive minimization.; 6.1.4 \(\mbox{SIMPLEX}\); This genuine multidimensio",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:63565,Availability,robust,robust,63565,"is that it depends heavily on knowledge of the first derivatives, and fails miserably if they are very inaccurate. If first derivatives are a problem, they can be calculated analytically inside \(\mbox{FCN}\) (see [howto:fcn]) or if this is not feasible, the user can try to improve the accuracy of M ’s numerical approximation by adjusting values of MnMachinePrecision and/or MnStrategy (see [api:epsmac] and [api:strategy]).; 6.1.2 \(\mbox{MINIMIZE}\); This is equivalent to \(\mbox{MIGRAD}\), except that if \(\mbox{MIGRAD}\) fails, it reverts to \(\mbox{SIMPLEX}\) and then calls \(\mbox{MIGRAD}\) again.; 6.1.3 \(\mbox{SCAN}\); This is not intended to minimize, and just scans the function, one parameter at a time. It does however retain the best value after each scan, so it does some sort of highly primitive minimization.; 6.1.4 \(\mbox{SIMPLEX}\); This genuine multidimensional minimization routine is usually much slower than \(\mbox{MIGRAD}\), but it does not use first derivatives, so it should not be so sensitive to the precision of the \(\mbox{FCN}\) calculations, and is even rather robust with respect to gross fluctuations in the function value. However, it gives no reliable information about parameter errors, no information whatsoever about parameter correlations, and worst of all cannot be expected to converge accurately to the minimum in a finite time. Its estimate of the expected distance to the minimum \(\mbox{EDM}\) is largely fantasy, so it would not even know if it did converge.; 6.2 Floating point precision; M figures out at execution time the machine precision [api:epsmac], and assumes that \(\mbox{FCN}\) provides about the same precision. That means not just the length of the numbers used and returned by \(\mbox{FCN}\), but the actual mathematical accuracy of the calculations. Section [install:epsmac] describes what to do if this is not the case.; 6.3 Parameter limits; Putting limits (absolute bounds) on the allowed values for a given parameter, causes M",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:63651,Availability,reliab,reliable,63651," to improve the accuracy of M ’s numerical approximation by adjusting values of MnMachinePrecision and/or MnStrategy (see [api:epsmac] and [api:strategy]).; 6.1.2 \(\mbox{MINIMIZE}\); This is equivalent to \(\mbox{MIGRAD}\), except that if \(\mbox{MIGRAD}\) fails, it reverts to \(\mbox{SIMPLEX}\) and then calls \(\mbox{MIGRAD}\) again.; 6.1.3 \(\mbox{SCAN}\); This is not intended to minimize, and just scans the function, one parameter at a time. It does however retain the best value after each scan, so it does some sort of highly primitive minimization.; 6.1.4 \(\mbox{SIMPLEX}\); This genuine multidimensional minimization routine is usually much slower than \(\mbox{MIGRAD}\), but it does not use first derivatives, so it should not be so sensitive to the precision of the \(\mbox{FCN}\) calculations, and is even rather robust with respect to gross fluctuations in the function value. However, it gives no reliable information about parameter errors, no information whatsoever about parameter correlations, and worst of all cannot be expected to converge accurately to the minimum in a finite time. Its estimate of the expected distance to the minimum \(\mbox{EDM}\) is largely fantasy, so it would not even know if it did converge.; 6.2 Floating point precision; M figures out at execution time the machine precision [api:epsmac], and assumes that \(\mbox{FCN}\) provides about the same precision. That means not just the length of the numbers used and returned by \(\mbox{FCN}\), but the actual mathematical accuracy of the calculations. Section [install:epsmac] describes what to do if this is not the case.; 6.3 Parameter limits; Putting limits (absolute bounds) on the allowed values for a given parameter, causes M to make a non-linear transformation of its own internal parameter values to obtain the (external) parameter values passed to \(\mbox{FCN}\). To understand the adverse effect of limits, see [intro:limits].; Basically, the use of limits should be avoided unless needed to ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:63688,Availability,error,errors,63688," to improve the accuracy of M ’s numerical approximation by adjusting values of MnMachinePrecision and/or MnStrategy (see [api:epsmac] and [api:strategy]).; 6.1.2 \(\mbox{MINIMIZE}\); This is equivalent to \(\mbox{MIGRAD}\), except that if \(\mbox{MIGRAD}\) fails, it reverts to \(\mbox{SIMPLEX}\) and then calls \(\mbox{MIGRAD}\) again.; 6.1.3 \(\mbox{SCAN}\); This is not intended to minimize, and just scans the function, one parameter at a time. It does however retain the best value after each scan, so it does some sort of highly primitive minimization.; 6.1.4 \(\mbox{SIMPLEX}\); This genuine multidimensional minimization routine is usually much slower than \(\mbox{MIGRAD}\), but it does not use first derivatives, so it should not be so sensitive to the precision of the \(\mbox{FCN}\) calculations, and is even rather robust with respect to gross fluctuations in the function value. However, it gives no reliable information about parameter errors, no information whatsoever about parameter correlations, and worst of all cannot be expected to converge accurately to the minimum in a finite time. Its estimate of the expected distance to the minimum \(\mbox{EDM}\) is largely fantasy, so it would not even know if it did converge.; 6.2 Floating point precision; M figures out at execution time the machine precision [api:epsmac], and assumes that \(\mbox{FCN}\) provides about the same precision. That means not just the length of the numbers used and returned by \(\mbox{FCN}\), but the actual mathematical accuracy of the calculations. Section [install:epsmac] describes what to do if this is not the case.; 6.3 Parameter limits; Putting limits (absolute bounds) on the allowed values for a given parameter, causes M to make a non-linear transformation of its own internal parameter values to obtain the (external) parameter values passed to \(\mbox{FCN}\). To understand the adverse effect of limits, see [intro:limits].; Basically, the use of limits should be avoided unless needed to ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:66491,Availability,error,errors,66491,"; The minimizer can become blocked at a limit, because at a limit the derivative seen by the minimizer \(\partial F / \partial P_{\mathrm{int}}\) is zero no matter what the real derivative \(\partial F / \partial P_{\mathrm{ext}}\) is.; \[\frac{\partial F}{\partial P_{\mathrm{int}}} =; \frac{\partial F}{\partial P_{\mathrm{ext}}}; \frac{\partial P_{\mathrm{ext}}}{\partial P_{\mathrm{int}}} =; \frac{\partial F}{\partial P_{\mathrm{ext}}} = 0\]; For a stepping method (like \(\mbox{SIMPLEX}\)) this seldom poses any problem, but a method based on derivatives (\(\mbox{MIGRAD}\)) may become blocked at such a value. If this happens, it may be necessary to move the value of the parameter in question a significant distance from the limit (e.g. with MnMigrad::setValue(…)) and restart the minimization, perhaps with that parameter fixed temporarily.; 6.3.2 Getting the right parameter errors with limits; [answer:right-errors]; In the best case, where the minimum is far from any limits, M will correctly transform the error matrix, and the parameter errors it reports should be accurate and very close to those you would have got without limits. In other cases (which should be more common, since otherwise you wouldn’t need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless. On the other hand, the \(\mbox{MINOS}\) analysis is still meaningful, at least in principle, as long as \(\mbox{MIGRAD}\) (which is called internally by \(\mbox{MINOS}\)) does not get blocked at a limit. Unfortunately, the user has no control over this aspect of the \(\mbox{MINOS}\) calculation, although it is possible to get enough printout from the \(\mbox{MINOS}\) result to be able to determine whether the results are reliable or not.; 6.4 Fixing and releasing pa",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:66525,Availability,error,errors,66525,"; The minimizer can become blocked at a limit, because at a limit the derivative seen by the minimizer \(\partial F / \partial P_{\mathrm{int}}\) is zero no matter what the real derivative \(\partial F / \partial P_{\mathrm{ext}}\) is.; \[\frac{\partial F}{\partial P_{\mathrm{int}}} =; \frac{\partial F}{\partial P_{\mathrm{ext}}}; \frac{\partial P_{\mathrm{ext}}}{\partial P_{\mathrm{int}}} =; \frac{\partial F}{\partial P_{\mathrm{ext}}} = 0\]; For a stepping method (like \(\mbox{SIMPLEX}\)) this seldom poses any problem, but a method based on derivatives (\(\mbox{MIGRAD}\)) may become blocked at such a value. If this happens, it may be necessary to move the value of the parameter in question a significant distance from the limit (e.g. with MnMigrad::setValue(…)) and restart the minimization, perhaps with that parameter fixed temporarily.; 6.3.2 Getting the right parameter errors with limits; [answer:right-errors]; In the best case, where the minimum is far from any limits, M will correctly transform the error matrix, and the parameter errors it reports should be accurate and very close to those you would have got without limits. In other cases (which should be more common, since otherwise you wouldn’t need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless. On the other hand, the \(\mbox{MINOS}\) analysis is still meaningful, at least in principle, as long as \(\mbox{MIGRAD}\) (which is called internally by \(\mbox{MINOS}\)) does not get blocked at a limit. Unfortunately, the user has no control over this aspect of the \(\mbox{MINOS}\) calculation, although it is possible to get enough printout from the \(\mbox{MINOS}\) result to be able to determine whether the results are reliable or not.; 6.4 Fixing and releasing pa",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:66625,Availability,error,error,66625,"; The minimizer can become blocked at a limit, because at a limit the derivative seen by the minimizer \(\partial F / \partial P_{\mathrm{int}}\) is zero no matter what the real derivative \(\partial F / \partial P_{\mathrm{ext}}\) is.; \[\frac{\partial F}{\partial P_{\mathrm{int}}} =; \frac{\partial F}{\partial P_{\mathrm{ext}}}; \frac{\partial P_{\mathrm{ext}}}{\partial P_{\mathrm{int}}} =; \frac{\partial F}{\partial P_{\mathrm{ext}}} = 0\]; For a stepping method (like \(\mbox{SIMPLEX}\)) this seldom poses any problem, but a method based on derivatives (\(\mbox{MIGRAD}\)) may become blocked at such a value. If this happens, it may be necessary to move the value of the parameter in question a significant distance from the limit (e.g. with MnMigrad::setValue(…)) and restart the minimization, perhaps with that parameter fixed temporarily.; 6.3.2 Getting the right parameter errors with limits; [answer:right-errors]; In the best case, where the minimum is far from any limits, M will correctly transform the error matrix, and the parameter errors it reports should be accurate and very close to those you would have got without limits. In other cases (which should be more common, since otherwise you wouldn’t need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless. On the other hand, the \(\mbox{MINOS}\) analysis is still meaningful, at least in principle, as long as \(\mbox{MIGRAD}\) (which is called internally by \(\mbox{MINOS}\)) does not get blocked at a limit. Unfortunately, the user has no control over this aspect of the \(\mbox{MINOS}\) calculation, although it is possible to get enough printout from the \(\mbox{MINOS}\) result to be able to determine whether the results are reliable or not.; 6.4 Fixing and releasing pa",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:66657,Availability,error,errors,66657,"; The minimizer can become blocked at a limit, because at a limit the derivative seen by the minimizer \(\partial F / \partial P_{\mathrm{int}}\) is zero no matter what the real derivative \(\partial F / \partial P_{\mathrm{ext}}\) is.; \[\frac{\partial F}{\partial P_{\mathrm{int}}} =; \frac{\partial F}{\partial P_{\mathrm{ext}}}; \frac{\partial P_{\mathrm{ext}}}{\partial P_{\mathrm{int}}} =; \frac{\partial F}{\partial P_{\mathrm{ext}}} = 0\]; For a stepping method (like \(\mbox{SIMPLEX}\)) this seldom poses any problem, but a method based on derivatives (\(\mbox{MIGRAD}\)) may become blocked at such a value. If this happens, it may be necessary to move the value of the parameter in question a significant distance from the limit (e.g. with MnMigrad::setValue(…)) and restart the minimization, perhaps with that parameter fixed temporarily.; 6.3.2 Getting the right parameter errors with limits; [answer:right-errors]; In the best case, where the minimum is far from any limits, M will correctly transform the error matrix, and the parameter errors it reports should be accurate and very close to those you would have got without limits. In other cases (which should be more common, since otherwise you wouldn’t need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless. On the other hand, the \(\mbox{MINOS}\) analysis is still meaningful, at least in principle, as long as \(\mbox{MIGRAD}\) (which is called internally by \(\mbox{MINOS}\)) does not get blocked at a limit. Unfortunately, the user has no control over this aspect of the \(\mbox{MINOS}\) calculation, although it is possible to get enough printout from the \(\mbox{MINOS}\) result to be able to determine whether the results are reliable or not.; 6.4 Fixing and releasing pa",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:66871,Availability,error,errors,66871,"thrm{ext}}\) is.; \[\frac{\partial F}{\partial P_{\mathrm{int}}} =; \frac{\partial F}{\partial P_{\mathrm{ext}}}; \frac{\partial P_{\mathrm{ext}}}{\partial P_{\mathrm{int}}} =; \frac{\partial F}{\partial P_{\mathrm{ext}}} = 0\]; For a stepping method (like \(\mbox{SIMPLEX}\)) this seldom poses any problem, but a method based on derivatives (\(\mbox{MIGRAD}\)) may become blocked at such a value. If this happens, it may be necessary to move the value of the parameter in question a significant distance from the limit (e.g. with MnMigrad::setValue(…)) and restart the minimization, perhaps with that parameter fixed temporarily.; 6.3.2 Getting the right parameter errors with limits; [answer:right-errors]; In the best case, where the minimum is far from any limits, M will correctly transform the error matrix, and the parameter errors it reports should be accurate and very close to those you would have got without limits. In other cases (which should be more common, since otherwise you wouldn’t need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless. On the other hand, the \(\mbox{MINOS}\) analysis is still meaningful, at least in principle, as long as \(\mbox{MIGRAD}\) (which is called internally by \(\mbox{MINOS}\)) does not get blocked at a limit. Unfortunately, the user has no control over this aspect of the \(\mbox{MINOS}\) calculation, although it is possible to get enough printout from the \(\mbox{MINOS}\) result to be able to determine whether the results are reliable or not.; 6.4 Fixing and releasing parameters; When M needs to be guided to the “right” minimum, often the best way to do this is with the methods e.g. MnMigrad::fix(…) and MnMigrad::release(…). That is, suppose you have a problem with ten free parameters",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:67007,Availability,error,error,67007,"}}{\partial P_{\mathrm{int}}} =; \frac{\partial F}{\partial P_{\mathrm{ext}}} = 0\]; For a stepping method (like \(\mbox{SIMPLEX}\)) this seldom poses any problem, but a method based on derivatives (\(\mbox{MIGRAD}\)) may become blocked at such a value. If this happens, it may be necessary to move the value of the parameter in question a significant distance from the limit (e.g. with MnMigrad::setValue(…)) and restart the minimization, perhaps with that parameter fixed temporarily.; 6.3.2 Getting the right parameter errors with limits; [answer:right-errors]; In the best case, where the minimum is far from any limits, M will correctly transform the error matrix, and the parameter errors it reports should be accurate and very close to those you would have got without limits. In other cases (which should be more common, since otherwise you wouldn’t need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless. On the other hand, the \(\mbox{MINOS}\) analysis is still meaningful, at least in principle, as long as \(\mbox{MIGRAD}\) (which is called internally by \(\mbox{MINOS}\)) does not get blocked at a limit. Unfortunately, the user has no control over this aspect of the \(\mbox{MINOS}\) calculation, although it is possible to get enough printout from the \(\mbox{MINOS}\) result to be able to determine whether the results are reliable or not.; 6.4 Fixing and releasing parameters; When M needs to be guided to the “right” minimum, often the best way to do this is with the methods e.g. MnMigrad::fix(…) and MnMigrad::release(…). That is, suppose you have a problem with ten free parameters, and when you minimize with respect to all at once, M goes to an unphysical solution characterized by an unphysical or unwanted value of parame",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:67045,Availability,error,error,67045,"x{SIMPLEX}\)) this seldom poses any problem, but a method based on derivatives (\(\mbox{MIGRAD}\)) may become blocked at such a value. If this happens, it may be necessary to move the value of the parameter in question a significant distance from the limit (e.g. with MnMigrad::setValue(…)) and restart the minimization, perhaps with that parameter fixed temporarily.; 6.3.2 Getting the right parameter errors with limits; [answer:right-errors]; In the best case, where the minimum is far from any limits, M will correctly transform the error matrix, and the parameter errors it reports should be accurate and very close to those you would have got without limits. In other cases (which should be more common, since otherwise you wouldn’t need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless. On the other hand, the \(\mbox{MINOS}\) analysis is still meaningful, at least in principle, as long as \(\mbox{MIGRAD}\) (which is called internally by \(\mbox{MINOS}\)) does not get blocked at a limit. Unfortunately, the user has no control over this aspect of the \(\mbox{MINOS}\) calculation, although it is possible to get enough printout from the \(\mbox{MINOS}\) result to be able to determine whether the results are reliable or not.; 6.4 Fixing and releasing parameters; When M needs to be guided to the “right” minimum, often the best way to do this is with the methods e.g. MnMigrad::fix(…) and MnMigrad::release(…). That is, suppose you have a problem with ten free parameters, and when you minimize with respect to all at once, M goes to an unphysical solution characterized by an unphysical or unwanted value of parameter number four. One way to avoid this is to fix parameter four at a “good” value (not necessarily the best, since you ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:67091,Availability,error,errors,67091,"x{SIMPLEX}\)) this seldom poses any problem, but a method based on derivatives (\(\mbox{MIGRAD}\)) may become blocked at such a value. If this happens, it may be necessary to move the value of the parameter in question a significant distance from the limit (e.g. with MnMigrad::setValue(…)) and restart the minimization, perhaps with that parameter fixed temporarily.; 6.3.2 Getting the right parameter errors with limits; [answer:right-errors]; In the best case, where the minimum is far from any limits, M will correctly transform the error matrix, and the parameter errors it reports should be accurate and very close to those you would have got without limits. In other cases (which should be more common, since otherwise you wouldn’t need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless. On the other hand, the \(\mbox{MINOS}\) analysis is still meaningful, at least in principle, as long as \(\mbox{MIGRAD}\) (which is called internally by \(\mbox{MINOS}\)) does not get blocked at a limit. Unfortunately, the user has no control over this aspect of the \(\mbox{MINOS}\) calculation, although it is possible to get enough printout from the \(\mbox{MINOS}\) result to be able to determine whether the results are reliable or not.; 6.4 Fixing and releasing parameters; When M needs to be guided to the “right” minimum, often the best way to do this is with the methods e.g. MnMigrad::fix(…) and MnMigrad::release(…). That is, suppose you have a problem with ten free parameters, and when you minimize with respect to all at once, M goes to an unphysical solution characterized by an unphysical or unwanted value of parameter number four. One way to avoid this is to fix parameter four at a “good” value (not necessarily the best, since you ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:67562,Availability,reliab,reliable,67562,"3.2 Getting the right parameter errors with limits; [answer:right-errors]; In the best case, where the minimum is far from any limits, M will correctly transform the error matrix, and the parameter errors it reports should be accurate and very close to those you would have got without limits. In other cases (which should be more common, since otherwise you wouldn’t need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless. On the other hand, the \(\mbox{MINOS}\) analysis is still meaningful, at least in principle, as long as \(\mbox{MIGRAD}\) (which is called internally by \(\mbox{MINOS}\)) does not get blocked at a limit. Unfortunately, the user has no control over this aspect of the \(\mbox{MINOS}\) calculation, although it is possible to get enough printout from the \(\mbox{MINOS}\) result to be able to determine whether the results are reliable or not.; 6.4 Fixing and releasing parameters; When M needs to be guided to the “right” minimum, often the best way to do this is with the methods e.g. MnMigrad::fix(…) and MnMigrad::release(…). That is, suppose you have a problem with ten free parameters, and when you minimize with respect to all at once, M goes to an unphysical solution characterized by an unphysical or unwanted value of parameter number four. One way to avoid this is to fix parameter four at a “good” value (not necessarily the best, since you presumably don’t know that yet), and minimize with respect to the others. Then release parameter four and minimize again. If the problem admits a “good” physical solution, you will normally find it this way. If it doesn’t work, you may see what is wrong by the following sequence (where \(\mbox{xxx}\) is the expected physical value for parameter four):; MnMigrad migrad(",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:69015,Availability,error,errors,69015,"ce you presumably don’t know that yet), and minimize with respect to the others. Then release parameter four and minimize again. If the problem admits a “good” physical solution, you will normally find it this way. If it doesn’t work, you may see what is wrong by the following sequence (where \(\mbox{xxx}\) is the expected physical value for parameter four):; MnMigrad migrad(...);; migrad.setValue(4, xxx);; migrad.fix(4);; FunctionMinimum min = migrad();; migrad.release(4);; MnScan scan(...);; std::vector<std::pair<double, double> > points = scan(4);; where \(\mbox{SCAN}\) gives you a picture of \(\mbox{FCN}\) as a function of parameter four alone, the others being fixed at their current best values. If you suspect the difficulty is due to parameter five, then add; MnContours contour(...);; std::vector<std::pair<double, double> > points = contour(4, 5);; to see a two-dimensional picture.; 6.5 Interpretation of parameter errors; There are two kinds of problems that can arise: The reliability of M ’s error estimates, and their statistical interpretation, assuming they are accurate.; 6.5.1 Statistical interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, parabolic versus \(\mbox{MINOS}\) errors, the appropriate value for \(\mbox{up}\) (see [howto:errordef]), and setting of exact confidence levels, see (in order of increasing complexity and completeness):. “Interpretation of the Errors on Parameters”, see Part 3 of this write-up.; “Determining the Statistical Significance of Experimental Results”@bib-MIN81.; “Statistical Methods in Experimental Physics”@bib-EADIE. 6.5.2 The reliability of M error estimates; M always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a \(\mbox{MIGRAD}\) or ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:69075,Availability,reliab,reliability,69075,"ce you presumably don’t know that yet), and minimize with respect to the others. Then release parameter four and minimize again. If the problem admits a “good” physical solution, you will normally find it this way. If it doesn’t work, you may see what is wrong by the following sequence (where \(\mbox{xxx}\) is the expected physical value for parameter four):; MnMigrad migrad(...);; migrad.setValue(4, xxx);; migrad.fix(4);; FunctionMinimum min = migrad();; migrad.release(4);; MnScan scan(...);; std::vector<std::pair<double, double> > points = scan(4);; where \(\mbox{SCAN}\) gives you a picture of \(\mbox{FCN}\) as a function of parameter four alone, the others being fixed at their current best values. If you suspect the difficulty is due to parameter five, then add; MnContours contour(...);; std::vector<std::pair<double, double> > points = contour(4, 5);; to see a two-dimensional picture.; 6.5 Interpretation of parameter errors; There are two kinds of problems that can arise: The reliability of M ’s error estimates, and their statistical interpretation, assuming they are accurate.; 6.5.1 Statistical interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, parabolic versus \(\mbox{MINOS}\) errors, the appropriate value for \(\mbox{up}\) (see [howto:errordef]), and setting of exact confidence levels, see (in order of increasing complexity and completeness):. “Interpretation of the Errors on Parameters”, see Part 3 of this write-up.; “Determining the Statistical Significance of Experimental Results”@bib-MIN81.; “Statistical Methods in Experimental Physics”@bib-EADIE. 6.5.2 The reliability of M error estimates; M always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a \(\mbox{MIGRAD}\) or ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:69095,Availability,error,error,69095,"ce you presumably don’t know that yet), and minimize with respect to the others. Then release parameter four and minimize again. If the problem admits a “good” physical solution, you will normally find it this way. If it doesn’t work, you may see what is wrong by the following sequence (where \(\mbox{xxx}\) is the expected physical value for parameter four):; MnMigrad migrad(...);; migrad.setValue(4, xxx);; migrad.fix(4);; FunctionMinimum min = migrad();; migrad.release(4);; MnScan scan(...);; std::vector<std::pair<double, double> > points = scan(4);; where \(\mbox{SCAN}\) gives you a picture of \(\mbox{FCN}\) as a function of parameter four alone, the others being fixed at their current best values. If you suspect the difficulty is due to parameter five, then add; MnContours contour(...);; std::vector<std::pair<double, double> > points = contour(4, 5);; to see a two-dimensional picture.; 6.5 Interpretation of parameter errors; There are two kinds of problems that can arise: The reliability of M ’s error estimates, and their statistical interpretation, assuming they are accurate.; 6.5.1 Statistical interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, parabolic versus \(\mbox{MINOS}\) errors, the appropriate value for \(\mbox{up}\) (see [howto:errordef]), and setting of exact confidence levels, see (in order of increasing complexity and completeness):. “Interpretation of the Errors on Parameters”, see Part 3 of this write-up.; “Determining the Statistical Significance of Experimental Results”@bib-MIN81.; “Statistical Methods in Experimental Physics”@bib-EADIE. 6.5.2 The reliability of M error estimates; M always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a \(\mbox{MIGRAD}\) or ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:69290,Availability,error,error,69290,"the following sequence (where \(\mbox{xxx}\) is the expected physical value for parameter four):; MnMigrad migrad(...);; migrad.setValue(4, xxx);; migrad.fix(4);; FunctionMinimum min = migrad();; migrad.release(4);; MnScan scan(...);; std::vector<std::pair<double, double> > points = scan(4);; where \(\mbox{SCAN}\) gives you a picture of \(\mbox{FCN}\) as a function of parameter four alone, the others being fixed at their current best values. If you suspect the difficulty is due to parameter five, then add; MnContours contour(...);; std::vector<std::pair<double, double> > points = contour(4, 5);; to see a two-dimensional picture.; 6.5 Interpretation of parameter errors; There are two kinds of problems that can arise: The reliability of M ’s error estimates, and their statistical interpretation, assuming they are accurate.; 6.5.1 Statistical interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, parabolic versus \(\mbox{MINOS}\) errors, the appropriate value for \(\mbox{up}\) (see [howto:errordef]), and setting of exact confidence levels, see (in order of increasing complexity and completeness):. “Interpretation of the Errors on Parameters”, see Part 3 of this write-up.; “Determining the Statistical Significance of Experimental Results”@bib-MIN81.; “Statistical Methods in Experimental Physics”@bib-EADIE. 6.5.2 The reliability of M error estimates; M always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a \(\mbox{MIGRAD}\) or \(\mbox{HESSE}\) step, the errors are usually quite accurate, unless there has been a problem. If no mitigating adjective is given in the printout of the errors, then at least M believes the errors are accurate, although there is always a small chance that M has be",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:69338,Availability,error,errors,69338,"the following sequence (where \(\mbox{xxx}\) is the expected physical value for parameter four):; MnMigrad migrad(...);; migrad.setValue(4, xxx);; migrad.fix(4);; FunctionMinimum min = migrad();; migrad.release(4);; MnScan scan(...);; std::vector<std::pair<double, double> > points = scan(4);; where \(\mbox{SCAN}\) gives you a picture of \(\mbox{FCN}\) as a function of parameter four alone, the others being fixed at their current best values. If you suspect the difficulty is due to parameter five, then add; MnContours contour(...);; std::vector<std::pair<double, double> > points = contour(4, 5);; to see a two-dimensional picture.; 6.5 Interpretation of parameter errors; There are two kinds of problems that can arise: The reliability of M ’s error estimates, and their statistical interpretation, assuming they are accurate.; 6.5.1 Statistical interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, parabolic versus \(\mbox{MINOS}\) errors, the appropriate value for \(\mbox{up}\) (see [howto:errordef]), and setting of exact confidence levels, see (in order of increasing complexity and completeness):. “Interpretation of the Errors on Parameters”, see Part 3 of this write-up.; “Determining the Statistical Significance of Experimental Results”@bib-MIN81.; “Statistical Methods in Experimental Physics”@bib-EADIE. 6.5.2 The reliability of M error estimates; M always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a \(\mbox{MIGRAD}\) or \(\mbox{HESSE}\) step, the errors are usually quite accurate, unless there has been a problem. If no mitigating adjective is given in the printout of the errors, then at least M believes the errors are accurate, although there is always a small chance that M has be",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:69398,Availability,error,errordef,69398,"the following sequence (where \(\mbox{xxx}\) is the expected physical value for parameter four):; MnMigrad migrad(...);; migrad.setValue(4, xxx);; migrad.fix(4);; FunctionMinimum min = migrad();; migrad.release(4);; MnScan scan(...);; std::vector<std::pair<double, double> > points = scan(4);; where \(\mbox{SCAN}\) gives you a picture of \(\mbox{FCN}\) as a function of parameter four alone, the others being fixed at their current best values. If you suspect the difficulty is due to parameter five, then add; MnContours contour(...);; std::vector<std::pair<double, double> > points = contour(4, 5);; to see a two-dimensional picture.; 6.5 Interpretation of parameter errors; There are two kinds of problems that can arise: The reliability of M ’s error estimates, and their statistical interpretation, assuming they are accurate.; 6.5.1 Statistical interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, parabolic versus \(\mbox{MINOS}\) errors, the appropriate value for \(\mbox{up}\) (see [howto:errordef]), and setting of exact confidence levels, see (in order of increasing complexity and completeness):. “Interpretation of the Errors on Parameters”, see Part 3 of this write-up.; “Determining the Statistical Significance of Experimental Results”@bib-MIN81.; “Statistical Methods in Experimental Physics”@bib-EADIE. 6.5.2 The reliability of M error estimates; M always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a \(\mbox{MIGRAD}\) or \(\mbox{HESSE}\) step, the errors are usually quite accurate, unless there has been a problem. If no mitigating adjective is given in the printout of the errors, then at least M believes the errors are accurate, although there is always a small chance that M has be",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:69731,Availability,reliab,reliability,69731,"ameter five, then add; MnContours contour(...);; std::vector<std::pair<double, double> > points = contour(4, 5);; to see a two-dimensional picture.; 6.5 Interpretation of parameter errors; There are two kinds of problems that can arise: The reliability of M ’s error estimates, and their statistical interpretation, assuming they are accurate.; 6.5.1 Statistical interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, parabolic versus \(\mbox{MINOS}\) errors, the appropriate value for \(\mbox{up}\) (see [howto:errordef]), and setting of exact confidence levels, see (in order of increasing complexity and completeness):. “Interpretation of the Errors on Parameters”, see Part 3 of this write-up.; “Determining the Statistical Significance of Experimental Results”@bib-MIN81.; “Statistical Methods in Experimental Physics”@bib-EADIE. 6.5.2 The reliability of M error estimates; M always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a \(\mbox{MIGRAD}\) or \(\mbox{HESSE}\) step, the errors are usually quite accurate, unless there has been a problem. If no mitigating adjective is given in the printout of the errors, then at least M believes the errors are accurate, although there is always a small chance that M has been fooled. Some visible signs that M may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of \(\mbox{EDM}\) too big. For a “normal” minimization, after \(\mbox{MIGRAD}\), the value of \(\mbox{EDM}\) is usually more than three orders of magnitude smaller than \(\mbox{up}\), unless a looser tolerance has been specified.; Correlation coefficients exactly equal to zero, unless some parameters are known to be u",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:69748,Availability,error,error,69748,"ameter five, then add; MnContours contour(...);; std::vector<std::pair<double, double> > points = contour(4, 5);; to see a two-dimensional picture.; 6.5 Interpretation of parameter errors; There are two kinds of problems that can arise: The reliability of M ’s error estimates, and their statistical interpretation, assuming they are accurate.; 6.5.1 Statistical interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, parabolic versus \(\mbox{MINOS}\) errors, the appropriate value for \(\mbox{up}\) (see [howto:errordef]), and setting of exact confidence levels, see (in order of increasing complexity and completeness):. “Interpretation of the Errors on Parameters”, see Part 3 of this write-up.; “Determining the Statistical Significance of Experimental Results”@bib-MIN81.; “Statistical Methods in Experimental Physics”@bib-EADIE. 6.5.2 The reliability of M error estimates; M always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a \(\mbox{MIGRAD}\) or \(\mbox{HESSE}\) step, the errors are usually quite accurate, unless there has been a problem. If no mitigating adjective is given in the printout of the errors, then at least M believes the errors are accurate, although there is always a small chance that M has been fooled. Some visible signs that M may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of \(\mbox{EDM}\) too big. For a “normal” minimization, after \(\mbox{MIGRAD}\), the value of \(\mbox{EDM}\) is usually more than three orders of magnitude smaller than \(\mbox{up}\), unless a looser tolerance has been specified.; Correlation coefficients exactly equal to zero, unless some parameters are known to be u",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:69832,Availability,error,errors,69832,"ameter five, then add; MnContours contour(...);; std::vector<std::pair<double, double> > points = contour(4, 5);; to see a two-dimensional picture.; 6.5 Interpretation of parameter errors; There are two kinds of problems that can arise: The reliability of M ’s error estimates, and their statistical interpretation, assuming they are accurate.; 6.5.1 Statistical interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, parabolic versus \(\mbox{MINOS}\) errors, the appropriate value for \(\mbox{up}\) (see [howto:errordef]), and setting of exact confidence levels, see (in order of increasing complexity and completeness):. “Interpretation of the Errors on Parameters”, see Part 3 of this write-up.; “Determining the Statistical Significance of Experimental Results”@bib-MIN81.; “Statistical Methods in Experimental Physics”@bib-EADIE. 6.5.2 The reliability of M error estimates; M always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a \(\mbox{MIGRAD}\) or \(\mbox{HESSE}\) step, the errors are usually quite accurate, unless there has been a problem. If no mitigating adjective is given in the printout of the errors, then at least M believes the errors are accurate, although there is always a small chance that M has been fooled. Some visible signs that M may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of \(\mbox{EDM}\) too big. For a “normal” minimization, after \(\mbox{MIGRAD}\), the value of \(\mbox{EDM}\) is usually more than three orders of magnitude smaller than \(\mbox{up}\), unless a looser tolerance has been specified.; Correlation coefficients exactly equal to zero, unless some parameters are known to be u",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:70108,Availability,error,errors,70108,"nd their statistical interpretation, assuming they are accurate.; 6.5.1 Statistical interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, parabolic versus \(\mbox{MINOS}\) errors, the appropriate value for \(\mbox{up}\) (see [howto:errordef]), and setting of exact confidence levels, see (in order of increasing complexity and completeness):. “Interpretation of the Errors on Parameters”, see Part 3 of this write-up.; “Determining the Statistical Significance of Experimental Results”@bib-MIN81.; “Statistical Methods in Experimental Physics”@bib-EADIE. 6.5.2 The reliability of M error estimates; M always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a \(\mbox{MIGRAD}\) or \(\mbox{HESSE}\) step, the errors are usually quite accurate, unless there has been a problem. If no mitigating adjective is given in the printout of the errors, then at least M believes the errors are accurate, although there is always a small chance that M has been fooled. Some visible signs that M may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of \(\mbox{EDM}\) too big. For a “normal” minimization, after \(\mbox{MIGRAD}\), the value of \(\mbox{EDM}\) is usually more than three orders of magnitude smaller than \(\mbox{up}\), unless a looser tolerance has been specified.; Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one which has been badly parametrized so that individual errors are not very meaningful because they are so highly correlat",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:70235,Availability,error,errors,70235,"g of the elements of the error matrix, parabolic versus \(\mbox{MINOS}\) errors, the appropriate value for \(\mbox{up}\) (see [howto:errordef]), and setting of exact confidence levels, see (in order of increasing complexity and completeness):. “Interpretation of the Errors on Parameters”, see Part 3 of this write-up.; “Determining the Statistical Significance of Experimental Results”@bib-MIN81.; “Statistical Methods in Experimental Physics”@bib-EADIE. 6.5.2 The reliability of M error estimates; M always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a \(\mbox{MIGRAD}\) or \(\mbox{HESSE}\) step, the errors are usually quite accurate, unless there has been a problem. If no mitigating adjective is given in the printout of the errors, then at least M believes the errors are accurate, although there is always a small chance that M has been fooled. Some visible signs that M may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of \(\mbox{EDM}\) too big. For a “normal” minimization, after \(\mbox{MIGRAD}\), the value of \(\mbox{EDM}\) is usually more than three orders of magnitude smaller than \(\mbox{up}\), unless a looser tolerance has been specified.; Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one which has been badly parametrized so that individual errors are not very meaningful because they are so highly correlated.; Parameter at limit. This condition, signalled by a M warning message, may make both the function minimum and parameter errors unreliable. See sectio",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:70272,Availability,error,errors,70272,"g of the elements of the error matrix, parabolic versus \(\mbox{MINOS}\) errors, the appropriate value for \(\mbox{up}\) (see [howto:errordef]), and setting of exact confidence levels, see (in order of increasing complexity and completeness):. “Interpretation of the Errors on Parameters”, see Part 3 of this write-up.; “Determining the Statistical Significance of Experimental Results”@bib-MIN81.; “Statistical Methods in Experimental Physics”@bib-EADIE. 6.5.2 The reliability of M error estimates; M always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a \(\mbox{MIGRAD}\) or \(\mbox{HESSE}\) step, the errors are usually quite accurate, unless there has been a problem. If no mitigating adjective is given in the printout of the errors, then at least M believes the errors are accurate, although there is always a small chance that M has been fooled. Some visible signs that M may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of \(\mbox{EDM}\) too big. For a “normal” minimization, after \(\mbox{MIGRAD}\), the value of \(\mbox{EDM}\) is usually more than three orders of magnitude smaller than \(\mbox{up}\), unless a looser tolerance has been specified.; Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one which has been badly parametrized so that individual errors are not very meaningful because they are so highly correlated.; Parameter at limit. This condition, signalled by a M warning message, may make both the function minimum and parameter errors unreliable. See sectio",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:70463,Availability,error,error,70463,"evels, see (in order of increasing complexity and completeness):. “Interpretation of the Errors on Parameters”, see Part 3 of this write-up.; “Determining the Statistical Significance of Experimental Results”@bib-MIN81.; “Statistical Methods in Experimental Physics”@bib-EADIE. 6.5.2 The reliability of M error estimates; M always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a \(\mbox{MIGRAD}\) or \(\mbox{HESSE}\) step, the errors are usually quite accurate, unless there has been a problem. If no mitigating adjective is given in the printout of the errors, then at least M believes the errors are accurate, although there is always a small chance that M has been fooled. Some visible signs that M may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of \(\mbox{EDM}\) too big. For a “normal” minimization, after \(\mbox{MIGRAD}\), the value of \(\mbox{EDM}\) is usually more than three orders of magnitude smaller than \(\mbox{up}\), unless a looser tolerance has been specified.; Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one which has been badly parametrized so that individual errors are not very meaningful because they are so highly correlated.; Parameter at limit. This condition, signalled by a M warning message, may make both the function minimum and parameter errors unreliable. See section [answer:right-errors], Getting the right parameter errors with limits. The best way to be absolutely sure of the errors, is to use “independent” calculations and compare them, ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:70716,Availability,toler,tolerance,70716,"Results”@bib-MIN81.; “Statistical Methods in Experimental Physics”@bib-EADIE. 6.5.2 The reliability of M error estimates; M always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a \(\mbox{MIGRAD}\) or \(\mbox{HESSE}\) step, the errors are usually quite accurate, unless there has been a problem. If no mitigating adjective is given in the printout of the errors, then at least M believes the errors are accurate, although there is always a small chance that M has been fooled. Some visible signs that M may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of \(\mbox{EDM}\) too big. For a “normal” minimization, after \(\mbox{MIGRAD}\), the value of \(\mbox{EDM}\) is usually more than three orders of magnitude smaller than \(\mbox{up}\), unless a looser tolerance has been specified.; Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one which has been badly parametrized so that individual errors are not very meaningful because they are so highly correlated.; Parameter at limit. This condition, signalled by a M warning message, may make both the function minimum and parameter errors unreliable. See section [answer:right-errors], Getting the right parameter errors with limits. The best way to be absolutely sure of the errors, is to use “independent” calculations and compare them, or compare the calculated errors with a picture of the function if possible. For example, if there is only one free parameter, \(\mbox{SCAN}\) allows the user to verify approximately the function curv",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:71047,Availability,error,errors,71047,"zes as specified by the user. After a \(\mbox{MIGRAD}\) or \(\mbox{HESSE}\) step, the errors are usually quite accurate, unless there has been a problem. If no mitigating adjective is given in the printout of the errors, then at least M believes the errors are accurate, although there is always a small chance that M has been fooled. Some visible signs that M may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of \(\mbox{EDM}\) too big. For a “normal” minimization, after \(\mbox{MIGRAD}\), the value of \(\mbox{EDM}\) is usually more than three orders of magnitude smaller than \(\mbox{up}\), unless a looser tolerance has been specified.; Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one which has been badly parametrized so that individual errors are not very meaningful because they are so highly correlated.; Parameter at limit. This condition, signalled by a M warning message, may make both the function minimum and parameter errors unreliable. See section [answer:right-errors], Getting the right parameter errors with limits. The best way to be absolutely sure of the errors, is to use “independent” calculations and compare them, or compare the calculated errors with a picture of the function if possible. For example, if there is only one free parameter, \(\mbox{SCAN}\) allows the user to verify approximately the function curvature. Similarly, if there are only two free parameters, use \(\mbox{CONTOURS}\). To verify a full error matrix, compare the results of \(\mbox{MIGRAD}\) with those (calculated afterward) by \(\mbox{HESSE}\), which uses a different method. And of course the most reliable and most expensive technique, which must be used if asymmetric errors are required, is \(\mbox{MINOS}\).; ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:71237,Availability,error,errors,71237,"ective is given in the printout of the errors, then at least M believes the errors are accurate, although there is always a small chance that M has been fooled. Some visible signs that M may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of \(\mbox{EDM}\) too big. For a “normal” minimization, after \(\mbox{MIGRAD}\), the value of \(\mbox{EDM}\) is usually more than three orders of magnitude smaller than \(\mbox{up}\), unless a looser tolerance has been specified.; Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one which has been badly parametrized so that individual errors are not very meaningful because they are so highly correlated.; Parameter at limit. This condition, signalled by a M warning message, may make both the function minimum and parameter errors unreliable. See section [answer:right-errors], Getting the right parameter errors with limits. The best way to be absolutely sure of the errors, is to use “independent” calculations and compare them, or compare the calculated errors with a picture of the function if possible. For example, if there is only one free parameter, \(\mbox{SCAN}\) allows the user to verify approximately the function curvature. Similarly, if there are only two free parameters, use \(\mbox{CONTOURS}\). To verify a full error matrix, compare the results of \(\mbox{MIGRAD}\) with those (calculated afterward) by \(\mbox{HESSE}\), which uses a different method. And of course the most reliable and most expensive technique, which must be used if asymmetric errors are required, is \(\mbox{MINOS}\).; 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; \(\mbox{MIGRAD}\) uses its current estimate of the covariance matrix of the function to determine the current",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:71282,Availability,error,errors,71282,"hough there is always a small chance that M has been fooled. Some visible signs that M may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of \(\mbox{EDM}\) too big. For a “normal” minimization, after \(\mbox{MIGRAD}\), the value of \(\mbox{EDM}\) is usually more than three orders of magnitude smaller than \(\mbox{up}\), unless a looser tolerance has been specified.; Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one which has been badly parametrized so that individual errors are not very meaningful because they are so highly correlated.; Parameter at limit. This condition, signalled by a M warning message, may make both the function minimum and parameter errors unreliable. See section [answer:right-errors], Getting the right parameter errors with limits. The best way to be absolutely sure of the errors, is to use “independent” calculations and compare them, or compare the calculated errors with a picture of the function if possible. For example, if there is only one free parameter, \(\mbox{SCAN}\) allows the user to verify approximately the function curvature. Similarly, if there are only two free parameters, use \(\mbox{CONTOURS}\). To verify a full error matrix, compare the results of \(\mbox{MIGRAD}\) with those (calculated afterward) by \(\mbox{HESSE}\), which uses a different method. And of course the most reliable and most expensive technique, which must be used if asymmetric errors are required, is \(\mbox{MINOS}\).; 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; \(\mbox{MIGRAD}\) uses its current estimate of the covariance matrix of the function to determine the current search direction, since this is the optimal strategy for quadratic functions and “physical” function",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:71319,Availability,error,errors,71319,"hough there is always a small chance that M has been fooled. Some visible signs that M may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of \(\mbox{EDM}\) too big. For a “normal” minimization, after \(\mbox{MIGRAD}\), the value of \(\mbox{EDM}\) is usually more than three orders of magnitude smaller than \(\mbox{up}\), unless a looser tolerance has been specified.; Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one which has been badly parametrized so that individual errors are not very meaningful because they are so highly correlated.; Parameter at limit. This condition, signalled by a M warning message, may make both the function minimum and parameter errors unreliable. See section [answer:right-errors], Getting the right parameter errors with limits. The best way to be absolutely sure of the errors, is to use “independent” calculations and compare them, or compare the calculated errors with a picture of the function if possible. For example, if there is only one free parameter, \(\mbox{SCAN}\) allows the user to verify approximately the function curvature. Similarly, if there are only two free parameters, use \(\mbox{CONTOURS}\). To verify a full error matrix, compare the results of \(\mbox{MIGRAD}\) with those (calculated afterward) by \(\mbox{HESSE}\), which uses a different method. And of course the most reliable and most expensive technique, which must be used if asymmetric errors are required, is \(\mbox{MINOS}\).; 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; \(\mbox{MIGRAD}\) uses its current estimate of the covariance matrix of the function to determine the current search direction, since this is the optimal strategy for quadratic functions and “physical” function",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:71381,Availability,error,errors,71381,"oduced during the minimization or error analysis.; Failure to find new minimum.; Value of \(\mbox{EDM}\) too big. For a “normal” minimization, after \(\mbox{MIGRAD}\), the value of \(\mbox{EDM}\) is usually more than three orders of magnitude smaller than \(\mbox{up}\), unless a looser tolerance has been specified.; Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one which has been badly parametrized so that individual errors are not very meaningful because they are so highly correlated.; Parameter at limit. This condition, signalled by a M warning message, may make both the function minimum and parameter errors unreliable. See section [answer:right-errors], Getting the right parameter errors with limits. The best way to be absolutely sure of the errors, is to use “independent” calculations and compare them, or compare the calculated errors with a picture of the function if possible. For example, if there is only one free parameter, \(\mbox{SCAN}\) allows the user to verify approximately the function curvature. Similarly, if there are only two free parameters, use \(\mbox{CONTOURS}\). To verify a full error matrix, compare the results of \(\mbox{MIGRAD}\) with those (calculated afterward) by \(\mbox{HESSE}\), which uses a different method. And of course the most reliable and most expensive technique, which must be used if asymmetric errors are required, is \(\mbox{MINOS}\).; 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; \(\mbox{MIGRAD}\) uses its current estimate of the covariance matrix of the function to determine the current search direction, since this is the optimal strategy for quadratic functions and “physical” functions should be quadratic in the neighbourhood of the minimum at least. The search directions determined by \(\mbox{MIGRAD}\) are guaran",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:71470,Availability,error,errors,71470,"oduced during the minimization or error analysis.; Failure to find new minimum.; Value of \(\mbox{EDM}\) too big. For a “normal” minimization, after \(\mbox{MIGRAD}\), the value of \(\mbox{EDM}\) is usually more than three orders of magnitude smaller than \(\mbox{up}\), unless a looser tolerance has been specified.; Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one which has been badly parametrized so that individual errors are not very meaningful because they are so highly correlated.; Parameter at limit. This condition, signalled by a M warning message, may make both the function minimum and parameter errors unreliable. See section [answer:right-errors], Getting the right parameter errors with limits. The best way to be absolutely sure of the errors, is to use “independent” calculations and compare them, or compare the calculated errors with a picture of the function if possible. For example, if there is only one free parameter, \(\mbox{SCAN}\) allows the user to verify approximately the function curvature. Similarly, if there are only two free parameters, use \(\mbox{CONTOURS}\). To verify a full error matrix, compare the results of \(\mbox{MIGRAD}\) with those (calculated afterward) by \(\mbox{HESSE}\), which uses a different method. And of course the most reliable and most expensive technique, which must be used if asymmetric errors are required, is \(\mbox{MINOS}\).; 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; \(\mbox{MIGRAD}\) uses its current estimate of the covariance matrix of the function to determine the current search direction, since this is the optimal strategy for quadratic functions and “physical” functions should be quadratic in the neighbourhood of the minimum at least. The search directions determined by \(\mbox{MIGRAD}\) are guaran",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:71743,Availability,error,error,71743,"me parameters are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one which has been badly parametrized so that individual errors are not very meaningful because they are so highly correlated.; Parameter at limit. This condition, signalled by a M warning message, may make both the function minimum and parameter errors unreliable. See section [answer:right-errors], Getting the right parameter errors with limits. The best way to be absolutely sure of the errors, is to use “independent” calculations and compare them, or compare the calculated errors with a picture of the function if possible. For example, if there is only one free parameter, \(\mbox{SCAN}\) allows the user to verify approximately the function curvature. Similarly, if there are only two free parameters, use \(\mbox{CONTOURS}\). To verify a full error matrix, compare the results of \(\mbox{MIGRAD}\) with those (calculated afterward) by \(\mbox{HESSE}\), which uses a different method. And of course the most reliable and most expensive technique, which must be used if asymmetric errors are required, is \(\mbox{MINOS}\).; 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; \(\mbox{MIGRAD}\) uses its current estimate of the covariance matrix of the function to determine the current search direction, since this is the optimal strategy for quadratic functions and “physical” functions should be quadratic in the neighbourhood of the minimum at least. The search directions determined by \(\mbox{MIGRAD}\) are guaranteed to be downhill only if the covariance matrix is positive–definite, so in case this is not true, it makes a positive–definite approximation by adding an appropriate constant along the diagonal as determined by the eigenvalues of the matrix. Theoretically, the covariance matrix for a “physical” function must be positive–definite at the minimum, although it may not be so",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:71907,Availability,reliab,reliable,71907,"n exceptionally difficult problem, and one which has been badly parametrized so that individual errors are not very meaningful because they are so highly correlated.; Parameter at limit. This condition, signalled by a M warning message, may make both the function minimum and parameter errors unreliable. See section [answer:right-errors], Getting the right parameter errors with limits. The best way to be absolutely sure of the errors, is to use “independent” calculations and compare them, or compare the calculated errors with a picture of the function if possible. For example, if there is only one free parameter, \(\mbox{SCAN}\) allows the user to verify approximately the function curvature. Similarly, if there are only two free parameters, use \(\mbox{CONTOURS}\). To verify a full error matrix, compare the results of \(\mbox{MIGRAD}\) with those (calculated afterward) by \(\mbox{HESSE}\), which uses a different method. And of course the most reliable and most expensive technique, which must be used if asymmetric errors are required, is \(\mbox{MINOS}\).; 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; \(\mbox{MIGRAD}\) uses its current estimate of the covariance matrix of the function to determine the current search direction, since this is the optimal strategy for quadratic functions and “physical” functions should be quadratic in the neighbourhood of the minimum at least. The search directions determined by \(\mbox{MIGRAD}\) are guaranteed to be downhill only if the covariance matrix is positive–definite, so in case this is not true, it makes a positive–definite approximation by adding an appropriate constant along the diagonal as determined by the eigenvalues of the matrix. Theoretically, the covariance matrix for a “physical” function must be positive–definite at the minimum, although it may not be so for all points far away from the minimum, even for a well–determined physical problem. Therefore, if \(\mbox{MIGRAD}\) reports that it has found a ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:71979,Availability,error,errors,71979,"n exceptionally difficult problem, and one which has been badly parametrized so that individual errors are not very meaningful because they are so highly correlated.; Parameter at limit. This condition, signalled by a M warning message, may make both the function minimum and parameter errors unreliable. See section [answer:right-errors], Getting the right parameter errors with limits. The best way to be absolutely sure of the errors, is to use “independent” calculations and compare them, or compare the calculated errors with a picture of the function if possible. For example, if there is only one free parameter, \(\mbox{SCAN}\) allows the user to verify approximately the function curvature. Similarly, if there are only two free parameters, use \(\mbox{CONTOURS}\). To verify a full error matrix, compare the results of \(\mbox{MIGRAD}\) with those (calculated afterward) by \(\mbox{HESSE}\), which uses a different method. And of course the most reliable and most expensive technique, which must be used if asymmetric errors are required, is \(\mbox{MINOS}\).; 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; \(\mbox{MIGRAD}\) uses its current estimate of the covariance matrix of the function to determine the current search direction, since this is the optimal strategy for quadratic functions and “physical” functions should be quadratic in the neighbourhood of the minimum at least. The search directions determined by \(\mbox{MIGRAD}\) are guaranteed to be downhill only if the covariance matrix is positive–definite, so in case this is not true, it makes a positive–definite approximation by adding an appropriate constant along the diagonal as determined by the eigenvalues of the matrix. Theoretically, the covariance matrix for a “physical” function must be positive–definite at the minimum, although it may not be so for all points far away from the minimum, even for a well–determined physical problem. Therefore, if \(\mbox{MIGRAD}\) reports that it has found a ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:72440,Availability,down,downhill,72440,"e. For example, if there is only one free parameter, \(\mbox{SCAN}\) allows the user to verify approximately the function curvature. Similarly, if there are only two free parameters, use \(\mbox{CONTOURS}\). To verify a full error matrix, compare the results of \(\mbox{MIGRAD}\) with those (calculated afterward) by \(\mbox{HESSE}\), which uses a different method. And of course the most reliable and most expensive technique, which must be used if asymmetric errors are required, is \(\mbox{MINOS}\).; 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; \(\mbox{MIGRAD}\) uses its current estimate of the covariance matrix of the function to determine the current search direction, since this is the optimal strategy for quadratic functions and “physical” functions should be quadratic in the neighbourhood of the minimum at least. The search directions determined by \(\mbox{MIGRAD}\) are guaranteed to be downhill only if the covariance matrix is positive–definite, so in case this is not true, it makes a positive–definite approximation by adding an appropriate constant along the diagonal as determined by the eigenvalues of the matrix. Theoretically, the covariance matrix for a “physical” function must be positive–definite at the minimum, although it may not be so for all points far away from the minimum, even for a well–determined physical problem. Therefore, if \(\mbox{MIGRAD}\) reports that it has found a non-positive–definite covariance matrix, this may be a sign of one or more of the following:. A non–physical region. On its way to the minimum, \(\mbox{MIGRAD}\) may have traversed a region which has unphysical behaviour, which is of course not a serious problem as long as it recovers and leaves such a region.; An underdetermined problem. If the matrix is not positive–definite even at the minimum, this may mean that the solution is not well–defined, for example that there are more unknowns than there are data points, or that the parametrization of the fit conta",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:73229,Availability,recover,recovers,73229,"nction to determine the current search direction, since this is the optimal strategy for quadratic functions and “physical” functions should be quadratic in the neighbourhood of the minimum at least. The search directions determined by \(\mbox{MIGRAD}\) are guaranteed to be downhill only if the covariance matrix is positive–definite, so in case this is not true, it makes a positive–definite approximation by adding an appropriate constant along the diagonal as determined by the eigenvalues of the matrix. Theoretically, the covariance matrix for a “physical” function must be positive–definite at the minimum, although it may not be so for all points far away from the minimum, even for a well–determined physical problem. Therefore, if \(\mbox{MIGRAD}\) reports that it has found a non-positive–definite covariance matrix, this may be a sign of one or more of the following:. A non–physical region. On its way to the minimum, \(\mbox{MIGRAD}\) may have traversed a region which has unphysical behaviour, which is of course not a serious problem as long as it recovers and leaves such a region.; An underdetermined problem. If the matrix is not positive–definite even at the minimum, this may mean that the solution is not well–defined, for example that there are more unknowns than there are data points, or that the parametrization of the fit contains a linear dependence. If this is the case, then M (or any other program) cannot solve your problem uniquely, and the error matrix will necessarily be largely meaningless, so the user must remove the under-determinedness by reformulating the parametrization. M cannot do this itself, but it can provide some hints (contours, global correlation coefficients, eigenvalues) which can help the clever user to find out what is wrong.; Numerical inaccuracies. It is possible that the apparent lack of positive–definiteness is in fact only due to excessive roundoff errors in numerical calculations, either in \(\mbox{FCN}\) or in M . This is unlikely ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:73639,Availability,error,error,73639," the matrix. Theoretically, the covariance matrix for a “physical” function must be positive–definite at the minimum, although it may not be so for all points far away from the minimum, even for a well–determined physical problem. Therefore, if \(\mbox{MIGRAD}\) reports that it has found a non-positive–definite covariance matrix, this may be a sign of one or more of the following:. A non–physical region. On its way to the minimum, \(\mbox{MIGRAD}\) may have traversed a region which has unphysical behaviour, which is of course not a serious problem as long as it recovers and leaves such a region.; An underdetermined problem. If the matrix is not positive–definite even at the minimum, this may mean that the solution is not well–defined, for example that there are more unknowns than there are data points, or that the parametrization of the fit contains a linear dependence. If this is the case, then M (or any other program) cannot solve your problem uniquely, and the error matrix will necessarily be largely meaningless, so the user must remove the under-determinedness by reformulating the parametrization. M cannot do this itself, but it can provide some hints (contours, global correlation coefficients, eigenvalues) which can help the clever user to find out what is wrong.; Numerical inaccuracies. It is possible that the apparent lack of positive–definiteness is in fact only due to excessive roundoff errors in numerical calculations, either in \(\mbox{FCN}\) or in M . This is unlikely in general, but becomes more likely if the number of free parameters is very large, or if the parameters are badly scaled (not all of the same order of magnitude), and correlations are also large. In any case, whether the non–positive–definiteness is real or only numerical is largely irrelevant, since in both cases the error matrix will be unreliable and the minimum suspicious. 6.7 Additional trouble–shooting; When M just doesn’t work, some of the more common causes are:. Precision mismatch",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:74080,Availability,error,errors,74080,"region. On its way to the minimum, \(\mbox{MIGRAD}\) may have traversed a region which has unphysical behaviour, which is of course not a serious problem as long as it recovers and leaves such a region.; An underdetermined problem. If the matrix is not positive–definite even at the minimum, this may mean that the solution is not well–defined, for example that there are more unknowns than there are data points, or that the parametrization of the fit contains a linear dependence. If this is the case, then M (or any other program) cannot solve your problem uniquely, and the error matrix will necessarily be largely meaningless, so the user must remove the under-determinedness by reformulating the parametrization. M cannot do this itself, but it can provide some hints (contours, global correlation coefficients, eigenvalues) which can help the clever user to find out what is wrong.; Numerical inaccuracies. It is possible that the apparent lack of positive–definiteness is in fact only due to excessive roundoff errors in numerical calculations, either in \(\mbox{FCN}\) or in M . This is unlikely in general, but becomes more likely if the number of free parameters is very large, or if the parameters are badly scaled (not all of the same order of magnitude), and correlations are also large. In any case, whether the non–positive–definiteness is real or only numerical is largely irrelevant, since in both cases the error matrix will be unreliable and the minimum suspicious. 6.7 Additional trouble–shooting; When M just doesn’t work, some of the more common causes are:. Precision mismatch. Make sure your \(\mbox{FCN}\) uses internally the same precision as M .; If the problem is only one of precision, and not of word length mismatch, an appropriate MnMachinePrecision::setPrecision() may fix it.; Trivial bugs in \(\mbox{FCN}\). The possibilities for bugs are numerous. Probably the most common among physicists inexperienced in is the confusion between double and int types, which you",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:74487,Availability,error,error,74487,"ere are data points, or that the parametrization of the fit contains a linear dependence. If this is the case, then M (or any other program) cannot solve your problem uniquely, and the error matrix will necessarily be largely meaningless, so the user must remove the under-determinedness by reformulating the parametrization. M cannot do this itself, but it can provide some hints (contours, global correlation coefficients, eigenvalues) which can help the clever user to find out what is wrong.; Numerical inaccuracies. It is possible that the apparent lack of positive–definiteness is in fact only due to excessive roundoff errors in numerical calculations, either in \(\mbox{FCN}\) or in M . This is unlikely in general, but becomes more likely if the number of free parameters is very large, or if the parameters are badly scaled (not all of the same order of magnitude), and correlations are also large. In any case, whether the non–positive–definiteness is real or only numerical is largely irrelevant, since in both cases the error matrix will be unreliable and the minimum suspicious. 6.7 Additional trouble–shooting; When M just doesn’t work, some of the more common causes are:. Precision mismatch. Make sure your \(\mbox{FCN}\) uses internally the same precision as M .; If the problem is only one of precision, and not of word length mismatch, an appropriate MnMachinePrecision::setPrecision() may fix it.; Trivial bugs in \(\mbox{FCN}\). The possibilities for bugs are numerous. Probably the most common among physicists inexperienced in is the confusion between double and int types, which you can sometimes get away with, but not always. 3 M can spot some trivial bugs itself, and issues a warning when it detects an unusual \(\mbox{FCN}\) behaviour. Such a warning should be taken seriously.; M also offers some tools (especially \(\mbox{SCAN}\)) which can help the user to find trivial bugs.; An ill–posed problem. For questions of parameter dependence, see the discussion above on p",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:82070,Availability,error,error,82070,"n+0.01);. // ... or access parameter by index; upar.setLimits(1, rms-0.1, rms+0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // fix a parameter...; migrad.fix(""mean"");. // ... and minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;. // release a parameter...; migrad.release(""mean"");. // ... and fix another one; migrad.fix(1);. // and minimize again; FunctionMinimum min1 = migrad();. // output; std::cout<<""minimum1: ""<<min1<<std::endl;. // release the parameter...; migrad.release(1);. // ... and minimize with all three parameters; // (still with limits!); FunctionMinimum min2 = migrad();. // output; std::cout<<""minimum2: ""<<min2<<std::endl;. // remove all limits on parameters...; migrad.removeLimits(""mean"");; migrad.removeLimits(""sigma"");. // ... and minimize again with all three parameters; // (now without limits!); FunctionMinimum min3 = migrad();. // output; std::cout<<""minimum3: ""<<min3<<std::endl;; }. {; // demonstrate MINOS error analysis. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create MINOS error factory; MnMinos minos(theFCN, min);. {; // 1-sigma MINOS errors; std::pair<double,double> e0 = minos(0);; std::pair<double,double> e1 = minos(1);; std::pair<double,double> e2 = minos(2);. // output; std::cout<<""1-sigma minos errors: ""<<std::endl;; std::cout<<""par0: ""; <<min.userState().value(""mean"")<<"" ""; <<e0.first<<"" ""<<e0.second<<std::endl;; std::cout<<""par1: ""; <<min.userState().value(1)<<"" ""; <<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""<<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""; <<e2.second<<std::endl;; }. {; // 2-sigma MINOS errors; theFCN.setErrorDef(4.);; std::pair<double,double> e0 = minos(0);; std::pair<double,double> e1 = minos(1);; std::pair<double,d",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:82362,Availability,error,error,82362,"rameter...; migrad.release(""mean"");. // ... and fix another one; migrad.fix(1);. // and minimize again; FunctionMinimum min1 = migrad();. // output; std::cout<<""minimum1: ""<<min1<<std::endl;. // release the parameter...; migrad.release(1);. // ... and minimize with all three parameters; // (still with limits!); FunctionMinimum min2 = migrad();. // output; std::cout<<""minimum2: ""<<min2<<std::endl;. // remove all limits on parameters...; migrad.removeLimits(""mean"");; migrad.removeLimits(""sigma"");. // ... and minimize again with all three parameters; // (now without limits!); FunctionMinimum min3 = migrad();. // output; std::cout<<""minimum3: ""<<min3<<std::endl;; }. {; // demonstrate MINOS error analysis. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create MINOS error factory; MnMinos minos(theFCN, min);. {; // 1-sigma MINOS errors; std::pair<double,double> e0 = minos(0);; std::pair<double,double> e1 = minos(1);; std::pair<double,double> e2 = minos(2);. // output; std::cout<<""1-sigma minos errors: ""<<std::endl;; std::cout<<""par0: ""; <<min.userState().value(""mean"")<<"" ""; <<e0.first<<"" ""<<e0.second<<std::endl;; std::cout<<""par1: ""; <<min.userState().value(1)<<"" ""; <<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""<<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""; <<e2.second<<std::endl;; }. {; // 2-sigma MINOS errors; theFCN.setErrorDef(4.);; std::pair<double,double> e0 = minos(0);; std::pair<double,double> e1 = minos(1);; std::pair<double,double> e2 = minos(2);. // output; std::cout<<""2-sigma minos errors: ""<<std::endl;; std::cout<<""par0: ""; <<min.userState().value(""mean""); <<"" ""<<e0.first<<"" ""<<e0.second<<std::endl;; std::cout<<""par1: ""; <<min.userState().value(1); <<"" ""<<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""; <<min.userSta",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:82426,Availability,error,errors,82426,"unctionMinimum min1 = migrad();. // output; std::cout<<""minimum1: ""<<min1<<std::endl;. // release the parameter...; migrad.release(1);. // ... and minimize with all three parameters; // (still with limits!); FunctionMinimum min2 = migrad();. // output; std::cout<<""minimum2: ""<<min2<<std::endl;. // remove all limits on parameters...; migrad.removeLimits(""mean"");; migrad.removeLimits(""sigma"");. // ... and minimize again with all three parameters; // (now without limits!); FunctionMinimum min3 = migrad();. // output; std::cout<<""minimum3: ""<<min3<<std::endl;; }. {; // demonstrate MINOS error analysis. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create MINOS error factory; MnMinos minos(theFCN, min);. {; // 1-sigma MINOS errors; std::pair<double,double> e0 = minos(0);; std::pair<double,double> e1 = minos(1);; std::pair<double,double> e2 = minos(2);. // output; std::cout<<""1-sigma minos errors: ""<<std::endl;; std::cout<<""par0: ""; <<min.userState().value(""mean"")<<"" ""; <<e0.first<<"" ""<<e0.second<<std::endl;; std::cout<<""par1: ""; <<min.userState().value(1)<<"" ""; <<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""<<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""; <<e2.second<<std::endl;; }. {; // 2-sigma MINOS errors; theFCN.setErrorDef(4.);; std::pair<double,double> e0 = minos(0);; std::pair<double,double> e1 = minos(1);; std::pair<double,double> e2 = minos(2);. // output; std::cout<<""2-sigma minos errors: ""<<std::endl;; std::cout<<""par0: ""; <<min.userState().value(""mean""); <<"" ""<<e0.first<<"" ""<<e0.second<<std::endl;; std::cout<<""par1: ""; <<min.userState().value(1); <<"" ""<<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""; <<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""<<e2.second<<std::endl;; }; }. {; // demonstrate how to use the CO",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:82594,Availability,error,errors,82594,"ad.release(1);. // ... and minimize with all three parameters; // (still with limits!); FunctionMinimum min2 = migrad();. // output; std::cout<<""minimum2: ""<<min2<<std::endl;. // remove all limits on parameters...; migrad.removeLimits(""mean"");; migrad.removeLimits(""sigma"");. // ... and minimize again with all three parameters; // (now without limits!); FunctionMinimum min3 = migrad();. // output; std::cout<<""minimum3: ""<<min3<<std::endl;; }. {; // demonstrate MINOS error analysis. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create MINOS error factory; MnMinos minos(theFCN, min);. {; // 1-sigma MINOS errors; std::pair<double,double> e0 = minos(0);; std::pair<double,double> e1 = minos(1);; std::pair<double,double> e2 = minos(2);. // output; std::cout<<""1-sigma minos errors: ""<<std::endl;; std::cout<<""par0: ""; <<min.userState().value(""mean"")<<"" ""; <<e0.first<<"" ""<<e0.second<<std::endl;; std::cout<<""par1: ""; <<min.userState().value(1)<<"" ""; <<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""<<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""; <<e2.second<<std::endl;; }. {; // 2-sigma MINOS errors; theFCN.setErrorDef(4.);; std::pair<double,double> e0 = minos(0);; std::pair<double,double> e1 = minos(1);; std::pair<double,double> e2 = minos(2);. // output; std::cout<<""2-sigma minos errors: ""<<std::endl;; std::cout<<""par0: ""; <<min.userState().value(""mean""); <<"" ""<<e0.first<<"" ""<<e0.second<<std::endl;; std::cout<<""par1: ""; <<min.userState().value(1); <<"" ""<<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""; <<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""<<e2.second<<std::endl;; }; }. {; // demonstrate how to use the CONTOURs. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"",",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:82932,Availability,error,errors,82932,"// (now without limits!); FunctionMinimum min3 = migrad();. // output; std::cout<<""minimum3: ""<<min3<<std::endl;; }. {; // demonstrate MINOS error analysis. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create MINOS error factory; MnMinos minos(theFCN, min);. {; // 1-sigma MINOS errors; std::pair<double,double> e0 = minos(0);; std::pair<double,double> e1 = minos(1);; std::pair<double,double> e2 = minos(2);. // output; std::cout<<""1-sigma minos errors: ""<<std::endl;; std::cout<<""par0: ""; <<min.userState().value(""mean"")<<"" ""; <<e0.first<<"" ""<<e0.second<<std::endl;; std::cout<<""par1: ""; <<min.userState().value(1)<<"" ""; <<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""<<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""; <<e2.second<<std::endl;; }. {; // 2-sigma MINOS errors; theFCN.setErrorDef(4.);; std::pair<double,double> e0 = minos(0);; std::pair<double,double> e1 = minos(1);; std::pair<double,double> e2 = minos(2);. // output; std::cout<<""2-sigma minos errors: ""<<std::endl;; std::cout<<""par0: ""; <<min.userState().value(""mean""); <<"" ""<<e0.first<<"" ""<<e0.second<<std::endl;; std::cout<<""par1: ""; <<min.userState().value(1); <<"" ""<<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""; <<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""<<e2.second<<std::endl;; }; }. {; // demonstrate how to use the CONTOURs. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create contours factory with FCN and minimum; MnContours contours(theFCN, min);. // 70% confidence level for 2 parameters contour; // around the minimum; theFCN.setErrorDef(2.41",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:83125,Availability,error,errors,83125,"rParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create MINOS error factory; MnMinos minos(theFCN, min);. {; // 1-sigma MINOS errors; std::pair<double,double> e0 = minos(0);; std::pair<double,double> e1 = minos(1);; std::pair<double,double> e2 = minos(2);. // output; std::cout<<""1-sigma minos errors: ""<<std::endl;; std::cout<<""par0: ""; <<min.userState().value(""mean"")<<"" ""; <<e0.first<<"" ""<<e0.second<<std::endl;; std::cout<<""par1: ""; <<min.userState().value(1)<<"" ""; <<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""<<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""; <<e2.second<<std::endl;; }. {; // 2-sigma MINOS errors; theFCN.setErrorDef(4.);; std::pair<double,double> e0 = minos(0);; std::pair<double,double> e1 = minos(1);; std::pair<double,double> e2 = minos(2);. // output; std::cout<<""2-sigma minos errors: ""<<std::endl;; std::cout<<""par0: ""; <<min.userState().value(""mean""); <<"" ""<<e0.first<<"" ""<<e0.second<<std::endl;; std::cout<<""par1: ""; <<min.userState().value(1); <<"" ""<<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""; <<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""<<e2.second<<std::endl;; }; }. {; // demonstrate how to use the CONTOURs. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create contours factory with FCN and minimum; MnContours contours(theFCN, min);. // 70% confidence level for 2 parameters contour; // around the minimum; theFCN.setErrorDef(2.41);; std::vector<std::pair<double,double> > cont =; contours(0, 1, 20);. // 95% confidence level for 2 parameters contour; theFCN.setErrorDef(5.99);; std::vector<std::pair<double,double> > cont4 =; conto",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:84529,Availability,error,error,84529,"td::endl;; std::cout<<""par1: ""; <<min.userState().value(1); <<"" ""<<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""; <<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""<<e2.second<<std::endl;; }; }. {; // demonstrate how to use the CONTOURs. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create contours factory with FCN and minimum; MnContours contours(theFCN, min);. // 70% confidence level for 2 parameters contour; // around the minimum; theFCN.setErrorDef(2.41);; std::vector<std::pair<double,double> > cont =; contours(0, 1, 20);. // 95% confidence level for 2 parameters contour; theFCN.setErrorDef(5.99);; std::vector<std::pair<double,double> > cont4 =; contours(0, 1, 20);. // plot the contours; MnPlot plot;; cont4.insert(cont4.end(), cont.begin(), cont.end());; plot(min.userState().value(""mean""),; min.userState().value(""sigma""),; cont4);; }. return 0;; };. ROOT @bib-ROOT uses its own version of the Fortran M when this manual was written. However an interface for this version exists and the library can be loaded dynamically on demand↩; The internal error matrix maintained by M is transformed for the user into external coordinates, but the numbering of rows and columns is of course still according to internal parameter numbering, since one does not want rows and columns corresponding to parameters which are not variable. The transformation therefore affects only parameters with limits; if there are no limits, internal and external error matrices are the same.↩; For example, if \(\mbox{a}\) and \(\mbox{b}\) are double precision variables, the statement \(\mbox{a = 2*b}\) is not good programming, but happens to do what the user probably intended, whereas the statement \(\mbox{a = b + 2/3}\) almost certainly will not do what the user intended.↩. ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:84918,Availability,error,error,84918,"td::endl;; std::cout<<""par1: ""; <<min.userState().value(1); <<"" ""<<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""; <<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""<<e2.second<<std::endl;; }; }. {; // demonstrate how to use the CONTOURs. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create contours factory with FCN and minimum; MnContours contours(theFCN, min);. // 70% confidence level for 2 parameters contour; // around the minimum; theFCN.setErrorDef(2.41);; std::vector<std::pair<double,double> > cont =; contours(0, 1, 20);. // 95% confidence level for 2 parameters contour; theFCN.setErrorDef(5.99);; std::vector<std::pair<double,double> > cont4 =; contours(0, 1, 20);. // plot the contours; MnPlot plot;; cont4.insert(cont4.end(), cont.begin(), cont.end());; plot(min.userState().value(""mean""),; min.userState().value(""sigma""),; cont4);; }. return 0;; };. ROOT @bib-ROOT uses its own version of the Fortran M when this manual was written. However an interface for this version exists and the library can be loaded dynamically on demand↩; The internal error matrix maintained by M is transformed for the user into external coordinates, but the numbering of rows and columns is of course still according to internal parameter numbering, since one does not want rows and columns corresponding to parameters which are not variable. The transformation therefore affects only parameters with limits; if there are no limits, internal and external error matrices are the same.↩; For example, if \(\mbox{a}\) and \(\mbox{b}\) are double precision variables, the statement \(\mbox{a = 2*b}\) is not good programming, but happens to do what the user probably intended, whereas the statement \(\mbox{a = b + 2/3}\) almost certainly will not do what the user intended.↩. ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:331,Deployability,install,installation,331,". Minuit 2. Minuit 2; Fred JAMES and Matthias WINKLER. Minuit 2; 1 Foreword; 1.1 What M is intended to do; 1.2 What M is not intended to do; 1.3 Further remarks. 2 Introduction: M basic concepts; 2.1 The organization of M; 2.2 Design aspects of M in; 2.3 Internal and external parameters; 2.4 M strategy; 2.5 Parameter errors. 3 M installation; 3.1 M releases; 3.2 Install M using autoconf/make; 3.3 CVS code repository; 3.4 Create a tar.gz from CVS; 3.5 M versions; 3.6 Interference with other packages; 3.7 Floating-point precision. 4 How to use M; 4.1 The \(\mbox{FCN}\) Function; 4.2 M parameters; 4.3 Input to M; 4.4 Running a M minimization; 4.5 The output from minimization. 5 M application programming interface (API); 5.1 FunctionMinimum; 5.2 MnContours; 5.3 MnEigen; 5.4 MnHesse; 5.5 MnMachinePrecision; 5.6 MnMigrad and VariableMetricMinimizer; 5.7 MnMinimize and CombinedMinimizer; 5.8 MnMinos; 5.9 MnPlot; 5.10 MnScan and ScanMinimizer; 5.11 MnSimplex and SimplexMinimizer; 5.12 MnStrategy; 5.13 MnUserCovariance; 5.14 MnUserParameters; 5.15 MnUserParameterState; 5.16 MnPrint.h. 6 How to get the right answer from M; 6.1 Which minimizer to use; 6.2 Floating point precision; 6.3 Parameter limits; 6.4 Fixing and releasing parameters; 6.5 Interpretation of parameter errors; 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; 6.7 Additional trouble–shooting. 7 A complete example; 7.1 The user’s \(\mbox{FCN}\); 7.2 The user’s main program. Minuit 2; *** Fred JAMES and Matthias WINKLER CERN, Geneva ***; 1 Foreword; 1.1 What M is intended to do; M is conceived as a tool to find the minimum value of a multi-parameter function (the “\(\mbox{FCN}\)”) and analyze the shape of the function around the minimum. The principal application is foreseen for statistical analysis, working on chisquare or log-likelihood functions, to compute the best-fit parameter values and uncertainties, including correlations between the parameters. It is especially suited to handle difficult ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:351,Deployability,release,releases,351,". Minuit 2. Minuit 2; Fred JAMES and Matthias WINKLER. Minuit 2; 1 Foreword; 1.1 What M is intended to do; 1.2 What M is not intended to do; 1.3 Further remarks. 2 Introduction: M basic concepts; 2.1 The organization of M; 2.2 Design aspects of M in; 2.3 Internal and external parameters; 2.4 M strategy; 2.5 Parameter errors. 3 M installation; 3.1 M releases; 3.2 Install M using autoconf/make; 3.3 CVS code repository; 3.4 Create a tar.gz from CVS; 3.5 M versions; 3.6 Interference with other packages; 3.7 Floating-point precision. 4 How to use M; 4.1 The \(\mbox{FCN}\) Function; 4.2 M parameters; 4.3 Input to M; 4.4 Running a M minimization; 4.5 The output from minimization. 5 M application programming interface (API); 5.1 FunctionMinimum; 5.2 MnContours; 5.3 MnEigen; 5.4 MnHesse; 5.5 MnMachinePrecision; 5.6 MnMigrad and VariableMetricMinimizer; 5.7 MnMinimize and CombinedMinimizer; 5.8 MnMinos; 5.9 MnPlot; 5.10 MnScan and ScanMinimizer; 5.11 MnSimplex and SimplexMinimizer; 5.12 MnStrategy; 5.13 MnUserCovariance; 5.14 MnUserParameters; 5.15 MnUserParameterState; 5.16 MnPrint.h. 6 How to get the right answer from M; 6.1 Which minimizer to use; 6.2 Floating point precision; 6.3 Parameter limits; 6.4 Fixing and releasing parameters; 6.5 Interpretation of parameter errors; 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; 6.7 Additional trouble–shooting. 7 A complete example; 7.1 The user’s \(\mbox{FCN}\); 7.2 The user’s main program. Minuit 2; *** Fred JAMES and Matthias WINKLER CERN, Geneva ***; 1 Foreword; 1.1 What M is intended to do; M is conceived as a tool to find the minimum value of a multi-parameter function (the “\(\mbox{FCN}\)”) and analyze the shape of the function around the minimum. The principal application is foreseen for statistical analysis, working on chisquare or log-likelihood functions, to compute the best-fit parameter values and uncertainties, including correlations between the parameters. It is especially suited to handle difficult ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:2835,Deployability,release,releases,2835,"to compute the best-fit parameter values and uncertainties, including correlations between the parameters. It is especially suited to handle difficult problems, including those which may require guidance in order to find the correct solution.; 1.2 What M is not intended to do; Although M will of course solve easy problems faster than complicated ones, it is not intended for the repeated solution of identically parametrized problems (such as track fitting in a detector) where a specialized program will in general be much more efficient.; 1.3 Further remarks; M was initially written in Fortran around 1975-1980 at CERN by Fred James @bib-MINUIT. Its main field of usage is statistical data analysis of experimental data recorded at CERN, but it is also used by people doing data analysis outside CERN or outside high energy physics (HEP). In 2002 Fred James started a project aiming to re-implement M in an object-oriented way using .; More information about recent developments, releases and installation can be obtained from the M homepage @bib-C++MINUIT.; The names of M applications are written in capital letters (e.g. \(\mbox{MIGRAD}\), \(\mbox{MINOS}\), \(\mbox{CONTOURS}\)), the corresponding names of the classes are written using sans-serif font type (MnMigrad, MnMinos, MnContours).; 2 Introduction: M basic concepts; [sec:intro]; 2.1 The organization of M; The M package acts on a multiparameter objective function which is called — for historical reasons — the \(\mbox{FCN}\) function (see [howto:fcn]). This function is usually a chisquared or a log–likelihood, but it could also be a mathematical function. The \(\mbox{FCN}\) function needs to be written in for which M defines the pure abstract base class FCNBase as interface. The user must define and implement the \(\mbox{FCN}\) function in a derived class from FCNBase. Sometimes this is done by an intermediate program such as HippoDraw@bib-HippoDraw, in which case M is being used under the control of such an intermediate p",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:2848,Deployability,install,installation,2848,"to compute the best-fit parameter values and uncertainties, including correlations between the parameters. It is especially suited to handle difficult problems, including those which may require guidance in order to find the correct solution.; 1.2 What M is not intended to do; Although M will of course solve easy problems faster than complicated ones, it is not intended for the repeated solution of identically parametrized problems (such as track fitting in a detector) where a specialized program will in general be much more efficient.; 1.3 Further remarks; M was initially written in Fortran around 1975-1980 at CERN by Fred James @bib-MINUIT. Its main field of usage is statistical data analysis of experimental data recorded at CERN, but it is also used by people doing data analysis outside CERN or outside high energy physics (HEP). In 2002 Fred James started a project aiming to re-implement M in an object-oriented way using .; More information about recent developments, releases and installation can be obtained from the M homepage @bib-C++MINUIT.; The names of M applications are written in capital letters (e.g. \(\mbox{MIGRAD}\), \(\mbox{MINOS}\), \(\mbox{CONTOURS}\)), the corresponding names of the classes are written using sans-serif font type (MnMigrad, MnMinos, MnContours).; 2 Introduction: M basic concepts; [sec:intro]; 2.1 The organization of M; The M package acts on a multiparameter objective function which is called — for historical reasons — the \(\mbox{FCN}\) function (see [howto:fcn]). This function is usually a chisquared or a log–likelihood, but it could also be a mathematical function. The \(\mbox{FCN}\) function needs to be written in for which M defines the pure abstract base class FCNBase as interface. The user must define and implement the \(\mbox{FCN}\) function in a derived class from FCNBase. Sometimes this is done by an intermediate program such as HippoDraw@bib-HippoDraw, in which case M is being used under the control of such an intermediate p",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:12889,Deployability,release,release,12889," recommended that:. Limits on variable parameters should be used only when needed in order to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits. Further discussion of the effects of parameter limits may be found in the last chapter.; 2.4 M strategy; At many places in the analysis of the \(\mbox{FCN}\) (the user provided function), M must decide whether to be “safe” and waste a few function calls in order to know where it is, or to be “fast” and attempt to get the requested results with the fewest possible calls at a certain risk of not obtaining the precision desired by the user. In order to allow the user to influence these decisions, there is a M class MnStrategy (see [api:strategy]) which the user can use to put different settings. In the current release, this MnStrategy can be instantiated with three different minimization quality levels for low (0), medium (1) and high (2) quality. Default settings for iteration cycles and tolerances are initialized then. The default setting is set for medium quality. Value 0 (low) indicates to M that it should economize function calls; it is intended for cases where there are many variable parameters and/or the function takes a long time to calculate and/or the user is not interested in very precise values for parameter errors. On the other hand, value 2 (high) indicates that M is allowed to waste function calls in order to be sure that all values are precise; it is intended for cases where the function is evaluated in a relatively short time and/or where the parameter errors must be calculated reliably. In addition all constants set in MnStrategy can be changed individually by the user, e.g. the number of iteration cycles in the numerical gradient.; 2.5 Parameter errors; M is usually used to find the “best” values of a set of parameters, where “best” ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:18706,Deployability,release,released,18706,"he covariance or the correlations can be printed and shown via std::cout as the ostream operator operator\(<<\) is overloaded. The eigenvalues of the error matrix can be calculated using MnEigen, which should all be positive if the matrix is positive-definite (see below on \(\mbox{MIGRAD}\) and positive-definiteness).; The effect of correlations on the individual parameter errors can be seen as follows. When parameter \(\mbox{n}\) is fixed (e.g. via the method MnMigrad::fix(n)), M inverts the error matrix, removes the row and column corresponding to parameter \(\mbox{n}\), and re-inverts the result. The effect on the errors of the other parameters will in general be to make them smaller, since the component due to the uncertainty in parameter \(\mbox{n}\) has now been removed. (In the limit that a given parameter is uncorrelated with parameter \(\mbox{n}\), its error will not change when parameter \(\mbox{n}\) is fixed.) However the procedure is not reversible, since M forgets the original error matrix, so if parameter \(\mbox{n}\) is then released (e.g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally available program to calculate parameter errors taking into account both parameter correlations and non-linearities. The \(\mbox{MINOS}\) error intervals are in general asymmetric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate after a good minimum has already been found, and the error matrix has been calculated, so the \(\mbox{MINOS}\) error analysis will normally follow a \(\mbox{MIGRAD}\) minimization. The \(\mbox{MINOS}\) error for a given parameter is defined as the change in the value of that parameter which causes \({\disp",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:18746,Deployability,release,release,18746,"alues of the error matrix can be calculated using MnEigen, which should all be positive if the matrix is positive-definite (see below on \(\mbox{MIGRAD}\) and positive-definiteness).; The effect of correlations on the individual parameter errors can be seen as follows. When parameter \(\mbox{n}\) is fixed (e.g. via the method MnMigrad::fix(n)), M inverts the error matrix, removes the row and column corresponding to parameter \(\mbox{n}\), and re-inverts the result. The effect on the errors of the other parameters will in general be to make them smaller, since the component due to the uncertainty in parameter \(\mbox{n}\) has now been removed. (In the limit that a given parameter is uncorrelated with parameter \(\mbox{n}\), its error will not change when parameter \(\mbox{n}\) is fixed.) However the procedure is not reversible, since M forgets the original error matrix, so if parameter \(\mbox{n}\) is then released (e.g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally available program to calculate parameter errors taking into account both parameter correlations and non-linearities. The \(\mbox{MINOS}\) error intervals are in general asymmetric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate after a good minimum has already been found, and the error matrix has been calculated, so the \(\mbox{MINOS}\) error analysis will normally follow a \(\mbox{MIGRAD}\) minimization. The \(\mbox{MINOS}\) error for a given parameter is defined as the change in the value of that parameter which causes \({\displaystyle F'}\) to increase by the amount FCNBase::up(), where \({\displaystyle F'}\) is the minimum of \(\mbox{FCN}\) with respect to al",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:22743,Deployability,install,installation,22743,"ntours provides the actual coordinates of the points around the contour, suitable for plotting with a graphics routine or by hand (using MnPlot, see [api:plot]). The points are given in counter-clockwise order around the contour. Only one contour is calculated per command, and the level is \(\displaystyle F_{\mathrm{min}} + \mbox{up}\). where \(\mbox{up}\) is the return value of FCNBase::up() specified by the user (usually 1.0 by default). The number of points to be calculated is chosen by the user (default is 20). As a by-product, \(\mbox{CONTOURS}\) provides the \(\mbox{MINOS}\) errors of the two parameters in question, since these are just the extreme points of the contour (use the MnContours::contour(…) method in order to get the points of the contour and the ones of the \(\mbox{MINOS}\) errors). MnContours::operator() returns a std::vector\(<\)std::pair\(<\)double,double\(> >\) of (x,y) points. Using MnPlot::operator() will generate a text graphics plot in the terminal.; 3 M installation; 3.1 M releases; To follow the current release process the user is referred to the M homepage @bib-C++MINUIT.; M was re–implemented in from 2002–2004, but the functionality is largely compatible with the one of the version. The usage is different in the sense that the re–write from to was done by its signification and not literally (with minor exceptions). Applications such as \(\mbox{MIGRAD}\) have a corresponding class MnMigrad, M “commands” became classes or methods of classes according to their purpose. Users familiar with the version of M , who have not yet used releases from the version, should however read this manual, in order to adapt to the changes as well as to discover the new features and easier ways of using old features.; 3.2 Install M using autoconf/make; For each release of M a tar.gz file is provided for downloading from the M homepage @bib-C++MINUIT. For non-UNIX platforms please refer to the M homepage.; The necessary steps to follow are:. download the tar.g",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:22763,Deployability,release,releases,22763,"contour, suitable for plotting with a graphics routine or by hand (using MnPlot, see [api:plot]). The points are given in counter-clockwise order around the contour. Only one contour is calculated per command, and the level is \(\displaystyle F_{\mathrm{min}} + \mbox{up}\). where \(\mbox{up}\) is the return value of FCNBase::up() specified by the user (usually 1.0 by default). The number of points to be calculated is chosen by the user (default is 20). As a by-product, \(\mbox{CONTOURS}\) provides the \(\mbox{MINOS}\) errors of the two parameters in question, since these are just the extreme points of the contour (use the MnContours::contour(…) method in order to get the points of the contour and the ones of the \(\mbox{MINOS}\) errors). MnContours::operator() returns a std::vector\(<\)std::pair\(<\)double,double\(> >\) of (x,y) points. Using MnPlot::operator() will generate a text graphics plot in the terminal.; 3 M installation; 3.1 M releases; To follow the current release process the user is referred to the M homepage @bib-C++MINUIT.; M was re–implemented in from 2002–2004, but the functionality is largely compatible with the one of the version. The usage is different in the sense that the re–write from to was done by its signification and not literally (with minor exceptions). Applications such as \(\mbox{MIGRAD}\) have a corresponding class MnMigrad, M “commands” became classes or methods of classes according to their purpose. Users familiar with the version of M , who have not yet used releases from the version, should however read this manual, in order to adapt to the changes as well as to discover the new features and easier ways of using old features.; 3.2 Install M using autoconf/make; For each release of M a tar.gz file is provided for downloading from the M homepage @bib-C++MINUIT. For non-UNIX platforms please refer to the M homepage.; The necessary steps to follow are:. download the tar.gz by clicking on it from the release page; unzip it:; $ unzip Mi",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:22795,Deployability,release,release,22795,"contour, suitable for plotting with a graphics routine or by hand (using MnPlot, see [api:plot]). The points are given in counter-clockwise order around the contour. Only one contour is calculated per command, and the level is \(\displaystyle F_{\mathrm{min}} + \mbox{up}\). where \(\mbox{up}\) is the return value of FCNBase::up() specified by the user (usually 1.0 by default). The number of points to be calculated is chosen by the user (default is 20). As a by-product, \(\mbox{CONTOURS}\) provides the \(\mbox{MINOS}\) errors of the two parameters in question, since these are just the extreme points of the contour (use the MnContours::contour(…) method in order to get the points of the contour and the ones of the \(\mbox{MINOS}\) errors). MnContours::operator() returns a std::vector\(<\)std::pair\(<\)double,double\(> >\) of (x,y) points. Using MnPlot::operator() will generate a text graphics plot in the terminal.; 3 M installation; 3.1 M releases; To follow the current release process the user is referred to the M homepage @bib-C++MINUIT.; M was re–implemented in from 2002–2004, but the functionality is largely compatible with the one of the version. The usage is different in the sense that the re–write from to was done by its signification and not literally (with minor exceptions). Applications such as \(\mbox{MIGRAD}\) have a corresponding class MnMigrad, M “commands” became classes or methods of classes according to their purpose. Users familiar with the version of M , who have not yet used releases from the version, should however read this manual, in order to adapt to the changes as well as to discover the new features and easier ways of using old features.; 3.2 Install M using autoconf/make; For each release of M a tar.gz file is provided for downloading from the M homepage @bib-C++MINUIT. For non-UNIX platforms please refer to the M homepage.; The necessary steps to follow are:. download the tar.gz by clicking on it from the release page; unzip it:; $ unzip Mi",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:23330,Deployability,release,releases,23330,"these are just the extreme points of the contour (use the MnContours::contour(…) method in order to get the points of the contour and the ones of the \(\mbox{MINOS}\) errors). MnContours::operator() returns a std::vector\(<\)std::pair\(<\)double,double\(> >\) of (x,y) points. Using MnPlot::operator() will generate a text graphics plot in the terminal.; 3 M installation; 3.1 M releases; To follow the current release process the user is referred to the M homepage @bib-C++MINUIT.; M was re–implemented in from 2002–2004, but the functionality is largely compatible with the one of the version. The usage is different in the sense that the re–write from to was done by its signification and not literally (with minor exceptions). Applications such as \(\mbox{MIGRAD}\) have a corresponding class MnMigrad, M “commands” became classes or methods of classes according to their purpose. Users familiar with the version of M , who have not yet used releases from the version, should however read this manual, in order to adapt to the changes as well as to discover the new features and easier ways of using old features.; 3.2 Install M using autoconf/make; For each release of M a tar.gz file is provided for downloading from the M homepage @bib-C++MINUIT. For non-UNIX platforms please refer to the M homepage.; The necessary steps to follow are:. download the tar.gz by clicking on it from the release page; unzip it:; $ unzip Minuit-x.x.x.tar.gz; untar it:; $ tar xvf Minuit-x.x.x.tar; step down to the created Minuit-x.x.x directory:; $ cd Minuit-x.x.x/; run the “configure” script:; $ ./configure; run “make” to compile the source code:; $ make; run “make check” to create the executable example:; $ make check; run the executable example:; $ tests/MnTutorial/Quad4FMain.C. The output should look like that:; Minuit did successfully converge. # of function calls: 74; minimum function value: 1.12392e-09; minimum edm: 1.12392e-09; minimum internal state vector: LAVector parameters:. -1.82079e-05; -",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:23547,Deployability,release,release,23547,"(\mbox{MINOS}\) errors). MnContours::operator() returns a std::vector\(<\)std::pair\(<\)double,double\(> >\) of (x,y) points. Using MnPlot::operator() will generate a text graphics plot in the terminal.; 3 M installation; 3.1 M releases; To follow the current release process the user is referred to the M homepage @bib-C++MINUIT.; M was re–implemented in from 2002–2004, but the functionality is largely compatible with the one of the version. The usage is different in the sense that the re–write from to was done by its signification and not literally (with minor exceptions). Applications such as \(\mbox{MIGRAD}\) have a corresponding class MnMigrad, M “commands” became classes or methods of classes according to their purpose. Users familiar with the version of M , who have not yet used releases from the version, should however read this manual, in order to adapt to the changes as well as to discover the new features and easier ways of using old features.; 3.2 Install M using autoconf/make; For each release of M a tar.gz file is provided for downloading from the M homepage @bib-C++MINUIT. For non-UNIX platforms please refer to the M homepage.; The necessary steps to follow are:. download the tar.gz by clicking on it from the release page; unzip it:; $ unzip Minuit-x.x.x.tar.gz; untar it:; $ tar xvf Minuit-x.x.x.tar; step down to the created Minuit-x.x.x directory:; $ cd Minuit-x.x.x/; run the “configure” script:; $ ./configure; run “make” to compile the source code:; $ make; run “make check” to create the executable example:; $ make check; run the executable example:; $ tests/MnTutorial/Quad4FMain.C. The output should look like that:; Minuit did successfully converge. # of function calls: 74; minimum function value: 1.12392e-09; minimum edm: 1.12392e-09; minimum internal state vector: LAVector parameters:. -1.82079e-05; -1.20794e-05; 6.22382e-06; -3.0465e-05. minimum internal covariance matrix: LASymMatrix parameters:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:23777,Deployability,release,release,23777,"the current release process the user is referred to the M homepage @bib-C++MINUIT.; M was re–implemented in from 2002–2004, but the functionality is largely compatible with the one of the version. The usage is different in the sense that the re–write from to was done by its signification and not literally (with minor exceptions). Applications such as \(\mbox{MIGRAD}\) have a corresponding class MnMigrad, M “commands” became classes or methods of classes according to their purpose. Users familiar with the version of M , who have not yet used releases from the version, should however read this manual, in order to adapt to the changes as well as to discover the new features and easier ways of using old features.; 3.2 Install M using autoconf/make; For each release of M a tar.gz file is provided for downloading from the M homepage @bib-C++MINUIT. For non-UNIX platforms please refer to the M homepage.; The necessary steps to follow are:. download the tar.gz by clicking on it from the release page; unzip it:; $ unzip Minuit-x.x.x.tar.gz; untar it:; $ tar xvf Minuit-x.x.x.tar; step down to the created Minuit-x.x.x directory:; $ cd Minuit-x.x.x/; run the “configure” script:; $ ./configure; run “make” to compile the source code:; $ make; run “make check” to create the executable example:; $ make check; run the executable example:; $ tests/MnTutorial/Quad4FMain.C. The output should look like that:; Minuit did successfully converge. # of function calls: 74; minimum function value: 1.12392e-09; minimum edm: 1.12392e-09; minimum internal state vector: LAVector parameters:. -1.82079e-05; -1.20794e-05; 6.22382e-06; -3.0465e-05. minimum internal covariance matrix: LASymMatrix parameters:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. # ext. || name || type || value || error +/-. 0 || x || free ||-1.821e-05 || 2; 1 || y || free ||-1.208e-05 || 2.236; 2 || z || free || 6.224e-06 || 2.449; 3 || w || free ||-3.047e-05 || 1. MnUserCovari",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:26274,Deployability,release,release,26274,"m the CVS repository one needs to do:; Kerberos IV authorization:; $ setenv CVSROOT :kserver:SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs co MathLibs/Minuit; Anonymous read-only access (if it’s enabled by the librarian, see details):; $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login; (Logging in to :pserver:anonymous@seal.cvs.cern.ch:2401/cvs/SEAL) CVS password:cvs; $ cvs co MathLibs/Minuit; (If you want to check out a tagged version SEAL_x_x_x of MINUIT, then do; $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ); 3.4 Create a tar.gz from CVS; Once the sources are checked out from the CVS code repository,. change to the directory:; $ cd MathLibs/Minuit; run autogen:; $ ./autogen; create a new directory:; $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/; run configure:; $ ../Minuit/configure; create the tar.gz:; $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used as described above.; 3.5 M versions; The version numbers of M follow the release numbers of the SEAL project @bib-SEAL at CERN @bib-CERN.; 3.5.1 From to; The program is entirely written in standard portable . M does not depend on any external library. In its minimal usage the user must only provide an implementation of the FCNBase class to M and parameters and uncertainties in form of std::vector containers.; 3.5.2 Memory allocation and thread safety; Differently to the version of M , the version has its own memory manager (StackAllocator. The user can select between the standard dynamic memory allocation and deallocation (default) and performance-optimized stack–like allocation (optional). However, the library is not thread save using stack–allocation.; 3.5.3 M parameters; Differently to the version of M there is no limit on the number of parameters, variable or non-variable. Memory allocation is done dynamically according to the actual needs and “on demand”. There is no protection against an upper limit on the number of parameters, however the “technological” li",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:27805,Deployability,install,install,27805,"eallocation (default) and performance-optimized stack–like allocation (optional). However, the library is not thread save using stack–allocation.; 3.5.3 M parameters; Differently to the version of M there is no limit on the number of parameters, variable or non-variable. Memory allocation is done dynamically according to the actual needs and “on demand”. There is no protection against an upper limit on the number of parameters, however the “technological” limitations of M can be seen around a maximum of 15 free parameters at a time.; 3.6 Interference with other packages; The new M has been designed to interfere as little as possible with other programs or packages which may be loaded at the same time. M is thread safe by default. Optionally the user can select a different way of dynamically allocating memory in the class StackAllacator for M , in which case (and after an entire recompilation of the whole library) the thread safety is lost.; 3.7 Floating-point precision; [install:epsmac]; M is entirely based on double precision. The actual floating point precision of double precision (32–bit or 64–bit) is platform dependent and can even vary on the same platform, depending on whether a floating point number is read from memory a CPU register.; The argument of the user’s implementation of FCNBase::operator() is therefore a std:vector\(<\)double\(>\). M expects that the calculations inside \(\mbox{FCN}\) will be performed approximately to the same accuracy.; The accuracy M expects is called machine precision (MnMachinePrecision, see [api:epsmac]) and can be printed on demand using std::cout. If the user fools M by making internal \(\mbox{FCN}\) computations in single precision, M will interpret roundoff noise as significant and will usually either fail to find a minimum, or give incorrect values for the parameter errors.; It is therefore recommended to make sure that all computations in \(\mbox{FCN}\), as well as all methods and functions called by \(\mbox{FCN}\), are ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:31915,Deployability,release,release,31915," by \(\mbox{up}\). Normally, for chisquared fits \(\mbox{up = 1}\), and for negative log likelihood, \(\mbox{up = 0.5}\).; 4.1.3 \(\mbox{FCN}\) function with gradient; By default first derivatives are calculated numerically by M . In case the user wants to supply their own gradient calculator (e.g. analytical derivatives), they need to implement the FCNGradientBase interface. The size of the output vector is the same as of the input one. The same is true for the position of the elements (first derivative of the function with respect to the \(n_\mathrm{th}\) variable has index \(n\) in the output vector).; 4.2 M parameters; Interaction with the parameters of the function are essential both for M and the user. Different interfaces are provided, depending on the level of interaction.; 4.2.1 Minimal required interface; Starting values of parameters and uncertainties can be provided to M by the user via std::vector\(<\)double\(>\) vector containers. Any interaction with the parameters before minimization (fix, release, limits, etc.) is not possible then.; Optionally if the user wants to provide starting values for the covariance, they have to provide the values in a std::vector\(<\)double\(>\) vector container stored in upper triangular packed storage format (see [api:covariance]).; 4.2.2 MnUserParameters; A more functional interface to the user parameters is provided through M via the class MnUserParameters. The user can add parameters giving them a name and starting values. More information can be found in [api:parameters].; 4.2.3 MnUserCovariance; The user can (optionally) provide a covariance matrix as input using the class MnUserCovariance. More information can be found in [api:covariance].; 4.2.4 MnUserParameterState; The MnUserParameterState contains the parameters (MnUserParameters) and covariance (MnUserCovariance). The MnUserParameterState has to main purposes:. It can be used as input to minimization.; The result of the minimization is transformed into the use",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:35000,Deployability,release,release,35000," parameter or put limits on it before minimization, they have to instantiate a MnUserParameters object and then add parameters one by one, giving them a name, value, uncertainty. Once all parameters are added to MnUserParameters, they can fix a parameter or put limits on another one before handing them over to Minuit for minimization.; 4.3.2 What the user can supply; Optionally the user can supply their own gradient calculator by implementing the FCNGradientBase interface or supply a full covariance matrix for input if one is available. The covariance matrix can be supplied in form of a std::vector\(<\)double\(>\) in packed storage format (upper triangular), or in a more user-friendly way by using the interface provided by the MnUserCovariance.; 4.4 Running a M minimization; Two use cases are addressed for minimization:. The user just wants the function to be minimized in one go.; The user wants to minimize the \(\mbox{FCN}\) in several minimization steps, re-using the result of the preceeding minimization in the next step and change parameters in between (fix/release/put limits on them, etc.). How M minimizations can be performed is shown in [example:main].; 4.4.1 Direct usage of minimizers; Minimizers such as the VariableMetricMinimizer are designed as state-less minimization engines, which means that they do not depend on the current function and its parameters. Any \(\mbox{FCN}\) function can be minimized with the same minimizer. The interface is restricted to minimization and no parameter interaction is possible.; 4.4.2 Using an application (MnMigrad); MnMigrad uses the VariableMetricMinimizer for minimization but allows as well for parameter interaction by the user. An instance of MnMigrad is specific to the current \(\mbox{FCN}\) and user parameters. Any parameter interaction of the user between two minimization steps will make use of the result of the preceeding minimization in an optimal way. The interface for parameters (see [api:parameters], [api:covarianc",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:36307,Deployability,release,release,36307,"ers. Any \(\mbox{FCN}\) function can be minimized with the same minimizer. The interface is restricted to minimization and no parameter interaction is possible.; 4.4.2 Using an application (MnMigrad); MnMigrad uses the VariableMetricMinimizer for minimization but allows as well for parameter interaction by the user. An instance of MnMigrad is specific to the current \(\mbox{FCN}\) and user parameters. Any parameter interaction of the user between two minimization steps will make use of the result of the preceeding minimization in an optimal way. The interface for parameters (see [api:parameters], [api:covariance] and [api:state]) is forwardedin MnMigrad.; 4.4.3 Subsequent minimizations; M takes care that all information is treated in an optimal and correct way if the user interacts with the parameters between two minimizations. MnMigrad retains the result of the last minimization and uses this as input for the next step. Between two minimization requests to MnMigrad the user can fix or release parameters, put limits on them or remove limits from them. Each instance of a MnMigrad object maintains its own state and one can have multiple instances of MnMigrad objects.; 4.4.4 M fails to find a minimum; If M fails to find a minimum, the user is notified by a warning message issued by M when running into troubles. Problems can be:. a bug in M; an error in the \(\mbox{FCN}\); a highly difficult problem (usually strong correlations among parameters); floating–point precision. 4.5 The output from minimization; 4.5.1 The FunctionMinimum; The output of the minimizers is the FunctionMinimum. The FunctionMinimum contains the result of the minimization in both internal parameter representation and external parameter representation.; 4.5.2 User representable format: MnUserParameterState; On request, the result of the minimization is transformed into a user representable format for parameters and errors, the MnUserParameterState.; 4.5.3 Access values, errors, covariance; The result ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:55960,Deployability,release,release,55960,"ble\(>\) in the FCNBase::operator(). That means the first parameter the user adds gets index 0, the second index 1, and so on. When calculating the function value inside FCN, M will call FCNBase::operator() with the elements at their positions.; 5.14.2 setValue(…); [api:setvalue] setValue(unsigned int parno, double value) or setValue(const char* name, double value) set the value of parameter \(\mbox{parno}\) or with name \(\mbox{name}\) to \(\mbox{ value}\). The parameter in question may be variable, fixed, or constant, but must be defined.; 5.14.3 setError(…); [api:seterror] setError(unsigned int parno, double error) or setError(const char* name, double error) set the error (sigma) of parameter \(\mbox{parno}\) or with name \(\mbox{name}\) to \(\mbox{value}\).; 5.14.4 fix(…); [api:fix] fix(unsigned int parno) or fix(const char* name) fixes parameter \(\mbox{parno}\) or with name \(\mbox{name}\).; 5.14.5 release(…); [api:release] release(unsigned int parno) or release(const char* name) releases a previously fixed parameter \(\mbox{parno}\) or with name \(\mbox{name}\).; 5.14.6 setLimits(…); [api:setlimits] setLimits(unsigned int n, double low, double up) or setLimits(const char* name, double low, double up) sets the lower and upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\).; However, if \(\mbox{low}\) is equal to \(\mbox{up}\), an error condition results.; 5.14.7 setUpperLimit(…); [api:setupperlimits] setUpperLimit(unsigned int n, double up) or setUpperLimit(const char* name, double up) sets the upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have a lower limit.; 5.14.8 setLowerLimit(…); [api:setlowerlimits] setLowerLimit(unsigned int n, double low) or setLowerLimit(const char* name, double low) sets the lower bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have an upper limit.; 5.14.9 removeLimits(…); [api:removelimits] removeLimits(unsigned int n) or removeLimits(co",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:55977,Deployability,release,release,55977,"ble\(>\) in the FCNBase::operator(). That means the first parameter the user adds gets index 0, the second index 1, and so on. When calculating the function value inside FCN, M will call FCNBase::operator() with the elements at their positions.; 5.14.2 setValue(…); [api:setvalue] setValue(unsigned int parno, double value) or setValue(const char* name, double value) set the value of parameter \(\mbox{parno}\) or with name \(\mbox{name}\) to \(\mbox{ value}\). The parameter in question may be variable, fixed, or constant, but must be defined.; 5.14.3 setError(…); [api:seterror] setError(unsigned int parno, double error) or setError(const char* name, double error) set the error (sigma) of parameter \(\mbox{parno}\) or with name \(\mbox{name}\) to \(\mbox{value}\).; 5.14.4 fix(…); [api:fix] fix(unsigned int parno) or fix(const char* name) fixes parameter \(\mbox{parno}\) or with name \(\mbox{name}\).; 5.14.5 release(…); [api:release] release(unsigned int parno) or release(const char* name) releases a previously fixed parameter \(\mbox{parno}\) or with name \(\mbox{name}\).; 5.14.6 setLimits(…); [api:setlimits] setLimits(unsigned int n, double low, double up) or setLimits(const char* name, double low, double up) sets the lower and upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\).; However, if \(\mbox{low}\) is equal to \(\mbox{up}\), an error condition results.; 5.14.7 setUpperLimit(…); [api:setupperlimits] setUpperLimit(unsigned int n, double up) or setUpperLimit(const char* name, double up) sets the upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have a lower limit.; 5.14.8 setLowerLimit(…); [api:setlowerlimits] setLowerLimit(unsigned int n, double low) or setLowerLimit(const char* name, double low) sets the lower bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have an upper limit.; 5.14.9 removeLimits(…); [api:removelimits] removeLimits(unsigned int n) or removeLimits(co",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:55986,Deployability,release,release,55986,"ble\(>\) in the FCNBase::operator(). That means the first parameter the user adds gets index 0, the second index 1, and so on. When calculating the function value inside FCN, M will call FCNBase::operator() with the elements at their positions.; 5.14.2 setValue(…); [api:setvalue] setValue(unsigned int parno, double value) or setValue(const char* name, double value) set the value of parameter \(\mbox{parno}\) or with name \(\mbox{name}\) to \(\mbox{ value}\). The parameter in question may be variable, fixed, or constant, but must be defined.; 5.14.3 setError(…); [api:seterror] setError(unsigned int parno, double error) or setError(const char* name, double error) set the error (sigma) of parameter \(\mbox{parno}\) or with name \(\mbox{name}\) to \(\mbox{value}\).; 5.14.4 fix(…); [api:fix] fix(unsigned int parno) or fix(const char* name) fixes parameter \(\mbox{parno}\) or with name \(\mbox{name}\).; 5.14.5 release(…); [api:release] release(unsigned int parno) or release(const char* name) releases a previously fixed parameter \(\mbox{parno}\) or with name \(\mbox{name}\).; 5.14.6 setLimits(…); [api:setlimits] setLimits(unsigned int n, double low, double up) or setLimits(const char* name, double low, double up) sets the lower and upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\).; However, if \(\mbox{low}\) is equal to \(\mbox{up}\), an error condition results.; 5.14.7 setUpperLimit(…); [api:setupperlimits] setUpperLimit(unsigned int n, double up) or setUpperLimit(const char* name, double up) sets the upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have a lower limit.; 5.14.8 setLowerLimit(…); [api:setlowerlimits] setLowerLimit(unsigned int n, double low) or setLowerLimit(const char* name, double low) sets the lower bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have an upper limit.; 5.14.9 removeLimits(…); [api:removelimits] removeLimits(unsigned int n) or removeLimits(co",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:56017,Deployability,release,release,56017,"ble\(>\) in the FCNBase::operator(). That means the first parameter the user adds gets index 0, the second index 1, and so on. When calculating the function value inside FCN, M will call FCNBase::operator() with the elements at their positions.; 5.14.2 setValue(…); [api:setvalue] setValue(unsigned int parno, double value) or setValue(const char* name, double value) set the value of parameter \(\mbox{parno}\) or with name \(\mbox{name}\) to \(\mbox{ value}\). The parameter in question may be variable, fixed, or constant, but must be defined.; 5.14.3 setError(…); [api:seterror] setError(unsigned int parno, double error) or setError(const char* name, double error) set the error (sigma) of parameter \(\mbox{parno}\) or with name \(\mbox{name}\) to \(\mbox{value}\).; 5.14.4 fix(…); [api:fix] fix(unsigned int parno) or fix(const char* name) fixes parameter \(\mbox{parno}\) or with name \(\mbox{name}\).; 5.14.5 release(…); [api:release] release(unsigned int parno) or release(const char* name) releases a previously fixed parameter \(\mbox{parno}\) or with name \(\mbox{name}\).; 5.14.6 setLimits(…); [api:setlimits] setLimits(unsigned int n, double low, double up) or setLimits(const char* name, double low, double up) sets the lower and upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\).; However, if \(\mbox{low}\) is equal to \(\mbox{up}\), an error condition results.; 5.14.7 setUpperLimit(…); [api:setupperlimits] setUpperLimit(unsigned int n, double up) or setUpperLimit(const char* name, double up) sets the upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have a lower limit.; 5.14.8 setLowerLimit(…); [api:setlowerlimits] setLowerLimit(unsigned int n, double low) or setLowerLimit(const char* name, double low) sets the lower bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have an upper limit.; 5.14.9 removeLimits(…); [api:removelimits] removeLimits(unsigned int n) or removeLimits(co",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:56043,Deployability,release,releases,56043,"ble\(>\) in the FCNBase::operator(). That means the first parameter the user adds gets index 0, the second index 1, and so on. When calculating the function value inside FCN, M will call FCNBase::operator() with the elements at their positions.; 5.14.2 setValue(…); [api:setvalue] setValue(unsigned int parno, double value) or setValue(const char* name, double value) set the value of parameter \(\mbox{parno}\) or with name \(\mbox{name}\) to \(\mbox{ value}\). The parameter in question may be variable, fixed, or constant, but must be defined.; 5.14.3 setError(…); [api:seterror] setError(unsigned int parno, double error) or setError(const char* name, double error) set the error (sigma) of parameter \(\mbox{parno}\) or with name \(\mbox{name}\) to \(\mbox{value}\).; 5.14.4 fix(…); [api:fix] fix(unsigned int parno) or fix(const char* name) fixes parameter \(\mbox{parno}\) or with name \(\mbox{name}\).; 5.14.5 release(…); [api:release] release(unsigned int parno) or release(const char* name) releases a previously fixed parameter \(\mbox{parno}\) or with name \(\mbox{name}\).; 5.14.6 setLimits(…); [api:setlimits] setLimits(unsigned int n, double low, double up) or setLimits(const char* name, double low, double up) sets the lower and upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\).; However, if \(\mbox{low}\) is equal to \(\mbox{up}\), an error condition results.; 5.14.7 setUpperLimit(…); [api:setupperlimits] setUpperLimit(unsigned int n, double up) or setUpperLimit(const char* name, double up) sets the upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have a lower limit.; 5.14.8 setLowerLimit(…); [api:setlowerlimits] setLowerLimit(unsigned int n, double low) or setLowerLimit(const char* name, double low) sets the lower bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have an upper limit.; 5.14.9 removeLimits(…); [api:removelimits] removeLimits(unsigned int n) or removeLimits(co",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:64294,Deployability,install,install,64294,"\); This genuine multidimensional minimization routine is usually much slower than \(\mbox{MIGRAD}\), but it does not use first derivatives, so it should not be so sensitive to the precision of the \(\mbox{FCN}\) calculations, and is even rather robust with respect to gross fluctuations in the function value. However, it gives no reliable information about parameter errors, no information whatsoever about parameter correlations, and worst of all cannot be expected to converge accurately to the minimum in a finite time. Its estimate of the expected distance to the minimum \(\mbox{EDM}\) is largely fantasy, so it would not even know if it did converge.; 6.2 Floating point precision; M figures out at execution time the machine precision [api:epsmac], and assumes that \(\mbox{FCN}\) provides about the same precision. That means not just the length of the numbers used and returned by \(\mbox{FCN}\), but the actual mathematical accuracy of the calculations. Section [install:epsmac] describes what to do if this is not the case.; 6.3 Parameter limits; Putting limits (absolute bounds) on the allowed values for a given parameter, causes M to make a non-linear transformation of its own internal parameter values to obtain the (external) parameter values passed to \(\mbox{FCN}\). To understand the adverse effect of limits, see [intro:limits].; Basically, the use of limits should be avoided unless needed to keep the parameter inside a desired range.; If parameter limits are needed, in spite of the effects described in Chapter One, then the user should be aware of the following techniques to alleviate problems caused by limits.; 6.3.1 Getting the Right Minimum with Limits; If \(\mbox{MIGRAD}\) converges normally to a point where no parameter is near one of its limits, then the existence of limits has probably not prevented M from finding the right minimum. On the other hand, if one or more parameters is near its limit at the minimum, this may be because the true minimum is indeed a",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:67753,Deployability,release,release,67753,"ut limits. In other cases (which should be more common, since otherwise you wouldn’t need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless. On the other hand, the \(\mbox{MINOS}\) analysis is still meaningful, at least in principle, as long as \(\mbox{MIGRAD}\) (which is called internally by \(\mbox{MINOS}\)) does not get blocked at a limit. Unfortunately, the user has no control over this aspect of the \(\mbox{MINOS}\) calculation, although it is possible to get enough printout from the \(\mbox{MINOS}\) result to be able to determine whether the results are reliable or not.; 6.4 Fixing and releasing parameters; When M needs to be guided to the “right” minimum, often the best way to do this is with the methods e.g. MnMigrad::fix(…) and MnMigrad::release(…). That is, suppose you have a problem with ten free parameters, and when you minimize with respect to all at once, M goes to an unphysical solution characterized by an unphysical or unwanted value of parameter number four. One way to avoid this is to fix parameter four at a “good” value (not necessarily the best, since you presumably don’t know that yet), and minimize with respect to the others. Then release parameter four and minimize again. If the problem admits a “good” physical solution, you will normally find it this way. If it doesn’t work, you may see what is wrong by the following sequence (where \(\mbox{xxx}\) is the expected physical value for parameter four):; MnMigrad migrad(...);; migrad.setValue(4, xxx);; migrad.fix(4);; FunctionMinimum min = migrad();; migrad.release(4);; MnScan scan(...);; std::vector<std::pair<double, double> > points = scan(4);; where \(\mbox{SCAN}\) gives you a picture of \(\mbox{FCN}\) as a function of parameter four alone, the o",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:68167,Deployability,release,release,68167," is still meaningful, at least in principle, as long as \(\mbox{MIGRAD}\) (which is called internally by \(\mbox{MINOS}\)) does not get blocked at a limit. Unfortunately, the user has no control over this aspect of the \(\mbox{MINOS}\) calculation, although it is possible to get enough printout from the \(\mbox{MINOS}\) result to be able to determine whether the results are reliable or not.; 6.4 Fixing and releasing parameters; When M needs to be guided to the “right” minimum, often the best way to do this is with the methods e.g. MnMigrad::fix(…) and MnMigrad::release(…). That is, suppose you have a problem with ten free parameters, and when you minimize with respect to all at once, M goes to an unphysical solution characterized by an unphysical or unwanted value of parameter number four. One way to avoid this is to fix parameter four at a “good” value (not necessarily the best, since you presumably don’t know that yet), and minimize with respect to the others. Then release parameter four and minimize again. If the problem admits a “good” physical solution, you will normally find it this way. If it doesn’t work, you may see what is wrong by the following sequence (where \(\mbox{xxx}\) is the expected physical value for parameter four):; MnMigrad migrad(...);; migrad.setValue(4, xxx);; migrad.fix(4);; FunctionMinimum min = migrad();; migrad.release(4);; MnScan scan(...);; std::vector<std::pair<double, double> > points = scan(4);; where \(\mbox{SCAN}\) gives you a picture of \(\mbox{FCN}\) as a function of parameter four alone, the others being fixed at their current best values. If you suspect the difficulty is due to parameter five, then add; MnContours contour(...);; std::vector<std::pair<double, double> > points = contour(4, 5);; to see a two-dimensional picture.; 6.5 Interpretation of parameter errors; There are two kinds of problems that can arise: The reliability of M ’s error estimates, and their statistical interpretation, assuming they are accurate.; 6.5.1 ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:68548,Deployability,release,release,68548," reliable or not.; 6.4 Fixing and releasing parameters; When M needs to be guided to the “right” minimum, often the best way to do this is with the methods e.g. MnMigrad::fix(…) and MnMigrad::release(…). That is, suppose you have a problem with ten free parameters, and when you minimize with respect to all at once, M goes to an unphysical solution characterized by an unphysical or unwanted value of parameter number four. One way to avoid this is to fix parameter four at a “good” value (not necessarily the best, since you presumably don’t know that yet), and minimize with respect to the others. Then release parameter four and minimize again. If the problem admits a “good” physical solution, you will normally find it this way. If it doesn’t work, you may see what is wrong by the following sequence (where \(\mbox{xxx}\) is the expected physical value for parameter four):; MnMigrad migrad(...);; migrad.setValue(4, xxx);; migrad.fix(4);; FunctionMinimum min = migrad();; migrad.release(4);; MnScan scan(...);; std::vector<std::pair<double, double> > points = scan(4);; where \(\mbox{SCAN}\) gives you a picture of \(\mbox{FCN}\) as a function of parameter four alone, the others being fixed at their current best values. If you suspect the difficulty is due to parameter five, then add; MnContours contour(...);; std::vector<std::pair<double, double> > points = contour(4, 5);; to see a two-dimensional picture.; 6.5 Interpretation of parameter errors; There are two kinds of problems that can arise: The reliability of M ’s error estimates, and their statistical interpretation, assuming they are accurate.; 6.5.1 Statistical interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, parabolic versus \(\mbox{MINOS}\) errors, the appropriate value for \(\mbox{up}\) (see [howto:errordef]), and setting of exact confidence levels, see (in order of increasing complexity and completeness):. “Interpretation of the Errors on Parameters”, see Pa",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:81363,Deployability,release,release,81363,". {; // demonstrate standard minimization using MIGRAD; // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create MIGRAD minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate full interaction with parameters over subsequent; // minimizations. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // access parameter by name to set limits...; upar.setLimits(""mean"", mean-0.01, mean+0.01);. // ... or access parameter by index; upar.setLimits(1, rms-0.1, rms+0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // fix a parameter...; migrad.fix(""mean"");. // ... and minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;. // release a parameter...; migrad.release(""mean"");. // ... and fix another one; migrad.fix(1);. // and minimize again; FunctionMinimum min1 = migrad();. // output; std::cout<<""minimum1: ""<<min1<<std::endl;. // release the parameter...; migrad.release(1);. // ... and minimize with all three parameters; // (still with limits!); FunctionMinimum min2 = migrad();. // output; std::cout<<""minimum2: ""<<min2<<std::endl;. // remove all limits on parameters...; migrad.removeLimits(""mean"");; migrad.removeLimits(""sigma"");. // ... and minimize again with all three parameters; // (now without limits!); FunctionMinimum min3 = migrad();. // output; std::cout<<""minimum3: ""<<min3<<std::endl;; }. {; // demonstrate MINOS error analysis. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create MINOS error fac",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:81394,Deployability,release,release,81394,"nimization using MIGRAD; // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create MIGRAD minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate full interaction with parameters over subsequent; // minimizations. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // access parameter by name to set limits...; upar.setLimits(""mean"", mean-0.01, mean+0.01);. // ... or access parameter by index; upar.setLimits(1, rms-0.1, rms+0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // fix a parameter...; migrad.fix(""mean"");. // ... and minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;. // release a parameter...; migrad.release(""mean"");. // ... and fix another one; migrad.fix(1);. // and minimize again; FunctionMinimum min1 = migrad();. // output; std::cout<<""minimum1: ""<<min1<<std::endl;. // release the parameter...; migrad.release(1);. // ... and minimize with all three parameters; // (still with limits!); FunctionMinimum min2 = migrad();. // output; std::cout<<""minimum2: ""<<min2<<std::endl;. // remove all limits on parameters...; migrad.removeLimits(""mean"");; migrad.removeLimits(""sigma"");. // ... and minimize again with all three parameters; // (now without limits!); FunctionMinimum min3 = migrad();. // output; std::cout<<""minimum3: ""<<min3<<std::endl;; }. {; // demonstrate MINOS error analysis. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create MINOS error factory; MnMinos minos(theFCN, min)",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:81570,Deployability,release,release,81570,". // create MIGRAD minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate full interaction with parameters over subsequent; // minimizations. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // access parameter by name to set limits...; upar.setLimits(""mean"", mean-0.01, mean+0.01);. // ... or access parameter by index; upar.setLimits(1, rms-0.1, rms+0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // fix a parameter...; migrad.fix(""mean"");. // ... and minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;. // release a parameter...; migrad.release(""mean"");. // ... and fix another one; migrad.fix(1);. // and minimize again; FunctionMinimum min1 = migrad();. // output; std::cout<<""minimum1: ""<<min1<<std::endl;. // release the parameter...; migrad.release(1);. // ... and minimize with all three parameters; // (still with limits!); FunctionMinimum min2 = migrad();. // output; std::cout<<""minimum2: ""<<min2<<std::endl;. // remove all limits on parameters...; migrad.removeLimits(""mean"");; migrad.removeLimits(""sigma"");. // ... and minimize again with all three parameters; // (now without limits!); FunctionMinimum min3 = migrad();. // output; std::cout<<""minimum3: ""<<min3<<std::endl;; }. {; // demonstrate MINOS error analysis. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create MINOS error factory; MnMinos minos(theFCN, min);. {; // 1-sigma MINOS errors; std::pair<double,double> e0 = minos(0);; std::pair<double,double> e1 = minos(1);; std::pair<double,double> e2 = minos(2);. // output; std::cout<<",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:81603,Deployability,release,release,81603,"MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate full interaction with parameters over subsequent; // minimizations. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // access parameter by name to set limits...; upar.setLimits(""mean"", mean-0.01, mean+0.01);. // ... or access parameter by index; upar.setLimits(1, rms-0.1, rms+0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // fix a parameter...; migrad.fix(""mean"");. // ... and minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;. // release a parameter...; migrad.release(""mean"");. // ... and fix another one; migrad.fix(1);. // and minimize again; FunctionMinimum min1 = migrad();. // output; std::cout<<""minimum1: ""<<min1<<std::endl;. // release the parameter...; migrad.release(1);. // ... and minimize with all three parameters; // (still with limits!); FunctionMinimum min2 = migrad();. // output; std::cout<<""minimum2: ""<<min2<<std::endl;. // remove all limits on parameters...; migrad.removeLimits(""mean"");; migrad.removeLimits(""sigma"");. // ... and minimize again with all three parameters; // (now without limits!); FunctionMinimum min3 = migrad();. // output; std::cout<<""minimum3: ""<<min3<<std::endl;; }. {; // demonstrate MINOS error analysis. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create MINOS error factory; MnMinos minos(theFCN, min);. {; // 1-sigma MINOS errors; std::pair<double,double> e0 = minos(0);; std::pair<double,double> e1 = minos(1);; std::pair<double,double> e2 = minos(2);. // output; std::cout<<""1-sigma minos errors: ""<<std:",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:2381,Energy Efficiency,efficient,efficient,2381,"ers; 6.5 Interpretation of parameter errors; 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; 6.7 Additional trouble–shooting. 7 A complete example; 7.1 The user’s \(\mbox{FCN}\); 7.2 The user’s main program. Minuit 2; *** Fred JAMES and Matthias WINKLER CERN, Geneva ***; 1 Foreword; 1.1 What M is intended to do; M is conceived as a tool to find the minimum value of a multi-parameter function (the “\(\mbox{FCN}\)”) and analyze the shape of the function around the minimum. The principal application is foreseen for statistical analysis, working on chisquare or log-likelihood functions, to compute the best-fit parameter values and uncertainties, including correlations between the parameters. It is especially suited to handle difficult problems, including those which may require guidance in order to find the correct solution.; 1.2 What M is not intended to do; Although M will of course solve easy problems faster than complicated ones, it is not intended for the repeated solution of identically parametrized problems (such as track fitting in a detector) where a specialized program will in general be much more efficient.; 1.3 Further remarks; M was initially written in Fortran around 1975-1980 at CERN by Fred James @bib-MINUIT. Its main field of usage is statistical data analysis of experimental data recorded at CERN, but it is also used by people doing data analysis outside CERN or outside high energy physics (HEP). In 2002 Fred James started a project aiming to re-implement M in an object-oriented way using .; More information about recent developments, releases and installation can be obtained from the M homepage @bib-C++MINUIT.; The names of M applications are written in capital letters (e.g. \(\mbox{MIGRAD}\), \(\mbox{MINOS}\), \(\mbox{CONTOURS}\)), the corresponding names of the classes are written using sans-serif font type (MnMigrad, MnMinos, MnContours).; 2 Introduction: M basic concepts; [sec:intro]; 2.1 The organization of M; The M package acts o",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:2672,Energy Efficiency,energy,energy,2672,"ol to find the minimum value of a multi-parameter function (the “\(\mbox{FCN}\)”) and analyze the shape of the function around the minimum. The principal application is foreseen for statistical analysis, working on chisquare or log-likelihood functions, to compute the best-fit parameter values and uncertainties, including correlations between the parameters. It is especially suited to handle difficult problems, including those which may require guidance in order to find the correct solution.; 1.2 What M is not intended to do; Although M will of course solve easy problems faster than complicated ones, it is not intended for the repeated solution of identically parametrized problems (such as track fitting in a detector) where a specialized program will in general be much more efficient.; 1.3 Further remarks; M was initially written in Fortran around 1975-1980 at CERN by Fred James @bib-MINUIT. Its main field of usage is statistical data analysis of experimental data recorded at CERN, but it is also used by people doing data analysis outside CERN or outside high energy physics (HEP). In 2002 Fred James started a project aiming to re-implement M in an object-oriented way using .; More information about recent developments, releases and installation can be obtained from the M homepage @bib-C++MINUIT.; The names of M applications are written in capital letters (e.g. \(\mbox{MIGRAD}\), \(\mbox{MINOS}\), \(\mbox{CONTOURS}\)), the corresponding names of the classes are written using sans-serif font type (MnMigrad, MnMinos, MnContours).; 2 Introduction: M basic concepts; [sec:intro]; 2.1 The organization of M; The M package acts on a multiparameter objective function which is called — for historical reasons — the \(\mbox{FCN}\) function (see [howto:fcn]). This function is usually a chisquared or a log–likelihood, but it could also be a mathematical function. The \(\mbox{FCN}\) function needs to be written in for which M defines the pure abstract base class FCNBase as interface",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:23402,Energy Efficiency,adapt,adapt,23402,"these are just the extreme points of the contour (use the MnContours::contour(…) method in order to get the points of the contour and the ones of the \(\mbox{MINOS}\) errors). MnContours::operator() returns a std::vector\(<\)std::pair\(<\)double,double\(> >\) of (x,y) points. Using MnPlot::operator() will generate a text graphics plot in the terminal.; 3 M installation; 3.1 M releases; To follow the current release process the user is referred to the M homepage @bib-C++MINUIT.; M was re–implemented in from 2002–2004, but the functionality is largely compatible with the one of the version. The usage is different in the sense that the re–write from to was done by its signification and not literally (with minor exceptions). Applications such as \(\mbox{MIGRAD}\) have a corresponding class MnMigrad, M “commands” became classes or methods of classes according to their purpose. Users familiar with the version of M , who have not yet used releases from the version, should however read this manual, in order to adapt to the changes as well as to discover the new features and easier ways of using old features.; 3.2 Install M using autoconf/make; For each release of M a tar.gz file is provided for downloading from the M homepage @bib-C++MINUIT. For non-UNIX platforms please refer to the M homepage.; The necessary steps to follow are:. download the tar.gz by clicking on it from the release page; unzip it:; $ unzip Minuit-x.x.x.tar.gz; untar it:; $ tar xvf Minuit-x.x.x.tar; step down to the created Minuit-x.x.x directory:; $ cd Minuit-x.x.x/; run the “configure” script:; $ ./configure; run “make” to compile the source code:; $ make; run “make check” to create the executable example:; $ make check; run the executable example:; $ tests/MnTutorial/Quad4FMain.C. The output should look like that:; Minuit did successfully converge. # of function calls: 74; minimum function value: 1.12392e-09; minimum edm: 1.12392e-09; minimum internal state vector: LAVector parameters:. -1.82079e-05; -",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:29095,Energy Efficiency,reduce,reduced,29095,"tions inside \(\mbox{FCN}\) will be performed approximately to the same accuracy.; The accuracy M expects is called machine precision (MnMachinePrecision, see [api:epsmac]) and can be printed on demand using std::cout. If the user fools M by making internal \(\mbox{FCN}\) computations in single precision, M will interpret roundoff noise as significant and will usually either fail to find a minimum, or give incorrect values for the parameter errors.; It is therefore recommended to make sure that all computations in \(\mbox{FCN}\), as well as all methods and functions called by \(\mbox{FCN}\), are done in double precision. If for some reason the computations cannot be done to a precision comparable with that expected by M , the user must inform M of this situation with setting a different machine precision via the MnMachinePrecision::setPrecision(double) method.; With reduced precision, the user may find that certain features sensitive to first and second differences (\(\mbox{HESSE}\), \(\mbox{MINOS}\), \(\mbox{CONTOURS}\)) do not work properly, in which case the calculations must be performed in higher precision.; 4 How to use M; [howto:howto]; 4.1 The \(\mbox{FCN}\) Function; [howto:fcn]; The user must always implement a derived class of FCNBase (the “\(\mbox{FCN}\)”) which calculates the function value to be minimized or analyzed. Note that when M is being used through an intermediate package such as HippoDraw @bib-HippoDraw, then the user’s \(\mbox{FCN}\) may be supplied by the this package.; The name of the user’s class to implement the FCNBase interface may be chosen freely (in documentation we give it the generic name \(\mbox{FCN}\)).; 4.1.1 FCNBase::operator()(const std::vector\(<\)double\(>\)&); The meaning of the vector of parameters std::vector\(<\)double\(>\) in the argument of FCNBase::operator() are of course defined by the user, who uses the values of those parameters to calculate their function value. The order and the position of these parameters is st",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:43054,Energy Efficiency,efficient,efficient,43054,"al (M ) and external (user) parameters. External parameters can be specified as std::vector\(<\)double\(>\) or as MnUserParameters. The return value is always a MnUserParameterState.; The optional argument \(\mbox{maxcalls}\) specifies the (approximate) maximum number of function calls after which the calculation will be stopped.; 5.5 MnMachinePrecision; [api:epsmac]; 5.5.1 MnMachinePrecision(); M determines the nominal precision itself in the default constructor MnMachinePrecision().; 5.5.2 setPrecision(double eps); Informs M that the relative floating point arithmetic precision is \(\mbox{eps}\). The method can be used to override M ’s own determination, when the user knows that the \(\mbox{FCN}\) function value is not calculated to the nominal machine accuracy. Typical values of \(\mbox{eps}\) are between \(10^{-5}\) and \(10^{-14}\).; 5.6 MnMigrad and VariableMetricMinimizer; [api:migrad]; MnMigrad provides minimization of the function by the method of \(\mbox{MIGRAD}\), the most efficient and complete single method, recommended for general functions (see also [api:minimize]), and the functionality for parameters interaction. It also retains the result from the last minimization in case the user may want to do subsequent minimization steps with parameter interactions in between the minimization requests. The minimization is done by the VariableMetricMinimizer. Minimization of the function can be done by directly using the VariableMetricMinimizer if no parameters interaction is required. The minimization produces as a by-product the error matrix of the parameters, which is usually reliable unless warning messages are produced.; 5.6.1 MnMigrad(const FCNBase&, const std::vector\(<\)double\(>\)&, const std::vector\(<\)double\(>\)&, unsigned int); Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.6.2 MnMigrad(const FCNBase&, const MnUserPa",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:53883,Energy Efficiency,allocate,allocate,53883,"xternal covariance matrix designed for the interaction of the user. The result of the minimization (internal covariance matrix) is converted into the user representable format. It can also be used as input prior to the minimization. The size of the covariance matrix is according to the number of variable parameters (free and limited).; 5.13.1 MnUserCovariance(const std::vector\(<\)double\(>\)&, unsigned int nrow); Construct from data, positions of the elements in the array are arranged according to the packed storage format. The size of the array must be \(nrow*(nrow+1)/2\). The array must contain the upper triangular part of the symmetric matrix packed sequentially, column by column, so that arr(0) contains covar(0,0), arr(1) and arr(2) contain covar(0,1) and covar(1,1) respectively, and so on. The number of rows (columns) has to be specified.; 5.13.2 MnUserCovariance(unsigned int nrow); Specify the number of rows (columns) at instantiation. It will allocate an array of the length \(nrow*(nrow+1)/2\) and initialize it to \(0\). Elements can then be set using the method operator()(unsigned int, unsigned int).; 5.13.3 MnUserCovariance::operator()(unsigned int, unsigned int); Individual elements can be accessed via the operator(), both for reading and writing.; 5.14 MnUserParameters; [api:parameters] MnUserParameters is the main class for user interaction with the parameters. It serves both as input to the minimization as well as output as the result of the minimization is converted into the user representable format in order to allow for further interaction. Parameters for M can be added (defined) specifying a name, value and initial uncertainty.; 5.14.1 add(…); The method MnUserParameters::add(…) is overloaded for three kind of parameters:. add(const char*, double, double) for adding a free variable parameter; add(const char*, double, double, double, double) for adding a variable parameter with limits (lower and upper); add(const char*, double) for adding a constant",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:710,Integrability,interface,interface,710,". Minuit 2. Minuit 2; Fred JAMES and Matthias WINKLER. Minuit 2; 1 Foreword; 1.1 What M is intended to do; 1.2 What M is not intended to do; 1.3 Further remarks. 2 Introduction: M basic concepts; 2.1 The organization of M; 2.2 Design aspects of M in; 2.3 Internal and external parameters; 2.4 M strategy; 2.5 Parameter errors. 3 M installation; 3.1 M releases; 3.2 Install M using autoconf/make; 3.3 CVS code repository; 3.4 Create a tar.gz from CVS; 3.5 M versions; 3.6 Interference with other packages; 3.7 Floating-point precision. 4 How to use M; 4.1 The \(\mbox{FCN}\) Function; 4.2 M parameters; 4.3 Input to M; 4.4 Running a M minimization; 4.5 The output from minimization. 5 M application programming interface (API); 5.1 FunctionMinimum; 5.2 MnContours; 5.3 MnEigen; 5.4 MnHesse; 5.5 MnMachinePrecision; 5.6 MnMigrad and VariableMetricMinimizer; 5.7 MnMinimize and CombinedMinimizer; 5.8 MnMinos; 5.9 MnPlot; 5.10 MnScan and ScanMinimizer; 5.11 MnSimplex and SimplexMinimizer; 5.12 MnStrategy; 5.13 MnUserCovariance; 5.14 MnUserParameters; 5.15 MnUserParameterState; 5.16 MnPrint.h. 6 How to get the right answer from M; 6.1 Which minimizer to use; 6.2 Floating point precision; 6.3 Parameter limits; 6.4 Fixing and releasing parameters; 6.5 Interpretation of parameter errors; 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; 6.7 Additional trouble–shooting. 7 A complete example; 7.1 The user’s \(\mbox{FCN}\); 7.2 The user’s main program. Minuit 2; *** Fred JAMES and Matthias WINKLER CERN, Geneva ***; 1 Foreword; 1.1 What M is intended to do; M is conceived as a tool to find the minimum value of a multi-parameter function (the “\(\mbox{FCN}\)”) and analyze the shape of the function around the minimum. The principal application is foreseen for statistical analysis, working on chisquare or log-likelihood functions, to compute the best-fit parameter values and uncertainties, including correlations between the parameters. It is especially suited to handle difficult ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:3588,Integrability,interface,interface,3588,"al data analysis of experimental data recorded at CERN, but it is also used by people doing data analysis outside CERN or outside high energy physics (HEP). In 2002 Fred James started a project aiming to re-implement M in an object-oriented way using .; More information about recent developments, releases and installation can be obtained from the M homepage @bib-C++MINUIT.; The names of M applications are written in capital letters (e.g. \(\mbox{MIGRAD}\), \(\mbox{MINOS}\), \(\mbox{CONTOURS}\)), the corresponding names of the classes are written using sans-serif font type (MnMigrad, MnMinos, MnContours).; 2 Introduction: M basic concepts; [sec:intro]; 2.1 The organization of M; The M package acts on a multiparameter objective function which is called — for historical reasons — the \(\mbox{FCN}\) function (see [howto:fcn]). This function is usually a chisquared or a log–likelihood, but it could also be a mathematical function. The \(\mbox{FCN}\) function needs to be written in for which M defines the pure abstract base class FCNBase as interface. The user must define and implement the \(\mbox{FCN}\) function in a derived class from FCNBase. Sometimes this is done by an intermediate program such as HippoDraw@bib-HippoDraw, in which case M is being used under the control of such an intermediate program1. The value of the \(\mbox{FCN}\) function will in general depend on one or more variable parameters whose meaning is defined by the user (or by the intermediate program), but whose trial values are determined by M .; To take a simple example, suppose the problem is to fit a polynomial through a set of data points. Then the user would write a \(\mbox{FCN}\) which calculates the \(\chi^2\) between a polynomial and the data; the variable parameters of \(\mbox{FCN}\) would be the coefficients of the polynomials. Using objects for minimization from M , the user would request M to minimize the \(\mbox{FCN}\) with respect to the parameters, that is, find those values of the co",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:3917,Integrability,depend,depend,3917,"etters (e.g. \(\mbox{MIGRAD}\), \(\mbox{MINOS}\), \(\mbox{CONTOURS}\)), the corresponding names of the classes are written using sans-serif font type (MnMigrad, MnMinos, MnContours).; 2 Introduction: M basic concepts; [sec:intro]; 2.1 The organization of M; The M package acts on a multiparameter objective function which is called — for historical reasons — the \(\mbox{FCN}\) function (see [howto:fcn]). This function is usually a chisquared or a log–likelihood, but it could also be a mathematical function. The \(\mbox{FCN}\) function needs to be written in for which M defines the pure abstract base class FCNBase as interface. The user must define and implement the \(\mbox{FCN}\) function in a derived class from FCNBase. Sometimes this is done by an intermediate program such as HippoDraw@bib-HippoDraw, in which case M is being used under the control of such an intermediate program1. The value of the \(\mbox{FCN}\) function will in general depend on one or more variable parameters whose meaning is defined by the user (or by the intermediate program), but whose trial values are determined by M .; To take a simple example, suppose the problem is to fit a polynomial through a set of data points. Then the user would write a \(\mbox{FCN}\) which calculates the \(\chi^2\) between a polynomial and the data; the variable parameters of \(\mbox{FCN}\) would be the coefficients of the polynomials. Using objects for minimization from M , the user would request M to minimize the \(\mbox{FCN}\) with respect to the parameters, that is, find those values of the coefficients which give the lowest value of chisquare.; The user must therefore supply, in addition to the function to be analyzed, via a set or sequence of M applications the instructions which analysis is wanted. The instructions are coded in in the calling program (main.cpp), which allows looping, conditional execution, and all the other possibilities of , but not interactivity, since it must be compiled before execution.; 2.",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:5852,Integrability,interface,interface,5852,"ion, and all the other possibilities of , but not interactivity, since it must be compiled before execution.; 2.2 Design aspects of M in; What M is:. platform independent; written in an object-oriented way using standard; independent of any external package. The maintainability should be guaranteed with the choice of a modern computer language. Choosing object-oriented technology M should profit from an increased flexibility and functionality and make it also extendable (recursiveness, new algorithms, new functionality).; What M does not:. histogramming; data handling; graphics. M is kept as a low-level package with optimal performance.; The main usages of M are. from a user’s program (such as int main()…); from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. its numerical accuracy (equivalent to its Fortran version); its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a two-way strategy was imposed:. a minimal required interface with minimum interaction with M objects and with appropriate usage of the standard library (STL): the user’s implementation of the FCNBase class, initial parameter values and uncertainties are provided by the to M user via std::vectors.; a rich interface which provides the user with more functionality such as interaction with parameters. The core of the minimization functionality and related tools (the kernel of M ) should be clearly separated from the user, who is interfacing via defined user interfaces (the API).; 2.3 Internal and external parameters; Each of the parameters to the \(\mbox{FCN}\) is defined by the user as belonging to one of the following types:. Freely variable: allowed to take on any value.; Variable with double sided limits: allowed to vary only between two limits specified by the user.; Variable with single sided limits: allowed to vary only between one upper or one lower limit specifi",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:5925,Integrability,interface,interface,5925,"an object-oriented way using standard; independent of any external package. The maintainability should be guaranteed with the choice of a modern computer language. Choosing object-oriented technology M should profit from an increased flexibility and functionality and make it also extendable (recursiveness, new algorithms, new functionality).; What M does not:. histogramming; data handling; graphics. M is kept as a low-level package with optimal performance.; The main usages of M are. from a user’s program (such as int main()…); from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. its numerical accuracy (equivalent to its Fortran version); its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a two-way strategy was imposed:. a minimal required interface with minimum interaction with M objects and with appropriate usage of the standard library (STL): the user’s implementation of the FCNBase class, initial parameter values and uncertainties are provided by the to M user via std::vectors.; a rich interface which provides the user with more functionality such as interaction with parameters. The core of the minimization functionality and related tools (the kernel of M ) should be clearly separated from the user, who is interfacing via defined user interfaces (the API).; 2.3 Internal and external parameters; Each of the parameters to the \(\mbox{FCN}\) is defined by the user as belonging to one of the following types:. Freely variable: allowed to take on any value.; Variable with double sided limits: allowed to vary only between two limits specified by the user.; Variable with single sided limits: allowed to vary only between one upper or one lower limit specified by the user and unlimited to the other side.; Fixed: originally defined as variable, but now taking on only the value the parameter had at the moment it was fixed, or a value later",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:6180,Integrability,interface,interface,6180,"nted technology M should profit from an increased flexibility and functionality and make it also extendable (recursiveness, new algorithms, new functionality).; What M does not:. histogramming; data handling; graphics. M is kept as a low-level package with optimal performance.; The main usages of M are. from a user’s program (such as int main()…); from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. its numerical accuracy (equivalent to its Fortran version); its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a two-way strategy was imposed:. a minimal required interface with minimum interaction with M objects and with appropriate usage of the standard library (STL): the user’s implementation of the FCNBase class, initial parameter values and uncertainties are provided by the to M user via std::vectors.; a rich interface which provides the user with more functionality such as interaction with parameters. The core of the minimization functionality and related tools (the kernel of M ) should be clearly separated from the user, who is interfacing via defined user interfaces (the API).; 2.3 Internal and external parameters; Each of the parameters to the \(\mbox{FCN}\) is defined by the user as belonging to one of the following types:. Freely variable: allowed to take on any value.; Variable with double sided limits: allowed to vary only between two limits specified by the user.; Variable with single sided limits: allowed to vary only between one upper or one lower limit specified by the user and unlimited to the other side.; Fixed: originally defined as variable, but now taking on only the value the parameter had at the moment it was fixed, or a value later assigned by the user.; Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are free and unbound.; The user, ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:6434,Integrability,interface,interfaces,6434,"w functionality).; What M does not:. histogramming; data handling; graphics. M is kept as a low-level package with optimal performance.; The main usages of M are. from a user’s program (such as int main()…); from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. its numerical accuracy (equivalent to its Fortran version); its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a two-way strategy was imposed:. a minimal required interface with minimum interaction with M objects and with appropriate usage of the standard library (STL): the user’s implementation of the FCNBase class, initial parameter values and uncertainties are provided by the to M user via std::vectors.; a rich interface which provides the user with more functionality such as interaction with parameters. The core of the minimization functionality and related tools (the kernel of M ) should be clearly separated from the user, who is interfacing via defined user interfaces (the API).; 2.3 Internal and external parameters; Each of the parameters to the \(\mbox{FCN}\) is defined by the user as belonging to one of the following types:. Freely variable: allowed to take on any value.; Variable with double sided limits: allowed to vary only between two limits specified by the user.; Variable with single sided limits: allowed to vary only between one upper or one lower limit specified by the user and unlimited to the other side.; Fixed: originally defined as variable, but now taking on only the value the parameter had at the moment it was fixed, or a value later assigned by the user.; Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are free and unbound.; The user, in their \(\mbox{FCN}\), must of course be able to “see” all types of defined parameters, and they therefore have access to what we call the e",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:7155,Integrability,interface,interface,7155,"tors.; a rich interface which provides the user with more functionality such as interaction with parameters. The core of the minimization functionality and related tools (the kernel of M ) should be clearly separated from the user, who is interfacing via defined user interfaces (the API).; 2.3 Internal and external parameters; Each of the parameters to the \(\mbox{FCN}\) is defined by the user as belonging to one of the following types:. Freely variable: allowed to take on any value.; Variable with double sided limits: allowed to vary only between two limits specified by the user.; Variable with single sided limits: allowed to vary only between one upper or one lower limit specified by the user and unlimited to the other side.; Fixed: originally defined as variable, but now taking on only the value the parameter had at the moment it was fixed, or a value later assigned by the user.; Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are free and unbound.; The user, in their \(\mbox{FCN}\), must of course be able to “see” all types of defined parameters, and they therefore have access to what we call the external parameter list, that is, the parameters as he defined them. On the other hand, the internal M minimizing routines only want to “see” variable parameters without limits, and so they have access only to the internal parameter list which is created from the external list by the following transformation:. Squeeze out all parameters that are not variable.; Transform all variable parameters with limits, so that the transformed parameter can vary without limits. (See the next section for details concerning this transformation.) Because this transformation is non-linear, it is recommended to avoid putting limits on parameters where they are not needed. As an example, suppose that the user has defined the following parameters:. Parameter 0, constant.; Parameter 1, freely variable.; Parameter ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:7478,Integrability,rout,routines,7478," the user as belonging to one of the following types:. Freely variable: allowed to take on any value.; Variable with double sided limits: allowed to vary only between two limits specified by the user.; Variable with single sided limits: allowed to vary only between one upper or one lower limit specified by the user and unlimited to the other side.; Fixed: originally defined as variable, but now taking on only the value the parameter had at the moment it was fixed, or a value later assigned by the user.; Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are free and unbound.; The user, in their \(\mbox{FCN}\), must of course be able to “see” all types of defined parameters, and they therefore have access to what we call the external parameter list, that is, the parameters as he defined them. On the other hand, the internal M minimizing routines only want to “see” variable parameters without limits, and so they have access only to the internal parameter list which is created from the external list by the following transformation:. Squeeze out all parameters that are not variable.; Transform all variable parameters with limits, so that the transformed parameter can vary without limits. (See the next section for details concerning this transformation.) Because this transformation is non-linear, it is recommended to avoid putting limits on parameters where they are not needed. As an example, suppose that the user has defined the following parameters:. Parameter 0, constant.; Parameter 1, freely variable.; Parameter 2, variable with limits.; Parameter 3, constant.; Parameter 4, freely variable. Then the internal parameter list would be as follows:. Internal parameter 0 = external parameter 1.; Internal parameter 1 = external parameter 2, transformed appropriately.; Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters is 5, and the n",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:14486,Integrability,depend,depend,14486,"re precise; it is intended for cases where the function is evaluated in a relatively short time and/or where the parameter errors must be calculated reliably. In addition all constants set in MnStrategy can be changed individually by the user, e.g. the number of iteration cycles in the numerical gradient.; 2.5 Parameter errors; M is usually used to find the “best” values of a set of parameters, where “best” is defined as those values which minimize a given function, \(\mbox{FCN}\). The width of the function minimum, or more generally, the shape of the function in some neighbourhood of the minimum, gives information about the uncertainty in the best parameter values, often called by physicists the parameter errors. An important feature of M is that it offers several tools to analyze the parameter errors.; 2.5.1 \(\mbox{FCN}\) normalization and the error definition; Whatever method is used to calculate the parameter errors, they will depend on the overall (multiplicative) normalization of \(\mbox{FCN}\), in the sense that if the value of \(\mbox{FCN}\) is everywhere multiplied by a constant \(\beta\), then the errors will be decreased by a factor \(\sqrt{\beta}\). Additive constants do not change the parameter errors, but may imply a different goodness-of-fit confidence level.; Assuming that the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they are interested in parameter errors, the user can change the error definition which allows them to define what they means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one “error”. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-deviation errors, then the error definition (return value of the FCNBase::up() method, see [howto:errordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FC",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:21859,Integrability,rout,routine,21859,"ther hand, when the problem is very non-linear (i.e., \(\mbox{FCN}\) is far from a quadratic function of its parameters), is precisely the situation when \(\mbox{MINOS}\) is needed in order to indicate the correct parameter errors.; 2.5.4 \(\mbox{CONTOURS}\) plotting; M offers a procedure for finding \(\mbox{FCN}\) \(\mbox{CONTOURS}\) (provided via the class MnContours, see [api:contours]).; The contour calculated by MnContours::operator() is dynamic, in the sense that it represents the minimum of \(\mbox{FCN}\) with respect to all the other \(\mbox{npar - 2}\) parameters (if any). In statistical terms, this means that MnContours takes account of the correlations between the two parameters being plotted, and all the other variable parameters, using a procedure analogous to that of \(\mbox{MINOS}\). (If this feature is not wanted, then the other parameters must be fixed before calling \(\mbox{CONTOURS}\).) MnContours provides the actual coordinates of the points around the contour, suitable for plotting with a graphics routine or by hand (using MnPlot, see [api:plot]). The points are given in counter-clockwise order around the contour. Only one contour is calculated per command, and the level is \(\displaystyle F_{\mathrm{min}} + \mbox{up}\). where \(\mbox{up}\) is the return value of FCNBase::up() specified by the user (usually 1.0 by default). The number of points to be calculated is chosen by the user (default is 20). As a by-product, \(\mbox{CONTOURS}\) provides the \(\mbox{MINOS}\) errors of the two parameters in question, since these are just the extreme points of the contour (use the MnContours::contour(…) method in order to get the points of the contour and the ones of the \(\mbox{MINOS}\) errors). MnContours::operator() returns a std::vector\(<\)std::pair\(<\)double,double\(> >\) of (x,y) points. Using MnPlot::operator() will generate a text graphics plot in the terminal.; 3 M installation; 3.1 M releases; To follow the current release process the user is ref",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:26421,Integrability,depend,depend,26421,"onymous read-only access (if it’s enabled by the librarian, see details):; $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login; (Logging in to :pserver:anonymous@seal.cvs.cern.ch:2401/cvs/SEAL) CVS password:cvs; $ cvs co MathLibs/Minuit; (If you want to check out a tagged version SEAL_x_x_x of MINUIT, then do; $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ); 3.4 Create a tar.gz from CVS; Once the sources are checked out from the CVS code repository,. change to the directory:; $ cd MathLibs/Minuit; run autogen:; $ ./autogen; create a new directory:; $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/; run configure:; $ ../Minuit/configure; create the tar.gz:; $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used as described above.; 3.5 M versions; The version numbers of M follow the release numbers of the SEAL project @bib-SEAL at CERN @bib-CERN.; 3.5.1 From to; The program is entirely written in standard portable . M does not depend on any external library. In its minimal usage the user must only provide an implementation of the FCNBase class to M and parameters and uncertainties in form of std::vector containers.; 3.5.2 Memory allocation and thread safety; Differently to the version of M , the version has its own memory manager (StackAllocator. The user can select between the standard dynamic memory allocation and deallocation (default) and performance-optimized stack–like allocation (optional). However, the library is not thread save using stack–allocation.; 3.5.3 M parameters; Differently to the version of M there is no limit on the number of parameters, variable or non-variable. Memory allocation is done dynamically according to the actual needs and “on demand”. There is no protection against an upper limit on the number of parameters, however the “technological” limitations of M can be seen around a maximum of 15 free parameters at a time.; 3.6 Interference with other packages; The new M has been designed to int",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:27950,Integrability,depend,dependent,27950," M parameters; Differently to the version of M there is no limit on the number of parameters, variable or non-variable. Memory allocation is done dynamically according to the actual needs and “on demand”. There is no protection against an upper limit on the number of parameters, however the “technological” limitations of M can be seen around a maximum of 15 free parameters at a time.; 3.6 Interference with other packages; The new M has been designed to interfere as little as possible with other programs or packages which may be loaded at the same time. M is thread safe by default. Optionally the user can select a different way of dynamically allocating memory in the class StackAllacator for M , in which case (and after an entire recompilation of the whole library) the thread safety is lost.; 3.7 Floating-point precision; [install:epsmac]; M is entirely based on double precision. The actual floating point precision of double precision (32–bit or 64–bit) is platform dependent and can even vary on the same platform, depending on whether a floating point number is read from memory a CPU register.; The argument of the user’s implementation of FCNBase::operator() is therefore a std:vector\(<\)double\(>\). M expects that the calculations inside \(\mbox{FCN}\) will be performed approximately to the same accuracy.; The accuracy M expects is called machine precision (MnMachinePrecision, see [api:epsmac]) and can be printed on demand using std::cout. If the user fools M by making internal \(\mbox{FCN}\) computations in single precision, M will interpret roundoff noise as significant and will usually either fail to find a minimum, or give incorrect values for the parameter errors.; It is therefore recommended to make sure that all computations in \(\mbox{FCN}\), as well as all methods and functions called by \(\mbox{FCN}\), are done in double precision. If for some reason the computations cannot be done to a precision comparable with that expected by M , the user must inform M ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:28000,Integrability,depend,depending,28000," M parameters; Differently to the version of M there is no limit on the number of parameters, variable or non-variable. Memory allocation is done dynamically according to the actual needs and “on demand”. There is no protection against an upper limit on the number of parameters, however the “technological” limitations of M can be seen around a maximum of 15 free parameters at a time.; 3.6 Interference with other packages; The new M has been designed to interfere as little as possible with other programs or packages which may be loaded at the same time. M is thread safe by default. Optionally the user can select a different way of dynamically allocating memory in the class StackAllacator for M , in which case (and after an entire recompilation of the whole library) the thread safety is lost.; 3.7 Floating-point precision; [install:epsmac]; M is entirely based on double precision. The actual floating point precision of double precision (32–bit or 64–bit) is platform dependent and can even vary on the same platform, depending on whether a floating point number is read from memory a CPU register.; The argument of the user’s implementation of FCNBase::operator() is therefore a std:vector\(<\)double\(>\). M expects that the calculations inside \(\mbox{FCN}\) will be performed approximately to the same accuracy.; The accuracy M expects is called machine precision (MnMachinePrecision, see [api:epsmac]) and can be printed on demand using std::cout. If the user fools M by making internal \(\mbox{FCN}\) computations in single precision, M will interpret roundoff noise as significant and will usually either fail to find a minimum, or give incorrect values for the parameter errors.; It is therefore recommended to make sure that all computations in \(\mbox{FCN}\), as well as all methods and functions called by \(\mbox{FCN}\), are done in double precision. If for some reason the computations cannot be done to a precision comparable with that expected by M , the user must inform M ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:29790,Integrability,interface,interface,29790,"CN}\), are done in double precision. If for some reason the computations cannot be done to a precision comparable with that expected by M , the user must inform M of this situation with setting a different machine precision via the MnMachinePrecision::setPrecision(double) method.; With reduced precision, the user may find that certain features sensitive to first and second differences (\(\mbox{HESSE}\), \(\mbox{MINOS}\), \(\mbox{CONTOURS}\)) do not work properly, in which case the calculations must be performed in higher precision.; 4 How to use M; [howto:howto]; 4.1 The \(\mbox{FCN}\) Function; [howto:fcn]; The user must always implement a derived class of FCNBase (the “\(\mbox{FCN}\)”) which calculates the function value to be minimized or analyzed. Note that when M is being used through an intermediate package such as HippoDraw @bib-HippoDraw, then the user’s \(\mbox{FCN}\) may be supplied by the this package.; The name of the user’s class to implement the FCNBase interface may be chosen freely (in documentation we give it the generic name \(\mbox{FCN}\)).; 4.1.1 FCNBase::operator()(const std::vector\(<\)double\(>\)&); The meaning of the vector of parameters std::vector\(<\)double\(>\) in the argument of FCNBase::operator() are of course defined by the user, who uses the values of those parameters to calculate their function value. The order and the position of these parameters is strictly the one specified by the user when supplying the starting values for minimization.; The starting values must be specified by the user, either via an std::vector\(<\)double\(>\) or the MnUserParameters (see [api:parameters]) supplied as input to the M minimizers such as VariableMetricMinimizer or MnMigrad (see [api:migrad]). Later values are determined by M as it searches for the minimum or performs whatever analysis is requested by the user.; 4.1.2 FCNBase::up(); [howto:errordef] Returns the value of \(\mbox{up}\) (default value \(= 1.\)), defining parameter errors. M defines pa",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:31262,Integrability,interface,interface,31262,"specified by the user when supplying the starting values for minimization.; The starting values must be specified by the user, either via an std::vector\(<\)double\(>\) or the MnUserParameters (see [api:parameters]) supplied as input to the M minimizers such as VariableMetricMinimizer or MnMigrad (see [api:migrad]). Later values are determined by M as it searches for the minimum or performs whatever analysis is requested by the user.; 4.1.2 FCNBase::up(); [howto:errordef] Returns the value of \(\mbox{up}\) (default value \(= 1.\)), defining parameter errors. M defines parameter errors as the change in parameter value required to change the function value by \(\mbox{up}\). Normally, for chisquared fits \(\mbox{up = 1}\), and for negative log likelihood, \(\mbox{up = 0.5}\).; 4.1.3 \(\mbox{FCN}\) function with gradient; By default first derivatives are calculated numerically by M . In case the user wants to supply their own gradient calculator (e.g. analytical derivatives), they need to implement the FCNGradientBase interface. The size of the output vector is the same as of the input one. The same is true for the position of the elements (first derivative of the function with respect to the \(n_\mathrm{th}\) variable has index \(n\) in the output vector).; 4.2 M parameters; Interaction with the parameters of the function are essential both for M and the user. Different interfaces are provided, depending on the level of interaction.; 4.2.1 Minimal required interface; Starting values of parameters and uncertainties can be provided to M by the user via std::vector\(<\)double\(>\) vector containers. Any interaction with the parameters before minimization (fix, release, limits, etc.) is not possible then.; Optionally if the user wants to provide starting values for the covariance, they have to provide the values in a std::vector\(<\)double\(>\) vector container stored in upper triangular packed storage format (see [api:covariance]).; 4.2.2 MnUserParameters; A more functiona",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:31622,Integrability,interface,interfaces,31622,"equested by the user.; 4.1.2 FCNBase::up(); [howto:errordef] Returns the value of \(\mbox{up}\) (default value \(= 1.\)), defining parameter errors. M defines parameter errors as the change in parameter value required to change the function value by \(\mbox{up}\). Normally, for chisquared fits \(\mbox{up = 1}\), and for negative log likelihood, \(\mbox{up = 0.5}\).; 4.1.3 \(\mbox{FCN}\) function with gradient; By default first derivatives are calculated numerically by M . In case the user wants to supply their own gradient calculator (e.g. analytical derivatives), they need to implement the FCNGradientBase interface. The size of the output vector is the same as of the input one. The same is true for the position of the elements (first derivative of the function with respect to the \(n_\mathrm{th}\) variable has index \(n\) in the output vector).; 4.2 M parameters; Interaction with the parameters of the function are essential both for M and the user. Different interfaces are provided, depending on the level of interaction.; 4.2.1 Minimal required interface; Starting values of parameters and uncertainties can be provided to M by the user via std::vector\(<\)double\(>\) vector containers. Any interaction with the parameters before minimization (fix, release, limits, etc.) is not possible then.; Optionally if the user wants to provide starting values for the covariance, they have to provide the values in a std::vector\(<\)double\(>\) vector container stored in upper triangular packed storage format (see [api:covariance]).; 4.2.2 MnUserParameters; A more functional interface to the user parameters is provided through M via the class MnUserParameters. The user can add parameters giving them a name and starting values. More information can be found in [api:parameters].; 4.2.3 MnUserCovariance; The user can (optionally) provide a covariance matrix as input using the class MnUserCovariance. More information can be found in [api:covariance].; 4.2.4 MnUserParameterState; The M",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:31647,Integrability,depend,depending,31647,"equested by the user.; 4.1.2 FCNBase::up(); [howto:errordef] Returns the value of \(\mbox{up}\) (default value \(= 1.\)), defining parameter errors. M defines parameter errors as the change in parameter value required to change the function value by \(\mbox{up}\). Normally, for chisquared fits \(\mbox{up = 1}\), and for negative log likelihood, \(\mbox{up = 0.5}\).; 4.1.3 \(\mbox{FCN}\) function with gradient; By default first derivatives are calculated numerically by M . In case the user wants to supply their own gradient calculator (e.g. analytical derivatives), they need to implement the FCNGradientBase interface. The size of the output vector is the same as of the input one. The same is true for the position of the elements (first derivative of the function with respect to the \(n_\mathrm{th}\) variable has index \(n\) in the output vector).; 4.2 M parameters; Interaction with the parameters of the function are essential both for M and the user. Different interfaces are provided, depending on the level of interaction.; 4.2.1 Minimal required interface; Starting values of parameters and uncertainties can be provided to M by the user via std::vector\(<\)double\(>\) vector containers. Any interaction with the parameters before minimization (fix, release, limits, etc.) is not possible then.; Optionally if the user wants to provide starting values for the covariance, they have to provide the values in a std::vector\(<\)double\(>\) vector container stored in upper triangular packed storage format (see [api:covariance]).; 4.2.2 MnUserParameters; A more functional interface to the user parameters is provided through M via the class MnUserParameters. The user can add parameters giving them a name and starting values. More information can be found in [api:parameters].; 4.2.3 MnUserCovariance; The user can (optionally) provide a covariance matrix as input using the class MnUserCovariance. More information can be found in [api:covariance].; 4.2.4 MnUserParameterState; The M",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:31710,Integrability,interface,interface,31710,"efining parameter errors. M defines parameter errors as the change in parameter value required to change the function value by \(\mbox{up}\). Normally, for chisquared fits \(\mbox{up = 1}\), and for negative log likelihood, \(\mbox{up = 0.5}\).; 4.1.3 \(\mbox{FCN}\) function with gradient; By default first derivatives are calculated numerically by M . In case the user wants to supply their own gradient calculator (e.g. analytical derivatives), they need to implement the FCNGradientBase interface. The size of the output vector is the same as of the input one. The same is true for the position of the elements (first derivative of the function with respect to the \(n_\mathrm{th}\) variable has index \(n\) in the output vector).; 4.2 M parameters; Interaction with the parameters of the function are essential both for M and the user. Different interfaces are provided, depending on the level of interaction.; 4.2.1 Minimal required interface; Starting values of parameters and uncertainties can be provided to M by the user via std::vector\(<\)double\(>\) vector containers. Any interaction with the parameters before minimization (fix, release, limits, etc.) is not possible then.; Optionally if the user wants to provide starting values for the covariance, they have to provide the values in a std::vector\(<\)double\(>\) vector container stored in upper triangular packed storage format (see [api:covariance]).; 4.2.2 MnUserParameters; A more functional interface to the user parameters is provided through M via the class MnUserParameters. The user can add parameters giving them a name and starting values. More information can be found in [api:parameters].; 4.2.3 MnUserCovariance; The user can (optionally) provide a covariance matrix as input using the class MnUserCovariance. More information can be found in [api:covariance].; 4.2.4 MnUserParameterState; The MnUserParameterState contains the parameters (MnUserParameters) and covariance (MnUserCovariance). The MnUserParameterState h",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:32235,Integrability,interface,interface,32235,"se interface. The size of the output vector is the same as of the input one. The same is true for the position of the elements (first derivative of the function with respect to the \(n_\mathrm{th}\) variable has index \(n\) in the output vector).; 4.2 M parameters; Interaction with the parameters of the function are essential both for M and the user. Different interfaces are provided, depending on the level of interaction.; 4.2.1 Minimal required interface; Starting values of parameters and uncertainties can be provided to M by the user via std::vector\(<\)double\(>\) vector containers. Any interaction with the parameters before minimization (fix, release, limits, etc.) is not possible then.; Optionally if the user wants to provide starting values for the covariance, they have to provide the values in a std::vector\(<\)double\(>\) vector container stored in upper triangular packed storage format (see [api:covariance]).; 4.2.2 MnUserParameters; A more functional interface to the user parameters is provided through M via the class MnUserParameters. The user can add parameters giving them a name and starting values. More information can be found in [api:parameters].; 4.2.3 MnUserCovariance; The user can (optionally) provide a covariance matrix as input using the class MnUserCovariance. More information can be found in [api:covariance].; 4.2.4 MnUserParameterState; The MnUserParameterState contains the parameters (MnUserParameters) and covariance (MnUserCovariance). The MnUserParameterState has to main purposes:. It can be used as input to minimization.; The result of the minimization is transformed into the user representable format by M . For more explanations see [api:state].; 4.3 Input to M; The following input combinations to M are possible:. \(\mbox{FCN}\) + parameters + uncertainties; \(\mbox{FCN}\) with gradient + parameters + uncertainties; \(\mbox{FCN}\) + parameters + covariance; \(\mbox{FCN}\) with gradient + parameters + covariance. For each of these combin",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:33312,Integrability,interface,interface,33312,"an add parameters giving them a name and starting values. More information can be found in [api:parameters].; 4.2.3 MnUserCovariance; The user can (optionally) provide a covariance matrix as input using the class MnUserCovariance. More information can be found in [api:covariance].; 4.2.4 MnUserParameterState; The MnUserParameterState contains the parameters (MnUserParameters) and covariance (MnUserCovariance). The MnUserParameterState has to main purposes:. It can be used as input to minimization.; The result of the minimization is transformed into the user representable format by M . For more explanations see [api:state].; 4.3 Input to M; The following input combinations to M are possible:. \(\mbox{FCN}\) + parameters + uncertainties; \(\mbox{FCN}\) with gradient + parameters + uncertainties; \(\mbox{FCN}\) + parameters + covariance; \(\mbox{FCN}\) with gradient + parameters + covariance. For each of these combinations the user can chose between a minimal required interface (using std::vector containers) for the parameters and uncertainties or a more functional one provided by M . If the user wants to interact with the parameters before minimization (fixing, adding/removing limits), the minimal required interface cannot be used.; 4.3.1 What the user must supply; The user must supply to M. a valid implementation of the FCNBase base class; parameters with their starting values; expected uncertainties on the parameters. The input parameters can be simply defined via an std::vector\(<\)double\(>\), which means that all parameters are variables. If the user wants fix a parameter or put limits on it before minimization, they have to instantiate a MnUserParameters object and then add parameters one by one, giving them a name, value, uncertainty. Once all parameters are added to MnUserParameters, they can fix a parameter or put limits on another one before handing them over to Minuit for minimization.; 4.3.2 What the user can supply; Optionally the user can supply their ow",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:33556,Integrability,interface,interface,33556,"ariance matrix as input using the class MnUserCovariance. More information can be found in [api:covariance].; 4.2.4 MnUserParameterState; The MnUserParameterState contains the parameters (MnUserParameters) and covariance (MnUserCovariance). The MnUserParameterState has to main purposes:. It can be used as input to minimization.; The result of the minimization is transformed into the user representable format by M . For more explanations see [api:state].; 4.3 Input to M; The following input combinations to M are possible:. \(\mbox{FCN}\) + parameters + uncertainties; \(\mbox{FCN}\) with gradient + parameters + uncertainties; \(\mbox{FCN}\) + parameters + covariance; \(\mbox{FCN}\) with gradient + parameters + covariance. For each of these combinations the user can chose between a minimal required interface (using std::vector containers) for the parameters and uncertainties or a more functional one provided by M . If the user wants to interact with the parameters before minimization (fixing, adding/removing limits), the minimal required interface cannot be used.; 4.3.1 What the user must supply; The user must supply to M. a valid implementation of the FCNBase base class; parameters with their starting values; expected uncertainties on the parameters. The input parameters can be simply defined via an std::vector\(<\)double\(>\), which means that all parameters are variables. If the user wants fix a parameter or put limits on it before minimization, they have to instantiate a MnUserParameters object and then add parameters one by one, giving them a name, value, uncertainty. Once all parameters are added to MnUserParameters, they can fix a parameter or put limits on another one before handing them over to Minuit for minimization.; 4.3.2 What the user can supply; Optionally the user can supply their own gradient calculator by implementing the FCNGradientBase interface or supply a full covariance matrix for input if one is available. The covariance matrix can be supplied in",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:34390,Integrability,interface,interface,34390,"meters and uncertainties or a more functional one provided by M . If the user wants to interact with the parameters before minimization (fixing, adding/removing limits), the minimal required interface cannot be used.; 4.3.1 What the user must supply; The user must supply to M. a valid implementation of the FCNBase base class; parameters with their starting values; expected uncertainties on the parameters. The input parameters can be simply defined via an std::vector\(<\)double\(>\), which means that all parameters are variables. If the user wants fix a parameter or put limits on it before minimization, they have to instantiate a MnUserParameters object and then add parameters one by one, giving them a name, value, uncertainty. Once all parameters are added to MnUserParameters, they can fix a parameter or put limits on another one before handing them over to Minuit for minimization.; 4.3.2 What the user can supply; Optionally the user can supply their own gradient calculator by implementing the FCNGradientBase interface or supply a full covariance matrix for input if one is available. The covariance matrix can be supplied in form of a std::vector\(<\)double\(>\) in packed storage format (upper triangular), or in a more user-friendly way by using the interface provided by the MnUserCovariance.; 4.4 Running a M minimization; Two use cases are addressed for minimization:. The user just wants the function to be minimized in one go.; The user wants to minimize the \(\mbox{FCN}\) in several minimization steps, re-using the result of the preceeding minimization in the next step and change parameters in between (fix/release/put limits on them, etc.). How M minimizations can be performed is shown in [example:main].; 4.4.1 Direct usage of minimizers; Minimizers such as the VariableMetricMinimizer are designed as state-less minimization engines, which means that they do not depend on the current function and its parameters. Any \(\mbox{FCN}\) function can be minimized with the ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:34634,Integrability,interface,interface,34634,"t be used.; 4.3.1 What the user must supply; The user must supply to M. a valid implementation of the FCNBase base class; parameters with their starting values; expected uncertainties on the parameters. The input parameters can be simply defined via an std::vector\(<\)double\(>\), which means that all parameters are variables. If the user wants fix a parameter or put limits on it before minimization, they have to instantiate a MnUserParameters object and then add parameters one by one, giving them a name, value, uncertainty. Once all parameters are added to MnUserParameters, they can fix a parameter or put limits on another one before handing them over to Minuit for minimization.; 4.3.2 What the user can supply; Optionally the user can supply their own gradient calculator by implementing the FCNGradientBase interface or supply a full covariance matrix for input if one is available. The covariance matrix can be supplied in form of a std::vector\(<\)double\(>\) in packed storage format (upper triangular), or in a more user-friendly way by using the interface provided by the MnUserCovariance.; 4.4 Running a M minimization; Two use cases are addressed for minimization:. The user just wants the function to be minimized in one go.; The user wants to minimize the \(\mbox{FCN}\) in several minimization steps, re-using the result of the preceeding minimization in the next step and change parameters in between (fix/release/put limits on them, etc.). How M minimizations can be performed is shown in [example:main].; 4.4.1 Direct usage of minimizers; Minimizers such as the VariableMetricMinimizer are designed as state-less minimization engines, which means that they do not depend on the current function and its parameters. Any \(\mbox{FCN}\) function can be minimized with the same minimizer. The interface is restricted to minimization and no parameter interaction is possible.; 4.4.2 Using an application (MnMigrad); MnMigrad uses the VariableMetricMinimizer for minimization but a",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:35260,Integrability,depend,depend,35260,"before handing them over to Minuit for minimization.; 4.3.2 What the user can supply; Optionally the user can supply their own gradient calculator by implementing the FCNGradientBase interface or supply a full covariance matrix for input if one is available. The covariance matrix can be supplied in form of a std::vector\(<\)double\(>\) in packed storage format (upper triangular), or in a more user-friendly way by using the interface provided by the MnUserCovariance.; 4.4 Running a M minimization; Two use cases are addressed for minimization:. The user just wants the function to be minimized in one go.; The user wants to minimize the \(\mbox{FCN}\) in several minimization steps, re-using the result of the preceeding minimization in the next step and change parameters in between (fix/release/put limits on them, etc.). How M minimizations can be performed is shown in [example:main].; 4.4.1 Direct usage of minimizers; Minimizers such as the VariableMetricMinimizer are designed as state-less minimization engines, which means that they do not depend on the current function and its parameters. Any \(\mbox{FCN}\) function can be minimized with the same minimizer. The interface is restricted to minimization and no parameter interaction is possible.; 4.4.2 Using an application (MnMigrad); MnMigrad uses the VariableMetricMinimizer for minimization but allows as well for parameter interaction by the user. An instance of MnMigrad is specific to the current \(\mbox{FCN}\) and user parameters. Any parameter interaction of the user between two minimization steps will make use of the result of the preceeding minimization in an optimal way. The interface for parameters (see [api:parameters], [api:covariance] and [api:state]) is forwardedin MnMigrad.; 4.4.3 Subsequent minimizations; M takes care that all information is treated in an optimal and correct way if the user interacts with the parameters between two minimizations. MnMigrad retains the result of the last minimization and uses ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:35385,Integrability,interface,interface,35385,"ance matrix for input if one is available. The covariance matrix can be supplied in form of a std::vector\(<\)double\(>\) in packed storage format (upper triangular), or in a more user-friendly way by using the interface provided by the MnUserCovariance.; 4.4 Running a M minimization; Two use cases are addressed for minimization:. The user just wants the function to be minimized in one go.; The user wants to minimize the \(\mbox{FCN}\) in several minimization steps, re-using the result of the preceeding minimization in the next step and change parameters in between (fix/release/put limits on them, etc.). How M minimizations can be performed is shown in [example:main].; 4.4.1 Direct usage of minimizers; Minimizers such as the VariableMetricMinimizer are designed as state-less minimization engines, which means that they do not depend on the current function and its parameters. Any \(\mbox{FCN}\) function can be minimized with the same minimizer. The interface is restricted to minimization and no parameter interaction is possible.; 4.4.2 Using an application (MnMigrad); MnMigrad uses the VariableMetricMinimizer for minimization but allows as well for parameter interaction by the user. An instance of MnMigrad is specific to the current \(\mbox{FCN}\) and user parameters. Any parameter interaction of the user between two minimization steps will make use of the result of the preceeding minimization in an optimal way. The interface for parameters (see [api:parameters], [api:covariance] and [api:state]) is forwardedin MnMigrad.; 4.4.3 Subsequent minimizations; M takes care that all information is treated in an optimal and correct way if the user interacts with the parameters between two minimizations. MnMigrad retains the result of the last minimization and uses this as input for the next step. Between two minimization requests to MnMigrad the user can fix or release parameters, put limits on them or remove limits from them. Each instance of a MnMigrad object maintains its ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:35862,Integrability,interface,interface,35862,"t of the preceeding minimization in the next step and change parameters in between (fix/release/put limits on them, etc.). How M minimizations can be performed is shown in [example:main].; 4.4.1 Direct usage of minimizers; Minimizers such as the VariableMetricMinimizer are designed as state-less minimization engines, which means that they do not depend on the current function and its parameters. Any \(\mbox{FCN}\) function can be minimized with the same minimizer. The interface is restricted to minimization and no parameter interaction is possible.; 4.4.2 Using an application (MnMigrad); MnMigrad uses the VariableMetricMinimizer for minimization but allows as well for parameter interaction by the user. An instance of MnMigrad is specific to the current \(\mbox{FCN}\) and user parameters. Any parameter interaction of the user between two minimization steps will make use of the result of the preceeding minimization in an optimal way. The interface for parameters (see [api:parameters], [api:covariance] and [api:state]) is forwardedin MnMigrad.; 4.4.3 Subsequent minimizations; M takes care that all information is treated in an optimal and correct way if the user interacts with the parameters between two minimizations. MnMigrad retains the result of the last minimization and uses this as input for the next step. Between two minimization requests to MnMigrad the user can fix or release parameters, put limits on them or remove limits from them. Each instance of a MnMigrad object maintains its own state and one can have multiple instances of MnMigrad objects.; 4.4.4 M fails to find a minimum; If M fails to find a minimum, the user is notified by a warning message issued by M when running into troubles. Problems can be:. a bug in M; an error in the \(\mbox{FCN}\); a highly difficult problem (usually strong correlations among parameters); floating–point precision. 4.5 The output from minimization; 4.5.1 The FunctionMinimum; The output of the minimizers is the FunctionMinimum. ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:36588,Integrability,message,message,36588," but allows as well for parameter interaction by the user. An instance of MnMigrad is specific to the current \(\mbox{FCN}\) and user parameters. Any parameter interaction of the user between two minimization steps will make use of the result of the preceeding minimization in an optimal way. The interface for parameters (see [api:parameters], [api:covariance] and [api:state]) is forwardedin MnMigrad.; 4.4.3 Subsequent minimizations; M takes care that all information is treated in an optimal and correct way if the user interacts with the parameters between two minimizations. MnMigrad retains the result of the last minimization and uses this as input for the next step. Between two minimization requests to MnMigrad the user can fix or release parameters, put limits on them or remove limits from them. Each instance of a MnMigrad object maintains its own state and one can have multiple instances of MnMigrad objects.; 4.4.4 M fails to find a minimum; If M fails to find a minimum, the user is notified by a warning message issued by M when running into troubles. Problems can be:. a bug in M; an error in the \(\mbox{FCN}\); a highly difficult problem (usually strong correlations among parameters); floating–point precision. 4.5 The output from minimization; 4.5.1 The FunctionMinimum; The output of the minimizers is the FunctionMinimum. The FunctionMinimum contains the result of the minimization in both internal parameter representation and external parameter representation.; 4.5.2 User representable format: MnUserParameterState; On request, the result of the minimization is transformed into a user representable format for parameters and errors, the MnUserParameterState.; 4.5.3 Access values, errors, covariance; The result can be accessed via methods like MnUserParameterState::value(unsigned int n) and MnUserParameterState::error(unsigned int n), where \(n\) is the index of the parameter in the list of parameters defined by the user.; 4.5.4 Printout of the result; The Function",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:37819,Integrability,message,message,37819,"nt precision. 4.5 The output from minimization; 4.5.1 The FunctionMinimum; The output of the minimizers is the FunctionMinimum. The FunctionMinimum contains the result of the minimization in both internal parameter representation and external parameter representation.; 4.5.2 User representable format: MnUserParameterState; On request, the result of the minimization is transformed into a user representable format for parameters and errors, the MnUserParameterState.; 4.5.3 Access values, errors, covariance; The result can be accessed via methods like MnUserParameterState::value(unsigned int n) and MnUserParameterState::error(unsigned int n), where \(n\) is the index of the parameter in the list of parameters defined by the user.; 4.5.4 Printout of the result; The FunctionMinimum can be printed on the output simply via std::cout. It will print both the internal and external state, that is parameters, errors and the covariance matrix (if available). It also tells the user if M did converge or not by issuing an appropriate message. If a covariance matrix is available, the global correlation coefficients are printed as well.; 4.5.5 Global correlation coefficients; The global correlation coefficient for parameter \(n\) is a number between zero and one which gives the correlation between parameter \(n\) and that linear combination of all other parameters which is most strongly correlated with \(n\).; 5 M application programming interface (API); [api:api]; 5.1 FunctionMinimum; [api:fm] The FunctionMinimum is the output of the minimizers and contains the minimization result. The state at the minimum is available both in internal and external representations. For the external representations the return methods. FunctionMinimum::userState(),; FunctionMinimum::userParameters() and; FunctionMinimum::userCovariance(). are provided. These can be used as new input to a new minimization after some manipulation. The parameters and/or the FunctionMinimum can be printed using std::cout.;",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:38229,Integrability,interface,interface,38229,"he MnUserParameterState.; 4.5.3 Access values, errors, covariance; The result can be accessed via methods like MnUserParameterState::value(unsigned int n) and MnUserParameterState::error(unsigned int n), where \(n\) is the index of the parameter in the list of parameters defined by the user.; 4.5.4 Printout of the result; The FunctionMinimum can be printed on the output simply via std::cout. It will print both the internal and external state, that is parameters, errors and the covariance matrix (if available). It also tells the user if M did converge or not by issuing an appropriate message. If a covariance matrix is available, the global correlation coefficients are printed as well.; 4.5.5 Global correlation coefficients; The global correlation coefficient for parameter \(n\) is a number between zero and one which gives the correlation between parameter \(n\) and that linear combination of all other parameters which is most strongly correlated with \(n\).; 5 M application programming interface (API); [api:api]; 5.1 FunctionMinimum; [api:fm] The FunctionMinimum is the output of the minimizers and contains the minimization result. The state at the minimum is available both in internal and external representations. For the external representations the return methods. FunctionMinimum::userState(),; FunctionMinimum::userParameters() and; FunctionMinimum::userCovariance(). are provided. These can be used as new input to a new minimization after some manipulation. The parameters and/or the FunctionMinimum can be printed using std::cout.; 5.1.1 isValid(); In general, if the method bool FunctionMinimum::isValid() returns “true”, the minimizer did find a minimum without running into troubles. However, in some cases it may happen that a minimum cannot be found, then the return value will be “false”. Reasons for the minimization to fail are. the number of allowed function calls has been exhausted; the minimizer could not improve the values of the parameters (and knowing that i",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:43690,Integrability,message,messages,43690," is \(\mbox{eps}\). The method can be used to override M ’s own determination, when the user knows that the \(\mbox{FCN}\) function value is not calculated to the nominal machine accuracy. Typical values of \(\mbox{eps}\) are between \(10^{-5}\) and \(10^{-14}\).; 5.6 MnMigrad and VariableMetricMinimizer; [api:migrad]; MnMigrad provides minimization of the function by the method of \(\mbox{MIGRAD}\), the most efficient and complete single method, recommended for general functions (see also [api:minimize]), and the functionality for parameters interaction. It also retains the result from the last minimization in case the user may want to do subsequent minimization steps with parameter interactions in between the minimization requests. The minimization is done by the VariableMetricMinimizer. Minimization of the function can be done by directly using the VariableMetricMinimizer if no parameters interaction is required. The minimization produces as a by-product the error matrix of the parameters, which is usually reliable unless warning messages are produced.; 5.6.1 MnMigrad(const FCNBase&, const std::vector\(<\)double\(>\)&, const std::vector\(<\)double\(>\)&, unsigned int); Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.6.2 MnMigrad(const FCNBase&, const MnUserParameters&, unsigned int); Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.6.3 MnMigrad(const FCNBase&, const MnUserParameterState&, const MnStrategy&); Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.6.4 operator(); [api:migradop] MnMigrad::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. The optional argument \(\mbox{maxfcn}\) specifies the (approximate) maximum numb",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:43869,Integrability,interface,interface,43869,"ical values of \(\mbox{eps}\) are between \(10^{-5}\) and \(10^{-14}\).; 5.6 MnMigrad and VariableMetricMinimizer; [api:migrad]; MnMigrad provides minimization of the function by the method of \(\mbox{MIGRAD}\), the most efficient and complete single method, recommended for general functions (see also [api:minimize]), and the functionality for parameters interaction. It also retains the result from the last minimization in case the user may want to do subsequent minimization steps with parameter interactions in between the minimization requests. The minimization is done by the VariableMetricMinimizer. Minimization of the function can be done by directly using the VariableMetricMinimizer if no parameters interaction is required. The minimization produces as a by-product the error matrix of the parameters, which is usually reliable unless warning messages are produced.; 5.6.1 MnMigrad(const FCNBase&, const std::vector\(<\)double\(>\)&, const std::vector\(<\)double\(>\)&, unsigned int); Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.6.2 MnMigrad(const FCNBase&, const MnUserParameters&, unsigned int); Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.6.3 MnMigrad(const FCNBase&, const MnUserParameterState&, const MnStrategy&); Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.6.4 operator(); [api:migradop] MnMigrad::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. The optional argument \(\mbox{maxfcn}\) specifies the (approximate) maximum number of function calls after which the calculation will be stopped even if it has not yet converged. The optional argument \(\mbox{tolerance}\) specifies the required tolerance on the function v",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:44119,Integrability,interface,interface,44119,"plete single method, recommended for general functions (see also [api:minimize]), and the functionality for parameters interaction. It also retains the result from the last minimization in case the user may want to do subsequent minimization steps with parameter interactions in between the minimization requests. The minimization is done by the VariableMetricMinimizer. Minimization of the function can be done by directly using the VariableMetricMinimizer if no parameters interaction is required. The minimization produces as a by-product the error matrix of the parameters, which is usually reliable unless warning messages are produced.; 5.6.1 MnMigrad(const FCNBase&, const std::vector\(<\)double\(>\)&, const std::vector\(<\)double\(>\)&, unsigned int); Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.6.2 MnMigrad(const FCNBase&, const MnUserParameters&, unsigned int); Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.6.3 MnMigrad(const FCNBase&, const MnUserParameterState&, const MnStrategy&); Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.6.4 operator(); [api:migradop] MnMigrad::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. The optional argument \(\mbox{maxfcn}\) specifies the (approximate) maximum number of function calls after which the calculation will be stopped even if it has not yet converged. The optional argument \(\mbox{tolerance}\) specifies the required tolerance on the function value at the minimum. The default \(\mbox{tolerance}\) value is \(0.1\), and the minimization will stop when the estimated vertical distance to the minimum (\(\mbox{EDM}\)) is less than \(0.001*\)\(\mbox{tolerance}\)\(*\)\(\mbox{up}\) (see ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:45229,Integrability,interface,interface,45229,"tegy can be specified.; 5.6.3 MnMigrad(const FCNBase&, const MnUserParameterState&, const MnStrategy&); Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.6.4 operator(); [api:migradop] MnMigrad::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. The optional argument \(\mbox{maxfcn}\) specifies the (approximate) maximum number of function calls after which the calculation will be stopped even if it has not yet converged. The optional argument \(\mbox{tolerance}\) specifies the required tolerance on the function value at the minimum. The default \(\mbox{tolerance}\) value is \(0.1\), and the minimization will stop when the estimated vertical distance to the minimum (\(\mbox{EDM}\)) is less than \(0.001*\)\(\mbox{tolerance}\)\(*\)\(\mbox{up}\) (see [howto:errordef]).; 5.6.5 Parameter interaction; MnMigrad retains the result after each minimization (MnUserParameterStae, see [api:state]) and forwards the interface.; 5.6.6 VariableMetricMinimizer(); The VariableMetricMinimizer is instantiated using default constructor.; 5.6.7 minimize(const FCNBase&, …); The VariableMetricMinimizer provides several overloaded methods minimize with return value FunctionMinimum. Together with the user \(\mbox{FCN}\) (either an implementation of FCNBase or FCNGradientBase) the user has to give as input the parameters with starting values in one of the defined formats (std::vector\(<\)double\(>\), MnUserParameters or MnUserParameterState).; 5.7 MnMinimize and CombinedMinimizer; [api:minimize]; Causes minimization of the function by the method of \(\mbox{MIGRAD}\), as does the MnMigrad class, but switches to the \(\mbox{SIMPLEX}\) method if \(\mbox{MIGRAD}\) fails to converge. Constructor arguments, methods arguments and names of methods are the same as for MnMigrad or MnSimplex and VariableMetricMinimizer or SimplexMinimizer.; 5.8 MnMinos; [api:mi",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:50400,Integrability,interface,interface,50400,"gh the \(\mbox{SCAN}\) method is not intended for minimization it can be used as a minimizer in its most primitive form.; 5.11 MnSimplex and SimplexMinimizer; [api:simplex]; \(\mbox{SIMPLEX}\) is a function minimization method using the simplex method of Nelder and Mead. MnSimplex provides minimization of the function by the method of \(\mbox{SIMPLEX}\) and the functionality for parameters interaction. It also retains the result from the last minimization in case the user may want to do subsequent minimization steps with parameter interactions in between the minimization requests. The minimization is done by the SimplexMinimizer. Minimization of the function can be done by directly using the SimplexMinimizer if no parameters interaction is required. As \(\mbox{SIMPLEX}\) is a stepping method it does not produce a covariance matrix.; 5.11.1 MnSimplex(const FCNBase&, const std::vector\(<\)double\(>\)&,. const std::vector\(<\)double\(>\)&, unsigned int) ###; Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.11.2 MnSimplex(const FCNBase&, const MnUserParameters&,. unsigned int) ###; Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.11.3 MnSimplex(const FCNBase&, const MnUserParameterState&,. const MnStrategy&) ###; Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.11.4 operator(); MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. Minimization terminates either when the function has been called (approximately) \(\mbox{maxfcn}\) times, or when the estimated vertical distance to minimum (\(\mbox{EDM}\)) is less than \(\mbox{tolerance*up}\). The default value of \(\mbox{tolerance}\) is \(\mbox{0.1}\). (see [howto:errordef]).; 5.",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:50657,Integrability,interface,interface,50657,"plex method of Nelder and Mead. MnSimplex provides minimization of the function by the method of \(\mbox{SIMPLEX}\) and the functionality for parameters interaction. It also retains the result from the last minimization in case the user may want to do subsequent minimization steps with parameter interactions in between the minimization requests. The minimization is done by the SimplexMinimizer. Minimization of the function can be done by directly using the SimplexMinimizer if no parameters interaction is required. As \(\mbox{SIMPLEX}\) is a stepping method it does not produce a covariance matrix.; 5.11.1 MnSimplex(const FCNBase&, const std::vector\(<\)double\(>\)&,. const std::vector\(<\)double\(>\)&, unsigned int) ###; Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.11.2 MnSimplex(const FCNBase&, const MnUserParameters&,. unsigned int) ###; Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.11.3 MnSimplex(const FCNBase&, const MnUserParameterState&,. const MnStrategy&) ###; Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.11.4 operator(); MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. Minimization terminates either when the function has been called (approximately) \(\mbox{maxfcn}\) times, or when the estimated vertical distance to minimum (\(\mbox{EDM}\)) is less than \(\mbox{tolerance*up}\). The default value of \(\mbox{tolerance}\) is \(\mbox{0.1}\). (see [howto:errordef]).; 5.11.5 Parameter interaction; MnSimplex retains the result after each minimization (MnUserParameterStae, see [api:state]) and forwards the interface for parameter interaction.; 5.11.6 SimplexMinimizer(); The SimplexMinimizer() is instantiated",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:51530,Integrability,interface,interface,51530,"ptional the strategy level in MnStrategy can be specified.; 5.11.2 MnSimplex(const FCNBase&, const MnUserParameters&,. unsigned int) ###; Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.11.3 MnSimplex(const FCNBase&, const MnUserParameterState&,. const MnStrategy&) ###; Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.11.4 operator(); MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. Minimization terminates either when the function has been called (approximately) \(\mbox{maxfcn}\) times, or when the estimated vertical distance to minimum (\(\mbox{EDM}\)) is less than \(\mbox{tolerance*up}\). The default value of \(\mbox{tolerance}\) is \(\mbox{0.1}\). (see [howto:errordef]).; 5.11.5 Parameter interaction; MnSimplex retains the result after each minimization (MnUserParameterStae, see [api:state]) and forwards the interface for parameter interaction.; 5.11.6 SimplexMinimizer(); The SimplexMinimizer() is instantiated using default constructor.; 5.11.7 minimize(const FCNBase&, …); The SimplexMinimizer provides several overloaded methods minimize with return value FunctionMinimum. Together with the user \(\mbox{FCN}\) (either an implementation of FCNBase or FCNGradientBase) the user has to give as input the parameters with starting values in one of the defined formats (std::vector\(<\)double\(>\), MnUserParameters or MnUserParameterState).; 5.12 MnStrategy; [api:strategy] Sets the strategy to be used in calculating first and second derivatives and in certain minimization methods. In general, low values of \(\mbox{level}\) mean fewer function calls and high values mean more reliable minimization. Currently allowed values are 0 (low), 1 (default), and 2 (high).; 5.12.1 MnStrategy(); Default constructor, sets all settings according to \(\mbox{level}\)$ ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:62476,Integrability,depend,depends,62476,"ersal, so users were encouraged to find the one that worked best for them. Since then, algorithms have improved considerably, but M still offers several, mostly so that old users will not feel cheated, but also to help the occasional user who does manage to defeat the best algorithms. M currently offers four applications which can be used to find a smaller function value, in addition to \(\mbox{MINOS}\), which will retain a smaller function value if it stumbles on one unexpectedly. The objects which can be used to minimize are:; 6.1.1 \(\mbox{MIGRAD}\); This is the best minimizer for nearly all functions. It is a variable-metric method with inexact line search, a stable metric updating scheme, and checks for positive-definiteness. It will run faster if you instantiate it with a low–level MnStrategy and will be more reliable if you instantiate it with a high–level MnStrategy (although the latter option may not help much). Its main weakness is that it depends heavily on knowledge of the first derivatives, and fails miserably if they are very inaccurate. If first derivatives are a problem, they can be calculated analytically inside \(\mbox{FCN}\) (see [howto:fcn]) or if this is not feasible, the user can try to improve the accuracy of M ’s numerical approximation by adjusting values of MnMachinePrecision and/or MnStrategy (see [api:epsmac] and [api:strategy]).; 6.1.2 \(\mbox{MINIMIZE}\); This is equivalent to \(\mbox{MIGRAD}\), except that if \(\mbox{MIGRAD}\) fails, it reverts to \(\mbox{SIMPLEX}\) and then calls \(\mbox{MIGRAD}\) again.; 6.1.3 \(\mbox{SCAN}\); This is not intended to minimize, and just scans the function, one parameter at a time. It does however retain the best value after each scan, so it does some sort of highly primitive minimization.; 6.1.4 \(\mbox{SIMPLEX}\); This genuine multidimensional minimization routine is usually much slower than \(\mbox{MIGRAD}\), but it does not use first derivatives, so it should not be so sensitive to the precision of ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:63366,Integrability,rout,routine,63366,"is that it depends heavily on knowledge of the first derivatives, and fails miserably if they are very inaccurate. If first derivatives are a problem, they can be calculated analytically inside \(\mbox{FCN}\) (see [howto:fcn]) or if this is not feasible, the user can try to improve the accuracy of M ’s numerical approximation by adjusting values of MnMachinePrecision and/or MnStrategy (see [api:epsmac] and [api:strategy]).; 6.1.2 \(\mbox{MINIMIZE}\); This is equivalent to \(\mbox{MIGRAD}\), except that if \(\mbox{MIGRAD}\) fails, it reverts to \(\mbox{SIMPLEX}\) and then calls \(\mbox{MIGRAD}\) again.; 6.1.3 \(\mbox{SCAN}\); This is not intended to minimize, and just scans the function, one parameter at a time. It does however retain the best value after each scan, so it does some sort of highly primitive minimization.; 6.1.4 \(\mbox{SIMPLEX}\); This genuine multidimensional minimization routine is usually much slower than \(\mbox{MIGRAD}\), but it does not use first derivatives, so it should not be so sensitive to the precision of the \(\mbox{FCN}\) calculations, and is even rather robust with respect to gross fluctuations in the function value. However, it gives no reliable information about parameter errors, no information whatsoever about parameter correlations, and worst of all cannot be expected to converge accurately to the minimum in a finite time. Its estimate of the expected distance to the minimum \(\mbox{EDM}\) is largely fantasy, so it would not even know if it did converge.; 6.2 Floating point precision; M figures out at execution time the machine precision [api:epsmac], and assumes that \(\mbox{FCN}\) provides about the same precision. That means not just the length of the numbers used and returned by \(\mbox{FCN}\), but the actual mathematical accuracy of the calculations. Section [install:epsmac] describes what to do if this is not the case.; 6.3 Parameter limits; Putting limits (absolute bounds) on the allowed values for a given parameter, causes M",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:70418,Integrability,message,messages,70418,"evels, see (in order of increasing complexity and completeness):. “Interpretation of the Errors on Parameters”, see Part 3 of this write-up.; “Determining the Statistical Significance of Experimental Results”@bib-MIN81.; “Statistical Methods in Experimental Physics”@bib-EADIE. 6.5.2 The reliability of M error estimates; M always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a \(\mbox{MIGRAD}\) or \(\mbox{HESSE}\) step, the errors are usually quite accurate, unless there has been a problem. If no mitigating adjective is given in the printout of the errors, then at least M believes the errors are accurate, although there is always a small chance that M has been fooled. Some visible signs that M may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of \(\mbox{EDM}\) too big. For a “normal” minimization, after \(\mbox{MIGRAD}\), the value of \(\mbox{EDM}\) is usually more than three orders of magnitude smaller than \(\mbox{up}\), unless a looser tolerance has been specified.; Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one which has been badly parametrized so that individual errors are not very meaningful because they are so highly correlated.; Parameter at limit. This condition, signalled by a M warning message, may make both the function minimum and parameter errors unreliable. See section [answer:right-errors], Getting the right parameter errors with limits. The best way to be absolutely sure of the errors, is to use “independent” calculations and compare them, ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:71179,Integrability,message,message,71179,"ective is given in the printout of the errors, then at least M believes the errors are accurate, although there is always a small chance that M has been fooled. Some visible signs that M may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of \(\mbox{EDM}\) too big. For a “normal” minimization, after \(\mbox{MIGRAD}\), the value of \(\mbox{EDM}\) is usually more than three orders of magnitude smaller than \(\mbox{up}\), unless a looser tolerance has been specified.; Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one which has been badly parametrized so that individual errors are not very meaningful because they are so highly correlated.; Parameter at limit. This condition, signalled by a M warning message, may make both the function minimum and parameter errors unreliable. See section [answer:right-errors], Getting the right parameter errors with limits. The best way to be absolutely sure of the errors, is to use “independent” calculations and compare them, or compare the calculated errors with a picture of the function if possible. For example, if there is only one free parameter, \(\mbox{SCAN}\) allows the user to verify approximately the function curvature. Similarly, if there are only two free parameters, use \(\mbox{CONTOURS}\). To verify a full error matrix, compare the results of \(\mbox{MIGRAD}\) with those (calculated afterward) by \(\mbox{HESSE}\), which uses a different method. And of course the most reliable and most expensive technique, which must be used if asymmetric errors are required, is \(\mbox{MINOS}\).; 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; \(\mbox{MIGRAD}\) uses its current estimate of the covariance matrix of the function to determine the current",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:73532,Integrability,depend,dependence,73532,") are guaranteed to be downhill only if the covariance matrix is positive–definite, so in case this is not true, it makes a positive–definite approximation by adding an appropriate constant along the diagonal as determined by the eigenvalues of the matrix. Theoretically, the covariance matrix for a “physical” function must be positive–definite at the minimum, although it may not be so for all points far away from the minimum, even for a well–determined physical problem. Therefore, if \(\mbox{MIGRAD}\) reports that it has found a non-positive–definite covariance matrix, this may be a sign of one or more of the following:. A non–physical region. On its way to the minimum, \(\mbox{MIGRAD}\) may have traversed a region which has unphysical behaviour, which is of course not a serious problem as long as it recovers and leaves such a region.; An underdetermined problem. If the matrix is not positive–definite even at the minimum, this may mean that the solution is not well–defined, for example that there are more unknowns than there are data points, or that the parametrization of the fit contains a linear dependence. If this is the case, then M (or any other program) cannot solve your problem uniquely, and the error matrix will necessarily be largely meaningless, so the user must remove the under-determinedness by reformulating the parametrization. M cannot do this itself, but it can provide some hints (contours, global correlation coefficients, eigenvalues) which can help the clever user to find out what is wrong.; Numerical inaccuracies. It is possible that the apparent lack of positive–definiteness is in fact only due to excessive roundoff errors in numerical calculations, either in \(\mbox{FCN}\) or in M . This is unlikely in general, but becomes more likely if the number of free parameters is very large, or if the parameters are badly scaled (not all of the same order of magnitude), and correlations are also large. In any case, whether the non–positive–definiteness is r",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:75413,Integrability,depend,dependence,75413," numerical is largely irrelevant, since in both cases the error matrix will be unreliable and the minimum suspicious. 6.7 Additional trouble–shooting; When M just doesn’t work, some of the more common causes are:. Precision mismatch. Make sure your \(\mbox{FCN}\) uses internally the same precision as M .; If the problem is only one of precision, and not of word length mismatch, an appropriate MnMachinePrecision::setPrecision() may fix it.; Trivial bugs in \(\mbox{FCN}\). The possibilities for bugs are numerous. Probably the most common among physicists inexperienced in is the confusion between double and int types, which you can sometimes get away with, but not always. 3 M can spot some trivial bugs itself, and issues a warning when it detects an unusual \(\mbox{FCN}\) behaviour. Such a warning should be taken seriously.; M also offers some tools (especially \(\mbox{SCAN}\)) which can help the user to find trivial bugs.; An ill–posed problem. For questions of parameter dependence, see the discussion above on postive–definiteness. Other mathematical problems which can arise are: excessive numerical roundoff — be especially careful of exponential and factorial functions which get big very quickly and lose accuracy; starting too far from the solution — the function may have unphysical local minima, especially at infinity in some variables; incorrect normalization — in likelihood functions, the probability distributions must be normalized or at least have an integral which is independent of the values of the variable parameters.; A bug in M . This is unlikely, but it happens. If a bug is suspected, and all other possible causes can be eliminated, please try to save a copy of the input and output files, listing of \(\mbox{FCN}\), and other information that may be relevant, and send them to \(\mbox{fred.james@cern.ch}\). 7 A complete example; [example:example]; Here a full example of a fit is presented, following the example DemoGaussSim.cpp.; 7.1 The user’s \(\mbox{FCN}\)",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:79776,Integrability,interface,interface,79776,"nclude ""GaussDataGen.h""; #include ""Minuit/FunctionMinimum.h""; #include ""Minuit/MnUserParameterState.h""; #include ""Minuit/MinimumPrint.h""; #include ""Minuit/MnMigrad.h""; #include ""Minuit/MnMinos.h""; #include ""Minuit/MnContours.h""; #include ""Minuit/MnPlot.h"". #include <iostream>. int main() {. // generate the data (100 data points); GaussDataGen gdg(100);. std::vector<double> pos = gdg.positions();; std::vector<double> meas = gdg.measurements();; std::vector<double> var = gdg.variances();. // create FCN function; GaussFcn theFCN(meas, pos, var);. // create initial starting values for parameters; double x = 0.;; double x2 = 0.;; double norm = 0.;; double dx = pos[1]-pos[0];; double area = 0.;; for(unsigned int i = 0; i < meas.size(); i++) {; norm += meas[i];; x += (meas[i]*pos[i]);; x2 += (meas[i]*pos[i]*pos[i]);; area += dx*meas[i];; }; double mean = x/norm;; double rms2 = x2/norm - mean*mean;; double rms = rms2 > 0. ? sqrt(rms2) : 1.;. {; // demonstrate minimal required interface for minimization; // create Minuit parameters without names. // starting values for parameters; std::vector<double> init_par;; init_par.push_back(mean);; init_par.push_back(rms);; init_par.push_back(area);. // starting values for initial uncertainties; std::vector<double> init_err;; init_err.push_back(0.1);; init_err.push_back(0.1);; init_err.push_back(0.1);. // create minimizer (default constructor); VariableMetricMinimizer theMinimizer;. // minimize; FunctionMinimum min =; theMinimizer.minimize(theFCN, init_par, init_err);. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate standard minimization using MIGRAD; // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create MIGRAD minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate full interaction with parameters ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:84428,Integrability,interface,interface,84428,"td::endl;; std::cout<<""par1: ""; <<min.userState().value(1); <<"" ""<<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""; <<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""<<e2.second<<std::endl;; }; }. {; // demonstrate how to use the CONTOURs. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create contours factory with FCN and minimum; MnContours contours(theFCN, min);. // 70% confidence level for 2 parameters contour; // around the minimum; theFCN.setErrorDef(2.41);; std::vector<std::pair<double,double> > cont =; contours(0, 1, 20);. // 95% confidence level for 2 parameters contour; theFCN.setErrorDef(5.99);; std::vector<std::pair<double,double> > cont4 =; contours(0, 1, 20);. // plot the contours; MnPlot plot;; cont4.insert(cont4.end(), cont.begin(), cont.end());; plot(min.userState().value(""mean""),; min.userState().value(""sigma""),; cont4);; }. return 0;; };. ROOT @bib-ROOT uses its own version of the Fortran M when this manual was written. However an interface for this version exists and the library can be loaded dynamically on demand↩; The internal error matrix maintained by M is transformed for the user into external coordinates, but the numbering of rows and columns is of course still according to internal parameter numbering, since one does not want rows and columns corresponding to parameters which are not variable. The transformation therefore affects only parameters with limits; if there are no limits, internal and external error matrices are the same.↩; For example, if \(\mbox{a}\) and \(\mbox{b}\) are double precision variables, the statement \(\mbox{a = 2*b}\) is not good programming, but happens to do what the user probably intended, whereas the statement \(\mbox{a = b + 2/3}\) almost certainly will not do what the user intended.↩. ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:3939,Modifiability,variab,variable,3939,"etters (e.g. \(\mbox{MIGRAD}\), \(\mbox{MINOS}\), \(\mbox{CONTOURS}\)), the corresponding names of the classes are written using sans-serif font type (MnMigrad, MnMinos, MnContours).; 2 Introduction: M basic concepts; [sec:intro]; 2.1 The organization of M; The M package acts on a multiparameter objective function which is called — for historical reasons — the \(\mbox{FCN}\) function (see [howto:fcn]). This function is usually a chisquared or a log–likelihood, but it could also be a mathematical function. The \(\mbox{FCN}\) function needs to be written in for which M defines the pure abstract base class FCNBase as interface. The user must define and implement the \(\mbox{FCN}\) function in a derived class from FCNBase. Sometimes this is done by an intermediate program such as HippoDraw@bib-HippoDraw, in which case M is being used under the control of such an intermediate program1. The value of the \(\mbox{FCN}\) function will in general depend on one or more variable parameters whose meaning is defined by the user (or by the intermediate program), but whose trial values are determined by M .; To take a simple example, suppose the problem is to fit a polynomial through a set of data points. Then the user would write a \(\mbox{FCN}\) which calculates the \(\chi^2\) between a polynomial and the data; the variable parameters of \(\mbox{FCN}\) would be the coefficients of the polynomials. Using objects for minimization from M , the user would request M to minimize the \(\mbox{FCN}\) with respect to the parameters, that is, find those values of the coefficients which give the lowest value of chisquare.; The user must therefore supply, in addition to the function to be analyzed, via a set or sequence of M applications the instructions which analysis is wanted. The instructions are coded in in the calling program (main.cpp), which allows looping, conditional execution, and all the other possibilities of , but not interactivity, since it must be compiled before execution.; 2.",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:4289,Modifiability,variab,variable,4289,"function which is called — for historical reasons — the \(\mbox{FCN}\) function (see [howto:fcn]). This function is usually a chisquared or a log–likelihood, but it could also be a mathematical function. The \(\mbox{FCN}\) function needs to be written in for which M defines the pure abstract base class FCNBase as interface. The user must define and implement the \(\mbox{FCN}\) function in a derived class from FCNBase. Sometimes this is done by an intermediate program such as HippoDraw@bib-HippoDraw, in which case M is being used under the control of such an intermediate program1. The value of the \(\mbox{FCN}\) function will in general depend on one or more variable parameters whose meaning is defined by the user (or by the intermediate program), but whose trial values are determined by M .; To take a simple example, suppose the problem is to fit a polynomial through a set of data points. Then the user would write a \(\mbox{FCN}\) which calculates the \(\chi^2\) between a polynomial and the data; the variable parameters of \(\mbox{FCN}\) would be the coefficients of the polynomials. Using objects for minimization from M , the user would request M to minimize the \(\mbox{FCN}\) with respect to the parameters, that is, find those values of the coefficients which give the lowest value of chisquare.; The user must therefore supply, in addition to the function to be analyzed, via a set or sequence of M applications the instructions which analysis is wanted. The instructions are coded in in the calling program (main.cpp), which allows looping, conditional execution, and all the other possibilities of , but not interactivity, since it must be compiled before execution.; 2.2 Design aspects of M in; What M is:. platform independent; written in an object-oriented way using standard; independent of any external package. The maintainability should be guaranteed with the choice of a modern computer language. Choosing object-oriented technology M should profit from an increased f",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:5118,Modifiability,maintainab,maintainability,5118,"t of data points. Then the user would write a \(\mbox{FCN}\) which calculates the \(\chi^2\) between a polynomial and the data; the variable parameters of \(\mbox{FCN}\) would be the coefficients of the polynomials. Using objects for minimization from M , the user would request M to minimize the \(\mbox{FCN}\) with respect to the parameters, that is, find those values of the coefficients which give the lowest value of chisquare.; The user must therefore supply, in addition to the function to be analyzed, via a set or sequence of M applications the instructions which analysis is wanted. The instructions are coded in in the calling program (main.cpp), which allows looping, conditional execution, and all the other possibilities of , but not interactivity, since it must be compiled before execution.; 2.2 Design aspects of M in; What M is:. platform independent; written in an object-oriented way using standard; independent of any external package. The maintainability should be guaranteed with the choice of a modern computer language. Choosing object-oriented technology M should profit from an increased flexibility and functionality and make it also extendable (recursiveness, new algorithms, new functionality).; What M does not:. histogramming; data handling; graphics. M is kept as a low-level package with optimal performance.; The main usages of M are. from a user’s program (such as int main()…); from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. its numerical accuracy (equivalent to its Fortran version); its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a two-way strategy was imposed:. a minimal required interface with minimum interaction with M objects and with appropriate usage of the standard library (STL): the user’s implementation of the FCNBase class, initial parameter values and uncertainties are provided by the to M user via",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:5319,Modifiability,extend,extendable,5319,"riable parameters of \(\mbox{FCN}\) would be the coefficients of the polynomials. Using objects for minimization from M , the user would request M to minimize the \(\mbox{FCN}\) with respect to the parameters, that is, find those values of the coefficients which give the lowest value of chisquare.; The user must therefore supply, in addition to the function to be analyzed, via a set or sequence of M applications the instructions which analysis is wanted. The instructions are coded in in the calling program (main.cpp), which allows looping, conditional execution, and all the other possibilities of , but not interactivity, since it must be compiled before execution.; 2.2 Design aspects of M in; What M is:. platform independent; written in an object-oriented way using standard; independent of any external package. The maintainability should be guaranteed with the choice of a modern computer language. Choosing object-oriented technology M should profit from an increased flexibility and functionality and make it also extendable (recursiveness, new algorithms, new functionality).; What M does not:. histogramming; data handling; graphics. M is kept as a low-level package with optimal performance.; The main usages of M are. from a user’s program (such as int main()…); from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. its numerical accuracy (equivalent to its Fortran version); its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a two-way strategy was imposed:. a minimal required interface with minimum interaction with M objects and with appropriate usage of the standard library (STL): the user’s implementation of the FCNBase class, initial parameter values and uncertainties are provided by the to M user via std::vectors.; a rich interface which provides the user with more functionality such as interaction with parameters. The core of the ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:6615,Modifiability,variab,variable,6615,"HippoDraw. The most important goals of M in are. its numerical accuracy (equivalent to its Fortran version); its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a two-way strategy was imposed:. a minimal required interface with minimum interaction with M objects and with appropriate usage of the standard library (STL): the user’s implementation of the FCNBase class, initial parameter values and uncertainties are provided by the to M user via std::vectors.; a rich interface which provides the user with more functionality such as interaction with parameters. The core of the minimization functionality and related tools (the kernel of M ) should be clearly separated from the user, who is interfacing via defined user interfaces (the API).; 2.3 Internal and external parameters; Each of the parameters to the \(\mbox{FCN}\) is defined by the user as belonging to one of the following types:. Freely variable: allowed to take on any value.; Variable with double sided limits: allowed to vary only between two limits specified by the user.; Variable with single sided limits: allowed to vary only between one upper or one lower limit specified by the user and unlimited to the other side.; Fixed: originally defined as variable, but now taking on only the value the parameter had at the moment it was fixed, or a value later assigned by the user.; Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are free and unbound.; The user, in their \(\mbox{FCN}\), must of course be able to “see” all types of defined parameters, and they therefore have access to what we call the external parameter list, that is, the parameters as he defined them. On the other hand, the internal M minimizing routines only want to “see” variable parameters without limits, and so they have access only to the internal parameter list which is created from the ext",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:6933,Modifiability,variab,variable,6933,"th appropriate usage of the standard library (STL): the user’s implementation of the FCNBase class, initial parameter values and uncertainties are provided by the to M user via std::vectors.; a rich interface which provides the user with more functionality such as interaction with parameters. The core of the minimization functionality and related tools (the kernel of M ) should be clearly separated from the user, who is interfacing via defined user interfaces (the API).; 2.3 Internal and external parameters; Each of the parameters to the \(\mbox{FCN}\) is defined by the user as belonging to one of the following types:. Freely variable: allowed to take on any value.; Variable with double sided limits: allowed to vary only between two limits specified by the user.; Variable with single sided limits: allowed to vary only between one upper or one lower limit specified by the user and unlimited to the other side.; Fixed: originally defined as variable, but now taking on only the value the parameter had at the moment it was fixed, or a value later assigned by the user.; Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are free and unbound.; The user, in their \(\mbox{FCN}\), must of course be able to “see” all types of defined parameters, and they therefore have access to what we call the external parameter list, that is, the parameters as he defined them. On the other hand, the internal M minimizing routines only want to “see” variable parameters without limits, and so they have access only to the internal parameter list which is created from the external list by the following transformation:. Squeeze out all parameters that are not variable.; Transform all variable parameters with limits, so that the transformed parameter can vary without limits. (See the next section for details concerning this transformation.) Because this transformation is non-linear, it is recommended to avoid putting lim",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:7170,Modifiability,variab,variable,7170,"tors.; a rich interface which provides the user with more functionality such as interaction with parameters. The core of the minimization functionality and related tools (the kernel of M ) should be clearly separated from the user, who is interfacing via defined user interfaces (the API).; 2.3 Internal and external parameters; Each of the parameters to the \(\mbox{FCN}\) is defined by the user as belonging to one of the following types:. Freely variable: allowed to take on any value.; Variable with double sided limits: allowed to vary only between two limits specified by the user.; Variable with single sided limits: allowed to vary only between one upper or one lower limit specified by the user and unlimited to the other side.; Fixed: originally defined as variable, but now taking on only the value the parameter had at the moment it was fixed, or a value later assigned by the user.; Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are free and unbound.; The user, in their \(\mbox{FCN}\), must of course be able to “see” all types of defined parameters, and they therefore have access to what we call the external parameter list, that is, the parameters as he defined them. On the other hand, the internal M minimizing routines only want to “see” variable parameters without limits, and so they have access only to the internal parameter list which is created from the external list by the following transformation:. Squeeze out all parameters that are not variable.; Transform all variable parameters with limits, so that the transformed parameter can vary without limits. (See the next section for details concerning this transformation.) Because this transformation is non-linear, it is recommended to avoid putting limits on parameters where they are not needed. As an example, suppose that the user has defined the following parameters:. Parameter 0, constant.; Parameter 1, freely variable.; Parameter ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:7506,Modifiability,variab,variable,7506," the user as belonging to one of the following types:. Freely variable: allowed to take on any value.; Variable with double sided limits: allowed to vary only between two limits specified by the user.; Variable with single sided limits: allowed to vary only between one upper or one lower limit specified by the user and unlimited to the other side.; Fixed: originally defined as variable, but now taking on only the value the parameter had at the moment it was fixed, or a value later assigned by the user.; Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are free and unbound.; The user, in their \(\mbox{FCN}\), must of course be able to “see” all types of defined parameters, and they therefore have access to what we call the external parameter list, that is, the parameters as he defined them. On the other hand, the internal M minimizing routines only want to “see” variable parameters without limits, and so they have access only to the internal parameter list which is created from the external list by the following transformation:. Squeeze out all parameters that are not variable.; Transform all variable parameters with limits, so that the transformed parameter can vary without limits. (See the next section for details concerning this transformation.) Because this transformation is non-linear, it is recommended to avoid putting limits on parameters where they are not needed. As an example, suppose that the user has defined the following parameters:. Parameter 0, constant.; Parameter 1, freely variable.; Parameter 2, variable with limits.; Parameter 3, constant.; Parameter 4, freely variable. Then the internal parameter list would be as follows:. Internal parameter 0 = external parameter 1.; Internal parameter 1 = external parameter 2, transformed appropriately.; Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters is 5, and the n",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:7716,Modifiability,variab,variable,7716,"o vary only between two limits specified by the user.; Variable with single sided limits: allowed to vary only between one upper or one lower limit specified by the user and unlimited to the other side.; Fixed: originally defined as variable, but now taking on only the value the parameter had at the moment it was fixed, or a value later assigned by the user.; Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are free and unbound.; The user, in their \(\mbox{FCN}\), must of course be able to “see” all types of defined parameters, and they therefore have access to what we call the external parameter list, that is, the parameters as he defined them. On the other hand, the internal M minimizing routines only want to “see” variable parameters without limits, and so they have access only to the internal parameter list which is created from the external list by the following transformation:. Squeeze out all parameters that are not variable.; Transform all variable parameters with limits, so that the transformed parameter can vary without limits. (See the next section for details concerning this transformation.) Because this transformation is non-linear, it is recommended to avoid putting limits on parameters where they are not needed. As an example, suppose that the user has defined the following parameters:. Parameter 0, constant.; Parameter 1, freely variable.; Parameter 2, variable with limits.; Parameter 3, constant.; Parameter 4, freely variable. Then the internal parameter list would be as follows:. Internal parameter 0 = external parameter 1.; Internal parameter 1 = external parameter 2, transformed appropriately.; Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters is 5, and the number of internal parameters is 3. This is the number which determines, for example, the size of the error matrix of the parameters, since only va",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:7741,Modifiability,variab,variable,7741,"ded limits: allowed to vary only between one upper or one lower limit specified by the user and unlimited to the other side.; Fixed: originally defined as variable, but now taking on only the value the parameter had at the moment it was fixed, or a value later assigned by the user.; Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are free and unbound.; The user, in their \(\mbox{FCN}\), must of course be able to “see” all types of defined parameters, and they therefore have access to what we call the external parameter list, that is, the parameters as he defined them. On the other hand, the internal M minimizing routines only want to “see” variable parameters without limits, and so they have access only to the internal parameter list which is created from the external list by the following transformation:. Squeeze out all parameters that are not variable.; Transform all variable parameters with limits, so that the transformed parameter can vary without limits. (See the next section for details concerning this transformation.) Because this transformation is non-linear, it is recommended to avoid putting limits on parameters where they are not needed. As an example, suppose that the user has defined the following parameters:. Parameter 0, constant.; Parameter 1, freely variable.; Parameter 2, variable with limits.; Parameter 3, constant.; Parameter 4, freely variable. Then the internal parameter list would be as follows:. Internal parameter 0 = external parameter 1.; Internal parameter 1 = external parameter 2, transformed appropriately.; Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters is 5, and the number of internal parameters is 3. This is the number which determines, for example, the size of the error matrix of the parameters, since only variable parameters have errors.; An important feature of M is that parameters ar",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:8146,Modifiability,variab,variable,8146,"inimal required interface, all variable parameters are free and unbound.; The user, in their \(\mbox{FCN}\), must of course be able to “see” all types of defined parameters, and they therefore have access to what we call the external parameter list, that is, the parameters as he defined them. On the other hand, the internal M minimizing routines only want to “see” variable parameters without limits, and so they have access only to the internal parameter list which is created from the external list by the following transformation:. Squeeze out all parameters that are not variable.; Transform all variable parameters with limits, so that the transformed parameter can vary without limits. (See the next section for details concerning this transformation.) Because this transformation is non-linear, it is recommended to avoid putting limits on parameters where they are not needed. As an example, suppose that the user has defined the following parameters:. Parameter 0, constant.; Parameter 1, freely variable.; Parameter 2, variable with limits.; Parameter 3, constant.; Parameter 4, freely variable. Then the internal parameter list would be as follows:. Internal parameter 0 = external parameter 1.; Internal parameter 1 = external parameter 2, transformed appropriately.; Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters is 5, and the number of internal parameters is 3. This is the number which determines, for example, the size of the error matrix of the parameters, since only variable parameters have errors.; An important feature of M is that parameters are allowed to change types during the M minimization and analysis of a \(\mbox{FCN}\) function. Several applications in M have methods available to make variable parameters fixed and vice-versa; to impose, change, or remove limits from variable parameters; and even to define completely new parameters at any time during a run. In addition, some M applications (",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:8170,Modifiability,variab,variable,8170,"iable parameters are free and unbound.; The user, in their \(\mbox{FCN}\), must of course be able to “see” all types of defined parameters, and they therefore have access to what we call the external parameter list, that is, the parameters as he defined them. On the other hand, the internal M minimizing routines only want to “see” variable parameters without limits, and so they have access only to the internal parameter list which is created from the external list by the following transformation:. Squeeze out all parameters that are not variable.; Transform all variable parameters with limits, so that the transformed parameter can vary without limits. (See the next section for details concerning this transformation.) Because this transformation is non-linear, it is recommended to avoid putting limits on parameters where they are not needed. As an example, suppose that the user has defined the following parameters:. Parameter 0, constant.; Parameter 1, freely variable.; Parameter 2, variable with limits.; Parameter 3, constant.; Parameter 4, freely variable. Then the internal parameter list would be as follows:. Internal parameter 0 = external parameter 1.; Internal parameter 1 = external parameter 2, transformed appropriately.; Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters is 5, and the number of internal parameters is 3. This is the number which determines, for example, the size of the error matrix of the parameters, since only variable parameters have errors.; An important feature of M is that parameters are allowed to change types during the M minimization and analysis of a \(\mbox{FCN}\) function. Several applications in M have methods available to make variable parameters fixed and vice-versa; to impose, change, or remove limits from variable parameters; and even to define completely new parameters at any time during a run. In addition, some M applications (notably the \(\mbox{MINOS}\) erro",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:8237,Modifiability,variab,variable,8237,"r \(\mbox{FCN}\), must of course be able to “see” all types of defined parameters, and they therefore have access to what we call the external parameter list, that is, the parameters as he defined them. On the other hand, the internal M minimizing routines only want to “see” variable parameters without limits, and so they have access only to the internal parameter list which is created from the external list by the following transformation:. Squeeze out all parameters that are not variable.; Transform all variable parameters with limits, so that the transformed parameter can vary without limits. (See the next section for details concerning this transformation.) Because this transformation is non-linear, it is recommended to avoid putting limits on parameters where they are not needed. As an example, suppose that the user has defined the following parameters:. Parameter 0, constant.; Parameter 1, freely variable.; Parameter 2, variable with limits.; Parameter 3, constant.; Parameter 4, freely variable. Then the internal parameter list would be as follows:. Internal parameter 0 = external parameter 1.; Internal parameter 1 = external parameter 2, transformed appropriately.; Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters is 5, and the number of internal parameters is 3. This is the number which determines, for example, the size of the error matrix of the parameters, since only variable parameters have errors.; An important feature of M is that parameters are allowed to change types during the M minimization and analysis of a \(\mbox{FCN}\) function. Several applications in M have methods available to make variable parameters fixed and vice-versa; to impose, change, or remove limits from variable parameters; and even to define completely new parameters at any time during a run. In addition, some M applications (notably the \(\mbox{MINOS}\) error analysis) cause one or more variable parameters to be te",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:8698,Modifiability,variab,variable,8698,"transformation:. Squeeze out all parameters that are not variable.; Transform all variable parameters with limits, so that the transformed parameter can vary without limits. (See the next section for details concerning this transformation.) Because this transformation is non-linear, it is recommended to avoid putting limits on parameters where they are not needed. As an example, suppose that the user has defined the following parameters:. Parameter 0, constant.; Parameter 1, freely variable.; Parameter 2, variable with limits.; Parameter 3, constant.; Parameter 4, freely variable. Then the internal parameter list would be as follows:. Internal parameter 0 = external parameter 1.; Internal parameter 1 = external parameter 2, transformed appropriately.; Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters is 5, and the number of internal parameters is 3. This is the number which determines, for example, the size of the error matrix of the parameters, since only variable parameters have errors.; An important feature of M is that parameters are allowed to change types during the M minimization and analysis of a \(\mbox{FCN}\) function. Several applications in M have methods available to make variable parameters fixed and vice-versa; to impose, change, or remove limits from variable parameters; and even to define completely new parameters at any time during a run. In addition, some M applications (notably the \(\mbox{MINOS}\) error analysis) cause one or more variable parameters to be temporarily fixed during the calculation. Therefore, the correspondence between external and internal parameter lists is in general a dynamic one, and the number of internal parameters is not necessarily constant.; For more details about parameter interaction see [api:parameters].; 2.3.1 The transformation for parameters with limits; [intro:limits]; For variable parameters with double sided limits \(a\) (lower) and \(b\) (uppe",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:8931,Modifiability,variab,variable,8931,"arameters where they are not needed. As an example, suppose that the user has defined the following parameters:. Parameter 0, constant.; Parameter 1, freely variable.; Parameter 2, variable with limits.; Parameter 3, constant.; Parameter 4, freely variable. Then the internal parameter list would be as follows:. Internal parameter 0 = external parameter 1.; Internal parameter 1 = external parameter 2, transformed appropriately.; Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters is 5, and the number of internal parameters is 3. This is the number which determines, for example, the size of the error matrix of the parameters, since only variable parameters have errors.; An important feature of M is that parameters are allowed to change types during the M minimization and analysis of a \(\mbox{FCN}\) function. Several applications in M have methods available to make variable parameters fixed and vice-versa; to impose, change, or remove limits from variable parameters; and even to define completely new parameters at any time during a run. In addition, some M applications (notably the \(\mbox{MINOS}\) error analysis) cause one or more variable parameters to be temporarily fixed during the calculation. Therefore, the correspondence between external and internal parameter lists is in general a dynamic one, and the number of internal parameters is not necessarily constant.; For more details about parameter interaction see [api:parameters].; 2.3.1 The transformation for parameters with limits; [intro:limits]; For variable parameters with double sided limits \(a\) (lower) and \(b\) (upper), M uses the following transformation:; \[\begin{aligned}; P_{\mathrm{int}} &=& \arcsin; \left( 2\: \frac{ P_{\mathrm{ext}}-a}{ b-a} - 1 \right) \\; P_{\mathrm{ext}} &=& a + \frac{ b - a}{ 2}; \left( \sin P_{\mathrm{int}} + 1 \right) \end{aligned}\]; so that the internal value \(P_{\mathrm{int}}\) can take on any value, while ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:9014,Modifiability,variab,variable,9014,"arameters where they are not needed. As an example, suppose that the user has defined the following parameters:. Parameter 0, constant.; Parameter 1, freely variable.; Parameter 2, variable with limits.; Parameter 3, constant.; Parameter 4, freely variable. Then the internal parameter list would be as follows:. Internal parameter 0 = external parameter 1.; Internal parameter 1 = external parameter 2, transformed appropriately.; Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters is 5, and the number of internal parameters is 3. This is the number which determines, for example, the size of the error matrix of the parameters, since only variable parameters have errors.; An important feature of M is that parameters are allowed to change types during the M minimization and analysis of a \(\mbox{FCN}\) function. Several applications in M have methods available to make variable parameters fixed and vice-versa; to impose, change, or remove limits from variable parameters; and even to define completely new parameters at any time during a run. In addition, some M applications (notably the \(\mbox{MINOS}\) error analysis) cause one or more variable parameters to be temporarily fixed during the calculation. Therefore, the correspondence between external and internal parameter lists is in general a dynamic one, and the number of internal parameters is not necessarily constant.; For more details about parameter interaction see [api:parameters].; 2.3.1 The transformation for parameters with limits; [intro:limits]; For variable parameters with double sided limits \(a\) (lower) and \(b\) (upper), M uses the following transformation:; \[\begin{aligned}; P_{\mathrm{int}} &=& \arcsin; \left( 2\: \frac{ P_{\mathrm{ext}}-a}{ b-a} - 1 \right) \\; P_{\mathrm{ext}} &=& a + \frac{ b - a}{ 2}; \left( \sin P_{\mathrm{int}} + 1 \right) \end{aligned}\]; so that the internal value \(P_{\mathrm{int}}\) can take on any value, while ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:9203,Modifiability,variab,variable,9203,"its.; Parameter 3, constant.; Parameter 4, freely variable. Then the internal parameter list would be as follows:. Internal parameter 0 = external parameter 1.; Internal parameter 1 = external parameter 2, transformed appropriately.; Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters is 5, and the number of internal parameters is 3. This is the number which determines, for example, the size of the error matrix of the parameters, since only variable parameters have errors.; An important feature of M is that parameters are allowed to change types during the M minimization and analysis of a \(\mbox{FCN}\) function. Several applications in M have methods available to make variable parameters fixed and vice-versa; to impose, change, or remove limits from variable parameters; and even to define completely new parameters at any time during a run. In addition, some M applications (notably the \(\mbox{MINOS}\) error analysis) cause one or more variable parameters to be temporarily fixed during the calculation. Therefore, the correspondence between external and internal parameter lists is in general a dynamic one, and the number of internal parameters is not necessarily constant.; For more details about parameter interaction see [api:parameters].; 2.3.1 The transformation for parameters with limits; [intro:limits]; For variable parameters with double sided limits \(a\) (lower) and \(b\) (upper), M uses the following transformation:; \[\begin{aligned}; P_{\mathrm{int}} &=& \arcsin; \left( 2\: \frac{ P_{\mathrm{ext}}-a}{ b-a} - 1 \right) \\; P_{\mathrm{ext}} &=& a + \frac{ b - a}{ 2}; \left( \sin P_{\mathrm{int}} + 1 \right) \end{aligned}\]; so that the internal value \(P_{\mathrm{int}}\) can take on any value, while the external value \(P_{\mathrm{ext}}\) can take on values only between the lower limit \(a\) and the upper limit \(b\). Since the transformation is necessarily non-linear, it would transform a nice ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:9585,Modifiability,variab,variable,9585,"the M minimization and analysis of a \(\mbox{FCN}\) function. Several applications in M have methods available to make variable parameters fixed and vice-versa; to impose, change, or remove limits from variable parameters; and even to define completely new parameters at any time during a run. In addition, some M applications (notably the \(\mbox{MINOS}\) error analysis) cause one or more variable parameters to be temporarily fixed during the calculation. Therefore, the correspondence between external and internal parameter lists is in general a dynamic one, and the number of internal parameters is not necessarily constant.; For more details about parameter interaction see [api:parameters].; 2.3.1 The transformation for parameters with limits; [intro:limits]; For variable parameters with double sided limits \(a\) (lower) and \(b\) (upper), M uses the following transformation:; \[\begin{aligned}; P_{\mathrm{int}} &=& \arcsin; \left( 2\: \frac{ P_{\mathrm{ext}}-a}{ b-a} - 1 \right) \\; P_{\mathrm{ext}} &=& a + \frac{ b - a}{ 2}; \left( \sin P_{\mathrm{int}} + 1 \right) \end{aligned}\]; so that the internal value \(P_{\mathrm{int}}\) can take on any value, while the external value \(P_{\mathrm{ext}}\) can take on values only between the lower limit \(a\) and the upper limit \(b\). Since the transformation is necessarily non-linear, it would transform a nice linear problem into a nasty non-linear one, which is the reason why limits should be avoided if not necessary. In addition, the transformation does require some computer time, so it slows down the computation a little bit, and more importantly, it introduces additional numerical inaccuracy into the problem in addition to what is introduced in the numerical calculation of the \(\mbox{FCN}\) value. The effects of non-linearity and numerical roundoff both become more important as the external value gets closer to one of the limits (expressed as the distance to nearest limit divided by distance between limits). The user m",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:11980,Modifiability,variab,variable,11980," single sided limits on parameters are provided by M , with their transformation being:; Lower bound \(a\):; \[\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(P_{\mathrm{ext}} - a + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& a - 1 + \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}\]; Upper bound \(b\):; \[\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(b - P_{\mathrm{ext}} + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& b + 1 - \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}\]; The transformation of course also affects the parameter error matrix, so M does a transformation of the error matrix (and the “parabolic” parameter errors) when there are parameter limits. Users should however realize that the transformation is only a linear approximation, and that it cannot give a meaningful result if one or more parameters is very close to a limit, where \(\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0\). Therefore, it is recommended that:. Limits on variable parameters should be used only when needed in order to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits. Further discussion of the effects of parameter limits may be found in the last chapter.; 2.4 M strategy; At many places in the analysis of the \(\mbox{FCN}\) (the user provided function), M must decide whether to be “safe” and waste a few function calls in order to know where it is, or to be “fast” and attempt to get the requested results with the fewest possible calls at a certain risk of not obtaining the precision desired by the user. In order to allow the user to influence these decisions, there is a M class MnStrategy (see [api:strategy]) which the user can use to put different settings. In the current release, this MnStrategy can be instantiated with three different minimization quality levels for low (0), medium (1) and high (2) quality. Defau",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:13267,Modifiability,variab,variable,13267,"iscussion of the effects of parameter limits may be found in the last chapter.; 2.4 M strategy; At many places in the analysis of the \(\mbox{FCN}\) (the user provided function), M must decide whether to be “safe” and waste a few function calls in order to know where it is, or to be “fast” and attempt to get the requested results with the fewest possible calls at a certain risk of not obtaining the precision desired by the user. In order to allow the user to influence these decisions, there is a M class MnStrategy (see [api:strategy]) which the user can use to put different settings. In the current release, this MnStrategy can be instantiated with three different minimization quality levels for low (0), medium (1) and high (2) quality. Default settings for iteration cycles and tolerances are initialized then. The default setting is set for medium quality. Value 0 (low) indicates to M that it should economize function calls; it is intended for cases where there are many variable parameters and/or the function takes a long time to calculate and/or the user is not interested in very precise values for parameter errors. On the other hand, value 2 (high) indicates that M is allowed to waste function calls in order to be sure that all values are precise; it is intended for cases where the function is evaluated in a relatively short time and/or where the parameter errors must be calculated reliably. In addition all constants set in MnStrategy can be changed individually by the user, e.g. the number of iteration cycles in the numerical gradient.; 2.5 Parameter errors; M is usually used to find the “best” values of a set of parameters, where “best” is defined as those values which minimize a given function, \(\mbox{FCN}\). The width of the function minimum, or more generally, the shape of the function in some neighbourhood of the minimum, gives information about the uncertainty in the best parameter values, often called by physicists the parameter errors. An important featur",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:20146,Modifiability,variab,variable,20146,"ric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate after a good minimum has already been found, and the error matrix has been calculated, so the \(\mbox{MINOS}\) error analysis will normally follow a \(\mbox{MIGRAD}\) minimization. The \(\mbox{MINOS}\) error for a given parameter is defined as the change in the value of that parameter which causes \({\displaystyle F'}\) to increase by the amount FCNBase::up(), where \({\displaystyle F'}\) is the minimum of \(\mbox{FCN}\) with respect to all other free parameters, and FCNBase::up() is the return value of the error definition specified by the user (default = 1.).; The algorithm for finding the positive and negative \(\mbox{MINOS}\) errors for parameter \(\mbox{n}\) consists of varying parameter \(\mbox{n}\), each time minimizing \(\mbox{FCN}\) with respect to all the other \(\mbox{npar - 1}\) variable parameters, to find numerically the two values of parameter \(\mbox{n}\) for which the minimum of \(\mbox{FCN}\) takes on the values \(\displaystyle F_{\mathrm{min}} + \mbox{up}\), where \(\displaystyle F_{\mathrm{min}}\) is the minimum of \(\mbox{FCN}\) with respect to all \(\mbox{npar}\) parameters. In order to make the procedure as fast as possible, \(\mbox{MINOS}\) uses the error matrix to predict the values of all parameters at the various sub-minima which it will have to find in the course of the calculation, and in the limit that the problem is nearly linear, the predictions of \(\mbox{MINOS}\) will be nearly exact, requiring very few iterations. On the other hand, when the problem is very non-linear (i.e., \(\mbox{FCN}\) is far from a quadratic function of its parameters), is precisely the situation when \(\mbox{MINOS}\) is needed in order to indicate the correct parameter errors.; 2.5.4 \(\mbox{CONTOURS}\) plotting; M offers a procedure for finding \(\mbox{FCN}\) \(\mbox{CONTOURS}\) (provided via the clas",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:21557,Modifiability,variab,variable,21557,"}\) uses the error matrix to predict the values of all parameters at the various sub-minima which it will have to find in the course of the calculation, and in the limit that the problem is nearly linear, the predictions of \(\mbox{MINOS}\) will be nearly exact, requiring very few iterations. On the other hand, when the problem is very non-linear (i.e., \(\mbox{FCN}\) is far from a quadratic function of its parameters), is precisely the situation when \(\mbox{MINOS}\) is needed in order to indicate the correct parameter errors.; 2.5.4 \(\mbox{CONTOURS}\) plotting; M offers a procedure for finding \(\mbox{FCN}\) \(\mbox{CONTOURS}\) (provided via the class MnContours, see [api:contours]).; The contour calculated by MnContours::operator() is dynamic, in the sense that it represents the minimum of \(\mbox{FCN}\) with respect to all the other \(\mbox{npar - 2}\) parameters (if any). In statistical terms, this means that MnContours takes account of the correlations between the two parameters being plotted, and all the other variable parameters, using a procedure analogous to that of \(\mbox{MINOS}\). (If this feature is not wanted, then the other parameters must be fixed before calling \(\mbox{CONTOURS}\).) MnContours provides the actual coordinates of the points around the contour, suitable for plotting with a graphics routine or by hand (using MnPlot, see [api:plot]). The points are given in counter-clockwise order around the contour. Only one contour is calculated per command, and the level is \(\displaystyle F_{\mathrm{min}} + \mbox{up}\). where \(\mbox{up}\) is the return value of FCNBase::up() specified by the user (usually 1.0 by default). The number of points to be calculated is chosen by the user (default is 20). As a by-product, \(\mbox{CONTOURS}\) provides the \(\mbox{MINOS}\) errors of the two parameters in question, since these are just the extreme points of the contour (use the MnContours::contour(…) method in order to get the points of the contour and the on",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:23402,Modifiability,adapt,adapt,23402,"these are just the extreme points of the contour (use the MnContours::contour(…) method in order to get the points of the contour and the ones of the \(\mbox{MINOS}\) errors). MnContours::operator() returns a std::vector\(<\)std::pair\(<\)double,double\(> >\) of (x,y) points. Using MnPlot::operator() will generate a text graphics plot in the terminal.; 3 M installation; 3.1 M releases; To follow the current release process the user is referred to the M homepage @bib-C++MINUIT.; M was re–implemented in from 2002–2004, but the functionality is largely compatible with the one of the version. The usage is different in the sense that the re–write from to was done by its signification and not literally (with minor exceptions). Applications such as \(\mbox{MIGRAD}\) have a corresponding class MnMigrad, M “commands” became classes or methods of classes according to their purpose. Users familiar with the version of M , who have not yet used releases from the version, should however read this manual, in order to adapt to the changes as well as to discover the new features and easier ways of using old features.; 3.2 Install M using autoconf/make; For each release of M a tar.gz file is provided for downloading from the M homepage @bib-C++MINUIT. For non-UNIX platforms please refer to the M homepage.; The necessary steps to follow are:. download the tar.gz by clicking on it from the release page; unzip it:; $ unzip Minuit-x.x.x.tar.gz; untar it:; $ tar xvf Minuit-x.x.x.tar; step down to the created Minuit-x.x.x directory:; $ cd Minuit-x.x.x/; run the “configure” script:; $ ./configure; run “make” to compile the source code:; $ make; run “make check” to create the executable example:; $ make check; run the executable example:; $ tests/MnTutorial/Quad4FMain.C. The output should look like that:; Minuit did successfully converge. # of function calls: 74; minimum function value: 1.12392e-09; minimum edm: 1.12392e-09; minimum internal state vector: LAVector parameters:. -1.82079e-05; -",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:23949,Modifiability,config,configure,23949,"h the one of the version. The usage is different in the sense that the re–write from to was done by its signification and not literally (with minor exceptions). Applications such as \(\mbox{MIGRAD}\) have a corresponding class MnMigrad, M “commands” became classes or methods of classes according to their purpose. Users familiar with the version of M , who have not yet used releases from the version, should however read this manual, in order to adapt to the changes as well as to discover the new features and easier ways of using old features.; 3.2 Install M using autoconf/make; For each release of M a tar.gz file is provided for downloading from the M homepage @bib-C++MINUIT. For non-UNIX platforms please refer to the M homepage.; The necessary steps to follow are:. download the tar.gz by clicking on it from the release page; unzip it:; $ unzip Minuit-x.x.x.tar.gz; untar it:; $ tar xvf Minuit-x.x.x.tar; step down to the created Minuit-x.x.x directory:; $ cd Minuit-x.x.x/; run the “configure” script:; $ ./configure; run “make” to compile the source code:; $ make; run “make check” to create the executable example:; $ make check; run the executable example:; $ tests/MnTutorial/Quad4FMain.C. The output should look like that:; Minuit did successfully converge. # of function calls: 74; minimum function value: 1.12392e-09; minimum edm: 1.12392e-09; minimum internal state vector: LAVector parameters:. -1.82079e-05; -1.20794e-05; 6.22382e-06; -3.0465e-05. minimum internal covariance matrix: LASymMatrix parameters:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. # ext. || name || type || value || error +/-. 0 || x || free ||-1.821e-05 || 2; 1 || y || free ||-1.208e-05 || 2.236; 2 || z || free || 6.224e-06 || 2.449; 3 || w || free ||-3.047e-05 || 1. MnUserCovariance:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. MnUserCovariance parameter correlations:. 1 0.223607 0.408248 1.3501",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:23973,Modifiability,config,configure,23973,"ication and not literally (with minor exceptions). Applications such as \(\mbox{MIGRAD}\) have a corresponding class MnMigrad, M “commands” became classes or methods of classes according to their purpose. Users familiar with the version of M , who have not yet used releases from the version, should however read this manual, in order to adapt to the changes as well as to discover the new features and easier ways of using old features.; 3.2 Install M using autoconf/make; For each release of M a tar.gz file is provided for downloading from the M homepage @bib-C++MINUIT. For non-UNIX platforms please refer to the M homepage.; The necessary steps to follow are:. download the tar.gz by clicking on it from the release page; unzip it:; $ unzip Minuit-x.x.x.tar.gz; untar it:; $ tar xvf Minuit-x.x.x.tar; step down to the created Minuit-x.x.x directory:; $ cd Minuit-x.x.x/; run the “configure” script:; $ ./configure; run “make” to compile the source code:; $ make; run “make check” to create the executable example:; $ make check; run the executable example:; $ tests/MnTutorial/Quad4FMain.C. The output should look like that:; Minuit did successfully converge. # of function calls: 74; minimum function value: 1.12392e-09; minimum edm: 1.12392e-09; minimum internal state vector: LAVector parameters:. -1.82079e-05; -1.20794e-05; 6.22382e-06; -3.0465e-05. minimum internal covariance matrix: LASymMatrix parameters:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. # ext. || name || type || value || error +/-. 0 || x || free ||-1.821e-05 || 2; 1 || y || free ||-1.208e-05 || 2.236; 2 || z || free || 6.224e-06 || 2.449; 3 || w || free ||-3.047e-05 || 1. MnUserCovariance:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. MnUserCovariance parameter correlations:. 1 0.223607 0.408248 1.35011e-18; 0.223607 1 0.547723 8.39663e-18; 0.408248 0.547723 1 9.36796e-18; 1.35011e-18 8.39663e-18 9.36796e-18 1.",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:26060,Modifiability,config,configure,26060,"663e-18 9.36796e-18 1. MnGlobalCorrelationCoeff:. 0.408248; 0.547723; 0.621261; 0; 3.3 CVS code repository; How to check out (–in) code from the CVS code repository is described at the M homepage @bib-C++MINUIT. To get the source code from the CVS repository one needs to do:; Kerberos IV authorization:; $ setenv CVSROOT :kserver:SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs co MathLibs/Minuit; Anonymous read-only access (if it’s enabled by the librarian, see details):; $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login; (Logging in to :pserver:anonymous@seal.cvs.cern.ch:2401/cvs/SEAL) CVS password:cvs; $ cvs co MathLibs/Minuit; (If you want to check out a tagged version SEAL_x_x_x of MINUIT, then do; $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ); 3.4 Create a tar.gz from CVS; Once the sources are checked out from the CVS code repository,. change to the directory:; $ cd MathLibs/Minuit; run autogen:; $ ./autogen; create a new directory:; $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/; run configure:; $ ../Minuit/configure; create the tar.gz:; $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used as described above.; 3.5 M versions; The version numbers of M follow the release numbers of the SEAL project @bib-SEAL at CERN @bib-CERN.; 3.5.1 From to; The program is entirely written in standard portable . M does not depend on any external library. In its minimal usage the user must only provide an implementation of the FCNBase class to M and parameters and uncertainties in form of std::vector containers.; 3.5.2 Memory allocation and thread safety; Differently to the version of M , the version has its own memory manager (StackAllocator. The user can select between the standard dynamic memory allocation and deallocation (default) and performance-optimized stack–like allocation (optional). However, the library is not thread save using stack–allocation.; 3.5.3 M parameters; Differently to the version of M there is no limit on the n",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:26084,Modifiability,config,configure,26084,"0.408248; 0.547723; 0.621261; 0; 3.3 CVS code repository; How to check out (–in) code from the CVS code repository is described at the M homepage @bib-C++MINUIT. To get the source code from the CVS repository one needs to do:; Kerberos IV authorization:; $ setenv CVSROOT :kserver:SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs co MathLibs/Minuit; Anonymous read-only access (if it’s enabled by the librarian, see details):; $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login; (Logging in to :pserver:anonymous@seal.cvs.cern.ch:2401/cvs/SEAL) CVS password:cvs; $ cvs co MathLibs/Minuit; (If you want to check out a tagged version SEAL_x_x_x of MINUIT, then do; $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ); 3.4 Create a tar.gz from CVS; Once the sources are checked out from the CVS code repository,. change to the directory:; $ cd MathLibs/Minuit; run autogen:; $ ./autogen; create a new directory:; $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/; run configure:; $ ../Minuit/configure; create the tar.gz:; $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used as described above.; 3.5 M versions; The version numbers of M follow the release numbers of the SEAL project @bib-SEAL at CERN @bib-CERN.; 3.5.1 From to; The program is entirely written in standard portable . M does not depend on any external library. In its minimal usage the user must only provide an implementation of the FCNBase class to M and parameters and uncertainties in form of std::vector containers.; 3.5.2 Memory allocation and thread safety; Differently to the version of M , the version has its own memory manager (StackAllocator. The user can select between the standard dynamic memory allocation and deallocation (default) and performance-optimized stack–like allocation (optional). However, the library is not thread save using stack–allocation.; 3.5.3 M parameters; Differently to the version of M there is no limit on the number of parameters, variable or non-variable. Me",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:26399,Modifiability,portab,portable,26399,"AL.cvs.cern.ch:/cvs/SEAL. $ cvs co MathLibs/Minuit; Anonymous read-only access (if it’s enabled by the librarian, see details):; $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login; (Logging in to :pserver:anonymous@seal.cvs.cern.ch:2401/cvs/SEAL) CVS password:cvs; $ cvs co MathLibs/Minuit; (If you want to check out a tagged version SEAL_x_x_x of MINUIT, then do; $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ); 3.4 Create a tar.gz from CVS; Once the sources are checked out from the CVS code repository,. change to the directory:; $ cd MathLibs/Minuit; run autogen:; $ ./autogen; create a new directory:; $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/; run configure:; $ ../Minuit/configure; create the tar.gz:; $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used as described above.; 3.5 M versions; The version numbers of M follow the release numbers of the SEAL project @bib-SEAL at CERN @bib-CERN.; 3.5.1 From to; The program is entirely written in standard portable . M does not depend on any external library. In its minimal usage the user must only provide an implementation of the FCNBase class to M and parameters and uncertainties in form of std::vector containers.; 3.5.2 Memory allocation and thread safety; Differently to the version of M , the version has its own memory manager (StackAllocator. The user can select between the standard dynamic memory allocation and deallocation (default) and performance-optimized stack–like allocation (optional). However, the library is not thread save using stack–allocation.; 3.5.3 M parameters; Differently to the version of M there is no limit on the number of parameters, variable or non-variable. Memory allocation is done dynamically according to the actual needs and “on demand”. There is no protection against an upper limit on the number of parameters, however the “technological” limitations of M can be seen around a maximum of 15 free parameters at a time.; 3.6 Interference w",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:27065,Modifiability,variab,variable,27065,"UILD; $ cd Minuit-BUILD/; run configure:; $ ../Minuit/configure; create the tar.gz:; $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used as described above.; 3.5 M versions; The version numbers of M follow the release numbers of the SEAL project @bib-SEAL at CERN @bib-CERN.; 3.5.1 From to; The program is entirely written in standard portable . M does not depend on any external library. In its minimal usage the user must only provide an implementation of the FCNBase class to M and parameters and uncertainties in form of std::vector containers.; 3.5.2 Memory allocation and thread safety; Differently to the version of M , the version has its own memory manager (StackAllocator. The user can select between the standard dynamic memory allocation and deallocation (default) and performance-optimized stack–like allocation (optional). However, the library is not thread save using stack–allocation.; 3.5.3 M parameters; Differently to the version of M there is no limit on the number of parameters, variable or non-variable. Memory allocation is done dynamically according to the actual needs and “on demand”. There is no protection against an upper limit on the number of parameters, however the “technological” limitations of M can be seen around a maximum of 15 free parameters at a time.; 3.6 Interference with other packages; The new M has been designed to interfere as little as possible with other programs or packages which may be loaded at the same time. M is thread safe by default. Optionally the user can select a different way of dynamically allocating memory in the class StackAllacator for M , in which case (and after an entire recompilation of the whole library) the thread safety is lost.; 3.7 Floating-point precision; [install:epsmac]; M is entirely based on double precision. The actual floating point precision of double precision (32–bit or 64–bit) is platform dependent and can even vary on the same platform, depending on whether a floatin",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:27081,Modifiability,variab,variable,27081,"UILD; $ cd Minuit-BUILD/; run configure:; $ ../Minuit/configure; create the tar.gz:; $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used as described above.; 3.5 M versions; The version numbers of M follow the release numbers of the SEAL project @bib-SEAL at CERN @bib-CERN.; 3.5.1 From to; The program is entirely written in standard portable . M does not depend on any external library. In its minimal usage the user must only provide an implementation of the FCNBase class to M and parameters and uncertainties in form of std::vector containers.; 3.5.2 Memory allocation and thread safety; Differently to the version of M , the version has its own memory manager (StackAllocator. The user can select between the standard dynamic memory allocation and deallocation (default) and performance-optimized stack–like allocation (optional). However, the library is not thread save using stack–allocation.; 3.5.3 M parameters; Differently to the version of M there is no limit on the number of parameters, variable or non-variable. Memory allocation is done dynamically according to the actual needs and “on demand”. There is no protection against an upper limit on the number of parameters, however the “technological” limitations of M can be seen around a maximum of 15 free parameters at a time.; 3.6 Interference with other packages; The new M has been designed to interfere as little as possible with other programs or packages which may be loaded at the same time. M is thread safe by default. Optionally the user can select a different way of dynamically allocating memory in the class StackAllacator for M , in which case (and after an entire recompilation of the whole library) the thread safety is lost.; 3.7 Floating-point precision; [install:epsmac]; M is entirely based on double precision. The actual floating point precision of double precision (32–bit or 64–bit) is platform dependent and can even vary on the same platform, depending on whether a floatin",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:31458,Modifiability,variab,variable,31458,"ters (see [api:parameters]) supplied as input to the M minimizers such as VariableMetricMinimizer or MnMigrad (see [api:migrad]). Later values are determined by M as it searches for the minimum or performs whatever analysis is requested by the user.; 4.1.2 FCNBase::up(); [howto:errordef] Returns the value of \(\mbox{up}\) (default value \(= 1.\)), defining parameter errors. M defines parameter errors as the change in parameter value required to change the function value by \(\mbox{up}\). Normally, for chisquared fits \(\mbox{up = 1}\), and for negative log likelihood, \(\mbox{up = 0.5}\).; 4.1.3 \(\mbox{FCN}\) function with gradient; By default first derivatives are calculated numerically by M . In case the user wants to supply their own gradient calculator (e.g. analytical derivatives), they need to implement the FCNGradientBase interface. The size of the output vector is the same as of the input one. The same is true for the position of the elements (first derivative of the function with respect to the \(n_\mathrm{th}\) variable has index \(n\) in the output vector).; 4.2 M parameters; Interaction with the parameters of the function are essential both for M and the user. Different interfaces are provided, depending on the level of interaction.; 4.2.1 Minimal required interface; Starting values of parameters and uncertainties can be provided to M by the user via std::vector\(<\)double\(>\) vector containers. Any interaction with the parameters before minimization (fix, release, limits, etc.) is not possible then.; Optionally if the user wants to provide starting values for the covariance, they have to provide the values in a std::vector\(<\)double\(>\) vector container stored in upper triangular packed storage format (see [api:covariance]).; 4.2.2 MnUserParameters; A more functional interface to the user parameters is provided through M via the class MnUserParameters. The user can add parameters giving them a name and starting values. More information can be found ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:33889,Modifiability,variab,variables,33889,"The result of the minimization is transformed into the user representable format by M . For more explanations see [api:state].; 4.3 Input to M; The following input combinations to M are possible:. \(\mbox{FCN}\) + parameters + uncertainties; \(\mbox{FCN}\) with gradient + parameters + uncertainties; \(\mbox{FCN}\) + parameters + covariance; \(\mbox{FCN}\) with gradient + parameters + covariance. For each of these combinations the user can chose between a minimal required interface (using std::vector containers) for the parameters and uncertainties or a more functional one provided by M . If the user wants to interact with the parameters before minimization (fixing, adding/removing limits), the minimal required interface cannot be used.; 4.3.1 What the user must supply; The user must supply to M. a valid implementation of the FCNBase base class; parameters with their starting values; expected uncertainties on the parameters. The input parameters can be simply defined via an std::vector\(<\)double\(>\), which means that all parameters are variables. If the user wants fix a parameter or put limits on it before minimization, they have to instantiate a MnUserParameters object and then add parameters one by one, giving them a name, value, uncertainty. Once all parameters are added to MnUserParameters, they can fix a parameter or put limits on another one before handing them over to Minuit for minimization.; 4.3.2 What the user can supply; Optionally the user can supply their own gradient calculator by implementing the FCNGradientBase interface or supply a full covariance matrix for input if one is available. The covariance matrix can be supplied in form of a std::vector\(<\)double\(>\) in packed storage format (upper triangular), or in a more user-friendly way by using the interface provided by the MnUserCovariance.; 4.4 Running a M minimization; Two use cases are addressed for minimization:. The user just wants the function to be minimized in one go.; The user wants to m",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:40367,Modifiability,variab,variable,40367,"ysis of the state at the minimum are provided.; 5.1.2 fval(), edm(), nfcn(); The method double FunctionMinimum::fval() returns the function value at the minimum, the method double FunctionMinimum::edm() returns the expected vertical distance to the minimum EDM and unsigned int FunctionMinimum::nfcn() returns the total number of function calls during the minimization.; 5.2 MnContours; [api:contours]; 5.2.1 MnContours(const FCNBase&, const FunctionMinimum&); Construct an MnContours object from the user’s FCN and a valid FunctionMinimum. Additional constructors for user specific MnStrategy settings are provided.; 5.2.2 operator(); The method MnContours::operator()(unsigned int parx, unsigned int pary, unsigned int npoints = 20) const calculates one function contour of \(\mbox{FCN}\) with respect to parameters \(\mbox{parx}\) and \(\mbox{pary}\). The return value is a std::vector\(<\)std::pair\(<\)double,double\(>\) \(>\) of (x,y) points. \(\mbox{FCN}\) minimized always with respect to all other \(\mbox{n - 2}\) variable parameters (if any). M will try to find \(\mbox{npoints}\) points on the contour (default 20). To calculate more than one contour, the user needs to set the error definition [howto:errordef] in its \(\mbox{FCN}\) to the appropriate value for the desired confidence level and call the method MnContours::operator() for each contour.; 5.2.3 contour(…); MnContours::contour(unsigned int parx, unsigned int pary, unsigned int npoints = 20) causes a \(\mbox{CONTOURS}\) error analysis and returns the result in form of ContoursError. As a by-product ContoursError keeps the MinosError information of parameters \(\mbox{parx}\) and \(\mbox{pary}\). The result ContoursError can be easily printed using std::cout.; 5.3 MnEigen; [api:eigen] MnEigen calculates and the eigenvalues of the user covariance matrix MnUserCovariance.; 5.3.1 MnEigen(); MnEigen is instantiated via default constructor.; 5.3.2 operator(); operator()(const MnUserCovariance&) const will perform the cal",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:41770,Modifiability,variab,variable,41770,"urs::contour(unsigned int parx, unsigned int pary, unsigned int npoints = 20) causes a \(\mbox{CONTOURS}\) error analysis and returns the result in form of ContoursError. As a by-product ContoursError keeps the MinosError information of parameters \(\mbox{parx}\) and \(\mbox{pary}\). The result ContoursError can be easily printed using std::cout.; 5.3 MnEigen; [api:eigen] MnEigen calculates and the eigenvalues of the user covariance matrix MnUserCovariance.; 5.3.1 MnEigen(); MnEigen is instantiated via default constructor.; 5.3.2 operator(); operator()(const MnUserCovariance&) const will perform the calculation of the eigenvalues of the covariance matrix and return the result in form of a std::vector<double>. The eigenvalues are ordered from the smallest first to the largest eigenvalue.; 5.4 MnHesse; [api:hesse]; With MnHesse the user can instructs M to calculate, by finite differences, the Hessian or error matrix. That is, it calculates the full matrix of second derivatives of the function with respect to the currently variable parameters, and inverts it.; 5.4.1 MnHesse(); The default constructor of MnHesse() will use default settings of MnStrategy. Other constructors with user specific MnStrategy settings are provided as well.; 5.4.2 operator(); The MnHesse::operator() is overloaded both for internal (M ) and external (user) parameters. External parameters can be specified as std::vector\(<\)double\(>\) or as MnUserParameters. The return value is always a MnUserParameterState.; The optional argument \(\mbox{maxcalls}\) specifies the (approximate) maximum number of function calls after which the calculation will be stopped.; 5.5 MnMachinePrecision; [api:epsmac]; 5.5.1 MnMachinePrecision(); M determines the nominal precision itself in the default constructor MnMachinePrecision().; 5.5.2 setPrecision(double eps); Informs M that the relative floating point arithmetic precision is \(\mbox{eps}\). The method can be used to override M ’s own determination, when the user ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:48773,Modifiability,variab,variable,48773,"nPlot(); The default constructor initializes default settings for the text window size.; 5.9.2 operator(); MnPlot::operator()(const std::vector\(<\)std::pair\(<\)double,double\(>\) \(>\)&) prints a vector of (x,y) points on the text terminal. operator()(double xmin, double ymin, const std::vector\(<\)std::pair\(<\)double,double\(>\) \(>\)&) prints in addition the coordinates of the (x,y) values at the minimum.; 5.10 MnScan and ScanMinimizer; [api:scan]; MnScan scans the value of the user function by varying one parameter. It is sometimes useful for debugging the user function or finding a reasonable starting point. Constructor arguments, methods arguments and names of methods are the same as for MnMigrad and VariableMetricMinimizer.; 5.10.1 scan(unsigned int par, unsigned int npoint, double low, double high); Scans the value of the user function by varying parameter number \(\mbox{par}\), leaving all other parameters fixed at the current value. If \(\mbox{par}\) is not specified, all variable parameters are scanned in sequence. The number of points \(\mbox{npoints}\) in the scan is 40 by default, and cannot exceed 100. The range of the scan is by default 2 standard deviations on each side of the current best value, but can be specified as from \(\mbox{low}\) to \(\mbox{high}\). After each scan, if a new minimum is found, the best parameter values are retained as start values for future scans or minimizations. The curve resulting from each scan can be plotted on the output terminal using MnPlot [api:plot] in order to show the approximate behaviour of the function.; 5.10.2 ScanMinimizer; Although the \(\mbox{SCAN}\) method is not intended for minimization it can be used as a minimizer in its most primitive form.; 5.11 MnSimplex and SimplexMinimizer; [api:simplex]; \(\mbox{SIMPLEX}\) is a function minimization method using the simplex method of Nelder and Mead. MnSimplex provides minimization of the function by the method of \(\mbox{SIMPLEX}\) and the functionality for ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:53215,Modifiability,variab,variable,53215,"ds. In general, low values of \(\mbox{level}\) mean fewer function calls and high values mean more reliable minimization. Currently allowed values are 0 (low), 1 (default), and 2 (high).; 5.12.1 MnStrategy(); Default constructor, sets all settings according to \(\mbox{level}\)$ = 1.$; 5.12.2 MnStrategy(unsigned int level); Explicit constructor for predefined settings of desired \(\mbox{level}\) 0 (low), 1 (default), or 2 (high).; 5.12.3 setLowStrategy(), setMediumStrategy(), setHighStrategy(); Methods to set specific strategy level.; 5.12.4 Other methods; In addition, methods for individual settings such as setGradientNCycles() are provided.; 5.13 MnUserCovariance; [api:covariance] MnUserCovariance is the external covariance matrix designed for the interaction of the user. The result of the minimization (internal covariance matrix) is converted into the user representable format. It can also be used as input prior to the minimization. The size of the covariance matrix is according to the number of variable parameters (free and limited).; 5.13.1 MnUserCovariance(const std::vector\(<\)double\(>\)&, unsigned int nrow); Construct from data, positions of the elements in the array are arranged according to the packed storage format. The size of the array must be \(nrow*(nrow+1)/2\). The array must contain the upper triangular part of the symmetric matrix packed sequentially, column by column, so that arr(0) contains covar(0,0), arr(1) and arr(2) contain covar(0,1) and covar(1,1) respectively, and so on. The number of rows (columns) has to be specified.; 5.13.2 MnUserCovariance(unsigned int nrow); Specify the number of rows (columns) at instantiation. It will allocate an array of the length \(nrow*(nrow+1)/2\) and initialize it to \(0\). Elements can then be set using the method operator()(unsigned int, unsigned int).; 5.13.3 MnUserCovariance::operator()(unsigned int, unsigned int); Individual elements can be accessed via the operator(), both for reading and writing.; 5.14",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:54740,Modifiability,variab,variable,54740," int nrow); Specify the number of rows (columns) at instantiation. It will allocate an array of the length \(nrow*(nrow+1)/2\) and initialize it to \(0\). Elements can then be set using the method operator()(unsigned int, unsigned int).; 5.13.3 MnUserCovariance::operator()(unsigned int, unsigned int); Individual elements can be accessed via the operator(), both for reading and writing.; 5.14 MnUserParameters; [api:parameters] MnUserParameters is the main class for user interaction with the parameters. It serves both as input to the minimization as well as output as the result of the minimization is converted into the user representable format in order to allow for further interaction. Parameters for M can be added (defined) specifying a name, value and initial uncertainty.; 5.14.1 add(…); The method MnUserParameters::add(…) is overloaded for three kind of parameters:. add(const char*, double, double) for adding a free variable parameter; add(const char*, double, double, double, double) for adding a variable parameter with limits (lower and upper); add(const char*, double) for adding a constant parameter. When adding parameters, M assigns indices to each parameter which will be the same as in the std::vector\(<\)double\(>\) in the FCNBase::operator(). That means the first parameter the user adds gets index 0, the second index 1, and so on. When calculating the function value inside FCN, M will call FCNBase::operator() with the elements at their positions.; 5.14.2 setValue(…); [api:setvalue] setValue(unsigned int parno, double value) or setValue(const char* name, double value) set the value of parameter \(\mbox{parno}\) or with name \(\mbox{name}\) to \(\mbox{ value}\). The parameter in question may be variable, fixed, or constant, but must be defined.; 5.14.3 setError(…); [api:seterror] setError(unsigned int parno, double error) or setError(const char* name, double error) set the error (sigma) of parameter \(\mbox{parno}\) or with name \(\mbox{name}\) to \(\mbox{value",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:54822,Modifiability,variab,variable,54822," int nrow); Specify the number of rows (columns) at instantiation. It will allocate an array of the length \(nrow*(nrow+1)/2\) and initialize it to \(0\). Elements can then be set using the method operator()(unsigned int, unsigned int).; 5.13.3 MnUserCovariance::operator()(unsigned int, unsigned int); Individual elements can be accessed via the operator(), both for reading and writing.; 5.14 MnUserParameters; [api:parameters] MnUserParameters is the main class for user interaction with the parameters. It serves both as input to the minimization as well as output as the result of the minimization is converted into the user representable format in order to allow for further interaction. Parameters for M can be added (defined) specifying a name, value and initial uncertainty.; 5.14.1 add(…); The method MnUserParameters::add(…) is overloaded for three kind of parameters:. add(const char*, double, double) for adding a free variable parameter; add(const char*, double, double, double, double) for adding a variable parameter with limits (lower and upper); add(const char*, double) for adding a constant parameter. When adding parameters, M assigns indices to each parameter which will be the same as in the std::vector\(<\)double\(>\) in the FCNBase::operator(). That means the first parameter the user adds gets index 0, the second index 1, and so on. When calculating the function value inside FCN, M will call FCNBase::operator() with the elements at their positions.; 5.14.2 setValue(…); [api:setvalue] setValue(unsigned int parno, double value) or setValue(const char* name, double value) set the value of parameter \(\mbox{parno}\) or with name \(\mbox{name}\) to \(\mbox{ value}\). The parameter in question may be variable, fixed, or constant, but must be defined.; 5.14.3 setError(…); [api:seterror] setError(unsigned int parno, double error) or setError(const char* name, double error) set the error (sigma) of parameter \(\mbox{parno}\) or with name \(\mbox{name}\) to \(\mbox{value",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:55538,Modifiability,variab,variable,55538,"ifying a name, value and initial uncertainty.; 5.14.1 add(…); The method MnUserParameters::add(…) is overloaded for three kind of parameters:. add(const char*, double, double) for adding a free variable parameter; add(const char*, double, double, double, double) for adding a variable parameter with limits (lower and upper); add(const char*, double) for adding a constant parameter. When adding parameters, M assigns indices to each parameter which will be the same as in the std::vector\(<\)double\(>\) in the FCNBase::operator(). That means the first parameter the user adds gets index 0, the second index 1, and so on. When calculating the function value inside FCN, M will call FCNBase::operator() with the elements at their positions.; 5.14.2 setValue(…); [api:setvalue] setValue(unsigned int parno, double value) or setValue(const char* name, double value) set the value of parameter \(\mbox{parno}\) or with name \(\mbox{name}\) to \(\mbox{ value}\). The parameter in question may be variable, fixed, or constant, but must be defined.; 5.14.3 setError(…); [api:seterror] setError(unsigned int parno, double error) or setError(const char* name, double error) set the error (sigma) of parameter \(\mbox{parno}\) or with name \(\mbox{name}\) to \(\mbox{value}\).; 5.14.4 fix(…); [api:fix] fix(unsigned int parno) or fix(const char* name) fixes parameter \(\mbox{parno}\) or with name \(\mbox{name}\).; 5.14.5 release(…); [api:release] release(unsigned int parno) or release(const char* name) releases a previously fixed parameter \(\mbox{parno}\) or with name \(\mbox{name}\).; 5.14.6 setLimits(…); [api:setlimits] setLimits(unsigned int n, double low, double up) or setLimits(const char* name, double low, double up) sets the lower and upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\).; However, if \(\mbox{low}\) is equal to \(\mbox{up}\), an error condition results.; 5.14.7 setUpperLimit(…); [api:setupperlimits] setUpperLimit(unsigned int n, double up) or setUpperLimit(co",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:60858,Modifiability,variab,variable,60858,"State), the function value, the expected distance to the minimum and the number of function calls.; 5.16.2 operator\(<<\)(std::ostream&, const MnUserParameters&); Prints out the MnUserParameters.; 5.16.3 operator\(<<\)(std::ostream&, const MnUserCovariance&); Prints out the MnUserCovariance.; 5.16.4 operator\(<<\)(std::ostream&, const MnGlobalCorrelationCoeff&); Prints out the MnGlobalCorrelationCoeff.; 5.16.5 operator\(<<\)(std::ostream&, const MnUserParameterState&); Prints out the whole MnUserParameterState: MnUserParameters, MnUserCovariance and MnGlobalCorrelationCoeff.; 5.16.6 operator\(<<\)(std::ostream&, const MinosError&); Prints out the MinosError of a given parameter.; 5.16.7 operator\(<<\)(std::ostream&, const ContoursErros&); Prints out the MinosError of the two parameters and plots a line printer graphic of the contours on the output terminal.; 6 How to get the right answer from M; The goal of M — to be able to minimize and analyze parameter errors for all possible user functions with any number of variable parameters — is of course impossible to realise, even in principle, in a finite amount of time. In practice, some assumptions must be made about the behaviour of the function in order to avoid evaluating it at all possible points. In this chapter we give some hints on how the user can help M to make the right assumptions.; 6.1 Which minimizer to use; One of the historically interesting advantages of M is that it was probably the first minimization program to offer the user a choice of several minimization algorithms. This could be taken as a reflection of the fact that none of the algorithms known at that time were good enough to be universal, so users were encouraged to find the one that worked best for them. Since then, algorithms have improved considerably, but M still offers several, mostly so that old users will not feel cheated, but also to help the occasional user who does manage to defeat the best algorithms. M currently offers four applicati",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:62133,Modifiability,variab,variable-metric,62133,"s.; 6.1 Which minimizer to use; One of the historically interesting advantages of M is that it was probably the first minimization program to offer the user a choice of several minimization algorithms. This could be taken as a reflection of the fact that none of the algorithms known at that time were good enough to be universal, so users were encouraged to find the one that worked best for them. Since then, algorithms have improved considerably, but M still offers several, mostly so that old users will not feel cheated, but also to help the occasional user who does manage to defeat the best algorithms. M currently offers four applications which can be used to find a smaller function value, in addition to \(\mbox{MINOS}\), which will retain a smaller function value if it stumbles on one unexpectedly. The objects which can be used to minimize are:; 6.1.1 \(\mbox{MIGRAD}\); This is the best minimizer for nearly all functions. It is a variable-metric method with inexact line search, a stable metric updating scheme, and checks for positive-definiteness. It will run faster if you instantiate it with a low–level MnStrategy and will be more reliable if you instantiate it with a high–level MnStrategy (although the latter option may not help much). Its main weakness is that it depends heavily on knowledge of the first derivatives, and fails miserably if they are very inaccurate. If first derivatives are a problem, they can be calculated analytically inside \(\mbox{FCN}\) (see [howto:fcn]) or if this is not feasible, the user can try to improve the accuracy of M ’s numerical approximation by adjusting values of MnMachinePrecision and/or MnStrategy (see [api:epsmac] and [api:strategy]).; 6.1.2 \(\mbox{MINIMIZE}\); This is equivalent to \(\mbox{MIGRAD}\), except that if \(\mbox{MIGRAD}\) fails, it reverts to \(\mbox{SIMPLEX}\) and then calls \(\mbox{MIGRAD}\) again.; 6.1.3 \(\mbox{SCAN}\); This is not intended to minimize, and just scans the function, one parameter at a time. It",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:75777,Modifiability,variab,variables,75777,"n as M .; If the problem is only one of precision, and not of word length mismatch, an appropriate MnMachinePrecision::setPrecision() may fix it.; Trivial bugs in \(\mbox{FCN}\). The possibilities for bugs are numerous. Probably the most common among physicists inexperienced in is the confusion between double and int types, which you can sometimes get away with, but not always. 3 M can spot some trivial bugs itself, and issues a warning when it detects an unusual \(\mbox{FCN}\) behaviour. Such a warning should be taken seriously.; M also offers some tools (especially \(\mbox{SCAN}\)) which can help the user to find trivial bugs.; An ill–posed problem. For questions of parameter dependence, see the discussion above on postive–definiteness. Other mathematical problems which can arise are: excessive numerical roundoff — be especially careful of exponential and factorial functions which get big very quickly and lose accuracy; starting too far from the solution — the function may have unphysical local minima, especially at infinity in some variables; incorrect normalization — in likelihood functions, the probability distributions must be normalized or at least have an integral which is independent of the values of the variable parameters.; A bug in M . This is unlikely, but it happens. If a bug is suspected, and all other possible causes can be eliminated, please try to save a copy of the input and output files, listing of \(\mbox{FCN}\), and other information that may be relevant, and send them to \(\mbox{fred.james@cern.ch}\). 7 A complete example; [example:example]; Here a full example of a fit is presented, following the example DemoGaussSim.cpp.; 7.1 The user’s \(\mbox{FCN}\); The implementation of FCNBase by the user’s GaussFcn is shown here.; 7.1.1 GaussFunction.h; The user’s model function is a Gaussian.; #ifndef MN_GaussFunction_H_; #define MN_GaussFunction_H_. #include <math.h>. class GaussFunction {. public:. GaussFunction(double mean, double sig, double consta",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:75959,Modifiability,variab,variable,75959,"n as M .; If the problem is only one of precision, and not of word length mismatch, an appropriate MnMachinePrecision::setPrecision() may fix it.; Trivial bugs in \(\mbox{FCN}\). The possibilities for bugs are numerous. Probably the most common among physicists inexperienced in is the confusion between double and int types, which you can sometimes get away with, but not always. 3 M can spot some trivial bugs itself, and issues a warning when it detects an unusual \(\mbox{FCN}\) behaviour. Such a warning should be taken seriously.; M also offers some tools (especially \(\mbox{SCAN}\)) which can help the user to find trivial bugs.; An ill–posed problem. For questions of parameter dependence, see the discussion above on postive–definiteness. Other mathematical problems which can arise are: excessive numerical roundoff — be especially careful of exponential and factorial functions which get big very quickly and lose accuracy; starting too far from the solution — the function may have unphysical local minima, especially at infinity in some variables; incorrect normalization — in likelihood functions, the probability distributions must be normalized or at least have an integral which is independent of the values of the variable parameters.; A bug in M . This is unlikely, but it happens. If a bug is suspected, and all other possible causes can be eliminated, please try to save a copy of the input and output files, listing of \(\mbox{FCN}\), and other information that may be relevant, and send them to \(\mbox{fred.james@cern.ch}\). 7 A complete example; [example:example]; Here a full example of a fit is presented, following the example DemoGaussSim.cpp.; 7.1 The user’s \(\mbox{FCN}\); The implementation of FCNBase by the user’s GaussFcn is shown here.; 7.1.1 GaussFunction.h; The user’s model function is a Gaussian.; #ifndef MN_GaussFunction_H_; #define MN_GaussFunction_H_. #include <math.h>. class GaussFunction {. public:. GaussFunction(double mean, double sig, double consta",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:84796,Modifiability,variab,variable,84796,"td::endl;; std::cout<<""par1: ""; <<min.userState().value(1); <<"" ""<<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""; <<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""<<e2.second<<std::endl;; }; }. {; // demonstrate how to use the CONTOURs. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create contours factory with FCN and minimum; MnContours contours(theFCN, min);. // 70% confidence level for 2 parameters contour; // around the minimum; theFCN.setErrorDef(2.41);; std::vector<std::pair<double,double> > cont =; contours(0, 1, 20);. // 95% confidence level for 2 parameters contour; theFCN.setErrorDef(5.99);; std::vector<std::pair<double,double> > cont4 =; contours(0, 1, 20);. // plot the contours; MnPlot plot;; cont4.insert(cont4.end(), cont.begin(), cont.end());; plot(min.userState().value(""mean""),; min.userState().value(""sigma""),; cont4);; }. return 0;; };. ROOT @bib-ROOT uses its own version of the Fortran M when this manual was written. However an interface for this version exists and the library can be loaded dynamically on demand↩; The internal error matrix maintained by M is transformed for the user into external coordinates, but the numbering of rows and columns is of course still according to internal parameter numbering, since one does not want rows and columns corresponding to parameters which are not variable. The transformation therefore affects only parameters with limits; if there are no limits, internal and external error matrices are the same.↩; For example, if \(\mbox{a}\) and \(\mbox{b}\) are double precision variables, the statement \(\mbox{a = 2*b}\) is not good programming, but happens to do what the user probably intended, whereas the statement \(\mbox{a = b + 2/3}\) almost certainly will not do what the user intended.↩. ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:85016,Modifiability,variab,variables,85016,"td::endl;; std::cout<<""par1: ""; <<min.userState().value(1); <<"" ""<<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""; <<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""<<e2.second<<std::endl;; }; }. {; // demonstrate how to use the CONTOURs. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create contours factory with FCN and minimum; MnContours contours(theFCN, min);. // 70% confidence level for 2 parameters contour; // around the minimum; theFCN.setErrorDef(2.41);; std::vector<std::pair<double,double> > cont =; contours(0, 1, 20);. // 95% confidence level for 2 parameters contour; theFCN.setErrorDef(5.99);; std::vector<std::pair<double,double> > cont4 =; contours(0, 1, 20);. // plot the contours; MnPlot plot;; cont4.insert(cont4.end(), cont.begin(), cont.end());; plot(min.userState().value(""mean""),; min.userState().value(""sigma""),; cont4);; }. return 0;; };. ROOT @bib-ROOT uses its own version of the Fortran M when this manual was written. However an interface for this version exists and the library can be loaded dynamically on demand↩; The internal error matrix maintained by M is transformed for the user into external coordinates, but the numbering of rows and columns is of course still according to internal parameter numbering, since one does not want rows and columns corresponding to parameters which are not variable. The transformation therefore affects only parameters with limits; if there are no limits, internal and external error matrices are the same.↩; For example, if \(\mbox{a}\) and \(\mbox{b}\) are double precision variables, the statement \(\mbox{a = 2*b}\) is not good programming, but happens to do what the user probably intended, whereas the statement \(\mbox{a = b + 2/3}\) almost certainly will not do what the user intended.↩. ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:5487,Performance,perform,performance,5487,"with respect to the parameters, that is, find those values of the coefficients which give the lowest value of chisquare.; The user must therefore supply, in addition to the function to be analyzed, via a set or sequence of M applications the instructions which analysis is wanted. The instructions are coded in in the calling program (main.cpp), which allows looping, conditional execution, and all the other possibilities of , but not interactivity, since it must be compiled before execution.; 2.2 Design aspects of M in; What M is:. platform independent; written in an object-oriented way using standard; independent of any external package. The maintainability should be guaranteed with the choice of a modern computer language. Choosing object-oriented technology M should profit from an increased flexibility and functionality and make it also extendable (recursiveness, new algorithms, new functionality).; What M does not:. histogramming; data handling; graphics. M is kept as a low-level package with optimal performance.; The main usages of M are. from a user’s program (such as int main()…); from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. its numerical accuracy (equivalent to its Fortran version); its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a two-way strategy was imposed:. a minimal required interface with minimum interaction with M objects and with appropriate usage of the standard library (STL): the user’s implementation of the FCNBase class, initial parameter values and uncertainties are provided by the to M user via std::vectors.; a rich interface which provides the user with more functionality such as interaction with parameters. The core of the minimization functionality and related tools (the kernel of M ) should be clearly separated from the user, who is interfacing via defined user interfaces (the API).; 2.3 Internal ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:5757,Performance,perform,performance,5757," wanted. The instructions are coded in in the calling program (main.cpp), which allows looping, conditional execution, and all the other possibilities of , but not interactivity, since it must be compiled before execution.; 2.2 Design aspects of M in; What M is:. platform independent; written in an object-oriented way using standard; independent of any external package. The maintainability should be guaranteed with the choice of a modern computer language. Choosing object-oriented technology M should profit from an increased flexibility and functionality and make it also extendable (recursiveness, new algorithms, new functionality).; What M does not:. histogramming; data handling; graphics. M is kept as a low-level package with optimal performance.; The main usages of M are. from a user’s program (such as int main()…); from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. its numerical accuracy (equivalent to its Fortran version); its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a two-way strategy was imposed:. a minimal required interface with minimum interaction with M objects and with appropriate usage of the standard library (STL): the user’s implementation of the FCNBase class, initial parameter values and uncertainties are provided by the to M user via std::vectors.; a rich interface which provides the user with more functionality such as interaction with parameters. The core of the minimization functionality and related tools (the kernel of M ) should be clearly separated from the user, who is interfacing via defined user interfaces (the API).; 2.3 Internal and external parameters; Each of the parameters to the \(\mbox{FCN}\) is defined by the user as belonging to one of the following types:. Freely variable: allowed to take on any value.; Variable with double sided limits: allowed to vary only between two limits specified b",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:12217,Performance,perform,perform,12217,"\sqrt{(P_{\mathrm{ext}} - a + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& a - 1 + \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}\]; Upper bound \(b\):; \[\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(b - P_{\mathrm{ext}} + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& b + 1 - \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}\]; The transformation of course also affects the parameter error matrix, so M does a transformation of the error matrix (and the “parabolic” parameter errors) when there are parameter limits. Users should however realize that the transformation is only a linear approximation, and that it cannot give a meaningful result if one or more parameters is very close to a limit, where \(\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0\). Therefore, it is recommended that:. Limits on variable parameters should be used only when needed in order to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits. Further discussion of the effects of parameter limits may be found in the last chapter.; 2.4 M strategy; At many places in the analysis of the \(\mbox{FCN}\) (the user provided function), M must decide whether to be “safe” and waste a few function calls in order to know where it is, or to be “fast” and attempt to get the requested results with the fewest possible calls at a certain risk of not obtaining the precision desired by the user. In order to allow the user to influence these decisions, there is a M class MnStrategy (see [api:strategy]) which the user can use to put different settings. In the current release, this MnStrategy can be instantiated with three different minimization quality levels for low (0), medium (1) and high (2) quality. Default settings for iteration cycles and tolerances are initialized then. The default setting is set for medium quality. Value 0 (low) indicates to M that i",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:12231,Performance,perform,perform,12231,"\sqrt{(P_{\mathrm{ext}} - a + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& a - 1 + \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}\]; Upper bound \(b\):; \[\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(b - P_{\mathrm{ext}} + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& b + 1 - \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}\]; The transformation of course also affects the parameter error matrix, so M does a transformation of the error matrix (and the “parabolic” parameter errors) when there are parameter limits. Users should however realize that the transformation is only a linear approximation, and that it cannot give a meaningful result if one or more parameters is very close to a limit, where \(\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0\). Therefore, it is recommended that:. Limits on variable parameters should be used only when needed in order to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits. Further discussion of the effects of parameter limits may be found in the last chapter.; 2.4 M strategy; At many places in the analysis of the \(\mbox{FCN}\) (the user provided function), M must decide whether to be “safe” and waste a few function calls in order to know where it is, or to be “fast” and attempt to get the requested results with the fewest possible calls at a certain risk of not obtaining the precision desired by the user. In order to allow the user to influence these decisions, there is a M class MnStrategy (see [api:strategy]) which the user can use to put different settings. In the current release, this MnStrategy can be instantiated with three different minimization quality levels for low (0), medium (1) and high (2) quality. Default settings for iteration cycles and tolerances are initialized then. The default setting is set for medium quality. Value 0 (low) indicates to M that i",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:15765,Performance,perform,perform,15765,"the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they are interested in parameter errors, the user can change the error definition which allows them to define what they means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one “error”. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-deviation errors, then the error definition (return value of the FCNBase::up() method, see [howto:errordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FCNBase::up() to return is \(0.5\). If the \(\mbox{FCN}\) is a chisquare, but the user wants two-standard-deviation errors, then FCNBase::up() should return \(= 4.0\), etc.; Note that in the usual case where M is being used to perform a fit to some experimental data, the parameter errors will be proportional to the uncertainty in the data, and therefore meaningful parameter errors cannot be obtained unless the measurement errors of the data are known. In the common case of a least-squares fit, \(\mbox{FCN}\) is usually defined as a chisquare:; \[\chi^2 (\alpha) = \sum_{i=1}^{n} (\frac{f(x_i,\alpha) - m_i)^2}{\sigma_i^2}\]; where \(\alpha\) is the vector of free parameters being fitted, and the \(\sigma_i\) are the uncertainties in the individual measurements \(m_i\). If these uncertainties are not known, and are simply left out of the calculation, then the fit may still have meaning, but not the quantitative values of the resulting parameter errors. (Only the relative errors of different parameters with respect to each other may be meaningful.); If the \(\sigma_i\) are all overestimated by a factor \(\beta\), then the resulting parameter errors from the fit will be overestimated by the same factor \(\beta\).; 2.5.2 The error matrix; The M processors \(\mbox{MIGRAD}\) (MnMigrad, see [api:migrad",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:26845,Performance,perform,performance-optimized,26845," tar.gz from CVS; Once the sources are checked out from the CVS code repository,. change to the directory:; $ cd MathLibs/Minuit; run autogen:; $ ./autogen; create a new directory:; $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/; run configure:; $ ../Minuit/configure; create the tar.gz:; $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used as described above.; 3.5 M versions; The version numbers of M follow the release numbers of the SEAL project @bib-SEAL at CERN @bib-CERN.; 3.5.1 From to; The program is entirely written in standard portable . M does not depend on any external library. In its minimal usage the user must only provide an implementation of the FCNBase class to M and parameters and uncertainties in form of std::vector containers.; 3.5.2 Memory allocation and thread safety; Differently to the version of M , the version has its own memory manager (StackAllocator. The user can select between the standard dynamic memory allocation and deallocation (default) and performance-optimized stack–like allocation (optional). However, the library is not thread save using stack–allocation.; 3.5.3 M parameters; Differently to the version of M there is no limit on the number of parameters, variable or non-variable. Memory allocation is done dynamically according to the actual needs and “on demand”. There is no protection against an upper limit on the number of parameters, however the “technological” limitations of M can be seen around a maximum of 15 free parameters at a time.; 3.6 Interference with other packages; The new M has been designed to interfere as little as possible with other programs or packages which may be loaded at the same time. M is thread safe by default. Optionally the user can select a different way of dynamically allocating memory in the class StackAllacator for M , in which case (and after an entire recompilation of the whole library) the thread safety is lost.; 3.7 Floating-point precision; [install:epsmac]; M",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:27505,Performance,load,loaded,27505,"ibrary. In its minimal usage the user must only provide an implementation of the FCNBase class to M and parameters and uncertainties in form of std::vector containers.; 3.5.2 Memory allocation and thread safety; Differently to the version of M , the version has its own memory manager (StackAllocator. The user can select between the standard dynamic memory allocation and deallocation (default) and performance-optimized stack–like allocation (optional). However, the library is not thread save using stack–allocation.; 3.5.3 M parameters; Differently to the version of M there is no limit on the number of parameters, variable or non-variable. Memory allocation is done dynamically according to the actual needs and “on demand”. There is no protection against an upper limit on the number of parameters, however the “technological” limitations of M can be seen around a maximum of 15 free parameters at a time.; 3.6 Interference with other packages; The new M has been designed to interfere as little as possible with other programs or packages which may be loaded at the same time. M is thread safe by default. Optionally the user can select a different way of dynamically allocating memory in the class StackAllacator for M , in which case (and after an entire recompilation of the whole library) the thread safety is lost.; 3.7 Floating-point precision; [install:epsmac]; M is entirely based on double precision. The actual floating point precision of double precision (32–bit or 64–bit) is platform dependent and can even vary on the same platform, depending on whether a floating point number is read from memory a CPU register.; The argument of the user’s implementation of FCNBase::operator() is therefore a std:vector\(<\)double\(>\). M expects that the calculations inside \(\mbox{FCN}\) will be performed approximately to the same accuracy.; The accuracy M expects is called machine precision (MnMachinePrecision, see [api:epsmac]) and can be printed on demand using std::cout. If the use",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:28252,Performance,perform,performed,28252,"meters, however the “technological” limitations of M can be seen around a maximum of 15 free parameters at a time.; 3.6 Interference with other packages; The new M has been designed to interfere as little as possible with other programs or packages which may be loaded at the same time. M is thread safe by default. Optionally the user can select a different way of dynamically allocating memory in the class StackAllacator for M , in which case (and after an entire recompilation of the whole library) the thread safety is lost.; 3.7 Floating-point precision; [install:epsmac]; M is entirely based on double precision. The actual floating point precision of double precision (32–bit or 64–bit) is platform dependent and can even vary on the same platform, depending on whether a floating point number is read from memory a CPU register.; The argument of the user’s implementation of FCNBase::operator() is therefore a std:vector\(<\)double\(>\). M expects that the calculations inside \(\mbox{FCN}\) will be performed approximately to the same accuracy.; The accuracy M expects is called machine precision (MnMachinePrecision, see [api:epsmac]) and can be printed on demand using std::cout. If the user fools M by making internal \(\mbox{FCN}\) computations in single precision, M will interpret roundoff noise as significant and will usually either fail to find a minimum, or give incorrect values for the parameter errors.; It is therefore recommended to make sure that all computations in \(\mbox{FCN}\), as well as all methods and functions called by \(\mbox{FCN}\), are done in double precision. If for some reason the computations cannot be done to a precision comparable with that expected by M , the user must inform M of this situation with setting a different machine precision via the MnMachinePrecision::setPrecision(double) method.; With reduced precision, the user may find that certain features sensitive to first and second differences (\(\mbox{HESSE}\), \(\mbox{MINOS}\), \(\mbox{CO",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:29315,Performance,perform,performed,29315,"tions inside \(\mbox{FCN}\) will be performed approximately to the same accuracy.; The accuracy M expects is called machine precision (MnMachinePrecision, see [api:epsmac]) and can be printed on demand using std::cout. If the user fools M by making internal \(\mbox{FCN}\) computations in single precision, M will interpret roundoff noise as significant and will usually either fail to find a minimum, or give incorrect values for the parameter errors.; It is therefore recommended to make sure that all computations in \(\mbox{FCN}\), as well as all methods and functions called by \(\mbox{FCN}\), are done in double precision. If for some reason the computations cannot be done to a precision comparable with that expected by M , the user must inform M of this situation with setting a different machine precision via the MnMachinePrecision::setPrecision(double) method.; With reduced precision, the user may find that certain features sensitive to first and second differences (\(\mbox{HESSE}\), \(\mbox{MINOS}\), \(\mbox{CONTOURS}\)) do not work properly, in which case the calculations must be performed in higher precision.; 4 How to use M; [howto:howto]; 4.1 The \(\mbox{FCN}\) Function; [howto:fcn]; The user must always implement a derived class of FCNBase (the “\(\mbox{FCN}\)”) which calculates the function value to be minimized or analyzed. Note that when M is being used through an intermediate package such as HippoDraw @bib-HippoDraw, then the user’s \(\mbox{FCN}\) may be supplied by the this package.; The name of the user’s class to implement the FCNBase interface may be chosen freely (in documentation we give it the generic name \(\mbox{FCN}\)).; 4.1.1 FCNBase::operator()(const std::vector\(<\)double\(>\)&); The meaning of the vector of parameters std::vector\(<\)double\(>\) in the argument of FCNBase::operator() are of course defined by the user, who uses the values of those parameters to calculate their function value. The order and the position of these parameters is st",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:30617,Performance,perform,performs,30617,"an intermediate package such as HippoDraw @bib-HippoDraw, then the user’s \(\mbox{FCN}\) may be supplied by the this package.; The name of the user’s class to implement the FCNBase interface may be chosen freely (in documentation we give it the generic name \(\mbox{FCN}\)).; 4.1.1 FCNBase::operator()(const std::vector\(<\)double\(>\)&); The meaning of the vector of parameters std::vector\(<\)double\(>\) in the argument of FCNBase::operator() are of course defined by the user, who uses the values of those parameters to calculate their function value. The order and the position of these parameters is strictly the one specified by the user when supplying the starting values for minimization.; The starting values must be specified by the user, either via an std::vector\(<\)double\(>\) or the MnUserParameters (see [api:parameters]) supplied as input to the M minimizers such as VariableMetricMinimizer or MnMigrad (see [api:migrad]). Later values are determined by M as it searches for the minimum or performs whatever analysis is requested by the user.; 4.1.2 FCNBase::up(); [howto:errordef] Returns the value of \(\mbox{up}\) (default value \(= 1.\)), defining parameter errors. M defines parameter errors as the change in parameter value required to change the function value by \(\mbox{up}\). Normally, for chisquared fits \(\mbox{up = 1}\), and for negative log likelihood, \(\mbox{up = 0.5}\).; 4.1.3 \(\mbox{FCN}\) function with gradient; By default first derivatives are calculated numerically by M . In case the user wants to supply their own gradient calculator (e.g. analytical derivatives), they need to implement the FCNGradientBase interface. The size of the output vector is the same as of the input one. The same is true for the position of the elements (first derivative of the function with respect to the \(n_\mathrm{th}\) variable has index \(n\) in the output vector).; 4.2 M parameters; Interaction with the parameters of the function are essential both for M and the use",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:35062,Performance,perform,performed,35062,"ng them a name, value, uncertainty. Once all parameters are added to MnUserParameters, they can fix a parameter or put limits on another one before handing them over to Minuit for minimization.; 4.3.2 What the user can supply; Optionally the user can supply their own gradient calculator by implementing the FCNGradientBase interface or supply a full covariance matrix for input if one is available. The covariance matrix can be supplied in form of a std::vector\(<\)double\(>\) in packed storage format (upper triangular), or in a more user-friendly way by using the interface provided by the MnUserCovariance.; 4.4 Running a M minimization; Two use cases are addressed for minimization:. The user just wants the function to be minimized in one go.; The user wants to minimize the \(\mbox{FCN}\) in several minimization steps, re-using the result of the preceeding minimization in the next step and change parameters in between (fix/release/put limits on them, etc.). How M minimizations can be performed is shown in [example:main].; 4.4.1 Direct usage of minimizers; Minimizers such as the VariableMetricMinimizer are designed as state-less minimization engines, which means that they do not depend on the current function and its parameters. Any \(\mbox{FCN}\) function can be minimized with the same minimizer. The interface is restricted to minimization and no parameter interaction is possible.; 4.4.2 Using an application (MnMigrad); MnMigrad uses the VariableMetricMinimizer for minimization but allows as well for parameter interaction by the user. An instance of MnMigrad is specific to the current \(\mbox{FCN}\) and user parameters. Any parameter interaction of the user between two minimization steps will make use of the result of the preceeding minimization in an optimal way. The interface for parameters (see [api:parameters], [api:covariance] and [api:state]) is forwardedin MnMigrad.; 4.4.3 Subsequent minimizations; M takes care that all information is treated in an optimal and co",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:41329,Performance,perform,perform,41329,"- 2}\) variable parameters (if any). M will try to find \(\mbox{npoints}\) points on the contour (default 20). To calculate more than one contour, the user needs to set the error definition [howto:errordef] in its \(\mbox{FCN}\) to the appropriate value for the desired confidence level and call the method MnContours::operator() for each contour.; 5.2.3 contour(…); MnContours::contour(unsigned int parx, unsigned int pary, unsigned int npoints = 20) causes a \(\mbox{CONTOURS}\) error analysis and returns the result in form of ContoursError. As a by-product ContoursError keeps the MinosError information of parameters \(\mbox{parx}\) and \(\mbox{pary}\). The result ContoursError can be easily printed using std::cout.; 5.3 MnEigen; [api:eigen] MnEigen calculates and the eigenvalues of the user covariance matrix MnUserCovariance.; 5.3.1 MnEigen(); MnEigen is instantiated via default constructor.; 5.3.2 operator(); operator()(const MnUserCovariance&) const will perform the calculation of the eigenvalues of the covariance matrix and return the result in form of a std::vector<double>. The eigenvalues are ordered from the smallest first to the largest eigenvalue.; 5.4 MnHesse; [api:hesse]; With MnHesse the user can instructs M to calculate, by finite differences, the Hessian or error matrix. That is, it calculates the full matrix of second derivatives of the function with respect to the currently variable parameters, and inverts it.; 5.4.1 MnHesse(); The default constructor of MnHesse() will use default settings of MnStrategy. Other constructors with user specific MnStrategy settings are provided as well.; 5.4.2 operator(); The MnHesse::operator() is overloaded both for internal (M ) and external (user) parameters. External parameters can be specified as std::vector\(<\)double\(>\) or as MnUserParameters. The return value is always a MnUserParameterState.; The optional argument \(\mbox{maxcalls}\) specifies the (approximate) maximum number of function calls after which the ca",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:46220,Performance,perform,performed,46220," and forwards the interface.; 5.6.6 VariableMetricMinimizer(); The VariableMetricMinimizer is instantiated using default constructor.; 5.6.7 minimize(const FCNBase&, …); The VariableMetricMinimizer provides several overloaded methods minimize with return value FunctionMinimum. Together with the user \(\mbox{FCN}\) (either an implementation of FCNBase or FCNGradientBase) the user has to give as input the parameters with starting values in one of the defined formats (std::vector\(<\)double\(>\), MnUserParameters or MnUserParameterState).; 5.7 MnMinimize and CombinedMinimizer; [api:minimize]; Causes minimization of the function by the method of \(\mbox{MIGRAD}\), as does the MnMigrad class, but switches to the \(\mbox{SIMPLEX}\) method if \(\mbox{MIGRAD}\) fails to converge. Constructor arguments, methods arguments and names of methods are the same as for MnMigrad or MnSimplex and VariableMetricMinimizer or SimplexMinimizer.; 5.8 MnMinos; [api:minos] Causes a \(\mbox{MINOS}\) error analysis to be performed on the parameter whose number is specified. \(\mbox{MINOS}\) errors may be expensive to calculate, but are very reliable since they take account of non-linearities in the problem as well as parameter correlations, and are in general asymmetric. The optional argument \(\mbox{maxcalls}\) specifies the (approximate) maximum number of function calls per parameter requested, after which the calculation will be stopped for that parameter.; 5.8.1 MnMinos(const FCNBase&, const FunctionMinimum&); Construct an MnMinos object from the user’s \(\mbox{FCN}\) and a valid FunctionMinimum. Additional constructors for user specific MnStrategy settings are provided.; 5.8.2 operator(); MnMinos::operator()(unsigned int n, unsigned int maxcalls) causes a \(\mbox{MINOS}\) error analysis for external parameter \(\mbox{n}\). The return value is a std::pair\(<\)double,double\(>\) with the lower and upper bounds of parameter \(\mbox{n}\).; 5.8.3 minos(unsigned int n, unsigned int maxcalls); Mn",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:84485,Performance,load,loaded,84485,"td::endl;; std::cout<<""par1: ""; <<min.userState().value(1); <<"" ""<<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""; <<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""<<e2.second<<std::endl;; }; }. {; // demonstrate how to use the CONTOURs. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create contours factory with FCN and minimum; MnContours contours(theFCN, min);. // 70% confidence level for 2 parameters contour; // around the minimum; theFCN.setErrorDef(2.41);; std::vector<std::pair<double,double> > cont =; contours(0, 1, 20);. // 95% confidence level for 2 parameters contour; theFCN.setErrorDef(5.99);; std::vector<std::pair<double,double> > cont4 =; contours(0, 1, 20);. // plot the contours; MnPlot plot;; cont4.insert(cont4.end(), cont.begin(), cont.end());; plot(min.userState().value(""mean""),; min.userState().value(""sigma""),; cont4);; }. return 0;; };. ROOT @bib-ROOT uses its own version of the Fortran M when this manual was written. However an interface for this version exists and the library can be loaded dynamically on demand↩; The internal error matrix maintained by M is transformed for the user into external coordinates, but the numbering of rows and columns is of course still according to internal parameter numbering, since one does not want rows and columns corresponding to parameters which are not variable. The transformation therefore affects only parameters with limits; if there are no limits, internal and external error matrices are the same.↩; For example, if \(\mbox{a}\) and \(\mbox{b}\) are double precision variables, the statement \(\mbox{a = 2*b}\) is not good programming, but happens to do what the user probably intended, whereas the statement \(\mbox{a = b + 2/3}\) almost certainly will not do what the user intended.↩. ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:2314,Safety,detect,detector,2314,"ers; 6.5 Interpretation of parameter errors; 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; 6.7 Additional trouble–shooting. 7 A complete example; 7.1 The user’s \(\mbox{FCN}\); 7.2 The user’s main program. Minuit 2; *** Fred JAMES and Matthias WINKLER CERN, Geneva ***; 1 Foreword; 1.1 What M is intended to do; M is conceived as a tool to find the minimum value of a multi-parameter function (the “\(\mbox{FCN}\)”) and analyze the shape of the function around the minimum. The principal application is foreseen for statistical analysis, working on chisquare or log-likelihood functions, to compute the best-fit parameter values and uncertainties, including correlations between the parameters. It is especially suited to handle difficult problems, including those which may require guidance in order to find the correct solution.; 1.2 What M is not intended to do; Although M will of course solve easy problems faster than complicated ones, it is not intended for the repeated solution of identically parametrized problems (such as track fitting in a detector) where a specialized program will in general be much more efficient.; 1.3 Further remarks; M was initially written in Fortran around 1975-1980 at CERN by Fred James @bib-MINUIT. Its main field of usage is statistical data analysis of experimental data recorded at CERN, but it is also used by people doing data analysis outside CERN or outside high energy physics (HEP). In 2002 Fred James started a project aiming to re-implement M in an object-oriented way using .; More information about recent developments, releases and installation can be obtained from the M homepage @bib-C++MINUIT.; The names of M applications are written in capital letters (e.g. \(\mbox{MIGRAD}\), \(\mbox{MINOS}\), \(\mbox{CONTOURS}\)), the corresponding names of the classes are written using sans-serif font type (MnMigrad, MnMinos, MnContours).; 2 Introduction: M basic concepts; [sec:intro]; 2.1 The organization of M; The M package acts o",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:7964,Safety,avoid,avoid,7964,"only the value the parameter had at the moment it was fixed, or a value later assigned by the user.; Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are free and unbound.; The user, in their \(\mbox{FCN}\), must of course be able to “see” all types of defined parameters, and they therefore have access to what we call the external parameter list, that is, the parameters as he defined them. On the other hand, the internal M minimizing routines only want to “see” variable parameters without limits, and so they have access only to the internal parameter list which is created from the external list by the following transformation:. Squeeze out all parameters that are not variable.; Transform all variable parameters with limits, so that the transformed parameter can vary without limits. (See the next section for details concerning this transformation.) Because this transformation is non-linear, it is recommended to avoid putting limits on parameters where they are not needed. As an example, suppose that the user has defined the following parameters:. Parameter 0, constant.; Parameter 1, freely variable.; Parameter 2, variable with limits.; Parameter 3, constant.; Parameter 4, freely variable. Then the internal parameter list would be as follows:. Internal parameter 0 = external parameter 1.; Internal parameter 1 = external parameter 2, transformed appropriately.; Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters is 5, and the number of internal parameters is 3. This is the number which determines, for example, the size of the error matrix of the parameters, since only variable parameters have errors.; An important feature of M is that parameters are allowed to change types during the M minimization and analysis of a \(\mbox{FCN}\) function. Several applications in M have methods available to make variable parameters fixed and v",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:10273,Safety,avoid,avoided,10273,"variable parameters to be temporarily fixed during the calculation. Therefore, the correspondence between external and internal parameter lists is in general a dynamic one, and the number of internal parameters is not necessarily constant.; For more details about parameter interaction see [api:parameters].; 2.3.1 The transformation for parameters with limits; [intro:limits]; For variable parameters with double sided limits \(a\) (lower) and \(b\) (upper), M uses the following transformation:; \[\begin{aligned}; P_{\mathrm{int}} &=& \arcsin; \left( 2\: \frac{ P_{\mathrm{ext}}-a}{ b-a} - 1 \right) \\; P_{\mathrm{ext}} &=& a + \frac{ b - a}{ 2}; \left( \sin P_{\mathrm{int}} + 1 \right) \end{aligned}\]; so that the internal value \(P_{\mathrm{int}}\) can take on any value, while the external value \(P_{\mathrm{ext}}\) can take on values only between the lower limit \(a\) and the upper limit \(b\). Since the transformation is necessarily non-linear, it would transform a nice linear problem into a nasty non-linear one, which is the reason why limits should be avoided if not necessary. In addition, the transformation does require some computer time, so it slows down the computation a little bit, and more importantly, it introduces additional numerical inaccuracy into the problem in addition to what is introduced in the numerical calculation of the \(\mbox{FCN}\) value. The effects of non-linearity and numerical roundoff both become more important as the external value gets closer to one of the limits (expressed as the distance to nearest limit divided by distance between limits). The user must therefore be aware of the fact that, for example, if they put limits of \((0,10^{10})\) on a parameter, then the values \(0.0\) and \(1.0\) will be indistinguishable to the accuracy of most machines.; For this purpose single sided limits on parameters are provided by M , with their transformation being:; Lower bound \(a\):; \[\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(P_{\mathrm{",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:12491,Safety,safe,safe,12491,"eter error matrix, so M does a transformation of the error matrix (and the “parabolic” parameter errors) when there are parameter limits. Users should however realize that the transformation is only a linear approximation, and that it cannot give a meaningful result if one or more parameters is very close to a limit, where \(\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0\). Therefore, it is recommended that:. Limits on variable parameters should be used only when needed in order to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits. Further discussion of the effects of parameter limits may be found in the last chapter.; 2.4 M strategy; At many places in the analysis of the \(\mbox{FCN}\) (the user provided function), M must decide whether to be “safe” and waste a few function calls in order to know where it is, or to be “fast” and attempt to get the requested results with the fewest possible calls at a certain risk of not obtaining the precision desired by the user. In order to allow the user to influence these decisions, there is a M class MnStrategy (see [api:strategy]) which the user can use to put different settings. In the current release, this MnStrategy can be instantiated with three different minimization quality levels for low (0), medium (1) and high (2) quality. Default settings for iteration cycles and tolerances are initialized then. The default setting is set for medium quality. Value 0 (low) indicates to M that it should economize function calls; it is intended for cases where there are many variable parameters and/or the function takes a long time to calculate and/or the user is not interested in very precise values for parameter errors. On the other hand, value 2 (high) indicates that M is allowed to waste function calls in order to be sure that all values a",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:12659,Safety,risk,risk,12659,"eter error matrix, so M does a transformation of the error matrix (and the “parabolic” parameter errors) when there are parameter limits. Users should however realize that the transformation is only a linear approximation, and that it cannot give a meaningful result if one or more parameters is very close to a limit, where \(\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0\). Therefore, it is recommended that:. Limits on variable parameters should be used only when needed in order to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits. Further discussion of the effects of parameter limits may be found in the last chapter.; 2.4 M strategy; At many places in the analysis of the \(\mbox{FCN}\) (the user provided function), M must decide whether to be “safe” and waste a few function calls in order to know where it is, or to be “fast” and attempt to get the requested results with the fewest possible calls at a certain risk of not obtaining the precision desired by the user. In order to allow the user to influence these decisions, there is a M class MnStrategy (see [api:strategy]) which the user can use to put different settings. In the current release, this MnStrategy can be instantiated with three different minimization quality levels for low (0), medium (1) and high (2) quality. Default settings for iteration cycles and tolerances are initialized then. The default setting is set for medium quality. Value 0 (low) indicates to M that it should economize function calls; it is intended for cases where there are many variable parameters and/or the function takes a long time to calculate and/or the user is not interested in very precise values for parameter errors. On the other hand, value 2 (high) indicates that M is allowed to waste function calls in order to be sure that all values a",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:20552,Safety,predict,predict,20552,"causes \({\displaystyle F'}\) to increase by the amount FCNBase::up(), where \({\displaystyle F'}\) is the minimum of \(\mbox{FCN}\) with respect to all other free parameters, and FCNBase::up() is the return value of the error definition specified by the user (default = 1.).; The algorithm for finding the positive and negative \(\mbox{MINOS}\) errors for parameter \(\mbox{n}\) consists of varying parameter \(\mbox{n}\), each time minimizing \(\mbox{FCN}\) with respect to all the other \(\mbox{npar - 1}\) variable parameters, to find numerically the two values of parameter \(\mbox{n}\) for which the minimum of \(\mbox{FCN}\) takes on the values \(\displaystyle F_{\mathrm{min}} + \mbox{up}\), where \(\displaystyle F_{\mathrm{min}}\) is the minimum of \(\mbox{FCN}\) with respect to all \(\mbox{npar}\) parameters. In order to make the procedure as fast as possible, \(\mbox{MINOS}\) uses the error matrix to predict the values of all parameters at the various sub-minima which it will have to find in the course of the calculation, and in the limit that the problem is nearly linear, the predictions of \(\mbox{MINOS}\) will be nearly exact, requiring very few iterations. On the other hand, when the problem is very non-linear (i.e., \(\mbox{FCN}\) is far from a quadratic function of its parameters), is precisely the situation when \(\mbox{MINOS}\) is needed in order to indicate the correct parameter errors.; 2.5.4 \(\mbox{CONTOURS}\) plotting; M offers a procedure for finding \(\mbox{FCN}\) \(\mbox{CONTOURS}\) (provided via the class MnContours, see [api:contours]).; The contour calculated by MnContours::operator() is dynamic, in the sense that it represents the minimum of \(\mbox{FCN}\) with respect to all the other \(\mbox{npar - 2}\) parameters (if any). In statistical terms, this means that MnContours takes account of the correlations between the two parameters being plotted, and all the other variable parameters, using a procedure analogous to that of \(\mbox{MINOS}\). (I",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:20732,Safety,predict,predictions,20732,"causes \({\displaystyle F'}\) to increase by the amount FCNBase::up(), where \({\displaystyle F'}\) is the minimum of \(\mbox{FCN}\) with respect to all other free parameters, and FCNBase::up() is the return value of the error definition specified by the user (default = 1.).; The algorithm for finding the positive and negative \(\mbox{MINOS}\) errors for parameter \(\mbox{n}\) consists of varying parameter \(\mbox{n}\), each time minimizing \(\mbox{FCN}\) with respect to all the other \(\mbox{npar - 1}\) variable parameters, to find numerically the two values of parameter \(\mbox{n}\) for which the minimum of \(\mbox{FCN}\) takes on the values \(\displaystyle F_{\mathrm{min}} + \mbox{up}\), where \(\displaystyle F_{\mathrm{min}}\) is the minimum of \(\mbox{FCN}\) with respect to all \(\mbox{npar}\) parameters. In order to make the procedure as fast as possible, \(\mbox{MINOS}\) uses the error matrix to predict the values of all parameters at the various sub-minima which it will have to find in the course of the calculation, and in the limit that the problem is nearly linear, the predictions of \(\mbox{MINOS}\) will be nearly exact, requiring very few iterations. On the other hand, when the problem is very non-linear (i.e., \(\mbox{FCN}\) is far from a quadratic function of its parameters), is precisely the situation when \(\mbox{MINOS}\) is needed in order to indicate the correct parameter errors.; 2.5.4 \(\mbox{CONTOURS}\) plotting; M offers a procedure for finding \(\mbox{FCN}\) \(\mbox{CONTOURS}\) (provided via the class MnContours, see [api:contours]).; The contour calculated by MnContours::operator() is dynamic, in the sense that it represents the minimum of \(\mbox{FCN}\) with respect to all the other \(\mbox{npar - 2}\) parameters (if any). In statistical terms, this means that MnContours takes account of the correlations between the two parameters being plotted, and all the other variable parameters, using a procedure analogous to that of \(\mbox{MINOS}\). (I",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:26649,Safety,safe,safety,26649,"s/Minuit; (If you want to check out a tagged version SEAL_x_x_x of MINUIT, then do; $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ); 3.4 Create a tar.gz from CVS; Once the sources are checked out from the CVS code repository,. change to the directory:; $ cd MathLibs/Minuit; run autogen:; $ ./autogen; create a new directory:; $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/; run configure:; $ ../Minuit/configure; create the tar.gz:; $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used as described above.; 3.5 M versions; The version numbers of M follow the release numbers of the SEAL project @bib-SEAL at CERN @bib-CERN.; 3.5.1 From to; The program is entirely written in standard portable . M does not depend on any external library. In its minimal usage the user must only provide an implementation of the FCNBase class to M and parameters and uncertainties in form of std::vector containers.; 3.5.2 Memory allocation and thread safety; Differently to the version of M , the version has its own memory manager (StackAllocator. The user can select between the standard dynamic memory allocation and deallocation (default) and performance-optimized stack–like allocation (optional). However, the library is not thread save using stack–allocation.; 3.5.3 M parameters; Differently to the version of M there is no limit on the number of parameters, variable or non-variable. Memory allocation is done dynamically according to the actual needs and “on demand”. There is no protection against an upper limit on the number of parameters, however the “technological” limitations of M can be seen around a maximum of 15 free parameters at a time.; 3.6 Interference with other packages; The new M has been designed to interfere as little as possible with other programs or packages which may be loaded at the same time. M is thread safe by default. Optionally the user can select a different way of dynamically allocating memory in the class StackAllacator for M , in whic",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:27542,Safety,safe,safe,27542,"M and parameters and uncertainties in form of std::vector containers.; 3.5.2 Memory allocation and thread safety; Differently to the version of M , the version has its own memory manager (StackAllocator. The user can select between the standard dynamic memory allocation and deallocation (default) and performance-optimized stack–like allocation (optional). However, the library is not thread save using stack–allocation.; 3.5.3 M parameters; Differently to the version of M there is no limit on the number of parameters, variable or non-variable. Memory allocation is done dynamically according to the actual needs and “on demand”. There is no protection against an upper limit on the number of parameters, however the “technological” limitations of M can be seen around a maximum of 15 free parameters at a time.; 3.6 Interference with other packages; The new M has been designed to interfere as little as possible with other programs or packages which may be loaded at the same time. M is thread safe by default. Optionally the user can select a different way of dynamically allocating memory in the class StackAllacator for M , in which case (and after an entire recompilation of the whole library) the thread safety is lost.; 3.7 Floating-point precision; [install:epsmac]; M is entirely based on double precision. The actual floating point precision of double precision (32–bit or 64–bit) is platform dependent and can even vary on the same platform, depending on whether a floating point number is read from memory a CPU register.; The argument of the user’s implementation of FCNBase::operator() is therefore a std:vector\(<\)double\(>\). M expects that the calculations inside \(\mbox{FCN}\) will be performed approximately to the same accuracy.; The accuracy M expects is called machine precision (MnMachinePrecision, see [api:epsmac]) and can be printed on demand using std::cout. If the user fools M by making internal \(\mbox{FCN}\) computations in single precision, M will interpret roun",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:27757,Safety,safe,safety,27757,"tly to the version of M , the version has its own memory manager (StackAllocator. The user can select between the standard dynamic memory allocation and deallocation (default) and performance-optimized stack–like allocation (optional). However, the library is not thread save using stack–allocation.; 3.5.3 M parameters; Differently to the version of M there is no limit on the number of parameters, variable or non-variable. Memory allocation is done dynamically according to the actual needs and “on demand”. There is no protection against an upper limit on the number of parameters, however the “technological” limitations of M can be seen around a maximum of 15 free parameters at a time.; 3.6 Interference with other packages; The new M has been designed to interfere as little as possible with other programs or packages which may be loaded at the same time. M is thread safe by default. Optionally the user can select a different way of dynamically allocating memory in the class StackAllacator for M , in which case (and after an entire recompilation of the whole library) the thread safety is lost.; 3.7 Floating-point precision; [install:epsmac]; M is entirely based on double precision. The actual floating point precision of double precision (32–bit or 64–bit) is platform dependent and can even vary on the same platform, depending on whether a floating point number is read from memory a CPU register.; The argument of the user’s implementation of FCNBase::operator() is therefore a std:vector\(<\)double\(>\). M expects that the calculations inside \(\mbox{FCN}\) will be performed approximately to the same accuracy.; The accuracy M expects is called machine precision (MnMachinePrecision, see [api:epsmac]) and can be printed on demand using std::cout. If the user fools M by making internal \(\mbox{FCN}\) computations in single precision, M will interpret roundoff noise as significant and will usually either fail to find a minimum, or give incorrect values for the parameter erro",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:61054,Safety,avoid,avoid,61054,"16.3 operator\(<<\)(std::ostream&, const MnUserCovariance&); Prints out the MnUserCovariance.; 5.16.4 operator\(<<\)(std::ostream&, const MnGlobalCorrelationCoeff&); Prints out the MnGlobalCorrelationCoeff.; 5.16.5 operator\(<<\)(std::ostream&, const MnUserParameterState&); Prints out the whole MnUserParameterState: MnUserParameters, MnUserCovariance and MnGlobalCorrelationCoeff.; 5.16.6 operator\(<<\)(std::ostream&, const MinosError&); Prints out the MinosError of a given parameter.; 5.16.7 operator\(<<\)(std::ostream&, const ContoursErros&); Prints out the MinosError of the two parameters and plots a line printer graphic of the contours on the output terminal.; 6 How to get the right answer from M; The goal of M — to be able to minimize and analyze parameter errors for all possible user functions with any number of variable parameters — is of course impossible to realise, even in principle, in a finite amount of time. In practice, some assumptions must be made about the behaviour of the function in order to avoid evaluating it at all possible points. In this chapter we give some hints on how the user can help M to make the right assumptions.; 6.1 Which minimizer to use; One of the historically interesting advantages of M is that it was probably the first minimization program to offer the user a choice of several minimization algorithms. This could be taken as a reflection of the fact that none of the algorithms known at that time were good enough to be universal, so users were encouraged to find the one that worked best for them. Since then, algorithms have improved considerably, but M still offers several, mostly so that old users will not feel cheated, but also to help the occasional user who does manage to defeat the best algorithms. M currently offers four applications which can be used to find a smaller function value, in addition to \(\mbox{MINOS}\), which will retain a smaller function value if it stumbles on one unexpectedly. The objects which can be used t",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:64711,Safety,avoid,avoided,64711,"out parameter correlations, and worst of all cannot be expected to converge accurately to the minimum in a finite time. Its estimate of the expected distance to the minimum \(\mbox{EDM}\) is largely fantasy, so it would not even know if it did converge.; 6.2 Floating point precision; M figures out at execution time the machine precision [api:epsmac], and assumes that \(\mbox{FCN}\) provides about the same precision. That means not just the length of the numbers used and returned by \(\mbox{FCN}\), but the actual mathematical accuracy of the calculations. Section [install:epsmac] describes what to do if this is not the case.; 6.3 Parameter limits; Putting limits (absolute bounds) on the allowed values for a given parameter, causes M to make a non-linear transformation of its own internal parameter values to obtain the (external) parameter values passed to \(\mbox{FCN}\). To understand the adverse effect of limits, see [intro:limits].; Basically, the use of limits should be avoided unless needed to keep the parameter inside a desired range.; If parameter limits are needed, in spite of the effects described in Chapter One, then the user should be aware of the following techniques to alleviate problems caused by limits.; 6.3.1 Getting the Right Minimum with Limits; If \(\mbox{MIGRAD}\) converges normally to a point where no parameter is near one of its limits, then the existence of limits has probably not prevented M from finding the right minimum. On the other hand, if one or more parameters is near its limit at the minimum, this may be because the true minimum is indeed at a limit, or it may be because the minimizer has become “blocked” at a limit. This may normally happen only if the parameter is so close to a limit (internal value at an odd multiple of \(\pm \frac{ \pi}{ 2}\) that M prints a warning to this effect when it prints the parameter values.; The minimizer can become blocked at a limit, because at a limit the derivative seen by the minimizer \(\partial F / ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:67997,Safety,avoid,avoid,67997,"gn only symmetric errors, then becomes essentially meaningless. On the other hand, the \(\mbox{MINOS}\) analysis is still meaningful, at least in principle, as long as \(\mbox{MIGRAD}\) (which is called internally by \(\mbox{MINOS}\)) does not get blocked at a limit. Unfortunately, the user has no control over this aspect of the \(\mbox{MINOS}\) calculation, although it is possible to get enough printout from the \(\mbox{MINOS}\) result to be able to determine whether the results are reliable or not.; 6.4 Fixing and releasing parameters; When M needs to be guided to the “right” minimum, often the best way to do this is with the methods e.g. MnMigrad::fix(…) and MnMigrad::release(…). That is, suppose you have a problem with ten free parameters, and when you minimize with respect to all at once, M goes to an unphysical solution characterized by an unphysical or unwanted value of parameter number four. One way to avoid this is to fix parameter four at a “good” value (not necessarily the best, since you presumably don’t know that yet), and minimize with respect to the others. Then release parameter four and minimize again. If the problem admits a “good” physical solution, you will normally find it this way. If it doesn’t work, you may see what is wrong by the following sequence (where \(\mbox{xxx}\) is the expected physical value for parameter four):; MnMigrad migrad(...);; migrad.setValue(4, xxx);; migrad.fix(4);; FunctionMinimum min = migrad();; migrad.release(4);; MnScan scan(...);; std::vector<std::pair<double, double> > points = scan(4);; where \(\mbox{SCAN}\) gives you a picture of \(\mbox{FCN}\) as a function of parameter four alone, the others being fixed at their current best values. If you suspect the difficulty is due to parameter five, then add; MnContours contour(...);; std::vector<std::pair<double, double> > points = contour(4, 5);; to see a two-dimensional picture.; 6.5 Interpretation of parameter errors; There are two kinds of problems that can arise: Th",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:73229,Safety,recover,recovers,73229,"nction to determine the current search direction, since this is the optimal strategy for quadratic functions and “physical” functions should be quadratic in the neighbourhood of the minimum at least. The search directions determined by \(\mbox{MIGRAD}\) are guaranteed to be downhill only if the covariance matrix is positive–definite, so in case this is not true, it makes a positive–definite approximation by adding an appropriate constant along the diagonal as determined by the eigenvalues of the matrix. Theoretically, the covariance matrix for a “physical” function must be positive–definite at the minimum, although it may not be so for all points far away from the minimum, even for a well–determined physical problem. Therefore, if \(\mbox{MIGRAD}\) reports that it has found a non-positive–definite covariance matrix, this may be a sign of one or more of the following:. A non–physical region. On its way to the minimum, \(\mbox{MIGRAD}\) may have traversed a region which has unphysical behaviour, which is of course not a serious problem as long as it recovers and leaves such a region.; An underdetermined problem. If the matrix is not positive–definite even at the minimum, this may mean that the solution is not well–defined, for example that there are more unknowns than there are data points, or that the parametrization of the fit contains a linear dependence. If this is the case, then M (or any other program) cannot solve your problem uniquely, and the error matrix will necessarily be largely meaningless, so the user must remove the under-determinedness by reformulating the parametrization. M cannot do this itself, but it can provide some hints (contours, global correlation coefficients, eigenvalues) which can help the clever user to find out what is wrong.; Numerical inaccuracies. It is possible that the apparent lack of positive–definiteness is in fact only due to excessive roundoff errors in numerical calculations, either in \(\mbox{FCN}\) or in M . This is unlikely ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:75175,Safety,detect,detects,75175,"ely in general, but becomes more likely if the number of free parameters is very large, or if the parameters are badly scaled (not all of the same order of magnitude), and correlations are also large. In any case, whether the non–positive–definiteness is real or only numerical is largely irrelevant, since in both cases the error matrix will be unreliable and the minimum suspicious. 6.7 Additional trouble–shooting; When M just doesn’t work, some of the more common causes are:. Precision mismatch. Make sure your \(\mbox{FCN}\) uses internally the same precision as M .; If the problem is only one of precision, and not of word length mismatch, an appropriate MnMachinePrecision::setPrecision() may fix it.; Trivial bugs in \(\mbox{FCN}\). The possibilities for bugs are numerous. Probably the most common among physicists inexperienced in is the confusion between double and int types, which you can sometimes get away with, but not always. 3 M can spot some trivial bugs itself, and issues a warning when it detects an unusual \(\mbox{FCN}\) behaviour. Such a warning should be taken seriously.; M also offers some tools (especially \(\mbox{SCAN}\)) which can help the user to find trivial bugs.; An ill–posed problem. For questions of parameter dependence, see the discussion above on postive–definiteness. Other mathematical problems which can arise are: excessive numerical roundoff — be especially careful of exponential and factorial functions which get big very quickly and lose accuracy; starting too far from the solution — the function may have unphysical local minima, especially at infinity in some variables; incorrect normalization — in likelihood functions, the probability distributions must be normalized or at least have an integral which is independent of the values of the variable parameters.; A bug in M . This is unlikely, but it happens. If a bug is suspected, and all other possible causes can be eliminated, please try to save a copy of the input and output files, listin",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:7337,Security,access,access,7337," related tools (the kernel of M ) should be clearly separated from the user, who is interfacing via defined user interfaces (the API).; 2.3 Internal and external parameters; Each of the parameters to the \(\mbox{FCN}\) is defined by the user as belonging to one of the following types:. Freely variable: allowed to take on any value.; Variable with double sided limits: allowed to vary only between two limits specified by the user.; Variable with single sided limits: allowed to vary only between one upper or one lower limit specified by the user and unlimited to the other side.; Fixed: originally defined as variable, but now taking on only the value the parameter had at the moment it was fixed, or a value later assigned by the user.; Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are free and unbound.; The user, in their \(\mbox{FCN}\), must of course be able to “see” all types of defined parameters, and they therefore have access to what we call the external parameter list, that is, the parameters as he defined them. On the other hand, the internal M minimizing routines only want to “see” variable parameters without limits, and so they have access only to the internal parameter list which is created from the external list by the following transformation:. Squeeze out all parameters that are not variable.; Transform all variable parameters with limits, so that the transformed parameter can vary without limits. (See the next section for details concerning this transformation.) Because this transformation is non-linear, it is recommended to avoid putting limits on parameters where they are not needed. As an example, suppose that the user has defined the following parameters:. Parameter 0, constant.; Parameter 1, freely variable.; Parameter 2, variable with limits.; Parameter 3, constant.; Parameter 4, freely variable. Then the internal parameter list would be as follows:. Internal parameter 0",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:7559,Security,access,access,7559," the user as belonging to one of the following types:. Freely variable: allowed to take on any value.; Variable with double sided limits: allowed to vary only between two limits specified by the user.; Variable with single sided limits: allowed to vary only between one upper or one lower limit specified by the user and unlimited to the other side.; Fixed: originally defined as variable, but now taking on only the value the parameter had at the moment it was fixed, or a value later assigned by the user.; Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are free and unbound.; The user, in their \(\mbox{FCN}\), must of course be able to “see” all types of defined parameters, and they therefore have access to what we call the external parameter list, that is, the parameters as he defined them. On the other hand, the internal M minimizing routines only want to “see” variable parameters without limits, and so they have access only to the internal parameter list which is created from the external list by the following transformation:. Squeeze out all parameters that are not variable.; Transform all variable parameters with limits, so that the transformed parameter can vary without limits. (See the next section for details concerning this transformation.) Because this transformation is non-linear, it is recommended to avoid putting limits on parameters where they are not needed. As an example, suppose that the user has defined the following parameters:. Parameter 0, constant.; Parameter 1, freely variable.; Parameter 2, variable with limits.; Parameter 3, constant.; Parameter 4, freely variable. Then the internal parameter list would be as follows:. Internal parameter 0 = external parameter 1.; Internal parameter 1 = external parameter 2, transformed appropriately.; Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters is 5, and the n",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:25332,Security,authoriz,authorization,25332," minimum internal state vector: LAVector parameters:. -1.82079e-05; -1.20794e-05; 6.22382e-06; -3.0465e-05. minimum internal covariance matrix: LASymMatrix parameters:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. # ext. || name || type || value || error +/-. 0 || x || free ||-1.821e-05 || 2; 1 || y || free ||-1.208e-05 || 2.236; 2 || z || free || 6.224e-06 || 2.449; 3 || w || free ||-3.047e-05 || 1. MnUserCovariance:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. MnUserCovariance parameter correlations:. 1 0.223607 0.408248 1.35011e-18; 0.223607 1 0.547723 8.39663e-18; 0.408248 0.547723 1 9.36796e-18; 1.35011e-18 8.39663e-18 9.36796e-18 1. MnGlobalCorrelationCoeff:. 0.408248; 0.547723; 0.621261; 0; 3.3 CVS code repository; How to check out (–in) code from the CVS code repository is described at the M homepage @bib-C++MINUIT. To get the source code from the CVS repository one needs to do:; Kerberos IV authorization:; $ setenv CVSROOT :kserver:SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs co MathLibs/Minuit; Anonymous read-only access (if it’s enabled by the librarian, see details):; $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login; (Logging in to :pserver:anonymous@seal.cvs.cern.ch:2401/cvs/SEAL) CVS password:cvs; $ cvs co MathLibs/Minuit; (If you want to check out a tagged version SEAL_x_x_x of MINUIT, then do; $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ); 3.4 Create a tar.gz from CVS; Once the sources are checked out from the CVS code repository,. change to the directory:; $ cd MathLibs/Minuit; run autogen:; $ ./autogen; create a new directory:; $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/; run configure:; $ ../Minuit/configure; create the tar.gz:; $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used as described above.; 3.5 M versions; The version numbers of M follow the release numbers of the SEAL project @bib-SE",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:25448,Security,access,access,25448,"arameters:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. # ext. || name || type || value || error +/-. 0 || x || free ||-1.821e-05 || 2; 1 || y || free ||-1.208e-05 || 2.236; 2 || z || free || 6.224e-06 || 2.449; 3 || w || free ||-3.047e-05 || 1. MnUserCovariance:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. MnUserCovariance parameter correlations:. 1 0.223607 0.408248 1.35011e-18; 0.223607 1 0.547723 8.39663e-18; 0.408248 0.547723 1 9.36796e-18; 1.35011e-18 8.39663e-18 9.36796e-18 1. MnGlobalCorrelationCoeff:. 0.408248; 0.547723; 0.621261; 0; 3.3 CVS code repository; How to check out (–in) code from the CVS code repository is described at the M homepage @bib-C++MINUIT. To get the source code from the CVS repository one needs to do:; Kerberos IV authorization:; $ setenv CVSROOT :kserver:SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs co MathLibs/Minuit; Anonymous read-only access (if it’s enabled by the librarian, see details):; $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login; (Logging in to :pserver:anonymous@seal.cvs.cern.ch:2401/cvs/SEAL) CVS password:cvs; $ cvs co MathLibs/Minuit; (If you want to check out a tagged version SEAL_x_x_x of MINUIT, then do; $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ); 3.4 Create a tar.gz from CVS; Once the sources are checked out from the CVS code repository,. change to the directory:; $ cd MathLibs/Minuit; run autogen:; $ ./autogen; create a new directory:; $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/; run configure:; $ ../Minuit/configure; create the tar.gz:; $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used as described above.; 3.5 M versions; The version numbers of M follow the release numbers of the SEAL project @bib-SEAL at CERN @bib-CERN.; 3.5.1 From to; The program is entirely written in standard portable . M does not depend on any external library. In its minimal usage ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:25652,Security,password,password,25652,"4e-06 || 2.449; 3 || w || free ||-3.047e-05 || 1. MnUserCovariance:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. MnUserCovariance parameter correlations:. 1 0.223607 0.408248 1.35011e-18; 0.223607 1 0.547723 8.39663e-18; 0.408248 0.547723 1 9.36796e-18; 1.35011e-18 8.39663e-18 9.36796e-18 1. MnGlobalCorrelationCoeff:. 0.408248; 0.547723; 0.621261; 0; 3.3 CVS code repository; How to check out (–in) code from the CVS code repository is described at the M homepage @bib-C++MINUIT. To get the source code from the CVS repository one needs to do:; Kerberos IV authorization:; $ setenv CVSROOT :kserver:SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs co MathLibs/Minuit; Anonymous read-only access (if it’s enabled by the librarian, see details):; $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login; (Logging in to :pserver:anonymous@seal.cvs.cern.ch:2401/cvs/SEAL) CVS password:cvs; $ cvs co MathLibs/Minuit; (If you want to check out a tagged version SEAL_x_x_x of MINUIT, then do; $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ); 3.4 Create a tar.gz from CVS; Once the sources are checked out from the CVS code repository,. change to the directory:; $ cd MathLibs/Minuit; run autogen:; $ ./autogen; create a new directory:; $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/; run configure:; $ ../Minuit/configure; create the tar.gz:; $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used as described above.; 3.5 M versions; The version numbers of M follow the release numbers of the SEAL project @bib-SEAL at CERN @bib-CERN.; 3.5.1 From to; The program is entirely written in standard portable . M does not depend on any external library. In its minimal usage the user must only provide an implementation of the FCNBase class to M and parameters and uncertainties in form of std::vector containers.; 3.5.2 Memory allocation and thread safety; Differently to the version of M , the version has its own memory ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:37314,Security,access,accessed,37314," a MnMigrad object maintains its own state and one can have multiple instances of MnMigrad objects.; 4.4.4 M fails to find a minimum; If M fails to find a minimum, the user is notified by a warning message issued by M when running into troubles. Problems can be:. a bug in M; an error in the \(\mbox{FCN}\); a highly difficult problem (usually strong correlations among parameters); floating–point precision. 4.5 The output from minimization; 4.5.1 The FunctionMinimum; The output of the minimizers is the FunctionMinimum. The FunctionMinimum contains the result of the minimization in both internal parameter representation and external parameter representation.; 4.5.2 User representable format: MnUserParameterState; On request, the result of the minimization is transformed into a user representable format for parameters and errors, the MnUserParameterState.; 4.5.3 Access values, errors, covariance; The result can be accessed via methods like MnUserParameterState::value(unsigned int n) and MnUserParameterState::error(unsigned int n), where \(n\) is the index of the parameter in the list of parameters defined by the user.; 4.5.4 Printout of the result; The FunctionMinimum can be printed on the output simply via std::cout. It will print both the internal and external state, that is parameters, errors and the covariance matrix (if available). It also tells the user if M did converge or not by issuing an appropriate message. If a covariance matrix is available, the global correlation coefficients are printed as well.; 4.5.5 Global correlation coefficients; The global correlation coefficient for parameter \(n\) is a number between zero and one which gives the correlation between parameter \(n\) and that linear combination of all other parameters which is most strongly correlated with \(n\).; 5 M application programming interface (API); [api:api]; 5.1 FunctionMinimum; [api:fm] The FunctionMinimum is the output of the minimizers and contains the minimization result. The state at ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:54138,Security,access,accessed,54138," prior to the minimization. The size of the covariance matrix is according to the number of variable parameters (free and limited).; 5.13.1 MnUserCovariance(const std::vector\(<\)double\(>\)&, unsigned int nrow); Construct from data, positions of the elements in the array are arranged according to the packed storage format. The size of the array must be \(nrow*(nrow+1)/2\). The array must contain the upper triangular part of the symmetric matrix packed sequentially, column by column, so that arr(0) contains covar(0,0), arr(1) and arr(2) contain covar(0,1) and covar(1,1) respectively, and so on. The number of rows (columns) has to be specified.; 5.13.2 MnUserCovariance(unsigned int nrow); Specify the number of rows (columns) at instantiation. It will allocate an array of the length \(nrow*(nrow+1)/2\) and initialize it to \(0\). Elements can then be set using the method operator()(unsigned int, unsigned int).; 5.13.3 MnUserCovariance::operator()(unsigned int, unsigned int); Individual elements can be accessed via the operator(), both for reading and writing.; 5.14 MnUserParameters; [api:parameters] MnUserParameters is the main class for user interaction with the parameters. It serves both as input to the minimization as well as output as the result of the minimization is converted into the user representable format in order to allow for further interaction. Parameters for M can be added (defined) specifying a name, value and initial uncertainty.; 5.14.1 add(…); The method MnUserParameters::add(…) is overloaded for three kind of parameters:. add(const char*, double, double) for adding a free variable parameter; add(const char*, double, double, double, double) for adding a variable parameter with limits (lower and upper); add(const char*, double) for adding a constant parameter. When adding parameters, M assigns indices to each parameter which will be the same as in the std::vector\(<\)double\(>\) in the FCNBase::operator(). That means the first parameter the user adds ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:80985,Security,access,access,80985,"ng values for initial uncertainties; std::vector<double> init_err;; init_err.push_back(0.1);; init_err.push_back(0.1);; init_err.push_back(0.1);. // create minimizer (default constructor); VariableMetricMinimizer theMinimizer;. // minimize; FunctionMinimum min =; theMinimizer.minimize(theFCN, init_par, init_err);. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate standard minimization using MIGRAD; // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create MIGRAD minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate full interaction with parameters over subsequent; // minimizations. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // access parameter by name to set limits...; upar.setLimits(""mean"", mean-0.01, mean+0.01);. // ... or access parameter by index; upar.setLimits(1, rms-0.1, rms+0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // fix a parameter...; migrad.fix(""mean"");. // ... and minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;. // release a parameter...; migrad.release(""mean"");. // ... and fix another one; migrad.fix(1);. // and minimize again; FunctionMinimum min1 = migrad();. // output; std::cout<<""minimum1: ""<<min1<<std::endl;. // release the parameter...; migrad.release(1);. // ... and minimize with all three parameters; // (still with limits!); FunctionMinimum min2 = migrad();. // output; std::cout<<""minimum2: ""<<min2<<std::endl;. // remove all limits on parameters...; migrad.removeLimits(""mean"");; migrad.removeLimits(""sigma"");. // ... and minimize again with all three parameters; // (now without limits!); FunctionMinimum min3 = migrad();. // output; std",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:81085,Security,access,access,81085,"t_err.push_back(0.1);; init_err.push_back(0.1);. // create minimizer (default constructor); VariableMetricMinimizer theMinimizer;. // minimize; FunctionMinimum min =; theMinimizer.minimize(theFCN, init_par, init_err);. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate standard minimization using MIGRAD; // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create MIGRAD minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate full interaction with parameters over subsequent; // minimizations. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // access parameter by name to set limits...; upar.setLimits(""mean"", mean-0.01, mean+0.01);. // ... or access parameter by index; upar.setLimits(1, rms-0.1, rms+0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // fix a parameter...; migrad.fix(""mean"");. // ... and minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;. // release a parameter...; migrad.release(""mean"");. // ... and fix another one; migrad.fix(1);. // and minimize again; FunctionMinimum min1 = migrad();. // output; std::cout<<""minimum1: ""<<min1<<std::endl;. // release the parameter...; migrad.release(1);. // ... and minimize with all three parameters; // (still with limits!); FunctionMinimum min2 = migrad();. // output; std::cout<<""minimum2: ""<<min2<<std::endl;. // remove all limits on parameters...; migrad.removeLimits(""mean"");; migrad.removeLimits(""sigma"");. // ... and minimize again with all three parameters; // (now without limits!); FunctionMinimum min3 = migrad();. // output; std::cout<<""minimum3: ""<<min3<<std::endl;; }. {; // demonstrate MINOS error analysis. // create Min",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:1824,Testability,log,log-likelihood,1824,"Minimizer; 5.7 MnMinimize and CombinedMinimizer; 5.8 MnMinos; 5.9 MnPlot; 5.10 MnScan and ScanMinimizer; 5.11 MnSimplex and SimplexMinimizer; 5.12 MnStrategy; 5.13 MnUserCovariance; 5.14 MnUserParameters; 5.15 MnUserParameterState; 5.16 MnPrint.h. 6 How to get the right answer from M; 6.1 Which minimizer to use; 6.2 Floating point precision; 6.3 Parameter limits; 6.4 Fixing and releasing parameters; 6.5 Interpretation of parameter errors; 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; 6.7 Additional trouble–shooting. 7 A complete example; 7.1 The user’s \(\mbox{FCN}\); 7.2 The user’s main program. Minuit 2; *** Fred JAMES and Matthias WINKLER CERN, Geneva ***; 1 Foreword; 1.1 What M is intended to do; M is conceived as a tool to find the minimum value of a multi-parameter function (the “\(\mbox{FCN}\)”) and analyze the shape of the function around the minimum. The principal application is foreseen for statistical analysis, working on chisquare or log-likelihood functions, to compute the best-fit parameter values and uncertainties, including correlations between the parameters. It is especially suited to handle difficult problems, including those which may require guidance in order to find the correct solution.; 1.2 What M is not intended to do; Although M will of course solve easy problems faster than complicated ones, it is not intended for the repeated solution of identically parametrized problems (such as track fitting in a detector) where a specialized program will in general be much more efficient.; 1.3 Further remarks; M was initially written in Fortran around 1975-1980 at CERN by Fred James @bib-MINUIT. Its main field of usage is statistical data analysis of experimental data recorded at CERN, but it is also used by people doing data analysis outside CERN or outside high energy physics (HEP). In 2002 Fred James started a project aiming to re-implement M in an object-oriented way using .; More information about recent developments, releases an",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:3415,Testability,log,log,3415,"tially written in Fortran around 1975-1980 at CERN by Fred James @bib-MINUIT. Its main field of usage is statistical data analysis of experimental data recorded at CERN, but it is also used by people doing data analysis outside CERN or outside high energy physics (HEP). In 2002 Fred James started a project aiming to re-implement M in an object-oriented way using .; More information about recent developments, releases and installation can be obtained from the M homepage @bib-C++MINUIT.; The names of M applications are written in capital letters (e.g. \(\mbox{MIGRAD}\), \(\mbox{MINOS}\), \(\mbox{CONTOURS}\)), the corresponding names of the classes are written using sans-serif font type (MnMigrad, MnMinos, MnContours).; 2 Introduction: M basic concepts; [sec:intro]; 2.1 The organization of M; The M package acts on a multiparameter objective function which is called — for historical reasons — the \(\mbox{FCN}\) function (see [howto:fcn]). This function is usually a chisquared or a log–likelihood, but it could also be a mathematical function. The \(\mbox{FCN}\) function needs to be written in for which M defines the pure abstract base class FCNBase as interface. The user must define and implement the \(\mbox{FCN}\) function in a derived class from FCNBase. Sometimes this is done by an intermediate program such as HippoDraw@bib-HippoDraw, in which case M is being used under the control of such an intermediate program1. The value of the \(\mbox{FCN}\) function will in general depend on one or more variable parameters whose meaning is defined by the user (or by the intermediate program), but whose trial values are determined by M .; To take a simple example, suppose the problem is to fit a polynomial through a set of data points. Then the user would write a \(\mbox{FCN}\) which calculates the \(\chi^2\) between a polynomial and the data; the variable parameters of \(\mbox{FCN}\) would be the coefficients of the polynomials. Using objects for minimization from M , the user wo",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:15471,Testability,log,log-likelihood,15471,"verall (multiplicative) normalization of \(\mbox{FCN}\), in the sense that if the value of \(\mbox{FCN}\) is everywhere multiplied by a constant \(\beta\), then the errors will be decreased by a factor \(\sqrt{\beta}\). Additive constants do not change the parameter errors, but may imply a different goodness-of-fit confidence level.; Assuming that the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they are interested in parameter errors, the user can change the error definition which allows them to define what they means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one “error”. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-deviation errors, then the error definition (return value of the FCNBase::up() method, see [howto:errordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FCNBase::up() to return is \(0.5\). If the \(\mbox{FCN}\) is a chisquare, but the user wants two-standard-deviation errors, then FCNBase::up() should return \(= 4.0\), etc.; Note that in the usual case where M is being used to perform a fit to some experimental data, the parameter errors will be proportional to the uncertainty in the data, and therefore meaningful parameter errors cannot be obtained unless the measurement errors of the data are known. In the common case of a least-squares fit, \(\mbox{FCN}\) is usually defined as a chisquare:; \[\chi^2 (\alpha) = \sum_{i=1}^{n} (\frac{f(x_i,\alpha) - m_i)^2}{\sigma_i^2}\]; where \(\alpha\) is the vector of free parameters being fitted, and the \(\sigma_i\) are the uncertainties in the individual measurements \(m_i\). If these uncertainties are not known, and are simply left out of the calculation, then the fit may still have meaning, but not the quantitative values of the resulting parameter errors. ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:24129,Testability,test,tests,24129,"ication and not literally (with minor exceptions). Applications such as \(\mbox{MIGRAD}\) have a corresponding class MnMigrad, M “commands” became classes or methods of classes according to their purpose. Users familiar with the version of M , who have not yet used releases from the version, should however read this manual, in order to adapt to the changes as well as to discover the new features and easier ways of using old features.; 3.2 Install M using autoconf/make; For each release of M a tar.gz file is provided for downloading from the M homepage @bib-C++MINUIT. For non-UNIX platforms please refer to the M homepage.; The necessary steps to follow are:. download the tar.gz by clicking on it from the release page; unzip it:; $ unzip Minuit-x.x.x.tar.gz; untar it:; $ tar xvf Minuit-x.x.x.tar; step down to the created Minuit-x.x.x directory:; $ cd Minuit-x.x.x/; run the “configure” script:; $ ./configure; run “make” to compile the source code:; $ make; run “make check” to create the executable example:; $ make check; run the executable example:; $ tests/MnTutorial/Quad4FMain.C. The output should look like that:; Minuit did successfully converge. # of function calls: 74; minimum function value: 1.12392e-09; minimum edm: 1.12392e-09; minimum internal state vector: LAVector parameters:. -1.82079e-05; -1.20794e-05; 6.22382e-06; -3.0465e-05. minimum internal covariance matrix: LASymMatrix parameters:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. # ext. || name || type || value || error +/-. 0 || x || free ||-1.821e-05 || 2; 1 || y || free ||-1.208e-05 || 2.236; 2 || z || free || 6.224e-06 || 2.449; 3 || w || free ||-3.047e-05 || 1. MnUserCovariance:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. MnUserCovariance parameter correlations:. 1 0.223607 0.408248 1.35011e-18; 0.223607 1 0.547723 8.39663e-18; 0.408248 0.547723 1 9.36796e-18; 1.35011e-18 8.39663e-18 9.36796e-18 1.",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:25575,Testability,log,login,25575,"e || type || value || error +/-. 0 || x || free ||-1.821e-05 || 2; 1 || y || free ||-1.208e-05 || 2.236; 2 || z || free || 6.224e-06 || 2.449; 3 || w || free ||-3.047e-05 || 1. MnUserCovariance:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. MnUserCovariance parameter correlations:. 1 0.223607 0.408248 1.35011e-18; 0.223607 1 0.547723 8.39663e-18; 0.408248 0.547723 1 9.36796e-18; 1.35011e-18 8.39663e-18 9.36796e-18 1. MnGlobalCorrelationCoeff:. 0.408248; 0.547723; 0.621261; 0; 3.3 CVS code repository; How to check out (–in) code from the CVS code repository is described at the M homepage @bib-C++MINUIT. To get the source code from the CVS repository one needs to do:; Kerberos IV authorization:; $ setenv CVSROOT :kserver:SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs co MathLibs/Minuit; Anonymous read-only access (if it’s enabled by the librarian, see details):; $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login; (Logging in to :pserver:anonymous@seal.cvs.cern.ch:2401/cvs/SEAL) CVS password:cvs; $ cvs co MathLibs/Minuit; (If you want to check out a tagged version SEAL_x_x_x of MINUIT, then do; $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ); 3.4 Create a tar.gz from CVS; Once the sources are checked out from the CVS code repository,. change to the directory:; $ cd MathLibs/Minuit; run autogen:; $ ./autogen; create a new directory:; $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/; run configure:; $ ../Minuit/configure; create the tar.gz:; $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used as described above.; 3.5 M versions; The version numbers of M follow the release numbers of the SEAL project @bib-SEAL at CERN @bib-CERN.; 3.5.1 From to; The program is entirely written in standard portable . M does not depend on any external library. In its minimal usage the user must only provide an implementation of the FCNBase class to M and parameters and uncertainties in form of std::v",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:30979,Testability,log,log,30979,"f the vector of parameters std::vector\(<\)double\(>\) in the argument of FCNBase::operator() are of course defined by the user, who uses the values of those parameters to calculate their function value. The order and the position of these parameters is strictly the one specified by the user when supplying the starting values for minimization.; The starting values must be specified by the user, either via an std::vector\(<\)double\(>\) or the MnUserParameters (see [api:parameters]) supplied as input to the M minimizers such as VariableMetricMinimizer or MnMigrad (see [api:migrad]). Later values are determined by M as it searches for the minimum or performs whatever analysis is requested by the user.; 4.1.2 FCNBase::up(); [howto:errordef] Returns the value of \(\mbox{up}\) (default value \(= 1.\)), defining parameter errors. M defines parameter errors as the change in parameter value required to change the function value by \(\mbox{up}\). Normally, for chisquared fits \(\mbox{up = 1}\), and for negative log likelihood, \(\mbox{up = 0.5}\).; 4.1.3 \(\mbox{FCN}\) function with gradient; By default first derivatives are calculated numerically by M . In case the user wants to supply their own gradient calculator (e.g. analytical derivatives), they need to implement the FCNGradientBase interface. The size of the output vector is the same as of the input one. The same is true for the position of the elements (first derivative of the function with respect to the \(n_\mathrm{th}\) variable has index \(n\) in the output vector).; 4.2 M parameters; Interaction with the parameters of the function are essential both for M and the user. Different interfaces are provided, depending on the level of interaction.; 4.2.1 Minimal required interface; Starting values of parameters and uncertainties can be provided to M by the user via std::vector\(<\)double\(>\) vector containers. Any interaction with the parameters before minimization (fix, release, limits, etc.) is not possible then.; ",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:78381,Testability,assert,assert,78381,"lic FCNBase {. public:. GaussFcn(const std::vector<double>& meas,; const std::vector<double>& pos,; const std::vector<double>& mvar) : theMeasurements(meas),; thePositions(pos),; theMVariances(mvar),; theErrorDef(1.) {}. ~GaussFcn() {}. virtual double up() const {return theErrorDef;}; virtual double operator()(const std::vector<double>&) const;. std::vector<double> measurements() const {return theMeasurements;}; std::vector<double> positions() const {return thePositions;}; std::vector<double> variances() const {return theMVariances;}. void setErrorDef(double def) {theErrorDef = def;}. private:. std::vector<double> theMeasurements;; std::vector<double> thePositions;; std::vector<double> theMVariances;; double theErrorDef;; };. #endif //MN_GaussFcn_H_; 7.1.3 GaussFcn.cpp; The actual implementation of the FCNBase::operator() (called by Minuit):; #include ""GaussFcn.h""; #include ""GaussFunction.h"". #include <cassert>. double GaussFcn::operator()(const std::vector<double>& par) const {. assert(par.size() == 3);; GaussFunction gauss(par[0], par[1], par[2]);. double chi2 = 0.;; for(unsigned int n = 0; n < theMeasurements.size(); n++) {; chi2 += ((gauss(thePositions[n]) - theMeasurements[n]) *; (gauss(thePositions[n]) - theMeasurements[n]) /; theMVariances[n]);; }. return chi2;; }; 7.2 The user’s main program; [example:main]; This is the main program DemoGaussSim.cpp:; #include ""GaussFcn.h""; #include ""GaussDataGen.h""; #include ""Minuit/FunctionMinimum.h""; #include ""Minuit/MnUserParameterState.h""; #include ""Minuit/MinimumPrint.h""; #include ""Minuit/MnMigrad.h""; #include ""Minuit/MnMinos.h""; #include ""Minuit/MnContours.h""; #include ""Minuit/MnPlot.h"". #include <iostream>. int main() {. // generate the data (100 data points); GaussDataGen gdg(100);. std::vector<double> pos = gdg.positions();; std::vector<double> meas = gdg.measurements();; std::vector<double> var = gdg.variances();. // create FCN function; GaussFcn theFCN(meas, pos, var);. // create initial starting values for param",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:2045,Usability,guid,guidance,2045,"e; 5.14 MnUserParameters; 5.15 MnUserParameterState; 5.16 MnPrint.h. 6 How to get the right answer from M; 6.1 Which minimizer to use; 6.2 Floating point precision; 6.3 Parameter limits; 6.4 Fixing and releasing parameters; 6.5 Interpretation of parameter errors; 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; 6.7 Additional trouble–shooting. 7 A complete example; 7.1 The user’s \(\mbox{FCN}\); 7.2 The user’s main program. Minuit 2; *** Fred JAMES and Matthias WINKLER CERN, Geneva ***; 1 Foreword; 1.1 What M is intended to do; M is conceived as a tool to find the minimum value of a multi-parameter function (the “\(\mbox{FCN}\)”) and analyze the shape of the function around the minimum. The principal application is foreseen for statistical analysis, working on chisquare or log-likelihood functions, to compute the best-fit parameter values and uncertainties, including correlations between the parameters. It is especially suited to handle difficult problems, including those which may require guidance in order to find the correct solution.; 1.2 What M is not intended to do; Although M will of course solve easy problems faster than complicated ones, it is not intended for the repeated solution of identically parametrized problems (such as track fitting in a detector) where a specialized program will in general be much more efficient.; 1.3 Further remarks; M was initially written in Fortran around 1975-1980 at CERN by Fred James @bib-MINUIT. Its main field of usage is statistical data analysis of experimental data recorded at CERN, but it is also used by people doing data analysis outside CERN or outside high energy physics (HEP). In 2002 Fred James started a project aiming to re-implement M in an object-oriented way using .; More information about recent developments, releases and installation can be obtained from the M homepage @bib-C++MINUIT.; The names of M applications are written in capital letters (e.g. \(\mbox{MIGRAD}\), \(\mbox{MINOS}\), \(\mbox{",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:4086,Usability,simpl,simple,4086,"d, MnMinos, MnContours).; 2 Introduction: M basic concepts; [sec:intro]; 2.1 The organization of M; The M package acts on a multiparameter objective function which is called — for historical reasons — the \(\mbox{FCN}\) function (see [howto:fcn]). This function is usually a chisquared or a log–likelihood, but it could also be a mathematical function. The \(\mbox{FCN}\) function needs to be written in for which M defines the pure abstract base class FCNBase as interface. The user must define and implement the \(\mbox{FCN}\) function in a derived class from FCNBase. Sometimes this is done by an intermediate program such as HippoDraw@bib-HippoDraw, in which case M is being used under the control of such an intermediate program1. The value of the \(\mbox{FCN}\) function will in general depend on one or more variable parameters whose meaning is defined by the user (or by the intermediate program), but whose trial values are determined by M .; To take a simple example, suppose the problem is to fit a polynomial through a set of data points. Then the user would write a \(\mbox{FCN}\) which calculates the \(\chi^2\) between a polynomial and the data; the variable parameters of \(\mbox{FCN}\) would be the coefficients of the polynomials. Using objects for minimization from M , the user would request M to minimize the \(\mbox{FCN}\) with respect to the parameters, that is, find those values of the coefficients which give the lowest value of chisquare.; The user must therefore supply, in addition to the function to be analyzed, via a set or sequence of M applications the instructions which analysis is wanted. The instructions are coded in in the calling program (main.cpp), which allows looping, conditional execution, and all the other possibilities of , but not interactivity, since it must be compiled before execution.; 2.2 Design aspects of M in; What M is:. platform independent; written in an object-oriented way using standard; independent of any external package. The mainta",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:6365,Usability,clear,clearly,6365,"w functionality).; What M does not:. histogramming; data handling; graphics. M is kept as a low-level package with optimal performance.; The main usages of M are. from a user’s program (such as int main()…); from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. its numerical accuracy (equivalent to its Fortran version); its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a two-way strategy was imposed:. a minimal required interface with minimum interaction with M objects and with appropriate usage of the standard library (STL): the user’s implementation of the FCNBase class, initial parameter values and uncertainties are provided by the to M user via std::vectors.; a rich interface which provides the user with more functionality such as interaction with parameters. The core of the minimization functionality and related tools (the kernel of M ) should be clearly separated from the user, who is interfacing via defined user interfaces (the API).; 2.3 Internal and external parameters; Each of the parameters to the \(\mbox{FCN}\) is defined by the user as belonging to one of the following types:. Freely variable: allowed to take on any value.; Variable with double sided limits: allowed to vary only between two limits specified by the user.; Variable with single sided limits: allowed to vary only between one upper or one lower limit specified by the user and unlimited to the other side.; Fixed: originally defined as variable, but now taking on only the value the parameter had at the moment it was fixed, or a value later assigned by the user.; Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are free and unbound.; The user, in their \(\mbox{FCN}\), must of course be able to “see” all types of defined parameters, and they therefore have access to what we call the e",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:16362,Usability,simpl,simply,16362,"ordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FCNBase::up() to return is \(0.5\). If the \(\mbox{FCN}\) is a chisquare, but the user wants two-standard-deviation errors, then FCNBase::up() should return \(= 4.0\), etc.; Note that in the usual case where M is being used to perform a fit to some experimental data, the parameter errors will be proportional to the uncertainty in the data, and therefore meaningful parameter errors cannot be obtained unless the measurement errors of the data are known. In the common case of a least-squares fit, \(\mbox{FCN}\) is usually defined as a chisquare:; \[\chi^2 (\alpha) = \sum_{i=1}^{n} (\frac{f(x_i,\alpha) - m_i)^2}{\sigma_i^2}\]; where \(\alpha\) is the vector of free parameters being fitted, and the \(\sigma_i\) are the uncertainties in the individual measurements \(m_i\). If these uncertainties are not known, and are simply left out of the calculation, then the fit may still have meaning, but not the quantitative values of the resulting parameter errors. (Only the relative errors of different parameters with respect to each other may be meaningful.); If the \(\sigma_i\) are all overestimated by a factor \(\beta\), then the resulting parameter errors from the fit will be overestimated by the same factor \(\beta\).; 2.5.2 The error matrix; The M processors \(\mbox{MIGRAD}\) (MnMigrad, see [api:migrad]) and HESSE (MnHesse, see [api:hesse]) (normally) produce an error matrix. This matrix is twice the inverse of the matrix of second derivatives of the \(\mbox{FCN}\), transformed if necessary into external coordinate space2, and multiplied by FCNBase::up(). Therefore, errors based on the M error matrix take account of all the parameter correlations, but not the non-linearities. That is, from the error matrix alone, two-standard-deviation errors are always exactly twice as big as one-standard-deviation errors.; When the error matrix has been calculat",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:33802,Usability,simpl,simply,33802,"The result of the minimization is transformed into the user representable format by M . For more explanations see [api:state].; 4.3 Input to M; The following input combinations to M are possible:. \(\mbox{FCN}\) + parameters + uncertainties; \(\mbox{FCN}\) with gradient + parameters + uncertainties; \(\mbox{FCN}\) + parameters + covariance; \(\mbox{FCN}\) with gradient + parameters + covariance. For each of these combinations the user can chose between a minimal required interface (using std::vector containers) for the parameters and uncertainties or a more functional one provided by M . If the user wants to interact with the parameters before minimization (fixing, adding/removing limits), the minimal required interface cannot be used.; 4.3.1 What the user must supply; The user must supply to M. a valid implementation of the FCNBase base class; parameters with their starting values; expected uncertainties on the parameters. The input parameters can be simply defined via an std::vector\(<\)double\(>\), which means that all parameters are variables. If the user wants fix a parameter or put limits on it before minimization, they have to instantiate a MnUserParameters object and then add parameters one by one, giving them a name, value, uncertainty. Once all parameters are added to MnUserParameters, they can fix a parameter or put limits on another one before handing them over to Minuit for minimization.; 4.3.2 What the user can supply; Optionally the user can supply their own gradient calculator by implementing the FCNGradientBase interface or supply a full covariance matrix for input if one is available. The covariance matrix can be supplied in form of a std::vector\(<\)double\(>\) in packed storage format (upper triangular), or in a more user-friendly way by using the interface provided by the MnUserCovariance.; 4.4 Running a M minimization; Two use cases are addressed for minimization:. The user just wants the function to be minimized in one go.; The user wants to m",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:34603,Usability,user-friendly,user-friendly,34603,"t be used.; 4.3.1 What the user must supply; The user must supply to M. a valid implementation of the FCNBase base class; parameters with their starting values; expected uncertainties on the parameters. The input parameters can be simply defined via an std::vector\(<\)double\(>\), which means that all parameters are variables. If the user wants fix a parameter or put limits on it before minimization, they have to instantiate a MnUserParameters object and then add parameters one by one, giving them a name, value, uncertainty. Once all parameters are added to MnUserParameters, they can fix a parameter or put limits on another one before handing them over to Minuit for minimization.; 4.3.2 What the user can supply; Optionally the user can supply their own gradient calculator by implementing the FCNGradientBase interface or supply a full covariance matrix for input if one is available. The covariance matrix can be supplied in form of a std::vector\(<\)double\(>\) in packed storage format (upper triangular), or in a more user-friendly way by using the interface provided by the MnUserCovariance.; 4.4 Running a M minimization; Two use cases are addressed for minimization:. The user just wants the function to be minimized in one go.; The user wants to minimize the \(\mbox{FCN}\) in several minimization steps, re-using the result of the preceeding minimization in the next step and change parameters in between (fix/release/put limits on them, etc.). How M minimizations can be performed is shown in [example:main].; 4.4.1 Direct usage of minimizers; Minimizers such as the VariableMetricMinimizer are designed as state-less minimization engines, which means that they do not depend on the current function and its parameters. Any \(\mbox{FCN}\) function can be minimized with the same minimizer. The interface is restricted to minimization and no parameter interaction is possible.; 4.4.2 Using an application (MnMigrad); MnMigrad uses the VariableMetricMinimizer for minimization but a",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:37602,Usability,simpl,simply,37602,"by a warning message issued by M when running into troubles. Problems can be:. a bug in M; an error in the \(\mbox{FCN}\); a highly difficult problem (usually strong correlations among parameters); floating–point precision. 4.5 The output from minimization; 4.5.1 The FunctionMinimum; The output of the minimizers is the FunctionMinimum. The FunctionMinimum contains the result of the minimization in both internal parameter representation and external parameter representation.; 4.5.2 User representable format: MnUserParameterState; On request, the result of the minimization is transformed into a user representable format for parameters and errors, the MnUserParameterState.; 4.5.3 Access values, errors, covariance; The result can be accessed via methods like MnUserParameterState::value(unsigned int n) and MnUserParameterState::error(unsigned int n), where \(n\) is the index of the parameter in the list of parameters defined by the user.; 4.5.4 Printout of the result; The FunctionMinimum can be printed on the output simply via std::cout. It will print both the internal and external state, that is parameters, errors and the covariance matrix (if available). It also tells the user if M did converge or not by issuing an appropriate message. If a covariance matrix is available, the global correlation coefficients are printed as well.; 4.5.5 Global correlation coefficients; The global correlation coefficient for parameter \(n\) is a number between zero and one which gives the correlation between parameter \(n\) and that linear combination of all other parameters which is most strongly correlated with \(n\).; 5 M application programming interface (API); [api:api]; 5.1 FunctionMinimum; [api:fm] The FunctionMinimum is the output of the minimizers and contains the minimization result. The state at the minimum is available both in internal and external representations. For the external representations the return methods. FunctionMinimum::userState(),; FunctionMinimum::userParamete",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:49557,Usability,simpl,simplex,49557,"gh); Scans the value of the user function by varying parameter number \(\mbox{par}\), leaving all other parameters fixed at the current value. If \(\mbox{par}\) is not specified, all variable parameters are scanned in sequence. The number of points \(\mbox{npoints}\) in the scan is 40 by default, and cannot exceed 100. The range of the scan is by default 2 standard deviations on each side of the current best value, but can be specified as from \(\mbox{low}\) to \(\mbox{high}\). After each scan, if a new minimum is found, the best parameter values are retained as start values for future scans or minimizations. The curve resulting from each scan can be plotted on the output terminal using MnPlot [api:plot] in order to show the approximate behaviour of the function.; 5.10.2 ScanMinimizer; Although the \(\mbox{SCAN}\) method is not intended for minimization it can be used as a minimizer in its most primitive form.; 5.11 MnSimplex and SimplexMinimizer; [api:simplex]; \(\mbox{SIMPLEX}\) is a function minimization method using the simplex method of Nelder and Mead. MnSimplex provides minimization of the function by the method of \(\mbox{SIMPLEX}\) and the functionality for parameters interaction. It also retains the result from the last minimization in case the user may want to do subsequent minimization steps with parameter interactions in between the minimization requests. The minimization is done by the SimplexMinimizer. Minimization of the function can be done by directly using the SimplexMinimizer if no parameters interaction is required. As \(\mbox{SIMPLEX}\) is a stepping method it does not produce a covariance matrix.; 5.11.1 MnSimplex(const FCNBase&, const std::vector\(<\)double\(>\)&,. const std::vector\(<\)double\(>\)&, unsigned int) ###; Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.11.2 MnSimplex(const FCNBase&, const MnUserParam",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:49630,Usability,simpl,simplex,49630,"gh); Scans the value of the user function by varying parameter number \(\mbox{par}\), leaving all other parameters fixed at the current value. If \(\mbox{par}\) is not specified, all variable parameters are scanned in sequence. The number of points \(\mbox{npoints}\) in the scan is 40 by default, and cannot exceed 100. The range of the scan is by default 2 standard deviations on each side of the current best value, but can be specified as from \(\mbox{low}\) to \(\mbox{high}\). After each scan, if a new minimum is found, the best parameter values are retained as start values for future scans or minimizations. The curve resulting from each scan can be plotted on the output terminal using MnPlot [api:plot] in order to show the approximate behaviour of the function.; 5.10.2 ScanMinimizer; Although the \(\mbox{SCAN}\) method is not intended for minimization it can be used as a minimizer in its most primitive form.; 5.11 MnSimplex and SimplexMinimizer; [api:simplex]; \(\mbox{SIMPLEX}\) is a function minimization method using the simplex method of Nelder and Mead. MnSimplex provides minimization of the function by the method of \(\mbox{SIMPLEX}\) and the functionality for parameters interaction. It also retains the result from the last minimization in case the user may want to do subsequent minimization steps with parameter interactions in between the minimization requests. The minimization is done by the SimplexMinimizer. Minimization of the function can be done by directly using the SimplexMinimizer if no parameters interaction is required. As \(\mbox{SIMPLEX}\) is a stepping method it does not produce a covariance matrix.; 5.11.1 MnSimplex(const FCNBase&, const std::vector\(<\)double\(>\)&,. const std::vector\(<\)double\(>\)&, unsigned int) ###; Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.11.2 MnSimplex(const FCNBase&, const MnUserParam",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:67636,Usability,guid,guided,67636,"ameter errors it reports should be accurate and very close to those you would have got without limits. In other cases (which should be more common, since otherwise you wouldn’t need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless. On the other hand, the \(\mbox{MINOS}\) analysis is still meaningful, at least in principle, as long as \(\mbox{MIGRAD}\) (which is called internally by \(\mbox{MINOS}\)) does not get blocked at a limit. Unfortunately, the user has no control over this aspect of the \(\mbox{MINOS}\) calculation, although it is possible to get enough printout from the \(\mbox{MINOS}\) result to be able to determine whether the results are reliable or not.; 6.4 Fixing and releasing parameters; When M needs to be guided to the “right” minimum, often the best way to do this is with the methods e.g. MnMigrad::fix(…) and MnMigrad::release(…). That is, suppose you have a problem with ten free parameters, and when you minimize with respect to all at once, M goes to an unphysical solution characterized by an unphysical or unwanted value of parameter number four. One way to avoid this is to fix parameter four at a “good” value (not necessarily the best, since you presumably don’t know that yet), and minimize with respect to the others. Then release parameter four and minimize again. If the problem admits a “good” physical solution, you will normally find it this way. If it doesn’t work, you may see what is wrong by the following sequence (where \(\mbox{xxx}\) is the expected physical value for parameter four):; MnMigrad migrad(...);; migrad.setValue(4, xxx);; migrad.fix(4);; FunctionMinimum min = migrad();; migrad.release(4);; MnScan scan(...);; std::vector<std::pair<double, double> > points = scan(4);; where \(\mbo",MatchSource.WIKI,root/htmldoc/guides/minuit2/Minuit2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:1023,Availability,error,error,1023,"ing and Visualization Functions; Miroslav Morháč. Processing and Visualization Functions; 1 BACKGROUND ELIMINATION; 1.1 1-DIMENSIONAL SPECTRA; 1.2 2-DIMENSIONAL SPECTRA. 2 SMOOTHING; 2.1 1-DIMENSIONAL SPECTRA; 2.2 2-DIMENSIONAL SPECTRA. 3 PEAK SEARCHING; 3.1 1-DIMENSIONAL SPECTRA; 3.2 2-DIMENSIONAL SPECTRA. 4 DECONVOLUTION - UNFOLDING; 4.1 1-DIMENSIONAL SPECTRA; 4.2 Gold deconvolution algorithm; 4.3 2-DIMENSIONAL SPECTRA. 5 FITTING; 5.1 1-DIMENSIONAL SPECTRA; 5.2 2-DIMENSIONAL SPECTRA. 6 TRANSFORMS; 6.1 1-DIMENSIONAL SPECTRA; 6.2 2-DIMENSIONAL SPECTRA. 7 VISUALIZATION; 7.1 1-DIMENSIONAL SPECTRA; 7.2 2-DIMENSIONAL SPECTRA. 8 References. Processing and Visualization Functions; *** Miroslav Morháč *** 12; ** E-mail : morhac@savba.sk **; 1 BACKGROUND ELIMINATION; 1.1 1-DIMENSIONAL SPECTRA; This function calculates background spectrum from the source spectrum. The result is placed in the vector pointed by spectrum pointer. On successful completion it returns 0. On error it returns pointer to the string describing error.; char *Background1(float *spectrum,; int size,; int number_of_iterations);; Function parameters:. spectrum: pointer to the vector of the source spectrum; size: length of spectrum; number_of_iterations: or width of the clipping window. The function allows to separate useless spectrum information (continuous background) from peaks, based on Sensitive Nonlinear Iterative Peak Clipping Algorithm. In fact, it represents the second order difference filter (-1,2,-1). The basic algorithm is described in details in [1], [2].; \[ v_p(i)= min\left\{v_{p-1} , \frac{[v_{p-1}(i+p)+v_{p-1}(i-p)]}{2} \right\} \]; where p can be changed as follows:. from 1 up to a given parameter value w by incrementing it in each iteration step by 1 - INCREASING CLIPPING WINDOW; from a given value w by decrementing it in each iteration step by 1 - DECREASING CLIPPING WINDOW. An example of the original spectrum and estimated background (INCREASING CLIPPING WINDOW) is given in the Figure 1",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:1073,Availability,error,error,1073,"ing and Visualization Functions; Miroslav Morháč. Processing and Visualization Functions; 1 BACKGROUND ELIMINATION; 1.1 1-DIMENSIONAL SPECTRA; 1.2 2-DIMENSIONAL SPECTRA. 2 SMOOTHING; 2.1 1-DIMENSIONAL SPECTRA; 2.2 2-DIMENSIONAL SPECTRA. 3 PEAK SEARCHING; 3.1 1-DIMENSIONAL SPECTRA; 3.2 2-DIMENSIONAL SPECTRA. 4 DECONVOLUTION - UNFOLDING; 4.1 1-DIMENSIONAL SPECTRA; 4.2 Gold deconvolution algorithm; 4.3 2-DIMENSIONAL SPECTRA. 5 FITTING; 5.1 1-DIMENSIONAL SPECTRA; 5.2 2-DIMENSIONAL SPECTRA. 6 TRANSFORMS; 6.1 1-DIMENSIONAL SPECTRA; 6.2 2-DIMENSIONAL SPECTRA. 7 VISUALIZATION; 7.1 1-DIMENSIONAL SPECTRA; 7.2 2-DIMENSIONAL SPECTRA. 8 References. Processing and Visualization Functions; *** Miroslav Morháč *** 12; ** E-mail : morhac@savba.sk **; 1 BACKGROUND ELIMINATION; 1.1 1-DIMENSIONAL SPECTRA; This function calculates background spectrum from the source spectrum. The result is placed in the vector pointed by spectrum pointer. On successful completion it returns 0. On error it returns pointer to the string describing error.; char *Background1(float *spectrum,; int size,; int number_of_iterations);; Function parameters:. spectrum: pointer to the vector of the source spectrum; size: length of spectrum; number_of_iterations: or width of the clipping window. The function allows to separate useless spectrum information (continuous background) from peaks, based on Sensitive Nonlinear Iterative Peak Clipping Algorithm. In fact, it represents the second order difference filter (-1,2,-1). The basic algorithm is described in details in [1], [2].; \[ v_p(i)= min\left\{v_{p-1} , \frac{[v_{p-1}(i+p)+v_{p-1}(i-p)]}{2} \right\} \]; where p can be changed as follows:. from 1 up to a given parameter value w by incrementing it in each iteration step by 1 - INCREASING CLIPPING WINDOW; from a given value w by decrementing it in each iteration step by 1 - DECREASING CLIPPING WINDOW. An example of the original spectrum and estimated background (INCREASING CLIPPING WINDOW) is given in the Figure 1",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:5209,Availability,error,error,5209,"r,; bool compton);; The meaning of the parameters is as follows:. spectrum: pointer to the vector of the source spectrum; size: length of spectrum vector; number_of_iterations: maximal width of clipping window; direction: direction of change of clipping window. Possible values:. BACK1_INCREASING_WINDOW; BACK1_DECREASING_WINDOW. filter_order: order of clipping filter. Possible values:. BACK1_ORDER2; BACK1_ORDER4; BACK1_ORDER6; BACK1_ORDER8. compton: logical variable whether the estimation of Compton edge will be included. Possible values:. BACK1_EXCLUDE_COMPTON; BACK1_INCLUDE_COMPTON. 1.2 2-DIMENSIONAL SPECTRA; This basic background estimation function allows to separate useless spectrum information (2D-continuous background and coincidences of peaks with background in both dimensions) from peaks. It calculates background spectrum from the source spectrum. The result is placed in the array pointed by spectrum pointer. On successful completion it returns 0. On error it returns a pointer to the string describing error.; char *Background2(float **spectrum,; int sizex,; int sizey,; int number_of_iterations);; Function parameters:. spectrum: pointer to the array of the source spectrum; sizex: x length of spectrum; sizey: y length of spectrum; number_of_iterations: width of the clipping window. In Figure 1.6 we present an example of a 2-dimensional spectrum before background elimination. 2-dimensional spectrum before background elimination. Estimated background is shown in Figure 1.7. After subtraction we get pure 2-dimensional peaks. Estimated background. Similarly to 1-dimensional case, we have generalized also the function for 2-dimensional background estimation. Sometimes the widths of peaks in both dimensions are different. As an example, we can introduce an n-gamma 2-dimensional spectra. Then it is necessary to set different widths of clipping window in both dimensions. In Figure 1.8 we give an example of such a spectrum. It is necessary to set different widths of cl",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:5261,Availability,error,error,5261,"r,; bool compton);; The meaning of the parameters is as follows:. spectrum: pointer to the vector of the source spectrum; size: length of spectrum vector; number_of_iterations: maximal width of clipping window; direction: direction of change of clipping window. Possible values:. BACK1_INCREASING_WINDOW; BACK1_DECREASING_WINDOW. filter_order: order of clipping filter. Possible values:. BACK1_ORDER2; BACK1_ORDER4; BACK1_ORDER6; BACK1_ORDER8. compton: logical variable whether the estimation of Compton edge will be included. Possible values:. BACK1_EXCLUDE_COMPTON; BACK1_INCLUDE_COMPTON. 1.2 2-DIMENSIONAL SPECTRA; This basic background estimation function allows to separate useless spectrum information (2D-continuous background and coincidences of peaks with background in both dimensions) from peaks. It calculates background spectrum from the source spectrum. The result is placed in the array pointed by spectrum pointer. On successful completion it returns 0. On error it returns a pointer to the string describing error.; char *Background2(float **spectrum,; int sizex,; int sizey,; int number_of_iterations);; Function parameters:. spectrum: pointer to the array of the source spectrum; sizex: x length of spectrum; sizey: y length of spectrum; number_of_iterations: width of the clipping window. In Figure 1.6 we present an example of a 2-dimensional spectrum before background elimination. 2-dimensional spectrum before background elimination. Estimated background is shown in Figure 1.7. After subtraction we get pure 2-dimensional peaks. Estimated background. Similarly to 1-dimensional case, we have generalized also the function for 2-dimensional background estimation. Sometimes the widths of peaks in both dimensions are different. As an example, we can introduce an n-gamma 2-dimensional spectra. Then it is necessary to set different widths of clipping window in both dimensions. In Figure 1.8 we give an example of such a spectrum. It is necessary to set different widths of cl",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:19404,Availability,robust,robustness,19404," markov,; int aver_window);; This function searches for peaks in the source spectrum. The number of found peaks and their positions are written into the structure pointed by the one_dim_peak structure pointer.; Function parameters:. spectrum: pointer to the vector of the source spectrum. This source spectrum is replaced by the new spectrum calculated using Markov chains method.; size: length of the source spectrum; sigma: sigma of searched peaks; threshold: threshold value for peaks selection; markov: logical variable. If it is set to true, then the source spectrum is first replaced by the new spectrum calculated using Markov chains method; aver_window: averaging window used in the calculation of Markov spectrum, applies only if the markov variable was set to true. The methods of peak searching are sensitive to the sigma. Usually the sigma value is known beforehand. It also changes only slightly with the energy. We have investigated as well the robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10 (see Figure 3.6). Robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10. We applied peak searching algorithm based on Markov approach. We changed sigma in the interval from 1 to 10. The spectra for averaging windows 3, 5, 10 are shown in Figure 3.7. Spectra for averaging windows 3, 5, 10. When we applied peak searching function to the Markov spectrum averaged with the window=10, we obtained correct estimate of all 10 peak positions for sigma=2,3,4,5,6,7,8. It was not the case when we made the same experiment with the original spectrum. For all sigmas some peaks were not discovered.; 3.2 2-DIMENSIONAL SPECTRA; The basic function of the 2-dimensional peak searching is described in details in [4]. It automatically identifies the peaks in a spectrum with the presence of the continuous background, statistical fluctuations as well as coincidences of background in one dimension and pea",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:35018,Availability,error,errors,35018,"loped (Gauss-Newton, Levenber-Marquart conjugate gradients, etc.) and more or less successfully implemented into programs for analysis of complex spectra. They are based on matrix inversion that can impose appreciable convergence difficulties mainly for large number of fitted parameters. Peaks can be fitted separately, each peak (or multiplets) in a region or together all peaks in a spectrum. To fit separately each peak one needs to determine the fitted region. However it can happen that the regions of neighboring peaks are overlapping (mainly in 2-dimensional spectra). Then the results of fitting are very poor. On the other hand, when fitting together all the peaks found in a spectrum, one needs to have a method that is stable (i.e., converges) and fast enough to carry out the fitting in a reasonable time. The gradient methods based on the inversion of large matrices are not applicable because of two reasons:. calculation of inverse matrix is extremely time consuming;; due to accumulation of truncation and rounding-off errors, the result can become worthless. We have implemented two kinds of fitting functions. The first approach is based on the algorithm without matrix inversion [9] - awmi algorithm. It allows to fit large blocks of data and large number of parameters.; The other one is based on a calculation of the system of linear equations using Stiefel-Hestens method [10]. It converges faster than the awmi algorithm, however, it is not suitable to fit large number of parameters.; 5.1 1-DIMENSIONAL SPECTRA; The quantity to be minimized in the fitting procedure for one-dimensional spectrum is defined as; \[ \chi^2 = \frac{1}{N-M}\sum_{i=1}^{N}\frac{[y_i-f(i,a)]^2}{y_i} \]; where i is the channel in the fitted spectrum, N is the number of channels in the fitting subregion, M is the number of free parameters, y_i is the content of the i-th channel, a is a vector of the parameters being fitted and f(i,a) is a fitting or peak shape function.; Instead of the weighting",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:37186,Availability,error,error,37186,"for data with poor statistics [11], [12].; The third statistic to be optimized, which is implemented in the fitting functions, is the Maximum Likelihood Method. It is up to the user to select a suitable statistic.; After differentiating chi^2 we obtain the following M simultaneous equations:; \[ \sum_{i=1}^{N}; \frac{y_i-f(i,a^{(t)})}{y_i}; \frac{\partial f(i,a^t)}{\partial a_k}=; \sum_{j=1}^{M}\sum_{i=1}^{N}; \frac{\partial f(i,a^{(t)})}{\partial a_j}; \frac{\partial f(i,a^{(t)})}{\partial a_k}; \Delta a_j^{(t)} \]. in gamma-ray spectra we have to fit together tens, hundreds of peaks simultaneously that sometimes represent thousands of parameters.; the calculation of the inversion matrix of such a size is practically impossible.; the awmi method is based on the assumption that the off-diagonal terms in the matrix A are equal to zero. \[; \Delta a_{k}^{(t+1)} = \alpha^{(t)}; \frac{; \sum_{i=1}^{N} \frac{e_{i}^{(t)}}{y_i}\frac{\partial f(i,a^{(t)})}{\partial a_k}; }{; \sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}; }; \]; where the error in the channel i is \(e_{i}^{(t)} = y_i-f(i,a^{(t)}); k=1,2,...,M\) and \(\alpha^{(t)}=1\) if the process is convergent or \(\alpha^{(t)}=0.5 \alpha^{(t-1)}\) if it is divergent. Another possibility is to optimize this coefficient.; The error of k-th parameter estimate is; \[; \Delta a_k^{(e)}=; \sqrt{\frac; {\sum_{i=1}^{N}\frac{e_i^2}{y_i}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}}; }; \]; Algorithm with higher powers w=1,2,3...:; \[; \Delta a_{k,w}^{(t+1)}=; \alpha^{(t)}; \frac; {\sum_{i=1}^{N} \frac{e_i}{y_i}\left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w-1}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w}\frac{1}{y_i}}; \]; We have implemented the non-symmetrical semi-empirical peak shape function. It contains the symmetrical Gaussian as well as non-symmetrical terms:; \[; f(i,a) =; \sum_{i=1}^{M} A(",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:37429,Availability,error,error,37429,"ial a_j}; \frac{\partial f(i,a^{(t)})}{\partial a_k}; \Delta a_j^{(t)} \]. in gamma-ray spectra we have to fit together tens, hundreds of peaks simultaneously that sometimes represent thousands of parameters.; the calculation of the inversion matrix of such a size is practically impossible.; the awmi method is based on the assumption that the off-diagonal terms in the matrix A are equal to zero. \[; \Delta a_{k}^{(t+1)} = \alpha^{(t)}; \frac{; \sum_{i=1}^{N} \frac{e_{i}^{(t)}}{y_i}\frac{\partial f(i,a^{(t)})}{\partial a_k}; }{; \sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}; }; \]; where the error in the channel i is \(e_{i}^{(t)} = y_i-f(i,a^{(t)}); k=1,2,...,M\) and \(\alpha^{(t)}=1\) if the process is convergent or \(\alpha^{(t)}=0.5 \alpha^{(t-1)}\) if it is divergent. Another possibility is to optimize this coefficient.; The error of k-th parameter estimate is; \[; \Delta a_k^{(e)}=; \sqrt{\frac; {\sum_{i=1}^{N}\frac{e_i^2}{y_i}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}}; }; \]; Algorithm with higher powers w=1,2,3...:; \[; \Delta a_{k,w}^{(t+1)}=; \alpha^{(t)}; \frac; {\sum_{i=1}^{N} \frac{e_i}{y_i}\left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w-1}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w}\frac{1}{y_i}}; \]; We have implemented the non-symmetrical semi-empirical peak shape function. It contains the symmetrical Gaussian as well as non-symmetrical terms:; \[; f(i,a) =; \sum_{i=1}^{M} A(j); \left\{; exp\left[\frac{-(i-p(j))^2}{2\sigma^2}\right]; +\frac{1}{2}T.exp\left[\frac{(i-p(j))}{B\sigma}\right]; .erfc\left[\frac{(i-p(j))}{\sigma}+\frac{1}{2B}\right]; +\frac{1}{2}S.erfc\left[\frac{(i-p(j))}{\sigma}\right]; \right\}; \]; where T, S are relative amplitudes and B is a slope.; Detailed description of the algorithm is given in [13].; The fitting function implementing the algorithm without matrix inversion has the form of; char*",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:40320,Availability,error,errors,40320,"t fitted channel; int xmax; // last fitted channel; double alpha; // convergence coefficient, input parameter, it should be a positive number and <=1; double chi; // here the function returns the resulting chi-square; int statistic_type; // type of statistics, possible values are:; // FIT1_OPTIM_CHI_COUNTS (chi square statistics with counts as weighting coefficients),; // FIT1_OPTIM_CHI_FUNC_VALUES (chi square statistics with function values as weighting coefficients); // FIT1_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values are:; // FIT1_ALPHA_HALVING,; // FIT1_ALPHA_OPTIMAL; int power; // possible values FIT1_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values; // FIT1_TAYLOR_ORDER_FIRST, FIT1_TAYLOR_ORDER_SECOND. double position_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks positions, input parameters; double position_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted positions, output parameters; double position_err[MAX_NUMBER_OF_PEAKS1]; // position errors; bool fix_position[MAX_NUMBER_OF_PEAKS1]; // logical vector which allows to fix appropriate positions (not fit). However they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted amplitudes, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS1]; // amplitude errors; bool fix_amp[MAX_NUMBER_OF_PEAKS1]i; // logical vector, which allows to fix appropriate amplitudes (not fit). However they are present in the estimated functional; double area[MAX_NUMBER_OF_PEAKS1]; // calculated areas of peaks; double area_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak areas; double sigma_init; // sigma parameter, see peak shape function; double sigma_calc;; double sigma_err;; bool fix_sigma;; double t_init // t parameter, see peak shape function; double t_calc;; double t_err;; ",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:40742,Availability,error,errors,40742,"S (chi square statistics with function values as weighting coefficients); // FIT1_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values are:; // FIT1_ALPHA_HALVING,; // FIT1_ALPHA_OPTIMAL; int power; // possible values FIT1_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values; // FIT1_TAYLOR_ORDER_FIRST, FIT1_TAYLOR_ORDER_SECOND. double position_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks positions, input parameters; double position_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted positions, output parameters; double position_err[MAX_NUMBER_OF_PEAKS1]; // position errors; bool fix_position[MAX_NUMBER_OF_PEAKS1]; // logical vector which allows to fix appropriate positions (not fit). However they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted amplitudes, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS1]; // amplitude errors; bool fix_amp[MAX_NUMBER_OF_PEAKS1]i; // logical vector, which allows to fix appropriate amplitudes (not fit). However they are present in the estimated functional; double area[MAX_NUMBER_OF_PEAKS1]; // calculated areas of peaks; double area_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak areas; double sigma_init; // sigma parameter, see peak shape function; double sigma_calc;; double sigma_err;; bool fix_sigma;; double t_init // t parameter, see peak shape function; double t_calc;; double t_err;; bool fix_t;; double b_init // b parameter, see peak shape function; double b_calc;; double b_err;; bool fix_b;; double s_init; // s parameter, see peak shape function; double s_calc;; double s_err;; bool fix_s;; double a0_init; // background is estimated as a0+a1*x+a2*x*x; double a0_calc;; double a0_err;; bool fix_a0;; double a1_init;; double a1_calc;; double a1_err;; bool fix_a1;; double a2_init;",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:41021,Availability,error,errors,41021,"errors; bool fix_position[MAX_NUMBER_OF_PEAKS1]; // logical vector which allows to fix appropriate positions (not fit). However they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted amplitudes, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS1]; // amplitude errors; bool fix_amp[MAX_NUMBER_OF_PEAKS1]i; // logical vector, which allows to fix appropriate amplitudes (not fit). However they are present in the estimated functional; double area[MAX_NUMBER_OF_PEAKS1]; // calculated areas of peaks; double area_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak areas; double sigma_init; // sigma parameter, see peak shape function; double sigma_calc;; double sigma_err;; bool fix_sigma;; double t_init // t parameter, see peak shape function; double t_calc;; double t_err;; bool fix_t;; double b_init // b parameter, see peak shape function; double b_calc;; double b_err;; bool fix_b;; double s_init; // s parameter, see peak shape function; double s_calc;; double s_err;; bool fix_s;; double a0_init; // background is estimated as a0+a1*x+a2*x*x; double a0_calc;; double a0_err;; bool fix_a0;; double a1_init;; double a1_calc;; double a1_err;; bool fix_a1;; double a2_init;; double a2_calc;; double a2_err;; bool fix_a2;; };; As an example we present a simple 1-dimensional synthetic spectrum with 5 peaks. The fit (obtained using above-given awmi fitting function) is given in Figure 5.1. The chi-square achieved in this fit was 0.76873. The input value of the fit (positions of peaks and their amplitudes) were estimated using peak searching function. Fit obtained using above given awmi fitting function. Let us go to a more complicated fit with a lot of overlapping peaks as in Figure 5.2. The initial positions of peaks were determined from original data, using peak searching function. The fit is not very good, as there are some peaks mis",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:47657,Availability,error,errors,47657,"the source spectrum; p: pointer to the two_dim_fit structure pointer, see manual; sizex: length x of the source spectrum; sizey: length y of the source spectrum. The two_dim_fit structure has the form of; class TSpectrumTwoDimFit{. public:. int number_of_peaks; // input parameter, should be>0; int number_of_iterations; // input parameter, should be >0; int xmin; // first fitted channel in x direction; int xmax; // last fitted channel in x direction; int ymin; // first fitted channel in y direction; int ymax; // last fitted channel in y direction; double alpha; // convergence coefficient, input parameter, it should be a positive number and <=1; double chi; // here the function returns resulting chi square; int statistic_type; // type of statistics, possible values are:; // FIT2_OPTIM_CHI_COUNTS (chi square statistics with counts as weighting coefficients),; // FIT2_OPTIM_CHI_FUNC_VALUES (chi square statistics with function values as weighting coefficients),; // FIT2_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values are:; // FIT2_ALPHA_HALVING, FIT2_ALPHA_OPTIMAL; int power; // possible values are: FIT21_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values are:; // FIT2_TAYLOR_ORDER_FIRST,; // FIT2_TAYLOR_ORDER_SECOND; double position_init_x[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 2D peaks, input parameters; double position_calc_x[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 2D peaks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate x positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitt",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:48154,Availability,error,errors,48154,"ha_optim; // optimization of convergence coefficients, possible values are:; // FIT2_ALPHA_HALVING, FIT2_ALPHA_OPTIMAL; int power; // possible values are: FIT21_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values are:; // FIT2_TAYLOR_ORDER_FIRST,; // FIT2_TAYLOR_ORDER_SECOND; double position_init_x[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 2D peaks, input parameters; double position_calc_x[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 2D peaks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate x positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y positions of 2D peaks, output parameters; double position_err_y[MAX_NUMBER_OF_PEAKS2]; // y position errors of 2D peaks; bool fix_position_y[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 1D ridges, input parameters; double position_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate x positions of 1D ridges (not fit). However, they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y pos",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:48656,Availability,error,errors,48656," positions of 2D peaks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate x positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y positions of 2D peaks, output parameters; double position_err_y[MAX_NUMBER_OF_PEAKS2]; // y position errors of 2D peaks; bool fix_position_y[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 1D ridges, input parameters; double position_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate x positions of 1D ridges (not fit). However, they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 2D pea",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:49157,Availability,error,errors,49157,"ions of 2D peaks, output parameters; double position_err_y[MAX_NUMBER_OF_PEAKS2]; // y position errors of 2D peaks; bool fix_position_y[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 1D ridges, input parameters; double position_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate x positions of 1D ridges (not fit). However, they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 2D peaks, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 2D peaks; bool fix_amp[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate amplitudes of 2D peaks (not fit). However, they are present in the estimated functional; double amp_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:49630,Availability,error,errors,49630," of fitted x positions of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate x positions of 1D ridges (not fit). However, they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 2D peaks, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 2D peaks; bool fix_amp[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate amplitudes of 2D peaks (not fit). However, they are present in the estimated functional; double amp_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_x1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_y1",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:50099,Availability,error,errors,50099,"_OF_PEAKS2]; // calculated values of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 2D peaks, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 2D peaks; bool fix_amp[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate amplitudes of 2D peaks (not fit). However, they are present in the estimated functional; double amp_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_x1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_y1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double volume[MAX_NUMBER_OF_PEAKS1]; // calculated volumes of peaks; double volume_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak volumes; double sigma_init_x; // sigma x parameter; double sigma_calc_x;; double sigma_err_x;; bool",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:50577,Availability,error,errors,50577,"NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 2D peaks, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 2D peaks; bool fix_amp[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate amplitudes of 2D peaks (not fit). However, they are present in the estimated functional; double amp_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_x1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_y1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double volume[MAX_NUMBER_OF_PEAKS1]; // calculated volumes of peaks; double volume_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak volumes; double sigma_init_x; // sigma x parameter; double sigma_calc_x;; double sigma_err_x;; bool fix_sigma_x;; double sigma_init_y; // sigma y parameter; double sigma_calc_y;; double sigma_err_y;; bool fix_sigma_y;; double ro_init; // correlation coefficient; double ro_calc;; double ro_err;; bool fix_ro;; double txy_init; // t parameter for 2D peaks; double txy_calc;; double txy_err;; bool fix_txy;; double sxy_init; // s parameter for 2D peaks; double sxy_calc;; double sxy_err;; bool fix_sxy;; double tx_init; // t parameter for 1D ridges (x direction); double tx_calc;",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:50894,Availability,error,errors,50894,"R_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double volume[MAX_NUMBER_OF_PEAKS1]; // calculated volumes of peaks; double volume_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak volumes; double sigma_init_x; // sigma x parameter; double sigma_calc_x;; double sigma_err_x;; bool fix_sigma_x;; double sigma_init_y; // sigma y parameter; double sigma_calc_y;; double sigma_err_y;; bool fix_sigma_y;; double ro_init; // correlation coefficient; double ro_calc;; double ro_err;; bool fix_ro;; double txy_init; // t parameter for 2D peaks; double txy_calc;; double txy_err;; bool fix_txy;; double sxy_init; // s parameter for 2D peaks; double sxy_calc;; double sxy_err;; bool fix_sxy;; double tx_init; // t parameter for 1D ridges (x direction); double tx_calc;; double tx_err;; bool fix_tx;; double ty_init; // t parameter for 1D ridges (y direction); double ty_calc;; double ty_err;; bool fix_ty;; double sx_init; // s parameter for 1D ridges (x direction); double sx_calc;; double sx_err;; bool fix_sx;; double sy_init; // s parameter for 1D ridges (y direction); double sy_calc;; double sy_err;; bool fix_sy;; double bx_init; // b parameter for 1D ridges (x direction); double bx_calc;; double bx_err;; bool fix_bx;; double by_init; // b parameter for 1D ridges (y direction); double by_calc;; double by_err;; bool fix_by;; double a0_init; // background is estimated as a0+ax*x+ay*y; double a0_calc;; double a0_err;; bool fix_a0;; double ax_init;; double ax_calc;; double ax_err;; bool fix_ax;; double ay_init;; double ay_calc;; double ay_err;; bool fix_ay;; };; The example of the original spectrum and the fitted spectrum is given in Figures 5.6 and 5.7, respectively. We have fitted 5 peaks. Each peak was represented by 7 parameters, which together with sigmax, sigmay and b0 resulted in 38 parameters. The chi-square",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:1377,Deployability,continuous,continuous,1377,"IMENSIONAL SPECTRA; 4.2 Gold deconvolution algorithm; 4.3 2-DIMENSIONAL SPECTRA. 5 FITTING; 5.1 1-DIMENSIONAL SPECTRA; 5.2 2-DIMENSIONAL SPECTRA. 6 TRANSFORMS; 6.1 1-DIMENSIONAL SPECTRA; 6.2 2-DIMENSIONAL SPECTRA. 7 VISUALIZATION; 7.1 1-DIMENSIONAL SPECTRA; 7.2 2-DIMENSIONAL SPECTRA. 8 References. Processing and Visualization Functions; *** Miroslav Morháč *** 12; ** E-mail : morhac@savba.sk **; 1 BACKGROUND ELIMINATION; 1.1 1-DIMENSIONAL SPECTRA; This function calculates background spectrum from the source spectrum. The result is placed in the vector pointed by spectrum pointer. On successful completion it returns 0. On error it returns pointer to the string describing error.; char *Background1(float *spectrum,; int size,; int number_of_iterations);; Function parameters:. spectrum: pointer to the vector of the source spectrum; size: length of spectrum; number_of_iterations: or width of the clipping window. The function allows to separate useless spectrum information (continuous background) from peaks, based on Sensitive Nonlinear Iterative Peak Clipping Algorithm. In fact, it represents the second order difference filter (-1,2,-1). The basic algorithm is described in details in [1], [2].; \[ v_p(i)= min\left\{v_{p-1} , \frac{[v_{p-1}(i+p)+v_{p-1}(i-p)]}{2} \right\} \]; where p can be changed as follows:. from 1 up to a given parameter value w by incrementing it in each iteration step by 1 - INCREASING CLIPPING WINDOW; from a given value w by decrementing it in each iteration step by 1 - DECREASING CLIPPING WINDOW. An example of the original spectrum and estimated background (INCREASING CLIPPING WINDOW) is given in the Figure 1.1. Example of the original spectrum and estimated background (INCREASING CLIPPING WINDOW). One can notice that on the edges of the peaks the estimated background goes under the peaks. An alternative approach is to decrease the clipping window from a given value to the value of one (DECREASING CLIPPING WINDOW). Then the result obtained is given",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:4948,Deployability,continuous,continuous,4948,"d of the estimation of Compton edge is described in details in [3]. Synthetic spectrum with Compton edges. The generalized form of the algorithm is implemented in the following function.; char *Background1General(float *spectrum,; int size,; int number_of_iterations,; int direction,; int filter_order,; bool compton);; The meaning of the parameters is as follows:. spectrum: pointer to the vector of the source spectrum; size: length of spectrum vector; number_of_iterations: maximal width of clipping window; direction: direction of change of clipping window. Possible values:. BACK1_INCREASING_WINDOW; BACK1_DECREASING_WINDOW. filter_order: order of clipping filter. Possible values:. BACK1_ORDER2; BACK1_ORDER4; BACK1_ORDER6; BACK1_ORDER8. compton: logical variable whether the estimation of Compton edge will be included. Possible values:. BACK1_EXCLUDE_COMPTON; BACK1_INCLUDE_COMPTON. 1.2 2-DIMENSIONAL SPECTRA; This basic background estimation function allows to separate useless spectrum information (2D-continuous background and coincidences of peaks with background in both dimensions) from peaks. It calculates background spectrum from the source spectrum. The result is placed in the array pointed by spectrum pointer. On successful completion it returns 0. On error it returns a pointer to the string describing error.; char *Background2(float **spectrum,; int sizex,; int sizey,; int number_of_iterations);; Function parameters:. spectrum: pointer to the array of the source spectrum; sizex: x length of spectrum; sizey: y length of spectrum; number_of_iterations: width of the clipping window. In Figure 1.6 we present an example of a 2-dimensional spectrum before background elimination. 2-dimensional spectrum before background elimination. Estimated background is shown in Figure 1.7. After subtraction we get pure 2-dimensional peaks. Estimated background. Similarly to 1-dimensional case, we have generalized also the function for 2-dimensional background estimation. Sometimes th",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:8646,Deployability,continuous,continuous,8646,"char *Background2RectangularRidges(float **spectrum,; int sizex,; int sizey,; int number_of_iterations_x,; int number_of_iterations_y,; int direction,; int filter_order,; int filter_type);; This function calculates background spectrum from source spectrum. The result is placed to the array pointed by spectrum pointer.; Function parameters:. spectrum: pointer to the array of the source spectrum; sizex: x length of spectrum; sizey: y length of spectrum; number_of_iterations_x_maximal: x width of clipping window; number_of_iterations_y_maximal: y width of clipping window; direction: direction of change of clipping window. Possible values:. BACK2_INCREASING_WINDOW; BACK2_DECREASING_WINDOW. filter_order: order of clipping filter. Possible values:. BACK2_ORDER2 BACK2_ORDER4; BACK2_ORDER6 BACK2_ORDER8. filter_type: determines the algorithm of the filtering. Possible values:. BACK2_SUCCESSIVE_FILTERING; BACK2_ONE_STEP_FILTERING. In what follows we describe a function to estimate a continuous 2-dimensional background together with rectangular and skew ridges. In Figure 1.13 we present a spectrum of this type. Function to estimate continuous 2-dimensional background together with rectangular and skew ridges. The goal is to remove rectangular as well as skew ridges from the spectrum and to leave only 2-dimensional coincidence peaks. After applying background elimination function and subtraction we get the two-dimensional peaks presented in Figure 1.14. Two dimensional peaks obtained after applying background elimination function and subtraction. In Figures 1.15 and 1.16 we present an experimental spectrum with skew ridges and estimated background, respectively. Experimental spectrum with skew ridges. Experimental spectrum with estimated background. The function for the estimation of background together with skew ridges has the form of; char *Background2SkewRidges(float **spectrum,; int sizex,; int sizey,; int number_of_iterations_x,; int number_of_iterations_y,; int direction,",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:8797,Deployability,continuous,continuous,8797,"r,; int filter_type);; This function calculates background spectrum from source spectrum. The result is placed to the array pointed by spectrum pointer.; Function parameters:. spectrum: pointer to the array of the source spectrum; sizex: x length of spectrum; sizey: y length of spectrum; number_of_iterations_x_maximal: x width of clipping window; number_of_iterations_y_maximal: y width of clipping window; direction: direction of change of clipping window. Possible values:. BACK2_INCREASING_WINDOW; BACK2_DECREASING_WINDOW. filter_order: order of clipping filter. Possible values:. BACK2_ORDER2 BACK2_ORDER4; BACK2_ORDER6 BACK2_ORDER8. filter_type: determines the algorithm of the filtering. Possible values:. BACK2_SUCCESSIVE_FILTERING; BACK2_ONE_STEP_FILTERING. In what follows we describe a function to estimate a continuous 2-dimensional background together with rectangular and skew ridges. In Figure 1.13 we present a spectrum of this type. Function to estimate continuous 2-dimensional background together with rectangular and skew ridges. The goal is to remove rectangular as well as skew ridges from the spectrum and to leave only 2-dimensional coincidence peaks. After applying background elimination function and subtraction we get the two-dimensional peaks presented in Figure 1.14. Two dimensional peaks obtained after applying background elimination function and subtraction. In Figures 1.15 and 1.16 we present an experimental spectrum with skew ridges and estimated background, respectively. Experimental spectrum with skew ridges. Experimental spectrum with estimated background. The function for the estimation of background together with skew ridges has the form of; char *Background2SkewRidges(float **spectrum,; int sizex,; int sizey,; int number_of_iterations_x,; int number_of_iterations_y,; int direction,; int filter_order);; The result is placed to the array pointed by spectrum pointer.; Function parameters:. spectrum: pointer to the array of the source spectrum; size",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:10280,Deployability,continuous,continuous,10280,"ridges and estimated background, respectively. Experimental spectrum with skew ridges. Experimental spectrum with estimated background. The function for the estimation of background together with skew ridges has the form of; char *Background2SkewRidges(float **spectrum,; int sizex,; int sizey,; int number_of_iterations_x,; int number_of_iterations_y,; int direction,; int filter_order);; The result is placed to the array pointed by spectrum pointer.; Function parameters:. spectrum: pointer to the array of the source spectrum; sizex: x length of spectrum; sizey: y length of spectrum; number_of_iterations_x: maximal x width of clipping window; number_of_iterations_y: maximal y width of clipping window; direction: direction of change of clipping window. Possible values:. BACK2_INCREASING_WINDOW; BACK2_DECREASING_WINDOW. filter_order: order of clipping filter. Possible values:. BACK2_ORDER2; BACK2_ORDER4; BACK2_ORDER6; BACK2_ORDER8. Next we present the function that estimates the continuous background together with rectangular and nonlinear ridges. To illustrate the data of such a form we present synthetic data shown in Figure 1.17. The estimated background is given in Figure 1.18. Pure Gaussian after subtracting the background from the original spectrum is shown in Figure 1.19. Synthetic data. Estimated background. Pure Gaussian after subtracting the background from the original spectrum. The function to estimate also the nonlinear ridges has the form of; char *Background2NonlinearRidges(float **spectrum,; int sizex,; int sizey,; int number_of_iterations_x,; int number_of_iterations_y,; int direction,; int filter_order);; The result is placed to the array pointed by spectrum pointer.; Function parameters:. spectrum: pointer to the array of the source spectrum; sizex: x length of spectrum; sizey: y length of spectrum; number_of_iterations_x: maximal x width of clipping window; number_of_iterations_y: maximal y width of clipping window; direction: direction of change of c",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:15880,Deployability,continuous,continuous,15880,"dth of the filter can be chosen independently for each dimension. The form of the 2-D smoothing function is as follows:; char *Smooth2(float **spectrum,; int sizex,; int sizey,; int pointsx,; int pointsy);; This function calculates smoothed spectrum from the source spectrum. The result is placed in the array pointed by the spectrum pointer.; Function parameters:. spectrum: pointer to the array of the source spectrum; sizex: x length of spectrum; sizey: y length of spectrum; pointsx, pointsy: width of smoothing window. Possible values:. SMOOTH2_3POINTS; SMOOTH2_5POINTS; SMOOTH2_7POINTS; SMOOTH2_9POINTS; SMOOTH2_11POINTS; SMOOTH2_13POINTS; SMOOTH2_15POINTS. An example of 2-D original data and data after smoothing is given in Figures 2.2, 2.3. 2-D original data. Data after smoothing. 3 PEAK SEARCHING; 3.1 1-DIMENSIONAL SPECTRA; The basic function of the 1-dimensional peak searching is described in details in [4], [5]. It allows to automatically identify the peaks in a spectrum with the presence of the continuous background and statistical fluctuations – noise. The algorithm is based on smoothed second differences that are compared to its standard deviations. Therefore it is necessary to pass a parameter of sigma to the peak searching function. The algorithm is selective to the peaks with a given sigma. The form of the basic peak searching function is; Int_t Search1(const float *spectrum,; int size,; double sigma);; This function searches for peaks in the source spectrum. The number of found peaks and their positions are written into structure pointed by one_dim_peak structure pointer.; Function parameters:. source: pointer to the vector of the source spectrum; p: pointer to the one_dim_peak structure pointer; size: length of the source spectrum; sigma: sigma of searched peaks. The one_dim_peak structure has the form of; struct one_dim_peak{; int number_of_peaks;; double position[MAX_NUMBER_OF_PEAKS1];; };; An example of simple one-dimensional spectrum with identified pe",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:20335,Deployability,continuous,continuous,20335,"nergy. We have investigated as well the robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10 (see Figure 3.6). Robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10. We applied peak searching algorithm based on Markov approach. We changed sigma in the interval from 1 to 10. The spectra for averaging windows 3, 5, 10 are shown in Figure 3.7. Spectra for averaging windows 3, 5, 10. When we applied peak searching function to the Markov spectrum averaged with the window=10, we obtained correct estimate of all 10 peak positions for sigma=2,3,4,5,6,7,8. It was not the case when we made the same experiment with the original spectrum. For all sigmas some peaks were not discovered.; 3.2 2-DIMENSIONAL SPECTRA; The basic function of the 2-dimensional peak searching is described in details in [4]. It automatically identifies the peaks in a spectrum with the presence of the continuous background, statistical fluctuations as well as coincidences of background in one dimension and peak in the other one-ridges. The form of the basic function of 2-dimensional peak searching is; Int_t Search2(const float **source,; int sizex,; int sizey,; double sigma);; This function searches for peaks in the source spectrum. The number of found peaks and their positions are written into the structure pointed by two_dim_peak structure pointer.; Function parameters:. source: pointer to the vector of the source spectrum; sizex: x length of the source spectrum; sizey: y length of the source spectrum; sigma: sigma of searched peaks. An example of the two-dimensional spectrum with the identified peaks is shown in Figure 3.8. Two-dimensional spectrum with the identified peaks. We have also generalized the peak searching function similarly to one-dimensional data. The generalized peak searching function for two-dimensional spectra has the form of; Int_t Search2General(float **source,; int sizex,; int sizey,; do",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:19363,Energy Efficiency,energy,energy,19363,"s as follows:; Int_t Search1General(float *spectrum,; int size,; float sigma,; int threshold,; bool markov,; int aver_window);; This function searches for peaks in the source spectrum. The number of found peaks and their positions are written into the structure pointed by the one_dim_peak structure pointer.; Function parameters:. spectrum: pointer to the vector of the source spectrum. This source spectrum is replaced by the new spectrum calculated using Markov chains method.; size: length of the source spectrum; sigma: sigma of searched peaks; threshold: threshold value for peaks selection; markov: logical variable. If it is set to true, then the source spectrum is first replaced by the new spectrum calculated using Markov chains method; aver_window: averaging window used in the calculation of Markov spectrum, applies only if the markov variable was set to true. The methods of peak searching are sensitive to the sigma. Usually the sigma value is known beforehand. It also changes only slightly with the energy. We have investigated as well the robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10 (see Figure 3.6). Robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10. We applied peak searching algorithm based on Markov approach. We changed sigma in the interval from 1 to 10. The spectra for averaging windows 3, 5, 10 are shown in Figure 3.7. Spectra for averaging windows 3, 5, 10. When we applied peak searching function to the Markov spectrum averaged with the window=10, we obtained correct estimate of all 10 peak positions for sigma=2,3,4,5,6,7,8. It was not the case when we made the same experiment with the original spectrum. For all sigmas some peaks were not discovered.; 3.2 2-DIMENSIONAL SPECTRA; The basic function of the 2-dimensional peak searching is described in details in [4]. It automatically identifies the peaks in a spectrum with the presence of the continuous b",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:25487,Energy Efficiency,energy,energy,25487,"er methods (Fourier, VanCittert etc.) oscillate.; \[ y = Hx \] \[ H^T=H^THx \] \[ y^{'} = H^{'}x \] \[x_{i}^{(k+1)}=\frac{y_{i}^{'}}{\sum_{m=0}^{N-1}H_{im}^{'}x_{m}^{(k)}}x_{i}^{(k)}, i=0,1,...,N-1, \] where: \[ k=1,2,3,...,I \] \[ x^{(0)} = [1,1,...,1]^T \]; The basic function has the form of; char *Deconvolution1(float *source,; const float *resp,; int size,; int number_of_iterations);; This function calculates deconvolution from the source spectrum according to the response spectrum.; Function parameters:. source: pointer to the vector of the source spectrum; resp: pointer to the vector of the response spectrum; size: length of source and the response spectra; number_of_iterations: for details see [8]. As an illustration of the method, let us introduce a small example. In Figure 4.1 we present original 1-dimensional spectrum. It contains multiplets that cannot be directly analyzed. The response function (one peak) is given in Figure 4.2. We assume the same response function (not changing the shape) along the entire energy scale. So the response matrix is composed of mutually shifted response functions by one channel, however of the same shape. Original 1-dimensional spectrum. Response function (one peak). The result after deconvolution is given in Figure 4.3. It substantially improves the resolution in the spectrum. Result after deconvolution. We have developed a new high resolution deconvolution algorithm. We have observed that the Gold deconvolution converges to its stable state (solution). It is useless to increase the number of iterations, the result obtained does not change. To continue decreasing the width of peaks, we have found that when the solution reaches its stable state, it is necessary to stop iterations, then to change the vector in a way and repeat again the Gold deconvolution. We have found that in order to change the particular solution we need to apply a non-linear boosting function to it. The power function proved to give the best results. At t",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:26402,Energy Efficiency,power,power,26402,"ame response function (not changing the shape) along the entire energy scale. So the response matrix is composed of mutually shifted response functions by one channel, however of the same shape. Original 1-dimensional spectrum. Response function (one peak). The result after deconvolution is given in Figure 4.3. It substantially improves the resolution in the spectrum. Result after deconvolution. We have developed a new high resolution deconvolution algorithm. We have observed that the Gold deconvolution converges to its stable state (solution). It is useless to increase the number of iterations, the result obtained does not change. To continue decreasing the width of peaks, we have found that when the solution reaches its stable state, it is necessary to stop iterations, then to change the vector in a way and repeat again the Gold deconvolution. We have found that in order to change the particular solution we need to apply a non-linear boosting function to it. The power function proved to give the best results. At the beginning the function calculates exact solution of the Toeplitz system of linear equations.; \[ x^{(0)} = [x_e^2(0),x_e^2(1),...,x_e^2(N-1),]^T\] where \[ x_e=H^{'-1}y^{'}\]; Then it applies the Gold deconvolution algorithm to the solution and carries out preset number of iterations. Then the power function with the exponent equal to the boosting coefficient is applied to the deconvolved data. These data are then used as initial estimate of the solution of linear system of equations and again the Gold algorithm is employed. The whole procedure is repeated number_of_repetitions times.; The form of the high-resolution deconvolution function is; char *Deconvolution1HighResolution(float *source,; const float *resp,; int size,; int number_of_iterations,; int number_of_repetitions,; double boost);; This function calculates deconvolution from the source spectrum according to the response spectrum.; The result is placed in the vector pointed by the source poi",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:26752,Energy Efficiency,power,power,26752,"lt after deconvolution. We have developed a new high resolution deconvolution algorithm. We have observed that the Gold deconvolution converges to its stable state (solution). It is useless to increase the number of iterations, the result obtained does not change. To continue decreasing the width of peaks, we have found that when the solution reaches its stable state, it is necessary to stop iterations, then to change the vector in a way and repeat again the Gold deconvolution. We have found that in order to change the particular solution we need to apply a non-linear boosting function to it. The power function proved to give the best results. At the beginning the function calculates exact solution of the Toeplitz system of linear equations.; \[ x^{(0)} = [x_e^2(0),x_e^2(1),...,x_e^2(N-1),]^T\] where \[ x_e=H^{'-1}y^{'}\]; Then it applies the Gold deconvolution algorithm to the solution and carries out preset number of iterations. Then the power function with the exponent equal to the boosting coefficient is applied to the deconvolved data. These data are then used as initial estimate of the solution of linear system of equations and again the Gold algorithm is employed. The whole procedure is repeated number_of_repetitions times.; The form of the high-resolution deconvolution function is; char *Deconvolution1HighResolution(float *source,; const float *resp,; int size,; int number_of_iterations,; int number_of_repetitions,; double boost);; This function calculates deconvolution from the source spectrum according to the response spectrum.; The result is placed in the vector pointed by the source pointer.; Function parameters:. source: pointer to the vector of the source spectrum; resp: pointer to the vector of the response spectrum; size: length of source and the response spectra; number_of_iterations: for details we refer to manual; number_of_repetitions: for details we refer to manual; boost: boosting factor, for details we refer to manual. The result obtained usin",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:37656,Energy Efficiency,power,powers,37656,"ial a_j}; \frac{\partial f(i,a^{(t)})}{\partial a_k}; \Delta a_j^{(t)} \]. in gamma-ray spectra we have to fit together tens, hundreds of peaks simultaneously that sometimes represent thousands of parameters.; the calculation of the inversion matrix of such a size is practically impossible.; the awmi method is based on the assumption that the off-diagonal terms in the matrix A are equal to zero. \[; \Delta a_{k}^{(t+1)} = \alpha^{(t)}; \frac{; \sum_{i=1}^{N} \frac{e_{i}^{(t)}}{y_i}\frac{\partial f(i,a^{(t)})}{\partial a_k}; }{; \sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}; }; \]; where the error in the channel i is \(e_{i}^{(t)} = y_i-f(i,a^{(t)}); k=1,2,...,M\) and \(\alpha^{(t)}=1\) if the process is convergent or \(\alpha^{(t)}=0.5 \alpha^{(t-1)}\) if it is divergent. Another possibility is to optimize this coefficient.; The error of k-th parameter estimate is; \[; \Delta a_k^{(e)}=; \sqrt{\frac; {\sum_{i=1}^{N}\frac{e_i^2}{y_i}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}}; }; \]; Algorithm with higher powers w=1,2,3...:; \[; \Delta a_{k,w}^{(t+1)}=; \alpha^{(t)}; \frac; {\sum_{i=1}^{N} \frac{e_i}{y_i}\left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w-1}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w}\frac{1}{y_i}}; \]; We have implemented the non-symmetrical semi-empirical peak shape function. It contains the symmetrical Gaussian as well as non-symmetrical terms:; \[; f(i,a) =; \sum_{i=1}^{M} A(j); \left\{; exp\left[\frac{-(i-p(j))^2}{2\sigma^2}\right]; +\frac{1}{2}T.exp\left[\frac{(i-p(j))}{B\sigma}\right]; .erfc\left[\frac{(i-p(j))}{\sigma}+\frac{1}{2B}\right]; +\frac{1}{2}S.erfc\left[\frac{(i-p(j))}{\sigma}\right]; \right\}; \]; where T, S are relative amplitudes and B is a slope.; Detailed description of the algorithm is given in [13].; The fitting function implementing the algorithm without matrix inversion has the form of; char*",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:39888,Energy Efficiency,power,power,39888,"mFit *p,; int size);; This function fits the source spectrum. The calling program should fill in the input parameters of the one_dim_fit structure. The fitted parameters are written into structure pointed by one_dim_fit structure pointer and fitted data are written into source spectrum.; Function parameters:. source: pointer to the vector of the source spectrum; p: pointer to the one_dim_fit structure pointer; size: length of the source spectrum. The one_dim_fit structure has the form of; class TSpectrumOneDimFit{. public:. int number_of_peaks; // input parameter, should be >0; int number_of_iterations; // input parameter, should be >0; int xmin; // first fitted channel; int xmax; // last fitted channel; double alpha; // convergence coefficient, input parameter, it should be a positive number and <=1; double chi; // here the function returns the resulting chi-square; int statistic_type; // type of statistics, possible values are:; // FIT1_OPTIM_CHI_COUNTS (chi square statistics with counts as weighting coefficients),; // FIT1_OPTIM_CHI_FUNC_VALUES (chi square statistics with function values as weighting coefficients); // FIT1_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values are:; // FIT1_ALPHA_HALVING,; // FIT1_ALPHA_OPTIMAL; int power; // possible values FIT1_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values; // FIT1_TAYLOR_ORDER_FIRST, FIT1_TAYLOR_ORDER_SECOND. double position_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks positions, input parameters; double position_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted positions, output parameters; double position_err[MAX_NUMBER_OF_PEAKS1]; // position errors; bool fix_position[MAX_NUMBER_OF_PEAKS1]; // logical vector which allows to fix appropriate positions (not fit). However they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks amplitudes, input parameters",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:44052,Energy Efficiency,power,power,44052,"imental spectrum (with background), we obtain the result shown in Figure 5.5. Now the fitted function corresponds much better to the experimental values. Fit of the original experimental spectrum (with background). We have also implemented the fitting function with matrix inversion based on Stiefel-Hestens method of the solution of the system of linear equations. The form of the function is as follows:; char *Fit1Stiefel(float *source,; TSpectrumOneDimFit* p,; int size);; This function fits the source spectrum. The calling program should fill in the input parameters of the one_dim_fit structure. The fitted parameters are written into structure pointed by one_dim_fit structure pointer and fitted data are written into source spectrum.; Function parameters:. source: pointer to the vector of the source spectrum; p: pointer to the one_dim_fit structure pointer; size: length of the source spectrum. The structure one_dim_fit is the same as in awmi function. The parameters power, fit_taylor, are not applicable for this function.; The results for small number of fitted parameters are the same as with awmi function. However, it converges faster. The example for data given in Figure 5.1 is given in the following table:. # of iterations; Chi awmi; Chi-Stiefel. 1; 924; 89.042. 5; 773.15; 0.96242. 10; 38.13; 0.77041. 50; 0.90293; 0.76873. 100; 0.76886; 0.76873. 500; 0.76873; 0.76873. 5.2 2-DIMENSIONAL SPECTRA; It is straightforward that for two-dimensional spectra one can write; \[; \Delta a_k^{(t+1)}=\alpha^{(t)}; \frac; {\sum_{i_1=1}^{N_1}\sum_{i_2=1}^{N_2}\frac{e_{i_1,i_2}^{(t)}}{y_{i_1,i_2}}; \frac{\partial f(i_1,i_2,a^{(t)})}{\partial a_k}}; {\sum_{i_1=1}^{N_1}\sum_{i_2=1}^{N_2}; \left[\frac{\partial f(i_1,i_2,a^{(t)})}{\partial a_k} \right]^2; \frac{1}{y_{i_1,i_2}}}; \]; In a similar way, for two-dimensional peaks we have chosen the peak shape function of the following form:; \[; f(i_1,i_2,a) = \sum_{j=1}^{M}\left\{; \begin{array}{l}; A_{xy}(j) exp\left\{-\frac{1}{2(1-\rho^",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:47180,Energy Efficiency,power,power,47180,"the source spectrum; p: pointer to the two_dim_fit structure pointer, see manual; sizex: length x of the source spectrum; sizey: length y of the source spectrum. The two_dim_fit structure has the form of; class TSpectrumTwoDimFit{. public:. int number_of_peaks; // input parameter, should be>0; int number_of_iterations; // input parameter, should be >0; int xmin; // first fitted channel in x direction; int xmax; // last fitted channel in x direction; int ymin; // first fitted channel in y direction; int ymax; // last fitted channel in y direction; double alpha; // convergence coefficient, input parameter, it should be a positive number and <=1; double chi; // here the function returns resulting chi square; int statistic_type; // type of statistics, possible values are:; // FIT2_OPTIM_CHI_COUNTS (chi square statistics with counts as weighting coefficients),; // FIT2_OPTIM_CHI_FUNC_VALUES (chi square statistics with function values as weighting coefficients),; // FIT2_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values are:; // FIT2_ALPHA_HALVING, FIT2_ALPHA_OPTIMAL; int power; // possible values are: FIT21_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values are:; // FIT2_TAYLOR_ORDER_FIRST,; // FIT2_TAYLOR_ORDER_SECOND; double position_init_x[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 2D peaks, input parameters; double position_calc_x[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 2D peaks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate x positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitt",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:53938,Energy Efficiency,power,power,53938,"obtained chi-square was 0.76732. Original spectrum. Fitted function. We have implemented the fitting function with matrix inversion based on Stiefel-Hestens method of the solution of the system of linear equations also for 2-dimensional data. The form of the function is as follows; char* Fit2Stiefel(float **source,; TSpectrumTwoDimFit* p,; int sizex,; int sizey);; This function fits the source spectrum. The calling program should fill in the input parameters of the two_dim_fit structure. The fitted parameters are written into structure pointed by two_dim_fit structure pointer and fitted data are written back into the source spectrum.; Function parameters:. source: pointer to the matrix of the source spectrum; p: pointer to the two_dim_fit structure pointer, see manual; sizex: length x of the source spectrum; sizey: length y of the source spectrum. The structure two_dim_fit is the same as in the awmi function. The parameters power, fit_taylor are not applicable for this function; The results for small number of fitted parameters are the same as with awmi function. However, it converges faster. The example for data given in Figure 5.6 (38 parameters) is presented in the following table:. # of iterations; Chi awmi; Chi-Stiefel. 1; 24.989; 10.415. 5; 20.546; 1.0553. 10; 6.256; 0.84383. 50; 1.0985; 0.64297. 100; 0.6571; 0.64297. 500; 0.65194; 0.64297. Again, Stiefel-Hestens method converges faster. However, its calculation is for this number of parameters takes approximately 3 times longer. For larger number of parameters the time needed to calculate the inversion grows with the cube of the number of fitted parameters. For example, the fit of large number of parameters (2068) for data in Figure 5.8 using awmi algorithm took about 12 hours (using 450 MHz PC). The calculation using matrix inversion method is not realizable in any reasonable time.; 6 TRANSFORMS; 6.1 1-DIMENSIONAL SPECTRA; Orthogonal transforms can be successfully used for the processing of nuclear spectra. T",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:63686,Energy Efficiency,efficient,efficient,63686,"data, its size should be sizex*sizey except for direct FOURIER, FOUR-WALSh, FOUR-HAAR. These need sizex*2*sizey length to store real and imaginary coefficients; sizex,sizey: basic dimensions of the source and dest spectra; type: type of transform. TRANSFORM2_HAAR; TRANSFORM2_WALSH; TRANSFORM2_COS; TRANSFORM2_SIN; TRANSFORM2_FOURIER; TRANSFORM2_HARTLEY; TRANSFORM2_FOURIER_WALSH; TRANSFORM2_FOURIER_HAAR; TRANSFORM2_WALSH_HAAR; TRANSFORM2_COS_WALSH; TRANSFORM2_COS_HAAR; TRANSFORM2_SIN_WALSH; TRANSFORM2_SIN_HAAR. direction: transform direction (forward, inverse); degree: applies only for mixed transforms. An example of the 2-dimensional Cosine transform of data from Figure 5.6 is given in Figure 6.7. One can notice that the data are concentrated again around the beginning of the coordinate system. This allows to apply filtration, enhancement and compression techniques in the transform domain. 2-dimensional Cosine transform of data from Figure 5.6. In some cases, when the spectrum is smooth, the cosine transforms are very efficient. In Figures 6.8, 6.9 we show original spectrum and transformed coefficients using Cosine transform, respectively. Original spectrum. Transformed coefficients using Cosine transform. Similarly to 1-dimensional case we have also implemented the functions for zonal filtration, Gauss filtration and enhancement. The zonal filtration function using classic transforms has the form of; char *Filter2Zonal(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int degree,; int xmin,; int xmax,; int ymin,; int ymax,; float filter_coeff);; This function transforms the source spectrum. The calling program should fill in the input parameters. Then it sets transformed coefficients in the given region to the given filter_coeff and transforms it back. Filtered data are written into the dest spectrum.; Function parameters:. source: pointer to the matrix of source spectrum, its size should be sizex*sizey; dest: pointer to the matrix of destinat",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:17995,Integrability,depend,depending,17995,"pectrum with many identified peaks is given in Figure 3.2. 1-dimensional experimental spectrum with many identified peaks. However, when we have noisy data, the number of peaks can be enormous. One such an example is given in Figure 3.3. With noisy data the number of peaks can be enormous. Therefore it can be useful to have a possibility to set a threshold value and to consider only the peaks higher than this threshold (see Figure 3.4, only three peaks were identified, threshold=50). The value in the center of the peak (value[i]) minus the average value in two symmetrically positioned channels (channels i-3*sigma, i+3*sigma) must be greater than threshold. Otherwise the peak is ignored. Iwth threshold=50, only three peaks were identified. An alternative approach was proposed in [6]. The algorithm generates new invariant spectrum based on discrete Markov chains. In this spectrum the noise is suppressed, the spectrum is smoother than the original one. On the other hand it emphasizes peaks (depending on the averaging window). The example of the part of original noisy spectrum and Markov spectrum for window=3 is given in Figure 3.5 Then the peaks can be found in Markov spectrum using standard above-presented algorithm. Part of original noisy spectrum and Markov spectrum for window=3. The form of the generalized peak searching function is as follows:; Int_t Search1General(float *spectrum,; int size,; float sigma,; int threshold,; bool markov,; int aver_window);; This function searches for peaks in the source spectrum. The number of found peaks and their positions are written into the structure pointed by the one_dim_peak structure pointer.; Function parameters:. spectrum: pointer to the vector of the source spectrum. This source spectrum is replaced by the new spectrum calculated using Markov chains method.; size: length of the source spectrum; sigma: sigma of searched peaks; threshold: threshold value for peaks selection; markov: logical variable. If it is set to true, t",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:55560,Integrability,depend,depends,55560,"me needed to calculate the inversion grows with the cube of the number of fitted parameters. For example, the fit of large number of parameters (2068) for data in Figure 5.8 using awmi algorithm took about 12 hours (using 450 MHz PC). The calculation using matrix inversion method is not realizable in any reasonable time.; 6 TRANSFORMS; 6.1 1-DIMENSIONAL SPECTRA; Orthogonal transforms can be successfully used for the processing of nuclear spectra. They can be used to remove high frequency noise, to increase signal-to-background ratio as well as to enhance low intensity components [14]. We have implemented also the function for the calculation of the commonly used orthogonal transforms:. Haar; Walsh; Cos; Sin; Fourier; Hartley. Between these transform one can define so called generalized mixed transforms that are also implemented in the transform function:. Fourier-Haar; Fourier-Walsh; Walsh-Haar; Cos-Walsh; Cos-Haar; Sin-Walsh; Sin-Haar. The suitability of the application of appropriate transform depends on the character of the data, i.e., on the shape of dominant components contained in the data. The form of the transform function is as follows:; char *Transform1(const float *source,; float *dest,; int size,; int type,; int direction,; int degree);; This function transforms the source spectrum. The calling program should fill in the input parameters. Transformed data are written into the dest spectrum.; Function parameters:. source: pointer to the vector of the source spectrum, its length should be equal to the size parameter except for inverse FOURIER, FOUR-WALSH, FOUR-HAAR transform. These need 2*size length to supply real and imaginary coefficients; dest: pointer to the vector of the dest data, its length should be equal to the size parameter except for direct FOURIER, FOUR-WALSh, FOUR-HAAR. These need 2*size length to store real and imaginary coefficients; size: basic length of the source and dest spectra; type: type of transform. TRANSFORM1_HAAR; TRANSFORM1_WALS",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:4697,Modifiability,variab,variable,4697,"on edges and decreasing clipping window. In the lower part of the Figure we present the background, which was added to the synthetic spectrum. One can observe good coincidence with the estimated background. The method of the estimation of Compton edge is described in details in [3]. Synthetic spectrum with Compton edges. The generalized form of the algorithm is implemented in the following function.; char *Background1General(float *spectrum,; int size,; int number_of_iterations,; int direction,; int filter_order,; bool compton);; The meaning of the parameters is as follows:. spectrum: pointer to the vector of the source spectrum; size: length of spectrum vector; number_of_iterations: maximal width of clipping window; direction: direction of change of clipping window. Possible values:. BACK1_INCREASING_WINDOW; BACK1_DECREASING_WINDOW. filter_order: order of clipping filter. Possible values:. BACK1_ORDER2; BACK1_ORDER4; BACK1_ORDER6; BACK1_ORDER8. compton: logical variable whether the estimation of Compton edge will be included. Possible values:. BACK1_EXCLUDE_COMPTON; BACK1_INCLUDE_COMPTON. 1.2 2-DIMENSIONAL SPECTRA; This basic background estimation function allows to separate useless spectrum information (2D-continuous background and coincidences of peaks with background in both dimensions) from peaks. It calculates background spectrum from the source spectrum. The result is placed in the array pointed by spectrum pointer. On successful completion it returns 0. On error it returns a pointer to the string describing error.; char *Background2(float **spectrum,; int sizex,; int sizey,; int number_of_iterations);; Function parameters:. spectrum: pointer to the array of the source spectrum; sizex: x length of spectrum; sizey: y length of spectrum; number_of_iterations: width of the clipping window. In Figure 1.6 we present an example of a 2-dimensional spectrum before background elimination. 2-dimensional spectrum before background elimination. Estimated background is sho",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:18960,Modifiability,variab,variable,18960,"uppressed, the spectrum is smoother than the original one. On the other hand it emphasizes peaks (depending on the averaging window). The example of the part of original noisy spectrum and Markov spectrum for window=3 is given in Figure 3.5 Then the peaks can be found in Markov spectrum using standard above-presented algorithm. Part of original noisy spectrum and Markov spectrum for window=3. The form of the generalized peak searching function is as follows:; Int_t Search1General(float *spectrum,; int size,; float sigma,; int threshold,; bool markov,; int aver_window);; This function searches for peaks in the source spectrum. The number of found peaks and their positions are written into the structure pointed by the one_dim_peak structure pointer.; Function parameters:. spectrum: pointer to the vector of the source spectrum. This source spectrum is replaced by the new spectrum calculated using Markov chains method.; size: length of the source spectrum; sigma: sigma of searched peaks; threshold: threshold value for peaks selection; markov: logical variable. If it is set to true, then the source spectrum is first replaced by the new spectrum calculated using Markov chains method; aver_window: averaging window used in the calculation of Markov spectrum, applies only if the markov variable was set to true. The methods of peak searching are sensitive to the sigma. Usually the sigma value is known beforehand. It also changes only slightly with the energy. We have investigated as well the robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10 (see Figure 3.6). Robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10. We applied peak searching algorithm based on Markov approach. We changed sigma in the interval from 1 to 10. The spectra for averaging windows 3, 5, 10 are shown in Figure 3.7. Spectra for averaging windows 3, 5, 10. When we applied peak searching function to the Markov",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:19195,Modifiability,variab,variable,19195,"pectrum for window=3 is given in Figure 3.5 Then the peaks can be found in Markov spectrum using standard above-presented algorithm. Part of original noisy spectrum and Markov spectrum for window=3. The form of the generalized peak searching function is as follows:; Int_t Search1General(float *spectrum,; int size,; float sigma,; int threshold,; bool markov,; int aver_window);; This function searches for peaks in the source spectrum. The number of found peaks and their positions are written into the structure pointed by the one_dim_peak structure pointer.; Function parameters:. spectrum: pointer to the vector of the source spectrum. This source spectrum is replaced by the new spectrum calculated using Markov chains method.; size: length of the source spectrum; sigma: sigma of searched peaks; threshold: threshold value for peaks selection; markov: logical variable. If it is set to true, then the source spectrum is first replaced by the new spectrum calculated using Markov chains method; aver_window: averaging window used in the calculation of Markov spectrum, applies only if the markov variable was set to true. The methods of peak searching are sensitive to the sigma. Usually the sigma value is known beforehand. It also changes only slightly with the energy. We have investigated as well the robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10 (see Figure 3.6). Robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10. We applied peak searching algorithm based on Markov approach. We changed sigma in the interval from 1 to 10. The spectra for averaging windows 3, 5, 10 are shown in Figure 3.7. Spectra for averaging windows 3, 5, 10. When we applied peak searching function to the Markov spectrum averaged with the window=10, we obtained correct estimate of all 10 peak positions for sigma=2,3,4,5,6,7,8. It was not the case when we made the same experiment with the original spectrum.",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:21856,Modifiability,variab,variable,21856,"ture pointed by two_dim_peak structure pointer.; Function parameters:. source: pointer to the vector of the source spectrum; sizex: x length of the source spectrum; sizey: y length of the source spectrum; sigma: sigma of searched peaks. An example of the two-dimensional spectrum with the identified peaks is shown in Figure 3.8. Two-dimensional spectrum with the identified peaks. We have also generalized the peak searching function similarly to one-dimensional data. The generalized peak searching function for two-dimensional spectra has the form of; Int_t Search2General(float **source,; int sizex,; int sizey,; double sigma,; int threshold,; bool markov,; int aver_window);; This function searches for peaks in the source spectrum. The number of found peaks and their positions are written into the structure pointed by two_dim_peak structure pointer.; Function parameters:. source: pointer to the vector of the source spectrum; sizex: x length of the source spectrum; sizey: y length of the source spectrum; sigma: sigma of searched peaks; threshold: threshold value for peaks selection; markov: logical variable. If it is set to true, then the source spectrum is first replaced by the new spectrum calculated using Markov chains method; aver_window averaging window of searched peaks (applies only for the Markov method). An example of experimental 2-dimensional spectrum is given in Figure 3.9. The number of peaks identified by the function now is 295. Experimental 2-dimensional spectrum. The function works even for very noisy data. In Figure 3.10 we present synthetic 2-dimensional spectrum with 5 peaks. The method should recognize what is the real 2-dimensional peak and what is the crossing of two 1-dimensional ridges. The Markov spectrum with averaging window=3 is given in Figure 3.11. One can observe that this spectrum is smoother than the original one. After applying the general peak searching function to the Markov spectrum with sigma=2 and threshold=600, we get correctly id",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:30705,Modifiability,extend,extended,30705,"hemical elements. The original spectrum before unfolding is given in Figure 4.7. The obtained coefficients after unfolding, i.e., the contents of the responses in the original spectrum, are presented in the Figure 4.8. Original spectrum before unfolding. Contents of the responses in the original spectrum. Another example where we have used the unfolding method is the decomposition of continuum of gamma-ray spectra. Using simulation and interpolation techniques, we have synthesized the response matrix (size 3400x3400 channels) of Gammasphere spectrometer (Figure 4.9). Its details are presented in Figure 4.10. The original spectrum of Co^56 before and after continuum decomposition are presented in Figures 4.11, 4.12, respectively. Response matrix (size 3400x3400 channels) of Gammasphere spectrometer. Detail of Figure 4.9. Original spectrum of Co56 before continuum decomposition. Original spectrum of Co56 after continuum decomposition. 4.3 2-DIMENSIONAL SPECTRA; We have extended the method of Gold deconvolution also for 2-dimensional data. Again, the goal of the deconvolution methods is to improve the resolution in the spectrum and to decompose multiplets. The method of optimized 2-dimensional deconvolution is described in details in [8].; Mathematical formulation of 2-dimensional convolution system is as follows:; \[ y(i_1,i_2) = \sum_{k_1=0}^{N_1-1}\sum_{k_2=0}^{N_2-1}h(i_1-k_1,i_2-k_2)x(k_1,k_2), i_1=0,1,2,...,N_1-1, i_2=0,1,2,...,N_2-1 \]; Assuming we know the output spectrum y and the response spectrum h, the task is to calculate the matrix x.; The basic function has the form of; char *Deconvolution2(float **source,; const float **resp,; int sizex,; int sizey,; int niter);; This function calculates deconvolution from the source spectrum according to the response spectrum. The result is placed in the matrix pointed by the source pointer.; Function parameters:. source: pointer to the matrix of the source spectrum; resp: pointer to the matrix of the response spectrum;",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:55102,Modifiability,enhance,enhance,55102," function. However, it converges faster. The example for data given in Figure 5.6 (38 parameters) is presented in the following table:. # of iterations; Chi awmi; Chi-Stiefel. 1; 24.989; 10.415. 5; 20.546; 1.0553. 10; 6.256; 0.84383. 50; 1.0985; 0.64297. 100; 0.6571; 0.64297. 500; 0.65194; 0.64297. Again, Stiefel-Hestens method converges faster. However, its calculation is for this number of parameters takes approximately 3 times longer. For larger number of parameters the time needed to calculate the inversion grows with the cube of the number of fitted parameters. For example, the fit of large number of parameters (2068) for data in Figure 5.8 using awmi algorithm took about 12 hours (using 450 MHz PC). The calculation using matrix inversion method is not realizable in any reasonable time.; 6 TRANSFORMS; 6.1 1-DIMENSIONAL SPECTRA; Orthogonal transforms can be successfully used for the processing of nuclear spectra. They can be used to remove high frequency noise, to increase signal-to-background ratio as well as to enhance low intensity components [14]. We have implemented also the function for the calculation of the commonly used orthogonal transforms:. Haar; Walsh; Cos; Sin; Fourier; Hartley. Between these transform one can define so called generalized mixed transforms that are also implemented in the transform function:. Fourier-Haar; Fourier-Walsh; Walsh-Haar; Cos-Walsh; Cos-Haar; Sin-Walsh; Sin-Haar. The suitability of the application of appropriate transform depends on the character of the data, i.e., on the shape of dominant components contained in the data. The form of the transform function is as follows:; char *Transform1(const float *source,; float *dest,; int size,; int type,; int direction,; int degree);; This function transforms the source spectrum. The calling program should fill in the input parameters. Transformed data are written into the dest spectrum.; Function parameters:. source: pointer to the vector of the source spectrum, its length should ",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:57469,Modifiability,enhance,enhanced,57469,"basic length of the source and dest spectra; type: type of transform. TRANSFORM1_HAAR; TRANSFORM1_WALSH; TRANSFORM1_COS; TRANSFORM1_SIN; TRANSFORM1_FOURIER; TRANSFORM1_HARTLEY; TRANSFORM1_FOURIER_WALSH; TRANSFORM1_FOURIER_HAAR; TRANSFORM1_WALSH_HAAR; TRANSFORM1_COS_WALSH; TRANSFORM1_COS_HAAR; TRANSFORM1_SIN_WALSH; TRANSFORM1_SIN_HAAR. direction: transform direction (forward, inverse). TRANSFORM1_FORWARD; TRANSFORM1_INVERSE. degree: applies only for mixed transforms. Let us illustrate the applications of the transform using an example. In Figure 6.1 we have spectrum with many peaks, complicated background and high level of noise. Spectrum with many peaks. In Figures 6.2, 6.3, 6.4 we present this spectrum transformed using Haar, Walsh and Cosine transforms, respectively. Spectrum transformed using Haar transform. Spectrum transformed using Walsh transform. Spectrum transformed using Cosine transform. Haar transforms (Figure 6.2) creates clusters of data. These coefficients can be analyzed and then filtered, enhanced, etc. On the other hand, the Walsh transform (Figure 6.3) concentrates the dominant components near zero of the coordinate system. It is more suitable to process data of a rectangular shape (e.g., in the field of digital signal processing). Finally, Cosine transform concentrates in the best way the transform coefficients to the beginning of the coordinate system. From the point of view of the variance distribution, it is sometimes called suboptimal. One can notice that approximately one half of the coefficients are negligible. This fact can be used to the compression purposes (in two- or more dimensional data), filtering (smoothing), etc.; We have implemented several application functions exploiting the properties of the orthogonal transforms. Let us start with zonal filtration function. It has the following form:; char *Filter1Zonal(const float *source,; float *dest,; int size,; int type,; int degree,; int xmin,; int xmax,; float filter_coeff);; This funct",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:60034,Modifiability,enhance,enhance,60034,"SIN; TRANSFORM1_FOURIER; TRANSFORM1_HARTLEY; TRANSFORM1_FOURIER_WALSH; TRANSFORM1_FOURIER_HAAR; TRANSFORM1_WALSH_HAAR; TRANSFORM1_COS_WALSH; TRANSFORM1_COS_HAAR; TRANSFORM1_SIN_WALSH; TRANSFORM1_SIN_HAAR. degree: applied only for mixed transforms; xmin: low limit of filtered region; xmax: high limit of filtered region; filter_coeff: value which is set in filtered region. An example of the filtration using Cosine transform is given in the Figure 6.5. It illustrates a part of the spectrum from Figure 6.1 and two spectra after filtration preserving 2048 coefficients and 1536 coefficients. One can observe a very good fidelity of the overall shape of both spectra with the original data. However, some distortion can be observed in details of the second spectrum after filtration preserving only 1536 coefficients. The useful information in the transform domain can be compressed into one half of the original space. Filtration using Cosine transform. In the transform domain one can also enhance (multiply with the constant > 1) some regions. This way, one can change peak-to-background ratio. This function has a form of; char *Enhance1(const float *source,; float *dest,; int size,; int type,; int degree,; int xmin,; int xmax,; float enhance_coeff);; This function transforms the source spectrum. The calling program should fill in the input parameters. Then it multiplies transformed coefficients in the given region (xmin, xmax) by the given enhance_coeff and transforms it back. Processed data are written into the dest spectrum.; Function parameters:. source: pointer to the vector of the source spectrum, its length should be equal to size; dest: pointer to the vector of the dest data, its length should be equal to size; size: basic length of the source and dest spectra; type: type of transform. TRANSFORM1_HAAR; TRANSFORM1_WALSH; TRANSFORM1_COS; TRANSFORM1_SIN; TRANSFORM1_FOURIER; TRANSFORM1_HARTLEY; TRANSFORM1_FOURIER_WALSH; TRANSFORM1_FOURIER_HAAR; TRANSFORM1_WALSH_HAAR; TRANSFOR",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:61315,Modifiability,enhance,enhancement,61315,"ld fill in the input parameters. Then it multiplies transformed coefficients in the given region (xmin, xmax) by the given enhance_coeff and transforms it back. Processed data are written into the dest spectrum.; Function parameters:. source: pointer to the vector of the source spectrum, its length should be equal to size; dest: pointer to the vector of the dest data, its length should be equal to size; size: basic length of the source and dest spectra; type: type of transform. TRANSFORM1_HAAR; TRANSFORM1_WALSH; TRANSFORM1_COS; TRANSFORM1_SIN; TRANSFORM1_FOURIER; TRANSFORM1_HARTLEY; TRANSFORM1_FOURIER_WALSH; TRANSFORM1_FOURIER_HAAR; TRANSFORM1_WALSH_HAAR; TRANSFORM1_COS_WALSH; TRANSFORM1_COS_HAAR; TRANSFORM1_SIN_WALSH; TRANSFORM1_SIN_HAAR. degree: applied only for mixed transforms; xmin: low limit of filtered region; xmax: high limit of filtered region; enhance_coeff: value by which the filtered region is multiplied. An example of enhancement of the coefficients from region 380-800 by the constant 2 in the Cosine transform domain is given in the Figure 6.6. The determination of the region is a matter of analysis in the appropriate transform domain. We assumed that low frequency components are placed in the low coefficients. As it can be observed, the enhancement changes the peak-to-background ratio. Enhancement of the coefficients from region 380-800 by the constant 2 in the Cosine transform domain. 6.2 2-DIMENSIONAL SPECTRA; Similarly to 1-dimensional data, we have implemented the transforms also for 2-dimensional data. Besides the classic orthogonal transforms like. Haar; Walsh; Cos; Sin; Fourier; Hartley; Fourier-Haar; Fourier-Walsh; Walsh-Haar; Cos-Walsh; Cos-Haar; Sin-Walsh; Sin-Haar. char *Transform2(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int direction,; int degree);; This function transforms the source spectrum. The calling program should fill in the input parameters. Transformed data are written into the dest spectrum.; Funct",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:61641,Modifiability,enhance,enhancement,61641,"ectrum, its length should be equal to size; dest: pointer to the vector of the dest data, its length should be equal to size; size: basic length of the source and dest spectra; type: type of transform. TRANSFORM1_HAAR; TRANSFORM1_WALSH; TRANSFORM1_COS; TRANSFORM1_SIN; TRANSFORM1_FOURIER; TRANSFORM1_HARTLEY; TRANSFORM1_FOURIER_WALSH; TRANSFORM1_FOURIER_HAAR; TRANSFORM1_WALSH_HAAR; TRANSFORM1_COS_WALSH; TRANSFORM1_COS_HAAR; TRANSFORM1_SIN_WALSH; TRANSFORM1_SIN_HAAR. degree: applied only for mixed transforms; xmin: low limit of filtered region; xmax: high limit of filtered region; enhance_coeff: value by which the filtered region is multiplied. An example of enhancement of the coefficients from region 380-800 by the constant 2 in the Cosine transform domain is given in the Figure 6.6. The determination of the region is a matter of analysis in the appropriate transform domain. We assumed that low frequency components are placed in the low coefficients. As it can be observed, the enhancement changes the peak-to-background ratio. Enhancement of the coefficients from region 380-800 by the constant 2 in the Cosine transform domain. 6.2 2-DIMENSIONAL SPECTRA; Similarly to 1-dimensional data, we have implemented the transforms also for 2-dimensional data. Besides the classic orthogonal transforms like. Haar; Walsh; Cos; Sin; Fourier; Hartley; Fourier-Haar; Fourier-Walsh; Walsh-Haar; Cos-Walsh; Cos-Haar; Sin-Walsh; Sin-Haar. char *Transform2(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int direction,; int degree);; This function transforms the source spectrum. The calling program should fill in the input parameters. Transformed data are written into the dest spectrum.; Function parameters:. source: pointer to the matrix of the source spectrum, its size should be sizex*sizey except for inverse FOURIER, FOUR-WALSH, FOUR-HAAR transform. These need sizex*2*sizey length to supply real and imaginary coefficients.; dest: pointer to the matrix of destination",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:63491,Modifiability,enhance,enhancement,63491,"-WALSH, FOUR-HAAR transform. These need sizex*2*sizey length to supply real and imaginary coefficients.; dest: pointer to the matrix of destination data, its size should be sizex*sizey except for direct FOURIER, FOUR-WALSh, FOUR-HAAR. These need sizex*2*sizey length to store real and imaginary coefficients; sizex,sizey: basic dimensions of the source and dest spectra; type: type of transform. TRANSFORM2_HAAR; TRANSFORM2_WALSH; TRANSFORM2_COS; TRANSFORM2_SIN; TRANSFORM2_FOURIER; TRANSFORM2_HARTLEY; TRANSFORM2_FOURIER_WALSH; TRANSFORM2_FOURIER_HAAR; TRANSFORM2_WALSH_HAAR; TRANSFORM2_COS_WALSH; TRANSFORM2_COS_HAAR; TRANSFORM2_SIN_WALSH; TRANSFORM2_SIN_HAAR. direction: transform direction (forward, inverse); degree: applies only for mixed transforms. An example of the 2-dimensional Cosine transform of data from Figure 5.6 is given in Figure 6.7. One can notice that the data are concentrated again around the beginning of the coordinate system. This allows to apply filtration, enhancement and compression techniques in the transform domain. 2-dimensional Cosine transform of data from Figure 5.6. In some cases, when the spectrum is smooth, the cosine transforms are very efficient. In Figures 6.8, 6.9 we show original spectrum and transformed coefficients using Cosine transform, respectively. Original spectrum. Transformed coefficients using Cosine transform. Similarly to 1-dimensional case we have also implemented the functions for zonal filtration, Gauss filtration and enhancement. The zonal filtration function using classic transforms has the form of; char *Filter2Zonal(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int degree,; int xmin,; int xmax,; int ymin,; int ymax,; float filter_coeff);; This function transforms the source spectrum. The calling program should fill in the input parameters. Then it sets transformed coefficients in the given region to the given filter_coeff and transforms it back. Filtered data are written into the dest spectru",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:63992,Modifiability,enhance,enhancement,63992,"SFORM2_COS; TRANSFORM2_SIN; TRANSFORM2_FOURIER; TRANSFORM2_HARTLEY; TRANSFORM2_FOURIER_WALSH; TRANSFORM2_FOURIER_HAAR; TRANSFORM2_WALSH_HAAR; TRANSFORM2_COS_WALSH; TRANSFORM2_COS_HAAR; TRANSFORM2_SIN_WALSH; TRANSFORM2_SIN_HAAR. direction: transform direction (forward, inverse); degree: applies only for mixed transforms. An example of the 2-dimensional Cosine transform of data from Figure 5.6 is given in Figure 6.7. One can notice that the data are concentrated again around the beginning of the coordinate system. This allows to apply filtration, enhancement and compression techniques in the transform domain. 2-dimensional Cosine transform of data from Figure 5.6. In some cases, when the spectrum is smooth, the cosine transforms are very efficient. In Figures 6.8, 6.9 we show original spectrum and transformed coefficients using Cosine transform, respectively. Original spectrum. Transformed coefficients using Cosine transform. Similarly to 1-dimensional case we have also implemented the functions for zonal filtration, Gauss filtration and enhancement. The zonal filtration function using classic transforms has the form of; char *Filter2Zonal(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int degree,; int xmin,; int xmax,; int ymin,; int ymax,; float filter_coeff);; This function transforms the source spectrum. The calling program should fill in the input parameters. Then it sets transformed coefficients in the given region to the given filter_coeff and transforms it back. Filtered data are written into the dest spectrum.; Function parameters:. source: pointer to the matrix of source spectrum, its size should be sizex*sizey; dest: pointer to the matrix of destination data, its size should be sizex*sizey; sizex,sizey: basic dimensions of source and dest spectra; type: type of transform:. TRANSFORM2_HAAR; TRANSFORM2_WALSH; TRANSFORM2_COS; TRANSFORM2_SIN; TRANSFORM2_FOURIER; TRANSFORM2_HARTLEY; TRANSFORM2_FOURIER_WALSH; TRANSFORM2_FOURIER_HAAR; TRAN",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:65300,Modifiability,enhance,enhancement,65300,"oeff and transforms it back. Filtered data are written into the dest spectrum.; Function parameters:. source: pointer to the matrix of source spectrum, its size should be sizex*sizey; dest: pointer to the matrix of destination data, its size should be sizex*sizey; sizex,sizey: basic dimensions of source and dest spectra; type: type of transform:. TRANSFORM2_HAAR; TRANSFORM2_WALSH; TRANSFORM2_COS; TRANSFORM2_SIN; TRANSFORM2_FOURIER; TRANSFORM2_HARTLEY; TRANSFORM2_FOURIER_WALSH; TRANSFORM2_FOURIER_HAAR; TRANSFORM2_WALSH_HAAR; TRANSFORM2_COS_WALSH; TRANSFORM2_COS_HAAR; TRANSFORM2_SIN_WALSH; TRANSFORM2_SIN_HAAR. degree: applies only for mixed transforms; xmin: low limit x of filtered region; xmax: high limit x of filtered region; ymin: low limit y of filtered region; ymax: high limit y of filtered region; filter_coeff: value which is set in filtered region. The enhancement function using transforms has a form of; char *Enhance2(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int degree,; int xmin,; int xmax,; int ymin,; int ymax,; float enhance_coeff);; This function transforms the source spectrum. The calling program should fill in the input parameters. Then it multiplies transformed coefficients in the given region by the given enhance_coeff and transforms it back.; Function parameters:. source: pointer to the matrix of the source spectrum, its size should be sizex*sizey; dest: pointer to the matrix of the destination data, its size should be sizex*sizey; sizex,sizey: basic dimensions of the source and dest spectra; type: type of transform. TRANSFORM2_HAAR; TRANSFORM2_WALSH; TRANSFORM2_COS; TRANSFORM2_SIN; TRANSFORM2_FOURIER; TRANSFORM2_HARTLEY; TRANSFORM2_FOURIER_WALSH; TRANSFORM2_FOURIER_HAAR; TRANSFORM2_WALSH_HAAR; TRANSFORM2_COS_WALSH; TRANSFORM2_COS_HAAR; TRANSFORM2_SIN_WALSH; TRANSFORM2_SIN_HAAR. degree: applies only for mixed transforms; xmin: low limit x of filtered region; xmax: high limit x of filtered region; ymin: low limit y of fil",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:69743,Modifiability,variab,variables,69743,"ithm, hsv modulo color component [15]. int bar_thickness; // applies only for bar display mode; int bar_empty_flag; // (empty bars, full bars) applies only for bar display mode; int border_color; // color of background of the picture; int full_border; // decides whether background is painted; int raster_en_dis; // decides whether the axes and rasters are shown; int raster_long; // decides whether the rasters are drawn as long lines; int raster_color; // color of the rasters; char *raster_description_x; // x axis description; char *raster_description_y; // y axis description. int pen_color; // color of spectrum; int pen_dash; // style of pen; int pen_width; // width of line. int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_color; // color of channel marks. // auxiliary variables, transform coefficients, for internal use only; double mx;; double my;; double px;; double py;. // auxiliary internal variables, working place; double gbezx,gbezy;; TPoint bz[4];; };; The examples using different display parameters are shown in the next few Figures. Display mode -polyline, width of pen=3. Display mode- bars, shown channel marks. Display mode- steps, log scale, shown channel marks. Display mode -Bezier curve interpolation, shown channel marks. Display mode- rainbow bars, color algorithm (model) RGB, number of color levels=1024, pen width=3. Display mode-empty bars, color algorithm YIQ, number of color levels 2048. 7.2 2-DIMENSIONAL SPECTRA; The 2-dimensional visualization function displays spectrum (or its part) on the Canvas of a form. Before calling the function, one has to fill in the two_dim_pic structure containing all parameters of the display. The function has a form of; char *display2(struct two_dim_pic* p);; This function displays the source two-dimensional spectrum on Canvas. All parameters are ",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:69871,Modifiability,variab,variables,69871,"plies only for bar display mode; int border_color; // color of background of the picture; int full_border; // decides whether background is painted; int raster_en_dis; // decides whether the axes and rasters are shown; int raster_long; // decides whether the rasters are drawn as long lines; int raster_color; // color of the rasters; char *raster_description_x; // x axis description; char *raster_description_y; // y axis description. int pen_color; // color of spectrum; int pen_dash; // style of pen; int pen_width; // width of line. int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_color; // color of channel marks. // auxiliary variables, transform coefficients, for internal use only; double mx;; double my;; double px;; double py;. // auxiliary internal variables, working place; double gbezx,gbezy;; TPoint bz[4];; };; The examples using different display parameters are shown in the next few Figures. Display mode -polyline, width of pen=3. Display mode- bars, shown channel marks. Display mode- steps, log scale, shown channel marks. Display mode -Bezier curve interpolation, shown channel marks. Display mode- rainbow bars, color algorithm (model) RGB, number of color levels=1024, pen width=3. Display mode-empty bars, color algorithm YIQ, number of color levels 2048. 7.2 2-DIMENSIONAL SPECTRA; The 2-dimensional visualization function displays spectrum (or its part) on the Canvas of a form. Before calling the function, one has to fill in the two_dim_pic structure containing all parameters of the display. The function has a form of; char *display2(struct two_dim_pic* p);; This function displays the source two-dimensional spectrum on Canvas. All parameters are grouped in the two_dim_pic structure. Before calling the display2 function, the structure should be filled in and the address of two_dim_pic shou",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:75923,Modifiability,variab,variables,75923,"r_color; // color of background of the picture; int full_border; // decides whether background is painted; int raster_en_dis; // decides whether the rasters are shown; int raster_long; // decides whether the rasters are drawn as long lines; int raster_color; // color of the rasters; char *raster_description_x; // x axis description; char *raster_description_y; // y axis description; char *raster_description_z; // z axis description; int pen_color; // color of spectrum; int pen_dash; // style of pen; int pen_width; // width of line; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_color; // color of channel marks; int chanline_en_dis; // decides whether the channel lines (grid) are shown. // auxiliary variables, transformation coefficients for internal use only; double kx;; double ky;; double mxx;; double mxy;; double myx;; double myy;; double txx;; double txy;; double tyx;; double tyy;; double tyz;; double vx;; double vy;; double nu_sli;. // auxiliary internal variables, working place; double z,zeq,gbezx,gbezy,dxspline,dyspline;; int xt,yt,xs,ys,xe,ye,priamka,z_preset_value;; unsigned short obal[MAXIMUM_XSCREEN_RESOLUTION];; unsigned short obal_cont[MAXIMUM_XSCREEN_RESOLUTION];; TPoint bz[4];; };; The examples using different display parameters are shown in the next few Figures. Display mode-bars, pen width=2. Display mode-triangles, log scale. Display mode-contours. Display mode surface shading according to height. Display mode-surface shading according to light point. Display mode-surface shading according to height+light position with ratio 50:50, CMY color model. Display mode bars shaded according to height. Display mode- surface shading according to light position with shadows. Display mode- surface shading according to height with 10 levels of contours. Display mode- surface shading acco",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:76188,Modifiability,variab,variables,76188,"ription_x; // x axis description; char *raster_description_y; // y axis description; char *raster_description_z; // z axis description; int pen_color; // color of spectrum; int pen_dash; // style of pen; int pen_width; // width of line; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_color; // color of channel marks; int chanline_en_dis; // decides whether the channel lines (grid) are shown. // auxiliary variables, transformation coefficients for internal use only; double kx;; double ky;; double mxx;; double mxy;; double myx;; double myy;; double txx;; double txy;; double tyx;; double tyy;; double tyz;; double vx;; double vy;; double nu_sli;. // auxiliary internal variables, working place; double z,zeq,gbezx,gbezy,dxspline,dyspline;; int xt,yt,xs,ys,xe,ye,priamka,z_preset_value;; unsigned short obal[MAXIMUM_XSCREEN_RESOLUTION];; unsigned short obal_cont[MAXIMUM_XSCREEN_RESOLUTION];; TPoint bz[4];; };; The examples using different display parameters are shown in the next few Figures. Display mode-bars, pen width=2. Display mode-triangles, log scale. Display mode-contours. Display mode surface shading according to height. Display mode-surface shading according to light point. Display mode-surface shading according to height+light position with ratio 50:50, CMY color model. Display mode bars shaded according to height. Display mode- surface shading according to light position with shadows. Display mode- surface shading according to height with 10 levels of contours. Display mode- surface shading according to height, sqrt scale, channel marks and lines shown. Display mode- surface shading according to height-contours, rasters allowing to localize interesting parts are shown. 8 References; [1] M. Morháč, J. Kliman, V. Matoušek, M. Veselský, I. Turzo.: Background elimination methods for multidimensi",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:79362,Modifiability,enhance,enhancement,79362,"31-434.; [4] M. Morháč, J. Kliman, V. Matoušek, M. Veselský, I. Turzo.:Identification of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000) 108-125.; [5] M.A. Mariscotti: A method for identification of peaks in the presence of background and its application to spectrum analysis. NIM 50 (1967), 309-320.; [6] Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376 (1996), 451.; [7] P. Bandžuch, M. Morháč, J. Krištiak: Study of the VanCitter and Gold iterative methods of deconvolution and their application in the deconvolution of experimental spectra of positron annihilation, NIM A 384 (1997) 506-515.; [8] M. Morháč, J. Kliman, V. Matoušek, M. Veselský, I. Turzo.: Efficient one- and two-dimensional Gold deconvolution and its application to gamma-ray spectra decomposition. NIM, A401 (1997) 385-408.; [9] I. A. Slavic: Nonlinear least-squares fitting without matrix inversion applied to complex Gaussian spectra analysis. NIM 134 (1976) 285-289.; [10] B. Mihaila: Analysis of complex gamma spectra, Rom. Jorn. Phys., Vol. 39, No. 2, (1994), 139-148.; [11] T. Awaya: A new method for curve fitting to the data with low statistics not using chi-square method. NIM 165 (1979) 317-323.; [12] T. Hauschild, M. Jentschel: Comparison of maximum likelihood estimation and chi-square statistics applied to counting experiments. NIM A 457 (2001) 384-401.; [13] M. Morháč, J. Kliman, M. Jandel, Ľ. Krupa, V. Matoušek: Study of fitting algorithms applied to simultaneous analysis of large number of peaks in \(\gamma\)-ray spectra. Applied Spectroscopy, Vol. 57, No. 7 (2003) 753-760.; [14] C.V. Hampton, B. Lian, Wm. C. McHarris: Fast-Fourier-transform spectral enhancement techniques for gamma-ray spectroscopy. NIM A353 (1994) 280-284.; [15] D. Hearn, M. P. Baker: Computer Graphics, Prentice-Hall International, Inc., 1994. Institute of Physics, Slovak Academy of Sciences, Bratislava, Slovakia↩; Flerov Laboratory of Nuclear Reactions, JINR, Dubna, Russia↩. ",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:30909,Performance,optimiz,optimized,30909," 4.8. Original spectrum before unfolding. Contents of the responses in the original spectrum. Another example where we have used the unfolding method is the decomposition of continuum of gamma-ray spectra. Using simulation and interpolation techniques, we have synthesized the response matrix (size 3400x3400 channels) of Gammasphere spectrometer (Figure 4.9). Its details are presented in Figure 4.10. The original spectrum of Co^56 before and after continuum decomposition are presented in Figures 4.11, 4.12, respectively. Response matrix (size 3400x3400 channels) of Gammasphere spectrometer. Detail of Figure 4.9. Original spectrum of Co56 before continuum decomposition. Original spectrum of Co56 after continuum decomposition. 4.3 2-DIMENSIONAL SPECTRA; We have extended the method of Gold deconvolution also for 2-dimensional data. Again, the goal of the deconvolution methods is to improve the resolution in the spectrum and to decompose multiplets. The method of optimized 2-dimensional deconvolution is described in details in [8].; Mathematical formulation of 2-dimensional convolution system is as follows:; \[ y(i_1,i_2) = \sum_{k_1=0}^{N_1-1}\sum_{k_2=0}^{N_2-1}h(i_1-k_1,i_2-k_2)x(k_1,k_2), i_1=0,1,2,...,N_1-1, i_2=0,1,2,...,N_2-1 \]; Assuming we know the output spectrum y and the response spectrum h, the task is to calculate the matrix x.; The basic function has the form of; char *Deconvolution2(float **source,; const float **resp,; int sizex,; int sizey,; int niter);; This function calculates deconvolution from the source spectrum according to the response spectrum. The result is placed in the matrix pointed by the source pointer.; Function parameters:. source: pointer to the matrix of the source spectrum; resp: pointer to the matrix of the response spectrum; sizex: x length of source and the response spectra; sizey: y length of source and the response spectra; number_of_iterations: see [8] for details. The example of 2-dimensional spectrum before deconvolution is pr",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:36168,Performance,optimiz,optimized,36168,"hm. It allows to fit large blocks of data and large number of parameters.; The other one is based on a calculation of the system of linear equations using Stiefel-Hestens method [10]. It converges faster than the awmi algorithm, however, it is not suitable to fit large number of parameters.; 5.1 1-DIMENSIONAL SPECTRA; The quantity to be minimized in the fitting procedure for one-dimensional spectrum is defined as; \[ \chi^2 = \frac{1}{N-M}\sum_{i=1}^{N}\frac{[y_i-f(i,a)]^2}{y_i} \]; where i is the channel in the fitted spectrum, N is the number of channels in the fitting subregion, M is the number of free parameters, y_i is the content of the i-th channel, a is a vector of the parameters being fitted and f(i,a) is a fitting or peak shape function.; Instead of the weighting coefficient y_i in the denominator of the formula given above, one can use also the value of f(i,a). It is suitable for data with poor statistics [11], [12].; The third statistic to be optimized, which is implemented in the fitting functions, is the Maximum Likelihood Method. It is up to the user to select a suitable statistic.; After differentiating chi^2 we obtain the following M simultaneous equations:; \[ \sum_{i=1}^{N}; \frac{y_i-f(i,a^{(t)})}{y_i}; \frac{\partial f(i,a^t)}{\partial a_k}=; \sum_{j=1}^{M}\sum_{i=1}^{N}; \frac{\partial f(i,a^{(t)})}{\partial a_j}; \frac{\partial f(i,a^{(t)})}{\partial a_k}; \Delta a_j^{(t)} \]. in gamma-ray spectra we have to fit together tens, hundreds of peaks simultaneously that sometimes represent thousands of parameters.; the calculation of the inversion matrix of such a size is practically impossible.; the awmi method is based on the assumption that the off-diagonal terms in the matrix A are equal to zero. \[; \Delta a_{k}^{(t+1)} = \alpha^{(t)}; \frac{; \sum_{i=1}^{N} \frac{e_{i}^{(t)}}{y_i}\frac{\partial f(i,a^{(t)})}{\partial a_k}; }{; \sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}; }; \]; where the error in the c",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:37397,Performance,optimiz,optimize,37397,"\sum_{i=1}^{N}; \frac{y_i-f(i,a^{(t)})}{y_i}; \frac{\partial f(i,a^t)}{\partial a_k}=; \sum_{j=1}^{M}\sum_{i=1}^{N}; \frac{\partial f(i,a^{(t)})}{\partial a_j}; \frac{\partial f(i,a^{(t)})}{\partial a_k}; \Delta a_j^{(t)} \]. in gamma-ray spectra we have to fit together tens, hundreds of peaks simultaneously that sometimes represent thousands of parameters.; the calculation of the inversion matrix of such a size is practically impossible.; the awmi method is based on the assumption that the off-diagonal terms in the matrix A are equal to zero. \[; \Delta a_{k}^{(t+1)} = \alpha^{(t)}; \frac{; \sum_{i=1}^{N} \frac{e_{i}^{(t)}}{y_i}\frac{\partial f(i,a^{(t)})}{\partial a_k}; }{; \sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}; }; \]; where the error in the channel i is \(e_{i}^{(t)} = y_i-f(i,a^{(t)}); k=1,2,...,M\) and \(\alpha^{(t)}=1\) if the process is convergent or \(\alpha^{(t)}=0.5 \alpha^{(t-1)}\) if it is divergent. Another possibility is to optimize this coefficient.; The error of k-th parameter estimate is; \[; \Delta a_k^{(e)}=; \sqrt{\frac; {\sum_{i=1}^{N}\frac{e_i^2}{y_i}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}}; }; \]; Algorithm with higher powers w=1,2,3...:; \[; \Delta a_{k,w}^{(t+1)}=; \alpha^{(t)}; \frac; {\sum_{i=1}^{N} \frac{e_i}{y_i}\left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w-1}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w}\frac{1}{y_i}}; \]; We have implemented the non-symmetrical semi-empirical peak shape function. It contains the symmetrical Gaussian as well as non-symmetrical terms:; \[; f(i,a) =; \sum_{i=1}^{M} A(j); \left\{; exp\left[\frac{-(i-p(j))^2}{2\sigma^2}\right]; +\frac{1}{2}T.exp\left[\frac{(i-p(j))}{B\sigma}\right]; .erfc\left[\frac{(i-p(j))}{\sigma}+\frac{1}{2B}\right]; +\frac{1}{2}S.erfc\left[\frac{(i-p(j))}{\sigma}\right]; \right\}; \]; where T, S are relative amplitudes and B is a slope.; De",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:39773,Performance,optimiz,optimization,39773,"mFit *p,; int size);; This function fits the source spectrum. The calling program should fill in the input parameters of the one_dim_fit structure. The fitted parameters are written into structure pointed by one_dim_fit structure pointer and fitted data are written into source spectrum.; Function parameters:. source: pointer to the vector of the source spectrum; p: pointer to the one_dim_fit structure pointer; size: length of the source spectrum. The one_dim_fit structure has the form of; class TSpectrumOneDimFit{. public:. int number_of_peaks; // input parameter, should be >0; int number_of_iterations; // input parameter, should be >0; int xmin; // first fitted channel; int xmax; // last fitted channel; double alpha; // convergence coefficient, input parameter, it should be a positive number and <=1; double chi; // here the function returns the resulting chi-square; int statistic_type; // type of statistics, possible values are:; // FIT1_OPTIM_CHI_COUNTS (chi square statistics with counts as weighting coefficients),; // FIT1_OPTIM_CHI_FUNC_VALUES (chi square statistics with function values as weighting coefficients); // FIT1_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values are:; // FIT1_ALPHA_HALVING,; // FIT1_ALPHA_OPTIMAL; int power; // possible values FIT1_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values; // FIT1_TAYLOR_ORDER_FIRST, FIT1_TAYLOR_ORDER_SECOND. double position_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks positions, input parameters; double position_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted positions, output parameters; double position_err[MAX_NUMBER_OF_PEAKS1]; // position errors; bool fix_position[MAX_NUMBER_OF_PEAKS1]; // logical vector which allows to fix appropriate positions (not fit). However they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks amplitudes, input parameters",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:47069,Performance,optimiz,optimization,47069,"the source spectrum; p: pointer to the two_dim_fit structure pointer, see manual; sizex: length x of the source spectrum; sizey: length y of the source spectrum. The two_dim_fit structure has the form of; class TSpectrumTwoDimFit{. public:. int number_of_peaks; // input parameter, should be>0; int number_of_iterations; // input parameter, should be >0; int xmin; // first fitted channel in x direction; int xmax; // last fitted channel in x direction; int ymin; // first fitted channel in y direction; int ymax; // last fitted channel in y direction; double alpha; // convergence coefficient, input parameter, it should be a positive number and <=1; double chi; // here the function returns resulting chi square; int statistic_type; // type of statistics, possible values are:; // FIT2_OPTIM_CHI_COUNTS (chi square statistics with counts as weighting coefficients),; // FIT2_OPTIM_CHI_FUNC_VALUES (chi square statistics with function values as weighting coefficients),; // FIT2_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values are:; // FIT2_ALPHA_HALVING, FIT2_ALPHA_OPTIMAL; int power; // possible values are: FIT21_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values are:; // FIT2_TAYLOR_ORDER_FIRST,; // FIT2_TAYLOR_ORDER_SECOND; double position_init_x[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 2D peaks, input parameters; double position_calc_x[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 2D peaks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate x positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitt",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:4689,Testability,log,logical,4689,"on edges and decreasing clipping window. In the lower part of the Figure we present the background, which was added to the synthetic spectrum. One can observe good coincidence with the estimated background. The method of the estimation of Compton edge is described in details in [3]. Synthetic spectrum with Compton edges. The generalized form of the algorithm is implemented in the following function.; char *Background1General(float *spectrum,; int size,; int number_of_iterations,; int direction,; int filter_order,; bool compton);; The meaning of the parameters is as follows:. spectrum: pointer to the vector of the source spectrum; size: length of spectrum vector; number_of_iterations: maximal width of clipping window; direction: direction of change of clipping window. Possible values:. BACK1_INCREASING_WINDOW; BACK1_DECREASING_WINDOW. filter_order: order of clipping filter. Possible values:. BACK1_ORDER2; BACK1_ORDER4; BACK1_ORDER6; BACK1_ORDER8. compton: logical variable whether the estimation of Compton edge will be included. Possible values:. BACK1_EXCLUDE_COMPTON; BACK1_INCLUDE_COMPTON. 1.2 2-DIMENSIONAL SPECTRA; This basic background estimation function allows to separate useless spectrum information (2D-continuous background and coincidences of peaks with background in both dimensions) from peaks. It calculates background spectrum from the source spectrum. The result is placed in the array pointed by spectrum pointer. On successful completion it returns 0. On error it returns a pointer to the string describing error.; char *Background2(float **spectrum,; int sizex,; int sizey,; int number_of_iterations);; Function parameters:. spectrum: pointer to the array of the source spectrum; sizex: x length of spectrum; sizey: y length of spectrum; number_of_iterations: width of the clipping window. In Figure 1.6 we present an example of a 2-dimensional spectrum before background elimination. 2-dimensional spectrum before background elimination. Estimated background is sho",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:18952,Testability,log,logical,18952,"uppressed, the spectrum is smoother than the original one. On the other hand it emphasizes peaks (depending on the averaging window). The example of the part of original noisy spectrum and Markov spectrum for window=3 is given in Figure 3.5 Then the peaks can be found in Markov spectrum using standard above-presented algorithm. Part of original noisy spectrum and Markov spectrum for window=3. The form of the generalized peak searching function is as follows:; Int_t Search1General(float *spectrum,; int size,; float sigma,; int threshold,; bool markov,; int aver_window);; This function searches for peaks in the source spectrum. The number of found peaks and their positions are written into the structure pointed by the one_dim_peak structure pointer.; Function parameters:. spectrum: pointer to the vector of the source spectrum. This source spectrum is replaced by the new spectrum calculated using Markov chains method.; size: length of the source spectrum; sigma: sigma of searched peaks; threshold: threshold value for peaks selection; markov: logical variable. If it is set to true, then the source spectrum is first replaced by the new spectrum calculated using Markov chains method; aver_window: averaging window used in the calculation of Markov spectrum, applies only if the markov variable was set to true. The methods of peak searching are sensitive to the sigma. Usually the sigma value is known beforehand. It also changes only slightly with the energy. We have investigated as well the robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10 (see Figure 3.6). Robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10. We applied peak searching algorithm based on Markov approach. We changed sigma in the interval from 1 to 10. The spectra for averaging windows 3, 5, 10 are shown in Figure 3.7. Spectra for averaging windows 3, 5, 10. When we applied peak searching function to the Markov",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:21848,Testability,log,logical,21848,"ture pointed by two_dim_peak structure pointer.; Function parameters:. source: pointer to the vector of the source spectrum; sizex: x length of the source spectrum; sizey: y length of the source spectrum; sigma: sigma of searched peaks. An example of the two-dimensional spectrum with the identified peaks is shown in Figure 3.8. Two-dimensional spectrum with the identified peaks. We have also generalized the peak searching function similarly to one-dimensional data. The generalized peak searching function for two-dimensional spectra has the form of; Int_t Search2General(float **source,; int sizex,; int sizey,; double sigma,; int threshold,; bool markov,; int aver_window);; This function searches for peaks in the source spectrum. The number of found peaks and their positions are written into the structure pointed by two_dim_peak structure pointer.; Function parameters:. source: pointer to the vector of the source spectrum; sizex: x length of the source spectrum; sizey: y length of the source spectrum; sigma: sigma of searched peaks; threshold: threshold value for peaks selection; markov: logical variable. If it is set to true, then the source spectrum is first replaced by the new spectrum calculated using Markov chains method; aver_window averaging window of searched peaks (applies only for the Markov method). An example of experimental 2-dimensional spectrum is given in Figure 3.9. The number of peaks identified by the function now is 295. Experimental 2-dimensional spectrum. The function works even for very noisy data. In Figure 3.10 we present synthetic 2-dimensional spectrum with 5 peaks. The method should recognize what is the real 2-dimensional peak and what is the crossing of two 1-dimensional ridges. The Markov spectrum with averaging window=3 is given in Figure 3.11. One can observe that this spectrum is smoother than the original one. After applying the general peak searching function to the Markov spectrum with sigma=2 and threshold=600, we get correctly id",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:40372,Testability,log,logical,40372,"t fitted channel; int xmax; // last fitted channel; double alpha; // convergence coefficient, input parameter, it should be a positive number and <=1; double chi; // here the function returns the resulting chi-square; int statistic_type; // type of statistics, possible values are:; // FIT1_OPTIM_CHI_COUNTS (chi square statistics with counts as weighting coefficients),; // FIT1_OPTIM_CHI_FUNC_VALUES (chi square statistics with function values as weighting coefficients); // FIT1_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values are:; // FIT1_ALPHA_HALVING,; // FIT1_ALPHA_OPTIMAL; int power; // possible values FIT1_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values; // FIT1_TAYLOR_ORDER_FIRST, FIT1_TAYLOR_ORDER_SECOND. double position_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks positions, input parameters; double position_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted positions, output parameters; double position_err[MAX_NUMBER_OF_PEAKS1]; // position errors; bool fix_position[MAX_NUMBER_OF_PEAKS1]; // logical vector which allows to fix appropriate positions (not fit). However they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted amplitudes, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS1]; // amplitude errors; bool fix_amp[MAX_NUMBER_OF_PEAKS1]i; // logical vector, which allows to fix appropriate amplitudes (not fit). However they are present in the estimated functional; double area[MAX_NUMBER_OF_PEAKS1]; // calculated areas of peaks; double area_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak areas; double sigma_init; // sigma parameter, see peak shape function; double sigma_calc;; double sigma_err;; bool fix_sigma;; double t_init // t parameter, see peak shape function; double t_calc;; double t_err;; ",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:40790,Testability,log,logical,40790,"S (chi square statistics with function values as weighting coefficients); // FIT1_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values are:; // FIT1_ALPHA_HALVING,; // FIT1_ALPHA_OPTIMAL; int power; // possible values FIT1_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values; // FIT1_TAYLOR_ORDER_FIRST, FIT1_TAYLOR_ORDER_SECOND. double position_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks positions, input parameters; double position_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted positions, output parameters; double position_err[MAX_NUMBER_OF_PEAKS1]; // position errors; bool fix_position[MAX_NUMBER_OF_PEAKS1]; // logical vector which allows to fix appropriate positions (not fit). However they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted amplitudes, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS1]; // amplitude errors; bool fix_amp[MAX_NUMBER_OF_PEAKS1]i; // logical vector, which allows to fix appropriate amplitudes (not fit). However they are present in the estimated functional; double area[MAX_NUMBER_OF_PEAKS1]; // calculated areas of peaks; double area_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak areas; double sigma_init; // sigma parameter, see peak shape function; double sigma_calc;; double sigma_err;; bool fix_sigma;; double t_init // t parameter, see peak shape function; double t_calc;; double t_err;; bool fix_t;; double b_init // b parameter, see peak shape function; double b_calc;; double b_err;; bool fix_b;; double s_init; // s parameter, see peak shape function; double s_calc;; double s_err;; bool fix_s;; double a0_init; // background is estimated as a0+a1*x+a2*x*x; double a0_calc;; double a0_err;; bool fix_a0;; double a1_init;; double a1_calc;; double a1_err;; bool fix_a1;; double a2_init;",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:47723,Testability,log,logical,47723,"the source spectrum; p: pointer to the two_dim_fit structure pointer, see manual; sizex: length x of the source spectrum; sizey: length y of the source spectrum. The two_dim_fit structure has the form of; class TSpectrumTwoDimFit{. public:. int number_of_peaks; // input parameter, should be>0; int number_of_iterations; // input parameter, should be >0; int xmin; // first fitted channel in x direction; int xmax; // last fitted channel in x direction; int ymin; // first fitted channel in y direction; int ymax; // last fitted channel in y direction; double alpha; // convergence coefficient, input parameter, it should be a positive number and <=1; double chi; // here the function returns resulting chi square; int statistic_type; // type of statistics, possible values are:; // FIT2_OPTIM_CHI_COUNTS (chi square statistics with counts as weighting coefficients),; // FIT2_OPTIM_CHI_FUNC_VALUES (chi square statistics with function values as weighting coefficients),; // FIT2_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values are:; // FIT2_ALPHA_HALVING, FIT2_ALPHA_OPTIMAL; int power; // possible values are: FIT21_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values are:; // FIT2_TAYLOR_ORDER_FIRST,; // FIT2_TAYLOR_ORDER_SECOND; double position_init_x[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 2D peaks, input parameters; double position_calc_x[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 2D peaks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate x positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitt",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:48220,Testability,log,logical,48220,"ha_optim; // optimization of convergence coefficients, possible values are:; // FIT2_ALPHA_HALVING, FIT2_ALPHA_OPTIMAL; int power; // possible values are: FIT21_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values are:; // FIT2_TAYLOR_ORDER_FIRST,; // FIT2_TAYLOR_ORDER_SECOND; double position_init_x[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 2D peaks, input parameters; double position_calc_x[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 2D peaks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate x positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y positions of 2D peaks, output parameters; double position_err_y[MAX_NUMBER_OF_PEAKS2]; // y position errors of 2D peaks; bool fix_position_y[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 1D ridges, input parameters; double position_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate x positions of 1D ridges (not fit). However, they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y pos",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:48724,Testability,log,logical,48724," positions of 2D peaks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate x positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y positions of 2D peaks, output parameters; double position_err_y[MAX_NUMBER_OF_PEAKS2]; // y position errors of 2D peaks; bool fix_position_y[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 1D ridges, input parameters; double position_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate x positions of 1D ridges (not fit). However, they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 2D pea",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:49225,Testability,log,logical,49225,"ions of 2D peaks, output parameters; double position_err_y[MAX_NUMBER_OF_PEAKS2]; // y position errors of 2D peaks; bool fix_position_y[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 1D ridges, input parameters; double position_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate x positions of 1D ridges (not fit). However, they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 2D peaks, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 2D peaks; bool fix_amp[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate amplitudes of 2D peaks (not fit). However, they are present in the estimated functional; double amp_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:49689,Testability,log,logical,49689," of fitted x positions of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate x positions of 1D ridges (not fit). However, they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 2D peaks, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 2D peaks; bool fix_amp[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate amplitudes of 2D peaks (not fit). However, they are present in the estimated functional; double amp_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_x1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_y1",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:50162,Testability,log,logical,50162,"_OF_PEAKS2]; // calculated values of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 2D peaks, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 2D peaks; bool fix_amp[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate amplitudes of 2D peaks (not fit). However, they are present in the estimated functional; double amp_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_x1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_y1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double volume[MAX_NUMBER_OF_PEAKS1]; // calculated volumes of peaks; double volume_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak volumes; double sigma_init_x; // sigma x parameter; double sigma_calc_x;; double sigma_err_x;; bool",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:50640,Testability,log,logical,50640,"NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 2D peaks, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 2D peaks; bool fix_amp[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate amplitudes of 2D peaks (not fit). However, they are present in the estimated functional; double amp_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_x1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_y1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double volume[MAX_NUMBER_OF_PEAKS1]; // calculated volumes of peaks; double volume_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak volumes; double sigma_init_x; // sigma x parameter; double sigma_calc_x;; double sigma_err_x;; bool fix_sigma_x;; double sigma_init_y; // sigma y parameter; double sigma_calc_y;; double sigma_err_y;; bool fix_sigma_y;; double ro_init; // correlation coefficient; double ro_calc;; double ro_err;; bool fix_ro;; double txy_init; // t parameter for 2D peaks; double txy_calc;; double txy_err;; bool fix_txy;; double sxy_init; // s parameter for 2D peaks; double sxy_calc;; double sxy_err;; bool fix_sxy;; double tx_init; // t parameter for 1D ridges (x direction); double tx_calc;",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:67963,Testability,log,log,67963,"rs is apparent from description of one_dim_pic structure. The constants, which can be used for appropriate parameters, are defined in procfunc.h header file.; struct one_dim_pic {. float *source; // spectrum to be displayed. TCanvas *Canvas; // Canvas where the spectrum will be displayed. int size; // size of source spectrum; int xmin; // x-starting channel of spectrum; int xmax; // x-end channel of spectrum; int ymin; // base counts; int ymax; // count full scale. int bx1; // position of picture on Canvas, min x; int bx2; // position of picture on Canvas, max x; int by1; // position of picture on Canvas, min y; int by2; // position of picture on Canvas, max y. int display_mode; // spectrum display mode (points, polyline, bars, rainbow, steps, bezier); int y_scale; // y scale (linear, log, sqrt); int levels; // # of color levels for rainbow display mode, it does not apply; // for other display modes; float rainbow1_step; // determines the first color component step for neighboring; // color levels, applies only for rainbow display mode; float rainbow2_step; // determines the second component color step for; // neighboring color levels, applies only for rainbow display mode; float rainbow3_step; // determines the third component color step for; // neighboring color levels, applies only for rainbow display mode. int color_alg; // applies only for rainbow display mode (rgb smooth algorithm, rgb; // modulo color component, cmy smooth algorithm, cmy modulo color; // component, cie smooth algorithm, cie modulo color component, yiq; // smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component [15]. int bar_thickness; // applies only for bar display mode; int bar_empty_flag; // (empty bars, full bars) applies only for bar display mode; int border_color; // color of background of the picture; int full_border; // decides whether background is painted; int raster_en_dis; // decides whether the axes and rasters are shown; int raster_long",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:70122,Testability,log,log,70122,"es and rasters are shown; int raster_long; // decides whether the rasters are drawn as long lines; int raster_color; // color of the rasters; char *raster_description_x; // x axis description; char *raster_description_y; // y axis description. int pen_color; // color of spectrum; int pen_dash; // style of pen; int pen_width; // width of line. int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_color; // color of channel marks. // auxiliary variables, transform coefficients, for internal use only; double mx;; double my;; double px;; double py;. // auxiliary internal variables, working place; double gbezx,gbezy;; TPoint bz[4];; };; The examples using different display parameters are shown in the next few Figures. Display mode -polyline, width of pen=3. Display mode- bars, shown channel marks. Display mode- steps, log scale, shown channel marks. Display mode -Bezier curve interpolation, shown channel marks. Display mode- rainbow bars, color algorithm (model) RGB, number of color levels=1024, pen width=3. Display mode-empty bars, color algorithm YIQ, number of color levels 2048. 7.2 2-DIMENSIONAL SPECTRA; The 2-dimensional visualization function displays spectrum (or its part) on the Canvas of a form. Before calling the function, one has to fill in the two_dim_pic structure containing all parameters of the display. The function has a form of; char *display2(struct two_dim_pic* p);; This function displays the source two-dimensional spectrum on Canvas. All parameters are grouped in the two_dim_pic structure. Before calling the display2 function, the structure should be filled in and the address of two_dim_pic should be passed as a parameter to display2 function. The meaning of corresponding parameters is apparent from the description of one_dim_pic structure. The constants, which can be used for appropr",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:72379,Testability,log,log,72379," y-size of source spectrum; int xmin; // x-starting channel of spectrum; int xmax; // x-end channel of spectrum; int ymin; // y-starting channel of spectrum; int ymax; // y-end channel of spectrum; int zmin; // base counts; int zmax; // counts full scale; int bx1; // position of picture on Canvas, min x; int bx2; // position of picture on Canvas, max x; int by1; // position of picture on Canvas, min y; int by2; // position of picture on Canvas, max y; int mode_group; // display mode algorithm group (simple modes-; // PICTURE2_MODE_GROUP_SIMPLE, modes with shading; // according to light-PICTURE2_MODE_GROUP_LIGHT, modes with; // shading according to channels counts-; // PICTURE2_MODE_GROUP_HEIGHT, modes of combination of; // shading according to light and to channels counts-; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT); int display_mode; // spectrum display mode (points, grid, contours, bars, x_lines,; // y_lines, bars_x, bars_y, needles, surface, triangles); int z_scale; // z scale (linear, log, sqrt); int nodesx; // number of nodes in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:76569,Testability,log,log,76569,"idth of line; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_color; // color of channel marks; int chanline_en_dis; // decides whether the channel lines (grid) are shown. // auxiliary variables, transformation coefficients for internal use only; double kx;; double ky;; double mxx;; double mxy;; double myx;; double myy;; double txx;; double txy;; double tyx;; double tyy;; double tyz;; double vx;; double vy;; double nu_sli;. // auxiliary internal variables, working place; double z,zeq,gbezx,gbezy,dxspline,dyspline;; int xt,yt,xs,ys,xe,ye,priamka,z_preset_value;; unsigned short obal[MAXIMUM_XSCREEN_RESOLUTION];; unsigned short obal_cont[MAXIMUM_XSCREEN_RESOLUTION];; TPoint bz[4];; };; The examples using different display parameters are shown in the next few Figures. Display mode-bars, pen width=2. Display mode-triangles, log scale. Display mode-contours. Display mode surface shading according to height. Display mode-surface shading according to light point. Display mode-surface shading according to height+light position with ratio 50:50, CMY color model. Display mode bars shaded according to height. Display mode- surface shading according to light position with shadows. Display mode- surface shading according to height with 10 levels of contours. Display mode- surface shading according to height, sqrt scale, channel marks and lines shown. Display mode- surface shading according to height-contours, rasters allowing to localize interesting parts are shown. 8 References; [1] M. Morháč, J. Kliman, V. Matoušek, M. Veselský, I. Turzo.: Background elimination methods for multidimensional gamma-ray spectra. NIM, A401 (1997) 113-132.; [2] C. G Ryan et al.: SNIP, a statistics-sensitive background treatment for the quantitative analysis of PIXE spectra in geoscience applications. NIM, B34 (1988), 396-402.;",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:16817,Usability,simpl,simple,16817," in [4], [5]. It allows to automatically identify the peaks in a spectrum with the presence of the continuous background and statistical fluctuations – noise. The algorithm is based on smoothed second differences that are compared to its standard deviations. Therefore it is necessary to pass a parameter of sigma to the peak searching function. The algorithm is selective to the peaks with a given sigma. The form of the basic peak searching function is; Int_t Search1(const float *spectrum,; int size,; double sigma);; This function searches for peaks in the source spectrum. The number of found peaks and their positions are written into structure pointed by one_dim_peak structure pointer.; Function parameters:. source: pointer to the vector of the source spectrum; p: pointer to the one_dim_peak structure pointer; size: length of the source spectrum; sigma: sigma of searched peaks. The one_dim_peak structure has the form of; struct one_dim_peak{; int number_of_peaks;; double position[MAX_NUMBER_OF_PEAKS1];; };; An example of simple one-dimensional spectrum with identified peaks is given in Figure 3.1. Simple one-dimensional spectrum with identified peaks. An example of 1-dimensional experimental spectrum with many identified peaks is given in Figure 3.2. 1-dimensional experimental spectrum with many identified peaks. However, when we have noisy data, the number of peaks can be enormous. One such an example is given in Figure 3.3. With noisy data the number of peaks can be enormous. Therefore it can be useful to have a possibility to set a threshold value and to consider only the peaks higher than this threshold (see Figure 3.4, only three peaks were identified, threshold=50). The value in the center of the peak (value[i]) minus the average value in two symmetrically positioned channels (channels i-3*sigma, i+3*sigma) must be greater than threshold. Otherwise the peak is ignored. Iwth threshold=50, only three peaks were identified. An alternative approach was proposed in ",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:41729,Usability,simpl,simple,41729,"errors; bool fix_position[MAX_NUMBER_OF_PEAKS1]; // logical vector which allows to fix appropriate positions (not fit). However they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted amplitudes, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS1]; // amplitude errors; bool fix_amp[MAX_NUMBER_OF_PEAKS1]i; // logical vector, which allows to fix appropriate amplitudes (not fit). However they are present in the estimated functional; double area[MAX_NUMBER_OF_PEAKS1]; // calculated areas of peaks; double area_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak areas; double sigma_init; // sigma parameter, see peak shape function; double sigma_calc;; double sigma_err;; bool fix_sigma;; double t_init // t parameter, see peak shape function; double t_calc;; double t_err;; bool fix_t;; double b_init // b parameter, see peak shape function; double b_calc;; double b_err;; bool fix_b;; double s_init; // s parameter, see peak shape function; double s_calc;; double s_err;; bool fix_s;; double a0_init; // background is estimated as a0+a1*x+a2*x*x; double a0_calc;; double a0_err;; bool fix_a0;; double a1_init;; double a1_calc;; double a1_err;; bool fix_a1;; double a2_init;; double a2_calc;; double a2_err;; bool fix_a2;; };; As an example we present a simple 1-dimensional synthetic spectrum with 5 peaks. The fit (obtained using above-given awmi fitting function) is given in Figure 5.1. The chi-square achieved in this fit was 0.76873. The input value of the fit (positions of peaks and their amplitudes) were estimated using peak searching function. Fit obtained using above given awmi fitting function. Let us go to a more complicated fit with a lot of overlapping peaks as in Figure 5.2. The initial positions of peaks were determined from original data, using peak searching function. The fit is not very good, as there are some peaks mis",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:71886,Usability,simpl,simple,71886,,MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:73014,Usability,simpl,simple,73014,"hading according to channels counts-; // PICTURE2_MODE_GROUP_HEIGHT, modes of combination of; // shading according to light and to channels counts-; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT); int display_mode; // spectrum display mode (points, grid, contours, bars, x_lines,; // y_lines, bars_x, bars_y, needles, surface, triangles); int z_scale; // z scale (linear, log, sqrt); int nodesx; // number of nodes in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // displa",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:73214,Usability,simpl,simple,73214,"ode; // spectrum display mode (points, grid, contours, bars, x_lines,; // y_lines, bars_x, bars_y, needles, surface, triangles); int z_scale; // z scale (linear, log, sqrt); int nodesx; // number of nodes in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT ",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:73415,Usability,simpl,simple,73415,"des in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT modes group; int xlight; // x position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int ylight; // y position of fictive light source, applies ",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:73615,Usability,simpl,simple,73615,"+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT modes group; int xlight; // x position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int ylight; // y position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int zlight; // z position of fictive light source, applies only for rainbowed display; // modes with shading according to light; i",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:74001,Usability,simpl,simple,74001,"y for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT modes group; int xlight; // x position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int ylight; // y position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int zlight; // z position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int shadow; // determines whether shadow will be drawn (no shadow, shadow),; // for rainbowed display modes with shading according to light; int shading; // determines whether the picture will shaded, smoothed (no shading,; // shading), for rainbowed display modes only; int bezier; // determines Bezier interpolation (applies only for simple display; // modes group for grid, x_lines, y",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:74954,Usability,simpl,simple,74954,"color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT modes group; int xlight; // x position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int ylight; // y position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int zlight; // z position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int shadow; // determines whether shadow will be drawn (no shadow, shadow),; // for rainbowed display modes with shading according to light; int shading; // determines whether the picture will shaded, smoothed (no shading,; // shading), for rainbowed display modes only; int bezier; // determines Bezier interpolation (applies only for simple display; // modes group for grid, x_lines, y_lines display modes); int border_color; // color of background of the picture; int full_border; // decides whether background is painted; int raster_en_dis; // decides whether the rasters are shown; int raster_long; // decides whether the rasters are drawn as long lines; int raster_color; // color of the rasters; char *raster_description_x; // x axis description; char *raster_description_y; // y axis description; char *raster_description_z; // z axis description; int pen_color; // color of spectrum; int pen_dash; // style of pen; int pen_width; // width of line; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_color; // color of channel marks; int chanline_en_dis; // decides whether the channel lines (grid) are shown.",MatchSource.WIKI,root/htmldoc/guides/spectrum/Spectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:3362,Availability,mainten,maintenance,3362,"cal and financial industries, many people are using ROOT. We estimate the current user base to be around several thousand people. In 1997, Eric Raymond analysed in his paper “The Cathedral and the Bazaar” the development method that makes Linux such a success. The essence of that method is: “release early, release often and listen to your customers”. This is precisely how ROOT is being developed. Over the last five years, many of our “customers” became co-developers. Here we would like to thank our main co-developers and contributors:; Masaharu Goto wrote the C++ interpreter CINT that was an essential part of ROOT before ROOT 6. Despite being 8 time zones ahead of us, we have the feeling he has been sitting in the room next door since 1995.; Andrei and Mihaela Gheata (Alice collaboration) are co-authors of the ROOT geometry classes and Virtual Monte-Carlo. They have been working with the ROOT team since 2000.; Olivier Couet, who after a successful development and maintenance of PAW, has joined the ROOT team in 2000 and has been working on the graphics sub-system.; Ilka Antcheva has been working on the Graphical User Interface classes. She is also responsible for this latest edition of the Users Guide with a better style, improved index and several new chapters (since 2002).; Bertrand Bellenot has been developing and maintaining the Win32GDK version of ROOT. Bertrand has also many other contributions like the nice RootShower example (since 2001).; Valeriy Onoutchin has been working on several ROOT packages, in particular the graphics sub-system for Windows and the GUI Builder (since 2000).; Gerri Ganis has been working on the authentication procedures to be used by the root daemons and the PROOF system (since 2002).; Maarten Ballintijn (MIT) is one of the main developers of the PROOF sub-system (since 1995).; Valeri Fine (now at BNL) ported ROOT to Windows and contributed largely to the 3-D graphics. He is currently working on the Qt layer of ROOT (since 1995).; Victo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:13108,Availability,reliab,reliable,13108,"thm provided by your telephone service. You also have to learn the framework interfaces, which in this analogy is the same as learning how to use a telephone.; If you are interested in doing physics, a good HEP framework will save you much work. Next is a list of the more commonly used components of ROOT: Command Line Interpreter, Histograms and Fitting, Writing a Graphical User Interface, 2D Graphics, Input/Output , Collection Classes, Script Processor.; There are also less commonly used components, as: 3D Graphics, Parallel Processing (PROOF), Run Time Type Identification (RTTI), Socket and Network Communication, Threads.; 1.4.1.1 Advantages of Frameworks; The benefits of frameworks can be summarized as follows:. Less code to write - the programmer should be able to use and reuse the majority of the existing code. Basic functionality, such as fitting and histogramming are implemented and ready to use and customize.; More reliable and robust code - the code inherited from a framework has already been tested and integrated with the rest of the framework.; More consistent and modular code - the code reuse provides consistency and common capabilities between programs, no matter who writes them. Frameworks make it easier to break programs into smaller pieces.; More focus on areas of expertise - users can concentrate on their particular problem domain. They do not have to be experts at writing user interfaces, graphics, or networking to use the frameworks that provide those services. 1.4.2 Why Object-Oriented?; Object-Oriented Programming offers considerable benefits compared to Procedure-Oriented Programming:. Encapsulation enforces data abstraction and increases opportunity for reuse.; Sub classing and inheritance make it possible to extend and modify objects.; Class hierarchies and containment containment hierarchies provide a flexible mechanism for modeling real-world objects and the relationships among them.; Complexity is reduced because there is little growth of ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:13121,Availability,robust,robust,13121,"thm provided by your telephone service. You also have to learn the framework interfaces, which in this analogy is the same as learning how to use a telephone.; If you are interested in doing physics, a good HEP framework will save you much work. Next is a list of the more commonly used components of ROOT: Command Line Interpreter, Histograms and Fitting, Writing a Graphical User Interface, 2D Graphics, Input/Output , Collection Classes, Script Processor.; There are also less commonly used components, as: 3D Graphics, Parallel Processing (PROOF), Run Time Type Identification (RTTI), Socket and Network Communication, Threads.; 1.4.1.1 Advantages of Frameworks; The benefits of frameworks can be summarized as follows:. Less code to write - the programmer should be able to use and reuse the majority of the existing code. Basic functionality, such as fitting and histogramming are implemented and ready to use and customize.; More reliable and robust code - the code inherited from a framework has already been tested and integrated with the rest of the framework.; More consistent and modular code - the code reuse provides consistency and common capabilities between programs, no matter who writes them. Frameworks make it easier to break programs into smaller pieces.; More focus on areas of expertise - users can concentrate on their particular problem domain. They do not have to be experts at writing user interfaces, graphics, or networking to use the frameworks that provide those services. 1.4.2 Why Object-Oriented?; Object-Oriented Programming offers considerable benefits compared to Procedure-Oriented Programming:. Encapsulation enforces data abstraction and increases opportunity for reuse.; Sub classing and inheritance make it possible to extend and modify objects.; Class hierarchies and containment containment hierarchies provide a flexible mechanism for modeling real-world objects and the relationships among them.; Complexity is reduced because there is little growth of ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:14502,Availability,down,download,14502,"trate on their particular problem domain. They do not have to be experts at writing user interfaces, graphics, or networking to use the frameworks that provide those services. 1.4.2 Why Object-Oriented?; Object-Oriented Programming offers considerable benefits compared to Procedure-Oriented Programming:. Encapsulation enforces data abstraction and increases opportunity for reuse.; Sub classing and inheritance make it possible to extend and modify objects.; Class hierarchies and containment containment hierarchies provide a flexible mechanism for modeling real-world objects and the relationships among them.; Complexity is reduced because there is little growth of the global state, the state is contained within each object, rather than scattered through the program in the form of global variables.; Objects may come and go, but the basic structure of the program remains relatively static, increases opportunity for reuse of design. 1.5 Installing ROOT. To install ROOT you have the choice to download the binaries or the source. The source is quicker to transfer since it is only ~22 MB, but you will need to compile and link it. The binaries compiled with no debug information range from ~35 MB to ~45 MB depending on the target platform.; The installation and building of ROOT is described in Appendix A: Install and Build ROOT. You can download the binaries, or the source. The GNU g++ compiler on most UNIX platforms can compile ROOT.; Before downloading a binary version make sure your machine contains the right run-time environment. In most cases it is not possible to run a version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is installed. In such cases you’ll have to install ROOT from source.; ROOT is currently running on the following platforms: supported platforms. GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc, Portland/PGCC,KAI/KCC); Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC); FreeBSD and OpenBSD (GCC); GNU/Hurd (GCC); HP HP-UX 10.",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:14849,Availability,down,download,14849,"ortunity for reuse.; Sub classing and inheritance make it possible to extend and modify objects.; Class hierarchies and containment containment hierarchies provide a flexible mechanism for modeling real-world objects and the relationships among them.; Complexity is reduced because there is little growth of the global state, the state is contained within each object, rather than scattered through the program in the form of global variables.; Objects may come and go, but the basic structure of the program remains relatively static, increases opportunity for reuse of design. 1.5 Installing ROOT. To install ROOT you have the choice to download the binaries or the source. The source is quicker to transfer since it is only ~22 MB, but you will need to compile and link it. The binaries compiled with no debug information range from ~35 MB to ~45 MB depending on the target platform.; The installation and building of ROOT is described in Appendix A: Install and Build ROOT. You can download the binaries, or the source. The GNU g++ compiler on most UNIX platforms can compile ROOT.; Before downloading a binary version make sure your machine contains the right run-time environment. In most cases it is not possible to run a version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is installed. In such cases you’ll have to install ROOT from source.; ROOT is currently running on the following platforms: supported platforms. GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc, Portland/PGCC,KAI/KCC); Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC); FreeBSD and OpenBSD (GCC); GNU/Hurd (GCC); HP HP-UX 10.x (IA32) and 11 (IA64) (HP CC, aCC, GCC); IBM AIX 4.1 (xlC compiler, GCC); Sun Solaris for SPARC (SUN C++ compiler, GCC); Sun Solaris for x86 (SUN C++ compiler, KAI/KCC); Compaq Alpha (GCC, KAI/KCC, DEC/CXX); SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler); Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC); MacOS X PPC, x86-32, x86-64 (GCC, Int",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:14957,Availability,down,downloading,14957,"tainment hierarchies provide a flexible mechanism for modeling real-world objects and the relationships among them.; Complexity is reduced because there is little growth of the global state, the state is contained within each object, rather than scattered through the program in the form of global variables.; Objects may come and go, but the basic structure of the program remains relatively static, increases opportunity for reuse of design. 1.5 Installing ROOT. To install ROOT you have the choice to download the binaries or the source. The source is quicker to transfer since it is only ~22 MB, but you will need to compile and link it. The binaries compiled with no debug information range from ~35 MB to ~45 MB depending on the target platform.; The installation and building of ROOT is described in Appendix A: Install and Build ROOT. You can download the binaries, or the source. The GNU g++ compiler on most UNIX platforms can compile ROOT.; Before downloading a binary version make sure your machine contains the right run-time environment. In most cases it is not possible to run a version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is installed. In such cases you’ll have to install ROOT from source.; ROOT is currently running on the following platforms: supported platforms. GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc, Portland/PGCC,KAI/KCC); Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC); FreeBSD and OpenBSD (GCC); GNU/Hurd (GCC); HP HP-UX 10.x (IA32) and 11 (IA64) (HP CC, aCC, GCC); IBM AIX 4.1 (xlC compiler, GCC); Sun Solaris for SPARC (SUN C++ compiler, GCC); Sun Solaris for x86 (SUN C++ compiler, KAI/KCC); Compaq Alpha (GCC, KAI/KCC, DEC/CXX); SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler); Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC); MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl); PowerPC with GNU/Linux and GCC, Debian v2; PowerPC64 with GNU/Linux and GCC; ARM with GNU/Linux and GCC; LynxOS. 1.6 Th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:16524,Availability,echo,echo,16524," compiler, GCC); Sun Solaris for x86 (SUN C++ compiler, KAI/KCC); Compaq Alpha (GCC, KAI/KCC, DEC/CXX); SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler); Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC); MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl); PowerPC with GNU/Linux and GCC, Debian v2; PowerPC64 with GNU/Linux and GCC; ARM with GNU/Linux and GCC; LynxOS. 1.6 The Organization of the ROOT Framework; Now after we know in abstract terms what the ROOT framework is, let us look at the physical directories and files that come with the ROOT installation. You may work on a platform where your system administrator has already installed ROOT. You will need to follow the specific development environment for your setup and you may not have write access to the directories. In any case, you will need an environment variable called ROOTSYS, which holds the path of the top ROOT directory.; > echo $ROOTSYS; /opt/root; In the ROOTSYS directory are examples, executables, tutorials, header tutorials files, and, if you opted to download it, the source is here. The directories of special interest to us are bin, tutorials, lib, test, andinclude. The next figure shows the contents of these directories. ROOT framework directories. 1.6.1 $ROOTSYS/bin; The bin directory contains several executables. root; shows the ROOT splash screen and calls root.exe. root.exe; the executable that root calls, if you use a debugger such as gdb, you will need to run root.exe directly. rootcling; is the utility ROOT uses to create a class dictionary for Cling. rmkdepend; a modified version of makedepend that is used by the ROOT build system. root-config; a script returning the needed compile flags and libraries for projects that compile and link with ROOT. proofd; a small daemon used to authenticate a user of ROOT parallel processing capability (PROOF). proofserv; the actual PROOF process, which is started by proofd after a user, has successfully been authenticated. rootd; is the ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:16658,Availability,down,download,16658," compiler, GCC); Sun Solaris for x86 (SUN C++ compiler, KAI/KCC); Compaq Alpha (GCC, KAI/KCC, DEC/CXX); SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler); Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC); MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl); PowerPC with GNU/Linux and GCC, Debian v2; PowerPC64 with GNU/Linux and GCC; ARM with GNU/Linux and GCC; LynxOS. 1.6 The Organization of the ROOT Framework; Now after we know in abstract terms what the ROOT framework is, let us look at the physical directories and files that come with the ROOT installation. You may work on a platform where your system administrator has already installed ROOT. You will need to follow the specific development environment for your setup and you may not have write access to the directories. In any case, you will need an environment variable called ROOTSYS, which holds the path of the top ROOT directory.; > echo $ROOTSYS; /opt/root; In the ROOTSYS directory are examples, executables, tutorials, header tutorials files, and, if you opted to download it, the source is here. The directories of special interest to us are bin, tutorials, lib, test, andinclude. The next figure shows the contents of these directories. ROOT framework directories. 1.6.1 $ROOTSYS/bin; The bin directory contains several executables. root; shows the ROOT splash screen and calls root.exe. root.exe; the executable that root calls, if you use a debugger such as gdb, you will need to run root.exe directly. rootcling; is the utility ROOT uses to create a class dictionary for Cling. rmkdepend; a modified version of makedepend that is used by the ROOT build system. root-config; a script returning the needed compile flags and libraries for projects that compile and link with ROOT. proofd; a small daemon used to authenticate a user of ROOT parallel processing capability (PROOF). proofserv; the actual PROOF process, which is started by proofd after a user, has successfully been authenticated. rootd; is the ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:17858,Availability,avail,available,17858,"The next figure shows the contents of these directories. ROOT framework directories. 1.6.1 $ROOTSYS/bin; The bin directory contains several executables. root; shows the ROOT splash screen and calls root.exe. root.exe; the executable that root calls, if you use a debugger such as gdb, you will need to run root.exe directly. rootcling; is the utility ROOT uses to create a class dictionary for Cling. rmkdepend; a modified version of makedepend that is used by the ROOT build system. root-config; a script returning the needed compile flags and libraries for projects that compile and link with ROOT. proofd; a small daemon used to authenticate a user of ROOT parallel processing capability (PROOF). proofserv; the actual PROOF process, which is started by proofd after a user, has successfully been authenticated. rootd; is the daemon for remote ROOT file access (see the TNetFile). 1.6.2 $ROOTSYS/lib; There are several ways to use ROOT, one way is to run the executable by typing root at the system prompt another way is to link with the ROOT libraries and make the ROOT classes available in your own program.; Here is a short description of the most relevant libraries, the ones marked with a * are only installed when the options specified them. libAsImage is the image manipulation library; libCling is the C++ interpreter (Cling); libCore is the Base classes; libEG is the abstract event generator interface classes; *libEGPythia is the Pythia5 event generator interface; *libEGPythia6 is the Pythia6 event generator interface; libFitPanel contains the GUI used for fitting; libGed contains the GUI used for editing the properties of histograms, graphs, etc.; libGeom is the geometry package (with builder and painter); libGpad is the pad and canvas classes which depend on low level graphics; libGraf is the 2D graphics primitives (can be used independent of libGpad); libGraf3d is the 3D graphics primitives; libGui is the GUI classes (depend on low level graphics); libGuiBld is the GUI des",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:24517,Availability,avail,available,24517,"Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain class names and the library names that the class depends on. After reading them, ROOT knows which classes are available, and which libraries to load for them.; When TSystem::Load(""ALib"") is called, ROOT uses this information to determine which libraries libALib.so depends on. It will load these libraries first. Otherwise, loading the requested library could cause a system (dynamic loader) error due to unresolved symbols.; 1.6.3 $ROOTSYS/tutorials; tutorials The tutorials directory contains many example example scripts. They assume some basic knowledge of ROOT, and for the new user we recommend reading the chapters: “Histograms” and “Input/Output” before trying the examples. The more experienced user can jump to chapter “The Tutorials and Tests” to find more explicit and specific information about how to build and run the examples.; The $ROOTSYS/tutorials/ directory include the following sub-directories:; fft: Fast Fourier Transform with the fftw package fit: Several examples illustrating minimization/fitting foam: Random generator in multidimensional space geom: Examples of use of the geometr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:24799,Availability,error,error,24799,"ch an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain class names and the library names that the class depends on. After reading them, ROOT knows which classes are available, and which libraries to load for them.; When TSystem::Load(""ALib"") is called, ROOT uses this information to determine which libraries libALib.so depends on. It will load these libraries first. Otherwise, loading the requested library could cause a system (dynamic loader) error due to unresolved symbols.; 1.6.3 $ROOTSYS/tutorials; tutorials The tutorials directory contains many example example scripts. They assume some basic knowledge of ROOT, and for the new user we recommend reading the chapters: “Histograms” and “Input/Output” before trying the examples. The more experienced user can jump to chapter “The Tutorials and Tests” to find more explicit and specific information about how to build and run the examples.; The $ROOTSYS/tutorials/ directory include the following sub-directories:; fft: Fast Fourier Transform with the fftw package fit: Several examples illustrating minimization/fitting foam: Random generator in multidimensional space geom: Examples of use of the geometry package (TGeo classes) gl: Visualisation with OpenGL graphics: Basic graphics graphs: Use of TGraph, TGraphErrors, etc. gui: Scripts to create Graphical User Interface hist: Histogramming image: Image Processing io: Input/Output math: Maths and Statistics f",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:27682,Availability,avail,available,27682,"ccess to the tutorials directory, the new files will be created in the tutorials directory, otherwise they will be created in the user directory.; 1.6.4 $ROOTSYS/test; The test directory contains a set of examples example that represent all areas of the framework. When a new release is cut, the examples in this directory are compiled and run to test the new release’s backward compatibility. The list of source files is described in chapter “The Tutorials and Tests”.; The $ROOTSYS/test directory is a gold mine of ROOT-wisdom nuggets, and we encourage you to explore and exploit it. We recommend the new users to read the chapter “Getting Started”. The chapter “The Tutorials and Tests” has instructions on how to build all the programs and it goes over the examples Event and stress.; 1.6.5 $ROOTSYS/include; The include directory contains all header files. It is especially important because the header files contain the class definitions.; 1.6.6 $ROOTSYS/<library>; The directories we explored above are available when downloading the binaries. When downloading the source you also get a directory for each library with the corresponding header and source files, located in the inc and src subdirectories. To see what classes are in a library, you can check the <library>/inc directory for the list of class definitions. For example, the physics library libPhysics.so contains these class definitions:; > ls -m $ROOTSYS/math/physics/inc/; LinkDef.h, TFeldmanCousins.h, TGenPhaseSpace.h, TLorentzRotation.h,; TLorentzVector.h, TQuaternion.h, TRobustEstimator.h, TRolke.h,; TRotation.h, TVector2.h, TVector3.h; 1.7 How to Find More Information; website The ROOT web site has up to date documentation. The ROOT source code automatically generates this documentation, so each class is explicitly documented on its own web page, which is always up to date with the latest official release of ROOT.; The ROOT Reference Guide web pages can be found at class index reference guide https://root.cern/doc",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:27697,Availability,down,downloading,27697,"ccess to the tutorials directory, the new files will be created in the tutorials directory, otherwise they will be created in the user directory.; 1.6.4 $ROOTSYS/test; The test directory contains a set of examples example that represent all areas of the framework. When a new release is cut, the examples in this directory are compiled and run to test the new release’s backward compatibility. The list of source files is described in chapter “The Tutorials and Tests”.; The $ROOTSYS/test directory is a gold mine of ROOT-wisdom nuggets, and we encourage you to explore and exploit it. We recommend the new users to read the chapter “Getting Started”. The chapter “The Tutorials and Tests” has instructions on how to build all the programs and it goes over the examples Event and stress.; 1.6.5 $ROOTSYS/include; The include directory contains all header files. It is especially important because the header files contain the class definitions.; 1.6.6 $ROOTSYS/<library>; The directories we explored above are available when downloading the binaries. When downloading the source you also get a directory for each library with the corresponding header and source files, located in the inc and src subdirectories. To see what classes are in a library, you can check the <library>/inc directory for the list of class definitions. For example, the physics library libPhysics.so contains these class definitions:; > ls -m $ROOTSYS/math/physics/inc/; LinkDef.h, TFeldmanCousins.h, TGenPhaseSpace.h, TLorentzRotation.h,; TLorentzVector.h, TQuaternion.h, TRobustEstimator.h, TRolke.h,; TRotation.h, TVector2.h, TVector3.h; 1.7 How to Find More Information; website The ROOT web site has up to date documentation. The ROOT source code automatically generates this documentation, so each class is explicitly documented on its own web page, which is always up to date with the latest official release of ROOT.; The ROOT Reference Guide web pages can be found at class index reference guide https://root.cern/doc",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:27728,Availability,down,downloading,27728,"user directory.; 1.6.4 $ROOTSYS/test; The test directory contains a set of examples example that represent all areas of the framework. When a new release is cut, the examples in this directory are compiled and run to test the new release’s backward compatibility. The list of source files is described in chapter “The Tutorials and Tests”.; The $ROOTSYS/test directory is a gold mine of ROOT-wisdom nuggets, and we encourage you to explore and exploit it. We recommend the new users to read the chapter “Getting Started”. The chapter “The Tutorials and Tests” has instructions on how to build all the programs and it goes over the examples Event and stress.; 1.6.5 $ROOTSYS/include; The include directory contains all header files. It is especially important because the header files contain the class definitions.; 1.6.6 $ROOTSYS/<library>; The directories we explored above are available when downloading the binaries. When downloading the source you also get a directory for each library with the corresponding header and source files, located in the inc and src subdirectories. To see what classes are in a library, you can check the <library>/inc directory for the list of class definitions. For example, the physics library libPhysics.so contains these class definitions:; > ls -m $ROOTSYS/math/physics/inc/; LinkDef.h, TFeldmanCousins.h, TGenPhaseSpace.h, TLorentzRotation.h,; TLorentzVector.h, TQuaternion.h, TRobustEstimator.h, TRolke.h,; TRotation.h, TVector2.h, TVector3.h; 1.7 How to Find More Information; website The ROOT web site has up to date documentation. The ROOT source code automatically generates this documentation, so each class is explicitly documented on its own web page, which is always up to date with the latest official release of ROOT.; The ROOT Reference Guide web pages can be found at class index reference guide https://root.cern/doc/master/classes.html. Each page contains a class description, and an explanation of each method. It shows the class inheritance tre",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:28955,Availability,avail,available,28955,"initions. For example, the physics library libPhysics.so contains these class definitions:; > ls -m $ROOTSYS/math/physics/inc/; LinkDef.h, TFeldmanCousins.h, TGenPhaseSpace.h, TLorentzRotation.h,; TLorentzVector.h, TQuaternion.h, TRobustEstimator.h, TRolke.h,; TRotation.h, TVector2.h, TVector3.h; 1.7 How to Find More Information; website The ROOT web site has up to date documentation. The ROOT source code automatically generates this documentation, so each class is explicitly documented on its own web page, which is always up to date with the latest official release of ROOT.; The ROOT Reference Guide web pages can be found at class index reference guide https://root.cern/doc/master/classes.html. Each page contains a class description, and an explanation of each method. It shows the class inheritance tree and lets you jump to the parent class page by clicking on the class name. If you want more details, you can even see the source. There is a help page available in the little box on the upper right hand side of each class documentation page. You can see on the next page what a typical class documentation web page looks like. The ROOT web site also contains in addition to this Reference Guide, “How To’s”, a list of publications and example applications.; 1.7.1 Class Reference Guide; The top of any class reference page lets you jump to different parts of the documentation. The first line links to the class index and the index for the current module (a group of classes, often a library). The second line links to the ROOT homepage and the class overviews. The third line links the source information - a HTML version of the source and header file as well as the CVS (the source management system used for the ROOT development) information of the files. The last line links the different parts of the current pages. Example of function documentation, with automatically generated LaTeX-like graphics. Inheritance tree, showing what the current class derives from, and which classe",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:34658,Availability,avail,available,34658,"a ROOT session. One simply adds the name of the script(s) after the ROOT command. Be warned: after finishing the execution of the script, ROOT will normally enter a new session.; -q process command line script files and exit. For example if you would like to run a script myMacro.C in the background, redirect the output into a file myMacro.log, and exit after the script execution, use the following syntax:; root -b -q myMacro.C > myMacro.log; If you need to pass a parameter to the script use:; root -b -q 'myMacro.C(3)' > myMacro.log; Be mindful of the quotes, i.e. if you need to pass a string as a parameter, the syntax is:; root -b -q 'myMacro.C(""text"")' > myMacro.log; You can build a shared library with ACLiC and then use this shared library on the command line for a quicker execution (i.e. the compiled speed rather than the interpreted speed). See also “Cling the C++ Interpreter”.; root -b -q myMacro.so > myMacro.log; ROOT has a powerful C/C++ interpreter giving you access to all available ROOT classes, global variables, and functions via the command line. By typing C++ statements at the prompt, you can create objects, call functions, execute scripts, etc. For example:; root[] 1+sqrt(9); (const double)4.00000000000000000e+00; root[] for (int i = 0; i<4; i++) cout << ""Hello"" << i << endl; Hello 0; Hello 1; Hello 2; Hello 3; root[] .q; To exit the ROOT session, type .q.; root[] .q; 2.3 Using the GUI; The basic whiteboard on which an object is drawn in ROOT is called a canvas (defined by the class TCanvas). Every object in the canvas is a graphical object in the sense that you can grab it, resize it, and change some characteristics using the mouse. The canvas area can be divided in several sub areas, so-called pads (the class TPad). A pad is a canvas sub area that can contain other pads or graphical objects. At any one time, just one pad is the so-called active pad. Any object at the moment of drawing will be drawn in the active pad. The obvious question is: what is th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:41261,Availability,avail,available,41261,"ram title.; Fit Parameters: toggles the display of the histogram or graph fit parameters.; Can Edit Histogram: enables/disables the possibility to edit histogram bin contents. 2.3.1.5 Inspect Menu. ROOT: inspects the top-level gROOT object (in a new canvas).; Start Browser: starts a new object browser (in a separate window).; GUI Builder: starts the GUI builder application (in a separate window). 2.3.1.6 Help Menu. Canvas: help on canvas as a whiteboard area for drawing.; Menus: help on canvas menus.; Graphics Editor: help on primitives’ drawing and objects’ editor.; Browser: help on the ROOT objects’ and files’ browser.; Objects: help on DrawClass, Inspect and Dump context menu items.; PostScript: help on how to print a canvas to a PostScript file format.; About ROOT: pops up the ROOT Logo with the version number. 2.3.1.7 Classes Menu. Classes: starts the ClassTree viewer that draws inheritance tree for a list of classes. 2.3.1.8 Toolbar; The following menu shortcuts and utilities are available from the toolbar:; Create a new canvas window.; Popup the Open File dialog.; Popup the Save As… dialog.; Popup the Print dialog.; Interrupts the current drawing process.; Redraw the canvas.; Inspect the gROOT object.; Create a new objects’ browser.; You can create the following graphical objects using the toolbar buttons for primitive drawing. Tool tips are provided for helping your choice.; An Arc or circle: Click on the center of the arc, and then move the mouse. A rubber band circle is shown. Click again with the left button to freeze the arc.; A Line: Click with the left button at the point where you want to start the line, then move the mouse and click again with the left button to freeze the line.; An Arrow:Click with the left button at the point where you want to start the arrow, then move the mouse and click again with the left button to freeze the arrow.; A Diamond: Click with the left button and freeze again with the left button. The editor draws a rubber band box ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:44406,Availability,down,down,44406," and drag to the new point position.; A Curly Line: Proceed as for the arrow or line. Once done, click with the third button to change the characteristics of the curly line, like transform it to wave, change the wavelength, etc.; A Curly Arc: Proceed like for an ellipse. The first click is located at the position of the center, the second click at the position of the arc beginning. Once done, one obtains a curly ellipse, for which one can click with the third button to change the characteristics, like transform it to wavy, change the wavelength, set the minimum and maximum angle to make an arc that is not closed, etc.; A Text/Latex string: Click with the left button where you want to draw the text and then type in the text terminated by carriage return. All TLatex expressions are valid. To move the text or formula, point on it keeping the left mouse button pressed and drag the text to its new position. You can grow/shrink the text if you position the mouse to the first top-third part of the string, then move the mouse up or down to grow or shrink the text respectively. If you position the mouse near the bottom-end of the text, you can rotate it.; A Marker: Click with the left button where to place the marker. The marker can be modified by using the method SetMarkerStyle() of TSystem.; A Graphical Cut: Click with the left button on each point of a polygon delimiting the selected area. Close the cut by double clicking on the last point. A TCutG object is created. It can be used as a selection for a TTree::Draw. You can get a pointer to this object with:; TCutG cut = (TCutG*)gPad->GetPrimitive(""CUTG""); Once you are happy with your picture, you can select the Save as canvas.C item in the canvas File menu. This will automatically generate a script with the C++ statements corresponding to the picture. This facility also works if you have other objects not drawn with the graphics editor (histograms for example).; 2.3.2 The Editor Frame; The ROOT graphics editor loads the c",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:46590,Availability,avail,available,46590," selected object is TAxis, the TAxisEditor will shows up in the editor frame giving the possibility for changing different axis attributes. The graphics editor can be:; Embedded - connected only with the canvas in the application window that appears on the left of the canvas window after been activated via View menu / Editor. It appears on the left side if the canvas window allowing users to edit the attributes of the selected object via provided user interface. The name of the selected object is displayed on the top of the editor frame in red color. If the user interface needs more space then the height of the canvas window, a vertical scroll bar appears for easer navigation. Global - has own application window and can be connected to any created canvas in a ROOT session. It can be activated via the context menu entries for setting line, fill, text and marker attributes for backward compatibility, but there will be a unique entry in the near future. The user interface for the following classes is available since ROOT v.4.04: TAttLine, TAttFill, TAttMarker, TAttText, TArrow, TAxis, TCurlyArc, TCurlyLine, TFrame, TH1, TH2, TGraph, TPad, TCanvas, TPaveStats. For more details, see “The Graphics Editor”, “The User Interface for Histograms”, “The User Interface for Graphs”.; 2.3.3 Classes, Methods and Constructors; Object oriented programming introduces objects, which have data members and methods. The next line creates an object named f1 of the class TF1 that is a one-dimensional function. The type of an object is called a class. The object itself is called an instance of a class. When a method builds an object, it is called a constructor.; TF1 f1(""func1"",""sin(x)/x"",0,10); In our constructor the function sin(x)/x is defined for use, and 0 and 10 are the limits. The first parameter, func1 is the name of the object f1. Most objects in ROOT have a name. ROOT maintains a list of objects that can be searched to find any object by its given name (in our example func1).; The s",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:49470,Availability,avail,available,49470,"od TF1::Paint(), that draws the function, computes 100 equidistant points to draw it. The number of points can be set to a higher value with:; root[] f1.SetNpx(2000);; Note that while the ROOT framework is an object-oriented framework, this does not prevent the user from calling plain functions.; 2.3.4 User Interaction; Now we will look at some interactive capabilities. Try to draw the function sin(x)/x again. Every object in a window (which is called a canvas) is, in fact, a graphical object in the sense that you can grab it, resize it, and change its characteristics with a mouse click. For example, bring the cursor over the x-axis. The cursor changes to a hand with a pointing finger when it is over the axis. Now, left click and drag the mouse along the axis to the right. You have a very simple zoom.; When you move the mouse over any object, you can get access to selected methods by pressing the right mouse button and obtaining a context menu. If you try this on the function TF1, you will get a menu showing available methods. The other objects on this canvas are the title, a TPaveText object; the x and y-axis, TAxis objects, the frame, a TFrame object, and the canvas a TCanvas object. Try clicking on these and observe the context menu with their methods. A context menu. For example try selecting the SetRange() method and putting -10, 10 in the dialog box fields. This is equivalent to executing f1.SetRange(-10,10) from the command line, followed by f1.Draw(). Here are some other options you can try.; Once the picture suits your wishes, you may want to see the code you should put in a script to obtain the same result. To do that, choose Save / canvas.C entry of the File menu. This will generate a script showing the options set in the current canvas. Notice that you can also save the picture into various file formats such as PostScript, GIF, etc. Another interesting possibility is to save your canvas into the native ROOT format (.rootfile). This will enable you to ope",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:53195,Availability,avail,available,53195,"orted file types can be saved via File menu / SaveAs… This dialog gives a choice to show or suppress the confirmation message for overwriting an existing file.; If the Overwrite check box is not selected, a message dialog appears asking the user to overwrite the file (Yes/No). The user choice is saved for the next time the Save As… dialog shows up.; 2.3.7 Printing the Canvas; The Print command in the canvas File menu pops-up a print dialog where the user can specify a preferred print command and the printer name. Both print parameters can be set via the new Print.Command and Print.Printer rootrc resources as follows:; # Printer settings.; WinNT.*.Print.Command: AcroRd32.exe; Unix.*.Print.Command: xprint -P%p %f; Print.Printer: 32-rb205-hp; Print.Directory: .; If the %p and %f are specified as a part of the print command, they will be replaced by the specified printer name and the file name. All other parameters will be kept as they are written. A print button is available in the canvas toolbar (activated via View menu/Toolbar).; 2.4 The ROOT Command Line; We have briefly touched on how to use the command line. There are different types of commands. Cling commands start with “.”. root[] .? //this command will list all the Cling commands; root[] .L <filename> //load [filename]; root[] .x <filename> //load and execute [filename]. SHELL commands start with “.!” for example:. root[] .! ls. C++ commands follow C++ syntax (almost). root[] TBrowser *b = new TBrowser(); 2.4.1 Multi-line Commands; You can use the command line to execute multi-line commands. To begin a multi-line command you must type a single left curly bracket {, and to end it you must type a single right curly bracket }. For example:; root[] {; end with '}'> Int_t j = 0;; end with '}'> for (Int_t i = 0; i < 3; i++); end with '}'> {; end with '}'> j= j + i;; end with '}'> cout << ""i = "" << i << "", j = "" << j << endl;; end with '}'> }; end with '}'> }; i = 0, j = 0; i = 1, j = 1; i = 2, j = 3; It is more conve",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:65397,Availability,down,down,65397," the environment variable ROOTDEBUG overrides the value in the .rootrc file at startup. Its value is used to set gDebug and helps for quick turn on debug mode in TROOT startup.; ROOT looks for scripts in the path specified in the .rootrc file in the Root.Macro.Path variable. You can expand this path to hold your own directories.; 2.7.1 Logon and Logoff Scripts; The rootlogon.C and rootlogoff.C files are scripts loaded and executed at start-up and shutdown. The rootalias.C file is loaded but not executed. It typically contains small utility functions. For example, the rootalias.C script that comes with the ROOT distributions (located in $ROOTSYS/tutorials) defines the function edit(char *file). This allows the user to call the editor from the command line. This particular function will start the VI editor if the environment variable EDITOR is not set.; root[0] edit(""c1.C""); For more details, see $ROOTSYS/tutorials/rootalias.C.; 2.7.2 History File; You can use the up and down arrow at the command line, to access the previous and next command. The commands are recorded in the history file $HOME/.root_hist. It is a text file, and you can edit, cut, and paste from it. You can specify the history file in the system.rootrc file, by setting the Rint.Historyoption. You can also turn off the command logging in the system.rootrc file with the option: Rint.History: -; The number of history lines to be kept can be set also in .rootrc by:; Rint.HistSize: 500; Rint.HistSave: 400; The first value defines the maximum of lines kept; once it is reached all, the last HistSave lines will be removed. One can set HistSize to 0 to disable history line management. There is also implemented an environment variable called ROOT_HIST. By setting ROOT_HIST=300:200 the above values can be overriden - the first value corresponds to HistSize, the (optional) second one to HistSave. You can set ROOT_HIST=0 to disable the history.; 2.7.3 Tracking Memory Leaks; You can track memory usage and detect leak",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:76334,Availability,error,errors,76334,"upport fixed or variable bin sizes. 2-D histograms may have fixed size bins along X and variable size bins along Y or vice-versa. The functions to fill, manipulate, draw, or access histograms are identical in both cases.; 3.3.1 Convention; For all histogram types: nbins , xlow , xup; Bin# 0 contains the underflow.; Bin# 1 contains the first bin with low-edge ( xlow INCLUDED).; The second to last bin (bin# nbins) contains the upper-edge (xup EXCLUDED).; The Last bin (bin# nbins+1) contains the overflow.; In case of 2-D or 3-D histograms, a “global bin” number is defined. For example, assuming a 3-D histogram h with binx, biny, binz, the function returns a global/linear bin number.; Int_t bin = h->GetBin(binx, biny, binz);; This global bin is useful to access the bin information independently of the dimension.; 3.3.2 Re-binning. At any time, a histogram can be re-binned via the TH1::Rebin() method. It returns a new histogram with the re-binned contents. If bin errors were stored, they are recomputed during the re-binning.; 3.4 Filling Histograms; A histogram is typically filled with statements like:; h1->Fill(x);; h1->Fill(x,w); // with weight; h2->Fill(x,y);; h2->Fill(x,y,w);; h3->Fill(x,y,z);; h3->Fill(x,y,z,w);; The Fill method computes the bin number corresponding to the given x, y or z argument and increments this bin by the given weight. The Fill() method returns the bin number for 1-D histograms or global bin number for 2-D and 3-D histograms. If TH1::Sumw2() has been called before filling, the sum of squares is also stored. One can increment a bin number directly by calling TH1::AddBinContent(), replace the existing content via TH1::SetBinContent() , and access the bin content of a given bin via TH1::GetBinContent() .; Double_t binContent = h->GetBinContent(bin);; 3.4.1 Automatic Re-binning Option; By default, the number of bins is computed using the range of the axis. You can change this to re-bin automatically by setting the automatic re-binning option:; h->",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:80921,Availability,error,error,80921,"d Multiplying; Many types of operations are supported on histograms or between histograms:. Addition of a histogram to the current histogram; Additions of two histograms with coefficients and storage into the current histogram; Multiplications and divisions are supported in the same way as additions.; The Add , Divide and Multiply methods also exist to add, divide or multiply a histogram by a function. Histograms objects (not pointers) TH1F h1 can be multiplied by a constant using:; h1.Scale(const); A new histogram can be created without changing the original one by doing:; TH1F h3 = 8*h1;; To multiply two histogram objects and put the result in a 3rd one do:; TH1F h3 = h1*h2;; The same operations can be done with histogram pointers TH1F *h1, *h2 following way:; h1->Scale(const) TH1F h3 = 8*(*h1); TH1F h3 = (*h1)*(*h2);; Of course, the TH1 methods Add , Multiply and Divide can be used instead of these operators.; If a histogram has associated error bars ( TH1::Sumw2() has been called), the resulting error bars are also computed assuming independent histograms. In case of divisions, binomial errors are also supported.; 3.7 Projections; One can make:. a 1-D projection of a 2-D histogram or profile. See TH2::ProfileX, TH2::ProfileY,TProfile::ProjectionX, TProfile2D::ProjectionXY, TH2::ProjectionX, TH2::ProjectionY .; a 1-D, 2-D or profile out of a 3-D histogram see TH3::ProjectionZ, TH3::Project3D. These projections can be fit via: TH2::FitSlicesX, TH2::FitSlicesY, TH3::FitSlicesZ.; 3.8 Drawing Histograms; When you call the Draw method of a histogram ( TH1::Draw ) for the first time, it creates a THistPainter object and saves a pointer to painter as a data member of the histogram. The THistPainter class specializes in the drawing of histograms. It allows logarithmic axes (x, y, z) when the CONT drawing option is using. The THistPainter class is separated from the histogram so that one can have histograms without the graphics overhead, for example in a batch program. The",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:80979,Availability,error,error,80979,"d Multiplying; Many types of operations are supported on histograms or between histograms:. Addition of a histogram to the current histogram; Additions of two histograms with coefficients and storage into the current histogram; Multiplications and divisions are supported in the same way as additions.; The Add , Divide and Multiply methods also exist to add, divide or multiply a histogram by a function. Histograms objects (not pointers) TH1F h1 can be multiplied by a constant using:; h1.Scale(const); A new histogram can be created without changing the original one by doing:; TH1F h3 = 8*h1;; To multiply two histogram objects and put the result in a 3rd one do:; TH1F h3 = h1*h2;; The same operations can be done with histogram pointers TH1F *h1, *h2 following way:; h1->Scale(const) TH1F h3 = 8*(*h1); TH1F h3 = (*h1)*(*h2);; Of course, the TH1 methods Add , Multiply and Divide can be used instead of these operators.; If a histogram has associated error bars ( TH1::Sumw2() has been called), the resulting error bars are also computed assuming independent histograms. In case of divisions, binomial errors are also supported.; 3.7 Projections; One can make:. a 1-D projection of a 2-D histogram or profile. See TH2::ProfileX, TH2::ProfileY,TProfile::ProjectionX, TProfile2D::ProjectionXY, TH2::ProjectionX, TH2::ProjectionY .; a 1-D, 2-D or profile out of a 3-D histogram see TH3::ProjectionZ, TH3::Project3D. These projections can be fit via: TH2::FitSlicesX, TH2::FitSlicesY, TH3::FitSlicesZ.; 3.8 Drawing Histograms; When you call the Draw method of a histogram ( TH1::Draw ) for the first time, it creates a THistPainter object and saves a pointer to painter as a data member of the histogram. The THistPainter class specializes in the drawing of histograms. It allows logarithmic axes (x, y, z) when the CONT drawing option is using. The THistPainter class is separated from the histogram so that one can have histograms without the graphics overhead, for example in a batch program. The",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:81072,Availability,error,errors,81072," histogram to the current histogram; Additions of two histograms with coefficients and storage into the current histogram; Multiplications and divisions are supported in the same way as additions.; The Add , Divide and Multiply methods also exist to add, divide or multiply a histogram by a function. Histograms objects (not pointers) TH1F h1 can be multiplied by a constant using:; h1.Scale(const); A new histogram can be created without changing the original one by doing:; TH1F h3 = 8*h1;; To multiply two histogram objects and put the result in a 3rd one do:; TH1F h3 = h1*h2;; The same operations can be done with histogram pointers TH1F *h1, *h2 following way:; h1->Scale(const) TH1F h3 = 8*(*h1); TH1F h3 = (*h1)*(*h2);; Of course, the TH1 methods Add , Multiply and Divide can be used instead of these operators.; If a histogram has associated error bars ( TH1::Sumw2() has been called), the resulting error bars are also computed assuming independent histograms. In case of divisions, binomial errors are also supported.; 3.7 Projections; One can make:. a 1-D projection of a 2-D histogram or profile. See TH2::ProfileX, TH2::ProfileY,TProfile::ProjectionX, TProfile2D::ProjectionXY, TH2::ProjectionX, TH2::ProjectionY .; a 1-D, 2-D or profile out of a 3-D histogram see TH3::ProjectionZ, TH3::Project3D. These projections can be fit via: TH2::FitSlicesX, TH2::FitSlicesY, TH3::FitSlicesZ.; 3.8 Drawing Histograms; When you call the Draw method of a histogram ( TH1::Draw ) for the first time, it creates a THistPainter object and saves a pointer to painter as a data member of the histogram. The THistPainter class specializes in the drawing of histograms. It allows logarithmic axes (x, y, z) when the CONT drawing option is using. The THistPainter class is separated from the histogram so that one can have histograms without the graphics overhead, for example in a batch program. The choice to give each histogram has its own painter rather than a central singleton painter, allows two h",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:85210,Availability,error,errors,85210,"Width(Width_t width = 1); When you change the current style and would like to propagate the change to a previously created histogram you can call TH1::UseCurrentStyle(). You will need to call UseCurrentStyle() on each histogram. When reading many histograms from a file and you wish to update them to the current style, you can use gROOT::ForceStyle and all histograms read after this call will be updated to use the current style. See “Graphics and the Graphical User Interface”. When a histogram is automatically created as a result of a TTree::Draw , the style of the histogram is inherited from the tree attributes and the current style is ignored. The tree attributes are the ones set in the current TStyle at the time the tree was created. You can change the existing tree to use the current style, by calling TTree::UseCurrentStyle() .; 3.8.2 Draw Options; The following draw options are supported on all histogram classes:. “AXIS”: Draw only the axis.; “HIST”: When a histogram has errors, it is visualized by default with error bars. To visualize it without errors use HIST together with the required option (e.g. “HIST SAME C”).; “SAME”: Superimpose on previous picture in the same pad.; “CYL”: Use cylindrical coordinates.; “POL”: Use polar coordinates.; “SPH”: Use spherical coordinates.; “PSR”: Use pseudo-rapidity/phi coordinates.; “LEGO”: Draw a lego plot with hidden line removal.; “LEGO1”: Draw a lego plot with hidden surface removal.; “LEGO2”: Draw a lego plot using colors to show the cell contents.; “SURF”: Draw a surface plot with hidden line removal.; “SURF1”: Draw a surface plot with hidden surface removal.; “SURF2”: Draw a surface plot using colors to show the cell contents.; “SURF3”: Same as SURF with a contour view on the top.; “SURF4”: Draw a surface plot using Gouraud shading.; “SURF5”: Same as SURF3 but only the colored contour is drawn. Used with option CYL , SPH or PSR it allows to draw colored contours on a sphere, a cylinder or in a pseudo rapidly space. In ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:85251,Availability,error,error,85251,"Width(Width_t width = 1); When you change the current style and would like to propagate the change to a previously created histogram you can call TH1::UseCurrentStyle(). You will need to call UseCurrentStyle() on each histogram. When reading many histograms from a file and you wish to update them to the current style, you can use gROOT::ForceStyle and all histograms read after this call will be updated to use the current style. See “Graphics and the Graphical User Interface”. When a histogram is automatically created as a result of a TTree::Draw , the style of the histogram is inherited from the tree attributes and the current style is ignored. The tree attributes are the ones set in the current TStyle at the time the tree was created. You can change the existing tree to use the current style, by calling TTree::UseCurrentStyle() .; 3.8.2 Draw Options; The following draw options are supported on all histogram classes:. “AXIS”: Draw only the axis.; “HIST”: When a histogram has errors, it is visualized by default with error bars. To visualize it without errors use HIST together with the required option (e.g. “HIST SAME C”).; “SAME”: Superimpose on previous picture in the same pad.; “CYL”: Use cylindrical coordinates.; “POL”: Use polar coordinates.; “SPH”: Use spherical coordinates.; “PSR”: Use pseudo-rapidity/phi coordinates.; “LEGO”: Draw a lego plot with hidden line removal.; “LEGO1”: Draw a lego plot with hidden surface removal.; “LEGO2”: Draw a lego plot using colors to show the cell contents.; “SURF”: Draw a surface plot with hidden line removal.; “SURF1”: Draw a surface plot with hidden surface removal.; “SURF2”: Draw a surface plot using colors to show the cell contents.; “SURF3”: Same as SURF with a contour view on the top.; “SURF4”: Draw a surface plot using Gouraud shading.; “SURF5”: Same as SURF3 but only the colored contour is drawn. Used with option CYL , SPH or PSR it allows to draw colored contours on a sphere, a cylinder or in a pseudo rapidly space. In ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:85287,Availability,error,errors,85287,"pagate the change to a previously created histogram you can call TH1::UseCurrentStyle(). You will need to call UseCurrentStyle() on each histogram. When reading many histograms from a file and you wish to update them to the current style, you can use gROOT::ForceStyle and all histograms read after this call will be updated to use the current style. See “Graphics and the Graphical User Interface”. When a histogram is automatically created as a result of a TTree::Draw , the style of the histogram is inherited from the tree attributes and the current style is ignored. The tree attributes are the ones set in the current TStyle at the time the tree was created. You can change the existing tree to use the current style, by calling TTree::UseCurrentStyle() .; 3.8.2 Draw Options; The following draw options are supported on all histogram classes:. “AXIS”: Draw only the axis.; “HIST”: When a histogram has errors, it is visualized by default with error bars. To visualize it without errors use HIST together with the required option (e.g. “HIST SAME C”).; “SAME”: Superimpose on previous picture in the same pad.; “CYL”: Use cylindrical coordinates.; “POL”: Use polar coordinates.; “SPH”: Use spherical coordinates.; “PSR”: Use pseudo-rapidity/phi coordinates.; “LEGO”: Draw a lego plot with hidden line removal.; “LEGO1”: Draw a lego plot with hidden surface removal.; “LEGO2”: Draw a lego plot using colors to show the cell contents.; “SURF”: Draw a surface plot with hidden line removal.; “SURF1”: Draw a surface plot with hidden surface removal.; “SURF2”: Draw a surface plot using colors to show the cell contents.; “SURF3”: Same as SURF with a contour view on the top.; “SURF4”: Draw a surface plot using Gouraud shading.; “SURF5”: Same as SURF3 but only the colored contour is drawn. Used with option CYL , SPH or PSR it allows to draw colored contours on a sphere, a cylinder or in a pseudo rapidly space. In Cartesian or polar coordinates, option SURF3 is used. The following options are ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:86495,Availability,error,error,86495,"s.; “SURF”: Draw a surface plot with hidden line removal.; “SURF1”: Draw a surface plot with hidden surface removal.; “SURF2”: Draw a surface plot using colors to show the cell contents.; “SURF3”: Same as SURF with a contour view on the top.; “SURF4”: Draw a surface plot using Gouraud shading.; “SURF5”: Same as SURF3 but only the colored contour is drawn. Used with option CYL , SPH or PSR it allows to draw colored contours on a sphere, a cylinder or in a pseudo rapidly space. In Cartesian or polar coordinates, option SURF3 is used. The following options are supported for 1-D histogram classes:. “AH”: Draw the histogram, but not the axis labels and tick marks; “B”: Draw a bar chart; “C”: Draw a smooth curve through the histogram bins; “E”: Draw the error bars; “E0”: Draw the error bars including bins with 0 contents; “E1”: Draw the error bars with perpendicular lines at the edges; “E2”: Draw the error bars with rectangles; “E3”: Draw a fill area through the end points of the vertical error bars; “E4”: Draw a smoothed filled area through the end points of the error bars; “L”: Draw a line through the bin contents; “P”: Draw a (poly)marker at each bin using the histogram’s current marker style; “P0”: Draw current marker at each bin including empty bins; “PIE”: Draw a Pie Chart; “*H”: Draw histogram with a * at each bin; “LF2”: Draw histogram as with option “L” but with a fill area. Note that “L” also draws a fill area if the histogram fill color is set but the fill area corresponds to the histogram contour.; “9”: Force histogram to be drawn in high resolution mode. By default, the histogram is drawn in low resolution in case the number of bins is greater than the number of pixels in the current pad; “][”: Draw histogram without the vertical lines for the first and the last bin. Use it when superposing many histograms on the same picture. The following options are supported for 2-D histogram classes:. “ARR”: Arrow mode. Shows gradient between adjacent cells; “BOX”: Draw a",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:86522,Availability,error,error,86522,"s.; “SURF”: Draw a surface plot with hidden line removal.; “SURF1”: Draw a surface plot with hidden surface removal.; “SURF2”: Draw a surface plot using colors to show the cell contents.; “SURF3”: Same as SURF with a contour view on the top.; “SURF4”: Draw a surface plot using Gouraud shading.; “SURF5”: Same as SURF3 but only the colored contour is drawn. Used with option CYL , SPH or PSR it allows to draw colored contours on a sphere, a cylinder or in a pseudo rapidly space. In Cartesian or polar coordinates, option SURF3 is used. The following options are supported for 1-D histogram classes:. “AH”: Draw the histogram, but not the axis labels and tick marks; “B”: Draw a bar chart; “C”: Draw a smooth curve through the histogram bins; “E”: Draw the error bars; “E0”: Draw the error bars including bins with 0 contents; “E1”: Draw the error bars with perpendicular lines at the edges; “E2”: Draw the error bars with rectangles; “E3”: Draw a fill area through the end points of the vertical error bars; “E4”: Draw a smoothed filled area through the end points of the error bars; “L”: Draw a line through the bin contents; “P”: Draw a (poly)marker at each bin using the histogram’s current marker style; “P0”: Draw current marker at each bin including empty bins; “PIE”: Draw a Pie Chart; “*H”: Draw histogram with a * at each bin; “LF2”: Draw histogram as with option “L” but with a fill area. Note that “L” also draws a fill area if the histogram fill color is set but the fill area corresponds to the histogram contour.; “9”: Force histogram to be drawn in high resolution mode. By default, the histogram is drawn in low resolution in case the number of bins is greater than the number of pixels in the current pad; “][”: Draw histogram without the vertical lines for the first and the last bin. Use it when superposing many histograms on the same picture. The following options are supported for 2-D histogram classes:. “ARR”: Arrow mode. Shows gradient between adjacent cells; “BOX”: Draw a",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:86580,Availability,error,error,86580,"s.; “SURF”: Draw a surface plot with hidden line removal.; “SURF1”: Draw a surface plot with hidden surface removal.; “SURF2”: Draw a surface plot using colors to show the cell contents.; “SURF3”: Same as SURF with a contour view on the top.; “SURF4”: Draw a surface plot using Gouraud shading.; “SURF5”: Same as SURF3 but only the colored contour is drawn. Used with option CYL , SPH or PSR it allows to draw colored contours on a sphere, a cylinder or in a pseudo rapidly space. In Cartesian or polar coordinates, option SURF3 is used. The following options are supported for 1-D histogram classes:. “AH”: Draw the histogram, but not the axis labels and tick marks; “B”: Draw a bar chart; “C”: Draw a smooth curve through the histogram bins; “E”: Draw the error bars; “E0”: Draw the error bars including bins with 0 contents; “E1”: Draw the error bars with perpendicular lines at the edges; “E2”: Draw the error bars with rectangles; “E3”: Draw a fill area through the end points of the vertical error bars; “E4”: Draw a smoothed filled area through the end points of the error bars; “L”: Draw a line through the bin contents; “P”: Draw a (poly)marker at each bin using the histogram’s current marker style; “P0”: Draw current marker at each bin including empty bins; “PIE”: Draw a Pie Chart; “*H”: Draw histogram with a * at each bin; “LF2”: Draw histogram as with option “L” but with a fill area. Note that “L” also draws a fill area if the histogram fill color is set but the fill area corresponds to the histogram contour.; “9”: Force histogram to be drawn in high resolution mode. By default, the histogram is drawn in low resolution in case the number of bins is greater than the number of pixels in the current pad; “][”: Draw histogram without the vertical lines for the first and the last bin. Use it when superposing many histograms on the same picture. The following options are supported for 2-D histogram classes:. “ARR”: Arrow mode. Shows gradient between adjacent cells; “BOX”: Draw a",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:86645,Availability,error,error,86645,"s.; “SURF”: Draw a surface plot with hidden line removal.; “SURF1”: Draw a surface plot with hidden surface removal.; “SURF2”: Draw a surface plot using colors to show the cell contents.; “SURF3”: Same as SURF with a contour view on the top.; “SURF4”: Draw a surface plot using Gouraud shading.; “SURF5”: Same as SURF3 but only the colored contour is drawn. Used with option CYL , SPH or PSR it allows to draw colored contours on a sphere, a cylinder or in a pseudo rapidly space. In Cartesian or polar coordinates, option SURF3 is used. The following options are supported for 1-D histogram classes:. “AH”: Draw the histogram, but not the axis labels and tick marks; “B”: Draw a bar chart; “C”: Draw a smooth curve through the histogram bins; “E”: Draw the error bars; “E0”: Draw the error bars including bins with 0 contents; “E1”: Draw the error bars with perpendicular lines at the edges; “E2”: Draw the error bars with rectangles; “E3”: Draw a fill area through the end points of the vertical error bars; “E4”: Draw a smoothed filled area through the end points of the error bars; “L”: Draw a line through the bin contents; “P”: Draw a (poly)marker at each bin using the histogram’s current marker style; “P0”: Draw current marker at each bin including empty bins; “PIE”: Draw a Pie Chart; “*H”: Draw histogram with a * at each bin; “LF2”: Draw histogram as with option “L” but with a fill area. Note that “L” also draws a fill area if the histogram fill color is set but the fill area corresponds to the histogram contour.; “9”: Force histogram to be drawn in high resolution mode. By default, the histogram is drawn in low resolution in case the number of bins is greater than the number of pixels in the current pad; “][”: Draw histogram without the vertical lines for the first and the last bin. Use it when superposing many histograms on the same picture. The following options are supported for 2-D histogram classes:. “ARR”: Arrow mode. Shows gradient between adjacent cells; “BOX”: Draw a",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:86735,Availability,error,error,86735,"s.; “SURF”: Draw a surface plot with hidden line removal.; “SURF1”: Draw a surface plot with hidden surface removal.; “SURF2”: Draw a surface plot using colors to show the cell contents.; “SURF3”: Same as SURF with a contour view on the top.; “SURF4”: Draw a surface plot using Gouraud shading.; “SURF5”: Same as SURF3 but only the colored contour is drawn. Used with option CYL , SPH or PSR it allows to draw colored contours on a sphere, a cylinder or in a pseudo rapidly space. In Cartesian or polar coordinates, option SURF3 is used. The following options are supported for 1-D histogram classes:. “AH”: Draw the histogram, but not the axis labels and tick marks; “B”: Draw a bar chart; “C”: Draw a smooth curve through the histogram bins; “E”: Draw the error bars; “E0”: Draw the error bars including bins with 0 contents; “E1”: Draw the error bars with perpendicular lines at the edges; “E2”: Draw the error bars with rectangles; “E3”: Draw a fill area through the end points of the vertical error bars; “E4”: Draw a smoothed filled area through the end points of the error bars; “L”: Draw a line through the bin contents; “P”: Draw a (poly)marker at each bin using the histogram’s current marker style; “P0”: Draw current marker at each bin including empty bins; “PIE”: Draw a Pie Chart; “*H”: Draw histogram with a * at each bin; “LF2”: Draw histogram as with option “L” but with a fill area. Note that “L” also draws a fill area if the histogram fill color is set but the fill area corresponds to the histogram contour.; “9”: Force histogram to be drawn in high resolution mode. By default, the histogram is drawn in low resolution in case the number of bins is greater than the number of pixels in the current pad; “][”: Draw histogram without the vertical lines for the first and the last bin. Use it when superposing many histograms on the same picture. The following options are supported for 2-D histogram classes:. “ARR”: Arrow mode. Shows gradient between adjacent cells; “BOX”: Draw a",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:86811,Availability,error,error,86811,"s.; “SURF”: Draw a surface plot with hidden line removal.; “SURF1”: Draw a surface plot with hidden surface removal.; “SURF2”: Draw a surface plot using colors to show the cell contents.; “SURF3”: Same as SURF with a contour view on the top.; “SURF4”: Draw a surface plot using Gouraud shading.; “SURF5”: Same as SURF3 but only the colored contour is drawn. Used with option CYL , SPH or PSR it allows to draw colored contours on a sphere, a cylinder or in a pseudo rapidly space. In Cartesian or polar coordinates, option SURF3 is used. The following options are supported for 1-D histogram classes:. “AH”: Draw the histogram, but not the axis labels and tick marks; “B”: Draw a bar chart; “C”: Draw a smooth curve through the histogram bins; “E”: Draw the error bars; “E0”: Draw the error bars including bins with 0 contents; “E1”: Draw the error bars with perpendicular lines at the edges; “E2”: Draw the error bars with rectangles; “E3”: Draw a fill area through the end points of the vertical error bars; “E4”: Draw a smoothed filled area through the end points of the error bars; “L”: Draw a line through the bin contents; “P”: Draw a (poly)marker at each bin using the histogram’s current marker style; “P0”: Draw current marker at each bin including empty bins; “PIE”: Draw a Pie Chart; “*H”: Draw histogram with a * at each bin; “LF2”: Draw histogram as with option “L” but with a fill area. Note that “L” also draws a fill area if the histogram fill color is set but the fill area corresponds to the histogram contour.; “9”: Force histogram to be drawn in high resolution mode. By default, the histogram is drawn in low resolution in case the number of bins is greater than the number of pixels in the current pad; “][”: Draw histogram without the vertical lines for the first and the last bin. Use it when superposing many histograms on the same picture. The following options are supported for 2-D histogram classes:. “ARR”: Arrow mode. Shows gradient between adjacent cells; “BOX”: Draw a",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:91185,Availability,error,error,91185,"t option; 3.8.2.1 The SCATter Plot Option; By default, 2D histograms are drawn as scatter plots. For each cell (i,j) a number of points proportional to the cell content are drawn. A maximum of 500 points per cell are drawn. If the maximum is above 500 contents are normalized to 500.; 3.8.2.2 The ARRow Option; The ARR option shows the gradient between adjacent cells. For each cell (i,j) an arrow is drawn. The orientation of the arrow follows the cell gradient.; 3.8.2.3 The BOX Option; For each cell (i,j) a box is drawn with surface proportional to contents. The size of the box is proportional to the absolute value of the cell contents. The cells with negative contents are drawn with an X on top of the boxes. With option BOX1 a button is drawn for each cell with surface proportional to contents’ absolute value. A sunken button is drawn for negative values, a raised one for positive values.; 3.8.2.4 The ERRor Bars Options. ""E"" Default. Draw only error bars, without markers; ""E0"" Draw also bins with 0 contents (turn off the symbols clipping).; ""E1"" Draw small lines at the end of error bars; ""E2"" Draw error rectangles; ""E3"" Draw a fill area through the end points of vertical error bars; ""E4"" Draw a smoothed filled area through the end points of error bars. The “E1” bars’ option. Note that for all options, the line and fill attributes of the histogram are used for the errors or errors contours. Use gStyle->SetErrorX(dx) to control the size of the error along x. The parameter dx is a percentage of bin width for errors along X. Set dx=0 to suppress the error along X. Use gStyle->SetEndErrorSize(np) to control the size of the lines at the end of the error bars (when option 1 is used). By default np=1 (np represents the number of pixels).; 3.8.2.5 The Color Option; For each cell (i,j) a box is drawn with a color proportional to the cell content. The color table used is defined in the current style (gStyle ). The color palette in TStyle can be modified with TStyle::SetPalette ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:91320,Availability,error,error,91320,"ontent are drawn. A maximum of 500 points per cell are drawn. If the maximum is above 500 contents are normalized to 500.; 3.8.2.2 The ARRow Option; The ARR option shows the gradient between adjacent cells. For each cell (i,j) an arrow is drawn. The orientation of the arrow follows the cell gradient.; 3.8.2.3 The BOX Option; For each cell (i,j) a box is drawn with surface proportional to contents. The size of the box is proportional to the absolute value of the cell contents. The cells with negative contents are drawn with an X on top of the boxes. With option BOX1 a button is drawn for each cell with surface proportional to contents’ absolute value. A sunken button is drawn for negative values, a raised one for positive values.; 3.8.2.4 The ERRor Bars Options. ""E"" Default. Draw only error bars, without markers; ""E0"" Draw also bins with 0 contents (turn off the symbols clipping).; ""E1"" Draw small lines at the end of error bars; ""E2"" Draw error rectangles; ""E3"" Draw a fill area through the end points of vertical error bars; ""E4"" Draw a smoothed filled area through the end points of error bars. The “E1” bars’ option. Note that for all options, the line and fill attributes of the histogram are used for the errors or errors contours. Use gStyle->SetErrorX(dx) to control the size of the error along x. The parameter dx is a percentage of bin width for errors along X. Set dx=0 to suppress the error along X. Use gStyle->SetEndErrorSize(np) to control the size of the lines at the end of the error bars (when option 1 is used). By default np=1 (np represents the number of pixels).; 3.8.2.5 The Color Option; For each cell (i,j) a box is drawn with a color proportional to the cell content. The color table used is defined in the current style (gStyle ). The color palette in TStyle can be modified with TStyle::SetPalette . Different draw options. 3.8.2.6 The TEXT Option; For each cell (i,j) the cell content is printed. The text attributes are:. Text font = current font set by TStyl",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:91342,Availability,error,error,91342,"ontent are drawn. A maximum of 500 points per cell are drawn. If the maximum is above 500 contents are normalized to 500.; 3.8.2.2 The ARRow Option; The ARR option shows the gradient between adjacent cells. For each cell (i,j) an arrow is drawn. The orientation of the arrow follows the cell gradient.; 3.8.2.3 The BOX Option; For each cell (i,j) a box is drawn with surface proportional to contents. The size of the box is proportional to the absolute value of the cell contents. The cells with negative contents are drawn with an X on top of the boxes. With option BOX1 a button is drawn for each cell with surface proportional to contents’ absolute value. A sunken button is drawn for negative values, a raised one for positive values.; 3.8.2.4 The ERRor Bars Options. ""E"" Default. Draw only error bars, without markers; ""E0"" Draw also bins with 0 contents (turn off the symbols clipping).; ""E1"" Draw small lines at the end of error bars; ""E2"" Draw error rectangles; ""E3"" Draw a fill area through the end points of vertical error bars; ""E4"" Draw a smoothed filled area through the end points of error bars. The “E1” bars’ option. Note that for all options, the line and fill attributes of the histogram are used for the errors or errors contours. Use gStyle->SetErrorX(dx) to control the size of the error along x. The parameter dx is a percentage of bin width for errors along X. Set dx=0 to suppress the error along X. Use gStyle->SetEndErrorSize(np) to control the size of the lines at the end of the error bars (when option 1 is used). By default np=1 (np represents the number of pixels).; 3.8.2.5 The Color Option; For each cell (i,j) a box is drawn with a color proportional to the cell content. The color table used is defined in the current style (gStyle ). The color palette in TStyle can be modified with TStyle::SetPalette . Different draw options. 3.8.2.6 The TEXT Option; For each cell (i,j) the cell content is printed. The text attributes are:. Text font = current font set by TStyl",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:91417,Availability,error,error,91417,"ontent are drawn. A maximum of 500 points per cell are drawn. If the maximum is above 500 contents are normalized to 500.; 3.8.2.2 The ARRow Option; The ARR option shows the gradient between adjacent cells. For each cell (i,j) an arrow is drawn. The orientation of the arrow follows the cell gradient.; 3.8.2.3 The BOX Option; For each cell (i,j) a box is drawn with surface proportional to contents. The size of the box is proportional to the absolute value of the cell contents. The cells with negative contents are drawn with an X on top of the boxes. With option BOX1 a button is drawn for each cell with surface proportional to contents’ absolute value. A sunken button is drawn for negative values, a raised one for positive values.; 3.8.2.4 The ERRor Bars Options. ""E"" Default. Draw only error bars, without markers; ""E0"" Draw also bins with 0 contents (turn off the symbols clipping).; ""E1"" Draw small lines at the end of error bars; ""E2"" Draw error rectangles; ""E3"" Draw a fill area through the end points of vertical error bars; ""E4"" Draw a smoothed filled area through the end points of error bars. The “E1” bars’ option. Note that for all options, the line and fill attributes of the histogram are used for the errors or errors contours. Use gStyle->SetErrorX(dx) to control the size of the error along x. The parameter dx is a percentage of bin width for errors along X. Set dx=0 to suppress the error along X. Use gStyle->SetEndErrorSize(np) to control the size of the lines at the end of the error bars (when option 1 is used). By default np=1 (np represents the number of pixels).; 3.8.2.5 The Color Option; For each cell (i,j) a box is drawn with a color proportional to the cell content. The color table used is defined in the current style (gStyle ). The color palette in TStyle can be modified with TStyle::SetPalette . Different draw options. 3.8.2.6 The TEXT Option; For each cell (i,j) the cell content is printed. The text attributes are:. Text font = current font set by TStyl",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:91488,Availability,error,error,91488,"ontent are drawn. A maximum of 500 points per cell are drawn. If the maximum is above 500 contents are normalized to 500.; 3.8.2.2 The ARRow Option; The ARR option shows the gradient between adjacent cells. For each cell (i,j) an arrow is drawn. The orientation of the arrow follows the cell gradient.; 3.8.2.3 The BOX Option; For each cell (i,j) a box is drawn with surface proportional to contents. The size of the box is proportional to the absolute value of the cell contents. The cells with negative contents are drawn with an X on top of the boxes. With option BOX1 a button is drawn for each cell with surface proportional to contents’ absolute value. A sunken button is drawn for negative values, a raised one for positive values.; 3.8.2.4 The ERRor Bars Options. ""E"" Default. Draw only error bars, without markers; ""E0"" Draw also bins with 0 contents (turn off the symbols clipping).; ""E1"" Draw small lines at the end of error bars; ""E2"" Draw error rectangles; ""E3"" Draw a fill area through the end points of vertical error bars; ""E4"" Draw a smoothed filled area through the end points of error bars. The “E1” bars’ option. Note that for all options, the line and fill attributes of the histogram are used for the errors or errors contours. Use gStyle->SetErrorX(dx) to control the size of the error along x. The parameter dx is a percentage of bin width for errors along X. Set dx=0 to suppress the error along X. Use gStyle->SetEndErrorSize(np) to control the size of the lines at the end of the error bars (when option 1 is used). By default np=1 (np represents the number of pixels).; 3.8.2.5 The Color Option; For each cell (i,j) a box is drawn with a color proportional to the cell content. The color table used is defined in the current style (gStyle ). The color palette in TStyle can be modified with TStyle::SetPalette . Different draw options. 3.8.2.6 The TEXT Option; For each cell (i,j) the cell content is printed. The text attributes are:. Text font = current font set by TStyl",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:91613,Availability,error,errors,91613," adjacent cells. For each cell (i,j) an arrow is drawn. The orientation of the arrow follows the cell gradient.; 3.8.2.3 The BOX Option; For each cell (i,j) a box is drawn with surface proportional to contents. The size of the box is proportional to the absolute value of the cell contents. The cells with negative contents are drawn with an X on top of the boxes. With option BOX1 a button is drawn for each cell with surface proportional to contents’ absolute value. A sunken button is drawn for negative values, a raised one for positive values.; 3.8.2.4 The ERRor Bars Options. ""E"" Default. Draw only error bars, without markers; ""E0"" Draw also bins with 0 contents (turn off the symbols clipping).; ""E1"" Draw small lines at the end of error bars; ""E2"" Draw error rectangles; ""E3"" Draw a fill area through the end points of vertical error bars; ""E4"" Draw a smoothed filled area through the end points of error bars. The “E1” bars’ option. Note that for all options, the line and fill attributes of the histogram are used for the errors or errors contours. Use gStyle->SetErrorX(dx) to control the size of the error along x. The parameter dx is a percentage of bin width for errors along X. Set dx=0 to suppress the error along X. Use gStyle->SetEndErrorSize(np) to control the size of the lines at the end of the error bars (when option 1 is used). By default np=1 (np represents the number of pixels).; 3.8.2.5 The Color Option; For each cell (i,j) a box is drawn with a color proportional to the cell content. The color table used is defined in the current style (gStyle ). The color palette in TStyle can be modified with TStyle::SetPalette . Different draw options. 3.8.2.6 The TEXT Option; For each cell (i,j) the cell content is printed. The text attributes are:. Text font = current font set by TStyle; Text size= 0.02 * pad-height * marker-size; Text color= marker color. The TEXT option. 3.8.2.7 The CONTour Options; The following contour options are supported:. ""CONT"": Draw a contour pl",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:91623,Availability,error,errors,91623," adjacent cells. For each cell (i,j) an arrow is drawn. The orientation of the arrow follows the cell gradient.; 3.8.2.3 The BOX Option; For each cell (i,j) a box is drawn with surface proportional to contents. The size of the box is proportional to the absolute value of the cell contents. The cells with negative contents are drawn with an X on top of the boxes. With option BOX1 a button is drawn for each cell with surface proportional to contents’ absolute value. A sunken button is drawn for negative values, a raised one for positive values.; 3.8.2.4 The ERRor Bars Options. ""E"" Default. Draw only error bars, without markers; ""E0"" Draw also bins with 0 contents (turn off the symbols clipping).; ""E1"" Draw small lines at the end of error bars; ""E2"" Draw error rectangles; ""E3"" Draw a fill area through the end points of vertical error bars; ""E4"" Draw a smoothed filled area through the end points of error bars. The “E1” bars’ option. Note that for all options, the line and fill attributes of the histogram are used for the errors or errors contours. Use gStyle->SetErrorX(dx) to control the size of the error along x. The parameter dx is a percentage of bin width for errors along X. Set dx=0 to suppress the error along X. Use gStyle->SetEndErrorSize(np) to control the size of the lines at the end of the error bars (when option 1 is used). By default np=1 (np represents the number of pixels).; 3.8.2.5 The Color Option; For each cell (i,j) a box is drawn with a color proportional to the cell content. The color table used is defined in the current style (gStyle ). The color palette in TStyle can be modified with TStyle::SetPalette . Different draw options. 3.8.2.6 The TEXT Option; For each cell (i,j) the cell content is printed. The text attributes are:. Text font = current font set by TStyle; Text size= 0.02 * pad-height * marker-size; Text color= marker color. The TEXT option. 3.8.2.7 The CONTour Options; The following contour options are supported:. ""CONT"": Draw a contour pl",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:91693,Availability,error,error,91693,"the cell gradient.; 3.8.2.3 The BOX Option; For each cell (i,j) a box is drawn with surface proportional to contents. The size of the box is proportional to the absolute value of the cell contents. The cells with negative contents are drawn with an X on top of the boxes. With option BOX1 a button is drawn for each cell with surface proportional to contents’ absolute value. A sunken button is drawn for negative values, a raised one for positive values.; 3.8.2.4 The ERRor Bars Options. ""E"" Default. Draw only error bars, without markers; ""E0"" Draw also bins with 0 contents (turn off the symbols clipping).; ""E1"" Draw small lines at the end of error bars; ""E2"" Draw error rectangles; ""E3"" Draw a fill area through the end points of vertical error bars; ""E4"" Draw a smoothed filled area through the end points of error bars. The “E1” bars’ option. Note that for all options, the line and fill attributes of the histogram are used for the errors or errors contours. Use gStyle->SetErrorX(dx) to control the size of the error along x. The parameter dx is a percentage of bin width for errors along X. Set dx=0 to suppress the error along X. Use gStyle->SetEndErrorSize(np) to control the size of the lines at the end of the error bars (when option 1 is used). By default np=1 (np represents the number of pixels).; 3.8.2.5 The Color Option; For each cell (i,j) a box is drawn with a color proportional to the cell content. The color table used is defined in the current style (gStyle ). The color palette in TStyle can be modified with TStyle::SetPalette . Different draw options. 3.8.2.6 The TEXT Option; For each cell (i,j) the cell content is printed. The text attributes are:. Text font = current font set by TStyle; Text size= 0.02 * pad-height * marker-size; Text color= marker color. The TEXT option. 3.8.2.7 The CONTour Options; The following contour options are supported:. ""CONT"": Draw a contour plot (same as CONT0); ""CONT0"": Draw a contour plot using surface colors to distinguish contour",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:91758,Availability,error,errors,91758,"ox is drawn with surface proportional to contents. The size of the box is proportional to the absolute value of the cell contents. The cells with negative contents are drawn with an X on top of the boxes. With option BOX1 a button is drawn for each cell with surface proportional to contents’ absolute value. A sunken button is drawn for negative values, a raised one for positive values.; 3.8.2.4 The ERRor Bars Options. ""E"" Default. Draw only error bars, without markers; ""E0"" Draw also bins with 0 contents (turn off the symbols clipping).; ""E1"" Draw small lines at the end of error bars; ""E2"" Draw error rectangles; ""E3"" Draw a fill area through the end points of vertical error bars; ""E4"" Draw a smoothed filled area through the end points of error bars. The “E1” bars’ option. Note that for all options, the line and fill attributes of the histogram are used for the errors or errors contours. Use gStyle->SetErrorX(dx) to control the size of the error along x. The parameter dx is a percentage of bin width for errors along X. Set dx=0 to suppress the error along X. Use gStyle->SetEndErrorSize(np) to control the size of the lines at the end of the error bars (when option 1 is used). By default np=1 (np represents the number of pixels).; 3.8.2.5 The Color Option; For each cell (i,j) a box is drawn with a color proportional to the cell content. The color table used is defined in the current style (gStyle ). The color palette in TStyle can be modified with TStyle::SetPalette . Different draw options. 3.8.2.6 The TEXT Option; For each cell (i,j) the cell content is printed. The text attributes are:. Text font = current font set by TStyle; Text size= 0.02 * pad-height * marker-size; Text color= marker color. The TEXT option. 3.8.2.7 The CONTour Options; The following contour options are supported:. ""CONT"": Draw a contour plot (same as CONT0); ""CONT0"": Draw a contour plot using surface colors to distinguish contours; ""CONT1"": Draw a contour plot using line styles to distinguish co",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:91799,Availability,error,error,91799,"e size of the box is proportional to the absolute value of the cell contents. The cells with negative contents are drawn with an X on top of the boxes. With option BOX1 a button is drawn for each cell with surface proportional to contents’ absolute value. A sunken button is drawn for negative values, a raised one for positive values.; 3.8.2.4 The ERRor Bars Options. ""E"" Default. Draw only error bars, without markers; ""E0"" Draw also bins with 0 contents (turn off the symbols clipping).; ""E1"" Draw small lines at the end of error bars; ""E2"" Draw error rectangles; ""E3"" Draw a fill area through the end points of vertical error bars; ""E4"" Draw a smoothed filled area through the end points of error bars. The “E1” bars’ option. Note that for all options, the line and fill attributes of the histogram are used for the errors or errors contours. Use gStyle->SetErrorX(dx) to control the size of the error along x. The parameter dx is a percentage of bin width for errors along X. Set dx=0 to suppress the error along X. Use gStyle->SetEndErrorSize(np) to control the size of the lines at the end of the error bars (when option 1 is used). By default np=1 (np represents the number of pixels).; 3.8.2.5 The Color Option; For each cell (i,j) a box is drawn with a color proportional to the cell content. The color table used is defined in the current style (gStyle ). The color palette in TStyle can be modified with TStyle::SetPalette . Different draw options. 3.8.2.6 The TEXT Option; For each cell (i,j) the cell content is printed. The text attributes are:. Text font = current font set by TStyle; Text size= 0.02 * pad-height * marker-size; Text color= marker color. The TEXT option. 3.8.2.7 The CONTour Options; The following contour options are supported:. ""CONT"": Draw a contour plot (same as CONT0); ""CONT0"": Draw a contour plot using surface colors to distinguish contours; ""CONT1"": Draw a contour plot using line styles to distinguish contours; ""CONT2"": Draw a contour plot using the same l",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:91897,Availability,error,error,91897,"he cells with negative contents are drawn with an X on top of the boxes. With option BOX1 a button is drawn for each cell with surface proportional to contents’ absolute value. A sunken button is drawn for negative values, a raised one for positive values.; 3.8.2.4 The ERRor Bars Options. ""E"" Default. Draw only error bars, without markers; ""E0"" Draw also bins with 0 contents (turn off the symbols clipping).; ""E1"" Draw small lines at the end of error bars; ""E2"" Draw error rectangles; ""E3"" Draw a fill area through the end points of vertical error bars; ""E4"" Draw a smoothed filled area through the end points of error bars. The “E1” bars’ option. Note that for all options, the line and fill attributes of the histogram are used for the errors or errors contours. Use gStyle->SetErrorX(dx) to control the size of the error along x. The parameter dx is a percentage of bin width for errors along X. Set dx=0 to suppress the error along X. Use gStyle->SetEndErrorSize(np) to control the size of the lines at the end of the error bars (when option 1 is used). By default np=1 (np represents the number of pixels).; 3.8.2.5 The Color Option; For each cell (i,j) a box is drawn with a color proportional to the cell content. The color table used is defined in the current style (gStyle ). The color palette in TStyle can be modified with TStyle::SetPalette . Different draw options. 3.8.2.6 The TEXT Option; For each cell (i,j) the cell content is printed. The text attributes are:. Text font = current font set by TStyle; Text size= 0.02 * pad-height * marker-size; Text color= marker color. The TEXT option. 3.8.2.7 The CONTour Options; The following contour options are supported:. ""CONT"": Draw a contour plot (same as CONT0); ""CONT0"": Draw a contour plot using surface colors to distinguish contours; ""CONT1"": Draw a contour plot using line styles to distinguish contours; ""CONT2"": Draw a contour plot using the same line style for all contours; ""CONT3"": Draw a contour plot using fill area colors;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:99499,Availability,avail,available,99499,");; For example, the option COL draws a 2-D histogram with cells represented by a box filled with a color index, which is a function of the cell content. If the cell content is N, the color index used will be the color number in colors[N] . If the maximum cell content is greater than ncolors , all cell contents are scaled to ncolors. If ncolors<=0, a default palette of 50 colors is defined. This palette is recommended for pads, labels. It defines:. Index 0 to 9: shades of gray; Index 10 to 19:shades of brown; Index 20 to 29:shades of blue; Index 30 to 39: shades of red; Index 40 to 49:basic colors. The color numbers specified in this palette can be viewed by selecting the menu entry Colors in the View menu of the canvas menu bar. The color’s red, green, and blue values can be changed via TColor::SetRGB.; If ncolors == 1 && colors == 0, then a Pretty Palette with a spectrum violet to red is created with 50 colors. That’s the default rain bow palette.; Other predefined palettes with 255 colors are available when colors == 0. The following value of ncolors (with colors = 0) give access to:. ncolors = 51 : Deep Sea palette.; ncolors = 52 : Grey Scale palette.; ncolors = 53 : Dark Body Radiator palette.; ncolors = 54 : Two-color hue palette palette. (dark blue through neutral gray to bright yellow); ncolors = 55 : Rain Bow palette.; ncolors = 56 : Inverted Dark Body Radiator palette. The color numbers specified in the palette can be viewed by selecting the item “colors” in the “VIEW” menu of the canvas toolbar. The color parameters can be changed via TColor::SetRGB.; Note that when drawing a 2D histogram h2 with the option “COL” or “COLZ” or with any “CONT” options using the color map, the number of colors used is defined by the number of contours n specified with: h2->SetContour(n); 3.8.2.13 TPaletteAxis; A TPaletteAxisobject is used to display the color palette when drawing 2D histograms. The object is automatically created when drawing a 2D histogram when the option “z",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:101428,Availability,avail,available,101428,"when drawing a 2D histogram when the option “z” is specified. It is added to the histogram list of functions. It can be retrieved and its attributes can be changed with:; TPaletteAxis *palette=(TPaletteAxis*)h->FindObject(""palette"");; The palette can be interactively moved and resized. The context menu can be used to set the axis attributes. It is possible to select a range on the axis, to set the min/max in z.; 3.8.2.14 The SPEC Option; The “SPEC” option offers a large set of options/attributes to visualize 2D histograms thanks to “operators” following the “SPEC” keyword. For example, to draw the 2-D histogram h2 using all default attributes except the viewing angles, one can do:; h2->Draw(""SPEC a(30,30,0)"");; The operators’ names are case insensitive (i.e. one can use “a” or “A”) and their parameters are separated by coma “,”. Operators can be put in any order in the option and must be separated by a space "" "". No space characters should be put in an operator. All the available operators are described below.; The way how a 2D histogram will be painted is controlled by two parameters: the “Display modes groups” and the “Display Modes”. “Display modes groups” can take the following values:. 0 = Simple - simple display modes using one color only; 1 = Light - the shading is carried out according to the position of the fictive light source; 2 = Height - the shading is carried out according to the channel contents; 3 = LightHeight - combination of two previous shading algorithms (one can control the weight between both algorithms). “Display modes” can take the following values:. 1 = Points; 2 = Grid; 3 = Contours; 4 = Bars; 5 = LinesX; 6 = LinesY; 7 = BarsX; 8 = BarsY; 9 = Needles; 10 = Surface; 11 = Triangles. These parameters can be set by using the “dm” operator in the option.; h2->Draw(""SPEC dm(1,2)"");; The above example draws the histogram using the “Light Display mode group” and the “Grid Display mode”. The following tables summarize all the possible combinations o",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:110860,Availability,error,error,110860,"t1 to the pad coordinates; Float_t rightmax = 1.1*hint1->GetMaximum();; Float_t scale = gPad->GetUymax()/rightmax;; hint1->SetLineColor(kRed);; hint1->Scale(scale);; hint1->Draw(""same"");; //draw an axis on the right side; TGaxis*axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; gPad->GetUxmax(),gPad->GetUymax(),; 0,rightmax,510,""+L"");; axis->SetLineColor(kRed);; axis->SetLabelColor(kRed);; axis->Draw();; }; 3.8.5 Statistics Display; By default, a histogram drawing includes the statistics box. Use TH1::SetStats(kFALSE) to eliminate the statistics box. If the statistics box is drawn, gStyle->SetOptStat(mode) allow you to select the type of displayed information . The parameter mode has up to nine digits that can be set OFF (0) or ON as follows:; mode = ksiourmen (default =000001111). n = 1 the name of histogram is printed; e = 1 the number of entries; m = 1 the mean value; m = 2 the mean and mean error values; r = 1 the root mean square (RMS); r = 2 the RMS and RMS error; u = 1 the number of underflows; o = 1 the number of overflows; i = 1 the integral of bins; s = 1 the skewness; s = 2 the skewness and the skewness error; k = 1 the kurtosis; k = 2 the kurtosis and the kurtosis error. Never call SetOptStat(0001111) , but SetOptStat(1111) , because 0001111 will be taken as an octal number.; The method TStyle::SetOptStat(Option_t*option) can also be called with a character string as a parameter. The parameter option can contain:. n for printing the name of histogram; e the number of entries; m the mean value; M the mean and mean error values; r the root mean square (RMS); R the RMS and RMS error; u the number of underflows; o the number of overflows; i the integral of bins; s the skewness; S the skewness and the skewness error; k the kurtosis; K the kurtosis and the kurtosis error. gStyle->SetOptStat(""ne""); // prints the histogram name and number; // of entries; gStyle->SetOptStat(""n""); // prints the histogram name; gStyle->SetOptStat(""nemr""); // the default value; W",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:110930,Availability,error,error,110930,"t1 to the pad coordinates; Float_t rightmax = 1.1*hint1->GetMaximum();; Float_t scale = gPad->GetUymax()/rightmax;; hint1->SetLineColor(kRed);; hint1->Scale(scale);; hint1->Draw(""same"");; //draw an axis on the right side; TGaxis*axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; gPad->GetUxmax(),gPad->GetUymax(),; 0,rightmax,510,""+L"");; axis->SetLineColor(kRed);; axis->SetLabelColor(kRed);; axis->Draw();; }; 3.8.5 Statistics Display; By default, a histogram drawing includes the statistics box. Use TH1::SetStats(kFALSE) to eliminate the statistics box. If the statistics box is drawn, gStyle->SetOptStat(mode) allow you to select the type of displayed information . The parameter mode has up to nine digits that can be set OFF (0) or ON as follows:; mode = ksiourmen (default =000001111). n = 1 the name of histogram is printed; e = 1 the number of entries; m = 1 the mean value; m = 2 the mean and mean error values; r = 1 the root mean square (RMS); r = 2 the RMS and RMS error; u = 1 the number of underflows; o = 1 the number of overflows; i = 1 the integral of bins; s = 1 the skewness; s = 2 the skewness and the skewness error; k = 1 the kurtosis; k = 2 the kurtosis and the kurtosis error. Never call SetOptStat(0001111) , but SetOptStat(1111) , because 0001111 will be taken as an octal number.; The method TStyle::SetOptStat(Option_t*option) can also be called with a character string as a parameter. The parameter option can contain:. n for printing the name of histogram; e the number of entries; m the mean value; M the mean and mean error values; r the root mean square (RMS); R the RMS and RMS error; u the number of underflows; o the number of overflows; i the integral of bins; s the skewness; S the skewness and the skewness error; k the kurtosis; K the kurtosis and the kurtosis error. gStyle->SetOptStat(""ne""); // prints the histogram name and number; // of entries; gStyle->SetOptStat(""n""); // prints the histogram name; gStyle->SetOptStat(""nemr""); // the default value; W",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:111084,Availability,error,error,111084,"t1 to the pad coordinates; Float_t rightmax = 1.1*hint1->GetMaximum();; Float_t scale = gPad->GetUymax()/rightmax;; hint1->SetLineColor(kRed);; hint1->Scale(scale);; hint1->Draw(""same"");; //draw an axis on the right side; TGaxis*axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; gPad->GetUxmax(),gPad->GetUymax(),; 0,rightmax,510,""+L"");; axis->SetLineColor(kRed);; axis->SetLabelColor(kRed);; axis->Draw();; }; 3.8.5 Statistics Display; By default, a histogram drawing includes the statistics box. Use TH1::SetStats(kFALSE) to eliminate the statistics box. If the statistics box is drawn, gStyle->SetOptStat(mode) allow you to select the type of displayed information . The parameter mode has up to nine digits that can be set OFF (0) or ON as follows:; mode = ksiourmen (default =000001111). n = 1 the name of histogram is printed; e = 1 the number of entries; m = 1 the mean value; m = 2 the mean and mean error values; r = 1 the root mean square (RMS); r = 2 the RMS and RMS error; u = 1 the number of underflows; o = 1 the number of overflows; i = 1 the integral of bins; s = 1 the skewness; s = 2 the skewness and the skewness error; k = 1 the kurtosis; k = 2 the kurtosis and the kurtosis error. Never call SetOptStat(0001111) , but SetOptStat(1111) , because 0001111 will be taken as an octal number.; The method TStyle::SetOptStat(Option_t*option) can also be called with a character string as a parameter. The parameter option can contain:. n for printing the name of histogram; e the number of entries; m the mean value; M the mean and mean error values; r the root mean square (RMS); R the RMS and RMS error; u the number of underflows; o the number of overflows; i the integral of bins; s the skewness; S the skewness and the skewness error; k the kurtosis; K the kurtosis and the kurtosis error. gStyle->SetOptStat(""ne""); // prints the histogram name and number; // of entries; gStyle->SetOptStat(""n""); // prints the histogram name; gStyle->SetOptStat(""nemr""); // the default value; W",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:111147,Availability,error,error,111147,"t1 to the pad coordinates; Float_t rightmax = 1.1*hint1->GetMaximum();; Float_t scale = gPad->GetUymax()/rightmax;; hint1->SetLineColor(kRed);; hint1->Scale(scale);; hint1->Draw(""same"");; //draw an axis on the right side; TGaxis*axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; gPad->GetUxmax(),gPad->GetUymax(),; 0,rightmax,510,""+L"");; axis->SetLineColor(kRed);; axis->SetLabelColor(kRed);; axis->Draw();; }; 3.8.5 Statistics Display; By default, a histogram drawing includes the statistics box. Use TH1::SetStats(kFALSE) to eliminate the statistics box. If the statistics box is drawn, gStyle->SetOptStat(mode) allow you to select the type of displayed information . The parameter mode has up to nine digits that can be set OFF (0) or ON as follows:; mode = ksiourmen (default =000001111). n = 1 the name of histogram is printed; e = 1 the number of entries; m = 1 the mean value; m = 2 the mean and mean error values; r = 1 the root mean square (RMS); r = 2 the RMS and RMS error; u = 1 the number of underflows; o = 1 the number of overflows; i = 1 the integral of bins; s = 1 the skewness; s = 2 the skewness and the skewness error; k = 1 the kurtosis; k = 2 the kurtosis and the kurtosis error. Never call SetOptStat(0001111) , but SetOptStat(1111) , because 0001111 will be taken as an octal number.; The method TStyle::SetOptStat(Option_t*option) can also be called with a character string as a parameter. The parameter option can contain:. n for printing the name of histogram; e the number of entries; m the mean value; M the mean and mean error values; r the root mean square (RMS); R the RMS and RMS error; u the number of underflows; o the number of overflows; i the integral of bins; s the skewness; S the skewness and the skewness error; k the kurtosis; K the kurtosis and the kurtosis error. gStyle->SetOptStat(""ne""); // prints the histogram name and number; // of entries; gStyle->SetOptStat(""n""); // prints the histogram name; gStyle->SetOptStat(""nemr""); // the default value; W",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:111503,Availability,error,error,111503,"elect the type of displayed information . The parameter mode has up to nine digits that can be set OFF (0) or ON as follows:; mode = ksiourmen (default =000001111). n = 1 the name of histogram is printed; e = 1 the number of entries; m = 1 the mean value; m = 2 the mean and mean error values; r = 1 the root mean square (RMS); r = 2 the RMS and RMS error; u = 1 the number of underflows; o = 1 the number of overflows; i = 1 the integral of bins; s = 1 the skewness; s = 2 the skewness and the skewness error; k = 1 the kurtosis; k = 2 the kurtosis and the kurtosis error. Never call SetOptStat(0001111) , but SetOptStat(1111) , because 0001111 will be taken as an octal number.; The method TStyle::SetOptStat(Option_t*option) can also be called with a character string as a parameter. The parameter option can contain:. n for printing the name of histogram; e the number of entries; m the mean value; M the mean and mean error values; r the root mean square (RMS); R the RMS and RMS error; u the number of underflows; o the number of overflows; i the integral of bins; s the skewness; S the skewness and the skewness error; k the kurtosis; K the kurtosis and the kurtosis error. gStyle->SetOptStat(""ne""); // prints the histogram name and number; // of entries; gStyle->SetOptStat(""n""); // prints the histogram name; gStyle->SetOptStat(""nemr""); // the default value; With the option ""same"", the statistic box is not redrawn. With the option ""sames"", it is re-drawn. If it hides the previous statistics box, you can change its position with the next lines (where h is the histogram pointer):; root[] TPaveStats *s =; (TPaveStats*)h->GetListOfFunctions()->FindObject(""stats"");; root[] s->SetX1NDC (newx1); // new x start position; root[] s->SetX2NDC (newx2); // new x end position; 3.8.6 Setting Line, Fill, Marker, and Text Attributes; The histogram classes inherit from the attribute classes: TAttLine, TAttFill, TAttMarker and TAttText. See the description of these classes for the list of options.;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:111565,Availability,error,error,111565,"elect the type of displayed information . The parameter mode has up to nine digits that can be set OFF (0) or ON as follows:; mode = ksiourmen (default =000001111). n = 1 the name of histogram is printed; e = 1 the number of entries; m = 1 the mean value; m = 2 the mean and mean error values; r = 1 the root mean square (RMS); r = 2 the RMS and RMS error; u = 1 the number of underflows; o = 1 the number of overflows; i = 1 the integral of bins; s = 1 the skewness; s = 2 the skewness and the skewness error; k = 1 the kurtosis; k = 2 the kurtosis and the kurtosis error. Never call SetOptStat(0001111) , but SetOptStat(1111) , because 0001111 will be taken as an octal number.; The method TStyle::SetOptStat(Option_t*option) can also be called with a character string as a parameter. The parameter option can contain:. n for printing the name of histogram; e the number of entries; m the mean value; M the mean and mean error values; r the root mean square (RMS); R the RMS and RMS error; u the number of underflows; o the number of overflows; i the integral of bins; s the skewness; S the skewness and the skewness error; k the kurtosis; K the kurtosis and the kurtosis error. gStyle->SetOptStat(""ne""); // prints the histogram name and number; // of entries; gStyle->SetOptStat(""n""); // prints the histogram name; gStyle->SetOptStat(""nemr""); // the default value; With the option ""same"", the statistic box is not redrawn. With the option ""sames"", it is re-drawn. If it hides the previous statistics box, you can change its position with the next lines (where h is the histogram pointer):; root[] TPaveStats *s =; (TPaveStats*)h->GetListOfFunctions()->FindObject(""stats"");; root[] s->SetX1NDC (newx1); // new x start position; root[] s->SetX2NDC (newx2); // new x end position; 3.8.6 Setting Line, Fill, Marker, and Text Attributes; The histogram classes inherit from the attribute classes: TAttLine, TAttFill, TAttMarker and TAttText. See the description of these classes for the list of options.;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:111699,Availability,error,error,111699,"elect the type of displayed information . The parameter mode has up to nine digits that can be set OFF (0) or ON as follows:; mode = ksiourmen (default =000001111). n = 1 the name of histogram is printed; e = 1 the number of entries; m = 1 the mean value; m = 2 the mean and mean error values; r = 1 the root mean square (RMS); r = 2 the RMS and RMS error; u = 1 the number of underflows; o = 1 the number of overflows; i = 1 the integral of bins; s = 1 the skewness; s = 2 the skewness and the skewness error; k = 1 the kurtosis; k = 2 the kurtosis and the kurtosis error. Never call SetOptStat(0001111) , but SetOptStat(1111) , because 0001111 will be taken as an octal number.; The method TStyle::SetOptStat(Option_t*option) can also be called with a character string as a parameter. The parameter option can contain:. n for printing the name of histogram; e the number of entries; m the mean value; M the mean and mean error values; r the root mean square (RMS); R the RMS and RMS error; u the number of underflows; o the number of overflows; i the integral of bins; s the skewness; S the skewness and the skewness error; k the kurtosis; K the kurtosis and the kurtosis error. gStyle->SetOptStat(""ne""); // prints the histogram name and number; // of entries; gStyle->SetOptStat(""n""); // prints the histogram name; gStyle->SetOptStat(""nemr""); // the default value; With the option ""same"", the statistic box is not redrawn. With the option ""sames"", it is re-drawn. If it hides the previous statistics box, you can change its position with the next lines (where h is the histogram pointer):; root[] TPaveStats *s =; (TPaveStats*)h->GetListOfFunctions()->FindObject(""stats"");; root[] s->SetX1NDC (newx1); // new x start position; root[] s->SetX2NDC (newx2); // new x end position; 3.8.6 Setting Line, Fill, Marker, and Text Attributes; The histogram classes inherit from the attribute classes: TAttLine, TAttFill, TAttMarker and TAttText. See the description of these classes for the list of options.;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:111754,Availability,error,error,111754,"elect the type of displayed information . The parameter mode has up to nine digits that can be set OFF (0) or ON as follows:; mode = ksiourmen (default =000001111). n = 1 the name of histogram is printed; e = 1 the number of entries; m = 1 the mean value; m = 2 the mean and mean error values; r = 1 the root mean square (RMS); r = 2 the RMS and RMS error; u = 1 the number of underflows; o = 1 the number of overflows; i = 1 the integral of bins; s = 1 the skewness; s = 2 the skewness and the skewness error; k = 1 the kurtosis; k = 2 the kurtosis and the kurtosis error. Never call SetOptStat(0001111) , but SetOptStat(1111) , because 0001111 will be taken as an octal number.; The method TStyle::SetOptStat(Option_t*option) can also be called with a character string as a parameter. The parameter option can contain:. n for printing the name of histogram; e the number of entries; m the mean value; M the mean and mean error values; r the root mean square (RMS); R the RMS and RMS error; u the number of underflows; o the number of overflows; i the integral of bins; s the skewness; S the skewness and the skewness error; k the kurtosis; K the kurtosis and the kurtosis error. gStyle->SetOptStat(""ne""); // prints the histogram name and number; // of entries; gStyle->SetOptStat(""n""); // prints the histogram name; gStyle->SetOptStat(""nemr""); // the default value; With the option ""same"", the statistic box is not redrawn. With the option ""sames"", it is re-drawn. If it hides the previous statistics box, you can change its position with the next lines (where h is the histogram pointer):; root[] TPaveStats *s =; (TPaveStats*)h->GetListOfFunctions()->FindObject(""stats"");; root[] s->SetX1NDC (newx1); // new x start position; root[] s->SetX2NDC (newx2); // new x end position; 3.8.6 Setting Line, Fill, Marker, and Text Attributes; The histogram classes inherit from the attribute classes: TAttLine, TAttFill, TAttMarker and TAttText. See the description of these classes for the list of options.;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:114634,Availability,error,errors,114634,"he titles are part of the persistent histogram. For example if you wanted to write E with a subscript (T) you could use this:; h->GetXaxis()->SetTitle(""E_{T}"");; For a complete explanation of the Latex mathematical expressions, see “Graphics and the Graphical User Interface”. It is also possible to specify the histogram title and the axis titles at creation time. These titles can be given in the “title” parameter. They must be separated by “;”:; TH1F* h=new TH1F(""h"",""Histogram title;X Axis;Y Axis;Z Axis"",; 100,0,1);; Any title can be omitted:; TH1F* h=new TH1F(""h"",""Histogram title;;Y Axis"",100,0,1);; TH1F* h=new TH1F(""h"","";;Y Axis"",100,0,1);; The method SetTitle has the same syntax:; h->SetTitle(""Histogram title;An other X title Axis"");; 3.9 Making a Copy of an Histogram; Like for any other ROOT object derived from TObject , the Clone method can be used. This makes an identical copy of the original histogram including all associated errors and functions:; TH1F *hnew = (TH1F*)h->Clone(); // renaming is recommended,; hnew->SetName(""hnew""); // because otherwise you will have; // two histograms with the same; // name; 3.10 Normalizing Histograms; You can scale a histogram ( TH1 *h ) such that the bins integral is equal to the normalization parameter norm:; Double_t scale = norm/h->Integral();; h->Scale(scale);; 3.11 Saving/Reading Histograms to/from a File; The following statements create a ROOT file and store a histogram on the file. Because TH1 derives from TNamed , the key identifier on the file is the histogram name:; TFile f(""histos.root"",""new"");; TH1F h1(""hgaus"",""histo from a gaussian"",100,-3,3);; h1.FillRandom(""gaus"",10000);; h1->Write();; To read this histogram in another ROOT session, do:; TFile f(""histos.root"");; TH1F *h = (TH1F*)f.Get(""hgaus"");; One can save all histograms in memory to the file by:; file->Write();; For a more detailed explanation, see “Input/Output”.; 3.12 Miscellaneous Operations. TH1::KolmogorovTest( TH1* h2,Option_t *option) is statistical",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:117465,Availability,error,error,117465," Carlo distribution. The number of pseudo-experiments NEXPT is currently fixed at 1000. The function returns the integral. Note that this option “X” is much slower.; TH1::Smooth - smoothes the bin contents of a 1D histogram.; TH1::Integral(Option_t *opt)-returns the integral of bin contents in a given bin range. If the option “width” is specified, the integral is the sum of the bin contents multiplied by the bin width in x .; TH1::GetMean(int axis) - returns the mean value along axis.; TH1::GetStdDev(int axis) - returns the sigma distribution along axis.; TH1::GetRMS(int axis) - returns the Root Mean Square along axis.; TH1::GetEntries() - returns the number of entries.; TH1::GetAsymmetry(TH1 *h2,Double_t c2,Double_tdc2). returns an histogram containing the asymmetry of this histogram with h2, where the asymmetry is defined as:. Asymmetry = (h1 - h2)/(h1 + h2); //where h1 = this. It works for 1D , 2D , etc. histograms. The parameter c2 is an optional argument that gives a relative weight between the two histograms, and dc 2 is the error on this weight. This is useful, for example, when forming an asymmetry between two histograms from two different data sets that need to be normalized to each other in some way. The function calculates the errors assuming Poisson statistics on h1 and h2 (that is, dh=sqrt(h)). In the next example we assume that h1 and h2 are already filled:. h3 = h1->GetAsymmetry(h2);. Then h3 is created and filled with the asymmetry between h1 and h2 ; h1 and h2 are left intact.; Note that the user’s responsibility is to manage the created histograms.; TH1::Reset() - resets the bin contents and errors of a histogram. 3.13 Important note on returned statistics (GetMean, GetStdDev, etc.); By default, histogram statistics are computed at fill time using the unbinned data used to update the bin content. This means the values returned by GetMean, GetStdDev, etc., are those of the dataset used to fill the histogram, not those of the binned content of the hi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:117676,Availability,error,errors,117676," bin contents in a given bin range. If the option “width” is specified, the integral is the sum of the bin contents multiplied by the bin width in x .; TH1::GetMean(int axis) - returns the mean value along axis.; TH1::GetStdDev(int axis) - returns the sigma distribution along axis.; TH1::GetRMS(int axis) - returns the Root Mean Square along axis.; TH1::GetEntries() - returns the number of entries.; TH1::GetAsymmetry(TH1 *h2,Double_t c2,Double_tdc2). returns an histogram containing the asymmetry of this histogram with h2, where the asymmetry is defined as:. Asymmetry = (h1 - h2)/(h1 + h2); //where h1 = this. It works for 1D , 2D , etc. histograms. The parameter c2 is an optional argument that gives a relative weight between the two histograms, and dc 2 is the error on this weight. This is useful, for example, when forming an asymmetry between two histograms from two different data sets that need to be normalized to each other in some way. The function calculates the errors assuming Poisson statistics on h1 and h2 (that is, dh=sqrt(h)). In the next example we assume that h1 and h2 are already filled:. h3 = h1->GetAsymmetry(h2);. Then h3 is created and filled with the asymmetry between h1 and h2 ; h1 and h2 are left intact.; Note that the user’s responsibility is to manage the created histograms.; TH1::Reset() - resets the bin contents and errors of a histogram. 3.13 Important note on returned statistics (GetMean, GetStdDev, etc.); By default, histogram statistics are computed at fill time using the unbinned data used to update the bin content. This means the values returned by GetMean, GetStdDev, etc., are those of the dataset used to fill the histogram, not those of the binned content of the histogram itself, unless one of the axes has been zoomed. (See the documentation on TH1::GetStats().) This is useful if you want to keep track of the mean and standard deviation of the dataset you are visualizing with the histogram, but it can lead to some unintuitive results.; Fo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:118055,Availability,error,errors,118055,".; TH1::GetEntries() - returns the number of entries.; TH1::GetAsymmetry(TH1 *h2,Double_t c2,Double_tdc2). returns an histogram containing the asymmetry of this histogram with h2, where the asymmetry is defined as:. Asymmetry = (h1 - h2)/(h1 + h2); //where h1 = this. It works for 1D , 2D , etc. histograms. The parameter c2 is an optional argument that gives a relative weight between the two histograms, and dc 2 is the error on this weight. This is useful, for example, when forming an asymmetry between two histograms from two different data sets that need to be normalized to each other in some way. The function calculates the errors assuming Poisson statistics on h1 and h2 (that is, dh=sqrt(h)). In the next example we assume that h1 and h2 are already filled:. h3 = h1->GetAsymmetry(h2);. Then h3 is created and filled with the asymmetry between h1 and h2 ; h1 and h2 are left intact.; Note that the user’s responsibility is to manage the created histograms.; TH1::Reset() - resets the bin contents and errors of a histogram. 3.13 Important note on returned statistics (GetMean, GetStdDev, etc.); By default, histogram statistics are computed at fill time using the unbinned data used to update the bin content. This means the values returned by GetMean, GetStdDev, etc., are those of the dataset used to fill the histogram, not those of the binned content of the histogram itself, unless one of the axes has been zoomed. (See the documentation on TH1::GetStats().) This is useful if you want to keep track of the mean and standard deviation of the dataset you are visualizing with the histogram, but it can lead to some unintuitive results.; For example, suppose you have a histogram with one bin between 0 and 100, then you fill it with a Gaussian dataset with mean 20 and standard deviation 2:; TH1F * h = new TH1F(""h"", ""h"", 1, 0, 100);; for(int i=0; i<10000; i++) h->Fill(gRandom->Gaus(20, 2));; Right now, h->GetMean() will return 20 and h->GetStdDev() will return 2; ROOT calculated the",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:123055,Availability,down,down,123055,"e in $ROOTSYS/tutorials/tree/cernstaff.C.; If a variable is defined as char* it is drawn as a string by default. You change that and draw the value of char[0] as an integer by adding an arithmetic operation to the expression as shown below.; // draw the integer value of MyChar[0] where ""MyChar"" is char[5]; tree.Draw(""MyChar + 0"");; 3.14.4 Sort Options; When using the options 2 or 3 above, the labels are automatically added to the list (THashList) of labels for a given axis. By default, an axis is drawn with the order of bins corresponding to the filling sequence. It is possible to reorder the axis alphabetically or by increasing or decreasing values. The reordering can be triggered via the TAxis context menu by selecting the menu item “LabelsOption” or by calling directly.; TH1::LabelsOption(option,axis);; Here axis may be X, Y, or Z. The parameter option may be:. “a” sort by alphabetic order; “>” sort by decreasing values; “<” sort by increasing values; “h” draw labels horizontal; “v” draw labels vertical; “u” draw labels up (end of label right adjusted); “d” draw labels down (start of label left adjusted). When using the option second above, new labels are added by doubling the current number of bins in case one label does not exist yet. When the filling is terminated, it is possible to trim the number of bins to match the number of active labels by calling:; TH1::LabelsDeflate(axis);; Here axis may be X, Y, or Z. This operation is automatic when using TTree::Draw . Once bin labels have been created, they become persistent if the histogram is written to a file or when generating the C++ code via SavePrimitive .; 3.15 Histogram Stacks; A THStack is a collection of TH1 (or derived) objects. Use THStack::Add( TH1 *h) to add a histogram to the stack. The THStack does not own the objects in the list. Stacked histograms. By default, THStack::Draw draws the histograms stacked as shown in the left pad in the picture above. If the option ""nostack"" is used, the histograms ar",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:126687,Availability,error,error,126687,"n 2; h2p->Fill(-0.7, -0.5, 1); // fill bin 2; h2p->Fill( 1, 3, 5); // fill bin 3; }; More examples can bin found in $ROOTSYS/tutorials/hist/th2poly*.C. A TH2Poly histogram example. 3.17 Profile Histograms; Profile histograms are in many cases an elegant replacement of two-dimensional histograms. The relationship of two quantities X and Y can be visualized by a two-dimensional histogram or a scatter-plot; its representation is not particularly satisfactory, except for sparse data. If Y is an unknown [but single-valued] function of X, it can be displayed by a profile histogram with much better precision than by a scatter-plot. Profile histograms display the mean value of Y and its RMS for each bin in X. The following shows the contents [capital letters] and the values shown in the graphics [small letters] of the elements for bin j. When you fill a profile histogram with TProfile.Fill(x,y) :. H[j] will contain for each bin j the sum of the y values for this bin; L[j] contains the number of entries in the bin j; e[j] or s[j] will be the resulting error depending on the selected option. See “Build Options”. E[j] = sum Y**2; L[j] = number of entries in bin J; H[j] = sum Y; h[j] = H[j] / L[j]; s[j] = sqrt[E[j] / L[j] - h[j]**2]; e[j] = s[j] / sqrt[L[j]]; In the special case where s[j] is zero, when there is only one entry per bin, e[j] is computed from the average of the s[j] for all bins. This approximation is used to keep the bin during a fit operation. The TProfile constructor takes up to eight arguments. The first five parameters are similar to TH1D constructor.; TProfile(const char *name,const char *title,Int_t nbinsx,; Double_t xlow, Double_t xup, Double_t ylow, Double_t yup,; Option_t *option); All values of y are accepted at filling time. To fill a profile histogram, you must use TProfile::Fill function. Note that when filling the profile histogram the method TProfile::Fill checks if the variable y is between fYmin and fYmax. If a minimum or maximum value is set fo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:128210,Availability,error,error,128210,"*name,const char *title,Int_t nbinsx,; Double_t xlow, Double_t xup, Double_t ylow, Double_t yup,; Option_t *option); All values of y are accepted at filling time. To fill a profile histogram, you must use TProfile::Fill function. Note that when filling the profile histogram the method TProfile::Fill checks if the variable y is between fYmin and fYmax. If a minimum or maximum value is set for the Y scale before filling, then all values below ylow or above yup will be discarded. Setting the minimum or maximum value for the Y scale before filling has the same effect as calling the special TProfile constructor above where ylow and yup are specified.; 3.17.1 Build Options; The last parameter is the build option. If a bin has N data points all with the same value Y, which is the case when dealing with integers, the spread in Y for that bin is zero, and the uncertainty assigned is also zero, and the bin is ignored in making subsequent fits. If SQRT(Y) was the correct error in the case above, then SQRT(Y)/SQRT(N) would be the correct error here. In fact, any bin with non-zero number of entries N but with zero spread (spread = s[j]) should have an uncertainty SQRT(Y)/SQRT(N). Now, is SQRT(Y)/SQRT(N) really the correct uncertainty ? That it is only in the case where the Y variable is some sort of counting statistics, following a Poisson distribution. This is the default case. However, Y can be any variable from an original NTUPLE, and does not necessarily follow a Poisson distribution. The computation of errors is based on Y = values of data points; N = number of data points. ' ' - the default is blank, the errors are:; spread/SQRT(N) for a non-zero spread; SQRT(Y)/SQRT(N) for a spread of zero and some data points; 0 for no data points; ‘ s ’ - errors are:; spread for a non-zero spread; SQRT(Y) for a Spread of zero and some data points; 0 for no data points; ‘ i ’ - errors are:; spread/SQRT(N) for a non-zero spread; 1/SQRT(12*N) for a Spread of zero and some data points; 0 fo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:128277,Availability,error,error,128277,"*name,const char *title,Int_t nbinsx,; Double_t xlow, Double_t xup, Double_t ylow, Double_t yup,; Option_t *option); All values of y are accepted at filling time. To fill a profile histogram, you must use TProfile::Fill function. Note that when filling the profile histogram the method TProfile::Fill checks if the variable y is between fYmin and fYmax. If a minimum or maximum value is set for the Y scale before filling, then all values below ylow or above yup will be discarded. Setting the minimum or maximum value for the Y scale before filling has the same effect as calling the special TProfile constructor above where ylow and yup are specified.; 3.17.1 Build Options; The last parameter is the build option. If a bin has N data points all with the same value Y, which is the case when dealing with integers, the spread in Y for that bin is zero, and the uncertainty assigned is also zero, and the bin is ignored in making subsequent fits. If SQRT(Y) was the correct error in the case above, then SQRT(Y)/SQRT(N) would be the correct error here. In fact, any bin with non-zero number of entries N but with zero spread (spread = s[j]) should have an uncertainty SQRT(Y)/SQRT(N). Now, is SQRT(Y)/SQRT(N) really the correct uncertainty ? That it is only in the case where the Y variable is some sort of counting statistics, following a Poisson distribution. This is the default case. However, Y can be any variable from an original NTUPLE, and does not necessarily follow a Poisson distribution. The computation of errors is based on Y = values of data points; N = number of data points. ' ' - the default is blank, the errors are:; spread/SQRT(N) for a non-zero spread; SQRT(Y)/SQRT(N) for a spread of zero and some data points; 0 for no data points; ‘ s ’ - errors are:; spread for a non-zero spread; SQRT(Y) for a Spread of zero and some data points; 0 for no data points; ‘ i ’ - errors are:; spread/SQRT(N) for a non-zero spread; 1/SQRT(12*N) for a Spread of zero and some data points; 0 fo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:128755,Availability,error,errors,128755,"ing has the same effect as calling the special TProfile constructor above where ylow and yup are specified.; 3.17.1 Build Options; The last parameter is the build option. If a bin has N data points all with the same value Y, which is the case when dealing with integers, the spread in Y for that bin is zero, and the uncertainty assigned is also zero, and the bin is ignored in making subsequent fits. If SQRT(Y) was the correct error in the case above, then SQRT(Y)/SQRT(N) would be the correct error here. In fact, any bin with non-zero number of entries N but with zero spread (spread = s[j]) should have an uncertainty SQRT(Y)/SQRT(N). Now, is SQRT(Y)/SQRT(N) really the correct uncertainty ? That it is only in the case where the Y variable is some sort of counting statistics, following a Poisson distribution. This is the default case. However, Y can be any variable from an original NTUPLE, and does not necessarily follow a Poisson distribution. The computation of errors is based on Y = values of data points; N = number of data points. ' ' - the default is blank, the errors are:; spread/SQRT(N) for a non-zero spread; SQRT(Y)/SQRT(N) for a spread of zero and some data points; 0 for no data points; ‘ s ’ - errors are:; spread for a non-zero spread; SQRT(Y) for a Spread of zero and some data points; 0 for no data points; ‘ i ’ - errors are:; spread/SQRT(N) for a non-zero spread; 1/SQRT(12*N) for a Spread of zero and some data points; 0 for no data points; ‘ G ’ - errors are:; spread/SQRT(N) for a non-zero spread; sigma/SQRT(N) for a spread of zero and some data points; 0 for no data points. The option ’ i ’ is used for integer Y values with the uncertainty of \(\pm 0.5\), assuming the probability that Y takes any value between Y-0.5 and Y+0.5 is uniform (the same argument for Y uniformly distributed between Y and Y+1). An example is an ADC measurement. The ‘G’ option is useful, if all Y variables are distributed according to some known Gaussian of standard deviation Sigma. ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:128860,Availability,error,errors,128860,"y assigned is also zero, and the bin is ignored in making subsequent fits. If SQRT(Y) was the correct error in the case above, then SQRT(Y)/SQRT(N) would be the correct error here. In fact, any bin with non-zero number of entries N but with zero spread (spread = s[j]) should have an uncertainty SQRT(Y)/SQRT(N). Now, is SQRT(Y)/SQRT(N) really the correct uncertainty ? That it is only in the case where the Y variable is some sort of counting statistics, following a Poisson distribution. This is the default case. However, Y can be any variable from an original NTUPLE, and does not necessarily follow a Poisson distribution. The computation of errors is based on Y = values of data points; N = number of data points. ' ' - the default is blank, the errors are:; spread/SQRT(N) for a non-zero spread; SQRT(Y)/SQRT(N) for a spread of zero and some data points; 0 for no data points; ‘ s ’ - errors are:; spread for a non-zero spread; SQRT(Y) for a Spread of zero and some data points; 0 for no data points; ‘ i ’ - errors are:; spread/SQRT(N) for a non-zero spread; 1/SQRT(12*N) for a Spread of zero and some data points; 0 for no data points; ‘ G ’ - errors are:; spread/SQRT(N) for a non-zero spread; sigma/SQRT(N) for a spread of zero and some data points; 0 for no data points. The option ’ i ’ is used for integer Y values with the uncertainty of \(\pm 0.5\), assuming the probability that Y takes any value between Y-0.5 and Y+0.5 is uniform (the same argument for Y uniformly distributed between Y and Y+1). An example is an ADC measurement. The ‘G’ option is useful, if all Y variables are distributed according to some known Gaussian of standard deviation Sigma. For example when all Y’s are experimental quantities measured with the same instrument with precision Sigma. The next figure shows the graphic output of this simple example of a profile histogram.; {; // Create a canvas giving the coordinates and the size; TCanvas *c1 = new TCanvas(""c1"", ""Profile example"",200,10,700,500);. // ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:129000,Availability,error,errors,129000,"y assigned is also zero, and the bin is ignored in making subsequent fits. If SQRT(Y) was the correct error in the case above, then SQRT(Y)/SQRT(N) would be the correct error here. In fact, any bin with non-zero number of entries N but with zero spread (spread = s[j]) should have an uncertainty SQRT(Y)/SQRT(N). Now, is SQRT(Y)/SQRT(N) really the correct uncertainty ? That it is only in the case where the Y variable is some sort of counting statistics, following a Poisson distribution. This is the default case. However, Y can be any variable from an original NTUPLE, and does not necessarily follow a Poisson distribution. The computation of errors is based on Y = values of data points; N = number of data points. ' ' - the default is blank, the errors are:; spread/SQRT(N) for a non-zero spread; SQRT(Y)/SQRT(N) for a spread of zero and some data points; 0 for no data points; ‘ s ’ - errors are:; spread for a non-zero spread; SQRT(Y) for a Spread of zero and some data points; 0 for no data points; ‘ i ’ - errors are:; spread/SQRT(N) for a non-zero spread; 1/SQRT(12*N) for a Spread of zero and some data points; 0 for no data points; ‘ G ’ - errors are:; spread/SQRT(N) for a non-zero spread; sigma/SQRT(N) for a spread of zero and some data points; 0 for no data points. The option ’ i ’ is used for integer Y values with the uncertainty of \(\pm 0.5\), assuming the probability that Y takes any value between Y-0.5 and Y+0.5 is uniform (the same argument for Y uniformly distributed between Y and Y+1). An example is an ADC measurement. The ‘G’ option is useful, if all Y variables are distributed according to some known Gaussian of standard deviation Sigma. For example when all Y’s are experimental quantities measured with the same instrument with precision Sigma. The next figure shows the graphic output of this simple example of a profile histogram.; {; // Create a canvas giving the coordinates and the size; TCanvas *c1 = new TCanvas(""c1"", ""Profile example"",200,10,700,500);. // ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:129124,Availability,error,errors,129124,"y assigned is also zero, and the bin is ignored in making subsequent fits. If SQRT(Y) was the correct error in the case above, then SQRT(Y)/SQRT(N) would be the correct error here. In fact, any bin with non-zero number of entries N but with zero spread (spread = s[j]) should have an uncertainty SQRT(Y)/SQRT(N). Now, is SQRT(Y)/SQRT(N) really the correct uncertainty ? That it is only in the case where the Y variable is some sort of counting statistics, following a Poisson distribution. This is the default case. However, Y can be any variable from an original NTUPLE, and does not necessarily follow a Poisson distribution. The computation of errors is based on Y = values of data points; N = number of data points. ' ' - the default is blank, the errors are:; spread/SQRT(N) for a non-zero spread; SQRT(Y)/SQRT(N) for a spread of zero and some data points; 0 for no data points; ‘ s ’ - errors are:; spread for a non-zero spread; SQRT(Y) for a Spread of zero and some data points; 0 for no data points; ‘ i ’ - errors are:; spread/SQRT(N) for a non-zero spread; 1/SQRT(12*N) for a Spread of zero and some data points; 0 for no data points; ‘ G ’ - errors are:; spread/SQRT(N) for a non-zero spread; sigma/SQRT(N) for a spread of zero and some data points; 0 for no data points. The option ’ i ’ is used for integer Y values with the uncertainty of \(\pm 0.5\), assuming the probability that Y takes any value between Y-0.5 and Y+0.5 is uniform (the same argument for Y uniformly distributed between Y and Y+1). An example is an ADC measurement. The ‘G’ option is useful, if all Y variables are distributed according to some known Gaussian of standard deviation Sigma. For example when all Y’s are experimental quantities measured with the same instrument with precision Sigma. The next figure shows the graphic output of this simple example of a profile histogram.; {; // Create a canvas giving the coordinates and the size; TCanvas *c1 = new TCanvas(""c1"", ""Profile example"",200,10,700,500);. // ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:129261,Availability,error,errors,129261,"y assigned is also zero, and the bin is ignored in making subsequent fits. If SQRT(Y) was the correct error in the case above, then SQRT(Y)/SQRT(N) would be the correct error here. In fact, any bin with non-zero number of entries N but with zero spread (spread = s[j]) should have an uncertainty SQRT(Y)/SQRT(N). Now, is SQRT(Y)/SQRT(N) really the correct uncertainty ? That it is only in the case where the Y variable is some sort of counting statistics, following a Poisson distribution. This is the default case. However, Y can be any variable from an original NTUPLE, and does not necessarily follow a Poisson distribution. The computation of errors is based on Y = values of data points; N = number of data points. ' ' - the default is blank, the errors are:; spread/SQRT(N) for a non-zero spread; SQRT(Y)/SQRT(N) for a spread of zero and some data points; 0 for no data points; ‘ s ’ - errors are:; spread for a non-zero spread; SQRT(Y) for a Spread of zero and some data points; 0 for no data points; ‘ i ’ - errors are:; spread/SQRT(N) for a non-zero spread; 1/SQRT(12*N) for a Spread of zero and some data points; 0 for no data points; ‘ G ’ - errors are:; spread/SQRT(N) for a non-zero spread; sigma/SQRT(N) for a spread of zero and some data points; 0 for no data points. The option ’ i ’ is used for integer Y values with the uncertainty of \(\pm 0.5\), assuming the probability that Y takes any value between Y-0.5 and Y+0.5 is uniform (the same argument for Y uniformly distributed between Y and Y+1). An example is an ADC measurement. The ‘G’ option is useful, if all Y variables are distributed according to some known Gaussian of standard deviation Sigma. For example when all Y’s are experimental quantities measured with the same instrument with precision Sigma. The next figure shows the graphic output of this simple example of a profile histogram.; {; // Create a canvas giving the coordinates and the size; TCanvas *c1 = new TCanvas(""c1"", ""Profile example"",200,10,700,500);. // ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:130812,Availability,error,error,130812,"l Y’s are experimental quantities measured with the same instrument with precision Sigma. The next figure shows the graphic output of this simple example of a profile histogram.; {; // Create a canvas giving the coordinates and the size; TCanvas *c1 = new TCanvas(""c1"", ""Profile example"",200,10,700,500);. // Create a profile with the name, title, the number of bins,; // the low and high limit of the x-axis and the low and high; // limit of the y-axis.; // No option is given so the default is used.; hprof = new TProfile(""hprof"",; ""Profile of pz versus px"",100,-4,4,0,20);. // Fill the profile 25000 times with random numbers; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; // Use the random number generator to get two numbers following; // a gaussian distribution with mean=0 and sigma=1; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof->Fill(px,pz,1);; }; hprof->Draw();; }. A profile histogram example. 3.17.2 Drawing a Profile without Error Bars; To draw a profile histogram and not show the error bars use the “HIST” option in the TProfile::Draw method. This will draw the outline of the TProfile.; 3.17.3 Create a Profile from a 2D Histogram; You can make a profile from a histogram using the methods TH2::ProfileX and TH2::ProfileY.; 3.17.4 Create a Histogram from a Profile; To create a regular histogram from a profile histogram, use the method TProfile::ProjectionX .This example instantiates a TH1D object by copying the TH1D piece of TProfile.; TH1D *sum = myProfile.ProjectionX();; You can do the same with a 2D profile using the method TProfile2D::ProjectionXY .; 3.17.5 Generating a Profile from a TTree; The 'prof' and 'profs' options in the TTree::Draw method generate a profile histogram ( TProfile ), given a two dimensional expression in the tree, or a TProfile2D given a three dimensional expression. See “Trees”. Note that you can specify 'prof' or 'profs' : 'prof' generates a TProfile with error on the mean, 'profs' generates a TProfile with error on the sprea",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:131730,Availability,error,error,131730,".2 Drawing a Profile without Error Bars; To draw a profile histogram and not show the error bars use the “HIST” option in the TProfile::Draw method. This will draw the outline of the TProfile.; 3.17.3 Create a Profile from a 2D Histogram; You can make a profile from a histogram using the methods TH2::ProfileX and TH2::ProfileY.; 3.17.4 Create a Histogram from a Profile; To create a regular histogram from a profile histogram, use the method TProfile::ProjectionX .This example instantiates a TH1D object by copying the TH1D piece of TProfile.; TH1D *sum = myProfile.ProjectionX();; You can do the same with a 2D profile using the method TProfile2D::ProjectionXY .; 3.17.5 Generating a Profile from a TTree; The 'prof' and 'profs' options in the TTree::Draw method generate a profile histogram ( TProfile ), given a two dimensional expression in the tree, or a TProfile2D given a three dimensional expression. See “Trees”. Note that you can specify 'prof' or 'profs' : 'prof' generates a TProfile with error on the mean, 'profs' generates a TProfile with error on the spread.; 3.17.6 2D Profiles; The class for a 2D Profile is called TProfile2D . It is in many cases an elegant replacement of a three-dimensional histogram. The relationship of three measured quantities X, Y and Z can be visualized by a three-dimensional histogram or scatter-plot; its representation is not particularly satisfactory, except for sparse data. If Z is an unknown (but single-valued) function of (X,Y), it can be displayed with a TProfile2D with better precision than by a scatter-plot. A TProfile2D displays the mean value of Z and its RMS for each cell in X, Y. The following shows the cumulated contents (capital letters) and the values displayed (small letters) of the elements for cell i,j.; When you fill a profile histogram with TProfile2D.Fill(x,y,z):. E[i,j] contains for each bin i,j the sum of the z values for this bin; L[i,j] contains the number of entries in the bin j; e[j] or s[j] will be the resulting",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:131783,Availability,error,error,131783,".2 Drawing a Profile without Error Bars; To draw a profile histogram and not show the error bars use the “HIST” option in the TProfile::Draw method. This will draw the outline of the TProfile.; 3.17.3 Create a Profile from a 2D Histogram; You can make a profile from a histogram using the methods TH2::ProfileX and TH2::ProfileY.; 3.17.4 Create a Histogram from a Profile; To create a regular histogram from a profile histogram, use the method TProfile::ProjectionX .This example instantiates a TH1D object by copying the TH1D piece of TProfile.; TH1D *sum = myProfile.ProjectionX();; You can do the same with a 2D profile using the method TProfile2D::ProjectionXY .; 3.17.5 Generating a Profile from a TTree; The 'prof' and 'profs' options in the TTree::Draw method generate a profile histogram ( TProfile ), given a two dimensional expression in the tree, or a TProfile2D given a three dimensional expression. See “Trees”. Note that you can specify 'prof' or 'profs' : 'prof' generates a TProfile with error on the mean, 'profs' generates a TProfile with error on the spread.; 3.17.6 2D Profiles; The class for a 2D Profile is called TProfile2D . It is in many cases an elegant replacement of a three-dimensional histogram. The relationship of three measured quantities X, Y and Z can be visualized by a three-dimensional histogram or scatter-plot; its representation is not particularly satisfactory, except for sparse data. If Z is an unknown (but single-valued) function of (X,Y), it can be displayed with a TProfile2D with better precision than by a scatter-plot. A TProfile2D displays the mean value of Z and its RMS for each cell in X, Y. The following shows the cumulated contents (capital letters) and the values displayed (small letters) of the elements for cell i,j.; When you fill a profile histogram with TProfile2D.Fill(x,y,z):. E[i,j] contains for each bin i,j the sum of the z values for this bin; L[i,j] contains the number of entries in the bin j; e[j] or s[j] will be the resulting",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:132728,Availability,error,error,132728," specify 'prof' or 'profs' : 'prof' generates a TProfile with error on the mean, 'profs' generates a TProfile with error on the spread.; 3.17.6 2D Profiles; The class for a 2D Profile is called TProfile2D . It is in many cases an elegant replacement of a three-dimensional histogram. The relationship of three measured quantities X, Y and Z can be visualized by a three-dimensional histogram or scatter-plot; its representation is not particularly satisfactory, except for sparse data. If Z is an unknown (but single-valued) function of (X,Y), it can be displayed with a TProfile2D with better precision than by a scatter-plot. A TProfile2D displays the mean value of Z and its RMS for each cell in X, Y. The following shows the cumulated contents (capital letters) and the values displayed (small letters) of the elements for cell i,j.; When you fill a profile histogram with TProfile2D.Fill(x,y,z):. E[i,j] contains for each bin i,j the sum of the z values for this bin; L[i,j] contains the number of entries in the bin j; e[j] or s[j] will be the resulting error depending on the selected option. See “Build Options”. E[i,j] = sum z; L[i,j] = sum l; h[i,j] = H[i,j ] / L[i,j]; s[i,j] = sqrt[E[i,j] / L[i,j]- h[i,j]**2]; e[i,j] = s[i,j] / sqrt[L[i,j]]; In the special case where s[i,j] is zero, when there is only one entry per cell, e[i,j] is computed from the average of the s[i,j] for all cells. This approximation is used to keep the cell during a fit operation. A TProfile2D histogram example. {; // Creating a Canvas and a TProfile2D; TCanvas *c1 = new TCanvas(""c1"",; ""Profile histogram example"",; 200, 10,700,500);; hprof2d = new TProfile2D(""hprof2d"",; ""Profile of pz versus px and py"",; 40,-4,4,40,-4,4,0,20);. // Filling the TProfile2D with 25000 points; Float_t px, py, pz;; for (Int_t i=0; i<25000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof2d->Fill(px,py,pz,1);; }; hprof2d->Draw();; }; 3.18 Iso Surfaces; Paint one Gouraud shaded 3d iso surface though a 3d histogram a",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:135491,Availability,error,error,135491,"ffect.; “NOL” No OutLine: do not draw the slices’ outlines; any property over the slices’ line is ignored. The method SetLabelFormat() is used to customize the label format. The format string must contain one of these modifiers:. %txt : to print the text label associated with the slice. %val : to print the numeric value of the slice. %frac : to print the relative fraction of this slice. %perc : to print the % of this slice. mypie->SetLabelFormat(""%txt (%frac)"");; See the macro $ROOTSYS/tutorials/graphics/piechart.C . The picture generated by tutorial macro piechart.C. 3.21 The User Interface for Histograms; The classes T H1 Editor and T H2 Editor provides the user interface for setting histogram’s attributes and rebinning interactively.; 3.21.1 TH1Editor. 3.21.1.1 The Style Tab; 3.21.1.1.1 Title; sets the title of the histogram.; 3.21.1.1.2 Plot; draw a 2D or 3D plot; according to the dimension, different drawing possibilities can be set.; 3.21.1.1.3 Error; add different error bars to the histogram (no errors, simple, etc.).; 3.21.1.1.4 Add; further things which can be added to the histogram (None, simple/smooth line, fill area, etc.); 3.21.1.2 2-D Plot; 3.21.1.2.1 Simple Drawing; draw a simple histogram without errors (= “HIST” draw option). In combination with some other draw options an outer line is drawn on top of the histogram; 3.21.1.2.2 Show markers; draw a marker on to of each bin (=“P” draw option).; 3.21.1.2.3 Draw bar chart; draw a bar chart (=“B” draw option).; 3.21.1.2.4 Bar option; draw a bar chart (=“BAR” draw option); if selected, it will show an additional interface elements for bars: width, offset, percentage and the possibility to draw horizontal bars.; 3.21.1.3 3-D Plot; 3.21.1.3.1 Add; set histogram type Lego-Plot or Surface draw (Lego, Lego1.2, Surf, Surf1…5).; 3.21.1.3.2 Coords; set the coordinate system (Cartesian, Spheric, etc.).; 3.21.1.3.3 Error; same as for 2D plot.; 3.21.1.3.4 Bar; set the bar attributes: width and offset.; 3.21.1.3.5 Hor",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:135523,Availability,error,errors,135523,"ffect.; “NOL” No OutLine: do not draw the slices’ outlines; any property over the slices’ line is ignored. The method SetLabelFormat() is used to customize the label format. The format string must contain one of these modifiers:. %txt : to print the text label associated with the slice. %val : to print the numeric value of the slice. %frac : to print the relative fraction of this slice. %perc : to print the % of this slice. mypie->SetLabelFormat(""%txt (%frac)"");; See the macro $ROOTSYS/tutorials/graphics/piechart.C . The picture generated by tutorial macro piechart.C. 3.21 The User Interface for Histograms; The classes T H1 Editor and T H2 Editor provides the user interface for setting histogram’s attributes and rebinning interactively.; 3.21.1 TH1Editor. 3.21.1.1 The Style Tab; 3.21.1.1.1 Title; sets the title of the histogram.; 3.21.1.1.2 Plot; draw a 2D or 3D plot; according to the dimension, different drawing possibilities can be set.; 3.21.1.1.3 Error; add different error bars to the histogram (no errors, simple, etc.).; 3.21.1.1.4 Add; further things which can be added to the histogram (None, simple/smooth line, fill area, etc.); 3.21.1.2 2-D Plot; 3.21.1.2.1 Simple Drawing; draw a simple histogram without errors (= “HIST” draw option). In combination with some other draw options an outer line is drawn on top of the histogram; 3.21.1.2.2 Show markers; draw a marker on to of each bin (=“P” draw option).; 3.21.1.2.3 Draw bar chart; draw a bar chart (=“B” draw option).; 3.21.1.2.4 Bar option; draw a bar chart (=“BAR” draw option); if selected, it will show an additional interface elements for bars: width, offset, percentage and the possibility to draw horizontal bars.; 3.21.1.3 3-D Plot; 3.21.1.3.1 Add; set histogram type Lego-Plot or Surface draw (Lego, Lego1.2, Surf, Surf1…5).; 3.21.1.3.2 Coords; set the coordinate system (Cartesian, Spheric, etc.).; 3.21.1.3.3 Error; same as for 2D plot.; 3.21.1.3.4 Bar; set the bar attributes: width and offset.; 3.21.1.3.5 Hor",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:135737,Availability,error,errors,135737,"fiers:. %txt : to print the text label associated with the slice. %val : to print the numeric value of the slice. %frac : to print the relative fraction of this slice. %perc : to print the % of this slice. mypie->SetLabelFormat(""%txt (%frac)"");; See the macro $ROOTSYS/tutorials/graphics/piechart.C . The picture generated by tutorial macro piechart.C. 3.21 The User Interface for Histograms; The classes T H1 Editor and T H2 Editor provides the user interface for setting histogram’s attributes and rebinning interactively.; 3.21.1 TH1Editor. 3.21.1.1 The Style Tab; 3.21.1.1.1 Title; sets the title of the histogram.; 3.21.1.1.2 Plot; draw a 2D or 3D plot; according to the dimension, different drawing possibilities can be set.; 3.21.1.1.3 Error; add different error bars to the histogram (no errors, simple, etc.).; 3.21.1.1.4 Add; further things which can be added to the histogram (None, simple/smooth line, fill area, etc.); 3.21.1.2 2-D Plot; 3.21.1.2.1 Simple Drawing; draw a simple histogram without errors (= “HIST” draw option). In combination with some other draw options an outer line is drawn on top of the histogram; 3.21.1.2.2 Show markers; draw a marker on to of each bin (=“P” draw option).; 3.21.1.2.3 Draw bar chart; draw a bar chart (=“B” draw option).; 3.21.1.2.4 Bar option; draw a bar chart (=“BAR” draw option); if selected, it will show an additional interface elements for bars: width, offset, percentage and the possibility to draw horizontal bars.; 3.21.1.3 3-D Plot; 3.21.1.3.1 Add; set histogram type Lego-Plot or Surface draw (Lego, Lego1.2, Surf, Surf1…5).; 3.21.1.3.2 Coords; set the coordinate system (Cartesian, Spheric, etc.).; 3.21.1.3.3 Error; same as for 2D plot.; 3.21.1.3.4 Bar; set the bar attributes: width and offset.; 3.21.1.3.5 Horizontal Bar; draw a horizontal bar chart.; 3.21.1.4 The Binning tab; The binning tab has two different layouts. One is for a histogram, which is not drawn from an ntuple. The other one is available for a histogram, which ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:136694,Availability,avail,available,136694,"imple histogram without errors (= “HIST” draw option). In combination with some other draw options an outer line is drawn on top of the histogram; 3.21.1.2.2 Show markers; draw a marker on to of each bin (=“P” draw option).; 3.21.1.2.3 Draw bar chart; draw a bar chart (=“B” draw option).; 3.21.1.2.4 Bar option; draw a bar chart (=“BAR” draw option); if selected, it will show an additional interface elements for bars: width, offset, percentage and the possibility to draw horizontal bars.; 3.21.1.3 3-D Plot; 3.21.1.3.1 Add; set histogram type Lego-Plot or Surface draw (Lego, Lego1.2, Surf, Surf1…5).; 3.21.1.3.2 Coords; set the coordinate system (Cartesian, Spheric, etc.).; 3.21.1.3.3 Error; same as for 2D plot.; 3.21.1.3.4 Bar; set the bar attributes: width and offset.; 3.21.1.3.5 Horizontal Bar; draw a horizontal bar chart.; 3.21.1.4 The Binning tab; The binning tab has two different layouts. One is for a histogram, which is not drawn from an ntuple. The other one is available for a histogram, which is drawn from an ntuple. In this case, the rebin algorithm can create a rebinned histogram from the original data i.e. the ntuple. To see the differences do:; TFile f(""hsimple.root"");; hpx->Draw(""BAR1""); // non ntuple histogram; ntuple->Draw(""px"");// ntuple histogram; 3.21.1.5 Non ntuple histogram; Rebin with a slider and the number of bins (shown in the field below the slider). The number of bins can be changed to any number, which divides the number of bins of the original histogram. A click on the Apply button will delete the origin histogram and will replace it by the rebinned one on the screen. A click on the Ignore button will restore the origin histogram.; 3.21.1.6 Histogram drawn from an ntuple; 3.21.1.6.1 Rebin; with the slider, the number of bins can be enlarged by a factor of 2, 3, 4, 5 (moving to the right) or reduced by a factor of \(\frac{1}{2}\), \(\frac{1}{3}\), \(\frac{1}{4}\), \(\frac{1}{5}\).; 3.21.1.6.2 BinOffset with a BinOffset slider; the origin of t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:139388,Availability,error,errors,139388,"am; change the draw options of the histogram.; 3.21.2.1.3 Plot; draw a 2D or 3D plot of the histogram; according to the dimension, the drawing possibilities are different.; 3.21.2.2 2-D Plot; 3.21.2.2.1 Contour; draw a contour plot (None, Cont0…5); 3.21.2.2.2 Cont #; set the number of Contours;; 3.21.2.2.3 Arrow; set the arrow mode and shows the gradient between adjacent cells;; 3.21.2.2.4 Col; a box is drawn for each cell with a color scale varying with contents;; 3.21.2.2.5 Text; draw bin contents as text;; 3.21.2.2.6 Box; a box is drawn for each cell with surface proportional to contents;; 3.21.2.2.7 Scat; draw a scatter-plot (default);; 3.21.2.2.8 Palette; the color palette is drawn.; 3.21.2.3 3-D Plot; 3.21.2.3.1 Type; set histogram type to Lego or surface plot; draw (Lego, Lego1.2, Surf, Surf1…5); 3.21.2.3.2 Coords; set the coordinate system (Cartesian, Spheric, etc.);; 3.21.2.3.3 Cont #; set the number of Contours (for e.g. Lego2 draw option);; 3.21.2.3.4 Errors; draw errors in a Cartesian lego plot;; 3.21.2.3.5 Palette; draw the color palette;; 3.21.2.3.6 Front; draw the front box of a Cartesian lego plot;; 3.21.2.3.7 Back; draw the back box of a Cartesian lego plot;; 3.21.2.3.8 Bar; change the bar attributes: the width and offset.; 3.21.2.4 Rebinning Tab; The Rebinning tab has two different layouts. One is for a histogram that is not drawn from an ntuple; the other one is available for a histogram, which is drawn from an ntuple. In this case, the rebin algorithm can create a rebinned histogram from the original data i.e. the ntuple. To see the differences do for example:; TFile f (""hsimple.root"");; hpxpy->Draw(""Lego2""); // non ntuple histogram; ntuple->Draw(""px:py"","""",""Lego2""); // ntuple histogram; 3.21.2.5 Non-ntuple histogram:; Rebin with sliders (one for the x, one for the y-axis) and the number of bins (shown in the field below them can be changed to any number, which divides the number of bins of the original histogram. Selecting the Apply button will d",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:139802,Availability,avail,available,139802,"l; a box is drawn for each cell with a color scale varying with contents;; 3.21.2.2.5 Text; draw bin contents as text;; 3.21.2.2.6 Box; a box is drawn for each cell with surface proportional to contents;; 3.21.2.2.7 Scat; draw a scatter-plot (default);; 3.21.2.2.8 Palette; the color palette is drawn.; 3.21.2.3 3-D Plot; 3.21.2.3.1 Type; set histogram type to Lego or surface plot; draw (Lego, Lego1.2, Surf, Surf1…5); 3.21.2.3.2 Coords; set the coordinate system (Cartesian, Spheric, etc.);; 3.21.2.3.3 Cont #; set the number of Contours (for e.g. Lego2 draw option);; 3.21.2.3.4 Errors; draw errors in a Cartesian lego plot;; 3.21.2.3.5 Palette; draw the color palette;; 3.21.2.3.6 Front; draw the front box of a Cartesian lego plot;; 3.21.2.3.7 Back; draw the back box of a Cartesian lego plot;; 3.21.2.3.8 Bar; change the bar attributes: the width and offset.; 3.21.2.4 Rebinning Tab; The Rebinning tab has two different layouts. One is for a histogram that is not drawn from an ntuple; the other one is available for a histogram, which is drawn from an ntuple. In this case, the rebin algorithm can create a rebinned histogram from the original data i.e. the ntuple. To see the differences do for example:; TFile f (""hsimple.root"");; hpxpy->Draw(""Lego2""); // non ntuple histogram; ntuple->Draw(""px:py"","""",""Lego2""); // ntuple histogram; 3.21.2.5 Non-ntuple histogram:; Rebin with sliders (one for the x, one for the y-axis) and the number of bins (shown in the field below them can be changed to any number, which divides the number of bins of the original histogram. Selecting the Apply button will delete the origin histogram and will replace it by the rebinned one on the screen. Selecting the Ignore the origin histogram will be restored. 3.21.2.6 Histogram drawn from an ntuple; 3.21.2.6.1 Rebin; with the sliders the number of bins can be enlarged by a factor of 2,3,4,5 (moving to the right) or reduced by a factor of \(\frac{1}{2}\), \(\frac{1}{3}\), \(\frac{1}{4}\), \(\frac{1}{5}\).; 3",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:142950,Availability,error,error,142950,"the special case with equidistant points. Graphs are created with the TGraph constructor. First, we define the arrays of coordinates and then create the graph. The coordinates can be arrays of doubles or floats.; Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0; i<n; i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; TGraph *gr1 = new TGraph (n, x, y);; An alternative constructor takes only the number of points n. It is expected that the coordinates will be set later.; TGraph *gr2 = new TGraph(n);; The default constructor can also be used. Further calls to SetPoint() will extend the internal vectors.; TGraph *gr3 = new TGraph();; 4.1.1 Graph Draw Options; The various drawing options for a graph are explained in TGraph::PaintGraph. They are:. “L” A simple poly-line between every points is drawn; “F” A fill area is drawn; “F1” Idem as “F” but fill area is no more repartee around X=0 or Y=0; “F2” draw a fill area poly line connecting the center of bins; “A” Axis are drawn around the graph; “C” A smooth curve is drawn; “*” A star is plotted at each point; “P” The current marker of the graph is plotted at each point; “B” A bar chart is drawn at each point; “[]” Only the end vertical/horizontal lines of the error bars are drawn. This option only applies to the TGraphAsymmErrors.; “1” ylow = rwymin. The options are not case sensitive and they can be concatenated in most cases. Let us look at some examples.; 4.1.1.1 Continuous Line, Axis and Stars (AC*). A graph drawn with axis, * markers and continuous line (option AC*). {; Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }. // create graph; TGraph *gr = new TGraph(n,x,y);; TCanvas *c1 = new TCanvas(""c1"",""Graph Draw Options"",; 200,10,600,400);. // draw the graph with axis, continuous line, and put; // a * at each point; gr->Draw(""AC*"");; }; 4.1.1.2 Bar Graphs (AB). A graph drawn with axis and bar (option AB). root[] TGraph *gr1 = new TGraph(n,x,y);; root[] gr1->Set",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:145909,Availability,error,error,145909," with the axis,contineous line, and put; // a marker using the graph's marker style at each point; gr3->SetMarkerStyle(21);; c1->cd(4);; gr3->Draw(""APL"");. // get the points in the graph and put them into an array; Double_t *nx = gr3->GetX();; Double_t *ny = gr3->GetY();. // create markers of different colors; for (Int_t j=2; j<n-1; j++) {; TMarker *m = new TMarker(nx[j], 0.5*ny[j], 22);; m->SetMarkerSize(2);; m->SetMarkerColor(31+j);; m->Draw();; }; }; 4.2 Superimposing Two Graphs; To super impose two graphs you need to draw the axis only once, and leave out the “A” in the draw options for the second graph. Next is an example:. Superimposing two graphs. {; Int_t n = 20;; Double_t x[n], y[n], x1[n], y1[n];. // create a blue graph with a cos function; gr1->SetLineColor(4);; gr1->Draw(""AC*"");. // superimpose the second graph by leaving out the axis option ""A""; gr2->SetLineWidth(3);; gr2->SetMarkerStyle(21);; gr2->SetLineColor(2);; gr2->Draw(""CP"");; }; 4.3 Graphs with Error Bars; A TGraphErrors is a TGraph with error bars. The various draw format options of TGraphErrors::Paint() are derived from TGraph.; void TGraphErrors::Paint(Option_t *option). Graphs with different draw options of error bars. In addition, it can be drawn with the “Z” option to leave off the small lines at the end of the error bars. If option contains “>”, an arrow is drawn at the end of the error bars. If option contains “|>”, a full arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size.; The option “[]” is interesting to superimpose systematic errors on top of the graph with the statistical errors. When it is specified, only the end vertical/horizontal lines of the error bars are drawn.; To control the size of the lines at the end of the error bars (when option 1 is chosen) use SetEndErrorSize(np). By default np=1; np represents the number of pixels.; gStyle->SetEndErrorSize(np);; The four parameters of TGraphErrors are: X, Y (as in TGraph), X-errors, a",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:146086,Availability,error,error,146086,"and put them into an array; Double_t *nx = gr3->GetX();; Double_t *ny = gr3->GetY();. // create markers of different colors; for (Int_t j=2; j<n-1; j++) {; TMarker *m = new TMarker(nx[j], 0.5*ny[j], 22);; m->SetMarkerSize(2);; m->SetMarkerColor(31+j);; m->Draw();; }; }; 4.2 Superimposing Two Graphs; To super impose two graphs you need to draw the axis only once, and leave out the “A” in the draw options for the second graph. Next is an example:. Superimposing two graphs. {; Int_t n = 20;; Double_t x[n], y[n], x1[n], y1[n];. // create a blue graph with a cos function; gr1->SetLineColor(4);; gr1->Draw(""AC*"");. // superimpose the second graph by leaving out the axis option ""A""; gr2->SetLineWidth(3);; gr2->SetMarkerStyle(21);; gr2->SetLineColor(2);; gr2->Draw(""CP"");; }; 4.3 Graphs with Error Bars; A TGraphErrors is a TGraph with error bars. The various draw format options of TGraphErrors::Paint() are derived from TGraph.; void TGraphErrors::Paint(Option_t *option). Graphs with different draw options of error bars. In addition, it can be drawn with the “Z” option to leave off the small lines at the end of the error bars. If option contains “>”, an arrow is drawn at the end of the error bars. If option contains “|>”, a full arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size.; The option “[]” is interesting to superimpose systematic errors on top of the graph with the statistical errors. When it is specified, only the end vertical/horizontal lines of the error bars are drawn.; To control the size of the lines at the end of the error bars (when option 1 is chosen) use SetEndErrorSize(np). By default np=1; np represents the number of pixels.; gStyle->SetEndErrorSize(np);; The four parameters of TGraphErrors are: X, Y (as in TGraph), X-errors, and Y-errors - the size of the errors in the x and y direction. Next example is $ROOTSYS/tutorials/graphs/gerrors.C.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:146194,Availability,error,error,146194,"tY();. // create markers of different colors; for (Int_t j=2; j<n-1; j++) {; TMarker *m = new TMarker(nx[j], 0.5*ny[j], 22);; m->SetMarkerSize(2);; m->SetMarkerColor(31+j);; m->Draw();; }; }; 4.2 Superimposing Two Graphs; To super impose two graphs you need to draw the axis only once, and leave out the “A” in the draw options for the second graph. Next is an example:. Superimposing two graphs. {; Int_t n = 20;; Double_t x[n], y[n], x1[n], y1[n];. // create a blue graph with a cos function; gr1->SetLineColor(4);; gr1->Draw(""AC*"");. // superimpose the second graph by leaving out the axis option ""A""; gr2->SetLineWidth(3);; gr2->SetMarkerStyle(21);; gr2->SetLineColor(2);; gr2->Draw(""CP"");; }; 4.3 Graphs with Error Bars; A TGraphErrors is a TGraph with error bars. The various draw format options of TGraphErrors::Paint() are derived from TGraph.; void TGraphErrors::Paint(Option_t *option). Graphs with different draw options of error bars. In addition, it can be drawn with the “Z” option to leave off the small lines at the end of the error bars. If option contains “>”, an arrow is drawn at the end of the error bars. If option contains “|>”, a full arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size.; The option “[]” is interesting to superimpose systematic errors on top of the graph with the statistical errors. When it is specified, only the end vertical/horizontal lines of the error bars are drawn.; To control the size of the lines at the end of the error bars (when option 1 is chosen) use SetEndErrorSize(np). By default np=1; np represents the number of pixels.; gStyle->SetEndErrorSize(np);; The four parameters of TGraphErrors are: X, Y (as in TGraph), X-errors, and Y-errors - the size of the errors in the x and y direction. Next example is $ROOTSYS/tutorials/graphs/gerrors.C.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:146266,Availability,error,error,146266,"new TMarker(nx[j], 0.5*ny[j], 22);; m->SetMarkerSize(2);; m->SetMarkerColor(31+j);; m->Draw();; }; }; 4.2 Superimposing Two Graphs; To super impose two graphs you need to draw the axis only once, and leave out the “A” in the draw options for the second graph. Next is an example:. Superimposing two graphs. {; Int_t n = 20;; Double_t x[n], y[n], x1[n], y1[n];. // create a blue graph with a cos function; gr1->SetLineColor(4);; gr1->Draw(""AC*"");. // superimpose the second graph by leaving out the axis option ""A""; gr2->SetLineWidth(3);; gr2->SetMarkerStyle(21);; gr2->SetLineColor(2);; gr2->Draw(""CP"");; }; 4.3 Graphs with Error Bars; A TGraphErrors is a TGraph with error bars. The various draw format options of TGraphErrors::Paint() are derived from TGraph.; void TGraphErrors::Paint(Option_t *option). Graphs with different draw options of error bars. In addition, it can be drawn with the “Z” option to leave off the small lines at the end of the error bars. If option contains “>”, an arrow is drawn at the end of the error bars. If option contains “|>”, a full arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size.; The option “[]” is interesting to superimpose systematic errors on top of the graph with the statistical errors. When it is specified, only the end vertical/horizontal lines of the error bars are drawn.; To control the size of the lines at the end of the error bars (when option 1 is chosen) use SetEndErrorSize(np). By default np=1; np represents the number of pixels.; gStyle->SetEndErrorSize(np);; The four parameters of TGraphErrors are: X, Y (as in TGraph), X-errors, and Y-errors - the size of the errors in the x and y direction. Next example is $ROOTSYS/tutorials/graphs/gerrors.C.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:146343,Availability,error,error,146343,"r(31+j);; m->Draw();; }; }; 4.2 Superimposing Two Graphs; To super impose two graphs you need to draw the axis only once, and leave out the “A” in the draw options for the second graph. Next is an example:. Superimposing two graphs. {; Int_t n = 20;; Double_t x[n], y[n], x1[n], y1[n];. // create a blue graph with a cos function; gr1->SetLineColor(4);; gr1->Draw(""AC*"");. // superimpose the second graph by leaving out the axis option ""A""; gr2->SetLineWidth(3);; gr2->SetMarkerStyle(21);; gr2->SetLineColor(2);; gr2->Draw(""CP"");; }; 4.3 Graphs with Error Bars; A TGraphErrors is a TGraph with error bars. The various draw format options of TGraphErrors::Paint() are derived from TGraph.; void TGraphErrors::Paint(Option_t *option). Graphs with different draw options of error bars. In addition, it can be drawn with the “Z” option to leave off the small lines at the end of the error bars. If option contains “>”, an arrow is drawn at the end of the error bars. If option contains “|>”, a full arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size.; The option “[]” is interesting to superimpose systematic errors on top of the graph with the statistical errors. When it is specified, only the end vertical/horizontal lines of the error bars are drawn.; To control the size of the lines at the end of the error bars (when option 1 is chosen) use SetEndErrorSize(np). By default np=1; np represents the number of pixels.; gStyle->SetEndErrorSize(np);; The four parameters of TGraphErrors are: X, Y (as in TGraph), X-errors, and Y-errors - the size of the errors in the x and y direction. Next example is $ROOTSYS/tutorials/graphs/gerrors.C.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.0",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:146469,Availability,error,errors,146469,"raw options for the second graph. Next is an example:. Superimposing two graphs. {; Int_t n = 20;; Double_t x[n], y[n], x1[n], y1[n];. // create a blue graph with a cos function; gr1->SetLineColor(4);; gr1->Draw(""AC*"");. // superimpose the second graph by leaving out the axis option ""A""; gr2->SetLineWidth(3);; gr2->SetMarkerStyle(21);; gr2->SetLineColor(2);; gr2->Draw(""CP"");; }; 4.3 Graphs with Error Bars; A TGraphErrors is a TGraph with error bars. The various draw format options of TGraphErrors::Paint() are derived from TGraph.; void TGraphErrors::Paint(Option_t *option). Graphs with different draw options of error bars. In addition, it can be drawn with the “Z” option to leave off the small lines at the end of the error bars. If option contains “>”, an arrow is drawn at the end of the error bars. If option contains “|>”, a full arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size.; The option “[]” is interesting to superimpose systematic errors on top of the graph with the statistical errors. When it is specified, only the end vertical/horizontal lines of the error bars are drawn.; To control the size of the lines at the end of the error bars (when option 1 is chosen) use SetEndErrorSize(np). By default np=1; np represents the number of pixels.; gStyle->SetEndErrorSize(np);; The four parameters of TGraphErrors are: X, Y (as in TGraph), X-errors, and Y-errors - the size of the errors in the x and y direction. Next example is $ROOTSYS/tutorials/graphs/gerrors.C.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:146517,Availability,error,errors,146517,"raw options for the second graph. Next is an example:. Superimposing two graphs. {; Int_t n = 20;; Double_t x[n], y[n], x1[n], y1[n];. // create a blue graph with a cos function; gr1->SetLineColor(4);; gr1->Draw(""AC*"");. // superimpose the second graph by leaving out the axis option ""A""; gr2->SetLineWidth(3);; gr2->SetMarkerStyle(21);; gr2->SetLineColor(2);; gr2->Draw(""CP"");; }; 4.3 Graphs with Error Bars; A TGraphErrors is a TGraph with error bars. The various draw format options of TGraphErrors::Paint() are derived from TGraph.; void TGraphErrors::Paint(Option_t *option). Graphs with different draw options of error bars. In addition, it can be drawn with the “Z” option to leave off the small lines at the end of the error bars. If option contains “>”, an arrow is drawn at the end of the error bars. If option contains “|>”, a full arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size.; The option “[]” is interesting to superimpose systematic errors on top of the graph with the statistical errors. When it is specified, only the end vertical/horizontal lines of the error bars are drawn.; To control the size of the lines at the end of the error bars (when option 1 is chosen) use SetEndErrorSize(np). By default np=1; np represents the number of pixels.; gStyle->SetEndErrorSize(np);; The four parameters of TGraphErrors are: X, Y (as in TGraph), X-errors, and Y-errors - the size of the errors in the x and y direction. Next example is $ROOTSYS/tutorials/graphs/gerrors.C.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:146593,Availability,error,error,146593,"ble_t x[n], y[n], x1[n], y1[n];. // create a blue graph with a cos function; gr1->SetLineColor(4);; gr1->Draw(""AC*"");. // superimpose the second graph by leaving out the axis option ""A""; gr2->SetLineWidth(3);; gr2->SetMarkerStyle(21);; gr2->SetLineColor(2);; gr2->Draw(""CP"");; }; 4.3 Graphs with Error Bars; A TGraphErrors is a TGraph with error bars. The various draw format options of TGraphErrors::Paint() are derived from TGraph.; void TGraphErrors::Paint(Option_t *option). Graphs with different draw options of error bars. In addition, it can be drawn with the “Z” option to leave off the small lines at the end of the error bars. If option contains “>”, an arrow is drawn at the end of the error bars. If option contains “|>”, a full arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size.; The option “[]” is interesting to superimpose systematic errors on top of the graph with the statistical errors. When it is specified, only the end vertical/horizontal lines of the error bars are drawn.; To control the size of the lines at the end of the error bars (when option 1 is chosen) use SetEndErrorSize(np). By default np=1; np represents the number of pixels.; gStyle->SetEndErrorSize(np);; The four parameters of TGraphErrors are: X, Y (as in TGraph), X-errors, and Y-errors - the size of the errors in the x and y direction. Next example is $ROOTSYS/tutorials/graphs/gerrors.C.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:146667,Availability,error,error,146667,"1->Draw(""AC*"");. // superimpose the second graph by leaving out the axis option ""A""; gr2->SetLineWidth(3);; gr2->SetMarkerStyle(21);; gr2->SetLineColor(2);; gr2->Draw(""CP"");; }; 4.3 Graphs with Error Bars; A TGraphErrors is a TGraph with error bars. The various draw format options of TGraphErrors::Paint() are derived from TGraph.; void TGraphErrors::Paint(Option_t *option). Graphs with different draw options of error bars. In addition, it can be drawn with the “Z” option to leave off the small lines at the end of the error bars. If option contains “>”, an arrow is drawn at the end of the error bars. If option contains “|>”, a full arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size.; The option “[]” is interesting to superimpose systematic errors on top of the graph with the statistical errors. When it is specified, only the end vertical/horizontal lines of the error bars are drawn.; To control the size of the lines at the end of the error bars (when option 1 is chosen) use SetEndErrorSize(np). By default np=1; np represents the number of pixels.; gStyle->SetEndErrorSize(np);; The four parameters of TGraphErrors are: X, Y (as in TGraph), X-errors, and Y-errors - the size of the errors in the x and y direction. Next example is $ROOTSYS/tutorials/graphs/gerrors.C.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TG",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:146877,Availability,error,errors,146877," Error Bars; A TGraphErrors is a TGraph with error bars. The various draw format options of TGraphErrors::Paint() are derived from TGraph.; void TGraphErrors::Paint(Option_t *option). Graphs with different draw options of error bars. In addition, it can be drawn with the “Z” option to leave off the small lines at the end of the error bars. If option contains “>”, an arrow is drawn at the end of the error bars. If option contains “|>”, a full arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size.; The option “[]” is interesting to superimpose systematic errors on top of the graph with the statistical errors. When it is specified, only the end vertical/horizontal lines of the error bars are drawn.; To control the size of the lines at the end of the error bars (when option 1 is chosen) use SetEndErrorSize(np). By default np=1; np represents the number of pixels.; gStyle->SetEndErrorSize(np);; The four parameters of TGraphErrors are: X, Y (as in TGraph), X-errors, and Y-errors - the size of the errors in the x and y direction. Next example is $ROOTSYS/tutorials/graphs/gerrors.C.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TGraphAsymmErrors is a TGraph with asymmetric error bars. It inherits the various draw format options from TGraph. Its method Paint(Option_t *option) paints the TGraphAsymmErrors with the current ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:146891,Availability,error,errors,146891," Error Bars; A TGraphErrors is a TGraph with error bars. The various draw format options of TGraphErrors::Paint() are derived from TGraph.; void TGraphErrors::Paint(Option_t *option). Graphs with different draw options of error bars. In addition, it can be drawn with the “Z” option to leave off the small lines at the end of the error bars. If option contains “>”, an arrow is drawn at the end of the error bars. If option contains “|>”, a full arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size.; The option “[]” is interesting to superimpose systematic errors on top of the graph with the statistical errors. When it is specified, only the end vertical/horizontal lines of the error bars are drawn.; To control the size of the lines at the end of the error bars (when option 1 is chosen) use SetEndErrorSize(np). By default np=1; np represents the number of pixels.; gStyle->SetEndErrorSize(np);; The four parameters of TGraphErrors are: X, Y (as in TGraph), X-errors, and Y-errors - the size of the errors in the x and y direction. Next example is $ROOTSYS/tutorials/graphs/gerrors.C.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TGraphAsymmErrors is a TGraph with asymmetric error bars. It inherits the various draw format options from TGraph. Its method Paint(Option_t *option) paints the TGraphAsymmErrors with the current ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:146916,Availability,error,errors,146916," Error Bars; A TGraphErrors is a TGraph with error bars. The various draw format options of TGraphErrors::Paint() are derived from TGraph.; void TGraphErrors::Paint(Option_t *option). Graphs with different draw options of error bars. In addition, it can be drawn with the “Z” option to leave off the small lines at the end of the error bars. If option contains “>”, an arrow is drawn at the end of the error bars. If option contains “|>”, a full arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size.; The option “[]” is interesting to superimpose systematic errors on top of the graph with the statistical errors. When it is specified, only the end vertical/horizontal lines of the error bars are drawn.; To control the size of the lines at the end of the error bars (when option 1 is chosen) use SetEndErrorSize(np). By default np=1; np represents the number of pixels.; gStyle->SetEndErrorSize(np);; The four parameters of TGraphErrors are: X, Y (as in TGraph), X-errors, and Y-errors - the size of the errors in the x and y direction. Next example is $ROOTSYS/tutorials/graphs/gerrors.C.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TGraphAsymmErrors is a TGraph with asymmetric error bars. It inherits the various draw format options from TGraph. Its method Paint(Option_t *option) paints the TGraphAsymmErrors with the current ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:147049,Availability,error,error,147049," Graphs with different draw options of error bars. In addition, it can be drawn with the “Z” option to leave off the small lines at the end of the error bars. If option contains “>”, an arrow is drawn at the end of the error bars. If option contains “|>”, a full arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size.; The option “[]” is interesting to superimpose systematic errors on top of the graph with the statistical errors. When it is specified, only the end vertical/horizontal lines of the error bars are drawn.; To control the size of the lines at the end of the error bars (when option 1 is chosen) use SetEndErrorSize(np). By default np=1; np represents the number of pixels.; gStyle->SetEndErrorSize(np);; The four parameters of TGraphErrors are: X, Y (as in TGraph), X-errors, and Y-errors - the size of the errors in the x and y direction. Next example is $ROOTSYS/tutorials/graphs/gerrors.C.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TGraphAsymmErrors is a TGraph with asymmetric error bars. It inherits the various draw format options from TGraph. Its method Paint(Option_t *option) paints the TGraphAsymmErrors with the current attributes. You can set the following additional options for drawing:. “z” or “Z”the horizontal and vertical small lines are not drawn at the end of error bars; “>”an arrow is drawn a",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:147268,Availability,error,error,147268,". If option contains “|>”, a full arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size.; The option “[]” is interesting to superimpose systematic errors on top of the graph with the statistical errors. When it is specified, only the end vertical/horizontal lines of the error bars are drawn.; To control the size of the lines at the end of the error bars (when option 1 is chosen) use SetEndErrorSize(np). By default np=1; np represents the number of pixels.; gStyle->SetEndErrorSize(np);; The four parameters of TGraphErrors are: X, Y (as in TGraph), X-errors, and Y-errors - the size of the errors in the x and y direction. Next example is $ROOTSYS/tutorials/graphs/gerrors.C.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TGraphAsymmErrors is a TGraph with asymmetric error bars. It inherits the various draw format options from TGraph. Its method Paint(Option_t *option) paints the TGraphAsymmErrors with the current attributes. You can set the following additional options for drawing:. “z” or “Z”the horizontal and vertical small lines are not drawn at the end of error bars; “>”an arrow is drawn at the end of the error bars; “|>”a full arrow is drawn at the end of the error bar; its size is \(\frac{2}{3}\) of the marker size; “[]”only the end vertical/horizontal lines of the error bars are drawn; this option is interestin",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:147655,Availability,error,error,147655," at the end of the error bars (when option 1 is chosen) use SetEndErrorSize(np). By default np=1; np represents the number of pixels.; gStyle->SetEndErrorSize(np);; The four parameters of TGraphErrors are: X, Y (as in TGraph), X-errors, and Y-errors - the size of the errors in the x and y direction. Next example is $ROOTSYS/tutorials/graphs/gerrors.C.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TGraphAsymmErrors is a TGraph with asymmetric error bars. It inherits the various draw format options from TGraph. Its method Paint(Option_t *option) paints the TGraphAsymmErrors with the current attributes. You can set the following additional options for drawing:. “z” or “Z”the horizontal and vertical small lines are not drawn at the end of error bars; “>”an arrow is drawn at the end of the error bars; “|>”a full arrow is drawn at the end of the error bar; its size is \(\frac{2}{3}\) of the marker size; “[]”only the end vertical/horizontal lines of the error bars are drawn; this option is interesting to superimpose systematic errors on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as TGraph and low X-errors and high X-errors, low Y-errors and high Y-errors. The low value is the length of the error bar to the left and down, the high value is the length of the error bar to the right and up.; {; c1 = new TCanvas(""c1"",""",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:147715,Availability,error,error,147715,"chosen) use SetEndErrorSize(np). By default np=1; np represents the number of pixels.; gStyle->SetEndErrorSize(np);; The four parameters of TGraphErrors are: X, Y (as in TGraph), X-errors, and Y-errors - the size of the errors in the x and y direction. Next example is $ROOTSYS/tutorials/graphs/gerrors.C.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TGraphAsymmErrors is a TGraph with asymmetric error bars. It inherits the various draw format options from TGraph. Its method Paint(Option_t *option) paints the TGraphAsymmErrors with the current attributes. You can set the following additional options for drawing:. “z” or “Z”the horizontal and vertical small lines are not drawn at the end of error bars; “>”an arrow is drawn at the end of the error bars; “|>”a full arrow is drawn at the end of the error bar; its size is \(\frac{2}{3}\) of the marker size; “[]”only the end vertical/horizontal lines of the error bars are drawn; this option is interesting to superimpose systematic errors on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as TGraph and low X-errors and high X-errors, low Y-errors and high Y-errors. The low value is the length of the error bar to the left and down, the high value is the length of the error bar to the right and up.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:148014,Availability,error,error,148014,"loat_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TGraphAsymmErrors is a TGraph with asymmetric error bars. It inherits the various draw format options from TGraph. Its method Paint(Option_t *option) paints the TGraphAsymmErrors with the current attributes. You can set the following additional options for drawing:. “z” or “Z”the horizontal and vertical small lines are not drawn at the end of error bars; “>”an arrow is drawn at the end of the error bars; “|>”a full arrow is drawn at the end of the error bar; its size is \(\frac{2}{3}\) of the marker size; “[]”only the end vertical/horizontal lines of the error bars are drawn; this option is interesting to superimpose systematic errors on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as TGraph and low X-errors and high X-errors, low Y-errors and high Y-errors. The low value is the length of the error bar to the left and down, the high value is the length of the error bar to the right and up.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:148065,Availability,error,error,148065,"loat_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TGraphAsymmErrors is a TGraph with asymmetric error bars. It inherits the various draw format options from TGraph. Its method Paint(Option_t *option) paints the TGraphAsymmErrors with the current attributes. You can set the following additional options for drawing:. “z” or “Z”the horizontal and vertical small lines are not drawn at the end of error bars; “>”an arrow is drawn at the end of the error bars; “|>”a full arrow is drawn at the end of the error bar; its size is \(\frac{2}{3}\) of the marker size; “[]”only the end vertical/horizontal lines of the error bars are drawn; this option is interesting to superimpose systematic errors on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as TGraph and low X-errors and high X-errors, low Y-errors and high Y-errors. The low value is the length of the error bar to the left and down, the high value is the length of the error bar to the right and up.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:148121,Availability,error,error,148121,"loat_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TGraphAsymmErrors is a TGraph with asymmetric error bars. It inherits the various draw format options from TGraph. Its method Paint(Option_t *option) paints the TGraphAsymmErrors with the current attributes. You can set the following additional options for drawing:. “z” or “Z”the horizontal and vertical small lines are not drawn at the end of error bars; “>”an arrow is drawn at the end of the error bars; “|>”a full arrow is drawn at the end of the error bar; its size is \(\frac{2}{3}\) of the marker size; “[]”only the end vertical/horizontal lines of the error bars are drawn; this option is interesting to superimpose systematic errors on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as TGraph and low X-errors and high X-errors, low Y-errors and high Y-errors. The low value is the length of the error bar to the left and down, the high value is the length of the error bar to the right and up.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:148230,Availability,error,error,148230,"loat_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TGraphAsymmErrors is a TGraph with asymmetric error bars. It inherits the various draw format options from TGraph. Its method Paint(Option_t *option) paints the TGraphAsymmErrors with the current attributes. You can set the following additional options for drawing:. “z” or “Z”the horizontal and vertical small lines are not drawn at the end of error bars; “>”an arrow is drawn at the end of the error bars; “|>”a full arrow is drawn at the end of the error bar; its size is \(\frac{2}{3}\) of the marker size; “[]”only the end vertical/horizontal lines of the error bars are drawn; this option is interesting to superimpose systematic errors on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as TGraph and low X-errors and high X-errors, low Y-errors and high Y-errors. The low value is the length of the error bar to the left and down, the high value is the length of the error bar to the right and up.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:148305,Availability,error,errors,148305,"loat_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TGraphAsymmErrors is a TGraph with asymmetric error bars. It inherits the various draw format options from TGraph. Its method Paint(Option_t *option) paints the TGraphAsymmErrors with the current attributes. You can set the following additional options for drawing:. “z” or “Z”the horizontal and vertical small lines are not drawn at the end of error bars; “>”an arrow is drawn at the end of the error bars; “|>”a full arrow is drawn at the end of the error bar; its size is \(\frac{2}{3}\) of the marker size; “[]”only the end vertical/horizontal lines of the error bars are drawn; this option is interesting to superimpose systematic errors on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as TGraph and low X-errors and high X-errors, low Y-errors and high Y-errors. The low value is the length of the error bar to the left and down, the high value is the length of the error bar to the right and up.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:148347,Availability,error,errors,148347,"loat_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TGraphAsymmErrors is a TGraph with asymmetric error bars. It inherits the various draw format options from TGraph. Its method Paint(Option_t *option) paints the TGraphAsymmErrors with the current attributes. You can set the following additional options for drawing:. “z” or “Z”the horizontal and vertical small lines are not drawn at the end of error bars; “>”an arrow is drawn at the end of the error bars; “|>”a full arrow is drawn at the end of the error bar; its size is \(\frac{2}{3}\) of the marker size; “[]”only the end vertical/horizontal lines of the error bars are drawn; this option is interesting to superimpose systematic errors on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as TGraph and low X-errors and high X-errors, low Y-errors and high Y-errors. The low value is the length of the error bar to the left and down, the high value is the length of the error bar to the right and up.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:148429,Availability,error,errors,148429,"d draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TGraphAsymmErrors is a TGraph with asymmetric error bars. It inherits the various draw format options from TGraph. Its method Paint(Option_t *option) paints the TGraphAsymmErrors with the current attributes. You can set the following additional options for drawing:. “z” or “Z”the horizontal and vertical small lines are not drawn at the end of error bars; “>”an arrow is drawn at the end of the error bars; “|>”a full arrow is drawn at the end of the error bar; its size is \(\frac{2}{3}\) of the marker size; “[]”only the end vertical/horizontal lines of the error bars are drawn; this option is interesting to superimpose systematic errors on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as TGraph and low X-errors and high X-errors, low Y-errors and high Y-errors. The low value is the length of the error bar to the left and down, the high value is the length of the error bar to the right and up.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.5 Graphs with Asymmetric Bent Errors. A graph with ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:148447,Availability,error,errors,148447,"d draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TGraphAsymmErrors is a TGraph with asymmetric error bars. It inherits the various draw format options from TGraph. Its method Paint(Option_t *option) paints the TGraphAsymmErrors with the current attributes. You can set the following additional options for drawing:. “z” or “Z”the horizontal and vertical small lines are not drawn at the end of error bars; “>”an arrow is drawn at the end of the error bars; “|>”a full arrow is drawn at the end of the error bar; its size is \(\frac{2}{3}\) of the marker size; “[]”only the end vertical/horizontal lines of the error bars are drawn; this option is interesting to superimpose systematic errors on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as TGraph and low X-errors and high X-errors, low Y-errors and high Y-errors. The low value is the length of the error bar to the left and down, the high value is the length of the error bar to the right and up.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.5 Graphs with Asymmetric Bent Errors. A graph with ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:148461,Availability,error,errors,148461,"d draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TGraphAsymmErrors is a TGraph with asymmetric error bars. It inherits the various draw format options from TGraph. Its method Paint(Option_t *option) paints the TGraphAsymmErrors with the current attributes. You can set the following additional options for drawing:. “z” or “Z”the horizontal and vertical small lines are not drawn at the end of error bars; “>”an arrow is drawn at the end of the error bars; “|>”a full arrow is drawn at the end of the error bar; its size is \(\frac{2}{3}\) of the marker size; “[]”only the end vertical/horizontal lines of the error bars are drawn; this option is interesting to superimpose systematic errors on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as TGraph and low X-errors and high X-errors, low Y-errors and high Y-errors. The low value is the length of the error bar to the left and down, the high value is the length of the error bar to the right and up.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.5 Graphs with Asymmetric Bent Errors. A graph with ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:148479,Availability,error,errors,148479,"d draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TGraphAsymmErrors is a TGraph with asymmetric error bars. It inherits the various draw format options from TGraph. Its method Paint(Option_t *option) paints the TGraphAsymmErrors with the current attributes. You can set the following additional options for drawing:. “z” or “Z”the horizontal and vertical small lines are not drawn at the end of error bars; “>”an arrow is drawn at the end of the error bars; “|>”a full arrow is drawn at the end of the error bar; its size is \(\frac{2}{3}\) of the marker size; “[]”only the end vertical/horizontal lines of the error bars are drawn; this option is interesting to superimpose systematic errors on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as TGraph and low X-errors and high X-errors, low Y-errors and high Y-errors. The low value is the length of the error bar to the left and down, the high value is the length of the error bar to the right and up.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.5 Graphs with Asymmetric Bent Errors. A graph with ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:148522,Availability,error,error,148522,";; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TGraphAsymmErrors is a TGraph with asymmetric error bars. It inherits the various draw format options from TGraph. Its method Paint(Option_t *option) paints the TGraphAsymmErrors with the current attributes. You can set the following additional options for drawing:. “z” or “Z”the horizontal and vertical small lines are not drawn at the end of error bars; “>”an arrow is drawn at the end of the error bars; “|>”a full arrow is drawn at the end of the error bar; its size is \(\frac{2}{3}\) of the marker size; “[]”only the end vertical/horizontal lines of the error bars are drawn; this option is interesting to superimpose systematic errors on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as TGraph and low X-errors and high X-errors, low Y-errors and high Y-errors. The low value is the length of the error bar to the left and down, the high value is the length of the error bar to the right and up.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.5 Graphs with Asymmetric Bent Errors. A graph with asymmetric bent error bars. A TGraphBentErrors is a TGraph with bent, asymmetric error bars. The various format options to draw a TGr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:148548,Availability,down,down,148548,";; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TGraphAsymmErrors is a TGraph with asymmetric error bars. It inherits the various draw format options from TGraph. Its method Paint(Option_t *option) paints the TGraphAsymmErrors with the current attributes. You can set the following additional options for drawing:. “z” or “Z”the horizontal and vertical small lines are not drawn at the end of error bars; “>”an arrow is drawn at the end of the error bars; “|>”a full arrow is drawn at the end of the error bar; its size is \(\frac{2}{3}\) of the marker size; “[]”only the end vertical/horizontal lines of the error bars are drawn; this option is interesting to superimpose systematic errors on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as TGraph and low X-errors and high X-errors, low Y-errors and high Y-errors. The low value is the length of the error bar to the left and down, the high value is the length of the error bar to the right and up.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.5 Graphs with Asymmetric Bent Errors. A graph with asymmetric bent error bars. A TGraphBentErrors is a TGraph with bent, asymmetric error bars. The various format options to draw a TGr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:148590,Availability,error,error,148590,";; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TGraphAsymmErrors is a TGraph with asymmetric error bars. It inherits the various draw format options from TGraph. Its method Paint(Option_t *option) paints the TGraphAsymmErrors with the current attributes. You can set the following additional options for drawing:. “z” or “Z”the horizontal and vertical small lines are not drawn at the end of error bars; “>”an arrow is drawn at the end of the error bars; “|>”a full arrow is drawn at the end of the error bar; its size is \(\frac{2}{3}\) of the marker size; “[]”only the end vertical/horizontal lines of the error bars are drawn; this option is interesting to superimpose systematic errors on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as TGraph and low X-errors and high X-errors, low Y-errors and high Y-errors. The low value is the length of the error bar to the left and down, the high value is the length of the error bar to the right and up.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.5 Graphs with Asymmetric Bent Errors. A graph with asymmetric bent error bars. A TGraphBentErrors is a TGraph with bent, asymmetric error bars. The various format options to draw a TGr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:148668,Availability,error,error,148668,"A TGraphAsymmErrors is a TGraph with asymmetric error bars. It inherits the various draw format options from TGraph. Its method Paint(Option_t *option) paints the TGraphAsymmErrors with the current attributes. You can set the following additional options for drawing:. “z” or “Z”the horizontal and vertical small lines are not drawn at the end of error bars; “>”an arrow is drawn at the end of the error bars; “|>”a full arrow is drawn at the end of the error bar; its size is \(\frac{2}{3}\) of the marker size; “[]”only the end vertical/horizontal lines of the error bars are drawn; this option is interesting to superimpose systematic errors on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as TGraph and low X-errors and high X-errors, low Y-errors and high Y-errors. The low value is the length of the error bar to the left and down, the high value is the length of the error bar to the right and up.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.5 Graphs with Asymmetric Bent Errors. A graph with asymmetric bent error bars. A TGraphBentErrors is a TGraph with bent, asymmetric error bars. The various format options to draw a TGraphBentErrors are explained in TGraphBentErrors::Paint method. The TGraphBentErrors is drawn by default with error ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:148921,Availability,error,errors,148921,"ptions for drawing:. “z” or “Z”the horizontal and vertical small lines are not drawn at the end of error bars; “>”an arrow is drawn at the end of the error bars; “|>”a full arrow is drawn at the end of the error bar; its size is \(\frac{2}{3}\) of the marker size; “[]”only the end vertical/horizontal lines of the error bars are drawn; this option is interesting to superimpose systematic errors on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as TGraph and low X-errors and high X-errors, low Y-errors and high Y-errors. The low value is the length of the error bar to the left and down, the high value is the length of the error bar to the right and up.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.5 Graphs with Asymmetric Bent Errors. A graph with asymmetric bent error bars. A TGraphBentErrors is a TGraph with bent, asymmetric error bars. The various format options to draw a TGraphBentErrors are explained in TGraphBentErrors::Paint method. The TGraphBentErrors is drawn by default with error bars and small horizontal and vertical lines at the end of the error bars. If option “z” or “Z” is specified, these small lines are not drawn. If the option “X” is specified, the errors are not drawn (the TGraph::Paint method equivalent). if optio",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:149436,Availability,error,error,149436," X-errors and high X-errors, low Y-errors and high Y-errors. The low value is the length of the error bar to the left and down, the high value is the length of the error bar to the right and up.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.5 Graphs with Asymmetric Bent Errors. A graph with asymmetric bent error bars. A TGraphBentErrors is a TGraph with bent, asymmetric error bars. The various format options to draw a TGraphBentErrors are explained in TGraphBentErrors::Paint method. The TGraphBentErrors is drawn by default with error bars and small horizontal and vertical lines at the end of the error bars. If option “z” or “Z” is specified, these small lines are not drawn. If the option “X” is specified, the errors are not drawn (the TGraph::Paint method equivalent). if option contains “>”, an arrow is drawn at the end of the error bars; if option contains “|>”, a full arrow is drawn at the end of the error bars; the size of the arrow is set to 2/3 of the marker size; if option “[]” is specified, only the end vertical/horizontal lines of the error bars are drawn. This option is interesting to superimpose systematic errors on top of a graph with statistical errors. This figure has been generated by the following macro:; {; Int_t n = 10;; Double_t x[n] = {-0.22,0.05,0.25,0.35,0.5",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:149501,Availability,error,error,149501,"errors. The low value is the length of the error bar to the left and down, the high value is the length of the error bar to the right and up.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.5 Graphs with Asymmetric Bent Errors. A graph with asymmetric bent error bars. A TGraphBentErrors is a TGraph with bent, asymmetric error bars. The various format options to draw a TGraphBentErrors are explained in TGraphBentErrors::Paint method. The TGraphBentErrors is drawn by default with error bars and small horizontal and vertical lines at the end of the error bars. If option “z” or “Z” is specified, these small lines are not drawn. If the option “X” is specified, the errors are not drawn (the TGraph::Paint method equivalent). if option contains “>”, an arrow is drawn at the end of the error bars; if option contains “|>”, a full arrow is drawn at the end of the error bars; the size of the arrow is set to 2/3 of the marker size; if option “[]” is specified, only the end vertical/horizontal lines of the error bars are drawn. This option is interesting to superimpose systematic errors on top of a graph with statistical errors. This figure has been generated by the following macro:; {; Int_t n = 10;; Double_t x[n] = {-0.22,0.05,0.25,0.35,0.5,0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:149662,Availability,error,error,149662,""",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.5 Graphs with Asymmetric Bent Errors. A graph with asymmetric bent error bars. A TGraphBentErrors is a TGraph with bent, asymmetric error bars. The various format options to draw a TGraphBentErrors are explained in TGraphBentErrors::Paint method. The TGraphBentErrors is drawn by default with error bars and small horizontal and vertical lines at the end of the error bars. If option “z” or “Z” is specified, these small lines are not drawn. If the option “X” is specified, the errors are not drawn (the TGraph::Paint method equivalent). if option contains “>”, an arrow is drawn at the end of the error bars; if option contains “|>”, a full arrow is drawn at the end of the error bars; the size of the arrow is set to 2/3 of the marker size; if option “[]” is specified, only the end vertical/horizontal lines of the error bars are drawn. This option is interesting to superimpose systematic errors on top of a graph with statistical errors. This figure has been generated by the following macro:; {; Int_t n = 10;; Double_t x[n] = {-0.22,0.05,0.25,0.35,0.5,0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.0",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:149731,Availability,error,error,149731,""",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5, .61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.5 Graphs with Asymmetric Bent Errors. A graph with asymmetric bent error bars. A TGraphBentErrors is a TGraph with bent, asymmetric error bars. The various format options to draw a TGraphBentErrors are explained in TGraphBentErrors::Paint method. The TGraphBentErrors is drawn by default with error bars and small horizontal and vertical lines at the end of the error bars. If option “z” or “Z” is specified, these small lines are not drawn. If the option “X” is specified, the errors are not drawn (the TGraph::Paint method equivalent). if option contains “>”, an arrow is drawn at the end of the error bars; if option contains “|>”, a full arrow is drawn at the end of the error bars; the size of the arrow is set to 2/3 of the marker size; if option “[]” is specified, only the end vertical/horizontal lines of the error bars are drawn. This option is interesting to superimpose systematic errors on top of a graph with statistical errors. This figure has been generated by the following macro:; {; Int_t n = 10;; Double_t x[n] = {-0.22,0.05,0.25,0.35,0.5,0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.0",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:149847,Availability,error,errors,149847,",9,9.6,8.7,6.3,4.5,1};. // create the arrays with high and low errors; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.5 Graphs with Asymmetric Bent Errors. A graph with asymmetric bent error bars. A TGraphBentErrors is a TGraph with bent, asymmetric error bars. The various format options to draw a TGraphBentErrors are explained in TGraphBentErrors::Paint method. The TGraphBentErrors is drawn by default with error bars and small horizontal and vertical lines at the end of the error bars. If option “z” or “Z” is specified, these small lines are not drawn. If the option “X” is specified, the errors are not drawn (the TGraph::Paint method equivalent). if option contains “>”, an arrow is drawn at the end of the error bars; if option contains “|>”, a full arrow is drawn at the end of the error bars; the size of the arrow is set to 2/3 of the marker size; if option “[]” is specified, only the end vertical/horizontal lines of the error bars are drawn. This option is interesting to superimpose systematic errors on top of a graph with statistical errors. This figure has been generated by the following macro:; {; Int_t n = 10;; Double_t x[n] = {-0.22,0.05,0.25,0.35,0.5,0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n]",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:149967,Availability,error,error,149967," = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.5 Graphs with Asymmetric Bent Errors. A graph with asymmetric bent error bars. A TGraphBentErrors is a TGraph with bent, asymmetric error bars. The various format options to draw a TGraphBentErrors are explained in TGraphBentErrors::Paint method. The TGraphBentErrors is drawn by default with error bars and small horizontal and vertical lines at the end of the error bars. If option “z” or “Z” is specified, these small lines are not drawn. If the option “X” is specified, the errors are not drawn (the TGraph::Paint method equivalent). if option contains “>”, an arrow is drawn at the end of the error bars; if option contains “|>”, a full arrow is drawn at the end of the error bars; the size of the arrow is set to 2/3 of the marker size; if option “[]” is specified, only the end vertical/horizontal lines of the error bars are drawn. This option is interesting to superimpose systematic errors on top of a graph with statistical errors. This figure has been generated by the following macro:; {; Int_t n = 10;; Double_t x[n] = {-0.22,0.05,0.25,0.35,0.5,0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; gr = new TGraphBentErrors(n,x,y,; exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Exam",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:150044,Availability,error,error,150044," = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.5 Graphs with Asymmetric Bent Errors. A graph with asymmetric bent error bars. A TGraphBentErrors is a TGraph with bent, asymmetric error bars. The various format options to draw a TGraphBentErrors are explained in TGraphBentErrors::Paint method. The TGraphBentErrors is drawn by default with error bars and small horizontal and vertical lines at the end of the error bars. If option “z” or “Z” is specified, these small lines are not drawn. If the option “X” is specified, the errors are not drawn (the TGraph::Paint method equivalent). if option contains “>”, an arrow is drawn at the end of the error bars; if option contains “|>”, a full arrow is drawn at the end of the error bars; the size of the arrow is set to 2/3 of the marker size; if option “[]” is specified, only the end vertical/horizontal lines of the error bars are drawn. This option is interesting to superimpose systematic errors on top of a graph with statistical errors. This figure has been generated by the following macro:; {; Int_t n = 10;; Double_t x[n] = {-0.22,0.05,0.25,0.35,0.5,0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; gr = new TGraphBentErrors(n,x,y,; exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Exam",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:150187,Availability,error,error,150187," = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};. // create TGraphAsymmErrors with the arrays; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.5 Graphs with Asymmetric Bent Errors. A graph with asymmetric bent error bars. A TGraphBentErrors is a TGraph with bent, asymmetric error bars. The various format options to draw a TGraphBentErrors are explained in TGraphBentErrors::Paint method. The TGraphBentErrors is drawn by default with error bars and small horizontal and vertical lines at the end of the error bars. If option “z” or “Z” is specified, these small lines are not drawn. If the option “X” is specified, the errors are not drawn (the TGraph::Paint method equivalent). if option contains “>”, an arrow is drawn at the end of the error bars; if option contains “|>”, a full arrow is drawn at the end of the error bars; the size of the arrow is set to 2/3 of the marker size; if option “[]” is specified, only the end vertical/horizontal lines of the error bars are drawn. This option is interesting to superimpose systematic errors on top of a graph with statistical errors. This figure has been generated by the following macro:; {; Int_t n = 10;; Double_t x[n] = {-0.22,0.05,0.25,0.35,0.5,0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; gr = new TGraphBentErrors(n,x,y,; exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Exam",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:150262,Availability,error,errors,150262,"tTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.5 Graphs with Asymmetric Bent Errors. A graph with asymmetric bent error bars. A TGraphBentErrors is a TGraph with bent, asymmetric error bars. The various format options to draw a TGraphBentErrors are explained in TGraphBentErrors::Paint method. The TGraphBentErrors is drawn by default with error bars and small horizontal and vertical lines at the end of the error bars. If option “z” or “Z” is specified, these small lines are not drawn. If the option “X” is specified, the errors are not drawn (the TGraph::Paint method equivalent). if option contains “>”, an arrow is drawn at the end of the error bars; if option contains “|>”, a full arrow is drawn at the end of the error bars; the size of the arrow is set to 2/3 of the marker size; if option “[]” is specified, only the end vertical/horizontal lines of the error bars are drawn. This option is interesting to superimpose systematic errors on top of a graph with statistical errors. This figure has been generated by the following macro:; {; Int_t n = 10;; Double_t x[n] = {-0.22,0.05,0.25,0.35,0.5,0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; gr = new TGraphBentErrors(n,x,y,; exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.6 TGraphPolar; The TGraphPolar class creates a polar graph (including error bars). A TGraphPolar is a TGraphErrors represen",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:150304,Availability,error,errors,150304,"tTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.5 Graphs with Asymmetric Bent Errors. A graph with asymmetric bent error bars. A TGraphBentErrors is a TGraph with bent, asymmetric error bars. The various format options to draw a TGraphBentErrors are explained in TGraphBentErrors::Paint method. The TGraphBentErrors is drawn by default with error bars and small horizontal and vertical lines at the end of the error bars. If option “z” or “Z” is specified, these small lines are not drawn. If the option “X” is specified, the errors are not drawn (the TGraph::Paint method equivalent). if option contains “>”, an arrow is drawn at the end of the error bars; if option contains “|>”, a full arrow is drawn at the end of the error bars; the size of the arrow is set to 2/3 of the marker size; if option “[]” is specified, only the end vertical/horizontal lines of the error bars are drawn. This option is interesting to superimpose systematic errors on top of a graph with statistical errors. This figure has been generated by the following macro:; {; Int_t n = 10;; Double_t x[n] = {-0.22,0.05,0.25,0.35,0.5,0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; gr = new TGraphBentErrors(n,x,y,; exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.6 TGraphPolar; The TGraphPolar class creates a polar graph (including error bars). A TGraphPolar is a TGraphErrors represen",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:151207,Availability,error,error,151207,"s of the error bars are drawn. This option is interesting to superimpose systematic errors on top of a graph with statistical errors. This figure has been generated by the following macro:; {; Int_t n = 10;; Double_t x[n] = {-0.22,0.05,0.25,0.35,0.5,0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; gr = new TGraphBentErrors(n,x,y,; exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.6 TGraphPolar; The TGraphPolar class creates a polar graph (including error bars). A TGraphPolar is a TGraphErrors represented in polar coordinates. It uses the class TGraphPolargram to draw the polar axis.; {; TCanvas *CPol = new TCanvas(""CPol"",""TGraphPolar Examples"",700,700);; Double_t rmin=0;; Double_t rmax=TMath::Pi()*2;; Double_t r[1000];; Double_t theta[1000];; TF1 * fp1 = new TF1(""fplot"",""cos(x)"",rmin,rmax);; for (Int_t ipt = 0; ipt < 1000; ipt++) {; r[ipt] = ipt*(rmax-rmin)/1000+rmin;; theta[ipt] = fp1->Eval(r[ipt]);; }; TGraphPolar * grP1 = new TGraphPolar(1000,r,theta);; grP1->SetLineColor(2);; grP1->Draw(""AOL"");; }; The TGraphPolar drawing options are:; “O” Polar labels are paint orthogonally to the polargram radius.; “P” Polymarker are paint at each point position.; “E” Paint error bars.; “F” Paint fill area (closed polygon).; “A”Force axis redrawing even if a polagram already exists. A polar graph. 4.7 TGraph Exclusion Zone; When a graph is painted with the option “C” or “L”, it is possible to draw a filled area ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:151936,Availability,error,error,151936,",.0,.05,.0};; gr = new TGraphBentErrors(n,x,y,; exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; 4.6 TGraphPolar; The TGraphPolar class creates a polar graph (including error bars). A TGraphPolar is a TGraphErrors represented in polar coordinates. It uses the class TGraphPolargram to draw the polar axis.; {; TCanvas *CPol = new TCanvas(""CPol"",""TGraphPolar Examples"",700,700);; Double_t rmin=0;; Double_t rmax=TMath::Pi()*2;; Double_t r[1000];; Double_t theta[1000];; TF1 * fp1 = new TF1(""fplot"",""cos(x)"",rmin,rmax);; for (Int_t ipt = 0; ipt < 1000; ipt++) {; r[ipt] = ipt*(rmax-rmin)/1000+rmin;; theta[ipt] = fp1->Eval(r[ipt]);; }; TGraphPolar * grP1 = new TGraphPolar(1000,r,theta);; grP1->SetLineColor(2);; grP1->Draw(""AOL"");; }; The TGraphPolar drawing options are:; “O” Polar labels are paint orthogonally to the polargram radius.; “P” Polymarker are paint at each point position.; “E” Paint error bars.; “F” Paint fill area (closed polygon).; “A”Force axis redrawing even if a polagram already exists. A polar graph. 4.7 TGraph Exclusion Zone; When a graph is painted with the option “C” or “L”, it is possible to draw a filled area on one side of the line. This is useful to show exclusion zones. This drawing mode is activated when the absolute value of the graph line width (set thanks to SetLineWidth) is greater than 99. In that case the line width number is interpreted as 100*ff+ll = ffll. The two-digit numbers “ll” represent the normal line width whereas “ff” is the filled area width. The sign of “ffll” allows flipping the filled area from one side of the line to the other. The current fill area attributes are used to draw the hatched zone. Graphs with exclusion zones. {; c1 = new TCanvas(""c1"",""Exclusion graphs examples"",200,10,700,500);; c1->SetGrid();. // create the multigraph; TMultiGraph *mg = new TMultiGraph();; mg->SetTitle(""Exclusion graphs"");. // create the graphs p",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:154327,Availability,robust,robust,154327,"gr2->SetLineColor(4);; gr2->SetLineWidth(-2002);; gr2->SetFillStyle(3004);; gr2->SetFillColor(9);. // create the 3rd TGraph; gr3 = new TGraph(n,x3,y3);; gr3->SetLineColor(5);; gr3->SetLineWidth(-802);; gr3->SetFillStyle(3002);; gr3->SetFillColor(2);. // put the graphs in the multigraph; mg->Add(gr1);; mg->Add(gr2);; mg->Add(gr3);. // draw the multigraph; mg->Draw(""AC"");; }; 4.8 TGraphQQ; A TGraphQQ allows drawing quantile-quantile plots. Such plots can be drawn for two datasets, or for one dataset and a theoretical distribution function.; 4.8.1 Two Datasets. Examples of qq-plots of 2 datasets. Quantile-quantile plots are used to determine whether two samples come from the same distribution. A qq-plot draws the quantiles of one dataset against the quantile of the other. The quantiles of the dataset with fewer entries are on Y-axis, with more entries - on X-axis. A straight line, going through 0.25 and 0.75 quantiles is also plotted for reference. It represents a robust linear fit, not sensitive to the extremes of the datasets. If the datasets come from the same distribution, points of the plot should fall approximately on the 45 degrees line. If they have the same distribution function, but different parameters of location or scale, they should still fall on the straight line, but not the 45 degrees one.; The greater their departure from the straight line, the more evidence there is that the datasets come from different distributions. The advantage of qq-plot is that it not only shows that the underlying distributions are different, but, unlike the analytical methods, it also gives information on the nature of this difference: heavier tails, different location/scale, different shape, etc.; 4.8.2 One Dataset. Examples of qq-plots of 1 dataset. Quantile-quantile plots are used to determine if the dataset comes from the specified theoretical distribution, such as normal. A qq-plot draws quantiles of the dataset against quantiles of the specified theoretical distribution",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:155509,Availability,robust,robust,155509," distribution function, but different parameters of location or scale, they should still fall on the straight line, but not the 45 degrees one.; The greater their departure from the straight line, the more evidence there is that the datasets come from different distributions. The advantage of qq-plot is that it not only shows that the underlying distributions are different, but, unlike the analytical methods, it also gives information on the nature of this difference: heavier tails, different location/scale, different shape, etc.; 4.8.2 One Dataset. Examples of qq-plots of 1 dataset. Quantile-quantile plots are used to determine if the dataset comes from the specified theoretical distribution, such as normal. A qq-plot draws quantiles of the dataset against quantiles of the specified theoretical distribution. Note, that density, not CDF should be specified a straight line, going through 0.25 and 0.75 quantiles could also be plotted for reference. It represents a robust linear fit, not sensitive to the extremes of the dataset. As in the two datasets case, departures from straight line indicate departures from the specified distribution. Next picture shows an example of a qq-plot of a dataset from N(3, 2) distribution and TMath::Gaus(0, 1) theoretical function. Fitting parameters are estimates of the distribution mean and sigma.; 4.9 TMultiGraph. A multigraph example. A TMultiGraph is a collection of TGraph (or derived) objects. Use TMultiGraph::Addto add a new graph to the list. The TMultiGraph owns the objects in the list. The drawing and fitting options are the same as for TGraph.; {; // create the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t x2[n] = {-.12,.15,.35,.45,.6,.71,.8,.95,.99,1.05};; Double_t y2[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the width of errors in x and y direction; Double_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t e",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:156434,Availability,error,errors,156434,"quantiles could also be plotted for reference. It represents a robust linear fit, not sensitive to the extremes of the dataset. As in the two datasets case, departures from straight line indicate departures from the specified distribution. Next picture shows an example of a qq-plot of a dataset from N(3, 2) distribution and TMath::Gaus(0, 1) theoretical function. Fitting parameters are estimates of the distribution mean and sigma.; 4.9 TMultiGraph. A multigraph example. A TMultiGraph is a collection of TGraph (or derived) objects. Use TMultiGraph::Addto add a new graph to the list. The TMultiGraph owns the objects in the list. The drawing and fitting options are the same as for TGraph.; {; // create the points; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t x2[n] = {-.12,.15,.35,.45,.6,.71,.8,.95,.99,1.05};; Double_t y2[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the width of errors in x and y direction; Double_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create two graphs; TGraph *gr1 = new TGraph(n,x2,y2);; TGraphErrors *gr2 = new TGraphErrors(n,x,y,ex,ey);. // create a multigraph and draw it; TMultiGraph *mg = new TMultiGraph();; mg->Add(gr1);; mg->Add(gr2);; mg->Draw(""ALP"");; }; 4.10 TGraph2D. Delaunay triangles and Voronoï diagram. This class is a set of N points x[i], y[i], z[i] in a non-uniform grid. Several visualization techniques are implemented, including Delaunay triangulation. Delaunay triangulation is defined as follow: ‘for a set S of points in the Euclidean plane, the unique triangulation DT(S) of S such that no point in S is inside the circum-circle of any triangle in DT(S). DT(S) is the dual of the Voronoï diagram of S. If n is the number of points in S, the Voronoï diagram of S is the partitioning of the plane containing S points into n convex polygons such that each polygon contains exact",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:160708,Availability,error,errors,160708,"erpolated surface thus takes the form of tessellating triangles at various angles. Output can take the form of a 2D histogram or a vector. The triangles found can be drawn in 3D. This software cannot be guaranteed to work under all circumstances. It was originally written to work with a few hundred points in anXY space with similar X and Y ranges. Graph2D drawn with option “surf1” and “tri1 p0”. {; TCanvas *c = new TCanvas(""c"",""Graph2D example"",0,0,700,600);; Double_t x, y, z, P = 6.;; Int_t np = 200;; TGraph2D *dt = new TGraph2D();; TRandom *r = new TRandom();. for (Int_t N=0; N<np; N++) {; x = 2*P*(r->Rndm(N))-P;; y = 2*P*(r->Rndm(N))-P;; z = (sin(x)/x)*(sin(y)/y)+0.2;; dt->SetPoint(N,x,y,z);; }; gStyle->SetPalette(55);; dt->Draw(""surf1""); // use ""surf1"" to generate the left picture; } // use ""tri1 p0"" to generate the right one; A more complete example is $ROOTSYS/tutorials/fit/graph2dfit.C that produces the next figure. Output of macro graph2dfit.C. 4.11 TGraph2DErrors; A TGraph2DErrors is a TGraph2D with errors. It is useful to perform fits with errors on a 2D graph. An example is the macro $ROOTSYS/tutorials/graphs/graph2derrorsfit.C.; 4.12 Fitting a Graph; The graph Fit method in general works the same way as the TH1::Fit. See “Fitting Histograms”.; 4.13 Setting the Graph’s Axis Title; To give the axis of a graph a title you need to draw the graph first, only then does it actually have an axis object. Once drawn, you set the title by getting the axis and calling the TAxis::SetTitle method, and if you want to center it, you can call the TAxis::CenterTitle method.; Assuming that n, x, and y are defined. Next code sets the titles of the x and y axes.; root[] gr5 = new TGraph(n,x,y); root[] gr5->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] gr5->Draw(""ALP""); root[] gr5->GetXaxis()->SetTitle(""X-Axis""); root[] gr5->GetYaxis()->SetTitle(""Y-Axis""); root[] gr5->GetXaxis()->CenterTitle(); root[] gr5->GetYaxis()->CenterTitle(); root[] gr5",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:160750,Availability,error,errors,160750,"gles at various angles. Output can take the form of a 2D histogram or a vector. The triangles found can be drawn in 3D. This software cannot be guaranteed to work under all circumstances. It was originally written to work with a few hundred points in anXY space with similar X and Y ranges. Graph2D drawn with option “surf1” and “tri1 p0”. {; TCanvas *c = new TCanvas(""c"",""Graph2D example"",0,0,700,600);; Double_t x, y, z, P = 6.;; Int_t np = 200;; TGraph2D *dt = new TGraph2D();; TRandom *r = new TRandom();. for (Int_t N=0; N<np; N++) {; x = 2*P*(r->Rndm(N))-P;; y = 2*P*(r->Rndm(N))-P;; z = (sin(x)/x)*(sin(y)/y)+0.2;; dt->SetPoint(N,x,y,z);; }; gStyle->SetPalette(55);; dt->Draw(""surf1""); // use ""surf1"" to generate the left picture; } // use ""tri1 p0"" to generate the right one; A more complete example is $ROOTSYS/tutorials/fit/graph2dfit.C that produces the next figure. Output of macro graph2dfit.C. 4.11 TGraph2DErrors; A TGraph2DErrors is a TGraph2D with errors. It is useful to perform fits with errors on a 2D graph. An example is the macro $ROOTSYS/tutorials/graphs/graph2derrorsfit.C.; 4.12 Fitting a Graph; The graph Fit method in general works the same way as the TH1::Fit. See “Fitting Histograms”.; 4.13 Setting the Graph’s Axis Title; To give the axis of a graph a title you need to draw the graph first, only then does it actually have an axis object. Once drawn, you set the title by getting the axis and calling the TAxis::SetTitle method, and if you want to center it, you can call the TAxis::CenterTitle method.; Assuming that n, x, and y are defined. Next code sets the titles of the x and y axes.; root[] gr5 = new TGraph(n,x,y); root[] gr5->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] gr5->Draw(""ALP""); root[] gr5->GetXaxis()->SetTitle(""X-Axis""); root[] gr5->GetYaxis()->SetTitle(""Y-Axis""); root[] gr5->GetXaxis()->CenterTitle(); root[] gr5->GetYaxis()->CenterTitle(); root[] gr5->Draw(""ALP""); For more graph examples see the scripts: $RO",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:164497,Availability,error,error,164497,"ts and programs.; 5.1 The Fit Method; The Fit method is implemented in ROOT for the histogram classes TH1, the sparse histogram classes, THnSparse, the graph classes, TGraph, TGraph2D and TMultiGraph for fitting a collection of Graphs with the same function.; 5.1.1 The TH1::Fit Method; To fit a histogram programmatically, you can use the TH1::Fit method. Here is the signatures of TH1::Fit and an explanation of the parameters:; TFitResultPtr Fit(TF1 *function, Option_t *option, Option_t *goption,; Axis_t xxmin, Axis_t xxmax). function a pointer to the fitted function (the fit model) object. One can also use the function name. This name may be one of ROOT pre-defined function names or a user-defined function. See the next paragraph for the list of pre-defined functions.; *option: The second parameter is the fitting option. Here is the list of fitting options:. “W” Set all weights to 1 for non empty bins; ignore error bars; “WW” Set all weights to 1 including empty bins; ignore error bars; “I” Use integral of function in bin instead of value at bin center; “L” Use log likelihood method (default is chi-square method). To be used when the histogram represents counts; “WL” Weighted log likelihood method. To be used when the histogram has been filled with weights different than 1.; “P” Use Pearson chi-square method, using expected errors instead of the observed one given by TH1::GetBinError (default case). The expected error is instead estimated from the square-root of the bin function value.; “Q” Quiet mode (minimum printing); “V” Verbose mode (default is between Q and V); “S” The result of the fit is returned in the TFitResultPtr.; “E” Perform better errors estimation using the Minos technique; “M” Improve fit results, by using the IMPROVE algorithm of TMinuit.; “R” Use the range specified in the function range; “N” Do not store the graphics function, do not draw; “0” Do not plot the result of the fit. By default the fitted function is drawn unless the option “N” above is",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:164564,Availability,error,error,164564,"ts and programs.; 5.1 The Fit Method; The Fit method is implemented in ROOT for the histogram classes TH1, the sparse histogram classes, THnSparse, the graph classes, TGraph, TGraph2D and TMultiGraph for fitting a collection of Graphs with the same function.; 5.1.1 The TH1::Fit Method; To fit a histogram programmatically, you can use the TH1::Fit method. Here is the signatures of TH1::Fit and an explanation of the parameters:; TFitResultPtr Fit(TF1 *function, Option_t *option, Option_t *goption,; Axis_t xxmin, Axis_t xxmax). function a pointer to the fitted function (the fit model) object. One can also use the function name. This name may be one of ROOT pre-defined function names or a user-defined function. See the next paragraph for the list of pre-defined functions.; *option: The second parameter is the fitting option. Here is the list of fitting options:. “W” Set all weights to 1 for non empty bins; ignore error bars; “WW” Set all weights to 1 including empty bins; ignore error bars; “I” Use integral of function in bin instead of value at bin center; “L” Use log likelihood method (default is chi-square method). To be used when the histogram represents counts; “WL” Weighted log likelihood method. To be used when the histogram has been filled with weights different than 1.; “P” Use Pearson chi-square method, using expected errors instead of the observed one given by TH1::GetBinError (default case). The expected error is instead estimated from the square-root of the bin function value.; “Q” Quiet mode (minimum printing); “V” Verbose mode (default is between Q and V); “S” The result of the fit is returned in the TFitResultPtr.; “E” Perform better errors estimation using the Minos technique; “M” Improve fit results, by using the IMPROVE algorithm of TMinuit.; “R” Use the range specified in the function range; “N” Do not store the graphics function, do not draw; “0” Do not plot the result of the fit. By default the fitted function is drawn unless the option “N” above is",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:164920,Availability,error,errors,164920,"ere is the signatures of TH1::Fit and an explanation of the parameters:; TFitResultPtr Fit(TF1 *function, Option_t *option, Option_t *goption,; Axis_t xxmin, Axis_t xxmax). function a pointer to the fitted function (the fit model) object. One can also use the function name. This name may be one of ROOT pre-defined function names or a user-defined function. See the next paragraph for the list of pre-defined functions.; *option: The second parameter is the fitting option. Here is the list of fitting options:. “W” Set all weights to 1 for non empty bins; ignore error bars; “WW” Set all weights to 1 including empty bins; ignore error bars; “I” Use integral of function in bin instead of value at bin center; “L” Use log likelihood method (default is chi-square method). To be used when the histogram represents counts; “WL” Weighted log likelihood method. To be used when the histogram has been filled with weights different than 1.; “P” Use Pearson chi-square method, using expected errors instead of the observed one given by TH1::GetBinError (default case). The expected error is instead estimated from the square-root of the bin function value.; “Q” Quiet mode (minimum printing); “V” Verbose mode (default is between Q and V); “S” The result of the fit is returned in the TFitResultPtr.; “E” Perform better errors estimation using the Minos technique; “M” Improve fit results, by using the IMPROVE algorithm of TMinuit.; “R” Use the range specified in the function range; “N” Do not store the graphics function, do not draw; “0” Do not plot the result of the fit. By default the fitted function is drawn unless the option “N” above is specified.; “+” Add this new fitted function to the list of fitted functions (by default, the previous function is deleted and only the last one is kept); “B”Use this option when you want to fix one or more parameters and the fitting function is a predefined one, like polN, expo, landau, gaus. Note that in case of pre-defined functions some default initi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:165010,Availability,error,error,165010,"tion_t *option, Option_t *goption,; Axis_t xxmin, Axis_t xxmax). function a pointer to the fitted function (the fit model) object. One can also use the function name. This name may be one of ROOT pre-defined function names or a user-defined function. See the next paragraph for the list of pre-defined functions.; *option: The second parameter is the fitting option. Here is the list of fitting options:. “W” Set all weights to 1 for non empty bins; ignore error bars; “WW” Set all weights to 1 including empty bins; ignore error bars; “I” Use integral of function in bin instead of value at bin center; “L” Use log likelihood method (default is chi-square method). To be used when the histogram represents counts; “WL” Weighted log likelihood method. To be used when the histogram has been filled with weights different than 1.; “P” Use Pearson chi-square method, using expected errors instead of the observed one given by TH1::GetBinError (default case). The expected error is instead estimated from the square-root of the bin function value.; “Q” Quiet mode (minimum printing); “V” Verbose mode (default is between Q and V); “S” The result of the fit is returned in the TFitResultPtr.; “E” Perform better errors estimation using the Minos technique; “M” Improve fit results, by using the IMPROVE algorithm of TMinuit.; “R” Use the range specified in the function range; “N” Do not store the graphics function, do not draw; “0” Do not plot the result of the fit. By default the fitted function is drawn unless the option “N” above is specified.; “+” Add this new fitted function to the list of fitted functions (by default, the previous function is deleted and only the last one is kept); “B”Use this option when you want to fix one or more parameters and the fitting function is a predefined one, like polN, expo, landau, gaus. Note that in case of pre-defined functions some default initial values and limits are set.; “C”In case of linear fitting, don’t calculate the chisquare (saves time).; “F",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:165248,Availability,error,errors,165248,"e the next paragraph for the list of pre-defined functions.; *option: The second parameter is the fitting option. Here is the list of fitting options:. “W” Set all weights to 1 for non empty bins; ignore error bars; “WW” Set all weights to 1 including empty bins; ignore error bars; “I” Use integral of function in bin instead of value at bin center; “L” Use log likelihood method (default is chi-square method). To be used when the histogram represents counts; “WL” Weighted log likelihood method. To be used when the histogram has been filled with weights different than 1.; “P” Use Pearson chi-square method, using expected errors instead of the observed one given by TH1::GetBinError (default case). The expected error is instead estimated from the square-root of the bin function value.; “Q” Quiet mode (minimum printing); “V” Verbose mode (default is between Q and V); “S” The result of the fit is returned in the TFitResultPtr.; “E” Perform better errors estimation using the Minos technique; “M” Improve fit results, by using the IMPROVE algorithm of TMinuit.; “R” Use the range specified in the function range; “N” Do not store the graphics function, do not draw; “0” Do not plot the result of the fit. By default the fitted function is drawn unless the option “N” above is specified.; “+” Add this new fitted function to the list of fitted functions (by default, the previous function is deleted and only the last one is kept); “B”Use this option when you want to fix one or more parameters and the fitting function is a predefined one, like polN, expo, landau, gaus. Note that in case of pre-defined functions some default initial values and limits are set.; “C”In case of linear fitting, don’t calculate the chisquare (saves time).; “F”If fitting a linear function (e.g. polN), switch to use the default minimizer (e.g. Minuit). By default, polN functions are fitted by the linear fitter. *goption:The third parameter is the graphics option that is the same as in the TH1::Draw (see the ch",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:166904,Availability,error,errors,166904," initial values and limits are set.; “C”In case of linear fitting, don’t calculate the chisquare (saves time).; “F”If fitting a linear function (e.g. polN), switch to use the default minimizer (e.g. Minuit). By default, polN functions are fitted by the linear fitter. *goption:The third parameter is the graphics option that is the same as in the TH1::Draw (see the chapter Draw Options).; xxmin, xxmax:Thee fourth and fifth parameters specify the range over which to apply the fit. By default, the fitted function object is added to the histogram and is drawn in the current pad.; 5.1.2 The TGraph::Fit Method; The signature for fitting a TGraph is exactly the same as for the TH1. Only some options apply only for fitting histograms, these are the options “L”, “WL” and “I”. These options apply instead only for TGraph::Fit, the rest of options (appart from “L”, “WL” and “I” are the same). TGraph specific options. “EX0” When fitting a TGraphErrors or a TgraphAsymErrors the errors on the coordinates are not used in the fit; “ROB” in case of linear fitting use the Robust fitting. Compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points.; “ROB=0.x” as above, but compute the LTS regression coefficients, using 0.x as a fraction of good points. 5.2 The TF1 function class; Here we will show how to create the TF1 class that is used for fitting histograms and graphs.; 5.2.1 Fit with a Predefined Function; To fit a histogram with a predefined function, simply pass the name of the function in the first parameter of TH1::Fit. For example, this line fits histogram object hist with a Gaussian.; root[] hist.Fit(""gaus"");; The initial parameter values (and eventual limits) for pre-defined functions are set automatically. For overriding the default limits values use the fit option B.; The list of pre-defined functions that can be used with the Fit method is the following:. “gaus” Gaussian function with 3 parameters: f(x) = p0*exp(-0.5*((",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:167052,Availability,robust,robust,167052,"n (e.g. polN), switch to use the default minimizer (e.g. Minuit). By default, polN functions are fitted by the linear fitter. *goption:The third parameter is the graphics option that is the same as in the TH1::Draw (see the chapter Draw Options).; xxmin, xxmax:Thee fourth and fifth parameters specify the range over which to apply the fit. By default, the fitted function object is added to the histogram and is drawn in the current pad.; 5.1.2 The TGraph::Fit Method; The signature for fitting a TGraph is exactly the same as for the TH1. Only some options apply only for fitting histograms, these are the options “L”, “WL” and “I”. These options apply instead only for TGraph::Fit, the rest of options (appart from “L”, “WL” and “I” are the same). TGraph specific options. “EX0” When fitting a TGraphErrors or a TgraphAsymErrors the errors on the coordinates are not used in the fit; “ROB” in case of linear fitting use the Robust fitting. Compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points.; “ROB=0.x” as above, but compute the LTS regression coefficients, using 0.x as a fraction of good points. 5.2 The TF1 function class; Here we will show how to create the TF1 class that is used for fitting histograms and graphs.; 5.2.1 Fit with a Predefined Function; To fit a histogram with a predefined function, simply pass the name of the function in the first parameter of TH1::Fit. For example, this line fits histogram object hist with a Gaussian.; root[] hist.Fit(""gaus"");; The initial parameter values (and eventual limits) for pre-defined functions are set automatically. For overriding the default limits values use the fit option B.; The list of pre-defined functions that can be used with the Fit method is the following:. “gaus” Gaussian function with 3 parameters: f(x) = p0*exp(-0.5*((x-p1)/p2)^2); “expo”An Exponential with 2 parameters: f(x) = exp(p0+p1*x); “polN” A polynomial of degree N, where N is a number between 0 and",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:178865,Availability,error,error,178865,"ctions and the combination function:; // Quadratic background function; Double_t background(Double_t *x, Double_t *par) {; return par[0] + par[1]*x[0] + par[2]*x[0]*x[0];; }. // Lorentzian Peak function; Double_t lorentzianPeak(Double_t *x, Double_t *par) {; return (0.5*par[0]*par[1]/TMath::Pi()) / TMath::Max(1.e-10,; (x[0]-par[2])*(x[0]-par[2])+ .25*par[1]*par[1]);; }. // Sum of background and peak function; Double_t fitFunction(Double_t *x, Double_t *par) {; return background(x,par) + lorentzianPeak(x,&par[3]);; }. void FittingDemo() {; // bevington exercise by P. Malzacher, modified by R. Brun; const int nBins = 60;; Stat_t data[nBins] = { 6, 1,10,12, 6,13,23,22,15,21,; 23,26,36,25,27,35,40,44,66,81,; 75,57,48,45,46,41,35,36,53,32,; 40,37,38,31,36,44,42,37,32,32,; 43,44,35,33,33,39,29,41,32,44,; 26,39,29,35,32,21,21,15,25,15};; TH1F *histo = new TH1F(""example_9_1"",; ""Lorentzian Peak on Quadratic Background"",60,0,3);. for(int i=0; i < nBins; i++) {; // we use these methods to explicitly set the content; // and error instead of using the fill method.; histo->SetBinContent(i+1,data[i]);; histo->SetBinError(i+1,TMath::Sqrt(data[i]));; }; // create a TF1 with the range from 0 to 3 and 6 parameters; TF1 *fitFcn = new TF1(""fitFcn"",fitFunction,0,3,6);. // first try without starting values for the parameters; // this defaults to 1 for each param.; histo->Fit(""fitFcn"");; // this results in an ok fit for the polynomial function however; // the non-linear part (Lorentzian. The output of the FittingDemo() example. 5.5 Result of the fit; Here we will show how to obtain the result of the fit (fitted function, parameter values, errors and eventually the covariance and correlation matrix).; 5.5.1 Associated Function; One or more objects (typically a TF1\*) can be added to the list of functions (fFunctions) associated to each histogram. A call to TH1::Fit adds the fitted function to this list. Given a histogram h, one can retrieve the associated function with:; TF1 *myfunc = h->Ge",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:179480,Availability,error,errors,179480,"ns = 60;; Stat_t data[nBins] = { 6, 1,10,12, 6,13,23,22,15,21,; 23,26,36,25,27,35,40,44,66,81,; 75,57,48,45,46,41,35,36,53,32,; 40,37,38,31,36,44,42,37,32,32,; 43,44,35,33,33,39,29,41,32,44,; 26,39,29,35,32,21,21,15,25,15};; TH1F *histo = new TH1F(""example_9_1"",; ""Lorentzian Peak on Quadratic Background"",60,0,3);. for(int i=0; i < nBins; i++) {; // we use these methods to explicitly set the content; // and error instead of using the fill method.; histo->SetBinContent(i+1,data[i]);; histo->SetBinError(i+1,TMath::Sqrt(data[i]));; }; // create a TF1 with the range from 0 to 3 and 6 parameters; TF1 *fitFcn = new TF1(""fitFcn"",fitFunction,0,3,6);. // first try without starting values for the parameters; // this defaults to 1 for each param.; histo->Fit(""fitFcn"");; // this results in an ok fit for the polynomial function however; // the non-linear part (Lorentzian. The output of the FittingDemo() example. 5.5 Result of the fit; Here we will show how to obtain the result of the fit (fitted function, parameter values, errors and eventually the covariance and correlation matrix).; 5.5.1 Associated Function; One or more objects (typically a TF1\*) can be added to the list of functions (fFunctions) associated to each histogram. A call to TH1::Fit adds the fitted function to this list. Given a histogram h, one can retrieve the associated function with:; TF1 *myfunc = h->GetFunction(""myfunc"");; 5.5.2 Access to the Fit Parameters and Results; If the histogram (or graph) is made persistent, the list of associated functions is also persistent. Retrieve a pointer to the function with the TH1::GetFunction() method. Then you can retrieve the fit parameters from the function (TF1) with calls such as:; root[] TF1 *fit = hist->GetFunction(function_name);; root[] Double_t chi2 = fit->GetChisquare();; // value of the first parameter; root[] Double_t p1 = fit->GetParameter(0);; // error of the first parameter; root[] Double_t e1 = fit->GetParError(0);; Using the fit option S one can access t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:180343,Availability,error,error,180343,"near part (Lorentzian. The output of the FittingDemo() example. 5.5 Result of the fit; Here we will show how to obtain the result of the fit (fitted function, parameter values, errors and eventually the covariance and correlation matrix).; 5.5.1 Associated Function; One or more objects (typically a TF1\*) can be added to the list of functions (fFunctions) associated to each histogram. A call to TH1::Fit adds the fitted function to this list. Given a histogram h, one can retrieve the associated function with:; TF1 *myfunc = h->GetFunction(""myfunc"");; 5.5.2 Access to the Fit Parameters and Results; If the histogram (or graph) is made persistent, the list of associated functions is also persistent. Retrieve a pointer to the function with the TH1::GetFunction() method. Then you can retrieve the fit parameters from the function (TF1) with calls such as:; root[] TF1 *fit = hist->GetFunction(function_name);; root[] Double_t chi2 = fit->GetChisquare();; // value of the first parameter; root[] Double_t p1 = fit->GetParameter(0);; // error of the first parameter; root[] Double_t e1 = fit->GetParError(0);; Using the fit option S one can access the full result of the fit including the covariance and correlation matrix. See later the paragraph TFitResult.; 5.5.3 Associated Errors; By default, for each bin, the sum of weights is computed at fill time. One can also call TH1::Sumw2 to force the storage and computation of the sum of the square of weights per bin. If Sumw2 has been called, the error per bin is computed as the sqrt(sum of squares of weights); otherwise, the error is set equal to the sqrt(bin content). To return the error for a given bin number, do:; Double_t error = h->GetBinError(bin);; Empty bins are excluded in the fit when using the Chi-square fit method. When fitting an histogram representing counts (i.e with Poisson statistics) it is recommended to use the Log-Likelihood method (option ‘L’ or “WL”), particularly in case of low statistics. When the histogram has b",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:180804,Availability,error,error,180804,"unc"");; 5.5.2 Access to the Fit Parameters and Results; If the histogram (or graph) is made persistent, the list of associated functions is also persistent. Retrieve a pointer to the function with the TH1::GetFunction() method. Then you can retrieve the fit parameters from the function (TF1) with calls such as:; root[] TF1 *fit = hist->GetFunction(function_name);; root[] Double_t chi2 = fit->GetChisquare();; // value of the first parameter; root[] Double_t p1 = fit->GetParameter(0);; // error of the first parameter; root[] Double_t e1 = fit->GetParError(0);; Using the fit option S one can access the full result of the fit including the covariance and correlation matrix. See later the paragraph TFitResult.; 5.5.3 Associated Errors; By default, for each bin, the sum of weights is computed at fill time. One can also call TH1::Sumw2 to force the storage and computation of the sum of the square of weights per bin. If Sumw2 has been called, the error per bin is computed as the sqrt(sum of squares of weights); otherwise, the error is set equal to the sqrt(bin content). To return the error for a given bin number, do:; Double_t error = h->GetBinError(bin);; Empty bins are excluded in the fit when using the Chi-square fit method. When fitting an histogram representing counts (i.e with Poisson statistics) it is recommended to use the Log-Likelihood method (option ‘L’ or “WL”), particularly in case of low statistics. When the histogram has been filled with weights different than one, a weighted likelihood method can be used and the errors retrieved from the fit are corrected following a procedure described in paragraph 8.5.2 of the book, F. James, Statistical Methods in Experimental Physics, 2nd Edition.; 5.5.4 Fit Statistics; You can change the statistics box to display the fit parameters with the TStyle::SetOptFit(mode) method. This parameter has four digits: mode = pcev (default = 0111). p = 1 print probability; c = 1 print Chi-square/number of degrees of freedom; e = 1 prin",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:180885,Availability,error,error,180885,"unc"");; 5.5.2 Access to the Fit Parameters and Results; If the histogram (or graph) is made persistent, the list of associated functions is also persistent. Retrieve a pointer to the function with the TH1::GetFunction() method. Then you can retrieve the fit parameters from the function (TF1) with calls such as:; root[] TF1 *fit = hist->GetFunction(function_name);; root[] Double_t chi2 = fit->GetChisquare();; // value of the first parameter; root[] Double_t p1 = fit->GetParameter(0);; // error of the first parameter; root[] Double_t e1 = fit->GetParError(0);; Using the fit option S one can access the full result of the fit including the covariance and correlation matrix. See later the paragraph TFitResult.; 5.5.3 Associated Errors; By default, for each bin, the sum of weights is computed at fill time. One can also call TH1::Sumw2 to force the storage and computation of the sum of the square of weights per bin. If Sumw2 has been called, the error per bin is computed as the sqrt(sum of squares of weights); otherwise, the error is set equal to the sqrt(bin content). To return the error for a given bin number, do:; Double_t error = h->GetBinError(bin);; Empty bins are excluded in the fit when using the Chi-square fit method. When fitting an histogram representing counts (i.e with Poisson statistics) it is recommended to use the Log-Likelihood method (option ‘L’ or “WL”), particularly in case of low statistics. When the histogram has been filled with weights different than one, a weighted likelihood method can be used and the errors retrieved from the fit are corrected following a procedure described in paragraph 8.5.2 of the book, F. James, Statistical Methods in Experimental Physics, 2nd Edition.; 5.5.4 Fit Statistics; You can change the statistics box to display the fit parameters with the TStyle::SetOptFit(mode) method. This parameter has four digits: mode = pcev (default = 0111). p = 1 print probability; c = 1 print Chi-square/number of degrees of freedom; e = 1 prin",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:180944,Availability,error,error,180944,"etrieve a pointer to the function with the TH1::GetFunction() method. Then you can retrieve the fit parameters from the function (TF1) with calls such as:; root[] TF1 *fit = hist->GetFunction(function_name);; root[] Double_t chi2 = fit->GetChisquare();; // value of the first parameter; root[] Double_t p1 = fit->GetParameter(0);; // error of the first parameter; root[] Double_t e1 = fit->GetParError(0);; Using the fit option S one can access the full result of the fit including the covariance and correlation matrix. See later the paragraph TFitResult.; 5.5.3 Associated Errors; By default, for each bin, the sum of weights is computed at fill time. One can also call TH1::Sumw2 to force the storage and computation of the sum of the square of weights per bin. If Sumw2 has been called, the error per bin is computed as the sqrt(sum of squares of weights); otherwise, the error is set equal to the sqrt(bin content). To return the error for a given bin number, do:; Double_t error = h->GetBinError(bin);; Empty bins are excluded in the fit when using the Chi-square fit method. When fitting an histogram representing counts (i.e with Poisson statistics) it is recommended to use the Log-Likelihood method (option ‘L’ or “WL”), particularly in case of low statistics. When the histogram has been filled with weights different than one, a weighted likelihood method can be used and the errors retrieved from the fit are corrected following a procedure described in paragraph 8.5.2 of the book, F. James, Statistical Methods in Experimental Physics, 2nd Edition.; 5.5.4 Fit Statistics; You can change the statistics box to display the fit parameters with the TStyle::SetOptFit(mode) method. This parameter has four digits: mode = pcev (default = 0111). p = 1 print probability; c = 1 print Chi-square/number of degrees of freedom; e = 1 print errors (if e=1, v must be 1); v = 1 print name/values of parameters. For example, to print the fit probability, parameter names/values, and errors, use:; gSt",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:180988,Availability,error,error,180988,"etrieve a pointer to the function with the TH1::GetFunction() method. Then you can retrieve the fit parameters from the function (TF1) with calls such as:; root[] TF1 *fit = hist->GetFunction(function_name);; root[] Double_t chi2 = fit->GetChisquare();; // value of the first parameter; root[] Double_t p1 = fit->GetParameter(0);; // error of the first parameter; root[] Double_t e1 = fit->GetParError(0);; Using the fit option S one can access the full result of the fit including the covariance and correlation matrix. See later the paragraph TFitResult.; 5.5.3 Associated Errors; By default, for each bin, the sum of weights is computed at fill time. One can also call TH1::Sumw2 to force the storage and computation of the sum of the square of weights per bin. If Sumw2 has been called, the error per bin is computed as the sqrt(sum of squares of weights); otherwise, the error is set equal to the sqrt(bin content). To return the error for a given bin number, do:; Double_t error = h->GetBinError(bin);; Empty bins are excluded in the fit when using the Chi-square fit method. When fitting an histogram representing counts (i.e with Poisson statistics) it is recommended to use the Log-Likelihood method (option ‘L’ or “WL”), particularly in case of low statistics. When the histogram has been filled with weights different than one, a weighted likelihood method can be used and the errors retrieved from the fit are corrected following a procedure described in paragraph 8.5.2 of the book, F. James, Statistical Methods in Experimental Physics, 2nd Edition.; 5.5.4 Fit Statistics; You can change the statistics box to display the fit parameters with the TStyle::SetOptFit(mode) method. This parameter has four digits: mode = pcev (default = 0111). p = 1 print probability; c = 1 print Chi-square/number of degrees of freedom; e = 1 print errors (if e=1, v must be 1); v = 1 print name/values of parameters. For example, to print the fit probability, parameter names/values, and errors, use:; gSt",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:181397,Availability,error,errors,181397,"ble_t e1 = fit->GetParError(0);; Using the fit option S one can access the full result of the fit including the covariance and correlation matrix. See later the paragraph TFitResult.; 5.5.3 Associated Errors; By default, for each bin, the sum of weights is computed at fill time. One can also call TH1::Sumw2 to force the storage and computation of the sum of the square of weights per bin. If Sumw2 has been called, the error per bin is computed as the sqrt(sum of squares of weights); otherwise, the error is set equal to the sqrt(bin content). To return the error for a given bin number, do:; Double_t error = h->GetBinError(bin);; Empty bins are excluded in the fit when using the Chi-square fit method. When fitting an histogram representing counts (i.e with Poisson statistics) it is recommended to use the Log-Likelihood method (option ‘L’ or “WL”), particularly in case of low statistics. When the histogram has been filled with weights different than one, a weighted likelihood method can be used and the errors retrieved from the fit are corrected following a procedure described in paragraph 8.5.2 of the book, F. James, Statistical Methods in Experimental Physics, 2nd Edition.; 5.5.4 Fit Statistics; You can change the statistics box to display the fit parameters with the TStyle::SetOptFit(mode) method. This parameter has four digits: mode = pcev (default = 0111). p = 1 print probability; c = 1 print Chi-square/number of degrees of freedom; e = 1 print errors (if e=1, v must be 1); v = 1 print name/values of parameters. For example, to print the fit probability, parameter names/values, and errors, use:; gStyle->SetOptFit(1011);; 5.6 The Fit Panel. The Fit Panel. To display the Fit Panel right click on a histogram to pop up the context menu, and then select the menu entry Fit Panel.; The new Fit Panel GUI is available in ROOT v5.14. Its goal is to replace the old Fit Panel and to provide more user friendly way for performing, exploring and comparing fits.; By design, this us",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:181853,Availability,error,errors,181853,"(sum of squares of weights); otherwise, the error is set equal to the sqrt(bin content). To return the error for a given bin number, do:; Double_t error = h->GetBinError(bin);; Empty bins are excluded in the fit when using the Chi-square fit method. When fitting an histogram representing counts (i.e with Poisson statistics) it is recommended to use the Log-Likelihood method (option ‘L’ or “WL”), particularly in case of low statistics. When the histogram has been filled with weights different than one, a weighted likelihood method can be used and the errors retrieved from the fit are corrected following a procedure described in paragraph 8.5.2 of the book, F. James, Statistical Methods in Experimental Physics, 2nd Edition.; 5.5.4 Fit Statistics; You can change the statistics box to display the fit parameters with the TStyle::SetOptFit(mode) method. This parameter has four digits: mode = pcev (default = 0111). p = 1 print probability; c = 1 print Chi-square/number of degrees of freedom; e = 1 print errors (if e=1, v must be 1); v = 1 print name/values of parameters. For example, to print the fit probability, parameter names/values, and errors, use:; gStyle->SetOptFit(1011);; 5.6 The Fit Panel. The Fit Panel. To display the Fit Panel right click on a histogram to pop up the context menu, and then select the menu entry Fit Panel.; The new Fit Panel GUI is available in ROOT v5.14. Its goal is to replace the old Fit Panel and to provide more user friendly way for performing, exploring and comparing fits.; By design, this user interface is planned to contain two tabs: “General” and “Minimization”. Currently, the “General” tab provides user interface elements for setting the fit function, fit method and different fit, draw, print options. The “Minimization tab” provides the option to set the Minimizer to use in the fit and its specific options.; The new fit panel is a modeless dialog, i.e. when opened, it does not prevent users from interacting with other windows. Its first ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:181993,Availability,error,errors,181993," Double_t error = h->GetBinError(bin);; Empty bins are excluded in the fit when using the Chi-square fit method. When fitting an histogram representing counts (i.e with Poisson statistics) it is recommended to use the Log-Likelihood method (option ‘L’ or “WL”), particularly in case of low statistics. When the histogram has been filled with weights different than one, a weighted likelihood method can be used and the errors retrieved from the fit are corrected following a procedure described in paragraph 8.5.2 of the book, F. James, Statistical Methods in Experimental Physics, 2nd Edition.; 5.5.4 Fit Statistics; You can change the statistics box to display the fit parameters with the TStyle::SetOptFit(mode) method. This parameter has four digits: mode = pcev (default = 0111). p = 1 print probability; c = 1 print Chi-square/number of degrees of freedom; e = 1 print errors (if e=1, v must be 1); v = 1 print name/values of parameters. For example, to print the fit probability, parameter names/values, and errors, use:; gStyle->SetOptFit(1011);; 5.6 The Fit Panel. The Fit Panel. To display the Fit Panel right click on a histogram to pop up the context menu, and then select the menu entry Fit Panel.; The new Fit Panel GUI is available in ROOT v5.14. Its goal is to replace the old Fit Panel and to provide more user friendly way for performing, exploring and comparing fits.; By design, this user interface is planned to contain two tabs: “General” and “Minimization”. Currently, the “General” tab provides user interface elements for setting the fit function, fit method and different fit, draw, print options. The “Minimization tab” provides the option to set the Minimizer to use in the fit and its specific options.; The new fit panel is a modeless dialog, i.e. when opened, it does not prevent users from interacting with other windows. Its first prototype is a singleton application. When the Fit Panel is activated, users can select an object for fitting in the usual way, i.e. by ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:182215,Availability,avail,available,182215,"ethod (option ‘L’ or “WL”), particularly in case of low statistics. When the histogram has been filled with weights different than one, a weighted likelihood method can be used and the errors retrieved from the fit are corrected following a procedure described in paragraph 8.5.2 of the book, F. James, Statistical Methods in Experimental Physics, 2nd Edition.; 5.5.4 Fit Statistics; You can change the statistics box to display the fit parameters with the TStyle::SetOptFit(mode) method. This parameter has four digits: mode = pcev (default = 0111). p = 1 print probability; c = 1 print Chi-square/number of degrees of freedom; e = 1 print errors (if e=1, v must be 1); v = 1 print name/values of parameters. For example, to print the fit probability, parameter names/values, and errors, use:; gStyle->SetOptFit(1011);; 5.6 The Fit Panel. The Fit Panel. To display the Fit Panel right click on a histogram to pop up the context menu, and then select the menu entry Fit Panel.; The new Fit Panel GUI is available in ROOT v5.14. Its goal is to replace the old Fit Panel and to provide more user friendly way for performing, exploring and comparing fits.; By design, this user interface is planned to contain two tabs: “General” and “Minimization”. Currently, the “General” tab provides user interface elements for setting the fit function, fit method and different fit, draw, print options. The “Minimization tab” provides the option to set the Minimizer to use in the fit and its specific options.; The new fit panel is a modeless dialog, i.e. when opened, it does not prevent users from interacting with other windows. Its first prototype is a singleton application. When the Fit Panel is activated, users can select an object for fitting in the usual way, i.e. by left-mouse click on it. If the selected object is suitable for fitting, the fit panel is connected with this object and users can perform fits by setting different parameters and options.; 5.6.1 Function Choice and Settings; ‘Predefin",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:183763,Availability,error,error,183763,"n opened, it does not prevent users from interacting with other windows. Its first prototype is a singleton application. When the Fit Panel is activated, users can select an object for fitting in the usual way, i.e. by left-mouse click on it. If the selected object is suitable for fitting, the fit panel is connected with this object and users can perform fits by setting different parameters and options.; 5.6.1 Function Choice and Settings; ‘Predefined’ combo box - contains a list of predefined functions in ROOT. You have a choice of several polynomials, a Gaussian, a Landau, and an Exponential function. The default one is Gaussian.; ‘Operation’ radio button group defines the selected operational mode between functions:; Nop - no operation (default);; Add - addition;; Conv - convolution (will be implemented in the future).; Users can enter the function expression into the text entry field below the ‘Predefined’ combo box. The entered string is checked after the Enter key was pressed and an error message shows up, if the function string is not accepted.; ‘Set Parameters’ button opens a dialog for parameters settings, which will be explained later.; 5.6.2 Fitter Settings; ‘Method’ combo box currently provides only two fit model choices: Chi-square and Binned Likelihood. The default one is Chi-square. The Binned Likelihood is recommended for bins with low statistics.; ‘Linear Fit’ check button sets the use of Linear fitter when is selected. Otherwise the minimization is done by Minuit, i.e. fit option “F” is applied. The Linear fitter can be selected only for functions linear in parameters (for example - polN).; ‘Robust’ number entry sets the robust value when fitting graphs.; ‘No Chi-square’ check button switch On/Off the fit option “C” - do not calculate Chi-square (for Linear fitter).; ‘Integral’ check button switch On/Off the option “I” - use integral of function instead of value in bin center.; ‘Best Errors’ sets On/Off the option “E” - better errors estimation by u",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:184426,Availability,robust,robust,184426,"roup defines the selected operational mode between functions:; Nop - no operation (default);; Add - addition;; Conv - convolution (will be implemented in the future).; Users can enter the function expression into the text entry field below the ‘Predefined’ combo box. The entered string is checked after the Enter key was pressed and an error message shows up, if the function string is not accepted.; ‘Set Parameters’ button opens a dialog for parameters settings, which will be explained later.; 5.6.2 Fitter Settings; ‘Method’ combo box currently provides only two fit model choices: Chi-square and Binned Likelihood. The default one is Chi-square. The Binned Likelihood is recommended for bins with low statistics.; ‘Linear Fit’ check button sets the use of Linear fitter when is selected. Otherwise the minimization is done by Minuit, i.e. fit option “F” is applied. The Linear fitter can be selected only for functions linear in parameters (for example - polN).; ‘Robust’ number entry sets the robust value when fitting graphs.; ‘No Chi-square’ check button switch On/Off the fit option “C” - do not calculate Chi-square (for Linear fitter).; ‘Integral’ check button switch On/Off the option “I” - use integral of function instead of value in bin center.; ‘Best Errors’ sets On/Off the option “E” - better errors estimation by using Minos technique.; ‘All weights = 1’ sets On/Off the option “W”- all weights set to 1 excluding empty bins; error bars ignored.; ‘Empty bins, weights=1’ sets On/Off the option “WW” - all weights equal to 1 including empty bins; error bars ignored.; ‘Use range’ sets On/Off the option “R” - fit only data within the specified function range. Sliders settings are used if this option is set to On. Users can change the function range values by pressing the left mouse button near to the left/right slider edges. It is possible to change both values simultaneously by pressing the left mouse button near to the slider center and moving it to a new position.; ‘Impro",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:184738,Availability,error,errors,184738," Enter key was pressed and an error message shows up, if the function string is not accepted.; ‘Set Parameters’ button opens a dialog for parameters settings, which will be explained later.; 5.6.2 Fitter Settings; ‘Method’ combo box currently provides only two fit model choices: Chi-square and Binned Likelihood. The default one is Chi-square. The Binned Likelihood is recommended for bins with low statistics.; ‘Linear Fit’ check button sets the use of Linear fitter when is selected. Otherwise the minimization is done by Minuit, i.e. fit option “F” is applied. The Linear fitter can be selected only for functions linear in parameters (for example - polN).; ‘Robust’ number entry sets the robust value when fitting graphs.; ‘No Chi-square’ check button switch On/Off the fit option “C” - do not calculate Chi-square (for Linear fitter).; ‘Integral’ check button switch On/Off the option “I” - use integral of function instead of value in bin center.; ‘Best Errors’ sets On/Off the option “E” - better errors estimation by using Minos technique.; ‘All weights = 1’ sets On/Off the option “W”- all weights set to 1 excluding empty bins; error bars ignored.; ‘Empty bins, weights=1’ sets On/Off the option “WW” - all weights equal to 1 including empty bins; error bars ignored.; ‘Use range’ sets On/Off the option “R” - fit only data within the specified function range. Sliders settings are used if this option is set to On. Users can change the function range values by pressing the left mouse button near to the left/right slider edges. It is possible to change both values simultaneously by pressing the left mouse button near to the slider center and moving it to a new position.; ‘Improve fit results’ sets On/Off the option “M”- after minimum is found, search for a new one.; ‘Add to list’ sets On/Off the option “+”- add function to the list without deleting the previous one. When fitting a histogram, the function is attached to the histogram’s list of functions. By default, the previously",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:184872,Availability,error,error,184872,"ameters’ button opens a dialog for parameters settings, which will be explained later.; 5.6.2 Fitter Settings; ‘Method’ combo box currently provides only two fit model choices: Chi-square and Binned Likelihood. The default one is Chi-square. The Binned Likelihood is recommended for bins with low statistics.; ‘Linear Fit’ check button sets the use of Linear fitter when is selected. Otherwise the minimization is done by Minuit, i.e. fit option “F” is applied. The Linear fitter can be selected only for functions linear in parameters (for example - polN).; ‘Robust’ number entry sets the robust value when fitting graphs.; ‘No Chi-square’ check button switch On/Off the fit option “C” - do not calculate Chi-square (for Linear fitter).; ‘Integral’ check button switch On/Off the option “I” - use integral of function instead of value in bin center.; ‘Best Errors’ sets On/Off the option “E” - better errors estimation by using Minos technique.; ‘All weights = 1’ sets On/Off the option “W”- all weights set to 1 excluding empty bins; error bars ignored.; ‘Empty bins, weights=1’ sets On/Off the option “WW” - all weights equal to 1 including empty bins; error bars ignored.; ‘Use range’ sets On/Off the option “R” - fit only data within the specified function range. Sliders settings are used if this option is set to On. Users can change the function range values by pressing the left mouse button near to the left/right slider edges. It is possible to change both values simultaneously by pressing the left mouse button near to the slider center and moving it to a new position.; ‘Improve fit results’ sets On/Off the option “M”- after minimum is found, search for a new one.; ‘Add to list’ sets On/Off the option “+”- add function to the list without deleting the previous one. When fitting a histogram, the function is attached to the histogram’s list of functions. By default, the previously fitted function is deleted and replaced with the most recent one, so the list only contains one funct",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:184992,Availability,error,error,184992,"hod’ combo box currently provides only two fit model choices: Chi-square and Binned Likelihood. The default one is Chi-square. The Binned Likelihood is recommended for bins with low statistics.; ‘Linear Fit’ check button sets the use of Linear fitter when is selected. Otherwise the minimization is done by Minuit, i.e. fit option “F” is applied. The Linear fitter can be selected only for functions linear in parameters (for example - polN).; ‘Robust’ number entry sets the robust value when fitting graphs.; ‘No Chi-square’ check button switch On/Off the fit option “C” - do not calculate Chi-square (for Linear fitter).; ‘Integral’ check button switch On/Off the option “I” - use integral of function instead of value in bin center.; ‘Best Errors’ sets On/Off the option “E” - better errors estimation by using Minos technique.; ‘All weights = 1’ sets On/Off the option “W”- all weights set to 1 excluding empty bins; error bars ignored.; ‘Empty bins, weights=1’ sets On/Off the option “WW” - all weights equal to 1 including empty bins; error bars ignored.; ‘Use range’ sets On/Off the option “R” - fit only data within the specified function range. Sliders settings are used if this option is set to On. Users can change the function range values by pressing the left mouse button near to the left/right slider edges. It is possible to change both values simultaneously by pressing the left mouse button near to the slider center and moving it to a new position.; ‘Improve fit results’ sets On/Off the option “M”- after minimum is found, search for a new one.; ‘Add to list’ sets On/Off the option “+”- add function to the list without deleting the previous one. When fitting a histogram, the function is attached to the histogram’s list of functions. By default, the previously fitted function is deleted and replaced with the most recent one, so the list only contains one function. Setting this option to On will add the newly fitted function to the existing list of functions for the histogr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:188128,Availability,toler,tolerance,188128,"Conf Interval : to plot the confidence interval of the fitted function as a filled coloured band around its central value. One can select the desired confidence level for the band to be plotted. 5.6.5 Print Options; This set of options specifies the amount of feedback printed on the root command line after performed fits.; ‘Verbose’ - prints fit results after each iteration.; ‘Quiet’ - no fit information is printed.; ‘Default’ - between Verbose and Quiet.; 5.6.6 Command Buttons; Fit button - performs a fit taking different option settings via the Fit Panel interface.; Reset - sets the GUI elements and related fit settings to the default ones.; Close - closes the Fit panel window.; 5.6.7 Minimization Options; With this tab one can select specific options for minimization. These include. The minimizer library ( Minuit, Minuit2, Fumili, GSL, Genetics ); The method (algorithm) for minimization. For example for Minuit one can choose between (Migrad, Simplex or Scan); Error definition; Minimization tolerance; Number of iterations/function calls; Print Level: (Default, Verbose or Quiet). 5.7 New ROOT::Fit classes; The fitting of the data objects in ROOT, histograms, graphs and tree is performed via some common classes, which are defined in the ROOT::Fit namespace. These classes can be classified in the following groups:. User classes driving the fit: ROOT::Fit::Fitter for executing the fit, ROOT::Fit::FitConfig for configuring the fit, ROOT::Fit::ParameterSettings to define the properties of the fit parameters (initial values, bounds, etc..), ROOT::Fit::FitResult for storing the result of the fit.; Data classes containing the data sets used in the fitting. These classes are theROOT::Fit::BinDatafor describing bin data sets, thus data points containing both coordinates and a corresponding value/weight with optionally an error on the value or the coordinate and the ROOT::Fit::UnBinData for un-binned data sets, which consists only of a vector of coordinate values. The coordin",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:188964,Availability,error,error,188964,"uit2, Fumili, GSL, Genetics ); The method (algorithm) for minimization. For example for Minuit one can choose between (Migrad, Simplex or Scan); Error definition; Minimization tolerance; Number of iterations/function calls; Print Level: (Default, Verbose or Quiet). 5.7 New ROOT::Fit classes; The fitting of the data objects in ROOT, histograms, graphs and tree is performed via some common classes, which are defined in the ROOT::Fit namespace. These classes can be classified in the following groups:. User classes driving the fit: ROOT::Fit::Fitter for executing the fit, ROOT::Fit::FitConfig for configuring the fit, ROOT::Fit::ParameterSettings to define the properties of the fit parameters (initial values, bounds, etc..), ROOT::Fit::FitResult for storing the result of the fit.; Data classes containing the data sets used in the fitting. These classes are theROOT::Fit::BinDatafor describing bin data sets, thus data points containing both coordinates and a corresponding value/weight with optionally an error on the value or the coordinate and the ROOT::Fit::UnBinData for un-binned data sets, which consists only of a vector of coordinate values. The coordinate values can be one-dimensional (i.e. one entry per event) or multi-dimensional (N entries per event).; Function classes defining the type of fit (the objective function used for fitting):. ROOT::Fit::Chi2FCN for chi2 (least-square fits),; ROOT::Fit::PoissonLikelihoodFCN for binned likelihood fits of histograms,; ROOT::Fit::LogLikelihoodFCN for generic un-binned likelihood fits. These classes are templated on the type of function interface they implement (see later). User convenient typedefs are also provided. They derive from the common generic interface multi-dimensional for function evaluation, ROOT::Math::IBaseFunctionMultiDim. In addition the fitter classes make uses of the generic interfaces for parametric function evaluations, ROOT::Math::IParametricFunctionMultiDim to define the fit model function and use the RO",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:190869,Availability,error,errors,190869,"and use the ROOT::Math::Minimizer interface to perform the minimization of the objective function. More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter.; Here we present a detailed description of the ROOT::Fit classes and how to use them. Using these classes instead of the interface provided directly in the ROOT data objects, like TH1::Fit allow are more fine control to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed.; To understand how these class work, let’s go through a simple example, such as fitting an histogram.; When fitting an histogram, instead of using TH1::Fit we will show in the following hot wo use the ROOT::Fit classes. We will show how to perform the following different type of fits with the histogram data: * a least square fit using the observed errors (Neyman chi-squared); * a least square fit using the expected errors from the function (Pearson chi-squared); * a binned likelihood fit; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it.; Let’s go through all the steps required for performing these fits using the ROOT::Fit::Fitter class. These steps are: 1. Create the input fit data object. 2. Create the input model function. 3. Configure the fit. 4. Perform the data fitting. 5. Examine the result.; 5.7.1 Creating the input fit data; We have two types of input data, binned data (class ROOT::Fit::BinData) used for least square (chi-square) fits of histograms or TGraph objects or un-binned data (class ROOT::Fit::UnBinData) used for fitting vectors of data points (e.g. from a TTree).; 5.7.1.1 Using Binned data; Let’s suppose we have an histogram, represented as a TH1 type object (it can be one or multi-dimensional). The following shows how to create and fill a ROOT:Fit::BinData object.; ROOT::Fit::DataOptions opt;; opt.fInt",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:190938,Availability,error,errors,190938,"and use the ROOT::Math::Minimizer interface to perform the minimization of the objective function. More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter.; Here we present a detailed description of the ROOT::Fit classes and how to use them. Using these classes instead of the interface provided directly in the ROOT data objects, like TH1::Fit allow are more fine control to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed.; To understand how these class work, let’s go through a simple example, such as fitting an histogram.; When fitting an histogram, instead of using TH1::Fit we will show in the following hot wo use the ROOT::Fit classes. We will show how to perform the following different type of fits with the histogram data: * a least square fit using the observed errors (Neyman chi-squared); * a least square fit using the expected errors from the function (Pearson chi-squared); * a binned likelihood fit; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it.; Let’s go through all the steps required for performing these fits using the ROOT::Fit::Fitter class. These steps are: 1. Create the input fit data object. 2. Create the input model function. 3. Configure the fit. 4. Perform the data fitting. 5. Examine the result.; 5.7.1 Creating the input fit data; We have two types of input data, binned data (class ROOT::Fit::BinData) used for least square (chi-square) fits of histograms or TGraph objects or un-binned data (class ROOT::Fit::UnBinData) used for fitting vectors of data points (e.g. from a TTree).; 5.7.1.1 Using Binned data; Let’s suppose we have an histogram, represented as a TH1 type object (it can be one or multi-dimensional). The following shows how to create and fill a ROOT:Fit::BinData object.; ROOT::Fit::DataOptions opt;; opt.fInt",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:193395,Availability,avail,available,193395,"ry, ROOT::Fit::FillData to fill the BinData object. The ROOT::Fit::FillData is defined in the headerfile HFitInterface.h and it has a signature for all different ROOT objects, like TH1, THnBase, TGraph, TGraph2D and TMultiGraph It is possible to specify, when creating the BinData object, the data range we want to use and some fitting options we want to apply to fill in the object and later when fitting. The fit data options are controlled by the ROOT::Fit::DataOptions class, the range by the ROOT::Fit::DataRange class.; Here is an example how to specify the input option to use the integral of the function value in the bin instead of using the function value evaluated at the bin center, when doing the fit and to use a range beween the ‘xmin’ and ‘xmax’ values.; ROOT::Fit::DataOptions opt;; opt.fIntegral = true;; ROOT::Fit::DataRange range(xmin,xmax);; ROOT::Fit::BinData data(opt,range);; // fill the bin data using the histogram; // we can do this using the following helper function from the Hist library; TH1 * h1 = (TH1*) gDirectory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; The list of possible fit options available is the following:; ROOT::Fit::DataOptions opt;; opt.fIntegral = true; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors a",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:193848,Availability,error,errors,193848," instead of using the function value evaluated at the bin center, when doing the fit and to use a range beween the ‘xmin’ and ‘xmax’ values.; ROOT::Fit::DataOptions opt;; opt.fIntegral = true;; ROOT::Fit::DataRange range(xmin,xmax);; ROOT::Fit::BinData data(opt,range);; // fill the bin data using the histogram; // we can do this using the following helper function from the Hist library; TH1 * h1 = (TH1*) gDirectory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; The list of possible fit options available is the following:; ROOT::Fit::DataOptions opt;; opt.fIntegral = true; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; The ROOT::Fit::DataRange class supports defining multiple rectangular ranges in each dimension, and supports n-dimension. The function DataRange::AddRange(icoord,xmin,xmax) adds a range in the coordinate icoord with lower value xmin and upper value xmax:; ROOT::Fit::DataRange range;; range.AddRang",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:193943,Availability,error,errors,193943," instead of using the function value evaluated at the bin center, when doing the fit and to use a range beween the ‘xmin’ and ‘xmax’ values.; ROOT::Fit::DataOptions opt;; opt.fIntegral = true;; ROOT::Fit::DataRange range(xmin,xmax);; ROOT::Fit::BinData data(opt,range);; // fill the bin data using the histogram; // we can do this using the following helper function from the Hist library; TH1 * h1 = (TH1*) gDirectory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; The list of possible fit options available is the following:; ROOT::Fit::DataOptions opt;; opt.fIntegral = true; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; The ROOT::Fit::DataRange class supports defining multiple rectangular ranges in each dimension, and supports n-dimension. The function DataRange::AddRange(icoord,xmin,xmax) adds a range in the coordinate icoord with lower value xmin and upper value xmax:; ROOT::Fit::DataRange range;; range.AddRang",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:194086,Availability,error,error,194086," ROOT::Fit::DataRange range(xmin,xmax);; ROOT::Fit::BinData data(opt,range);; // fill the bin data using the histogram; // we can do this using the following helper function from the Hist library; TH1 * h1 = (TH1*) gDirectory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; The list of possible fit options available is the following:; ROOT::Fit::DataOptions opt;; opt.fIntegral = true; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; The ROOT::Fit::DataRange class supports defining multiple rectangular ranges in each dimension, and supports n-dimension. The function DataRange::AddRange(icoord,xmin,xmax) adds a range in the coordinate icoord with lower value xmin and upper value xmax:; ROOT::Fit::DataRange range;; range.AddRange(icoordinate, xmin, xmax);; 5.7.1.2 Using Un-Binned data; The unbinned data sets are represented with the ROOT::Fit::UnBinData class. For creating un-binned data sets, a ROOT::Fit::UnBinData ob",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:194165,Availability,error,errors,194165," fill the bin data using the histogram; // we can do this using the following helper function from the Hist library; TH1 * h1 = (TH1*) gDirectory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; The list of possible fit options available is the following:; ROOT::Fit::DataOptions opt;; opt.fIntegral = true; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; The ROOT::Fit::DataRange class supports defining multiple rectangular ranges in each dimension, and supports n-dimension. The function DataRange::AddRange(icoord,xmin,xmax) adds a range in the coordinate icoord with lower value xmin and upper value xmax:; ROOT::Fit::DataRange range;; range.AddRange(icoordinate, xmin, xmax);; 5.7.1.2 Using Un-Binned data; The unbinned data sets are represented with the ROOT::Fit::UnBinData class. For creating un-binned data sets, a ROOT::Fit::UnBinData object, one has two possibilities: 1. Copy the data inside ROOT::Fit::UnBinData. ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:194232,Availability,avail,available,194232,"TH1 * h1 = (TH1*) gDirectory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; The list of possible fit options available is the following:; ROOT::Fit::DataOptions opt;; opt.fIntegral = true; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; The ROOT::Fit::DataRange class supports defining multiple rectangular ranges in each dimension, and supports n-dimension. The function DataRange::AddRange(icoord,xmin,xmax) adds a range in the coordinate icoord with lower value xmin and upper value xmax:; ROOT::Fit::DataRange range;; range.AddRange(icoordinate, xmin, xmax);; 5.7.1.2 Using Un-Binned data; The unbinned data sets are represented with the ROOT::Fit::UnBinData class. For creating un-binned data sets, a ROOT::Fit::UnBinData object, one has two possibilities: 1. Copy the data inside ROOT::Fit::UnBinData. One can create an empty UnBinData object, iterate on the data and add the data point one by one, or directly create th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:194253,Availability,error,errors,194253,"TH1 * h1 = (TH1*) gDirectory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; The list of possible fit options available is the following:; ROOT::Fit::DataOptions opt;; opt.fIntegral = true; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; The ROOT::Fit::DataRange class supports defining multiple rectangular ranges in each dimension, and supports n-dimension. The function DataRange::AddRange(icoord,xmin,xmax) adds a range in the coordinate icoord with lower value xmin and upper value xmax:; ROOT::Fit::DataRange range;; range.AddRange(icoordinate, xmin, xmax);; 5.7.1.2 Using Un-Binned data; The unbinned data sets are represented with the ROOT::Fit::UnBinData class. For creating un-binned data sets, a ROOT::Fit::UnBinData object, one has two possibilities: 1. Copy the data inside ROOT::Fit::UnBinData. One can create an empty UnBinData object, iterate on the data and add the data point one by one, or directly create th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:194310,Availability,error,errors,194310,"TH1 * h1 = (TH1*) gDirectory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; The list of possible fit options available is the following:; ROOT::Fit::DataOptions opt;; opt.fIntegral = true; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; The ROOT::Fit::DataRange class supports defining multiple rectangular ranges in each dimension, and supports n-dimension. The function DataRange::AddRange(icoord,xmin,xmax) adds a range in the coordinate icoord with lower value xmin and upper value xmax:; ROOT::Fit::DataRange range;; range.AddRange(icoordinate, xmin, xmax);; 5.7.1.2 Using Un-Binned data; The unbinned data sets are represented with the ROOT::Fit::UnBinData class. For creating un-binned data sets, a ROOT::Fit::UnBinData object, one has two possibilities: 1. Copy the data inside ROOT::Fit::UnBinData. One can create an empty UnBinData object, iterate on the data and add the data point one by one, or directly create th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:194340,Availability,avail,available,194340,"TH1 * h1 = (TH1*) gDirectory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; The list of possible fit options available is the following:; ROOT::Fit::DataOptions opt;; opt.fIntegral = true; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; The ROOT::Fit::DataRange class supports defining multiple rectangular ranges in each dimension, and supports n-dimension. The function DataRange::AddRange(icoord,xmin,xmax) adds a range in the coordinate icoord with lower value xmin and upper value xmax:; ROOT::Fit::DataRange range;; range.AddRange(icoordinate, xmin, xmax);; 5.7.1.2 Using Un-Binned data; The unbinned data sets are represented with the ROOT::Fit::UnBinData class. For creating un-binned data sets, a ROOT::Fit::UnBinData object, one has two possibilities: 1. Copy the data inside ROOT::Fit::UnBinData. One can create an empty UnBinData object, iterate on the data and add the data point one by one, or directly create th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:194419,Availability,avail,available,194419,"; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; The ROOT::Fit::DataRange class supports defining multiple rectangular ranges in each dimension, and supports n-dimension. The function DataRange::AddRange(icoord,xmin,xmax) adds a range in the coordinate icoord with lower value xmin and upper value xmax:; ROOT::Fit::DataRange range;; range.AddRange(icoordinate, xmin, xmax);; 5.7.1.2 Using Un-Binned data; The unbinned data sets are represented with the ROOT::Fit::UnBinData class. For creating un-binned data sets, a ROOT::Fit::UnBinData object, one has two possibilities: 1. Copy the data inside ROOT::Fit::UnBinData. One can create an empty UnBinData object, iterate on the data and add the data point one by one, or directly create the UnBinData object from a data iterator. In this case an input ROOT::Fit::DataRange object is passed in order to copy the data according to the given range. 2. Use ROOT::Fit::UnBinData as a wrap",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:194440,Availability,error,errors,194440,"; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; The ROOT::Fit::DataRange class supports defining multiple rectangular ranges in each dimension, and supports n-dimension. The function DataRange::AddRange(icoord,xmin,xmax) adds a range in the coordinate icoord with lower value xmin and upper value xmax:; ROOT::Fit::DataRange range;; range.AddRange(icoordinate, xmin, xmax);; 5.7.1.2 Using Un-Binned data; The unbinned data sets are represented with the ROOT::Fit::UnBinData class. For creating un-binned data sets, a ROOT::Fit::UnBinData object, one has two possibilities: 1. Copy the data inside ROOT::Fit::UnBinData. One can create an empty UnBinData object, iterate on the data and add the data point one by one, or directly create the UnBinData object from a data iterator. In this case an input ROOT::Fit::DataRange object is passed in order to copy the data according to the given range. 2. Use ROOT::Fit::UnBinData as a wrap",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:194510,Availability,error,errors,194510,"; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; The ROOT::Fit::DataRange class supports defining multiple rectangular ranges in each dimension, and supports n-dimension. The function DataRange::AddRange(icoord,xmin,xmax) adds a range in the coordinate icoord with lower value xmin and upper value xmax:; ROOT::Fit::DataRange range;; range.AddRange(icoordinate, xmin, xmax);; 5.7.1.2 Using Un-Binned data; The unbinned data sets are represented with the ROOT::Fit::UnBinData class. For creating un-binned data sets, a ROOT::Fit::UnBinData object, one has two possibilities: 1. Copy the data inside ROOT::Fit::UnBinData. One can create an empty UnBinData object, iterate on the data and add the data point one by one, or directly create the UnBinData object from a data iterator. In this case an input ROOT::Fit::DataRange object is passed in order to copy the data according to the given range. 2. Use ROOT::Fit::UnBinData as a wrap",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:194540,Availability,avail,available,194540,"; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; The ROOT::Fit::DataRange class supports defining multiple rectangular ranges in each dimension, and supports n-dimension. The function DataRange::AddRange(icoord,xmin,xmax) adds a range in the coordinate icoord with lower value xmin and upper value xmax:; ROOT::Fit::DataRange range;; range.AddRange(icoordinate, xmin, xmax);; 5.7.1.2 Using Un-Binned data; The unbinned data sets are represented with the ROOT::Fit::UnBinData class. For creating un-binned data sets, a ROOT::Fit::UnBinData object, one has two possibilities: 1. Copy the data inside ROOT::Fit::UnBinData. One can create an empty UnBinData object, iterate on the data and add the data point one by one, or directly create the UnBinData object from a data iterator. In this case an input ROOT::Fit::DataRange object is passed in order to copy the data according to the given range. 2. Use ROOT::Fit::UnBinData as a wrap",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:198135,Availability,avail,available,198135,"itrary number k of independent variables. For example, when fitting a k-dimensional histogram, the independent variables X are the bin center coordinates and Y is the bin weight.; The model function needs to be expressed as function of some unknown parameters. The fitting will find the best parameter value to describe the observed data.; We can use the ROOT TF1 class, the parametric function class, to describe the model function. However the ROOT::Fit::Fitter class, to be independent of the ROOT Hist library, takes as input a more general parametric function object, the interface (abstract) class ROOT::Math::IParametricFunctionMultiDim, which describe a generic one or multi-dimensional function with parameters. This interface extends the abstract class ROOT::Math::IBaseFunctionMultiDim, with methods to set/retrieve parameter values and to evaluate the function given the independent vector of values X and vector of parameters P. More information about the different ROOT::Math function interfaces is available in the Mathematical Library chapter.; An end-user can convert a TF1 object in a ROOT::Math::IParametricFunctionMultiDim, using the wrapper class ROOT::Math::WrapperMultiTF1:; TF1 * f1 = new TF1(""f1"",""gaus"");; ROOT::Math::WrappedMultiTF1 fitFunction(f1, f1->GetNdim() );; ROOT::Fit::Fitter fitter;; fitter.SetFunction( fitFunction, false);; When creating the wrapper, the parameter values stored in TF1 will be copied in the ROOT::Math::WrappedMultiTF1 object. The function object representing the model function is given to the ROOT::Fitter class using the Fitter::SetFunction method.; The user has also the possibility to provide a function object, which implements the derivatives of the function with respect to the parameters. This information might be useful for some types of fits. In this case he needs to provide the function object as a class deriving from the ROOT::Math::IParametricGradFunctionMultiDim interface. Note that the wrapper class ROOT::Math::WrappedMulti",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:200176,Availability,toler,tolerance,200176," also the gradient interface, using internally TF1::GradientPar, which is based on numerical differentiation, apart for the case of linear functions (i.e. when TF1::IsLinear() is true). The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili. However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised numerical differentiation algorithm. In order to not provide to the fitter the parameter derivatives, we explicitly passed in Fitter::SetFunction a false value.; 5.7.3 Fit Configuration; The configuration of the fit is done via the ROOT::Fit::FitConfig class and its contained ROOT::Fit::ParameterSettings class. These are the possible allowed fit configurations:. setting the initial values of the parameters;; setting the parameter step sizes;; setting eventual parameter bounds;; setting the minimizer library and the particular algorithm to use;; setting different minimization options (print level, tolerance, max iterations, etc…); setting the type of parameter errors to compute (parabolic error, Minos errors, re-normalize errors using fitted chi2 values). The initial parameter values can be set directly in the input model function object. However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the ROOT::Fit::ParameterSetting class. This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; Note that a ROOT::Fit::ParameterSettings objects exists for each fit parameter and it created by the ROOT::Fit::FitConfig class, after the model function has been set in the Fitter. Only when the function is set, the number of parameter is known and automatically the FitConfig creates ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:200240,Availability,error,errors,200240," also the gradient interface, using internally TF1::GradientPar, which is based on numerical differentiation, apart for the case of linear functions (i.e. when TF1::IsLinear() is true). The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili. However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised numerical differentiation algorithm. In order to not provide to the fitter the parameter derivatives, we explicitly passed in Fitter::SetFunction a false value.; 5.7.3 Fit Configuration; The configuration of the fit is done via the ROOT::Fit::FitConfig class and its contained ROOT::Fit::ParameterSettings class. These are the possible allowed fit configurations:. setting the initial values of the parameters;; setting the parameter step sizes;; setting eventual parameter bounds;; setting the minimizer library and the particular algorithm to use;; setting different minimization options (print level, tolerance, max iterations, etc…); setting the type of parameter errors to compute (parabolic error, Minos errors, re-normalize errors using fitted chi2 values). The initial parameter values can be set directly in the input model function object. However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the ROOT::Fit::ParameterSetting class. This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; Note that a ROOT::Fit::ParameterSettings objects exists for each fit parameter and it created by the ROOT::Fit::FitConfig class, after the model function has been set in the Fitter. Only when the function is set, the number of parameter is known and automatically the FitConfig creates ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:200269,Availability,error,error,200269," also the gradient interface, using internally TF1::GradientPar, which is based on numerical differentiation, apart for the case of linear functions (i.e. when TF1::IsLinear() is true). The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili. However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised numerical differentiation algorithm. In order to not provide to the fitter the parameter derivatives, we explicitly passed in Fitter::SetFunction a false value.; 5.7.3 Fit Configuration; The configuration of the fit is done via the ROOT::Fit::FitConfig class and its contained ROOT::Fit::ParameterSettings class. These are the possible allowed fit configurations:. setting the initial values of the parameters;; setting the parameter step sizes;; setting eventual parameter bounds;; setting the minimizer library and the particular algorithm to use;; setting different minimization options (print level, tolerance, max iterations, etc…); setting the type of parameter errors to compute (parabolic error, Minos errors, re-normalize errors using fitted chi2 values). The initial parameter values can be set directly in the input model function object. However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the ROOT::Fit::ParameterSetting class. This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; Note that a ROOT::Fit::ParameterSettings objects exists for each fit parameter and it created by the ROOT::Fit::FitConfig class, after the model function has been set in the Fitter. Only when the function is set, the number of parameter is known and automatically the FitConfig creates ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:200282,Availability,error,errors,200282," also the gradient interface, using internally TF1::GradientPar, which is based on numerical differentiation, apart for the case of linear functions (i.e. when TF1::IsLinear() is true). The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili. However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised numerical differentiation algorithm. In order to not provide to the fitter the parameter derivatives, we explicitly passed in Fitter::SetFunction a false value.; 5.7.3 Fit Configuration; The configuration of the fit is done via the ROOT::Fit::FitConfig class and its contained ROOT::Fit::ParameterSettings class. These are the possible allowed fit configurations:. setting the initial values of the parameters;; setting the parameter step sizes;; setting eventual parameter bounds;; setting the minimizer library and the particular algorithm to use;; setting different minimization options (print level, tolerance, max iterations, etc…); setting the type of parameter errors to compute (parabolic error, Minos errors, re-normalize errors using fitted chi2 values). The initial parameter values can be set directly in the input model function object. However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the ROOT::Fit::ParameterSetting class. This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; Note that a ROOT::Fit::ParameterSettings objects exists for each fit parameter and it created by the ROOT::Fit::FitConfig class, after the model function has been set in the Fitter. Only when the function is set, the number of parameter is known and automatically the FitConfig creates ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:200303,Availability,error,errors,200303," also the gradient interface, using internally TF1::GradientPar, which is based on numerical differentiation, apart for the case of linear functions (i.e. when TF1::IsLinear() is true). The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili. However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised numerical differentiation algorithm. In order to not provide to the fitter the parameter derivatives, we explicitly passed in Fitter::SetFunction a false value.; 5.7.3 Fit Configuration; The configuration of the fit is done via the ROOT::Fit::FitConfig class and its contained ROOT::Fit::ParameterSettings class. These are the possible allowed fit configurations:. setting the initial values of the parameters;; setting the parameter step sizes;; setting eventual parameter bounds;; setting the minimizer library and the particular algorithm to use;; setting different minimization options (print level, tolerance, max iterations, etc…); setting the type of parameter errors to compute (parabolic error, Minos errors, re-normalize errors using fitted chi2 values). The initial parameter values can be set directly in the input model function object. However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the ROOT::Fit::ParameterSetting class. This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; Note that a ROOT::Fit::ParameterSettings objects exists for each fit parameter and it created by the ROOT::Fit::FitConfig class, after the model function has been set in the Fitter. Only when the function is set, the number of parameter is known and automatically the FitConfig creates ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:201725,Availability,avail,available,201725,"ttings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; Note that a ROOT::Fit::ParameterSettings objects exists for each fit parameter and it created by the ROOT::Fit::FitConfig class, after the model function has been set in the Fitter. Only when the function is set, the number of parameter is known and automatically the FitConfig creates the corresponding ParameterSetting objects.; When fitting, different minimizer can be used. The can be implemented in different libraries and loaded ar run time by the plug-in manager system of ROOT. Each different minimizer (e.g. Minuit, Minuit2, Fumili, etc.) consists of a different implementation of the ROOT::Math::Minimizer interface. Within the same minimizer, thus within the same class implementing the Minimizer interface, different algorithms can exist. For example in the case of Minuit, we have Migrad, Simplex or Minimize. The minimizer and its corresponding algorithm, when available, can be set by using the function FitConfig::SetMinimizer(""minimizerName"") or by using directly the ROOT:Math::MinimizerOptions class.; If the requested minimizer is not available in ROOT, the default one is used. The default minimizer type and algorithm can be specified by using the static function ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""minimizerName""); 5.7.4 Minimizer Libraries and Algorithms; The list of available minimizer libraries currently available in ROOT, with their corresponding available algorithms is the following one. Some minimizers (e.g. Minuit) contain several algorithms that the user can choose. Others are based on a single algorithm (e.g. Fumili). Minuit (library libMinuit). Old version of Minuit, based on the TMinuit class. The list of possible algorithms are:. Migrad (default one); Simplex; Minimize (it is a combination of Migrad and Simplex); MigradImproved; Scan; Seek. Minuit2 (library libMinuit2). New C++ version of Minuit. The list of possible algorithm is :. Migrad (default); Simplex",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:201905,Availability,avail,available,201905,"r each fit parameter and it created by the ROOT::Fit::FitConfig class, after the model function has been set in the Fitter. Only when the function is set, the number of parameter is known and automatically the FitConfig creates the corresponding ParameterSetting objects.; When fitting, different minimizer can be used. The can be implemented in different libraries and loaded ar run time by the plug-in manager system of ROOT. Each different minimizer (e.g. Minuit, Minuit2, Fumili, etc.) consists of a different implementation of the ROOT::Math::Minimizer interface. Within the same minimizer, thus within the same class implementing the Minimizer interface, different algorithms can exist. For example in the case of Minuit, we have Migrad, Simplex or Minimize. The minimizer and its corresponding algorithm, when available, can be set by using the function FitConfig::SetMinimizer(""minimizerName"") or by using directly the ROOT:Math::MinimizerOptions class.; If the requested minimizer is not available in ROOT, the default one is used. The default minimizer type and algorithm can be specified by using the static function ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""minimizerName""); 5.7.4 Minimizer Libraries and Algorithms; The list of available minimizer libraries currently available in ROOT, with their corresponding available algorithms is the following one. Some minimizers (e.g. Minuit) contain several algorithms that the user can choose. Others are based on a single algorithm (e.g. Fumili). Minuit (library libMinuit). Old version of Minuit, based on the TMinuit class. The list of possible algorithms are:. Migrad (default one); Simplex; Minimize (it is a combination of Migrad and Simplex); MigradImproved; Scan; Seek. Minuit2 (library libMinuit2). New C++ version of Minuit. The list of possible algorithm is :. Migrad (default); Simplex; Minimize; Scan; Fumili . This is the same algorithm of TFumili, but implemented in the Minuit2 library. Fumili. Implement a dedicated mi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:202158,Availability,avail,available,202158,"ifferent minimizer can be used. The can be implemented in different libraries and loaded ar run time by the plug-in manager system of ROOT. Each different minimizer (e.g. Minuit, Minuit2, Fumili, etc.) consists of a different implementation of the ROOT::Math::Minimizer interface. Within the same minimizer, thus within the same class implementing the Minimizer interface, different algorithms can exist. For example in the case of Minuit, we have Migrad, Simplex or Minimize. The minimizer and its corresponding algorithm, when available, can be set by using the function FitConfig::SetMinimizer(""minimizerName"") or by using directly the ROOT:Math::MinimizerOptions class.; If the requested minimizer is not available in ROOT, the default one is used. The default minimizer type and algorithm can be specified by using the static function ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""minimizerName""); 5.7.4 Minimizer Libraries and Algorithms; The list of available minimizer libraries currently available in ROOT, with their corresponding available algorithms is the following one. Some minimizers (e.g. Minuit) contain several algorithms that the user can choose. Others are based on a single algorithm (e.g. Fumili). Minuit (library libMinuit). Old version of Minuit, based on the TMinuit class. The list of possible algorithms are:. Migrad (default one); Simplex; Minimize (it is a combination of Migrad and Simplex); MigradImproved; Scan; Seek. Minuit2 (library libMinuit2). New C++ version of Minuit. The list of possible algorithm is :. Migrad (default); Simplex; Minimize; Scan; Fumili . This is the same algorithm of TFumili, but implemented in the Minuit2 library. Fumili. Implement a dedicated minimization algorithm for least-square and likelihood fits. It has requirements on the type of method function to be used. No specific algorithm exists; GSLMultiMin (library libMathMore). Minimizer based on the Multidimensional Minimization routines of the Gnu Scientific Library (GSL). T",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:202198,Availability,avail,available,202198,"ifferent minimizer can be used. The can be implemented in different libraries and loaded ar run time by the plug-in manager system of ROOT. Each different minimizer (e.g. Minuit, Minuit2, Fumili, etc.) consists of a different implementation of the ROOT::Math::Minimizer interface. Within the same minimizer, thus within the same class implementing the Minimizer interface, different algorithms can exist. For example in the case of Minuit, we have Migrad, Simplex or Minimize. The minimizer and its corresponding algorithm, when available, can be set by using the function FitConfig::SetMinimizer(""minimizerName"") or by using directly the ROOT:Math::MinimizerOptions class.; If the requested minimizer is not available in ROOT, the default one is used. The default minimizer type and algorithm can be specified by using the static function ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""minimizerName""); 5.7.4 Minimizer Libraries and Algorithms; The list of available minimizer libraries currently available in ROOT, with their corresponding available algorithms is the following one. Some minimizers (e.g. Minuit) contain several algorithms that the user can choose. Others are based on a single algorithm (e.g. Fumili). Minuit (library libMinuit). Old version of Minuit, based on the TMinuit class. The list of possible algorithms are:. Migrad (default one); Simplex; Minimize (it is a combination of Migrad and Simplex); MigradImproved; Scan; Seek. Minuit2 (library libMinuit2). New C++ version of Minuit. The list of possible algorithm is :. Migrad (default); Simplex; Minimize; Scan; Fumili . This is the same algorithm of TFumili, but implemented in the Minuit2 library. Fumili. Implement a dedicated minimization algorithm for least-square and likelihood fits. It has requirements on the type of method function to be used. No specific algorithm exists; GSLMultiMin (library libMathMore). Minimizer based on the Multidimensional Minimization routines of the Gnu Scientific Library (GSL). T",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:202242,Availability,avail,available,202242,"ifferent minimizer can be used. The can be implemented in different libraries and loaded ar run time by the plug-in manager system of ROOT. Each different minimizer (e.g. Minuit, Minuit2, Fumili, etc.) consists of a different implementation of the ROOT::Math::Minimizer interface. Within the same minimizer, thus within the same class implementing the Minimizer interface, different algorithms can exist. For example in the case of Minuit, we have Migrad, Simplex or Minimize. The minimizer and its corresponding algorithm, when available, can be set by using the function FitConfig::SetMinimizer(""minimizerName"") or by using directly the ROOT:Math::MinimizerOptions class.; If the requested minimizer is not available in ROOT, the default one is used. The default minimizer type and algorithm can be specified by using the static function ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""minimizerName""); 5.7.4 Minimizer Libraries and Algorithms; The list of available minimizer libraries currently available in ROOT, with their corresponding available algorithms is the following one. Some minimizers (e.g. Minuit) contain several algorithms that the user can choose. Others are based on a single algorithm (e.g. Fumili). Minuit (library libMinuit). Old version of Minuit, based on the TMinuit class. The list of possible algorithms are:. Migrad (default one); Simplex; Minimize (it is a combination of Migrad and Simplex); MigradImproved; Scan; Seek. Minuit2 (library libMinuit2). New C++ version of Minuit. The list of possible algorithm is :. Migrad (default); Simplex; Minimize; Scan; Fumili . This is the same algorithm of TFumili, but implemented in the Minuit2 library. Fumili. Implement a dedicated minimization algorithm for least-square and likelihood fits. It has requirements on the type of method function to be used. No specific algorithm exists; GSLMultiMin (library libMathMore). Minimizer based on the Multidimensional Minimization routines of the Gnu Scientific Library (GSL). T",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:203207,Availability,avail,available,203207,"OOT, with their corresponding available algorithms is the following one. Some minimizers (e.g. Minuit) contain several algorithms that the user can choose. Others are based on a single algorithm (e.g. Fumili). Minuit (library libMinuit). Old version of Minuit, based on the TMinuit class. The list of possible algorithms are:. Migrad (default one); Simplex; Minimize (it is a combination of Migrad and Simplex); MigradImproved; Scan; Seek. Minuit2 (library libMinuit2). New C++ version of Minuit. The list of possible algorithm is :. Migrad (default); Simplex; Minimize; Scan; Fumili . This is the same algorithm of TFumili, but implemented in the Minuit2 library. Fumili. Implement a dedicated minimization algorithm for least-square and likelihood fits. It has requirements on the type of method function to be used. No specific algorithm exists; GSLMultiMin (library libMathMore). Minimizer based on the Multidimensional Minimization routines of the Gnu Scientific Library (GSL). The list of available algorithms is. BFGS2 (default) : second version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; BFGS : old version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; ConjugateFR : Fletcher-Reeves conjugate gradient algorithm;; ConjugatePR : Polak-Ribiere conjugate gradient algorithm;; SteepestDescent: steepest descent algorithm;. GSLMultiFit (library libMathMore). Minimizer based on the Non-Linear Least-Square routines of GSL. This minimizer can be used only for least-square fits.; GSLSimAn (library libMathMore). Minimizer based on simulated annealing.; Genetic (library libGenetic). Genetic minimizer based on an algorithm implemented in the TMVA package. Each minimizer can be configured using the ROOT::Math::MinimizerOptions class. The list of possible option that can be set are:. Minimizer type (MinimizerOptions::SetMinimizerType(const char *)) .; Minimizer algorithm (MinimizerOptions::SetMinimizerAlgorithm(const char *)).; Print Level (MinimizerOp",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:204344,Availability,toler,tolerance,204344," old version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; ConjugateFR : Fletcher-Reeves conjugate gradient algorithm;; ConjugatePR : Polak-Ribiere conjugate gradient algorithm;; SteepestDescent: steepest descent algorithm;. GSLMultiFit (library libMathMore). Minimizer based on the Non-Linear Least-Square routines of GSL. This minimizer can be used only for least-square fits.; GSLSimAn (library libMathMore). Minimizer based on simulated annealing.; Genetic (library libGenetic). Genetic minimizer based on an algorithm implemented in the TMVA package. Each minimizer can be configured using the ROOT::Math::MinimizerOptions class. The list of possible option that can be set are:. Minimizer type (MinimizerOptions::SetMinimizerType(const char *)) .; Minimizer algorithm (MinimizerOptions::SetMinimizerAlgorithm(const char *)).; Print Level (MinimizerOptions::SetPrintLevel(int )) to set the verbose printing level (default is 0).; Tolerance (MinimizerOptions::SetTolerance(double )) tolerance used to control the iterations.; Maximum number of function calls (MinimizerOptions::SetMaxFunctionCalls(int )).; Maximum number of iterations (MinimizerOptions::SetMaxIterations(int )). Note that this is not used by Minuit; FCN Upper value for Error Definition (MinimizerOptions::SetErrorDef(double )). Value in the minimization function used to compute the parameter errors. The default is to get the uncertainties at the 68% CL is a value of 1 for a chi-squared function minimization and 0.5 for a log-likelihood function.; Strategy (MinimizerOptions::SetStrategy(int )), minimization strategy used. For each minimization strategy Minuit uses different configuration parameters (e.g. different requirements in computing derivatives, computing full Hessian (strategy = 2) or an approximate version. The default is a value of 1. In this case the full Hessian matrix is computed only after the minimization.; Precision (MinimizerOptions::SetPrecision(double )). Precision value in the",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:204723,Availability,error,errors,204723,"er can be used only for least-square fits.; GSLSimAn (library libMathMore). Minimizer based on simulated annealing.; Genetic (library libGenetic). Genetic minimizer based on an algorithm implemented in the TMVA package. Each minimizer can be configured using the ROOT::Math::MinimizerOptions class. The list of possible option that can be set are:. Minimizer type (MinimizerOptions::SetMinimizerType(const char *)) .; Minimizer algorithm (MinimizerOptions::SetMinimizerAlgorithm(const char *)).; Print Level (MinimizerOptions::SetPrintLevel(int )) to set the verbose printing level (default is 0).; Tolerance (MinimizerOptions::SetTolerance(double )) tolerance used to control the iterations.; Maximum number of function calls (MinimizerOptions::SetMaxFunctionCalls(int )).; Maximum number of iterations (MinimizerOptions::SetMaxIterations(int )). Note that this is not used by Minuit; FCN Upper value for Error Definition (MinimizerOptions::SetErrorDef(double )). Value in the minimization function used to compute the parameter errors. The default is to get the uncertainties at the 68% CL is a value of 1 for a chi-squared function minimization and 0.5 for a log-likelihood function.; Strategy (MinimizerOptions::SetStrategy(int )), minimization strategy used. For each minimization strategy Minuit uses different configuration parameters (e.g. different requirements in computing derivatives, computing full Hessian (strategy = 2) or an approximate version. The default is a value of 1. In this case the full Hessian matrix is computed only after the minimization.; Precision (MinimizerOptions::SetPrecision(double )). Precision value in the evaluation of the minimization function. Default is numerical double precision. Note that not all the options are implemented by all the minimizers. For example in Minuit is possible to set the maximum number of function calls, but not the maximum number of iterations. The Strategy and the Precision options apply instead only for Minuit (and Minuit2).; ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:206429,Availability,avail,available,206429,"ault is numerical double precision. Note that not all the options are implemented by all the minimizers. For example in Minuit is possible to set the maximum number of function calls, but not the maximum number of iterations. The Strategy and the Precision options apply instead only for Minuit (and Minuit2).; The class supports also setting global default values for the options, by using the static functions MinimizerOptions::SetDefault... (for example MinimizerOptions::SetDefaultPrintLevel(int )). The static functions can be also used to set the minimizer options when using TH1::Fit or TGraph::Fit. The list of the current option values can be inspected by using MinimizerOptions::Print.; ROOT::Math::MinimizerOptions() opt;; // print the default minimizer option values; opt.Print();; In addition it is possible to provide extra options which might apply for a particular minimizer MinimizerOptions::SetExtraOptions(const IOptions & ). See the documentation of the particular minimizer to use for the list of possible additional options available.; 5.7.5 Performing the Fit; Here we have now all the required input ingredients for the fit, the data and the function to fit. Depending on these we have now several different way to perform the fit, using the corresponding methods of the ROOT::Fit::Fitter class and depending on the type of input data.; 5.7.5.1 Available fit methods. Least-square fit: Fitter::LeastSquare(const BinData & ) or Fitter::Fit(const Bindata &). It requires the user to pass a BinData object. It should be used when the data values follow a Gaussian distribution. This fit method is implemented using the class ROOT::Fit::Chi2FCN.; Binned Likelihood fit : Fitter::LikelihoodFit(const Bindata & ). The user needs to pass a BinData object. It should be used when the data values follow a Poisson or a multinomial distribution. The Poisson case (extended fit) is the default and in this case the function normalization is also fit to the data. The Multi-nominal case c",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:210778,Availability,error,errors,210778,"s is an interface class extending the ROOT::Math::IBaseFunctionMultiDim with some extra functionality which can be used when fitting. This extra functionality is required by dedicated fitting algorithms like Fumili or GSLMultiFit. bool Fitter::SetFCN(const ROOT::Math::FitMethodFunction & f,; const double * initialParameters = 0, unsigned int dataSize=0). A old-Minuit like FCN interface (i.e. a free function with the signature fcn(int &npar, double *gin, double &f, double *u, int flag). typedef void(* MinuitFCN)(int &npar, double *gin, double &f, double *u, int flag); bool Fitter::SetFCN(MinuitFCN fcn, int npar,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); 5.7.6 Fit Result; The result of the fit is contained in the ROOT::Fit::Result object. A reference to the result object is obtained with the function Fitter::Result(). The ROOT::Fit::FitResult class provides an API for retrieving parameter values, errors, covariance and correlation matrix from the fit, minimum chi2/likelihood values, etc…; A FitResult::Print method is also available to print the result of the fit.; The class has a self-explanatory API so, see its reference documentation for the possible information available after the fit.; One extra functionality offered by ROOT::Fit::FitResult is the possibility to compute the confidence intervals of the function after the fit. The function ROOT::Fit::FitResult::GetConfidenceInterval given an input data sets (e.g. a BinData object) and a confidence level value (e.g. 68%) computes the lower/upper band values of the model function at the given data points.; 5.7.7 TFitResult; TFitResult is a class deriving from ROOT::Fit::Result and providing in addition some convenient methods to return a covariance or correlation matrix as a TMatrixDSym object. In addition TFitResult derives from TNamed and can be conveniently stored in a file.; When fitting an histogram ( a TH1 object) or a graph (a TGraph object) it is possible to retu",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:210906,Availability,avail,available,210906,"s is an interface class extending the ROOT::Math::IBaseFunctionMultiDim with some extra functionality which can be used when fitting. This extra functionality is required by dedicated fitting algorithms like Fumili or GSLMultiFit. bool Fitter::SetFCN(const ROOT::Math::FitMethodFunction & f,; const double * initialParameters = 0, unsigned int dataSize=0). A old-Minuit like FCN interface (i.e. a free function with the signature fcn(int &npar, double *gin, double &f, double *u, int flag). typedef void(* MinuitFCN)(int &npar, double *gin, double &f, double *u, int flag); bool Fitter::SetFCN(MinuitFCN fcn, int npar,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); 5.7.6 Fit Result; The result of the fit is contained in the ROOT::Fit::Result object. A reference to the result object is obtained with the function Fitter::Result(). The ROOT::Fit::FitResult class provides an API for retrieving parameter values, errors, covariance and correlation matrix from the fit, minimum chi2/likelihood values, etc…; A FitResult::Print method is also available to print the result of the fit.; The class has a self-explanatory API so, see its reference documentation for the possible information available after the fit.; One extra functionality offered by ROOT::Fit::FitResult is the possibility to compute the confidence intervals of the function after the fit. The function ROOT::Fit::FitResult::GetConfidenceInterval given an input data sets (e.g. a BinData object) and a confidence level value (e.g. 68%) computes the lower/upper band values of the model function at the given data points.; 5.7.7 TFitResult; TFitResult is a class deriving from ROOT::Fit::Result and providing in addition some convenient methods to return a covariance or correlation matrix as a TMatrixDSym object. In addition TFitResult derives from TNamed and can be conveniently stored in a file.; When fitting an histogram ( a TH1 object) or a graph (a TGraph object) it is possible to retu",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:211051,Availability,avail,available,211051,"ng algorithms like Fumili or GSLMultiFit. bool Fitter::SetFCN(const ROOT::Math::FitMethodFunction & f,; const double * initialParameters = 0, unsigned int dataSize=0). A old-Minuit like FCN interface (i.e. a free function with the signature fcn(int &npar, double *gin, double &f, double *u, int flag). typedef void(* MinuitFCN)(int &npar, double *gin, double &f, double *u, int flag); bool Fitter::SetFCN(MinuitFCN fcn, int npar,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); 5.7.6 Fit Result; The result of the fit is contained in the ROOT::Fit::Result object. A reference to the result object is obtained with the function Fitter::Result(). The ROOT::Fit::FitResult class provides an API for retrieving parameter values, errors, covariance and correlation matrix from the fit, minimum chi2/likelihood values, etc…; A FitResult::Print method is also available to print the result of the fit.; The class has a self-explanatory API so, see its reference documentation for the possible information available after the fit.; One extra functionality offered by ROOT::Fit::FitResult is the possibility to compute the confidence intervals of the function after the fit. The function ROOT::Fit::FitResult::GetConfidenceInterval given an input data sets (e.g. a BinData object) and a confidence level value (e.g. 68%) computes the lower/upper band values of the model function at the given data points.; 5.7.7 TFitResult; TFitResult is a class deriving from ROOT::Fit::Result and providing in addition some convenient methods to return a covariance or correlation matrix as a TMatrixDSym object. In addition TFitResult derives from TNamed and can be conveniently stored in a file.; When fitting an histogram ( a TH1 object) or a graph (a TGraph object) it is possible to return a TFitResult via the TFitResultPtr object, which behaves as a smart pointer to a TFitResult. TFitResultPtr is the return object by TH1::Fit or TGraph::Fit. By default the TFitResultPtr c",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:212697,Availability,error,error,212697,"r correlation matrix as a TMatrixDSym object. In addition TFitResult derives from TNamed and can be conveniently stored in a file.; When fitting an histogram ( a TH1 object) or a graph (a TGraph object) it is possible to return a TFitResult via the TFitResultPtr object, which behaves as a smart pointer to a TFitResult. TFitResultPtr is the return object by TH1::Fit or TGraph::Fit. By default the TFitResultPtr contains only the status of the fit and can be obtained by an automatic conversion of the TFitResultPtr to an integer.; If the fit option S is instead used, TFitResultPtr contains the TFitResult and behaves as a smart pointer to it. This is an example:; int fitStatus = hist->Fit(myFunction); // TFitResultPtr contains only the fit status. TFitResultPtr r = hist->Fit(myFunction,""S""); // TFitResultPtr contains the TFitResult; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file; 5.8 The Minimization packages; As explained before various minimization packages can be used when fitting in ROOT. We have seen before how to configure the Fitter class to use different minimization packages and different minimization options. When using the Fit method the minimization package (and its options) can be selected using the static methods of the ROOT::Math::MinimizerOptions class. For example to select Minuit2 instead of Minuit for fitting an histogram do:; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; // fit the histogram histo with the gaussian pre-defined function; histo->Fit(""gaus"");; In the following we will give some brief description of the minimization packages. The packages all implement the ROOT::Math::Mi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:216737,Availability,down,down,216737,"e Minuit package acts on a multi parameter FORTRAN function to which one must give the generic name FCN. In the ROOT implementation, the function FCN is defined via the Minuit SetFCN member function when an histogram fitting is invoked. The value of FCN will in general depend on one or more variable parameters.; 5.9.2 The Transformation of Limited Parameters; For variable parameters with limits, Minuit uses the following transformation:; Pint = arcsin(2((Pext-a)/(b-a))-1); Pext = a+((b-a)/(2))(sinPint+1); so that the internal value Pint can take on any value, while the external value Pext can take on values only between the lower limit a and the ext upper limit b. Since the transformation is necessarily non-linear, it would transform a nice linear problem into a nasty non-linear one, which is the reason why limits should be avoided if not necessary. In addition, the transformation does require some computer time, so it slows down the computation a little bit, and more importantly, it introduces additional numerical inaccuracy into the problem in addition to what is introduced in the numerical calculation of the FCN value. The effects of non-linearity and numerical round off both become more important as the external value gets closer to one of the limits (expressed as the distance to nearest limit divided by distance between limits). The user must therefore be aware of the fact that, for example, if they put limits of (0, 1010) on a parameter, then the values 0.0 and 1. 0 will be indistinguishable to the accuracy of most machines.; The transformation also affects the parameter error matrix, of course, so Minuit does a transformation of the error matrix (and the ‘’parabolic’’ parameter errors) when there are parameter limits. Users should however realize that the transformation is only a linear approximation, and that it cannot give a meaningful result if one or more parameters is very close to a limit, where \(\frac{\partial Pext}{\partial Pint} \neq 0\). Therefore,",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:217402,Availability,error,error,217402,"xt upper limit b. Since the transformation is necessarily non-linear, it would transform a nice linear problem into a nasty non-linear one, which is the reason why limits should be avoided if not necessary. In addition, the transformation does require some computer time, so it slows down the computation a little bit, and more importantly, it introduces additional numerical inaccuracy into the problem in addition to what is introduced in the numerical calculation of the FCN value. The effects of non-linearity and numerical round off both become more important as the external value gets closer to one of the limits (expressed as the distance to nearest limit divided by distance between limits). The user must therefore be aware of the fact that, for example, if they put limits of (0, 1010) on a parameter, then the values 0.0 and 1. 0 will be indistinguishable to the accuracy of most machines.; The transformation also affects the parameter error matrix, of course, so Minuit does a transformation of the error matrix (and the ‘’parabolic’’ parameter errors) when there are parameter limits. Users should however realize that the transformation is only a linear approximation, and that it cannot give a meaningful result if one or more parameters is very close to a limit, where \(\frac{\partial Pext}{\partial Pint} \neq 0\). Therefore, it is recommended that:. Limits on variable parameters should be used only when needed in order to prevent the parameter from taking on unphysical values; When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits. 5.9.3 How to Get the Right Answer from Minuit; Minuit offers the user a choice of several minimization algorithms. The MIGRAD algorithm is in general the best minimized for nearly all functions. It is a variable-metric method with inexact line search, a stable metric updating scheme, and checks for positive-definiteness. Its",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:217466,Availability,error,error,217466,"xt upper limit b. Since the transformation is necessarily non-linear, it would transform a nice linear problem into a nasty non-linear one, which is the reason why limits should be avoided if not necessary. In addition, the transformation does require some computer time, so it slows down the computation a little bit, and more importantly, it introduces additional numerical inaccuracy into the problem in addition to what is introduced in the numerical calculation of the FCN value. The effects of non-linearity and numerical round off both become more important as the external value gets closer to one of the limits (expressed as the distance to nearest limit divided by distance between limits). The user must therefore be aware of the fact that, for example, if they put limits of (0, 1010) on a parameter, then the values 0.0 and 1. 0 will be indistinguishable to the accuracy of most machines.; The transformation also affects the parameter error matrix, of course, so Minuit does a transformation of the error matrix (and the ‘’parabolic’’ parameter errors) when there are parameter limits. Users should however realize that the transformation is only a linear approximation, and that it cannot give a meaningful result if one or more parameters is very close to a limit, where \(\frac{\partial Pext}{\partial Pint} \neq 0\). Therefore, it is recommended that:. Limits on variable parameters should be used only when needed in order to prevent the parameter from taking on unphysical values; When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits. 5.9.3 How to Get the Right Answer from Minuit; Minuit offers the user a choice of several minimization algorithms. The MIGRAD algorithm is in general the best minimized for nearly all functions. It is a variable-metric method with inexact line search, a stable metric updating scheme, and checks for positive-definiteness. Its",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:217512,Availability,error,errors,217512,"xt upper limit b. Since the transformation is necessarily non-linear, it would transform a nice linear problem into a nasty non-linear one, which is the reason why limits should be avoided if not necessary. In addition, the transformation does require some computer time, so it slows down the computation a little bit, and more importantly, it introduces additional numerical inaccuracy into the problem in addition to what is introduced in the numerical calculation of the FCN value. The effects of non-linearity and numerical round off both become more important as the external value gets closer to one of the limits (expressed as the distance to nearest limit divided by distance between limits). The user must therefore be aware of the fact that, for example, if they put limits of (0, 1010) on a parameter, then the values 0.0 and 1. 0 will be indistinguishable to the accuracy of most machines.; The transformation also affects the parameter error matrix, of course, so Minuit does a transformation of the error matrix (and the ‘’parabolic’’ parameter errors) when there are parameter limits. Users should however realize that the transformation is only a linear approximation, and that it cannot give a meaningful result if one or more parameters is very close to a limit, where \(\frac{\partial Pext}{\partial Pint} \neq 0\). Therefore, it is recommended that:. Limits on variable parameters should be used only when needed in order to prevent the parameter from taking on unphysical values; When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits. 5.9.3 How to Get the Right Answer from Minuit; Minuit offers the user a choice of several minimization algorithms. The MIGRAD algorithm is in general the best minimized for nearly all functions. It is a variable-metric method with inexact line search, a stable metric updating scheme, and checks for positive-definiteness. Its",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:218096,Availability,error,error,218096,"erical round off both become more important as the external value gets closer to one of the limits (expressed as the distance to nearest limit divided by distance between limits). The user must therefore be aware of the fact that, for example, if they put limits of (0, 1010) on a parameter, then the values 0.0 and 1. 0 will be indistinguishable to the accuracy of most machines.; The transformation also affects the parameter error matrix, of course, so Minuit does a transformation of the error matrix (and the ‘’parabolic’’ parameter errors) when there are parameter limits. Users should however realize that the transformation is only a linear approximation, and that it cannot give a meaningful result if one or more parameters is very close to a limit, where \(\frac{\partial Pext}{\partial Pint} \neq 0\). Therefore, it is recommended that:. Limits on variable parameters should be used only when needed in order to prevent the parameter from taking on unphysical values; When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits. 5.9.3 How to Get the Right Answer from Minuit; Minuit offers the user a choice of several minimization algorithms. The MIGRAD algorithm is in general the best minimized for nearly all functions. It is a variable-metric method with inexact line search, a stable metric updating scheme, and checks for positive-definiteness. Its main weakness is that it depends heavily on knowledge of the first derivatives, and fails miserably if they are very inaccurate.; If parameter limits are needed, in spite of the side effects, then the user should be aware of the following techniques to alleviate problems caused by limits:; 5.9.3.1 Getting the Right Minimum with Limits; If MIGRAD converges normally to a point where no parameter is near one of its limits, then the existence of limits has probably not prevented Minuit from finding the right minimum. On",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:219974,Availability,error,error,219974,"minimum. On the other hand, if one or more parameters is near its limit at the minimum, this may be because the true minimum is indeed at a limit, or it may be because the minimized has become ‘’blocked’’ at a limit. This may normally happen only if the parameter is so close to a limit (internal value at an odd multiple of \(\pm \frac{\pi}{2}\) that Minuit prints a warning to this effect when it prints the parameter values. The minimized can become blocked at a limit, because at a limit the derivative seen by the minimized \(\frac{\partial F}{\partial Pint}\) is zero no matter what the real derivative \(\frac{\partial F}{\partial Pext}\) is.; \[; \left(\frac{\partial F}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right); \left(\frac{\partial Pext}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right) = 0; \]; 5.9.3.2 Getting the Right Parameter Errors with Limits; In the best case, where the minimum is far from any limits, Minuit will correctly transform the error matrix, and the parameter errors it reports should be accurate and very close to those you would have got without limits. In other cases (which should be more common, since otherwise you would not need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless.; 5.9.3.3 Interpretation of Parameter Errors; There are two kinds of problems that can arise: the reliability of Minuit’s error estimates, and their statistical interpretation, assuming they are accurate.; 5.9.3.4 Statistical Interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, or setting of exact confidence levels see the articles:. F.James. Determining the statistical Significance of experimental Results. Technical Repo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:220006,Availability,error,errors,220006,"minimum. On the other hand, if one or more parameters is near its limit at the minimum, this may be because the true minimum is indeed at a limit, or it may be because the minimized has become ‘’blocked’’ at a limit. This may normally happen only if the parameter is so close to a limit (internal value at an odd multiple of \(\pm \frac{\pi}{2}\) that Minuit prints a warning to this effect when it prints the parameter values. The minimized can become blocked at a limit, because at a limit the derivative seen by the minimized \(\frac{\partial F}{\partial Pint}\) is zero no matter what the real derivative \(\frac{\partial F}{\partial Pext}\) is.; \[; \left(\frac{\partial F}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right); \left(\frac{\partial Pext}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right) = 0; \]; 5.9.3.2 Getting the Right Parameter Errors with Limits; In the best case, where the minimum is far from any limits, Minuit will correctly transform the error matrix, and the parameter errors it reports should be accurate and very close to those you would have got without limits. In other cases (which should be more common, since otherwise you would not need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless.; 5.9.3.3 Interpretation of Parameter Errors; There are two kinds of problems that can arise: the reliability of Minuit’s error estimates, and their statistical interpretation, assuming they are accurate.; 5.9.3.4 Statistical Interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, or setting of exact confidence levels see the articles:. F.James. Determining the statistical Significance of experimental Results. Technical Repo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:220221,Availability,error,errors,220221,"limit. This may normally happen only if the parameter is so close to a limit (internal value at an odd multiple of \(\pm \frac{\pi}{2}\) that Minuit prints a warning to this effect when it prints the parameter values. The minimized can become blocked at a limit, because at a limit the derivative seen by the minimized \(\frac{\partial F}{\partial Pint}\) is zero no matter what the real derivative \(\frac{\partial F}{\partial Pext}\) is.; \[; \left(\frac{\partial F}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right); \left(\frac{\partial Pext}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right) = 0; \]; 5.9.3.2 Getting the Right Parameter Errors with Limits; In the best case, where the minimum is far from any limits, Minuit will correctly transform the error matrix, and the parameter errors it reports should be accurate and very close to those you would have got without limits. In other cases (which should be more common, since otherwise you would not need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless.; 5.9.3.3 Interpretation of Parameter Errors; There are two kinds of problems that can arise: the reliability of Minuit’s error estimates, and their statistical interpretation, assuming they are accurate.; 5.9.3.4 Statistical Interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, or setting of exact confidence levels see the articles:. F.James. Determining the statistical Significance of experimental Results. Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet. Statistical Methods in Experimental Physics. North-Holland, 1971. 5.9.4 Reliability of Minuit Error Estimate",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:220357,Availability,error,error,220357,"uit prints a warning to this effect when it prints the parameter values. The minimized can become blocked at a limit, because at a limit the derivative seen by the minimized \(\frac{\partial F}{\partial Pint}\) is zero no matter what the real derivative \(\frac{\partial F}{\partial Pext}\) is.; \[; \left(\frac{\partial F}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right); \left(\frac{\partial Pext}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right) = 0; \]; 5.9.3.2 Getting the Right Parameter Errors with Limits; In the best case, where the minimum is far from any limits, Minuit will correctly transform the error matrix, and the parameter errors it reports should be accurate and very close to those you would have got without limits. In other cases (which should be more common, since otherwise you would not need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless.; 5.9.3.3 Interpretation of Parameter Errors; There are two kinds of problems that can arise: the reliability of Minuit’s error estimates, and their statistical interpretation, assuming they are accurate.; 5.9.3.4 Statistical Interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, or setting of exact confidence levels see the articles:. F.James. Determining the statistical Significance of experimental Results. Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet. Statistical Methods in Experimental Physics. North-Holland, 1971. 5.9.4 Reliability of Minuit Error Estimates; Minuit always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:220395,Availability,error,error,220395,"ecause at a limit the derivative seen by the minimized \(\frac{\partial F}{\partial Pint}\) is zero no matter what the real derivative \(\frac{\partial F}{\partial Pext}\) is.; \[; \left(\frac{\partial F}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right); \left(\frac{\partial Pext}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right) = 0; \]; 5.9.3.2 Getting the Right Parameter Errors with Limits; In the best case, where the minimum is far from any limits, Minuit will correctly transform the error matrix, and the parameter errors it reports should be accurate and very close to those you would have got without limits. In other cases (which should be more common, since otherwise you would not need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless.; 5.9.3.3 Interpretation of Parameter Errors; There are two kinds of problems that can arise: the reliability of Minuit’s error estimates, and their statistical interpretation, assuming they are accurate.; 5.9.3.4 Statistical Interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, or setting of exact confidence levels see the articles:. F.James. Determining the statistical Significance of experimental Results. Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet. Statistical Methods in Experimental Physics. North-Holland, 1971. 5.9.4 Reliability of Minuit Error Estimates; Minuit always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:220441,Availability,error,errors,220441,"ecause at a limit the derivative seen by the minimized \(\frac{\partial F}{\partial Pint}\) is zero no matter what the real derivative \(\frac{\partial F}{\partial Pext}\) is.; \[; \left(\frac{\partial F}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right); \left(\frac{\partial Pext}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right) = 0; \]; 5.9.3.2 Getting the Right Parameter Errors with Limits; In the best case, where the minimum is far from any limits, Minuit will correctly transform the error matrix, and the parameter errors it reports should be accurate and very close to those you would have got without limits. In other cases (which should be more common, since otherwise you would not need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless.; 5.9.3.3 Interpretation of Parameter Errors; There are two kinds of problems that can arise: the reliability of Minuit’s error estimates, and their statistical interpretation, assuming they are accurate.; 5.9.3.4 Statistical Interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, or setting of exact confidence levels see the articles:. F.James. Determining the statistical Significance of experimental Results. Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet. Statistical Methods in Experimental Physics. North-Holland, 1971. 5.9.4 Reliability of Minuit Error Estimates; Minuit always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:220584,Availability,reliab,reliability,220584,"{\partial Pext}\) is.; \[; \left(\frac{\partial F}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right); \left(\frac{\partial Pext}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right) = 0; \]; 5.9.3.2 Getting the Right Parameter Errors with Limits; In the best case, where the minimum is far from any limits, Minuit will correctly transform the error matrix, and the parameter errors it reports should be accurate and very close to those you would have got without limits. In other cases (which should be more common, since otherwise you would not need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless.; 5.9.3.3 Interpretation of Parameter Errors; There are two kinds of problems that can arise: the reliability of Minuit’s error estimates, and their statistical interpretation, assuming they are accurate.; 5.9.3.4 Statistical Interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, or setting of exact confidence levels see the articles:. F.James. Determining the statistical Significance of experimental Results. Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet. Statistical Methods in Experimental Physics. North-Holland, 1971. 5.9.4 Reliability of Minuit Error Estimates; Minuit always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a HESSE step, the errors are usually quite accurate, unless there has been a problem. Minuit, when it prints out err",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:220608,Availability,error,error,220608,"{\partial Pext}\) is.; \[; \left(\frac{\partial F}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right); \left(\frac{\partial Pext}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right) = 0; \]; 5.9.3.2 Getting the Right Parameter Errors with Limits; In the best case, where the minimum is far from any limits, Minuit will correctly transform the error matrix, and the parameter errors it reports should be accurate and very close to those you would have got without limits. In other cases (which should be more common, since otherwise you would not need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless.; 5.9.3.3 Interpretation of Parameter Errors; There are two kinds of problems that can arise: the reliability of Minuit’s error estimates, and their statistical interpretation, assuming they are accurate.; 5.9.3.4 Statistical Interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, or setting of exact confidence levels see the articles:. F.James. Determining the statistical Significance of experimental Results. Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet. Statistical Methods in Experimental Physics. North-Holland, 1971. 5.9.4 Reliability of Minuit Error Estimates; Minuit always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a HESSE step, the errors are usually quite accurate, unless there has been a problem. Minuit, when it prints out err",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:220805,Availability,error,error,220805,"l F}{\partial Pext}\right) = 0; \]; 5.9.3.2 Getting the Right Parameter Errors with Limits; In the best case, where the minimum is far from any limits, Minuit will correctly transform the error matrix, and the parameter errors it reports should be accurate and very close to those you would have got without limits. In other cases (which should be more common, since otherwise you would not need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless.; 5.9.3.3 Interpretation of Parameter Errors; There are two kinds of problems that can arise: the reliability of Minuit’s error estimates, and their statistical interpretation, assuming they are accurate.; 5.9.3.4 Statistical Interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, or setting of exact confidence levels see the articles:. F.James. Determining the statistical Significance of experimental Results. Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet. Statistical Methods in Experimental Physics. North-Holland, 1971. 5.9.4 Reliability of Minuit Error Estimates; Minuit always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a HESSE step, the errors are usually quite accurate, unless there has been a problem. Minuit, when it prints out error values, also gives some indication of how reliable it thinks they are. For example, those marked CURRENT GUESS ERROR are only working values not to be believed, and APPROXIMATE ERROR means tha",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:221250,Availability,error,errors,221250,"Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless.; 5.9.3.3 Interpretation of Parameter Errors; There are two kinds of problems that can arise: the reliability of Minuit’s error estimates, and their statistical interpretation, assuming they are accurate.; 5.9.3.4 Statistical Interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, or setting of exact confidence levels see the articles:. F.James. Determining the statistical Significance of experimental Results. Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet. Statistical Methods in Experimental Physics. North-Holland, 1971. 5.9.4 Reliability of Minuit Error Estimates; Minuit always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a HESSE step, the errors are usually quite accurate, unless there has been a problem. Minuit, when it prints out error values, also gives some indication of how reliable it thinks they are. For example, those marked CURRENT GUESS ERROR are only working values not to be believed, and APPROXIMATE ERROR means that they have been calculated but there is reason to believe that they may not be accurate.; If no mitigating adjective is given, then at least Minuit believes the errors are accurate, although there is always a small chance that Minuit has been fooled. Some visible signs that Minuit may have been fooled:. Warning messages produced during the minimization or error analysis; Failure to find new minimum; Value of EDM too big (estimated Distance to Minimum); Corre",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:221494,Availability,error,errors,221494,"arameter Errors; There are two kinds of problems that can arise: the reliability of Minuit’s error estimates, and their statistical interpretation, assuming they are accurate.; 5.9.3.4 Statistical Interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, or setting of exact confidence levels see the articles:. F.James. Determining the statistical Significance of experimental Results. Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet. Statistical Methods in Experimental Physics. North-Holland, 1971. 5.9.4 Reliability of Minuit Error Estimates; Minuit always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a HESSE step, the errors are usually quite accurate, unless there has been a problem. Minuit, when it prints out error values, also gives some indication of how reliable it thinks they are. For example, those marked CURRENT GUESS ERROR are only working values not to be believed, and APPROXIMATE ERROR means that they have been calculated but there is reason to believe that they may not be accurate.; If no mitigating adjective is given, then at least Minuit believes the errors are accurate, although there is always a small chance that Minuit has been fooled. Some visible signs that Minuit may have been fooled:. Warning messages produced during the minimization or error analysis; Failure to find new minimum; Value of EDM too big (estimated Distance to Minimum); Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others; Correlation coefficients very close to one (greater than 0.99). This indicates both an exceptionally difficult problem, and one which has been badly para",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:221589,Availability,error,error,221589," estimates, and their statistical interpretation, assuming they are accurate.; 5.9.3.4 Statistical Interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, or setting of exact confidence levels see the articles:. F.James. Determining the statistical Significance of experimental Results. Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet. Statistical Methods in Experimental Physics. North-Holland, 1971. 5.9.4 Reliability of Minuit Error Estimates; Minuit always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a HESSE step, the errors are usually quite accurate, unless there has been a problem. Minuit, when it prints out error values, also gives some indication of how reliable it thinks they are. For example, those marked CURRENT GUESS ERROR are only working values not to be believed, and APPROXIMATE ERROR means that they have been calculated but there is reason to believe that they may not be accurate.; If no mitigating adjective is given, then at least Minuit believes the errors are accurate, although there is always a small chance that Minuit has been fooled. Some visible signs that Minuit may have been fooled:. Warning messages produced during the minimization or error analysis; Failure to find new minimum; Value of EDM too big (estimated Distance to Minimum); Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others; Correlation coefficients very close to one (greater than 0.99). This indicates both an exceptionally difficult problem, and one which has been badly parameterized so that individual errors are not very meaningful because they are so highly correlated;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:221637,Availability,reliab,reliable,221637," estimates, and their statistical interpretation, assuming they are accurate.; 5.9.3.4 Statistical Interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, or setting of exact confidence levels see the articles:. F.James. Determining the statistical Significance of experimental Results. Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet. Statistical Methods in Experimental Physics. North-Holland, 1971. 5.9.4 Reliability of Minuit Error Estimates; Minuit always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a HESSE step, the errors are usually quite accurate, unless there has been a problem. Minuit, when it prints out error values, also gives some indication of how reliable it thinks they are. For example, those marked CURRENT GUESS ERROR are only working values not to be believed, and APPROXIMATE ERROR means that they have been calculated but there is reason to believe that they may not be accurate.; If no mitigating adjective is given, then at least Minuit believes the errors are accurate, although there is always a small chance that Minuit has been fooled. Some visible signs that Minuit may have been fooled:. Warning messages produced during the minimization or error analysis; Failure to find new minimum; Value of EDM too big (estimated Distance to Minimum); Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others; Correlation coefficients very close to one (greater than 0.99). This indicates both an exceptionally difficult problem, and one which has been badly parameterized so that individual errors are not very meaningful because they are so highly correlated;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:221949,Availability,error,errors,221949,"cal Report DD/81/02 and CERN Report 81-03, CERN, 1981; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet. Statistical Methods in Experimental Physics. North-Holland, 1971. 5.9.4 Reliability of Minuit Error Estimates; Minuit always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a HESSE step, the errors are usually quite accurate, unless there has been a problem. Minuit, when it prints out error values, also gives some indication of how reliable it thinks they are. For example, those marked CURRENT GUESS ERROR are only working values not to be believed, and APPROXIMATE ERROR means that they have been calculated but there is reason to believe that they may not be accurate.; If no mitigating adjective is given, then at least Minuit believes the errors are accurate, although there is always a small chance that Minuit has been fooled. Some visible signs that Minuit may have been fooled:. Warning messages produced during the minimization or error analysis; Failure to find new minimum; Value of EDM too big (estimated Distance to Minimum); Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others; Correlation coefficients very close to one (greater than 0.99). This indicates both an exceptionally difficult problem, and one which has been badly parameterized so that individual errors are not very meaningful because they are so highly correlated; Parameter at limit. This condition, signaled by a Minuit warning message, may make both the function minimum and parameter errors unreliable. See the discussion above ‘Getting the right parameter errors with limits’. The best way to be absolutely sure of the errors is to use ‘’independent’’ calculations and compare them, or compare the calcu",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:222146,Availability,error,error,222146,", which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a HESSE step, the errors are usually quite accurate, unless there has been a problem. Minuit, when it prints out error values, also gives some indication of how reliable it thinks they are. For example, those marked CURRENT GUESS ERROR are only working values not to be believed, and APPROXIMATE ERROR means that they have been calculated but there is reason to believe that they may not be accurate.; If no mitigating adjective is given, then at least Minuit believes the errors are accurate, although there is always a small chance that Minuit has been fooled. Some visible signs that Minuit may have been fooled:. Warning messages produced during the minimization or error analysis; Failure to find new minimum; Value of EDM too big (estimated Distance to Minimum); Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others; Correlation coefficients very close to one (greater than 0.99). This indicates both an exceptionally difficult problem, and one which has been badly parameterized so that individual errors are not very meaningful because they are so highly correlated; Parameter at limit. This condition, signaled by a Minuit warning message, may make both the function minimum and parameter errors unreliable. See the discussion above ‘Getting the right parameter errors with limits’. The best way to be absolutely sure of the errors is to use ‘’independent’’ calculations and compare them, or compare the calculated errors with a picture of the function. Theoretically, the covariance matrix for a ‘’physical’’ function must be positive-definite at the minimum, although it may not be so for all points far away from the minimum, even for a well-determined physical problem. Therefore, if MIGRAD reports that i",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:222544,Availability,error,errors,222544,"unless there has been a problem. Minuit, when it prints out error values, also gives some indication of how reliable it thinks they are. For example, those marked CURRENT GUESS ERROR are only working values not to be believed, and APPROXIMATE ERROR means that they have been calculated but there is reason to believe that they may not be accurate.; If no mitigating adjective is given, then at least Minuit believes the errors are accurate, although there is always a small chance that Minuit has been fooled. Some visible signs that Minuit may have been fooled:. Warning messages produced during the minimization or error analysis; Failure to find new minimum; Value of EDM too big (estimated Distance to Minimum); Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others; Correlation coefficients very close to one (greater than 0.99). This indicates both an exceptionally difficult problem, and one which has been badly parameterized so that individual errors are not very meaningful because they are so highly correlated; Parameter at limit. This condition, signaled by a Minuit warning message, may make both the function minimum and parameter errors unreliable. See the discussion above ‘Getting the right parameter errors with limits’. The best way to be absolutely sure of the errors is to use ‘’independent’’ calculations and compare them, or compare the calculated errors with a picture of the function. Theoretically, the covariance matrix for a ‘’physical’’ function must be positive-definite at the minimum, although it may not be so for all points far away from the minimum, even for a well-determined physical problem. Therefore, if MIGRAD reports that it has found a non-positive-definite covariance matrix, this may be a sign of one or more of the following:; 5.9.4.1 A Non-physical Region; On its way to the minimum, MIGRAD may have traversed a region that has unphysical behavior, which is of course not a serious problem ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:222737,Availability,error,errors,222737,"RRENT GUESS ERROR are only working values not to be believed, and APPROXIMATE ERROR means that they have been calculated but there is reason to believe that they may not be accurate.; If no mitigating adjective is given, then at least Minuit believes the errors are accurate, although there is always a small chance that Minuit has been fooled. Some visible signs that Minuit may have been fooled:. Warning messages produced during the minimization or error analysis; Failure to find new minimum; Value of EDM too big (estimated Distance to Minimum); Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others; Correlation coefficients very close to one (greater than 0.99). This indicates both an exceptionally difficult problem, and one which has been badly parameterized so that individual errors are not very meaningful because they are so highly correlated; Parameter at limit. This condition, signaled by a Minuit warning message, may make both the function minimum and parameter errors unreliable. See the discussion above ‘Getting the right parameter errors with limits’. The best way to be absolutely sure of the errors is to use ‘’independent’’ calculations and compare them, or compare the calculated errors with a picture of the function. Theoretically, the covariance matrix for a ‘’physical’’ function must be positive-definite at the minimum, although it may not be so for all points far away from the minimum, even for a well-determined physical problem. Therefore, if MIGRAD reports that it has found a non-positive-definite covariance matrix, this may be a sign of one or more of the following:; 5.9.4.1 A Non-physical Region; On its way to the minimum, MIGRAD may have traversed a region that has unphysical behavior, which is of course not a serious problem as long as it recovers and leaves such a region.; 5.9.4.2 An Underdetermined Problem; If the matrix is not positive-definite even at the minimum, this may mean that ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:222810,Availability,error,errors,222810,"y have been calculated but there is reason to believe that they may not be accurate.; If no mitigating adjective is given, then at least Minuit believes the errors are accurate, although there is always a small chance that Minuit has been fooled. Some visible signs that Minuit may have been fooled:. Warning messages produced during the minimization or error analysis; Failure to find new minimum; Value of EDM too big (estimated Distance to Minimum); Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others; Correlation coefficients very close to one (greater than 0.99). This indicates both an exceptionally difficult problem, and one which has been badly parameterized so that individual errors are not very meaningful because they are so highly correlated; Parameter at limit. This condition, signaled by a Minuit warning message, may make both the function minimum and parameter errors unreliable. See the discussion above ‘Getting the right parameter errors with limits’. The best way to be absolutely sure of the errors is to use ‘’independent’’ calculations and compare them, or compare the calculated errors with a picture of the function. Theoretically, the covariance matrix for a ‘’physical’’ function must be positive-definite at the minimum, although it may not be so for all points far away from the minimum, even for a well-determined physical problem. Therefore, if MIGRAD reports that it has found a non-positive-definite covariance matrix, this may be a sign of one or more of the following:; 5.9.4.1 A Non-physical Region; On its way to the minimum, MIGRAD may have traversed a region that has unphysical behavior, which is of course not a serious problem as long as it recovers and leaves such a region.; 5.9.4.2 An Underdetermined Problem; If the matrix is not positive-definite even at the minimum, this may mean that the solution is not well defined, for example that there are more unknowns than there are data poin",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:222873,Availability,error,errors,222873,"then at least Minuit believes the errors are accurate, although there is always a small chance that Minuit has been fooled. Some visible signs that Minuit may have been fooled:. Warning messages produced during the minimization or error analysis; Failure to find new minimum; Value of EDM too big (estimated Distance to Minimum); Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others; Correlation coefficients very close to one (greater than 0.99). This indicates both an exceptionally difficult problem, and one which has been badly parameterized so that individual errors are not very meaningful because they are so highly correlated; Parameter at limit. This condition, signaled by a Minuit warning message, may make both the function minimum and parameter errors unreliable. See the discussion above ‘Getting the right parameter errors with limits’. The best way to be absolutely sure of the errors is to use ‘’independent’’ calculations and compare them, or compare the calculated errors with a picture of the function. Theoretically, the covariance matrix for a ‘’physical’’ function must be positive-definite at the minimum, although it may not be so for all points far away from the minimum, even for a well-determined physical problem. Therefore, if MIGRAD reports that it has found a non-positive-definite covariance matrix, this may be a sign of one or more of the following:; 5.9.4.1 A Non-physical Region; On its way to the minimum, MIGRAD may have traversed a region that has unphysical behavior, which is of course not a serious problem as long as it recovers and leaves such a region.; 5.9.4.2 An Underdetermined Problem; If the matrix is not positive-definite even at the minimum, this may mean that the solution is not well defined, for example that there are more unknowns than there are data points, or that the parameterization of the fit contains a linear dependence. If this is the case, then Minuit (or any other pr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:222963,Availability,error,errors,222963,"then at least Minuit believes the errors are accurate, although there is always a small chance that Minuit has been fooled. Some visible signs that Minuit may have been fooled:. Warning messages produced during the minimization or error analysis; Failure to find new minimum; Value of EDM too big (estimated Distance to Minimum); Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others; Correlation coefficients very close to one (greater than 0.99). This indicates both an exceptionally difficult problem, and one which has been badly parameterized so that individual errors are not very meaningful because they are so highly correlated; Parameter at limit. This condition, signaled by a Minuit warning message, may make both the function minimum and parameter errors unreliable. See the discussion above ‘Getting the right parameter errors with limits’. The best way to be absolutely sure of the errors is to use ‘’independent’’ calculations and compare them, or compare the calculated errors with a picture of the function. Theoretically, the covariance matrix for a ‘’physical’’ function must be positive-definite at the minimum, although it may not be so for all points far away from the minimum, even for a well-determined physical problem. Therefore, if MIGRAD reports that it has found a non-positive-definite covariance matrix, this may be a sign of one or more of the following:; 5.9.4.1 A Non-physical Region; On its way to the minimum, MIGRAD may have traversed a region that has unphysical behavior, which is of course not a serious problem as long as it recovers and leaves such a region.; 5.9.4.2 An Underdetermined Problem; If the matrix is not positive-definite even at the minimum, this may mean that the solution is not well defined, for example that there are more unknowns than there are data points, or that the parameterization of the fit contains a linear dependence. If this is the case, then Minuit (or any other pr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:223543,Availability,recover,recovers,223543,"roblem, and one which has been badly parameterized so that individual errors are not very meaningful because they are so highly correlated; Parameter at limit. This condition, signaled by a Minuit warning message, may make both the function minimum and parameter errors unreliable. See the discussion above ‘Getting the right parameter errors with limits’. The best way to be absolutely sure of the errors is to use ‘’independent’’ calculations and compare them, or compare the calculated errors with a picture of the function. Theoretically, the covariance matrix for a ‘’physical’’ function must be positive-definite at the minimum, although it may not be so for all points far away from the minimum, even for a well-determined physical problem. Therefore, if MIGRAD reports that it has found a non-positive-definite covariance matrix, this may be a sign of one or more of the following:; 5.9.4.1 A Non-physical Region; On its way to the minimum, MIGRAD may have traversed a region that has unphysical behavior, which is of course not a serious problem as long as it recovers and leaves such a region.; 5.9.4.2 An Underdetermined Problem; If the matrix is not positive-definite even at the minimum, this may mean that the solution is not well defined, for example that there are more unknowns than there are data points, or that the parameterization of the fit contains a linear dependence. If this is the case, then Minuit (or any other program) cannot solve your problem uniquely. The error matrix will necessarily be largely meaningless, so the user must remove the under determinedness by reformulating the parameterization. Minuit cannot do this itself.; 5.9.4.3 Numerical Inaccuracies; It is possible that the apparent lack of positive-definiteness is due to excessive round off errors in numerical calculations (in the user function), or not enough precision. This is unlikely in general, but becomes more likely if the number of free parameters is very large, or if the parameters are badly",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:223963,Availability,error,error,223963," matrix for a ‘’physical’’ function must be positive-definite at the minimum, although it may not be so for all points far away from the minimum, even for a well-determined physical problem. Therefore, if MIGRAD reports that it has found a non-positive-definite covariance matrix, this may be a sign of one or more of the following:; 5.9.4.1 A Non-physical Region; On its way to the minimum, MIGRAD may have traversed a region that has unphysical behavior, which is of course not a serious problem as long as it recovers and leaves such a region.; 5.9.4.2 An Underdetermined Problem; If the matrix is not positive-definite even at the minimum, this may mean that the solution is not well defined, for example that there are more unknowns than there are data points, or that the parameterization of the fit contains a linear dependence. If this is the case, then Minuit (or any other program) cannot solve your problem uniquely. The error matrix will necessarily be largely meaningless, so the user must remove the under determinedness by reformulating the parameterization. Minuit cannot do this itself.; 5.9.4.3 Numerical Inaccuracies; It is possible that the apparent lack of positive-definiteness is due to excessive round off errors in numerical calculations (in the user function), or not enough precision. This is unlikely in general, but becomes more likely if the number of free parameters is very large, or if the parameters are badly scaled (not all of the same order of magnitude), and correlations are large. In any case, whether the non-positive-definiteness is real or only numerical is largely irrelevant, since in both cases the error matrix will be unreliable and the minimum suspicious.; 5.9.4.4 An Ill-posed Problem; For questions of parameter dependence, see the discussion above on positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical round off - be especially careful of exponential and factorial functions which get big very quick",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:224261,Availability,error,errors,224261," reports that it has found a non-positive-definite covariance matrix, this may be a sign of one or more of the following:; 5.9.4.1 A Non-physical Region; On its way to the minimum, MIGRAD may have traversed a region that has unphysical behavior, which is of course not a serious problem as long as it recovers and leaves such a region.; 5.9.4.2 An Underdetermined Problem; If the matrix is not positive-definite even at the minimum, this may mean that the solution is not well defined, for example that there are more unknowns than there are data points, or that the parameterization of the fit contains a linear dependence. If this is the case, then Minuit (or any other program) cannot solve your problem uniquely. The error matrix will necessarily be largely meaningless, so the user must remove the under determinedness by reformulating the parameterization. Minuit cannot do this itself.; 5.9.4.3 Numerical Inaccuracies; It is possible that the apparent lack of positive-definiteness is due to excessive round off errors in numerical calculations (in the user function), or not enough precision. This is unlikely in general, but becomes more likely if the number of free parameters is very large, or if the parameters are badly scaled (not all of the same order of magnitude), and correlations are large. In any case, whether the non-positive-definiteness is real or only numerical is largely irrelevant, since in both cases the error matrix will be unreliable and the minimum suspicious.; 5.9.4.4 An Ill-posed Problem; For questions of parameter dependence, see the discussion above on positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical round off - be especially careful of exponential and factorial functions which get big very quickly and lose accuracy.; Starting too far from the solution - the function may have unphysical local minima, especially at infinity in some variables. 5.10 Minuit2 Package; Minuit2 is a new object-oriented impleme",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:224676,Availability,error,error,224676,"e-definite even at the minimum, this may mean that the solution is not well defined, for example that there are more unknowns than there are data points, or that the parameterization of the fit contains a linear dependence. If this is the case, then Minuit (or any other program) cannot solve your problem uniquely. The error matrix will necessarily be largely meaningless, so the user must remove the under determinedness by reformulating the parameterization. Minuit cannot do this itself.; 5.9.4.3 Numerical Inaccuracies; It is possible that the apparent lack of positive-definiteness is due to excessive round off errors in numerical calculations (in the user function), or not enough precision. This is unlikely in general, but becomes more likely if the number of free parameters is very large, or if the parameters are badly scaled (not all of the same order of magnitude), and correlations are large. In any case, whether the non-positive-definiteness is real or only numerical is largely irrelevant, since in both cases the error matrix will be unreliable and the minimum suspicious.; 5.9.4.4 An Ill-posed Problem; For questions of parameter dependence, see the discussion above on positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical round off - be especially careful of exponential and factorial functions which get big very quickly and lose accuracy.; Starting too far from the solution - the function may have unphysical local minima, especially at infinity in some variables. 5.10 Minuit2 Package; Minuit2 is a new object-oriented implementation, written in C++, of the popular MINUIT minimization package. Compared with the TMinuit class, which is a direct conversion from FORTRAN to C++, Minuit2 is a complete redesign and re-implementation of the package. This new version provides all the functionality present in the old FORTRAN version, with almost equivalent numerical accuracy and computational performances. Furthermore, it contai",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:226743,Availability,avail,available,226743,"et single side parameter limits * the FUMILI algorithm (see the next paragraph “FUMILI Minimization Package”), which is an optimized method for least square and log likelihood minimizations.; Minuit2 has been originally developed by M. Winkler and F. James in the SEAL project. More information can be found on the MINUIT Web Site and in particular at the following documentation page at http://www.cern.ch/minuit/doc/doc.html.; A detailed User Guide for Minuit2 exists, describing the API of the internal classes. ROOT uses Minuit2 for fitting via the Minuit2Minimizer class which implements the ROOT::Math::Minimizer interface.; Minuit2 is also distributed as an independent package of ROOT and can be built without any other dependency on the ROOT libraries.; Examples on how to use the Minuit2 and Fumili2 plug-ins are provided in the tutorials’ directory $ROOTSYS/tutorials/fit: minuit2FitBench.C, minuit2FitBench2D.C and minuit2GausFit.C. More information on the classes and functions present in Minuit2 is available at online reference documentation.; Useful information on MINUIT and minimization in general is provided in the following documents:; F. James, Minuit Tutorial on Function Minimization ( http://seal.cern.ch/documents/minuit/mntutorial.pdf); F. James, The Interpretation of Errors in Minuit ( http://seal.cern.ch/documents/minuit/mnerror.pdf);; 5.11 FUMILI Minimization Package; FUMILI is used to minimize Chi-square function or to search maximum of likelihood function. Experimentally measured values \(F_{i}\) are fitted with theoretical functions \(f_{i}(\vec{x_{i}},\vec{\theta})\), where \(\vec{x_{i}}\) are coordinates, and \(\vec{\theta}\) - vector of parameters. For better convergence Chi-square function has to be the following form; \[; \frac{\chi^2}{2} = \frac{1}{2} \sum_{i=1}^{n}; \left(\frac{f_{i}(\vec{x_{i}},\vec{\theta}) - F_{i}}; {\sigma_{i}}\right)^{2}; \]; where \(\sigma_{i}\) are errors of the measured function. The minimum condition is:; \[; \frac{\parti",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:227655,Availability,error,errors,227655,"rovided in the tutorials’ directory $ROOTSYS/tutorials/fit: minuit2FitBench.C, minuit2FitBench2D.C and minuit2GausFit.C. More information on the classes and functions present in Minuit2 is available at online reference documentation.; Useful information on MINUIT and minimization in general is provided in the following documents:; F. James, Minuit Tutorial on Function Minimization ( http://seal.cern.ch/documents/minuit/mntutorial.pdf); F. James, The Interpretation of Errors in Minuit ( http://seal.cern.ch/documents/minuit/mnerror.pdf);; 5.11 FUMILI Minimization Package; FUMILI is used to minimize Chi-square function or to search maximum of likelihood function. Experimentally measured values \(F_{i}\) are fitted with theoretical functions \(f_{i}(\vec{x_{i}},\vec{\theta})\), where \(\vec{x_{i}}\) are coordinates, and \(\vec{\theta}\) - vector of parameters. For better convergence Chi-square function has to be the following form; \[; \frac{\chi^2}{2} = \frac{1}{2} \sum_{i=1}^{n}; \left(\frac{f_{i}(\vec{x_{i}},\vec{\theta}) - F_{i}}; {\sigma_{i}}\right)^{2}; \]; where \(\sigma_{i}\) are errors of the measured function. The minimum condition is:; \[; \frac{\partial \chi^{2}}{\partial \theta_{i}} =; \sum_{j=1}^{n}; \frac{1}{\sigma_{j}^{2}} . \frac{\partial f_{i}}{\partial \theta_{i}}; \left[ (\vec{x_{j}},\vec{\theta}); - F_{j}\right] = 0, i = 1 ... m; \]; where \(m\) is the quantity of parameters. Expanding left part of this equation over parameter increments and retaining only linear terms one gets; \[; \left(\frac{\partial \chi^{2}}{\theta_{i}}\right); _{\theta = \vec{\theta}^{0}} +; \sum_{k}; \left(\frac{\partial^{2} \chi^{2}}{\partial \theta_{i}; \partial \theta_{k}}\right); _{\theta = \vec{\theta}^{0}} . (\theta_{k} - \theta_{k}^{0}) = 0; \]; here \(\vec{\theta}^{0}\) is some initial value of parameters. In general case:; \[; {\frac{\partial^2\chi^2}{\partial\theta_i\partial\theta_k}}=; \sum^n_{j=1}{\frac{1}{\sigma^2_j}}; {\frac{\partial f_j}{\theta_i}} {\frac{\parti",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:228978,Availability,down,down,228978,"]; where \(m\) is the quantity of parameters. Expanding left part of this equation over parameter increments and retaining only linear terms one gets; \[; \left(\frac{\partial \chi^{2}}{\theta_{i}}\right); _{\theta = \vec{\theta}^{0}} +; \sum_{k}; \left(\frac{\partial^{2} \chi^{2}}{\partial \theta_{i}; \partial \theta_{k}}\right); _{\theta = \vec{\theta}^{0}} . (\theta_{k} - \theta_{k}^{0}) = 0; \]; here \(\vec{\theta}^{0}\) is some initial value of parameters. In general case:; \[; {\frac{\partial^2\chi^2}{\partial\theta_i\partial\theta_k}}=; \sum^n_{j=1}{\frac{1}{\sigma^2_j}}; {\frac{\partial f_j}{\theta_i}} {\frac{\partial f_j}{\theta_k}} +; \sum^n_{j=1}{\frac{(f_j - F_j)}{\sigma^2_j}}\cdot; {\frac{\partial^2f_j}{\partial\theta_i\partial\theta_k}}; \]; In FUMILI algorithm for second derivatives of Chi-square approximate expression is used when last term in previous equation is discarded. It is often done, not always wittingly, and sometimes causes troubles, for example, if user wants to limit parameters with positive values by writing down \(\theta_i^2\) instead of \(\theta_i\). FUMILI will fail if one tries minimize \(\chi^2 = g^2(\vec\theta)\) where g is arbitrary function.; Approximate value is:; \[; {\frac{\partial^2\chi^2}{\partial\theta_i\partial\theta_k}}\approx Z_{ik}=; \sum^n_{j=1}{\frac{1}{\sigma^2_j}}{\frac{\partial f_j}{\theta_i}}; {\frac{\partial f_j}{\theta_k}}; \]; Then the equations for parameter increments are:; \[; \left(\frac{\partial\chi^2}{\partial\theta_i}\right)_; {\vec\theta={\vec\theta}^0} +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) =; 0, \qquad i=1\ldots m; \]; Remarkable feature of algorithm is the technique for step restriction. For an initial value of parameter \({\vec\theta}^0\) a parallelepiped \(P_0\) is built with the center at \({\vec\theta}^0\) and axes parallel to coordinate axes \(\theta_i\). The lengths of parallelepiped sides along i-th axis is \(2b_i\), where \(b_i\) is such a value that the functions \(f_j(\vec\theta)\) are qu",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:231912,Availability,error,error,231912,"it package, which remains one of the fastest tools for neural networks studies.; 5.12.2 The MLP; The multilayer perceptron is a simple feed-forward network with the following structure showed on the left. It is made of neurons characterized by a bias and weighted links in between - let’s call those links synapses. The input neurons receive the inputs, normalize them and forward them to the first hidden layer. Each neuron in any subsequent layer first computes a linear combination of the outputs of the previous layer. The output of the neuron is then function of that combination with f being linear for output neurons or a sigmoid for hidden layers.; Such a structure is very useful because of two theorems:; 1- A linear combination of sigmoids can approximate any continuous function.; 2- Trained with output=1 for the signal and 0 for the background, the approximated function of inputs X is the probability of signal, knowing X.; 5.12.3 Learning Methods; The aim of all learning methods is to minimize the total error on a set of weighted examples. The error is defined as the sum in quadrate, divided by two, of the error on each individual output neuron. In all methods implemented in this library, one needs to compute the first derivative of that error with respect to the weights. Exploiting the well-known properties of the derivative, one can express this derivative as the product of the local partial derivative by the weighted sum of the outputs derivatives (for a neuron) or as the product of the input value with the local partial derivative of the output neuron (for a synapse). This computation is called “back-propagation of the errors”. Six learning methods are implemented.; 5.12.3.1 Stochastic Minimization; This is the most trivial learning method. The Robbins-Monro stochastic approximation is applied to multilayer perceptrons. The weights are updated after each example according to the formula:; \[; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); \]; with:; \[; \Delta w_{",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:231953,Availability,error,error,231953," perceptron is a simple feed-forward network with the following structure showed on the left. It is made of neurons characterized by a bias and weighted links in between - let’s call those links synapses. The input neurons receive the inputs, normalize them and forward them to the first hidden layer. Each neuron in any subsequent layer first computes a linear combination of the outputs of the previous layer. The output of the neuron is then function of that combination with f being linear for output neurons or a sigmoid for hidden layers.; Such a structure is very useful because of two theorems:; 1- A linear combination of sigmoids can approximate any continuous function.; 2- Trained with output=1 for the signal and 0 for the background, the approximated function of inputs X is the probability of signal, knowing X.; 5.12.3 Learning Methods; The aim of all learning methods is to minimize the total error on a set of weighted examples. The error is defined as the sum in quadrate, divided by two, of the error on each individual output neuron. In all methods implemented in this library, one needs to compute the first derivative of that error with respect to the weights. Exploiting the well-known properties of the derivative, one can express this derivative as the product of the local partial derivative by the weighted sum of the outputs derivatives (for a neuron) or as the product of the input value with the local partial derivative of the output neuron (for a synapse). This computation is called “back-propagation of the errors”. Six learning methods are implemented.; 5.12.3.1 Stochastic Minimization; This is the most trivial learning method. The Robbins-Monro stochastic approximation is applied to multilayer perceptrons. The weights are updated after each example according to the formula:; \[; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); \]; with:; \[; \Delta w_{ij}(t) = - \eta \left(; \frac{\partial e_p}{\partial w_{ij}} + \delta \right) +; \epsilon \Delta w_{ij}(t-1); ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:232017,Availability,error,error,232017," perceptron is a simple feed-forward network with the following structure showed on the left. It is made of neurons characterized by a bias and weighted links in between - let’s call those links synapses. The input neurons receive the inputs, normalize them and forward them to the first hidden layer. Each neuron in any subsequent layer first computes a linear combination of the outputs of the previous layer. The output of the neuron is then function of that combination with f being linear for output neurons or a sigmoid for hidden layers.; Such a structure is very useful because of two theorems:; 1- A linear combination of sigmoids can approximate any continuous function.; 2- Trained with output=1 for the signal and 0 for the background, the approximated function of inputs X is the probability of signal, knowing X.; 5.12.3 Learning Methods; The aim of all learning methods is to minimize the total error on a set of weighted examples. The error is defined as the sum in quadrate, divided by two, of the error on each individual output neuron. In all methods implemented in this library, one needs to compute the first derivative of that error with respect to the weights. Exploiting the well-known properties of the derivative, one can express this derivative as the product of the local partial derivative by the weighted sum of the outputs derivatives (for a neuron) or as the product of the input value with the local partial derivative of the output neuron (for a synapse). This computation is called “back-propagation of the errors”. Six learning methods are implemented.; 5.12.3.1 Stochastic Minimization; This is the most trivial learning method. The Robbins-Monro stochastic approximation is applied to multilayer perceptrons. The weights are updated after each example according to the formula:; \[; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); \]; with:; \[; \Delta w_{ij}(t) = - \eta \left(; \frac{\partial e_p}{\partial w_{ij}} + \delta \right) +; \epsilon \Delta w_{ij}(t-1); ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:232151,Availability,error,error,232151,"aracterized by a bias and weighted links in between - let’s call those links synapses. The input neurons receive the inputs, normalize them and forward them to the first hidden layer. Each neuron in any subsequent layer first computes a linear combination of the outputs of the previous layer. The output of the neuron is then function of that combination with f being linear for output neurons or a sigmoid for hidden layers.; Such a structure is very useful because of two theorems:; 1- A linear combination of sigmoids can approximate any continuous function.; 2- Trained with output=1 for the signal and 0 for the background, the approximated function of inputs X is the probability of signal, knowing X.; 5.12.3 Learning Methods; The aim of all learning methods is to minimize the total error on a set of weighted examples. The error is defined as the sum in quadrate, divided by two, of the error on each individual output neuron. In all methods implemented in this library, one needs to compute the first derivative of that error with respect to the weights. Exploiting the well-known properties of the derivative, one can express this derivative as the product of the local partial derivative by the weighted sum of the outputs derivatives (for a neuron) or as the product of the input value with the local partial derivative of the output neuron (for a synapse). This computation is called “back-propagation of the errors”. Six learning methods are implemented.; 5.12.3.1 Stochastic Minimization; This is the most trivial learning method. The Robbins-Monro stochastic approximation is applied to multilayer perceptrons. The weights are updated after each example according to the formula:; \[; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); \]; with:; \[; \Delta w_{ij}(t) = - \eta \left(; \frac{\partial e_p}{\partial w_{ij}} + \delta \right) +; \epsilon \Delta w_{ij}(t-1); \]; The parameters for this method are Eta, EtaDecay, Delta and Epsilon.; 5.12.3.2 Steepest Descent With Fixed Step Siz",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:232544,Availability,error,errors,232544,"igmoid for hidden layers.; Such a structure is very useful because of two theorems:; 1- A linear combination of sigmoids can approximate any continuous function.; 2- Trained with output=1 for the signal and 0 for the background, the approximated function of inputs X is the probability of signal, knowing X.; 5.12.3 Learning Methods; The aim of all learning methods is to minimize the total error on a set of weighted examples. The error is defined as the sum in quadrate, divided by two, of the error on each individual output neuron. In all methods implemented in this library, one needs to compute the first derivative of that error with respect to the weights. Exploiting the well-known properties of the derivative, one can express this derivative as the product of the local partial derivative by the weighted sum of the outputs derivatives (for a neuron) or as the product of the input value with the local partial derivative of the output neuron (for a synapse). This computation is called “back-propagation of the errors”. Six learning methods are implemented.; 5.12.3.1 Stochastic Minimization; This is the most trivial learning method. The Robbins-Monro stochastic approximation is applied to multilayer perceptrons. The weights are updated after each example according to the formula:; \[; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); \]; with:; \[; \Delta w_{ij}(t) = - \eta \left(; \frac{\partial e_p}{\partial w_{ij}} + \delta \right) +; \epsilon \Delta w_{ij}(t-1); \]; The parameters for this method are Eta, EtaDecay, Delta and Epsilon.; 5.12.3.2 Steepest Descent With Fixed Step Size (Batch Learning); It is the same as the stochastic minimization, but the weights are updated after considering all the examples, with the total derivative dEdw. The parameters for this method are Eta, EtaDecay, Delta and Epsilon.; 5.12.3.3 Steepest Descent Algorithm; Weights are set to the minimum along the line defined by the gradient. The only parameter for this method is Tau. Lower Tau = highe",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:236094,Availability,error,error,236094,"by ‘@’ (e.g. “@out”) if one wants to normalize the corresponding value. Also, if the string ends with ‘!’, output neurons are set up for classification, i.e. with a sigmoid (1 neuron) or softmax (more neurons) activation function.; Many questions on the good usage of neural network, including rules of dumb to determine the best network topology are addressed at ftp://ftp.sas.com/pub/neural/FAQ.html; // a simple network: 2 inputs, 10 hidden and 1 normalized; // output neuron; TMultiLayerPerceptron network(""r,z:10:@Br"",tree);; Expressions are evaluated as for TTree::Draw(). Input and outputs are taken from the TTree associated with the network. This TTree can be given as argument of the constructor or defined later with TMultiLayerPerceptron::SetData(). Events can also be weighted. The weight expression can be given in the constructor or set later with the method SetWeight() of the class TMultiLayerPerceptron. Two datasets must be defined before learning the network: a training dataset that is used when minimizing the error, and a test dataset that will avoid bias. Those two datasets can be built aside and then given to the network, or can be built from a standard expression. By default, half of the events are put in both datasets.; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; The method TMultiLayerPerceptron::SetLearningMethod() defines the learning method. Learning methods are:; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; The training can start with TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options). The first argument is the number of epochs while option is a string that can contain “text” (simple text output), “grap",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:237252,Availability,avail,available,237252,"ression. By default, half of the events are put in both datasets.; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; The method TMultiLayerPerceptron::SetLearningMethod() defines the learning method. Learning methods are:; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; The training can start with TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options). The first argument is the number of epochs while option is a string that can contain “text” (simple text output), “graph” (evaluating graphical training curves), “update = X” (step for the text/graph output update) or “+” (will skip the randomization and start from the previous values). All combinations are available.; network.Train(1000,""text,graph,update=10""); // full output every; // 10 epochs; network.Train(100,""text,+""); // 100 more epochs; //starts with existing weights; The weights can be saved to a file (DumpWeights) and then reloaded (LoadWeights) to a new compatible network. The output can also be evaluated (Evaluate) for a given output neuron and an array of double input parameters or the network can be exported (Export) as a standalone code. Up to now, this is only as a C++ or PYTHON class, but other languages could be implemented.; 5.12.5 Examples; An example of how to use TMultiLayerPerceptron is the macro mlpHiggs.C in $ROOTSYS/tutorials. Using some standard simulated information that could have been obtained at LEP, a neural network is build, which can make the difference between WW events and events containing a Higgs boson. Starting with a TFile containing two TTrees: one for the signal, the other for the background, a simple script is used:; void mlpHiggs(Int_t nt",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:241472,Availability,recover,recovered,241472,"he neural net output” shows this plot. The neural net output. As it can be seen, this is a quite efficient technique. As mentioned earlier, neural networks are also used for fitting function. For some application with a cylindrical symmetry, a magnetic field simulation gives as output the angular component of the potential vector A, as well as the radial and z components of the B field.; One wants to fit those distributions with a function in order to plug them into the Geant simulation code. Polynomial fits could be tried, but it seems difficult to reach the desired precision over the full range. One could also use a spline interpolation between known points. In all cases, the resulting field would not be C-infinite.; An example of output (for Br) is shown. First the initial function can be seen as the target. Then, the resulting (normalized) neural net output. In order to ease the learning, the “normalize output” was used here. The initial amplitude can be recovered by multiplying by the original RMS and then shifting by the original mean. The original and the neural net for Br. 6 A Little C++. This chapter introduces you to some useful insights into C++, to allow you to use some of the most advanced features in ROOT. It is in no case a full course in C++.; 6.1 Classes, Methods and Constructors; C++ extends C with the notion of a class. If you’re used to structures in C, a class is a struct that is a group of related variables, which is extended with functions and routines specific to this structure (class). What is the interest? Consider a struct that is defined this way:; struct Line {; float x1;; float y1;; float x2;; float y2;; }; This structure represents a line to be drawn in a graphical window. (x1,y1) are the coordinates of the first point, (x2,y2) the coordinates of the second point. In the standard C, if you want to draw effectively such a line, you first have to define a structure and initialize the points (you can try this):; Line firstline;; firstline",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:252327,Availability,toler,tolerate,252327,"ON block variables, live for the lifetime of the program. However, most people in HEP who use FORTRAN will have experience of a memory manager and the act of creating a bank is a good equivalent of a heap object. For those who know systems like ZEBRA, it will come as a relief to learn that objects do not move, C++ does not garbage collect, so there is never a danger that a pointer to an object becomes invalid for that reason. However, having created an object, it is the user’s responsibility to ensure that it is deleted when no longer needed, or to pass that responsibility onto to some other object. Failing to do that will result in a memory leak, one of the most common and most hard-to-find C++ bugs.; To send a message to an object via a pointer to it, you need to use the “->” operator e.g.:; root[] my_objptr->Solve();; Although we chose to call our pointer my_objptr, to emphasize that it is a pointer, heap objects are so common in an object-oriented program that pointer names rarely reflect the fact - you have to be careful that you know if you are dealing with an object or its pointer! Fortunately, the compiler won’t tolerate an attempt to do something like:; root[] my_objptr.Solve();; As we have seen, heap objects have to be accessed via pointers, whereas stack objects can be accessed directly. They can also be accessed via pointers:; root[] Quad stack_quad(1.,2.,-3.);; root[] Quad *stack_ptr = &stack_quad;; root[] stack_ptr->Solve();; Here we have a Quad pointer that has been initialized with the address of a stack object. Be very careful if you take the address of stack objects. As we shall see soon, they are deleted automatically, which could leave you with an illegal pointer. Using it will corrupt and may as well crash the program!; It is time to look at the destruction of objects. A destructor is a special C++ function that releases resources for (or destroys) an object of a class. It is the opposite of a constructor that creates the object of a class when ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:265189,Availability,error,error,265189," but the pointer in the named script scope will be “gone”. Since histograms (and trees) are added to the list of objects in the current directory, you can always retrieve them to delete them if needed.; root[] TH1F *h = (TH1F*)gDirectory->Get(""myHist""); // or; root[] TH1F *h = (TH1F*)gDirectory->GetList()->FindObject(""myHist"");; In addition, histograms and trees are automatically deleted when the current directory is closed. This will automatically take care of the clean up. See “Input/Output”.; 7.2.1 Executing a Script From a Script; You may want to execute a script conditionally inside another script. To do it you need to call the interpreter and you can do that with TROOT::ProcessLine(). The example $ROOTSYS/tutorials/tree/cernstaff.C calls a script to build the root file if it does not exist:; void cernstaff() {; if (gSystem->AccessPathName(""cernstaff.root"")) {; gROOT->ProcessLine("".x cernbuild.C"");; }; ProcessLine takes a parameter, which is a pointer to an int or to a TInterpreter::EErrorCode to let you access the interpreter error code after an attempt to interpret. This will contain the error as defined in enum TInterpreter::EErrorCode with TInterpreter::kSuccess being the value for a successful execution.; 7.2.2 Executing a Script From the Invocation; Instead if starting ROOT and running a script on the prompt you can also pass it to ROOT in its invocation:; $ root -l -b 'myCode.C(""some String"", 12)'; The exact kind of quoting depends on your shell; the one shown here works for bash-like shells.; ROOT can evaluate any expression as part of the invocation; another version of the previous example can be spelled like this:; $ root -l -b -e 'gROOT->ProcessLine("".x myCode.C(\""some String\"", 12)"");'; 7.3 C++ Extensions To Ease Scripting; In the next example, we demonstrate three of the most important extensions ROOT and Cling make to C++. Start ROOT in the directory $ROOTSYS/tutorials (make sure to have first run .x hsimple.C):; root [0] f = new TFile(""hsimple.roo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:265253,Availability,error,error,265253," retrieve them to delete them if needed.; root[] TH1F *h = (TH1F*)gDirectory->Get(""myHist""); // or; root[] TH1F *h = (TH1F*)gDirectory->GetList()->FindObject(""myHist"");; In addition, histograms and trees are automatically deleted when the current directory is closed. This will automatically take care of the clean up. See “Input/Output”.; 7.2.1 Executing a Script From a Script; You may want to execute a script conditionally inside another script. To do it you need to call the interpreter and you can do that with TROOT::ProcessLine(). The example $ROOTSYS/tutorials/tree/cernstaff.C calls a script to build the root file if it does not exist:; void cernstaff() {; if (gSystem->AccessPathName(""cernstaff.root"")) {; gROOT->ProcessLine("".x cernbuild.C"");; }; ProcessLine takes a parameter, which is a pointer to an int or to a TInterpreter::EErrorCode to let you access the interpreter error code after an attempt to interpret. This will contain the error as defined in enum TInterpreter::EErrorCode with TInterpreter::kSuccess being the value for a successful execution.; 7.2.2 Executing a Script From the Invocation; Instead if starting ROOT and running a script on the prompt you can also pass it to ROOT in its invocation:; $ root -l -b 'myCode.C(""some String"", 12)'; The exact kind of quoting depends on your shell; the one shown here works for bash-like shells.; ROOT can evaluate any expression as part of the invocation; another version of the previous example can be spelled like this:; $ root -l -b -e 'gROOT->ProcessLine("".x myCode.C(\""some String\"", 12)"");'; 7.3 C++ Extensions To Ease Scripting; In the next example, we demonstrate three of the most important extensions ROOT and Cling make to C++. Start ROOT in the directory $ROOTSYS/tutorials (make sure to have first run .x hsimple.C):; root [0] f = new TFile(""hsimple.root""); (class TFile *) 0x4045e690; root [1] f->ls(); TFile** hsimple.root; TFile* hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:275144,Availability,error,errors,275144,"SYS/etc/system.rootrc) and the prefix is the name of your script.; The default behavior of rootcling is to not link in (i.e. generate the dictionary for) any of the symbols. In particular, this means that the following lines are, in the general case, unnecessary.; #pragma link off all globals;; #pragma link off all classes;; #pragma link off all functions;; This also means that linking the instantiation of a class template:; #pragma link C++ class mytemplate<int>;; ONLY links this specific class. You need to request the generation of the iterators explicitly.; See the documentation of rootcling for details how pragma can be used.; NOTE: You should not call ACLiC with a script that has a function called main().; 7.4.4 Intermediate Steps and Files; ACLiC executes two steps and a third one if needed. These are:. Calling rootcling to create a dictionary using rootcling.; Calling the compiler to build the shared library from the script.; If there are errors, it calls the compiler to build a dummy executable to clearly report unresolved symbols. ACLiC makes a shared library with a dictionary containing the classes and functions declared in the script. It also adds the classes and functions declared in included files with the same name as the script file and any of the following extensions: .h, .hh, .hpp, .hxx, .hPP, .hXX. This means that, by default, you cannot combine scripts from different files into one library by using #include statements; you will need to compile each script separately. In a future release, we plan to add the global variables declared in the script to the dictionary also. If you are curious about the specific calls, you can raise the ROOT debug level: gDebug=3 and ACLiC will print these steps. If you need to keep the intermediate files around, for example when debugging the script using gdb, use gDebug=7.; 7.4.5 Moving between Interpreter and Compiler; The best way to develop portable scripts is to make sure you can always run them with both, the int",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:277234,Availability,avail,available,277234,"always run them with both, the interpreter and with ACLiC. To do so, do not use the Cling extensions and program around the Cling limitations. When it is not possible or desirable to program around the Cling limitations, you can use the C preprocessor symbols defined for Cling and rootcling.; The preprocessor symbol __CLING__ is defined for both ROOT and rootcling. The symbol __ROOTCLING__ (and __MAKECINT__ for backward compatibility) is only defined in rootcling.; Use !defined(__CLING__) || defined(__ROOTCLING__) to bracket code that needs to be seen by the compiler and rootcling, but will be invisible to the interpreter.; Use !defined(__CLING__)to bracket code that should be seen only by the compiler and not by Cling nor rootcling.For example, the following will hide the declaration and initialization of the array gArray from both Cling and rootcling.; #if !defined(__CLING__); int gArray[] = { 2, 3, 4};; #endif; Because ACLiC calls rootcling to build a dictionary, the declaration of gArray will not be included in the dictionary, and consequently, gArray will not be available at the command line even if ACLiC is used. Cling and rootcling will ignore all statements between the ""#if !defined (__CLING__)"" and ""#endif"". If you want to use gArray in the same script as its declaration, you can do so. However, if you want use the script in the interpreter you have to bracket the usage of gArray between #if's, since the definition is not visible. If you add the following preprocessor statements:; #if !defined(__CLING__); int gArray[] = { 2, 3, 4};; #elif defined(__ROOTCLING__); int gArray[];; #endif; gArray will be visible to rootcling but still not visible to Cling. If you use ACLiC, gArray will be available at the command line and be initialized properly by the compiled code.; We recommend you always write scripts with the needed include statements. In most cases, the script will still run with the interpreter. However, a few header files are not handled very well by Clin",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:277872,Availability,avail,available,277872,"or example, the following will hide the declaration and initialization of the array gArray from both Cling and rootcling.; #if !defined(__CLING__); int gArray[] = { 2, 3, 4};; #endif; Because ACLiC calls rootcling to build a dictionary, the declaration of gArray will not be included in the dictionary, and consequently, gArray will not be available at the command line even if ACLiC is used. Cling and rootcling will ignore all statements between the ""#if !defined (__CLING__)"" and ""#endif"". If you want to use gArray in the same script as its declaration, you can do so. However, if you want use the script in the interpreter you have to bracket the usage of gArray between #if's, since the definition is not visible. If you add the following preprocessor statements:; #if !defined(__CLING__); int gArray[] = { 2, 3, 4};; #elif defined(__ROOTCLING__); int gArray[];; #endif; gArray will be visible to rootcling but still not visible to Cling. If you use ACLiC, gArray will be available at the command line and be initialized properly by the compiled code.; We recommend you always write scripts with the needed include statements. In most cases, the script will still run with the interpreter. However, a few header files are not handled very well by Cling.; These types of headers can be included in interpreted and compiled mode:. The subset of standard C/C++ headers defined in $ROOTSYS/Cling/include.; Headers of classes defined in a previously loaded library (including ROOT own). The defined class must have a name known to ROOT (i.e. a class with a ClassDef). Hiding header files from rootcling that are necessary for the compiler but optional for the interpreter can lead to a subtle but fatal error. For example:; #ifndef __CLING__; #include ""TTree.h""; #else; class TTree;; #endif. class subTree : public TTree {; };; In this case, rootcling does not have enough information about the TTree class to produce the correct dictionary file. If you try this, rootcling and compiling will be erro",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:278598,Availability,error,error,278598," bracket the usage of gArray between #if's, since the definition is not visible. If you add the following preprocessor statements:; #if !defined(__CLING__); int gArray[] = { 2, 3, 4};; #elif defined(__ROOTCLING__); int gArray[];; #endif; gArray will be visible to rootcling but still not visible to Cling. If you use ACLiC, gArray will be available at the command line and be initialized properly by the compiled code.; We recommend you always write scripts with the needed include statements. In most cases, the script will still run with the interpreter. However, a few header files are not handled very well by Cling.; These types of headers can be included in interpreted and compiled mode:. The subset of standard C/C++ headers defined in $ROOTSYS/Cling/include.; Headers of classes defined in a previously loaded library (including ROOT own). The defined class must have a name known to ROOT (i.e. a class with a ClassDef). Hiding header files from rootcling that are necessary for the compiler but optional for the interpreter can lead to a subtle but fatal error. For example:; #ifndef __CLING__; #include ""TTree.h""; #else; class TTree;; #endif. class subTree : public TTree {; };; In this case, rootcling does not have enough information about the TTree class to produce the correct dictionary file. If you try this, rootcling and compiling will be error free, however, instantiating a subTree object from the Cling command line will cause a fatal error. In general, it is recommended to let rootcling see as many header files as possible.; 7.5 Classes Defined By Scripts; Lets create a small class TMyClass and a derived class TChild. The virtual method TMyClass::Print()is overridden in TChild. Save this in file called script4.C.; #include <iostream.h>. class TMyClass {; private:; float fX; //x position in centimeters; float fY; //y position in centimeters; public:; TMyClass() { fX = fY = -1; }; virtual void Print() const;; void SetX(float x) { fX = x; }; void SetY(float y) { fY = y;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:278891,Availability,error,error,278891,"ed properly by the compiled code.; We recommend you always write scripts with the needed include statements. In most cases, the script will still run with the interpreter. However, a few header files are not handled very well by Cling.; These types of headers can be included in interpreted and compiled mode:. The subset of standard C/C++ headers defined in $ROOTSYS/Cling/include.; Headers of classes defined in a previously loaded library (including ROOT own). The defined class must have a name known to ROOT (i.e. a class with a ClassDef). Hiding header files from rootcling that are necessary for the compiler but optional for the interpreter can lead to a subtle but fatal error. For example:; #ifndef __CLING__; #include ""TTree.h""; #else; class TTree;; #endif. class subTree : public TTree {; };; In this case, rootcling does not have enough information about the TTree class to produce the correct dictionary file. If you try this, rootcling and compiling will be error free, however, instantiating a subTree object from the Cling command line will cause a fatal error. In general, it is recommended to let rootcling see as many header files as possible.; 7.5 Classes Defined By Scripts; Lets create a small class TMyClass and a derived class TChild. The virtual method TMyClass::Print()is overridden in TChild. Save this in file called script4.C.; #include <iostream.h>. class TMyClass {; private:; float fX; //x position in centimeters; float fY; //y position in centimeters; public:; TMyClass() { fX = fY = -1; }; virtual void Print() const;; void SetX(float x) { fX = x; }; void SetY(float y) { fY = y; }; };; void TMyClass::Print() const // parent print method; {; cout << ""fX = "" << fX << "", fY = "" << fY << endl;; }; class TChild : public TMyClass {; public:; void Print() const;; };; void TChild::Print() const // child print metod; {; cout << ""This is TChild::Print()"" << endl;; TMyClass::Print();; }; To execute script4.C do:; root[] .L script4.C; root[] TMyClass *a = new TChild; r",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:278990,Availability,error,error,278990,"ed properly by the compiled code.; We recommend you always write scripts with the needed include statements. In most cases, the script will still run with the interpreter. However, a few header files are not handled very well by Cling.; These types of headers can be included in interpreted and compiled mode:. The subset of standard C/C++ headers defined in $ROOTSYS/Cling/include.; Headers of classes defined in a previously loaded library (including ROOT own). The defined class must have a name known to ROOT (i.e. a class with a ClassDef). Hiding header files from rootcling that are necessary for the compiler but optional for the interpreter can lead to a subtle but fatal error. For example:; #ifndef __CLING__; #include ""TTree.h""; #else; class TTree;; #endif. class subTree : public TTree {; };; In this case, rootcling does not have enough information about the TTree class to produce the correct dictionary file. If you try this, rootcling and compiling will be error free, however, instantiating a subTree object from the Cling command line will cause a fatal error. In general, it is recommended to let rootcling see as many header files as possible.; 7.5 Classes Defined By Scripts; Lets create a small class TMyClass and a derived class TChild. The virtual method TMyClass::Print()is overridden in TChild. Save this in file called script4.C.; #include <iostream.h>. class TMyClass {; private:; float fX; //x position in centimeters; float fY; //y position in centimeters; public:; TMyClass() { fX = fY = -1; }; virtual void Print() const;; void SetX(float x) { fX = x; }; void SetY(float y) { fY = y; }; };; void TMyClass::Print() const // parent print method; {; cout << ""fX = "" << fX << "", fY = "" << fY << endl;; }; class TChild : public TMyClass {; public:; void Print() const;; };; void TChild::Print() const // child print metod; {; cout << ""This is TChild::Print()"" << endl;; TMyClass::Print();; }; To execute script4.C do:; root[] .L script4.C; root[] TMyClass *a = new TChild; r",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:335970,Availability,avail,available,335970,"xis for the same plot, one on the left and one on the right.; For historical reasons, there are two classes representing axis. TAxis * axis is the axis object, which will be returned when calling the TH1::GetAxis() method.; TAxis *axis = histo->GetXaxis(); Of course, you may do the same for Y and Z-axis. The graphical representation of an axis is done with the TGaxis class. The histogram classes and TGraph generate instances of this class. This is internal and the user should not have to see it.; 9.5.1 Axis Title; The axis title is set, as with all named objects, by; axis->SetTitle(""Whatever title you want"");; When the axis is embedded into a histogram or a graph, one has to first extract the axis object:; h->GetXaxis()->SetTitle(""Whatever title you want""); 9.5.2 Axis Options and Characteristics; The axis options are most simply set with the styles. The available style options controlling specific axis options are the following:; TAxis *axis = histo->GetXaxis();; axis->SetAxisColor(Color_t color = 1);; axis->SetLabelColor(Color_t color = 1);; axis->SetLabelFont(Style_t font = 62);; axis->SetLabelOffset(Float_t offset = 0.005);; axis->SetLabelSize(Float_t size = 0.04);; axis->SetNdivisions(Int_t n = 510, Bool_t optim = kTRUE);; axis->SetNoExponent(Bool_t noExponent = kTRUE);; axis->SetTickLength(Float_t length = 0.03);; axis->SetTitleOffset(Float_t offset = 1);; axis->SetTitleSize(Float_t size = 0.02);; The getters corresponding to the described setters are also available. The general options, not specific to axis, as for instance SetTitleTextColor() are valid and do have an effect on axis characteristics.; 9.5.3 Setting the Number of Divisions; Use TAxis::SetNdivisions(ndiv,optim) to set the number of divisions for an axis. The ndiv and optim are as follows:. ndiv = N1 + 100*N2 + 10000*N3; N1 = number of first divisions.; N2 = number of secondary divisions.; N3 = number of tertiary divisions.; optim = kTRUE (default), the divisions’ number will be optimized around t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:336590,Availability,avail,available,336590,"al and the user should not have to see it.; 9.5.1 Axis Title; The axis title is set, as with all named objects, by; axis->SetTitle(""Whatever title you want"");; When the axis is embedded into a histogram or a graph, one has to first extract the axis object:; h->GetXaxis()->SetTitle(""Whatever title you want""); 9.5.2 Axis Options and Characteristics; The axis options are most simply set with the styles. The available style options controlling specific axis options are the following:; TAxis *axis = histo->GetXaxis();; axis->SetAxisColor(Color_t color = 1);; axis->SetLabelColor(Color_t color = 1);; axis->SetLabelFont(Style_t font = 62);; axis->SetLabelOffset(Float_t offset = 0.005);; axis->SetLabelSize(Float_t size = 0.04);; axis->SetNdivisions(Int_t n = 510, Bool_t optim = kTRUE);; axis->SetNoExponent(Bool_t noExponent = kTRUE);; axis->SetTickLength(Float_t length = 0.03);; axis->SetTitleOffset(Float_t offset = 1);; axis->SetTitleSize(Float_t size = 0.02);; The getters corresponding to the described setters are also available. The general options, not specific to axis, as for instance SetTitleTextColor() are valid and do have an effect on axis characteristics.; 9.5.3 Setting the Number of Divisions; Use TAxis::SetNdivisions(ndiv,optim) to set the number of divisions for an axis. The ndiv and optim are as follows:. ndiv = N1 + 100*N2 + 10000*N3; N1 = number of first divisions.; N2 = number of secondary divisions.; N3 = number of tertiary divisions.; optim = kTRUE (default), the divisions’ number will be optimized around the specified value.; optim = kFALSE, or n < 0, the axis will be forced to use exactly n divisions. For example:; ndiv = 0: no tick marks.; ndiv = 2: 2 divisions, one tick mark in the middle of the axis.; ndiv = 510: 10 primary divisions, 5 secondary divisions; ndiv = -10: exactly 10 primary divisions; 9.5.4 Zooming the Axis; You can use TAxis::SetRange or TAxis::SetRangeUser to zoom the axis.; TAxis::SetRange(Int_t binfirst,Int_t binlast); The SetRange m",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:341271,Availability,avail,available,341271,"unction TAxis::CenterLabels() sets the bit kCenterLabels and it is visible from TAxis context menu. It centers the bin labels and it makes sense only when the number of bins is equal to the number of tick marks. The class responsible for drawing the axis TGaxis inherits this property.; 9.5.7.2 Orientation; Labels are normally drawn parallel to the axis. However, if xmin = xmax, then they are drawn orthogonal, and if ymin=ymax they are drawn parallel.; 9.5.7.3 Labels for Exponents; By default, an exponent of the form 10^N is used when the label values are either all very small or very large. One can disable the exponent by calling:; TAxis::SetNoExponent(kTRUE); Note that this option is implicitly selected if the number of digits to draw a label is less than the fgMaxDigits global member. If the property SetNoExponent was set in TAxis (via TAxis::SetNoExponent), the TGaxis will inherit this property. TGaxis is the class responsible for drawing the axis. The method SetNoExponent is also available from the axis context menu. Y-axis with and without exponent labels. 9.5.7.4 Number of Digits in Labels; TGaxis::fgMaxDigits is the maximum number of digits permitted for the axis labels above which the notation with 10^N is used. It must be greater than 0. By default fgMaxDigits is 5 and to change it use the TGaxis::SetMaxDigits method. For example to set fgMaxDigits to accept 6 digits and accept numbers like 900000 on an axis call:; TGaxis::SetMaxDigits(6); 9.5.7.5 Tick Mark Positions; Labels are centered on tick marks. However, if xmin = xmax, then they are right adjusted. chopt = 'R': labels are right adjusted on tick mark (default is centered); chopt = 'L': labels are left adjusted on tick mark.; chopt = 'C': labels are centered on tick mark.; chopt = 'M': In the Middle of the divisions. 9.5.7.6 Label Formatting; Blank characters are stripped, and then the label is correctly aligned. The dot, if last character of the string, is also stripped. In the following, we have some",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:354452,Availability,avail,available,354452,"Suppose “la” is a TLatex object. The alignment is set with:; root[] la->SetTextAlign(align); The parameter align is a short describing the alignment:; align = 10*HorizontalAlign + VerticalAlign; For horizontal alignment, the following convention applies:. 1 = left; 2 = centered; 3 = right. For vertical alignment, the following convention applies:. 1 = bottom; 2 = centered; 3 = top. For example, align: 11 = left adjusted and bottom adjusted; 32 = right adjusted and vertically centered.; 9.6.1.2 Setting Text Angle; Use TAttText::SetTextAngle to set the text angle. The angle is the degrees of the horizontal.; root[] la->SetTextAngle(angle); 9.6.1.3 Setting Text Color; Use TAttText::SetTextColor to set the text color. The color is the color index. The colors are described in “Color and Color Palettes”.; root[] la->SetTextColor(color); 9.6.1.4 Setting Text Font; Use TAttText::SetTextFont to set the font. The parameter font is the font code, combining the font and precision: font = 10 * fontID + precision; root[] la->SetTextFont(font); The table below lists the available fonts. The font IDs must be between 1 and 14. The precision can be:. Precision = 0 fast hardware fonts (steps in the size); Precision = 1 scalable and rotate-able hardware fonts (see below); Precision = 2 scalable and rotate-able hardware fonts. When precision 0 is used, only the original non-scaled system fonts are used. The fonts have a minimum (4) and maximum (37) size in pixels. These fonts are fast and are of good quality. Their size varies with large steps and they cannot be rotated. Precision 1 and 2 fonts have a different behavior depending if True Type Fonts (TTF) are used or not. If TTF are used, you always get very good quality scalable and rotate-able fonts. However, TTF are slow. Precision 1 and 2 fonts have a different behavior for PostScript in case of TLatex objects:. With precision 1, the PostScript text uses the old convention (see TPostScript) for some special characters to draw sub and",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:355651,Availability,avail,available,355651,"ion = 2 scalable and rotate-able hardware fonts. When precision 0 is used, only the original non-scaled system fonts are used. The fonts have a minimum (4) and maximum (37) size in pixels. These fonts are fast and are of good quality. Their size varies with large steps and they cannot be rotated. Precision 1 and 2 fonts have a different behavior depending if True Type Fonts (TTF) are used or not. If TTF are used, you always get very good quality scalable and rotate-able fonts. However, TTF are slow. Precision 1 and 2 fonts have a different behavior for PostScript in case of TLatex objects:. With precision 1, the PostScript text uses the old convention (see TPostScript) for some special characters to draw sub and superscripts or Greek text.; With precision 2, the “PostScript” special characters are drawn as such. To draw sub and superscripts it is highly recommended to use TLatex objects instead. For example: font = 62 is the font with ID 6 and precision 2. Font’s examples. The available fonts are:. Font ID; X11; True Type name; Is italic; “boldness”. 1; times-medium-i-normal; “Times New Roman”; Yes; 4. 2; times-bold-r-normal; “Times New Roman”; No; 7. 3; times-bold-i-normal; “Times New Roman”; Yes; 7. 4; helvetica-medium-r-norma l; “Arial”; No; 4. 5; helvetica-medium-o-norma l; “Arial”; Yes; 4. 6; helvetica-bold-r-normal; “Arial”; No; 7. 7; helvetica-bold-o-normal; “Arial”; Yes; 7. 8; courier-medium-r-normal; “Courier New”; No; 4. 9; courier-medium-o-normal; “Courier New”; Yes; 4. 10; courier-bold-r-normal; “Courier New”; No; 7. 11; courier-bold-o-normal; “Courier New”; Yes; 7. 12; symbol-medium-r-normal; “Symbol”; No; 6. 13; times-medium-r-normal; “Times New Roman”; No; 4. 14. “Wingdings”; No; 4. This script makes the image of the different fonts:; {; textc = new TCanvas(""textc"",""Example of text"",1);; for (int i=1;i<15;i++) {; cid = new char[8];; sprintf(cid,""ID %d :"",i);; cid[7] = 0;; lid = new TLatex(0.1,1-(double)i/15,cid);; lid->SetTextFont(62);; lid->Draw();; ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:361333,Availability,avail,available,361333," styles >3100 and <3999 are hatches. They are defined according to the FillStyle=3ijk value as follows:. i(1-9) specifies the space between each hatch (1=minimum space, 9=maximum). The final spacing is set by SetHatchesSpacing() method and it is*GetHatchesSpacing().; j(0-9) specifies the angle between 0 and 90 degres as follows: 0=0, 1=10, 2=20, 3=30, 4=45, 5=not drawn, 6=60, 7=70, 8=80 and 9=90.; k(0-9) specifies the angle between 0 and 90 degres as follows: 0=180, 1=170, 2=160, 3=150, 4=135, 5=not drawn, 6=120, 7=110, 8=100 and 9=90. The various patterns. 9.6.4 Color and Color Palettes; At initialization time, a table of basic colors is generated when the first Canvas constructor is called. This table is a linked list, which can be accessed from the gROOT object (see TROOT::GetListOfColors()). Each color has an index and when a basic color is defined, two “companion” colors are defined: the dark version and the bright version. Two static functions are available that return the bright or dark color number corresponding to a given color index. If these variants don’t already exist, they are created as needed:; Int_t dark = TColor::GetColorDark(color_index);; Int_t bright = TColor::GetColorBright(color_index);; The dark and bright colors are used to give 3-D effects when drawing various boxes (see TWbox, TPave, TPaveText, TPaveLabel, etc). If you have a black and white copy of the manual, here are the basic colors and their indices. The basic ROOT colors. The list of currently supported basic colors (here dark and bright colors are not shown) are shown. The color numbers specified in the basic palette, and the picture above, can be viewed by selecting the menu entry Colors in the View canvas menu. The user may define other colors. To do this, one has to build a new TColor:; TColor(Int_t color,Float_t r,Float_t g,Float_t b,const char* name); One has to give the color number and the three Red, Green, Blue values, each being defined from 0 (min) to 1(max). An optional na",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:365510,Availability,avail,available,365510,"he number of contours.; void palette() {; // Example of creating new colors (purples); const Int_t colNum = 10; // and defining of a new palette; Int_t palette[colNum];; for (Int_t i=0; i<colNum; i++) {; // get the color and if it does not exist create it; if (! gROOT->GetColor(230+i) ){; TColor *color =; new TColor(230+i,1-(i/((colNum)*1.0)),0.3,0.5,"""");; } else {; TColor *color = gROOT->GetColor(230+i);; color->SetRGB(1-(i/((colNum)*1.0)),0.3,0.5);; }; palette[i] = 230+i;; }; gStyle->SetPalette(colNum,palette);; TF2 *f2 = new TF2(""f2"",""exp(-(x^2)-(y^2))"",-3,3,-3,3);; // two contours less than the number of colors in palette; f2->SetContour(colNum-2);; f2->Draw(""cont"");; }; Since ROOT 6.26, you can also define a palette based on an ASCII text file, using TColor::CreateColorTableFromFile(""filename.txt"") or gStyle->SetPalette(""filename.txt""). The input file contains one color per line in “r g b” float format. This function is useful to profit from a full set of colour-vision deficiency friendly and perceptually uniform colour maps that are available to download; 9.7 The Graphics Editor; A new graphics editor took place in ROOT v4.0. The editor can be activated by selecting the Editor menu entry in the canvas View menu or one of the context menu entries for setting line, fill, marker or text attributes. The following object editors are available for the current ROOT version.; 9.7.1 TAxisEditor. This user interface gives the possibility for changing the following axis attributes:. color of the selected axis, the axis’ title and labels;; the length of thick parameters and the possibility to set them on both axis sides (if +- is selected);; to set logarithmic or linear scale along the selected axis with a choice for optimized or more logarithmic labels;; primary, secondary and tertiary axis divisions can be set via the three number fields;; the axis title can be added or edited and the title’s color, position, offset, size and font can be set interactively;; the color, si",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:365523,Availability,down,download,365523,"he number of contours.; void palette() {; // Example of creating new colors (purples); const Int_t colNum = 10; // and defining of a new palette; Int_t palette[colNum];; for (Int_t i=0; i<colNum; i++) {; // get the color and if it does not exist create it; if (! gROOT->GetColor(230+i) ){; TColor *color =; new TColor(230+i,1-(i/((colNum)*1.0)),0.3,0.5,"""");; } else {; TColor *color = gROOT->GetColor(230+i);; color->SetRGB(1-(i/((colNum)*1.0)),0.3,0.5);; }; palette[i] = 230+i;; }; gStyle->SetPalette(colNum,palette);; TF2 *f2 = new TF2(""f2"",""exp(-(x^2)-(y^2))"",-3,3,-3,3);; // two contours less than the number of colors in palette; f2->SetContour(colNum-2);; f2->Draw(""cont"");; }; Since ROOT 6.26, you can also define a palette based on an ASCII text file, using TColor::CreateColorTableFromFile(""filename.txt"") or gStyle->SetPalette(""filename.txt""). The input file contains one color per line in “r g b” float format. This function is useful to profit from a full set of colour-vision deficiency friendly and perceptually uniform colour maps that are available to download; 9.7 The Graphics Editor; A new graphics editor took place in ROOT v4.0. The editor can be activated by selecting the Editor menu entry in the canvas View menu or one of the context menu entries for setting line, fill, marker or text attributes. The following object editors are available for the current ROOT version.; 9.7.1 TAxisEditor. This user interface gives the possibility for changing the following axis attributes:. color of the selected axis, the axis’ title and labels;; the length of thick parameters and the possibility to set them on both axis sides (if +- is selected);; to set logarithmic or linear scale along the selected axis with a choice for optimized or more logarithmic labels;; primary, secondary and tertiary axis divisions can be set via the three number fields;; the axis title can be added or edited and the title’s color, position, offset, size and font can be set interactively;; the color, si",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:365811,Availability,avail,available,365811," } else {; TColor *color = gROOT->GetColor(230+i);; color->SetRGB(1-(i/((colNum)*1.0)),0.3,0.5);; }; palette[i] = 230+i;; }; gStyle->SetPalette(colNum,palette);; TF2 *f2 = new TF2(""f2"",""exp(-(x^2)-(y^2))"",-3,3,-3,3);; // two contours less than the number of colors in palette; f2->SetContour(colNum-2);; f2->Draw(""cont"");; }; Since ROOT 6.26, you can also define a palette based on an ASCII text file, using TColor::CreateColorTableFromFile(""filename.txt"") or gStyle->SetPalette(""filename.txt""). The input file contains one color per line in “r g b” float format. This function is useful to profit from a full set of colour-vision deficiency friendly and perceptually uniform colour maps that are available to download; 9.7 The Graphics Editor; A new graphics editor took place in ROOT v4.0. The editor can be activated by selecting the Editor menu entry in the canvas View menu or one of the context menu entries for setting line, fill, marker or text attributes. The following object editors are available for the current ROOT version.; 9.7.1 TAxisEditor. This user interface gives the possibility for changing the following axis attributes:. color of the selected axis, the axis’ title and labels;; the length of thick parameters and the possibility to set them on both axis sides (if +- is selected);; to set logarithmic or linear scale along the selected axis with a choice for optimized or more logarithmic labels;; primary, secondary and tertiary axis divisions can be set via the three number fields;; the axis title can be added or edited and the title’s color, position, offset, size and font can be set interactively;; the color, size, and offset of axis labels can be set similarly. In addition, there is a check box for no exponent choice, and another one for setting the same decimal part for all labels. 9.7.2 TPadEditor. It provides the following user interface:; Fixed aspect ratio - can be set for pad resizing.; Edit - sets pad or canvas as editable.; Cross-hair - sets a cross hair",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:389530,Availability,down,down,389530,"eful for obtaining a ‘real world’ views. The degree of foreshortening is affected by the current camera field of view (focal length of its ‘lens’) - see “Adjusting Cameras”.; Orthographic: Distance from camera does not affect object size. These projections are useful for measurement or checking alignments, as the sizes and angles between objects are preserved. You can select the active camera from the viewer’s Camera menu on the top menu bar. There are three perspective camera choices:. Perspective (Floor XOZ) Default; Perspective (Floor YOZ); Perspective (Floor XOY). In each case the perspective camera is constrained to keep the chosen floor plane, defined by a pair of world axes, appearing level at all times - i.e. there is no banking of the ‘horizon’ that you experience when a plane rolls. There are also three orthographic camera choices:. Orthographic (XOY); Orthographic (XOZ); Orthographic (ZOY). Orthographic projections are generally constrained to look down one of the global axes of the world, with the other two axes lying horizontal/vertical on the viewer window. Therefore, XOY has the X-axis horizontal, the Y-axis vertical. You can always confirm the orientation and constraints of the camera in the world by enabling axis drawing in the “Guides” tab - see sections “Guides” and “Clipping” below. For orthographic camera a ruler-depicting current scene units is also available.; You can also pick the current camera by obtaining a handle to the GL Viewer object behind the interface:; TGLViewer * v = (TGLViewer *)gPad->GetViewer3D();; calling the method TGLViewer::SetCurrentCamera with one of the TGLViewer::ECameraType types:; v->SetCurrentCamera(TGLViewer::kCameraPerspXOZ);; See also $ROOTSYS/tutorials/gl/glViewerExercise.C.; 9.13.2.2 Adjusting Cameras; The interactions with the camera are summarized above. In each case the interaction is listed, along with description and user actions required to achieve it. For all cameras you can reset the original default view",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:389950,Availability,avail,available,389950,"You can select the active camera from the viewer’s Camera menu on the top menu bar. There are three perspective camera choices:. Perspective (Floor XOZ) Default; Perspective (Floor YOZ); Perspective (Floor XOY). In each case the perspective camera is constrained to keep the chosen floor plane, defined by a pair of world axes, appearing level at all times - i.e. there is no banking of the ‘horizon’ that you experience when a plane rolls. There are also three orthographic camera choices:. Orthographic (XOY); Orthographic (XOZ); Orthographic (ZOY). Orthographic projections are generally constrained to look down one of the global axes of the world, with the other two axes lying horizontal/vertical on the viewer window. Therefore, XOY has the X-axis horizontal, the Y-axis vertical. You can always confirm the orientation and constraints of the camera in the world by enabling axis drawing in the “Guides” tab - see sections “Guides” and “Clipping” below. For orthographic camera a ruler-depicting current scene units is also available.; You can also pick the current camera by obtaining a handle to the GL Viewer object behind the interface:; TGLViewer * v = (TGLViewer *)gPad->GetViewer3D();; calling the method TGLViewer::SetCurrentCamera with one of the TGLViewer::ECameraType types:; v->SetCurrentCamera(TGLViewer::kCameraPerspXOZ);; See also $ROOTSYS/tutorials/gl/glViewerExercise.C.; 9.13.2.2 Adjusting Cameras; The interactions with the camera are summarized above. In each case the interaction is listed, along with description and user actions required to achieve it. For all cameras you can reset the original default view, framing the entire scene, by double clicking any mouse button. GL Viewer camera interactions. For the Zoom interaction you can use the following modifiers combinations to adjust the sensitivity:. Shiftx 10; Ctrlx 0.1; Shift + Ctrlx 0.01. The modifiers must be applied after the zoom action has started (right mouse button is down).; Note for orthographic camera",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:390884,Availability,down,down,390884,"tions “Guides” and “Clipping” below. For orthographic camera a ruler-depicting current scene units is also available.; You can also pick the current camera by obtaining a handle to the GL Viewer object behind the interface:; TGLViewer * v = (TGLViewer *)gPad->GetViewer3D();; calling the method TGLViewer::SetCurrentCamera with one of the TGLViewer::ECameraType types:; v->SetCurrentCamera(TGLViewer::kCameraPerspXOZ);; See also $ROOTSYS/tutorials/gl/glViewerExercise.C.; 9.13.2.2 Adjusting Cameras; The interactions with the camera are summarized above. In each case the interaction is listed, along with description and user actions required to achieve it. For all cameras you can reset the original default view, framing the entire scene, by double clicking any mouse button. GL Viewer camera interactions. For the Zoom interaction you can use the following modifiers combinations to adjust the sensitivity:. Shiftx 10; Ctrlx 0.1; Shift + Ctrlx 0.01. The modifiers must be applied after the zoom action has started (right mouse button is down).; Note for orthographic cameras:. There is no field of view of view/focal length - dollying and zooming producing an identical scaling action.; There is a fixed eye direction - so the ‘Orbit’ action is disabled. Note for perspective cameras:. Dollying (moving the camera backwards/forwards) and zooming are often confused, and may appear very similar.; When you dolly the camera the lens focal length does not change, hence the distortions associated with the projections are unaffected. However the movement can result in objects coming ‘through the front’ of the camera and disappearing.; When you zoom, the camera does not move - hence clipping of near objects is unaffected. However with extremely small zooms (FOV large/focal length short) noticeable distortions, causing straight lines to become curved, can be seen with objects near the camera - the ‘fisheye’ lens effect.; Generally dollying is more ‘natural’, but you may need to use both to ac",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:400365,Availability,avail,available,400365,"ll description of OpenGL materials, colors and lighting is beyond the scope of this document. You should refer to the OpenGL programming manual (Red Book) for a full discussion. In most cases adjustment of the Diffuse color material + Opacity/Shine properties is sufficient to achieve desired results.; A shape has four-color materials (components):. Diffuse; Ambient; Specular; Emissive. For each of these you can select the component via the radio buttons. Each component can have the red, green and blue values for the component adjusted via the sliders. You can apply this adjustment to the shape itself, or to all shapes sharing a common ‘family’. Shapes of the same family have external objects with the same TObject name string. You can also adjust the ‘Opacity’ and ‘Shine’ for the shapes materials via the sliders.; 9.13.2.11 Geometry; Viewer Controls Pane ‘Geometry’ tab.; Review and modify the shapes X/Y/Z center and scaling factors via the edit boxes. Selection and editing of shapes is not available via the API at present.; 9.13.2.12 Outputting Viewer Contents; The current viewer rendering can be output to an external EPS or PDF, using the options under the ‘File’ menu on the top menu bar. The file is named ‘viewer.eps’ or ‘viewer.pdf’ and written to the current ROOT directory.; 9.13.3 The X3D Viewer; The X3D viewer is a fairly simple and limited viewer, capable of showing basic lines and polygons. It lacks the quality, performance and more advanced features of the GL Viewer, and additionally is not supported on Windows. It is not actively developed and you are encouraged to use the GL Viewer out of preference. The below table presents the main interactions - these are repeated in the Help dialog of the viewer.; Action KeyActionKey; Wireframe Mode wRotate about xx a; Hidden Line Mode eRotate about yy b; Hidden Surface Mode rRotate about zz c; Move object down uAuto-rotate about x1 2 3; Move object up iAuto-rotate about y4 5 6; Move object left lAuto-rotate about z7 8 ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:401247,Availability,down,down,401247,"shapes is not available via the API at present.; 9.13.2.12 Outputting Viewer Contents; The current viewer rendering can be output to an external EPS or PDF, using the options under the ‘File’ menu on the top menu bar. The file is named ‘viewer.eps’ or ‘viewer.pdf’ and written to the current ROOT directory.; 9.13.3 The X3D Viewer; The X3D viewer is a fairly simple and limited viewer, capable of showing basic lines and polygons. It lacks the quality, performance and more advanced features of the GL Viewer, and additionally is not supported on Windows. It is not actively developed and you are encouraged to use the GL Viewer out of preference. The below table presents the main interactions - these are repeated in the Help dialog of the viewer.; Action KeyActionKey; Wireframe Mode wRotate about xx a; Hidden Line Mode eRotate about yy b; Hidden Surface Mode rRotate about zz c; Move object down uAuto-rotate about x1 2 3; Move object up iAuto-rotate about y4 5 6; Move object left lAuto-rotate about z7 8 9; Move object right hToggle controls styleo; Move object forward jToggle stereo displays; Move object backward kToggle blue stereo viewd; Adjust focus (stereo mode) [ ] { }Toggle double bufferf; Rotate object Left mouse button down + move.; 9.13.4 Common 3D Viewer Architecture; The 3D Viewer Architecture provides a common mechanism for viewer clients to publish 3D objects to it. It enables:. Decoupling of producers (geometry packages etc) who model collection of 3D objects from consumers (viewers) which display them.; Producer code free of explicit drawing commands & viewer specific branching.; Support differing viewers and clients capabilities, e.g.; Mix of native (in viewer) shapes and generic client side tessellation.; Local/global frame object description; Bounding boxes; Placing copies sharing common geometry (logical/physical shapes). The architecture consists of:. TVirtualViewer3D interface: An abstract handle to the viewer, allowing client to add objects, test prefe",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:401590,Availability,down,down,401590,"shapes is not available via the API at present.; 9.13.2.12 Outputting Viewer Contents; The current viewer rendering can be output to an external EPS or PDF, using the options under the ‘File’ menu on the top menu bar. The file is named ‘viewer.eps’ or ‘viewer.pdf’ and written to the current ROOT directory.; 9.13.3 The X3D Viewer; The X3D viewer is a fairly simple and limited viewer, capable of showing basic lines and polygons. It lacks the quality, performance and more advanced features of the GL Viewer, and additionally is not supported on Windows. It is not actively developed and you are encouraged to use the GL Viewer out of preference. The below table presents the main interactions - these are repeated in the Help dialog of the viewer.; Action KeyActionKey; Wireframe Mode wRotate about xx a; Hidden Line Mode eRotate about yy b; Hidden Surface Mode rRotate about zz c; Move object down uAuto-rotate about x1 2 3; Move object up iAuto-rotate about y4 5 6; Move object left lAuto-rotate about z7 8 9; Move object right hToggle controls styleo; Move object forward jToggle stereo displays; Move object backward kToggle blue stereo viewd; Adjust focus (stereo mode) [ ] { }Toggle double bufferf; Rotate object Left mouse button down + move.; 9.13.4 Common 3D Viewer Architecture; The 3D Viewer Architecture provides a common mechanism for viewer clients to publish 3D objects to it. It enables:. Decoupling of producers (geometry packages etc) who model collection of 3D objects from consumers (viewers) which display them.; Producer code free of explicit drawing commands & viewer specific branching.; Support differing viewers and clients capabilities, e.g.; Mix of native (in viewer) shapes and generic client side tessellation.; Local/global frame object description; Bounding boxes; Placing copies sharing common geometry (logical/physical shapes). The architecture consists of:. TVirtualViewer3D interface: An abstract handle to the viewer, allowing client to add objects, test prefe",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:429126,Availability,recover,recovery,429126,">Add(run);; The first parameter of the Add method is a pointer to a TTask, the second parameter is the string to show in the browser. If the string is left out, the name of the task is used.; After executing, the script above the browser will look like in this figure.; 10.5 Execute and Debug Tasks; The browser can be used to start a task, set break points at the beginning of a task or when the task has completed. At a breakpoint, data structures generated by the execution up this point may be inspected asynchronously and then the execution can be resumed by selecting the “Continue” function of a task.; A task may be active or inactive (controlled by TTask::SetActive). When a task is inactive, its sub tasks are not executed. A task tree may be made persistent, saving the status of all the tasks.; 11 Input/Output. This chapter covers the saving and reading of objects to and from ROOT files. It begins with an explanation of the physical layout of a ROOT file. It includes a discussion on compression, and file recovery. Then we explain the logical file, the class TFile and its methods. We show how to navigate in a file, how to save objects and read them back. We also include a discussion on Streamers. Streamers are the methods responsible to capture an objects current state to save it to disk or send it over the network. At the end of the chapter is a discussion on the two specialized ROOT files: TNetFile and TWebFile.; 11.1 The Physical Layout of ROOT Files; A ROOT file is like a UNIX file directory. It can contain directories and objects organized in unlimited number of levels. It also is stored in machine independent format (ASCII, IEEE floating point, Big Endian byte ordering). To look at the physical layout of a ROOT file, we first create one. This example creates a ROOT file and 15 histograms, fills each histogram with 1000 entries from a Gaussian distribution, and writes them to the file.; {; char name[10], title[20];; TObjArray Hlist(0); // create an array of His",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:433966,Availability,avail,available,433966,"1->28]; fSeekFree; Pointer to FREE data record. 21 -> 24 [29->32]; fNbytesFree; Number of bytes in FREE data record. 25 -> 28 [33->36]; nfree; Number of free data records. 29 -> 32 [37->40]; fNbytesName; Number of bytes in TNamed at creation time. 33 -> 33 [41->41]; fUnits; Number of bytes for file pointers. 34 -> 37 [42->45]; fCompress; Zip compression level. 38 -> 41 [46->53]; fSeekInfo; Pointer to TStreamerInfo record. 42 -> 45 [54->57]; fNBytesInfo; Number of bytes in TStreamerInfo record. 46 -> 63 [58->75]; fCompress; Universal Unique ID. The first four bytes of the file header contain the string “root” which identifies a file as a ROOT file. Because of this identifier, ROOT is not dependent on the “.root” extension. It is still a good idea to use the extension, just for us to recognize them easier. The nfree and value is the number of free records. This variable along with FNBytesFree keeps track of the free space in terms of records and bytes. This count also includes the deleted records, which are available again.; 11.1.2 The Top Directory Description; The 84 bytes after the file header contain the top directory description, including the name, the date and time it was created, and the date and time of the last modification.; 20010404/092347 At:64 N=84 TFile; 11.1.3 The Histogram Records; What follows are the 15 histograms, in records of variable length.; 20010404/092347 At:148 N=380 TH1F CX = 2.49; 20010404/092347 At:528 N=377 TH1F CX = 2.51; The first 4 bytes of each record is an integer holding the number of bytes in this record. A negative number flags the record as deleted, and makes the space available for recycling in the next writing. The rest of bytes in the header contain all the information to identify uniquely a data block on the file. It is followed by the object data.; The next table explains the values in each individual record. If the key is located past the 32 bit file limit (> 2 GB) then some fields will be 8 bytes instead of 4 bytes (values",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:434579,Availability,avail,available,434579,"identifies a file as a ROOT file. Because of this identifier, ROOT is not dependent on the “.root” extension. It is still a good idea to use the extension, just for us to recognize them easier. The nfree and value is the number of free records. This variable along with FNBytesFree keeps track of the free space in terms of records and bytes. This count also includes the deleted records, which are available again.; 11.1.2 The Top Directory Description; The 84 bytes after the file header contain the top directory description, including the name, the date and time it was created, and the date and time of the last modification.; 20010404/092347 At:64 N=84 TFile; 11.1.3 The Histogram Records; What follows are the 15 histograms, in records of variable length.; 20010404/092347 At:148 N=380 TH1F CX = 2.49; 20010404/092347 At:528 N=377 TH1F CX = 2.51; The first 4 bytes of each record is an integer holding the number of bytes in this record. A negative number flags the record as deleted, and makes the space available for recycling in the next writing. The rest of bytes in the header contain all the information to identify uniquely a data block on the file. It is followed by the object data.; The next table explains the values in each individual record. If the key is located past the 32 bit file limit (> 2 GB) then some fields will be 8 bytes instead of 4 bytes (values between the brackets):. Byte; Value Name; Description. 1 -> 4; Nbytes; Length of compressed object (in bytes). 5 -> 6; Version; TKey version identifier. 7 -> 10; ObjLen; Length of uncompressed object. 11 -> 14; Datime; Date and time when object was written to file. 15 -> 16; KeyLen; Length of the key structure (in bytes). 17 -> 18; Cycle; Cycle of key. 19 -> 22 [19->26]; SeekKey; Pointer to record itself (consistency check). 23 -> 26 [27->34]; SeekPdir; Pointer to directory header. 27 -> 27 [35->35]; lname; Number of bytes in the class name. 28 -> … [36->..; .] | ClassName; | Object Class Name. … -> …; | lname; |",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:440420,Availability,recover,recover,440420,"e last three entries on the output of TFile::Map() are the list of keys, the list of free segments, and the address where the data ends.. When a file is closed, it writes a linked list of keys at the end of the file. This is what we see in the third to the last entry. In our example, the list of keys is stored in 732 bytes beginning at byte# 8244.; 20010404/092347 At:8244 N=732 KeysList; 20010404/092347 At:8976 N=53 FreeSegments; 20010404/092347 At:9029 N=1 END; The second to last entry is a list of free segments. In our case, this starts 8976 and is not very long, only 53 bytes, since we have not deleted any objects. The last entry is the address of the last byte in the file.; 11.1.6 File Recovery; A file may become corrupted or it may be impossible to write it to disk and close it properly. For example if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:440518,Availability,recover,recovery,440518,"address where the data ends.. When a file is closed, it writes a linked list of keys at the end of the file. This is what we see in the third to the last entry. In our example, the list of keys is stored in 732 bytes beginning at byte# 8244.; 20010404/092347 At:8244 N=732 KeysList; 20010404/092347 At:8976 N=53 FreeSegments; 20010404/092347 At:9029 N=1 END; The second to last entry is a list of free segments. In our case, this starts 8976 and is not very long, only 53 bytes, since we have not deleted any objects. The last entry is the address of the last byte in the file.; 11.1.6 File Recovery; A file may become corrupted or it may be impossible to write it to disk and close it properly. For example if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:440547,Availability,redundant,redundant,440547,"address where the data ends.. When a file is closed, it writes a linked list of keys at the end of the file. This is what we see in the third to the last entry. In our example, the list of keys is stored in 732 bytes beginning at byte# 8244.; 20010404/092347 At:8244 N=732 KeysList; 20010404/092347 At:8976 N=53 FreeSegments; 20010404/092347 At:9029 N=1 END; The second to last entry is a list of free segments. In our case, this starts 8976 and is not very long, only 53 bytes, since we have not deleted any objects. The last entry is the address of the last byte in the file.; 11.1.6 File Recovery; A file may become corrupted or it may be impossible to write it to disk and close it properly. For example if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:440744,Availability,recover,recovery,440744,":8244 N=732 KeysList; 20010404/092347 At:8976 N=53 FreeSegments; 20010404/092347 At:9029 N=1 END; The second to last entry is a list of free segments. In our case, this starts 8976 and is not very long, only 53 bytes, since we have not deleted any objects. The last entry is the address of the last byte in the file.; 11.1.6 File Recovery; A file may become corrupted or it may be impossible to write it to disk and close it properly. For example if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints informa",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:440947,Availability,recover,recovery,440947,"nly 53 bytes, since we have not deleted any objects. The last entry is the address of the last byte in the file.; 11.1.6 File Recovery; A file may become corrupted or it may be impossible to write it to disk and close it properly. For example if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, T",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:441132,Availability,recover,recovery,441132,"may become corrupted or it may be impossible to write it to disk and close it properly. For example if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, TFile keeps a list of TKeys, which is essentially an index to the objects in the file. The TKey class describes the record headers of objects i",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:441199,Availability,recover,recover,441199,"le if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, TFile keeps a list of TKeys, which is essentially an index to the objects in the file. The TKey class describes the record headers of objects in the file. For example, we can get the list of keys and print them. To find a specific object on ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:441261,Availability,recover,recovered,441261,"le if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, TFile keeps a list of TKeys, which is essentially an index to the objects in the file. The TKey class describes the record headers of objects in the file. For example, we can get the list of keys and print them. To find a specific object on ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:441510,Availability,recover,recovery,441510,"ible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, TFile keeps a list of TKeys, which is essentially an index to the objects in the file. The TKey class describes the record headers of objects in the file. For example, we can get the list of keys and print them. To find a specific object on the file we can use the TFile::Get() method.; root[] TFile f(""demo.root""); root[] f.GetListOfKeys()->Print(); TKey Name = h0, Title = histo nr:0, Cycle = 1; TKey Name = h1, Title = histo nr:1, Cycle = 1; TKey Name = h2, Title ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:441631,Availability,recover,recover,441631,"erly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, TFile keeps a list of TKeys, which is essentially an index to the objects in the file. The TKey class describes the record headers of objects in the file. For example, we can get the list of keys and print them. To find a specific object on the file we can use the TFile::Get() method.; root[] TFile f(""demo.root""); root[] f.GetListOfKeys()->Print(); TKey Name = h0, Title = histo nr:0, Cycle = 1; TKey Name = h1, Title = histo nr:1, Cycle = 1; TKey Name = h2, Title = histo nr:2, Cycle = 1; TKey Name = h3, Title = histo nr:3, Cycle = 1; TKey Name = h4, Title = histo nr:4, Cycle = 1; TKey Name = h5, Title = histo nr:5, Cycle = 1; TK",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:441652,Availability,recover,recovered,441652,"erly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, TFile keeps a list of TKeys, which is essentially an index to the objects in the file. The TKey class describes the record headers of objects in the file. For example, we can get the list of keys and print them. To find a specific object on the file we can use the TFile::Get() method.; root[] TFile f(""demo.root""); root[] f.GetListOfKeys()->Print(); TKey Name = h0, Title = histo nr:0, Cycle = 1; TKey Name = h1, Title = histo nr:1, Cycle = 1; TKey Name = h2, Title = histo nr:2, Cycle = 1; TKey Name = h3, Title = histo nr:3, Cycle = 1; TKey Name = h4, Title = histo nr:4, Cycle = 1; TKey Name = h5, Title = histo nr:5, Cycle = 1; TK",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:443399,Availability,avail,available,443399,", Cycle = 1; TKey Name = h2, Title = histo nr:2, Cycle = 1; TKey Name = h3, Title = histo nr:3, Cycle = 1; TKey Name = h4, Title = histo nr:4, Cycle = 1; TKey Name = h5, Title = histo nr:5, Cycle = 1; TKey Name = h6, Title = histo nr:6, Cycle = 1; TKey Name = h7, Title = histo nr:7, Cycle = 1; TKey Name = h8, Title = histo nr:8, Cycle = 1; TKey Name = h9, Title = histo nr:9, Cycle = 1; TKey Name = h10, Title = histo nr:10, Cycle = 1; TKey Name = h11, Title = histo nr:11, Cycle = 1; TKey Name = h12, Title = histo nr:12, Cycle = 1; TKey Name = h13, Title = histo nr:13, Cycle = 1; TKey Name = h14, Title = histo nr:14, Cycle = 1; root[] TH1F *h9 = (TH1F*)f.Get(""h9"");; The TFile::Get() finds the TKey object with name “h9”. Using the TKey info it will import in memory the object in the file at the file address #3352 (see the output from the TFile::Map above). This is done by the Streamer method that is covered in detail in a later section. Since the keys are available in a TList of TKeys we can iterate over the list of keys:; {; TFile f(""demo.root"");; TIter next(f.GetListOfKeys());; TKey *key;; while ((key=(TKey*)next())) {; printf(""key: %s points to an object of class: %s at %dn"",; key->GetName(),; key->GetClassName(),key->GetSeekKey());; }; }; The output of this script is:; root[] .x iterate.C; key: h0 points to an object of class: TH1F at 150; key: h1 points to an object of class: TH1F at 503; key: h2 points to an object of class: TH1F at 854; key: h3 points to an object of class: TH1F at 1194; key: h4 points to an object of class: TH1F at 1539; key: h5 points to an object of class: TH1F at 1882; key: h6 points to an object of class: TH1F at 2240; key: h7 points to an object of class: TH1F at 2582; key: h8 points to an object of class: TH1F at 2937; key: h9 points to an object of class: TH1F at 3293; key: h10 points to an object of class: TH1F at 3639; key: h11 points to an object of class: TH1F at 3986; key: h12 points to an object of class: TH1F at 4339; key: h13 poi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:460211,Availability,avail,available,460211,"a function such as in the code below, it will be deleted when it goes out of scope.; void foo() {; TFile f(""AFile.root"",""RECREATE"");; }; As soon as the function foohas finished executing, the variable f is deleted. When a TFile object is deleted an implicit call to TFile::Close is made. This will save only the file descriptor to disk. It contains the file header, the StreamerInfolist, the key list, the free segment list, and the end address. See “The Physical Layout of ROOT Files”. The TFile::Close does not make a call to Write(), which means that the objects in memory will not be saved in the file. You need to explicitly call TFile::Write() to save the object in memory to file before the exit of the function.; void foo() {; TFile f(""AFile.root"",""RECREATE"");; ... stuff ...; f.Write();; }; To prevent an object in a function from being deleted when it goes out of scope, you can create it on the heap instead of on the stack. This will create a TFile object f, that is available on a global scope, and it will still be available when exiting the function.; void foo() {; TFile *f = new TFile(""AFile.root"",""RECREATE"");; }; 11.2.9 Retrieving Objects from Disk; If you have a ROOT session running, please quit and start fresh.; We saw that multiple versions of an object with the same name could be in a ROOT file. In our example, we saved a modified histogram hpx to the file, which resulted in two hpx's uniquely identified by the cycle number: hpx;1 and hpx;2. The question is how we can retrieve the right version of hpx. When opening the file and using hpx, Cling retrieves the one with the highest cycle number. To read the hpx;1 into memory, rather than the hpx:2 we would get by default, we have to explicitly get it and assign it to a variable.; root[] TFile *f1 = new TFile(""hsimple.root""); root[] TH1F *hpx1; f1->GetObject(""hpx;1"",hpx); root[] hpx1->Draw(); 11.2.10 Subdirectories and Navigation; The TDirectory class lets you organize its contents into subdirectories, and TFile be",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:460261,Availability,avail,available,460261,"a function such as in the code below, it will be deleted when it goes out of scope.; void foo() {; TFile f(""AFile.root"",""RECREATE"");; }; As soon as the function foohas finished executing, the variable f is deleted. When a TFile object is deleted an implicit call to TFile::Close is made. This will save only the file descriptor to disk. It contains the file header, the StreamerInfolist, the key list, the free segment list, and the end address. See “The Physical Layout of ROOT Files”. The TFile::Close does not make a call to Write(), which means that the objects in memory will not be saved in the file. You need to explicitly call TFile::Write() to save the object in memory to file before the exit of the function.; void foo() {; TFile f(""AFile.root"",""RECREATE"");; ... stuff ...; f.Write();; }; To prevent an object in a function from being deleted when it goes out of scope, you can create it on the heap instead of on the stack. This will create a TFile object f, that is available on a global scope, and it will still be available when exiting the function.; void foo() {; TFile *f = new TFile(""AFile.root"",""RECREATE"");; }; 11.2.9 Retrieving Objects from Disk; If you have a ROOT session running, please quit and start fresh.; We saw that multiple versions of an object with the same name could be in a ROOT file. In our example, we saved a modified histogram hpx to the file, which resulted in two hpx's uniquely identified by the cycle number: hpx;1 and hpx;2. The question is how we can retrieve the right version of hpx. When opening the file and using hpx, Cling retrieves the one with the highest cycle number. To read the hpx;1 into memory, rather than the hpx:2 we would get by default, we have to explicitly get it and assign it to a variable.; root[] TFile *f1 = new TFile(""hsimple.root""); root[] TH1F *hpx1; f1->GetObject(""hpx;1"",hpx); root[] hpx1->Draw(); 11.2.10 Subdirectories and Navigation; The TDirectory class lets you organize its contents into subdirectories, and TFile be",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:480054,Availability,error,error,480054,"with a unique object identifier. The object identifier is unique for one I/O operation. If there is another pointer to the object in the same I/O operation, the first object is referenced i.e. it is not saved again. When reading the file, the object is rebuilt and the references recalculated. Streaming object pointers. In this way, the network of pointers and their objects is rebuilt and ready to use the same way it was used before it was persistent. If the pointer hold the address of an object which in embedded in another object (as opposed to being pointed to by a pointer), the object will be duplicate at read time. To avoid this, make the pointer a transient data member.; 11.4.2 Motivation for the TRef Class; If the object is split into several files or into several branches of one or more TTrees, standard C++ pointers cannot be used because each I/O operation will write the referenced objects, and multiple copies will exist. In addition, if the pointer is read before the referenced object, it is null and may cause a run time system error. To address these limitations, ROOT offers the TRef class.; TRef allows referencing an object in a different branch and/or in a different file. TRef also supports the complex situation where a TFile is updated multiple times on the same machine or a different machine. When a TRef is read before its referenced object, it is null. As soon as the referenced object is read, the TRef points to it. In addition, one can specify an action to be taken by TRef in the case it is read before its reference object (see“Action on Demand” below).; 11.4.3 Using TRef; A TRef is a lightweight object pointing to any TObject. This object can be used instead of normal C++ pointers in case:. The referenced object R and the pointer P are not written to the same file; P is read before R; R and P are written to different Tree branches. Below is a line from the example in $ROOTSYS/test/Event.cxx.; TRef fLastTrack; //pointer to last track; ...; Track *trac",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:505954,Availability,avail,available,505954,"g lines should be added to the read part of the Streamer:; if (R__v > 1) R__b >> fNew;; else fNew = 0; // set to some default value; If, in the same new version 2 you remove the member fH, you must add the following code to read the histogram object into some temporary object and delete it:; if (R__v) < 2 {; TH1F *dummy = 0;; R__b >> dummy;; delete dummy;; }; Our experience with manual schema evolution shows that it is easy to make and mismatches between Streamer writers and readers are frequent and increase as the number of classes increase. We recommend you use rootcling generated Streamers whenever you can, and profit from the automatic schema evolution.; 11.5.8 Building Class Definitions with the StreamerInfo; A ROOT file’s StreamerInfolist contains the description of all versions of all classes in the file. When a file is opened the StreamerInfois read into memory and it provides enough information to make the file browsable. The TStreamerInfoenables us to recreate a header file for the class in case the compiled class is not available. This is done with the TFile::MakeProject method. It creates a directory with the header files for the named classes and a makefile to compile a shared library with the class definitions.; 11.5.9 Example: MakeProject; To explain the details, we use the example of the ATLFast project that is a fast simulation for the ATLAS experiment. The complete source for ATLFast can be down loaded at ftp://root.cern.ch/root/atlfast.tar.gz. Once we compile and run ATLFast we get a ROOT file called atlfast.root, containing the ATLFast objects. When we open the file, we get a warning that the file contains classes that are not in the dictionary. This is correct since we did not load the class definitions.; root[] TFile f(""atlfast.root""); Warning in <TClass::TClass>: no dictionary for class TMCParticle is available; Warning in <TClass::TClass>: no dictionary for class ATLFMuon available; We can see the StreamerInfofor the classes:; root[] f.ShowStr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:506339,Availability,down,down,506339,"sy to make and mismatches between Streamer writers and readers are frequent and increase as the number of classes increase. We recommend you use rootcling generated Streamers whenever you can, and profit from the automatic schema evolution.; 11.5.8 Building Class Definitions with the StreamerInfo; A ROOT file’s StreamerInfolist contains the description of all versions of all classes in the file. When a file is opened the StreamerInfois read into memory and it provides enough information to make the file browsable. The TStreamerInfoenables us to recreate a header file for the class in case the compiled class is not available. This is done with the TFile::MakeProject method. It creates a directory with the header files for the named classes and a makefile to compile a shared library with the class definitions.; 11.5.9 Example: MakeProject; To explain the details, we use the example of the ATLFast project that is a fast simulation for the ATLAS experiment. The complete source for ATLFast can be down loaded at ftp://root.cern.ch/root/atlfast.tar.gz. Once we compile and run ATLFast we get a ROOT file called atlfast.root, containing the ATLFast objects. When we open the file, we get a warning that the file contains classes that are not in the dictionary. This is correct since we did not load the class definitions.; root[] TFile f(""atlfast.root""); Warning in <TClass::TClass>: no dictionary for class TMCParticle is available; Warning in <TClass::TClass>: no dictionary for class ATLFMuon available; We can see the StreamerInfofor the classes:; root[] f.ShowStreamerInfo(); ...; StreamerInfo for class: ATLFMuon, version=1; BASE TObject offset= 0 type=66 Basic ROOT object; BASE TAtt3D offset= 0 type= 0 3D attributes; Int_t m_KFcode offset= 0 type= 3 Muon KF-code; Int_t m_MCParticle offset= 0 type= 3 Muon position in MCParticles list; Int_t m_KFmother offset= 0 type= 3 Muon mother KF-code; Int_t m_UseFlag offset= 0 type= 3 Muon energy usage flag; Int_t m_Isolated offset= 0 type= ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:506763,Availability,avail,available,506763,"t provides enough information to make the file browsable. The TStreamerInfoenables us to recreate a header file for the class in case the compiled class is not available. This is done with the TFile::MakeProject method. It creates a directory with the header files for the named classes and a makefile to compile a shared library with the class definitions.; 11.5.9 Example: MakeProject; To explain the details, we use the example of the ATLFast project that is a fast simulation for the ATLAS experiment. The complete source for ATLFast can be down loaded at ftp://root.cern.ch/root/atlfast.tar.gz. Once we compile and run ATLFast we get a ROOT file called atlfast.root, containing the ATLFast objects. When we open the file, we get a warning that the file contains classes that are not in the dictionary. This is correct since we did not load the class definitions.; root[] TFile f(""atlfast.root""); Warning in <TClass::TClass>: no dictionary for class TMCParticle is available; Warning in <TClass::TClass>: no dictionary for class ATLFMuon available; We can see the StreamerInfofor the classes:; root[] f.ShowStreamerInfo(); ...; StreamerInfo for class: ATLFMuon, version=1; BASE TObject offset= 0 type=66 Basic ROOT object; BASE TAtt3D offset= 0 type= 0 3D attributes; Int_t m_KFcode offset= 0 type= 3 Muon KF-code; Int_t m_MCParticle offset= 0 type= 3 Muon position in MCParticles list; Int_t m_KFmother offset= 0 type= 3 Muon mother KF-code; Int_t m_UseFlag offset= 0 type= 3 Muon energy usage flag; Int_t m_Isolated offset= 0 type= 3 Muon isolation (1 for isolated); Float_t m_Eta offset= 0 type= 5 Eta coordinate; Float_t m_Phi offset= 0 type= 5 Phi coordinate; Float_t m_PT offset= 0 type= 5 Transverse energy; Int_t m_Trigger offset= 0 type= 3 Result of trigger...; However, when we try to use a specific class we get a warning because the class is not in the dictionary. We can create a class using gROOT->GetClass() which makes a fake class from the StreamerInfo.; // Build a 'fake' class;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:506836,Availability,avail,available,506836,"t provides enough information to make the file browsable. The TStreamerInfoenables us to recreate a header file for the class in case the compiled class is not available. This is done with the TFile::MakeProject method. It creates a directory with the header files for the named classes and a makefile to compile a shared library with the class definitions.; 11.5.9 Example: MakeProject; To explain the details, we use the example of the ATLFast project that is a fast simulation for the ATLAS experiment. The complete source for ATLFast can be down loaded at ftp://root.cern.ch/root/atlfast.tar.gz. Once we compile and run ATLFast we get a ROOT file called atlfast.root, containing the ATLFast objects. When we open the file, we get a warning that the file contains classes that are not in the dictionary. This is correct since we did not load the class definitions.; root[] TFile f(""atlfast.root""); Warning in <TClass::TClass>: no dictionary for class TMCParticle is available; Warning in <TClass::TClass>: no dictionary for class ATLFMuon available; We can see the StreamerInfofor the classes:; root[] f.ShowStreamerInfo(); ...; StreamerInfo for class: ATLFMuon, version=1; BASE TObject offset= 0 type=66 Basic ROOT object; BASE TAtt3D offset= 0 type= 0 3D attributes; Int_t m_KFcode offset= 0 type= 3 Muon KF-code; Int_t m_MCParticle offset= 0 type= 3 Muon position in MCParticles list; Int_t m_KFmother offset= 0 type= 3 Muon mother KF-code; Int_t m_UseFlag offset= 0 type= 3 Muon energy usage flag; Int_t m_Isolated offset= 0 type= 3 Muon isolation (1 for isolated); Float_t m_Eta offset= 0 type= 5 Eta coordinate; Float_t m_Phi offset= 0 type= 5 Phi coordinate; Float_t m_PT offset= 0 type= 5 Transverse energy; Int_t m_Trigger offset= 0 type= 3 Result of trigger...; However, when we try to use a specific class we get a warning because the class is not in the dictionary. We can create a class using gROOT->GetClass() which makes a fake class from the StreamerInfo.; // Build a 'fake' class;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:515858,Availability,failure,failure,515858,"eral Open Function of TFile; To make life simple we provide a general function to open any type of file (except shared memory files of class TMapFile). This functionality is provided by the static TFile::Open() function:; TFile *TFile::Open(const Text_t *name,Option_t *option="""",; const Text_t *title="""",Int_t compress,Int_t netopt); Depending on the name argument, the function returns a TFile or one of its derivations, for example a TNetXNGFile or a TDavixFile object. In case a URL specifies a local file, a TFile object will be returned (and of course no login information is needed). The arguments of the Open() function are the same as the ones for the TFile constructor.; Using ReOpen() method it is possible to reopen a file with a different access mode, like from READ to UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the mode argument can be either “READ” or “UPDATE”. The method returns:. 0 in case the mode was successfully modified;; 1 in case the mode did not change (it was already as requested or there were wrong input arguments);; -1 in case of failure. In the last case the file cannot be used anymore. 11.7 Remotely Access to ROOT Files; ROOT files can be accessed remotely in many ways, on the base of the protocol URL. Among the most popular are XRootD (protocols ‘root://’ and ‘xrd://’) and a Web server (protocl ‘http://’ or ‘https://’).; The rootd daemon is deprecated and has been removed in version 6.16/00.; Please refer to the XRootD documentation for starting and ensuring that such a daemon is running.; Reading and writing ROOT files over the net can be done by creating a TFile object using the static method TFile::Open() object. This will instantiate the appropriate derivation of TFile to handle the request. Inheriting from the TFile class, the returned instance will have exactly the same interface and behavior of TFile. The only difference is that it reads and writes from a remote service. In the example below the file is read via a web server",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:529234,Availability,echo,echoed,529234,"stogram; NOTE that just double clicking a leaf will not produce a record: the histogram must be produced when clicking the DRAW button on the bottom-left. The records will appear on the list of records in the bottom right of the tree viewer. Selecting a record will draw the corresponding histogram. Records can be played using the arrow buttons near to the record button. When saving the session, the list of records is being saved as well.; Records have a default name corresponding to the Z: Y: X selection, but this can be changed using SetRecordName() method from the right panel context menu. You can create a new expression by right clicking on any of theE() boxes. The expression can be dragged and dropped into any of the boxes (X, Y, Z, Cut, or Scan). To scan one or more variables, drop them into the Scan box, then double click on the box. You can also redirect the result of the scan to a file by checking the Scan box on top. When the “Rec” box is checked, the Draw and Scan commands are recorded in the history file and echoed on the command line. The “Histogram” text box contains the name of the resulting histogram. By default it is htemp. You can type any name, if the histogram does not exist it will create one. The Option text box contains the list of Draw options. See “Draw Options”. You can select the options with the Options menu. The Command box lets you enter any command that you could also enter on the command line. The vertical slider on the far left side can be used to select the minimum and maximum of an event range. The actual start and end index are shown in on the bottom in the status window.; There is an extensive help utility accessible with the Help menu. The IList and OList are to specify an input list of entry indices and a name for the output list respectively. Both need to be of type TList and contain integers of entry indices. These lists are described below in the paragraph “Error! Reference source not found.”. A couple of graphs. The first one",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:532179,Availability,recover,recover,532179,"t this is a folder not just the title. You fill the tree by placing the data into the folder structure and calling TTree::Fill.; 12.7.2 Tree and TRef Objects; MyTree->BranchRef();; This call requests the construction of an optional branch supporting table of references (TRefTable). This branch (TBranchRef) will keep all the information needed to find the branches containing referenced objects at each Tree::Fill, the branch numbers containing the referenced objects are saved in the table of references. When the Tree header is saved (via TTree::Write for example), the branch is saved, keeping the information with the pointers to the branches having referenced objects. Enabling this optional table, allow TTree::Draw to automatically load the branches needed to dereference a TRef (or TRefArray) object.; 12.7.3 Autosave; Autosave gives the option to save all branch buffers every n byte. We recommend using Autosave for large acquisitions. If the acquisition fails to complete, you can recover the file and all the contents since the last Autosave. To set the number of bytes between Autosave you can use the TTree::SetAutosave() method. You can also call TTree::Autosave in the acquisition loop every nentry.; 12.7.4 Trees with Circular Buffers; When a TTree is memory resident, you set it up so that it retains retain only the last few entries. For example, this can be very useful for monitoring purpose.; void TTree::SetCircular(Long64_t maxEntries);; where maxEntries is the maximum number of entries to be kept in the buffers. When the number of entries exceeds this value, the first entries in the Tree are deleted and the buffers used again. An example of a script using a circular buffer is shown below:; void circular() {; gROOT->cd(); //make sure that the Tree is memory resident; TTree *T = new TTree(""T"",""test circular buffers"");; TRandom r;; Float_t px,py,pz;; Double_t random;; UShort_t i;; T->Branch(""px"",&px,""px/F"");; T->Branch(""py"",&py,""py/F"");; T->Branch(""pz"",&pz,""pz/F"");; T",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:536354,Availability,failure,failure,536354,"the TTree::GetEntryWithIndex(majornumber, minornumber) one entry can be retrieved. Example:; // to create an index using leaves Run and Event; tree.BuildIndex(""Run"",""Event"");; // to read entry corresponding to Run=1234 and Event=56789; tree.GetEntryWithIndex(1234,56789);; Note that majorname and minorname may be expressions using original tree variables e.g.: “run-90000”, “event +3*xx”. In case an expression is specified, the equivalent expression must be computed when calling GetEntryWithIndex(). To build an index with only majorname, specify minorname=""0"" (default).; Note that once the index is built, it can be saved with the TTree object with:; tree.Write(); //if the file has been open in ""update"" mode; The most convenient place to create the index is at the end of the filling process just before saving the tree header. If a previous index was computed, it is redefined by this new call.; Note that this function can also be applied to a TChain. The return value is the number of entries in the Index (< 0 indicates failure).; 12.8 Branches; The organization of branches allows the designer to optimize the data for the anticipated use. The class for a branch is called TBranch. If two variables are independent, and the designer knows the variables will not be used together, they should be placed on separate branches. If, however, the variables are related, such as the coordinates of a point, it is most efficient to create one branch with both coordinates on it. A variable on a TBranch is called a leaf (yes - TLeaf). Another point to keep in mind when designing trees is that branches of the same TTree can be written to separate files. To add a TBranch to a TTree we call the method TTree::Branch(). Note that we DO NOT use the TBranch constructor.; The TTree::Branch method has several signatures. The branch type differs by what is stored in it. A branch can hold an entire object, a list of simple variables, contents of a folder, contents of a TList, or an array of objects",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:558580,Availability,avail,available,558580,"pointer TClonesArray *fTracks in the $ROOTSYS/test/Event example). If “->” is not specified, the pointer member is read via buf >> pointer. In this case the pointer may be null. Note that the option with “->” is faster to read or write and it also consumes less space in the file.; Option 2 - the option AutoDelete is set:; TBranch *branch = T.GetBranch(""event"");; branch->SetAddress(&event);; branch->SetAutoDelete(kTRUE);; for (Int_t i=0; i<nentries; i++) {; T.GetEntry(i); // the object event has been filled at this point; }; At any iteration, the GetEntry deletes the object event and a new instance of Event is created and filled.; Option 3 - same as option 1, but you delete the event yourself:; for (Int_t i=0; i<nentries; i++) {; delete event;; event = 0; //EXTREMELY IMPORTANT; T.GetEntry(i);; // the objrect event has been filled at this point; }; It is strongly recommended to use the default option 1. It has the additional advantage that functions like TTree::Draw (internally calling TTree::GetEntry) will be functional even when the classes in the file are not available. Reading selected branches is quicker than reading an entire entry. If you are interested in only one branch, you can use the TBranch::GetEntry method and only that branch is read. Here is the script tree1r:; void tree1r(){; // read the Tree generated by tree1w and fill two histograms; // note that we use ""new"" to create the TFile and TTree objects,; // to keep them alive after leaving this function.; TFile *f = new TFile(""tree1.root"");; TTree *t1 = (TTree*)f->Get(""t1"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1->SetBranchAddress(""px"",&px);; t1->SetBranchAddress(""py"",&py);; t1->SetBranchAddress(""pz"",&pz);; t1->SetBranchAddress(""random"",&random);; t1->SetBranchAddress(""ev"",&ev);; // create two histograms; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-3,3);; TH2F *hpxpy = new TH2F(""hpxpy"",""py vs px"",30,-3,3,30,-3,3);; //read all entries and fill the histograms; Int_t nentries = (Int_t)t1",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:558959,Availability,alive,alive,558959,"dress(&event);; branch->SetAutoDelete(kTRUE);; for (Int_t i=0; i<nentries; i++) {; T.GetEntry(i); // the object event has been filled at this point; }; At any iteration, the GetEntry deletes the object event and a new instance of Event is created and filled.; Option 3 - same as option 1, but you delete the event yourself:; for (Int_t i=0; i<nentries; i++) {; delete event;; event = 0; //EXTREMELY IMPORTANT; T.GetEntry(i);; // the objrect event has been filled at this point; }; It is strongly recommended to use the default option 1. It has the additional advantage that functions like TTree::Draw (internally calling TTree::GetEntry) will be functional even when the classes in the file are not available. Reading selected branches is quicker than reading an entire entry. If you are interested in only one branch, you can use the TBranch::GetEntry method and only that branch is read. Here is the script tree1r:; void tree1r(){; // read the Tree generated by tree1w and fill two histograms; // note that we use ""new"" to create the TFile and TTree objects,; // to keep them alive after leaving this function.; TFile *f = new TFile(""tree1.root"");; TTree *t1 = (TTree*)f->Get(""t1"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1->SetBranchAddress(""px"",&px);; t1->SetBranchAddress(""py"",&py);; t1->SetBranchAddress(""pz"",&pz);; t1->SetBranchAddress(""random"",&random);; t1->SetBranchAddress(""ev"",&ev);; // create two histograms; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-3,3);; TH2F *hpxpy = new TH2F(""hpxpy"",""py vs px"",30,-3,3,30,-3,3);; //read all entries and fill the histograms; Int_t nentries = (Int_t)t1->GetEntries();; for (Int_t i=0; i<nentries; i++) {; t1->GetEntry(i);; hpx->Fill(px);; hpxpy->Fill(px,py);; }; // We do not close the file. We want to keep the generated; // histograms we open a browser and the TreeViewer; if (gROOT->IsBatch()) return;; new TBrowser ();; t1->StartViewer();. //In the browser, click on ""ROOT Files"", then on ""tree1.root""; //You can click on the ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:566810,Availability,alive,alive,566810,"he variable nmec is a random number and is reset for each entry.; gstep.nmec = (Int_t)(5*gRandom->Rndm());; 12.15.1.3 Filling the Tree; In this emulation of Geant3, we generate and transport particles in a magnetic field and store the particle parameters at each tracking step in a ROOT tree.; 12.15.2 Analysis; In this analysis, we do not read the entire entry we only read one branch. First, we set the address for the branch to the file dstep, and then we use the TBranch::GetEntry method. Then we fill a histogram with the dstep branch entries, draw it and fit it with a Gaussian. In addition, we draw the particle’s path using the three values in the vector. Here we use the TTree::Draw method. It automatically creates a histogram and plots the 3 expressions (see Trees in Analysis). void tree2r() {. // read the Tree generated by tree2w and fill one histogram; // we are only interested by the destep branch. // note that we use ""new"" to create the TFile and TTree objects because we; // want to keep these objects alive when we leave this function; TFile *f = new TFile(""tree2.root"");; TTree *t2 = (TTree*)f->Get(""t2"");; static Float_t destep;; TBranch *b_destep = t2->GetBranch(""destep"");; b_destep->SetAddress(&destep);. //create one histogram; TH1F *hdestep = new TH1F(""hdestep"",""destep in Mev"",100,1e-5,3e-5);; //read only the destep branch for all entries; Int_t nentries = (Int_t)t2->GetEntries();; for (Int_t i=0;i<nentries;i++) {; b_destep->GetEntry(i);; // fill the histogram with the destep entry; hdestep->Fill(destep);; }. // we do not close the file; we want to keep the generated histograms;; // we fill a 3-d scatter plot with the particle step coordinates; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,800);; c1->SetFillColor(42);; c1->Divide(1,2);. c1->cd(1);; hdestep->SetFillColor(45);; hdestep->Fit(""gaus"");. c1->cd(2);; gPad->SetFillColor(37); // continued...; t2->SetMarkerColor(kRed);; t2->Draw(""vect[0]:vect[1]:vect[2]"");; if (gROOT->IsBatch()) return;. // invoke the x3d v",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:581021,Availability,alive,alive,581021," i1 < 4; i1++) {; event->SetMatrix(i0,i1,gRandom->Gaus(i0*i1,1));; }; }; // create and fill the Track objects; for (Int_t t = 0; t < ntrack; t++) event->AddTrack(random);; t4.Fill(); // Fill the tree; event->Clear(); // Clear before reloading event; }; f.Write(); // Write the file header; t4.Print(); // Print the tree contents; }; 12.17.5 Reading the Tree; First, we check if the shared library with the class definitions is loaded. If not we load it. Then we read two branches, one for the number of tracks and one for the entire event. We check the number of tracks first, and if it meets our condition, we read the entire event. We show the fist entry that meets the condition.; void tree4r() {; // check if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // read the tree generated with tree4w. // note that we use ""new"" to create the TFile and TTree objects, because we; // want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree4.root"");; TTree *t4 = (TTree*)f->Get(""t4"");. // create a pointer to an event object for reading the branch values.; Event *event = new Event();; // get two branches and set the branch address; TBranch *bntrack = t4->GetBranch(""fNtrack"");; TBranch *branch = t4->GetBranch(""event_split"");; branch->SetAddress(&event);. Int_t nevent = t4->GetEntries();; Int_t nselected = 0;; Int_t nb = 0;; for (Int_t i=0; i<nevent; i++) {; //read branch ""fNtrack""only; bntrack->GetEntry(i);. // reject events with more than 587 tracks; if (event->GetNtrack() > 587)continue;. // read complete accepted event in memory; nb += t4->GetEntry(i);; nselected++;. // print the first accepted event; if (nselected == 1) t4->Show();; // clear tracks array; event->Clear();; }. if (gROOT->IsBatch()) return;; new TBrowser();; t4->StartViewer();; }; Now, let’s see how the tree looks like in the tree viewer. The tree viewer with",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:583958,Availability,avail,available,583958," ascii file.; Long64_t TTree::ReadFile(const char *filename,; const char *branchDescriptor); Creates or simply read branches from the file named whose name is passed in 'filename'.; {; gROOT->Reset();; TFile *f = new TFile(""basic2.root"",""RECREATE"");; TH1F *h1 = new TH1F(""h1"",""x distribution"",100,-4,4);; TTree *T = new TTree(""ntuple"",""data from ascii file"");; Long64_t nlines = T->ReadFile(""basic.dat"",""x:y:z"");; printf("" found %lld pointsn"",nlines);; T->Draw(""x"",""z>2"");; T->Write();; }; If branchDescriptor is set to an empty string (the default), it is assumed that the Tree descriptor is given in the first line of the file with a syntax like: A/D:Table[2]/F:Ntracks/I:astring/C.; Otherwise branchDescriptor must be specified with the above syntax.Lines in the input file starting with “#” are ignored. A TBranch object is created for each variable in the expression. The total number of rows read from the file is returned.; 12.19 Trees in Analysis; The methods TTree::Draw, TTree::MakeClass and TTree::MakeSelector are available for data analysis using trees. The TTree::Draw method is a powerful yet simple way to look and draw the trees contents. It enables you to plot a variable (a leaf) with just one line of code. However, the Draw method falls short once you want to look at each entry and design more sophisticated acceptance criteria for your analysis. For these cases, you can use TTree::MakeClass. It creates a class that loops over the trees entries one by one. You can then expand it to do the logic of your analysis.; The TTree::MakeSelector is the recommended method for ROOT data analysis. It is especially important for large data set in a parallel processing configuration where the analysis is distributed over several processors and you can specify which entries to send to each processor. With MakeClass the user has control over the event loop, with MakeSelectorthe tree is in control of the event loop.; 12.20 Simple Analysis Using TTree::Draw; We will use the tree in c",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:589769,Availability,avail,available,589769,". A TCut object has a name and a title. It does not have any data members in addition to what it inherits from TNamed. It only adds a set of operators to do logical string concatenation. For example, assume:; TCut cut1 = ""x<1""; TCut cut2 = ""y>2""; then; cut1 && cut2; //result is the string ""(x<1)&&(y>2)""; Operators =, +=, +, *, !, &&, || are overloaded, here are some examples:; root[] TCut c1 = ""x < 1""; root[] TCut c2 = ""y < 0""; root[] TCut c3 = c1 && c2; root[] MyTree.Draw(""x"", c1); root[] MyTree.Draw(""x"", c1 || ""x>0""); root[] MyTree.Draw(""x"", c1 && c2); root[] MyTree.Draw(""x"", ""(x + y)"" * (c1 && c2)); 12.20.3 Accessing the Histogram in Batch Mode; The TTree::Draw method creates a histogram called htemp and puts it on the active pad. In a batch program, the histogram htemp created by default, is reachable from the current pad.; // draw the histogram; nt->Draw(""x"", ""cuts"");; // get the histogram from the current pad; TH1F *htemp = (TH1F*)gPad->GetPrimitive(""htemp"");; // now we have full use of the histogram; htemp->GetEntries();; If you pipe the result of the TTree::Draw into a histogram, the histogram is also available in the current directory. You can do:; // Draw the histogram and fill hnew with it; nt->Draw(""x>>hnew"",""cuts"");; // get hnew from the current directory; TH1F *hnew = (TH1F*)gDirectory->Get(""hnew"");; // or get hnew from the current Pad; TH1F *hnew = (TH1F*)gPad->GetPrimitive(""hnew"");; 12.20.4 Using Draw Options in TTree::Draw; The next parameter is the draw option for the histogram:; root[] MyTree->Draw(""Cost:Age"",""Nation == \""FR\"""",""surf2"");. Using draw options in trees. The draw options are the same as for TH1::Draw. See “Draw Options” where they are listed. In addition to the draw options defined in TH1, there are three more. The 'prof' and 'profs' draw a profile histogram (TProfile) rather than a regular 2D histogram (TH2D) from an expression with two variables. If the expression has three variables, a TProfile2D is generated.; The ‘profs’ generate",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:590660,Availability,error,error,590660,"the histogram; htemp->GetEntries();; If you pipe the result of the TTree::Draw into a histogram, the histogram is also available in the current directory. You can do:; // Draw the histogram and fill hnew with it; nt->Draw(""x>>hnew"",""cuts"");; // get hnew from the current directory; TH1F *hnew = (TH1F*)gDirectory->Get(""hnew"");; // or get hnew from the current Pad; TH1F *hnew = (TH1F*)gPad->GetPrimitive(""hnew"");; 12.20.4 Using Draw Options in TTree::Draw; The next parameter is the draw option for the histogram:; root[] MyTree->Draw(""Cost:Age"",""Nation == \""FR\"""",""surf2"");. Using draw options in trees. The draw options are the same as for TH1::Draw. See “Draw Options” where they are listed. In addition to the draw options defined in TH1, there are three more. The 'prof' and 'profs' draw a profile histogram (TProfile) rather than a regular 2D histogram (TH2D) from an expression with two variables. If the expression has three variables, a TProfile2D is generated.; The ‘profs’ generates a TProfile with error on the spread. The ‘prof’ option generates a TProfile with error on the mean. The “goff” option suppresses generating the graphics. You can combine the draw options in a list separated by commas. After typing the lines above, you should now have a canvas that looks this.; 12.20.5 Superimposing Two Histograms; When superimposing two 2-D histograms inside a script with TTree::Draw and using the “same” option, you will need to update the pad between Draw commands.; {; // superimpose two 2D scatter plots; // Create a 2D histogram and fill it with random numbers; TH2 *h2 = new TH2D (""h2"",""2D histo"",100,0,70,100,0,20000);; for (Int_t i = 0; i < 10000; i++); h2->Fill(gRandom->Gaus(40,10),gRandom->Gaus(10000,3000));; // set the color to differentiate it visually; h2->SetMarkerColor(kGreen);; h2->Draw();; // Open the example file and get the tree; TFile f(""cernstaff.root"");; TTree *myTree = (TTree*)f.Get(""T"");; // the update is needed for the next draw command to work properly; ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:590725,Availability,error,error,590725,"f the TTree::Draw into a histogram, the histogram is also available in the current directory. You can do:; // Draw the histogram and fill hnew with it; nt->Draw(""x>>hnew"",""cuts"");; // get hnew from the current directory; TH1F *hnew = (TH1F*)gDirectory->Get(""hnew"");; // or get hnew from the current Pad; TH1F *hnew = (TH1F*)gPad->GetPrimitive(""hnew"");; 12.20.4 Using Draw Options in TTree::Draw; The next parameter is the draw option for the histogram:; root[] MyTree->Draw(""Cost:Age"",""Nation == \""FR\"""",""surf2"");. Using draw options in trees. The draw options are the same as for TH1::Draw. See “Draw Options” where they are listed. In addition to the draw options defined in TH1, there are three more. The 'prof' and 'profs' draw a profile histogram (TProfile) rather than a regular 2D histogram (TH2D) from an expression with two variables. If the expression has three variables, a TProfile2D is generated.; The ‘profs’ generates a TProfile with error on the spread. The ‘prof’ option generates a TProfile with error on the mean. The “goff” option suppresses generating the graphics. You can combine the draw options in a list separated by commas. After typing the lines above, you should now have a canvas that looks this.; 12.20.5 Superimposing Two Histograms; When superimposing two 2-D histograms inside a script with TTree::Draw and using the “same” option, you will need to update the pad between Draw commands.; {; // superimpose two 2D scatter plots; // Create a 2D histogram and fill it with random numbers; TH2 *h2 = new TH2D (""h2"",""2D histo"",100,0,70,100,0,20000);; for (Int_t i = 0; i < 10000; i++); h2->Fill(gRandom->Gaus(40,10),gRandom->Gaus(10000,3000));; // set the color to differentiate it visually; h2->SetMarkerColor(kGreen);; h2->Draw();; // Open the example file and get the tree; TFile f(""cernstaff.root"");; TTree *myTree = (TTree*)f.Get(""T"");; // the update is needed for the next draw command to work properly; gPad->Update();; myTree->Draw(""Cost:Age"", """",""same"");; }; In t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:601072,Availability,avail,available,601072,"[3][2]. tree->Draw(""fMatrix[ ][ ] - fVertex[ ][ ]""). This is the same as case 15. The first dimension minimum is 4 (from fMatrix), and the second dimension minimum is 3 (from fVertex). Twelve values are selected from each entry. tree->Draw(""fClosestDistance""). This event data member fClosestDistance is a variable length array:; Float_t *fClosestDistance; //[fNvertex]; This command selects all elements, but the number per entry depends on the number of vertices of that entry. tree->Draw(""fClosestDistance[fNvertex/2]""). With this command the element at fNvertex/2 of the fClosestDistancearray is selected. Only one per entry is selected. tree->Draw(""sqrt(fPx*fPx + fPy*fPy + fPz*fPz)""). This command shows the use of a mathematical expression. It draws the square root of the sum of the product. tree->Draw(""TMath::BreitWigner(fPx,3,2)""). The formula can contains call to a function that takes numerical arguments and returns a numerical value. The function needs to be declared to the dictionary and need to be available from the global namespace. In particular, global functions and public static member functions can be called. tree->Draw(""fEvtHdr.fEvtNum"",""fType==""type1"" ""). You can compare strings, using the symbols == and !=, in the first two parameters of the Draw command (TTreeFormula). In this case, the event number for ‘type1’ events is plotted. tree->Draw(""fEvtHdr.fEvtNum"",""strstr(fType,""1"") ""). To compare strings, you can also use strstr. In this case, events having a ‘1’ in fType are selected. tree->Draw(""fTracks.fPoints""). If fPoints is a data member of the Track class declared as:; Int_t fNpoint;; Int_t *fPoints; [fNpoint]; The size of the array fPoints varies with each track of each event. This command draws all the value in the fPoints arrays. tree->Draw(""fTracks.fPoints - fTracks.fPoints[][fAvgPoints]"");. When fAvgPoints is a data member of the Event class, this example selects:; fTracks[0].fPoints[0] - fTracks[0].fPoint[fAvgPoints]; fTracks[0].fPoints[1] - fTra",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:606298,Availability,avail,available,606298,"array.; if (fVertex[0]>10) fVertex[0]; if (fVertex[1]>10) fVertex[1]; if (fVertex[2]>10) fVertex[2]. tree->Draw(""fPx[600]""); tree->Draw(""fPx[600]"",""fNtrack > 600""). When using a specific element for a variable length array the entries with fewer elements are ignored. Thus these two commands are equivalent. tree->Draw(""Nation""). Nation is a char* branch. When drawing a char* it will plot an alphanumeric histogram, of the different value of the string Nation. The axis will have the Nation values. See “Histograms”. tree->Draw(""MyChar +0""). If you want to plot a char* variable as a byte rather than a string, you can use the syntax above. tree->Draw(""fTracks.fTriggerBits""). fTriggerBits is a data member of TTrack of type TBits. Objects of class TBits can be drawn directly. This command will create a 1D histogram from 0 to nbits which is filled for each non-null bit-number. tree->Draw(""fMatrix-Alt$(fClosestDistance,0)""). Alt$(primary,alternate) returns the value of “primary” if it is available for the current iteration; otherwise return the value of “alternate”. Assuming that fClosestDistance is a smaller array than fMatrix. This example will draw fMatrix[i]+fClosestDistance[i] for i less than the size of fClosestDistance, and will draw fMatrix[i]+0 for the other value of i. tree->Draw(""fClosestDistance:Iteration$""). This example draws a 2D plot with, for all entries, fClosestDistance[i]:i for each value of i between 0 and the size of fClosestDistance. Iterations$ is one of four special variables giving some indications of the state of the loops implied by the formula:; Entry$ : return the current entry number (TTree::GetReadEntry()); Entries$ : return the total number of entries (TTree::GetEntries()); Length$ : return the total number of element of this formula for this entry; Iteration$: return the current iteration over this formula for this entry (i.e. varies from 0 to Length$). tree->Draw(""fLastTrack.GetPx():fLastTrack.fPx"");. TRef and TRefArray are automatically def",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:608735,Availability,avail,available,608735,"ore requesting the GetPx() member functions. tree->Draw(""This->GetReadEntry()"");. You can refer to the tree (or chain) containing the data by using the string ‘This’. You can also call any TTree methods. Next example will display the name of the first ‘user info’ object:; tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");. tree->Draw(""mybr.mystring"");. TString and std::string object are plotted directly. The example 45 draws the same results - i.e. an histogram whose labels are the string value of ‘mystring’:; tree->Draw(""mybr.mystring.c_str()"");; or; tree->Draw(""mybr.mytstring.Data()"");. tree->Draw(""myTimeStamp"");. You can plot plot objects of any class which has either AsDouble or AsString (AsDouble has priority). For such a class (for example TTimeStamp), the line 46 will plot the same as:; tree->Draw(""myTimeStamp.AsDouble"");; AsString can be returning either a char*, or a TString or an std::string.; 12.20.8 Multiple variables visualisation; This section presents the visualization technique available in ROOT to represent multiple variables (>4) data sets.; 12.20.8.1 Spider (Radar) Plots; Spider plots (sometimes called “web-plots” or “radar plots”) are used to compare series of data points (events). They use the human ability to spot un-symmetry. Example of spider plot. Variables are represented on individual axes displayed along a circle. For each variable the minimum value sits on the circle’s center, and the maximum on the circle’s radius. Spider plots are not suitable for an accurate graph reading since, by their nature, it can be difficult to read out very detailed values, but they give quickly a global view of an event in order to compare it with the others. In ROOT the spider plot facility is accessed from the tree viewer GUI. The variables to be visualized are selected in the tree viewer and can be scanned using the spider plot button. The tree viewer Graphical User Interface and the Spider Plot Editor. The spider plot graphics editor provides two tabs to",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:612920,Availability,avail,available,612920," rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; nt->Fill( s1x+1, s1y+1, s1z+1, s3x-2, s3y-2, s3z-2, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, s3x, rnd, s3z );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; }; The data set generated has:. 9 variables: x, y, z, u, v, w, a, b, c.; 3000*8 = 24000 events.; 3 sets of random points distributed on spheres: s1, s2, s3; Random values (noise): rnd; The variables a,b,c are almost completely random. The variables a and c are correlated via the 1st and 3rd coordinates of the 3rd “sphere” s3. The command used to produce the Parallel Coordinates plot is:; nt->Draw(""x:a:y:b:z:u:c:v:w"","""",""PARA"");. Cluttered output produced when all the tree events are plotted. If the 24000 events are plotted as solid lines and no special techniques are used to clarify the picture, the result is the previous picture which is very cluttered and useless. To improve the readability of the Parallel Coordinates output and to explore interactively the data set, many techniques are available. We have implemented a few in ROOT. First of all, in order to show better where the clusters on the various axes are, a 1D histogram is associated to each axis. These histograms (one per axis) are filled according to the number of lines passing through the bins. The histogram’s axis can be represented with colors or as bar charts. These histograms can be represented which colors (get from a palette according to the bin contents) or as bar charts. Both representations can be cumulated on the same plot. This technique allows seeing clearly where the clusters are on an individual axis but it does not give any hints about the correlations between the axes.; Avery simple technique allows to make the clusters appearing: Instead of painting solid lines we paint dotted lines. The cluttering of each individual line is reduced and the clusters show clearly as we can see on the next figure. The spacing between the dots is a param",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:635218,Availability,avail,available,635218,"mmon task, ROOT provides a utility that generates a skeleton class designed to loop over the entries of the tree.; This is the TTree::MakeClass method. We will now go through the steps of using MakeClass with a simplified example. The methods used here obviously work for complex event loop calculations.; These are our assumptions: we would like to do selective plotting and loop through each entry of the tree and tracks. We chose a simple example: we want to plot fPx of the first 100 tracks of each entry. We have a ROOT tree with a branch for each data member in the “Event” object. To build this file and tree follow the instructions on how to build the examples in $ROOTSYS/test. Execute Event and instruct it to split the object with this command (from the UNIX command line).; > $ROOTSYS/test/Event 400 1 2 1; This creates an Event.root file with 400 events, compressed, split, and filled.; See $ROOTSYS/test/MainEvent.cxx for more info.; The person who designed the tree makes a shared library available to you, which defines the classes needed. In this case, the classes are Event, EventHeader, and Track and they are defined in the shared library libEvent.so. The designer also gives you the Event.h file to see the definition of the classes. You can locate Event.h in $ROOTSYS/test, and if you have not yet built libEvent.so, please see the instructions of how to build it (typing make in $ROOTSYS/test is enough). If you have already built it, you can now use it again.; 12.21.1 Creating a Class with MakeClass; First, we load the shared library and open Event.root.; root[] .L libEvent.so; root[] TFile *f = new TFile(""Event.root"");; root[] f->ls();; TFile** Event.root TTree benchmark ROOT file; TFile* Event.root TTree benchmark ROOT file; KEY: TH1F htime;1 Real-Time to write versus time; KEY: TTree T;1 An example of a ROOT tree; We can see there is a tree “T”, and just to verify that we are working with the correct one, we print the tree, which will show us the header and branch",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:639997,Availability,error,error,639997,"lass definition shows us that this tree has one branch and one leaf per data member. The methods of MyClass are:. MyClass(TTree *tree=0) - this constructor has an optional tree for a parameter. If you pass a tree, MyClass will use it rather than the tree from which it was created.; void Init(TTree *tree) - it is called by the constructor to initialize the tree for reading. It associates each branch with the corresponding leaf data member.; ~MyClass() -the destructor, nothing special.; Int_t GetEntry(Int_t entry) - it loads the class with the entry specified. Once you have executed GetEntry, the leaf data members in MyClass are set to the values of the entry. For example, GetEntry(12) loads the 13th event into the event data member of MyClass (note that the first entry is 0). GetEntry returns the number of bytes read from the file. In case the same entry is read twice, ROOT does not have to do any I/O. In this case GetEntry returns 1. It does not return 0, because many people assume a return of 0 means an error has occurred while reading.; Int_t LoadTree(Int_t entry) and void Notify() - these two methods are related to chains. LoadTree will load the tree containing the specified entry from a chain of trees. Notify is called by LoadTree to adjust the branch addresses.; void Loop() - it is the skeleton method that loops through each entry of the tree. This is interesting to us, because we will need to customize it for our analysis. 12.21.3 MyClass.C; MyClass::Loop consists of a for-loop calling GetEntry for each entry. In the template, the numbers of bytes are added up, but it does nothing else. If we were to execute it now, there would be no output.; void MyClass::Loop() {; if (fChain == 0) return;. Int_t nentries = Int_t(fChain->GetEntries());; Int_t nbytes = 0, nb = 0;; for (Int_t jentry=0; jentry<nentries;jentry++) {; Int_t ientry = LoadTree(jentry);; // in case of a TChain , ientry is the entry number in the; // current file; nb = fChain->GetEntry(jentry); nbytes ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:648152,Availability,down,down,648152,"ClonesArrays collection class. It creates trees with and without compression for the following cases: vector<THit>, vector<THit*>, TClonesArray(TObjHit) not split TClonesArray(TObjHit) split.; The next graphs show the two columns on the right which represent the split and non-split TClonesArray, are significantly lower than the vectors. The most significant difference is in reading a file without compression.; The file size with compression, write times with and without compression and the read times with and without compression all favor the TClonesArray.; 12.23 Impact of Compression on I/O; This benchmark illustrates the pros and cons of the compression option. We recommend using compression when the time spent in I/O is small compared to the total processing time. In this case, if the I/O operation is increased by a factor of 5 it is still a small percentage of the total time and it may very well save a factor of 10 on disk space. On the other hand if the time spend on I/O is large, compression may slow down the program’s performance. The standard test program $ROOTSYS/test/Event was used in various configurations with 400 events. The data file contains a TTree. The program was invoked with:; Event 400 comp split. comp = 0 means: no compression at all.; comp = 1 means: compress everything if split = 0.; comp = 1 means: compress only the tree branches with integers if split = 1.; comp = 2 means: compress everything if split=1.; split = 0 : the full event is serialized into one single buffer.; split = 1 : the event is split into branches. One branch for each data member of the Event class. The list of tracks (a TClonesArray) has the data members of the Track class also split into individual buffers. These tests were run on Pentium III CPU with 650 MHz. Event Parameters; File Size; Total Time to Write (MB/sec); Effective Time to Write (MB/sec); Total Time to Read All (MB/sec); Total Time to Read Sample (MB/sec). Comp = 0; Split = 1; 19.75 MB; 6.84 s.(2.8 MB/s); 3.56",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:656343,Availability,error,error,656343,"thematical and statistical functions. The latest developments have been concentrated in providing first versions of the MathCore and MathMore libraries, included in ROOT v5.08. Other recent developments include the new version of MINUIT, which has been re-designed and re-implemented in the C++ language. It is integrated in ROOT. In addition, an optimized package for describing small matrices and vector with fixed sizes and their operation has been developed (SMatrix). The structure is shown in the following picture. Math libraries and packages. 13.1 MathCore Library; MathCore provides a collection of functions and C++ classes for numerical computing. This library includes only the basic mathematical functions and algorithms and not all the functionality required by the physics community. A more advanced mathematical functionality is provided by the MathMore library. The current set of included classes, which are provided in the ROOT::Math namespace are:. Basic special functions like the gamma, beta and error function.; Mathematical functions used in statistics, such as the probability density functions and the cumulative distributions functions (lower and upper integral of the pdf’s).; Generic function classes and interfaces for evaluating one-dimensional (ROOT::Math::IBaseFunctiononeDim) and multi-dimensional functions (ROOT::Math::IBaseFunctionMultiDim) and parametric function interfaces for evaluating functions with parameters in one (ROOT::Math::IParametricFunctionOneDim) or multi dimensions (ROOT::Math::IParametricFunctionMultiDim). A set of user convenient wrapper classes, such as ROOT::Math::Functor is provided for wrapping user-classes in the needed interface, required to use the algorithms of the ROOT Mathematical libraries.; Numerical algorithms interfaces and in same cases default implementations for:. numerical integration;; numerical differentiation;; one dimensional root-finding;; one-dimensional minimization;; multi-dimensional minimization (only the R",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:658041,Availability,avail,available,658041,"lgorithms of the ROOT Mathematical libraries.; Numerical algorithms interfaces and in same cases default implementations for:. numerical integration;; numerical differentiation;; one dimensional root-finding;; one-dimensional minimization;; multi-dimensional minimization (only the ROOT::Math::Minimizer interface). Fitting classes: set of classes for fitting generic data sets. These classes are provided in the namespace ROOT::Fit. They are describing separately in the Fitting chapter. The sets described above is independent of ROOT libraries and can be built as a set of standalone classes. In addition MathCore provides the following classes (depending on ROOT libCore library):. TMath: namespace with mathematical functions and basic function algorithms.; TComplex: class for complex numbers.; Random classes: the base class TRandom and the derived classes TRandom1, TRandom2 and TRandom3, implementing the pseudo-random number generators. A detailed description for all MathCore classes is available in the Doxygen online reference documentation.; 13.2 MathMore Library; The MathMore library provides an advanced collection of functions and C++ classes for numerical computing. This is an extension of the functionality provided by the MathCore library. The MathMore library is implemented wrapping in C++ the GNU Scientific Library (GSL). The current set, provided in the ROOT::Math namespace include:. Special mathematical functions (like Bessel functions, Legendre polynomials, etc.. ); Additional mathematical functions used in statistics such as probability density functions, cumulative distributions functions and their inverse which are not in MathCore but present in the GSL library.; Numerical algorithms for one dimensional functions based on implementation of the GNU Scientific Library (GSL):; Numerical integration classes implementing the interface ROOT::Math::Integrator which is based on the Adaptive integration algorithms of QUADPACK; Numerical differentiation via ROOT::Ma",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:660382,Availability,down,downloding,660382," on Chebyshev polynomials via the class ROOT::Math::Chebyshev; Random number generators and distributions based on GSL using the ROOT::Math::Random<Engine_type> class.; Polynomial evaluation and root solvers. The mathematical functions are implemented as a set of free functions in the namespace ROOT::Math. The naming used for the special functions is the same proposed for the C++ standard (see C++ standard extension proposal document).The MathMore library is implemented wrapping in C++ the GNU Scientific Library ( ). Building MathMore requires a version of GSL larger or equal 1.8. The source code of MathMore is distributed under the GNU General Public License.; MathMore (and its ROOT Cling dictionary) can be built within ROOT whenever a GSL library is found in the system. The GSL library and header file location can be specified in the ROOT configure script, by doing:; ./configure --with-gsl-incdir=... --with-gsl-libdir=...; MathMore can be built also a stand-alone library (without requiring ROOT) downloding the tar file from the Web at this link. In this case the library will not contain the dictionary information and therefore cannot be used interactively; More information on the classes and functions present in MathMore is available in the online reference documentation.; 13.3 TMath; In the namespace, TMath, a collection of free functions is provided for the following functionality:. numerical constants (like pi, e, h, etc.);; trigonometric and elementary mathematical functions;; functions to work with arrays and collections (e.g. functions to find min and max of arrays);; statistic functions to work on array of data (e.g. mean and RMS of arrays);; algorithms for binary search/hashing sorting;; special mathematical functions like Bessel, Erf, Gamma, etc.;; statistical functions, like common probability and cumulative (quantile) distributions; geometrical functions. For more details, see the reference documentation of TMath at <http://root.cern.ch/root/htmldoc/TMa",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:660615,Availability,avail,available,660615,"l evaluation and root solvers. The mathematical functions are implemented as a set of free functions in the namespace ROOT::Math. The naming used for the special functions is the same proposed for the C++ standard (see C++ standard extension proposal document).The MathMore library is implemented wrapping in C++ the GNU Scientific Library ( ). Building MathMore requires a version of GSL larger or equal 1.8. The source code of MathMore is distributed under the GNU General Public License.; MathMore (and its ROOT Cling dictionary) can be built within ROOT whenever a GSL library is found in the system. The GSL library and header file location can be specified in the ROOT configure script, by doing:; ./configure --with-gsl-incdir=... --with-gsl-libdir=...; MathMore can be built also a stand-alone library (without requiring ROOT) downloding the tar file from the Web at this link. In this case the library will not contain the dictionary information and therefore cannot be used interactively; More information on the classes and functions present in MathMore is available in the online reference documentation.; 13.3 TMath; In the namespace, TMath, a collection of free functions is provided for the following functionality:. numerical constants (like pi, e, h, etc.);; trigonometric and elementary mathematical functions;; functions to work with arrays and collections (e.g. functions to find min and max of arrays);; statistic functions to work on array of data (e.g. mean and RMS of arrays);; algorithms for binary search/hashing sorting;; special mathematical functions like Bessel, Erf, Gamma, etc.;; statistical functions, like common probability and cumulative (quantile) distributions; geometrical functions. For more details, see the reference documentation of TMath at <http://root.cern.ch/root/htmldoc/TMath.html>.; 13.3.1 Numerical Constants; TMath offers a wide range of constants in the form of inline functions. Notice that they are not defined as C/C++ preprocessor macros. This ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:670233,Availability,avail,available,670233,"nique seed will be automatically generated using TUUID; TRandom1 r1(0);; TRandom2 r2(0);; TRandom3 r3(0);; // seed generated using machine clock (different every second); TRandom r0(0);; 13.4.7 Random Number Distributions; The TRandom base class provides functions, which can be used by all the other derived classes for generating random variates according to predefined distributions. In the simplest cases, like in the case of the exponential distribution, the non-uniform random number is obtained by applying appropriate transformations. In the more complicated cases, random variates are obtained using acceptance-rejection methods, which require several random numbers.; TRandom3 r;; // generate a gaussian distributed number with:; // mu=0, sigma=1 (default values); double x1 = r.Gaus();; double x2 = r.Gaus(10,3); // use mu = 10, sigma = 3;; The following table shows the various distributions that can be generated using methods of the TRandom classes. More information is available in the reference documentation for TRandom. In addition, random numbers distributed according to a user defined function, in a limited interval, or to a user defined histogram, can be generated in a very efficient way using TF1::GetRandom() or TH1::GetRandom(). Distributions; Description. Double_t Uniform(Double_t x1,Double_t x2 ); Uniform random numbers between x1,x2. Double_t Gaus(Double_t mu,Double_t sigma ); Gaussian random numbers.; Default values: mu=0, sigma=1. Double_t Exp(Double_t tau); Exponential random numbers with mean tau. Double_t Landau(Double_t mean,Double_t s igma); Landau distributed random numbers.; Default values: mean=0, sigma=1. Double_t BreitWigner(Double_t mean,; Double_t gamma); Breit-Wigner distributed random numbers.; Default values mean=0, gamma=1. Int_t Poisson(Double_t mean); Double_t PoissonD(Double_t mean); Poisson random numbers. Int_t Binomial(Int_t ntot,Double_t prob ); Binomial Random numbers. Circle(Double_t &x,Double_t &y,Double_t r); Generate a random ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:672064,Availability,avail,available,672064,"ean); Double_t PoissonD(Double_t mean); Poisson random numbers. Int_t Binomial(Int_t ntot,Double_t prob ); Binomial Random numbers. Circle(Double_t &x,Double_t &y,Double_t r); Generate a random 2D point (x,y) in; a circle of radius r. Sphere(Double_t &x,Double_t &y,; Double_t &z,Double_t r); Generate a random 3D point (x,y,z) in; a sphere of radius r. Rannor(Double_t &a,Double_t &b); Generate a pair of Gaussian random; numbers with mu=0 and sigma=1. 13.4.8 UNURAN; An interface to a new package, UNU.RAN, (Universal Non Uniform Random number generator for generating non-uniform pseudo-random numbers) was introduced in ROOT v5.16.; UNU.RAN is an ANSI C library licensed under GPL. It contains universal (also called automatic or black-box) algorithms that can generate random numbers from large classes of continuous (in one or multi-dimensions), discrete distributions, empirical distributions (like histograms) and also from practically all standard distributions. An extensive online documentation is available at the UNU.RAN Web Site http://statmath.wu-wien.ac.at/unuran/; The ROOT class TUnuran is used to interface the UNURAN package. It can be used as following:. With the UNU.RAN native, string API for pre-defined distributions (see UNU.RAN documentation for the allowed string values at http://statistik.wu-wien.ac.at/unuran/doc/unuran.html ):. TUnuran unr;; // initialize unuran to generate normal random numbers using; // a ""arou"" method; unr.Init(""normal()"",""method=arou"");; ...; // sample distributions N times (generate N random numbers); for (int i = 0; i<N; ++i); double x = unr.Sample();. For continuous 1D distribution object via the class TUnuranContDist that can be created for example from a TF1 function providing the pdf (probability density function) . The user can optionally provide additional information via TUnuranContDist::SetDomain(min,max) like the domain() for generating numbers in a restricted region. // 1D case: create a distribution from two TF1 object; // ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:676778,Availability,error,error,676778,"116; 216; 126; 130. Poisson(m-10); 147; 1161; 162; 239. Poisson(m=10) UNURAN; 80; 294; 89; 99. 13.5 Mathematical Functions; The mathematical functions are present in both MathCore and MathMore libraries. All mathematical functions are implemented as free functions in the namespace ROOT::Math. The most used functions are in the MathCore library while the others are in the MathMore library. The functions in MathMore are all using the implementation of the GNU Scientific Library (GSL). The naming of the special functions is the same defined in the C++ Technical Report on Standard Library extensions. The special functions are defined in the header file Math/SpecFunc.h.; 13.5.1 Special Functions in MathCore. ROOT::Math::beta(double x,double y) -evaluates the beta function: \[B(x,y) = \frac{\Gamma(x) \Gamma(y)}{\Gamma(x+y)}\]; double ROOT::Math::erf(double x) - evaluates the error function encountered in integrating the normal distribution: \[erf(x) = \frac{2}{\sqrt{\pi}} \int_{0}^{x} e^{-t^2} dt\]; double ROOT::Math::erfc(double x) - evaluates the complementary error function: \[erfc(x) = 1 - erf(x) = \frac{2}{\sqrt{\pi}} \int_{x}^{\infty} e^{-t^2} dt\]; double ROOT::Math::tgamma(double x) - calculates the gamma function: \[\Gamma(x) = \int_{0}^{\infty} t^{x-1} e^{-t} dt\]. 13.5.2 Special Functions in MathMore. double ROOT::Math::assoc_legendre(unsigned l,unsigned m,double x) -computes the associated Legendre polynomials (with m>=0, l>=m and |x|<1): \[P_{l}^{m}(x) = (1-x^2)^{m/2} \frac{d^m}{dx^m} P_{l}(x)\]; double ROOT::Math::comp_ellint_1(double k) - calculates the complete elliptic integral of the first kind (with \(0 \le k^2 \le 1\): \[; K(k) = F(k, \pi / 2) = \int_{0}^{\pi /2} \frac{d \theta}{\sqrt{1 - k^2 \sin^2{\theta}}}; \]; double ROOT::Math::comp_ellint_2(double k) - calculates the complete elliptic integral of the second kind (with \(0 \le k^2 \le 1\)): \[; E(k) = E(k , \pi / 2) = \int_{0}^{\pi /2} \sqrt{1 - k^2 \sin^2{\theta}} d \theta; \]; double ROOT::Math::",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:676969,Availability,error,error,676969,"116; 216; 126; 130. Poisson(m-10); 147; 1161; 162; 239. Poisson(m=10) UNURAN; 80; 294; 89; 99. 13.5 Mathematical Functions; The mathematical functions are present in both MathCore and MathMore libraries. All mathematical functions are implemented as free functions in the namespace ROOT::Math. The most used functions are in the MathCore library while the others are in the MathMore library. The functions in MathMore are all using the implementation of the GNU Scientific Library (GSL). The naming of the special functions is the same defined in the C++ Technical Report on Standard Library extensions. The special functions are defined in the header file Math/SpecFunc.h.; 13.5.1 Special Functions in MathCore. ROOT::Math::beta(double x,double y) -evaluates the beta function: \[B(x,y) = \frac{\Gamma(x) \Gamma(y)}{\Gamma(x+y)}\]; double ROOT::Math::erf(double x) - evaluates the error function encountered in integrating the normal distribution: \[erf(x) = \frac{2}{\sqrt{\pi}} \int_{0}^{x} e^{-t^2} dt\]; double ROOT::Math::erfc(double x) - evaluates the complementary error function: \[erfc(x) = 1 - erf(x) = \frac{2}{\sqrt{\pi}} \int_{x}^{\infty} e^{-t^2} dt\]; double ROOT::Math::tgamma(double x) - calculates the gamma function: \[\Gamma(x) = \int_{0}^{\infty} t^{x-1} e^{-t} dt\]. 13.5.2 Special Functions in MathMore. double ROOT::Math::assoc_legendre(unsigned l,unsigned m,double x) -computes the associated Legendre polynomials (with m>=0, l>=m and |x|<1): \[P_{l}^{m}(x) = (1-x^2)^{m/2} \frac{d^m}{dx^m} P_{l}(x)\]; double ROOT::Math::comp_ellint_1(double k) - calculates the complete elliptic integral of the first kind (with \(0 \le k^2 \le 1\): \[; K(k) = F(k, \pi / 2) = \int_{0}^{\pi /2} \frac{d \theta}{\sqrt{1 - k^2 \sin^2{\theta}}}; \]; double ROOT::Math::comp_ellint_2(double k) - calculates the complete elliptic integral of the second kind (with \(0 \le k^2 \le 1\)): \[; E(k) = E(k , \pi / 2) = \int_{0}^{\pi /2} \sqrt{1 - k^2 \sin^2{\theta}} d \theta; \]; double ROOT::Math::",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:686033,Availability,avail,available,686033,"are defined in the header file Math/ProbFunc.h. The majority of the CDF’s are present in the MathCore, apart from the chisquared, fdistribution, gamma and tdistribution, which are in the MathMore library.; 13.5.4.1 Inverse of the Cumulative Distribution Functions(Quantiles); For almost all the cumulative distribution functions (_cdf) and their complements (_cdf_c) present in the library, we provide the inverse functions. The inverse of the cumulative distribution function is called in statistics quantile function. The functions with the extension _quantile calculate the inverse of the cumulative distribution function (lower tail integral of the probability density function), while those with the quantile_c extension calculate the inverse of the complement of the cumulative distribution (upper tail integral). All the inverse distributions are in the MathMore library and are defined in the header file Math/ProbFuncInv.h.; The following picture illustrates the available statistical functions (PDF, CDF and quantiles) in the case of the normal distribution. PDF, CDF and quantiles in the case of the normal distribution. 13.6 Numerical Algorithms; ROOT provides C++ classes implementing numerical algorithms to solve a wide set of problem, like:. Evaluation of function derivatives.; Evaluation of integrals.; Finding the roots of a function; Finding the minimum/maximum of a function. In order to use these algorithm the user needs to provide a function. ROOT provides a common way of specifying them via some interfaces; 13.7 ROOT::Math Function interfaces; To get a consistency in the mathematical methods within ROOT, there exists a set of interfaces to define the basic behaviour of a mathematical function. In order to use the classes presented in this chapter, the mathematical functions defined by the user must inherit from any of the classes seen in the figure:. ROOT::Math Function interface structure. 13.7.1 One-dimensional Function Interfaces; These interfaces are used for n",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:700184,Availability,toler,tolerance,700184,"For a TF1 defining a multidimensional function or in case we need to wrap in a multi-dimensional function interface, the class to use is ROOT::Math::WrappedMultiTF1. Following the usual procedure, setting the TF1 though the constructor, will wrap it into a ROOT::Math::IParametricGradFunctionMultiDim. Example:; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; 13.8 Numerical Integration; The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. ROOT::Math::VirtualIntegrator defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in ROOT::Math::VirtualIntegratorOneDim and ROOT::Math::VirtualIntegratorMultiDim. These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance. These methods must be implemented in the concrete classes existing for the different integration algorithms. The user cannot create directly these virtual integrator interfaces. He needs to create the ROOT::Math::IntegratorOneDim class for integrating one-dimensional functions and ROOT::Math::IntegratorMultiDim for multi-dimensional functions. Through the ROOT Plug-In Manager, the user can initialize ROOT::Math::IntegratorOneDim or ROOT::Math::IntegratorMultiDim with any of the concrete integration classes without dealing with them directly. These two classes provide the same interface as in VirtualIntegratorOneDim and VirtualIntegratorMultiDim, but with the possibility to choose in the constructor, which method will be used to perform the integration.; The method to set the function to be integrated, must be of the function interface type described before. ROOT::Math::IBaseFunctionOneDimFunction is used for",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:702097,Availability,avail,available,702097,"th::IBaseFunctionOneDimFunction is used for ROOT::Math::IBaseFunctionMultiDim and The only difference between the ROOT::Math::IntegratorOneDim and ROOT::Math::IntegratorMultiDim resides in the dimensionality of that function and some specific that will be seen afterwards for the one dimensional one. ROOT::Math Numerical Integrator classes. The rest of the classes shown above in the diagram are the specialized classes provided. Each one implements a different method that will be explained in detail. It is important to notice that the two grayed classes (the one which name starts by GSL) are part of the MathMore library. We will later show in more detail the differences between the implementations.; 13.8.1 Integration of One-dimensional Functions; 13.8.1.1 Using ROOT::Math::IntegratorOneDim; Here is a code example on how to use the ROOT::Math::IntegratorOneDim class (note that the class is defined in the header file Math/Integrator.h). In this example we create different instance of the class using some of the available algorithms in ROOT. If no algorithm is specified, the default one is used. The default Integrator together with other integration options such as relative and absolute tolerance, can be specified using the static method of the ROOT::Math::IntegratorOneDimOptions; #include ""Math/Integrator.h"". const double ERRORLIMIT = 1E-3;. double f(double x) {; return x;; }. double f2(const double * x) {; return x[0] + x[1];; }. int testIntegration1D() {. const double RESULT = 0.5;; int status = 0;. // set default tolerances for all integrators; ROOT::Math::IntegratorOneDimOptions::SetDefaultAbsTolerance(1.E-6);; ROOT::Math::IntegratorOneDimOptions::SetDefaultRelTolerance(1.E-6);. ROOT::Math::Functor1D wf(&f);; ROOT::Math::Integrator ig(ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR);; ig.SetFunction(wf);; double val = ig.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:702275,Availability,toler,tolerance,702275,"function and some specific that will be seen afterwards for the one dimensional one. ROOT::Math Numerical Integrator classes. The rest of the classes shown above in the diagram are the specialized classes provided. Each one implements a different method that will be explained in detail. It is important to notice that the two grayed classes (the one which name starts by GSL) are part of the MathMore library. We will later show in more detail the differences between the implementations.; 13.8.1 Integration of One-dimensional Functions; 13.8.1.1 Using ROOT::Math::IntegratorOneDim; Here is a code example on how to use the ROOT::Math::IntegratorOneDim class (note that the class is defined in the header file Math/Integrator.h). In this example we create different instance of the class using some of the available algorithms in ROOT. If no algorithm is specified, the default one is used. The default Integrator together with other integration options such as relative and absolute tolerance, can be specified using the static method of the ROOT::Math::IntegratorOneDimOptions; #include ""Math/Integrator.h"". const double ERRORLIMIT = 1E-3;. double f(double x) {; return x;; }. double f2(const double * x) {; return x[0] + x[1];; }. int testIntegration1D() {. const double RESULT = 0.5;; int status = 0;. // set default tolerances for all integrators; ROOT::Math::IntegratorOneDimOptions::SetDefaultAbsTolerance(1.E-6);; ROOT::Math::IntegratorOneDimOptions::SetDefaultRelTolerance(1.E-6);. ROOT::Math::Functor1D wf(&f);; ROOT::Math::Integrator ig(ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR);; ig.SetFunction(wf);; double val = ig.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig2(ROOT::Math::IntegrationOneDim::kNONADAPTIVE);; ig2.SetFunction(wf);; val = ig2.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Int",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:702612,Availability,toler,tolerances,702612,"starts by GSL) are part of the MathMore library. We will later show in more detail the differences between the implementations.; 13.8.1 Integration of One-dimensional Functions; 13.8.1.1 Using ROOT::Math::IntegratorOneDim; Here is a code example on how to use the ROOT::Math::IntegratorOneDim class (note that the class is defined in the header file Math/Integrator.h). In this example we create different instance of the class using some of the available algorithms in ROOT. If no algorithm is specified, the default one is used. The default Integrator together with other integration options such as relative and absolute tolerance, can be specified using the static method of the ROOT::Math::IntegratorOneDimOptions; #include ""Math/Integrator.h"". const double ERRORLIMIT = 1E-3;. double f(double x) {; return x;; }. double f2(const double * x) {; return x[0] + x[1];; }. int testIntegration1D() {. const double RESULT = 0.5;; int status = 0;. // set default tolerances for all integrators; ROOT::Math::IntegratorOneDimOptions::SetDefaultAbsTolerance(1.E-6);; ROOT::Math::IntegratorOneDimOptions::SetDefaultRelTolerance(1.E-6);. ROOT::Math::Functor1D wf(&f);; ROOT::Math::Integrator ig(ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR);; ig.SetFunction(wf);; double val = ig.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig2(ROOT::Math::IntegrationOneDim::kNONADAPTIVE);; ig2.SetFunction(wf);; val = ig2.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig3(wf, ROOT::Math::IntegrationOneDim::kADAPTIVE);; val = ig3.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig4(ROOT::Math::IntegrationOneDim::kGAUSS);; ig4.SetFunction(wf);; val = ig4.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:706731,Availability,toler,tolerance,706731," 13.8.2.3 ROOT::Math::GSLIntegrator; This is a wrapper for the QUADPACK integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time. The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the GSL library, wich is provided in the MathMore library of ROOT.; The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the ROOT::Math::GSLIntegrator class.; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied \[; absErr <= max ( epsAbs, epsRel * Integral); \] Where absErr is an estimate of the absolute error (it can be retrieved with GSLIntegrator::Error()) and Integral is the estimate of the function integral (it can be obtained with GSLIntegrator::Result()); The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the GSL users documentation. * ROOT::Math::Integration::kNONADAPTIVE : based on gsl_integration_qng. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions. * ROOT::Math::Integration::kADAPTIVE: based on gsl_integration_qag. It is an adaptiva Gauss-Kronrod integration algo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:706785,Availability,toler,tolerance,706785,"ented in the GSL library. It supports several integration methods that can be chosen in construction time. The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the GSL library, wich is provided in the MathMore library of ROOT.; The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the ROOT::Math::GSLIntegrator class.; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied \[; absErr <= max ( epsAbs, epsRel * Integral); \] Where absErr is an estimate of the absolute error (it can be retrieved with GSLIntegrator::Error()) and Integral is the estimate of the function integral (it can be obtained with GSLIntegrator::Result()); The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the GSL users documentation. * ROOT::Math::Integration::kNONADAPTIVE : based on gsl_integration_qng. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions. * ROOT::Math::Integration::kADAPTIVE: based on gsl_integration_qag. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each iteration the sub",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:706859,Availability,toler,tolerance,706859,"ented in the GSL library. It supports several integration methods that can be chosen in construction time. The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the GSL library, wich is provided in the MathMore library of ROOT.; The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the ROOT::Math::GSLIntegrator class.; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied \[; absErr <= max ( epsAbs, epsRel * Integral); \] Where absErr is an estimate of the absolute error (it can be retrieved with GSLIntegrator::Error()) and Integral is the estimate of the function integral (it can be obtained with GSLIntegrator::Result()); The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the GSL users documentation. * ROOT::Math::Integration::kNONADAPTIVE : based on gsl_integration_qng. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions. * ROOT::Math::Integration::kADAPTIVE: based on gsl_integration_qag. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each iteration the sub",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:707037,Availability,error,error,707037,"isit the GSL user guide This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the GSL library, wich is provided in the MathMore library of ROOT.; The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the ROOT::Math::GSLIntegrator class.; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied \[; absErr <= max ( epsAbs, epsRel * Integral); \] Where absErr is an estimate of the absolute error (it can be retrieved with GSLIntegrator::Error()) and Integral is the estimate of the function integral (it can be obtained with GSLIntegrator::Result()); The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the GSL users documentation. * ROOT::Math::Integration::kNONADAPTIVE : based on gsl_integration_qng. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions. * ROOT::Math::Integration::kADAPTIVE: based on gsl_integration_qag. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are * Integration::kGAUSS15 : 15 points Gauss-Konrod rule (value = 1) * Integration::kGAUSS21 : 21 points ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:707852,Availability,error,error,707852,"t absoulte tolerance; The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied \[; absErr <= max ( epsAbs, epsRel * Integral); \] Where absErr is an estimate of the absolute error (it can be retrieved with GSLIntegrator::Error()) and Integral is the estimate of the function integral (it can be obtained with GSLIntegrator::Result()); The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the GSL users documentation. * ROOT::Math::Integration::kNONADAPTIVE : based on gsl_integration_qng. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions. * ROOT::Math::Integration::kADAPTIVE: based on gsl_integration_qag. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are * Integration::kGAUSS15 : 15 points Gauss-Konrod rule (value = 1) * Integration::kGAUSS21 : 21 points Gauss-Konrod rule (value = 2) * Integration::kGAUSS31 : 31 points Gauss-Konrod rule (value = 3) * Integration::kGAUSS41 : 41 points Gauss-Konrod rule (value = 4) * Integration::kGAUSS51 : 51 points Gauss-Konrod rule (value = 5) * Integration::kGAUSS61 : 61 points Gauss-Konrod rule (value = 6) The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule is passed, the 31 points rule is used as default. ROOT::Math::Integration::kADAPTIVESINGULAR: based on gsl_integration_qags. It is an integration type which can be used in the case of the presence of singula",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:709762,Availability,avail,available,709762," the case of the presence of singularities.It uses the Gauss-Kronrod 21-point integration rule. This is the default algorithm. Note that when using the common ROOT::Math::IntegratorOneDIm class the enumeration type defining the algorithm must be defined in the namespace ROOT::Math::IntegrationOneDim (to distinguish from the multi-dimensional case) and the rule enumeration (or its corresponding integer) can be passed in the constructor of the ROOT::Math::IntegratorOneDIm.; 13.8.3 Multi-dimensional Integration; The multi-dimensional integration algorithm should be applied to functions with dimension larger than one. Adaptive multi-dimensional integration works for low function dimension, while MC integration can be applied to higher dimensions.; 13.8.3.1 Using ROOT::Math::IntegratorMultiDim; Here is a code example on how to use the ROOT::Math::IntegratorOneDim class (note that the class is defined in the header file Math/Integrator.h). In this example we create different instance of the class using some of the available algorithms in ROOT.; #include ""Math/IntegratorMultiDim.h""; #include ""Math/Functor.h"". double f2(const double * x) {; return x[0] + x[1];; }. int testIntegrationMultiDim() {. const double RESULT = 1.0;; const double ERRORLIMIT = 1E-3;; int status = 0;. ROOT::Math::Functor wf(&f2,2);; double a[2] = {0,0};; double b[2] = {1,1};. ROOT::Math::IntegratorMultiDim ig(ROOT::Math::IntegrationMultiDim::kADAPTIVE);; ig.SetFunction(wf);; double val = ig.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig2(ROOT::Math::IntegrationMultiDim::kVEGAS);; ig2.SetFunction(wf);; val = ig2.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig3(wf,ROOT::Math::IntegrationMultiDim::kPLAIN);; val = ig3.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:711891,Availability,toler,tolerance,711891,"bs(val-RESULT) > ERRORLIMIT;. return status;; }; 13.8.3.2 Multi-dimensions Integration Algorithms; Here is the types, that can be specified as enumeration and the corresponding classes. Enumeration name; Integrator class. ROOT::Math::IntegratorMultiDim::kADAPTIVE; ROOT::Math::AdaptiveIntegratorMultiDim. ROOT::Math::IntegratorMultiDim::kVEGAS; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kMISER; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kPLAIN; ROOT::Math:::GSLMCIntegrator. The control parameters for the integration algorithms can be specified using the ROOT::Math::IntegratorMultiDimOptions class. Static methods are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail de",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:711919,Availability,toler,tolerance,711919,"bs(val-RESULT) > ERRORLIMIT;. return status;; }; 13.8.3.2 Multi-dimensions Integration Algorithms; Here is the types, that can be specified as enumeration and the corresponding classes. Enumeration name; Integrator class. ROOT::Math::IntegratorMultiDim::kADAPTIVE; ROOT::Math::AdaptiveIntegratorMultiDim. ROOT::Math::IntegratorMultiDim::kVEGAS; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kMISER; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kPLAIN; ROOT::Math:::GSLMCIntegrator. The control parameters for the integration algorithms can be specified using the ROOT::Math::IntegratorMultiDimOptions class. Static methods are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail de",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:712484,Availability,toler,tolerance,712484,"ters for the integration algorithms can be specified using the ROOT::Math::IntegratorMultiDimOptions class. Static methods are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:715763,Availability,toler,tolerance,715763,"e in the MathCore library implementing the Brent method (not using the derivatives) and one in the MathMore library implementing several different methods, using in some case the derivatives.; 13.10.1.1 ROOT::Math::BrentMinimizer1D; This class implements the Brent method to minimize one-dimensional function. An interval containing the function minimum must be provided. Here is an example where we define the function to minimize as a lambda function (requires C++11). The function to minimize must be given to the class implementing the algorithm as a ROOT::Math::IBaseFunctionOneDim object.; ROOT::Math::Functor1D func( [](double x){ return 1 + -4*x + 1*x*x; } );. ROOT::Math::BrentMinimizer1D bm;; bm.SetFunction(func, -10,10);; bm.Minimize(10,0,0);; cout << ""Minimum: f("" << bm.XMinimum() << "") = "" <<bm.FValMinimum() << endl;; Note that when setting the function to minimize, one needs to provide the interval range to find the minimum. In the Minimize call, the maximum number of function calls, the relative and absolute tolerance must be provided.; 13.10.1.2 ROOT::Math::GSLMInimizer1D; This class wraps two different methods from the GSL. The algorithms which can be chosen at construction time are GOLDENSECTION, which is the simplest method but the slowest and BRENT (the default one) which combines the golden section with a parabolic interpolation. The algorithm can be chosen as a different enumeration in the constructor: * ROOT::Math::Minim1D::kBRENT for the Brent algorithm (default) * ROOT::Math::Minim1D::kGOLDENSECTION for the golden section algorithm; // this makes class with the default Brent algorithm; ROOT::Math::GSLMinimizer1D minBrent;; // this make the class with the Golden Section algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; The interface to set the function and to minimize is the same as in the case of the BrentMinimizer1D.; 13.10.1.3 Using the TF1 class; It is possible to perform the one-dimensional minimization/maximiza",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:716892,Availability,avail,available,716892," is the simplest method but the slowest and BRENT (the default one) which combines the golden section with a parabolic interpolation. The algorithm can be chosen as a different enumeration in the constructor: * ROOT::Math::Minim1D::kBRENT for the Brent algorithm (default) * ROOT::Math::Minim1D::kGOLDENSECTION for the golden section algorithm; // this makes class with the default Brent algorithm; ROOT::Math::GSLMinimizer1D minBrent;; // this make the class with the Golden Section algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; The interface to set the function and to minimize is the same as in the case of the BrentMinimizer1D.; 13.10.1.3 Using the TF1 class; It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, TF1 of the Hist library. The minmization is implemented in TF1 using the BrentMInimizer1D and available with the class member functions * TF1::GetMinimum/TF1::GetMaximum to find the function minimum/maximum value * TF1::GetMinimumX/TF1::GetMaximumX to find the x value corresponding at the function minimum.; The interval to search for the minimum (the default is the TF1 range), tolerance and maximum iterations can be provided as optional parameters of the TF1::GetMinimum/Maximum functions.; 13.10.2 Multi-Dimensional Minimization; All the algorithms for multi-dimensional minimization are implementing the ROOT::Math::Minimizer interface and they can be used in the same way and one can switch between minimizer at run-time. The minimizer concrete class can be in different ROOT libraries and they can be instantiate using the ROOT plug-in manager. More information on multi-dimensional minimization is provided in the Fitting Histogram chapter.; 13.11 ROOT Finder Algorithms; The function must be given to the class implementing the algorithm as a ROOT::Math::IBaseFunctionOneDim object. Some of the algorithm requires the derivatives of the function. In that c",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:717178,Availability,toler,tolerance,717178,"ENT for the Brent algorithm (default) * ROOT::Math::Minim1D::kGOLDENSECTION for the golden section algorithm; // this makes class with the default Brent algorithm; ROOT::Math::GSLMinimizer1D minBrent;; // this make the class with the Golden Section algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; The interface to set the function and to minimize is the same as in the case of the BrentMinimizer1D.; 13.10.1.3 Using the TF1 class; It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, TF1 of the Hist library. The minmization is implemented in TF1 using the BrentMInimizer1D and available with the class member functions * TF1::GetMinimum/TF1::GetMaximum to find the function minimum/maximum value * TF1::GetMinimumX/TF1::GetMaximumX to find the x value corresponding at the function minimum.; The interval to search for the minimum (the default is the TF1 range), tolerance and maximum iterations can be provided as optional parameters of the TF1::GetMinimum/Maximum functions.; 13.10.2 Multi-Dimensional Minimization; All the algorithms for multi-dimensional minimization are implementing the ROOT::Math::Minimizer interface and they can be used in the same way and one can switch between minimizer at run-time. The minimizer concrete class can be in different ROOT libraries and they can be instantiate using the ROOT plug-in manager. More information on multi-dimensional minimization is provided in the Fitting Histogram chapter.; 13.11 ROOT Finder Algorithms; The function must be given to the class implementing the algorithm as a ROOT::Math::IBaseFunctionOneDim object. Some of the algorithm requires the derivatives of the function. In that case a ROOT::Math::IGradientFunctionOneDim object must be provided.; 13.12 Generic Vectors for 2, 3 and 4 Dimensions (GenVector); GenVector is a package intended to represent vectors and their operations and transformations, such as ro",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:719522,Availability,avail,available,719522,"ibe generic N-dimensional vectors. Similar functionality is currently provided by the CLHEP and packages and the ROOT Physics vector classes (See “Physics Vectors”). It also re-uses concepts and ideas from the CMS Common Vector package. In contrast to CLHEP or the ROOT physics libraries, GenVector provides class templates for modeling the vectors. The user can control how the vector is internally represented. This is expressed by a choice of coordinate system, which is supplied as a template parameter when the vector is constructed. Furthermore, each coordinate system is itself a template, so that the user can specify the underlying scalar type.; The GenVector classes do not inherit from TObject, therefore cannot be used as in the case of the physics vector classes in ROOT collections.; In addition, to optimize performances, no virtual destructors are provided. In the following paragraphs, the main characteristics of GenVector are described. A more detailed description of all the GenVector classes is available also at http://seal.cern.ch/documents/mathlib/GenVector.pdf; 13.12.1 Main Characteristics; 13.12.1.1 Optimal Runtime Performances; We try to minimize any overhead in the run-time performance. We have deliberately avoided the use of any virtual function and even virtual destructors in the classes. In addition, as much as possible functions are defined as inline. For this reason, we have chosen to use template classes to implement the GenVector concepts instead of abstract or base classes and virtual functions. It is then recommended to avoid using the GenVector classes polymorphically and developing classes inheriting from them.; 13.12.1.2 Points and Vector Concept; Mathematically vectors and points are two distinct concepts. They have different transformations, as vectors only rotate while points rotate and translate. You can add two vectors but not two points and the difference between two points is a vector. We then distinguish for the 3 dimensional case, bet",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:722083,Availability,avail,available,722083,"ate System; The vector classes are based on a generic type of coordinate system, expressed as a template parameter of the class. Various classes exist to describe the various coordinates systems:; 2D coordinate system classes:. ROOT::Math::Cartesian2D, based on (x,y);; ROOT::Math::Polar2D, based on (r,phi);. 3D coordinate system classes:. ROOT::Math::Cartesian3D, based on (x,y,z);; ROOT::Math::Polar3D, based on (r,theta,phi);; ROOT::Math::Cylindrical3D, based on (rho,z,phi); ROOT::Math::CylindricalEta3D, based on (rho,eta,phi), where eta is the pseudo-rapidity;. 4D coordinate system classes:. ROOT::Math::PxPyPzE4D, based on based on (px,py,pz,E);; ROOT::Math::PxPyPzM4D, based on based on (px,py,pz,M);; ROOT::Math::PtEtaPhiE4D, based on based on (pt,eta,phi,E);; ROOT::Math::PtEtaPhiM4D, based on based on (pt,eta,phi,M);. Users can define the vectors according to the coordinate type, which is the most efficient for their use. Transformations between the various coordinate systems are available through copy constructors or the assignment (=) operator. For maximum flexibility and minimize memory allocation, the coordinate system classes are templated on the scalar type. To avoid exposing templated parameter to the users, typedefs are defined for all types of vectors based on doubles. See in the examples for all the possible types of vector classes, which can be constructed by users with the available coordinate system types.; 13.12.1.4 Coordinate System Tag; The 2D and 3D points and vector classes can be associated to a tag defining the coordinate system. This can be used to distinguish between vectors of different coordinate systems like global or local vectors. The coordinate system tag is a template parameter of the ROOT::Math::DisplacementVector3D and ROOT::Math::PositionVector3D (and also for 2D classes). A default tag exists for users who do not need this functionality, ROOT::Math::DefaultCoordinateSystemTag.; 13.12.1.5 Transformations; The transformations are mode",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:722496,Availability,avail,available,722496,"on (x,y,z);; ROOT::Math::Polar3D, based on (r,theta,phi);; ROOT::Math::Cylindrical3D, based on (rho,z,phi); ROOT::Math::CylindricalEta3D, based on (rho,eta,phi), where eta is the pseudo-rapidity;. 4D coordinate system classes:. ROOT::Math::PxPyPzE4D, based on based on (px,py,pz,E);; ROOT::Math::PxPyPzM4D, based on based on (px,py,pz,M);; ROOT::Math::PtEtaPhiE4D, based on based on (pt,eta,phi,E);; ROOT::Math::PtEtaPhiM4D, based on based on (pt,eta,phi,M);. Users can define the vectors according to the coordinate type, which is the most efficient for their use. Transformations between the various coordinate systems are available through copy constructors or the assignment (=) operator. For maximum flexibility and minimize memory allocation, the coordinate system classes are templated on the scalar type. To avoid exposing templated parameter to the users, typedefs are defined for all types of vectors based on doubles. See in the examples for all the possible types of vector classes, which can be constructed by users with the available coordinate system types.; 13.12.1.4 Coordinate System Tag; The 2D and 3D points and vector classes can be associated to a tag defining the coordinate system. This can be used to distinguish between vectors of different coordinate systems like global or local vectors. The coordinate system tag is a template parameter of the ROOT::Math::DisplacementVector3D and ROOT::Math::PositionVector3D (and also for 2D classes). A default tag exists for users who do not need this functionality, ROOT::Math::DefaultCoordinateSystemTag.; 13.12.1.5 Transformations; The transformations are modeled using simple (non-template) classes, using double as the scalar type to avoid too large numerical errors. The transformations are grouped in rotations (in 3 dimensions), Lorentz transformations and Poincare transformations, which are translation/rotation combinations. Each group has several members which may model physically equivalent transformations but with diff",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:723189,Availability,error,errors,723189," or the assignment (=) operator. For maximum flexibility and minimize memory allocation, the coordinate system classes are templated on the scalar type. To avoid exposing templated parameter to the users, typedefs are defined for all types of vectors based on doubles. See in the examples for all the possible types of vector classes, which can be constructed by users with the available coordinate system types.; 13.12.1.4 Coordinate System Tag; The 2D and 3D points and vector classes can be associated to a tag defining the coordinate system. This can be used to distinguish between vectors of different coordinate systems like global or local vectors. The coordinate system tag is a template parameter of the ROOT::Math::DisplacementVector3D and ROOT::Math::PositionVector3D (and also for 2D classes). A default tag exists for users who do not need this functionality, ROOT::Math::DefaultCoordinateSystemTag.; 13.12.1.5 Transformations; The transformations are modeled using simple (non-template) classes, using double as the scalar type to avoid too large numerical errors. The transformations are grouped in rotations (in 3 dimensions), Lorentz transformations and Poincare transformations, which are translation/rotation combinations. Each group has several members which may model physically equivalent transformations but with different internal representations. Transformation classes can operate on all type of vectors by using the operator ()or the operator * and the transformations can be combined via the operator *. The available transformations are:. 3D rotation classes; rotation described by a 3x3 matrix (ROOT::Math::Rotation3D); rotation described by Euler angles (ROOT::Math::EulerAngles); rotation described by a direction axis and an angle (ROOT::Math::AxisAngle); rotation described by a quaternion (ROOT::Math::Quaternion); optimized rotation around x (ROOT::Math::RotationX), y (ROOT::Math::RotationY) and z (ROOT::Math::RotationZ) and described by just one angle.; 3D tran",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:723654,Availability,avail,available,723654,"s can be used to distinguish between vectors of different coordinate systems like global or local vectors. The coordinate system tag is a template parameter of the ROOT::Math::DisplacementVector3D and ROOT::Math::PositionVector3D (and also for 2D classes). A default tag exists for users who do not need this functionality, ROOT::Math::DefaultCoordinateSystemTag.; 13.12.1.5 Transformations; The transformations are modeled using simple (non-template) classes, using double as the scalar type to avoid too large numerical errors. The transformations are grouped in rotations (in 3 dimensions), Lorentz transformations and Poincare transformations, which are translation/rotation combinations. Each group has several members which may model physically equivalent transformations but with different internal representations. Transformation classes can operate on all type of vectors by using the operator ()or the operator * and the transformations can be combined via the operator *. The available transformations are:. 3D rotation classes; rotation described by a 3x3 matrix (ROOT::Math::Rotation3D); rotation described by Euler angles (ROOT::Math::EulerAngles); rotation described by a direction axis and an angle (ROOT::Math::AxisAngle); rotation described by a quaternion (ROOT::Math::Quaternion); optimized rotation around x (ROOT::Math::RotationX), y (ROOT::Math::RotationY) and z (ROOT::Math::RotationZ) and described by just one angle.; 3D transformation: we describe the transformations defined as a composition between a rotation and a translation using the class ROOT::Math::Transform3D. It is important to note that transformations act differently on vectors and points. The vectors only rotate, therefore when applying a transformation (rotation + translation) on a vector, only the rotation operates while the translation has no effect. The Transform3D class interface is similar to the one used in the CLHEP Geometry package (class ).; Lorentz rotation:; generic Lorentz rotation descri",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:728075,Availability,avail,available,728075," methods which allow to get and set their data members (like SetCoordinates and GetCoordinates) passing either a generic iterator or a pointer to a contiguous set of data, like a C array. This allows an easy connection with the linear algebra package, which in turn, allows creation of matrices using C arrays (like the ROOT TMatrix classes) or iterators (SMatrix classes). Multiplication between linear algebra matrices and GenVector vectors is possible by using the template free functions ROOT::Math::VectorUtil::Mult. This function works for any linear algebra matrix, which implements the operator (i,j) and with first matrix element at i=j=0.; 13.12.2 Example: 3D Vector Classes; To avoid exposing template parameter to the users, typedef’s are defined for all types of vectors based on double’s and float’s. To use them, one must include the header file Math/Vector3D.h. The following typedef’s, defined in the header file Math/Vector3Dfwd.h, are available for the different instantiations of the template class ROOT::Math::DisplacementVector3D:. ROOT::Math::XYZVector vector based on x,y,z coordinates (Cartesian) in double precision; ROOT::Math::XYZVectorF vector based on x,y,z coordinates (Cartesian) in float precision; ROOT::Math::Polar3DVector vector based on r,theta,phi coordinates (polar) in double precision; ROOT::Math::Polar3DVectorF vector based on r,theta,phi coordinates (polar) in float precision; ROOT::Math::RhoZPhiVector vector based on rho,z,phi coordinates (cylindrical) in double precision; ROOT::Math::RhoZPhiVectorF vector based on rho,z,phi coordinates (cylindrical) in float precision; ROOT::Math::RhoEtaPhiVector vector based on rho,eta,phi coordinates (cylindrical using eta instead of z) in double precision; ROOT::Math::RhoEtaPhiVectorF vector based on rho,eta,phi coordinates (cylindrical using eta instead of z) in float precision. 13.12.2.1 Constructors and Assignment; The following declarations are available:; XYZVector v1; //an empty vector (x=0, y=0, z=0",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:729063,Availability,avail,available,729063,"es (Cartesian) in double precision; ROOT::Math::XYZVectorF vector based on x,y,z coordinates (Cartesian) in float precision; ROOT::Math::Polar3DVector vector based on r,theta,phi coordinates (polar) in double precision; ROOT::Math::Polar3DVectorF vector based on r,theta,phi coordinates (polar) in float precision; ROOT::Math::RhoZPhiVector vector based on rho,z,phi coordinates (cylindrical) in double precision; ROOT::Math::RhoZPhiVectorF vector based on rho,z,phi coordinates (cylindrical) in float precision; ROOT::Math::RhoEtaPhiVector vector based on rho,eta,phi coordinates (cylindrical using eta instead of z) in double precision; ROOT::Math::RhoEtaPhiVectorF vector based on rho,eta,phi coordinates (cylindrical using eta instead of z) in float precision. 13.12.2.1 Constructors and Assignment; The following declarations are available:; XYZVector v1; //an empty vector (x=0, y=0, z=0); XYZVector v2(1,2,3); //vector with x=1, y=2, z=3;; Polar3DVector v3(1,PI/2,PI); //vector with r=1, theta=PI/2, phi=PI; RhoEtaPHiVector v4(1,2, PI); //vector with rho=1, eta=2, phi=PI; Note that each vector type is constructed by passing its coordinate representation, so a XYZVector(1,2,3) is different from a Polar3DVector(1,2,3). In addition, the vector classes can be constructed by any vector, which implements the accessors x(), y() and z(). This can be another 3D vector based on a different coordinate system type. It can be even any vector of a different package, like the CLHEP HepThreeVector that implements the required signature.; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1);; CLHEP::HepThreeVector q(1,2,3);; XYZVector v3(q);; 13.12.2.2 Coordinate Accessors; All coordinate accessors are available through the class ROOT::Math::DisplacementVector3D:; //returns cartesian components for the cartesian vector v1; v1.X(); v1.Y(); v1.Z();; //returns cylindrical components for the cartesian vector v1; v1.Rho(); v1.Eta(); v1.Phi();; //returns cartesian components for the cylindrical vector r2;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:729926,Availability,avail,available,729926,"tead of z) in float precision. 13.12.2.1 Constructors and Assignment; The following declarations are available:; XYZVector v1; //an empty vector (x=0, y=0, z=0); XYZVector v2(1,2,3); //vector with x=1, y=2, z=3;; Polar3DVector v3(1,PI/2,PI); //vector with r=1, theta=PI/2, phi=PI; RhoEtaPHiVector v4(1,2, PI); //vector with rho=1, eta=2, phi=PI; Note that each vector type is constructed by passing its coordinate representation, so a XYZVector(1,2,3) is different from a Polar3DVector(1,2,3). In addition, the vector classes can be constructed by any vector, which implements the accessors x(), y() and z(). This can be another 3D vector based on a different coordinate system type. It can be even any vector of a different package, like the CLHEP HepThreeVector that implements the required signature.; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1);; CLHEP::HepThreeVector q(1,2,3);; XYZVector v3(q);; 13.12.2.2 Coordinate Accessors; All coordinate accessors are available through the class ROOT::Math::DisplacementVector3D:; //returns cartesian components for the cartesian vector v1; v1.X(); v1.Y(); v1.Z();; //returns cylindrical components for the cartesian vector v1; v1.Rho(); v1.Eta(); v1.Phi();; //returns cartesian components for the cylindrical vector r2; r2.X(); r2.Y(); r2.Z(); In addition, all the 3 coordinates of the vector can be retrieved with the GetCoordinates method:; double d[3];; //fill d array with (x,y,z) components of v1; v1.GetCoordinates(d);; //fill d array with (r,eta,phi) components of r2; r2.GetCoordinates(d);; std::vector vc(3);; //fill std::vector with (x,y,z) components of v1; v1.GetCoordinates(vc.begin(),vc.end());; See the reference documentation of ROOT::Math::DisplacementVector3D for more details on all the coordinate accessors.; 13.12.2.3 Setter Methods; One can set only all the three coordinates via:; v1.SetCoordinates(c1,c2,c3); // (x,y,z) for a XYZVector; r2.SetCoordinates(c1,c2,c3); // r,theta,phi for a Polar3DVector; r2.SetXYZ(x,y,z); // 3 carte",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:731035,Availability,avail,available,731035," vector v1; v1.X(); v1.Y(); v1.Z();; //returns cylindrical components for the cartesian vector v1; v1.Rho(); v1.Eta(); v1.Phi();; //returns cartesian components for the cylindrical vector r2; r2.X(); r2.Y(); r2.Z(); In addition, all the 3 coordinates of the vector can be retrieved with the GetCoordinates method:; double d[3];; //fill d array with (x,y,z) components of v1; v1.GetCoordinates(d);; //fill d array with (r,eta,phi) components of r2; r2.GetCoordinates(d);; std::vector vc(3);; //fill std::vector with (x,y,z) components of v1; v1.GetCoordinates(vc.begin(),vc.end());; See the reference documentation of ROOT::Math::DisplacementVector3D for more details on all the coordinate accessors.; 13.12.2.3 Setter Methods; One can set only all the three coordinates via:; v1.SetCoordinates(c1,c2,c3); // (x,y,z) for a XYZVector; r2.SetCoordinates(c1,c2,c3); // r,theta,phi for a Polar3DVector; r2.SetXYZ(x,y,z); // 3 cartesian components for Polar3DVector; Single coordinate setter methods are available for the basic vector coordinates, like SetX() for a XYZVector or SetR() for a polar vector. Attempting to do a SetX() on a polar vector will not compile.; XYZVector v1;; v1.SetX(1); //OK setting x for a Cartesian vector; Polar3DVector v2;; v2.SetX(1); //ERROR: cannot set X for a Polar vector.; //Method will not compile; v2.SetR(1); //OK setting r for a Polar vector; In addition, there are setter methods from C arrays or iterator; double d[3] = {1.,2.,3.};; XYZVector v;; // set (x,y,z) components of v using values from d; v.SetCoordinates(d);; or, for example, from an std::vector using the iterator; std::vector w(3);; // set (x,y,z) components of v using values from w; v.SetCoordinates(w.begin(),w.end());; 13.12.2.4 Arithmetic Operations; The following operations are possible between vector classes, even of different coordinate system types: (v1,v2 are any type of ROOT::Math::DisplacementVector3D classes, v3 is the same type of v1; a is a scalar value); v1 += v2;; v1 -= v2;; v1 ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:732894,Availability,avail,available,732894,"placementVector3D classes, v3 is the same type of v1; a is a scalar value); v1 += v2;; v1 -= v2;; v1 = - v2;; v1 *= a;; v1 /= a;; v2 = a * v1;; v2 = v1 / a;; v2 = v1 * a;; v3 = v1 + v2;; v3 = v1 - v2;; 13.12.2.5 Comparison; For v1 and v2 of the same type (same coordinate system and same scalar type):; v1 == v2;; v1 != v2;; 13.12.2.6 Dot and Cross Product; We support the dot and cross products, through the Dot() and Cross() method, with any vector (q) implementing x(), y() and z().; XYZVector v1(x,y,z);; double s = v1.Dot(q);; XYZVector v2 = v1.Cross(q);; Note that the multiplication between two vectors using the operator * is not supported because it is ambiguous.; 13.12.2.7 Other Methods; XYZVector u = v1.Unit(); //return unit vector parallel to v1; 13.12.3 Example: 3D Point Classes; To use all possible types of 3D points one must include the header file Math/Point3D.h. The following typedef’s defined in the header file Math/Point3Dfwd.h, are available for different instantiations of the template class ROOT::Math::PositionVector3D:. ROOT::Math::XYZPoint point based on x, y, z coordinates (Cartesian) in double precision; ROOT::Math::XYZPointF point based on x, y, z coordinates (Cartesian) in float precision; ROOT::Math::Polar3DPoint point based on r, theta, phi coordinates (polar) in double precision; ROOT::Math::Polar3DPointF point based on r, theta, phi coordinates (polar) in float precision; ROOT::Math::RhoZPhiPoint point based on rho, z, phi coordinates (cylindrical using z) in double precision; ROOT::Math::RhoZPhiPointF point based on rho, z, phi coordinates (cylindrical using z) in float precision; ROOT::Math::RhoEtaPhiPoint point based on rho, eta, phi coordinates (cylindrical using eta instead of z) in double precision; ROOT::Math::RhoEtaPhiPointF point based on rho, eta, phi coordinates (cylindrical using eta instead of z) in float precision. 13.12.3.1 Constructors and Assignment; The following declarations are available:; XYZPoint p1; //an empty vector (x=",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:733890,Availability,avail,available,733890,"onVector3D:. ROOT::Math::XYZPoint point based on x, y, z coordinates (Cartesian) in double precision; ROOT::Math::XYZPointF point based on x, y, z coordinates (Cartesian) in float precision; ROOT::Math::Polar3DPoint point based on r, theta, phi coordinates (polar) in double precision; ROOT::Math::Polar3DPointF point based on r, theta, phi coordinates (polar) in float precision; ROOT::Math::RhoZPhiPoint point based on rho, z, phi coordinates (cylindrical using z) in double precision; ROOT::Math::RhoZPhiPointF point based on rho, z, phi coordinates (cylindrical using z) in float precision; ROOT::Math::RhoEtaPhiPoint point based on rho, eta, phi coordinates (cylindrical using eta instead of z) in double precision; ROOT::Math::RhoEtaPhiPointF point based on rho, eta, phi coordinates (cylindrical using eta instead of z) in float precision. 13.12.3.1 Constructors and Assignment; The following declarations are available:; XYZPoint p1; //an empty vector (x=0, y=0, z=0); XYZPoint p2(1,2,3); //; Note that each point type is constructed by passing its coordinate representation, so a XYZPoint(1,2,3) is different from a Polar3DPoint(1,2,3). In addition the point classes can be constructed by any vector, which implements the accessors x(), y() and z(). This can be another 3D point based on a different coordinate system type or even any vector of a different package, like the CLHEP HepThreePoint that implements the required signatures.; XYZPoint p1(1,2,3);; RhoEtaPHiPoint r2(v1);; CLHEP::HepThreePoint q(1,2,3);; XYZPoint p3(q);; 13.12.3.2 Coordinate Accessors and Setter Methods; For the points classes we have the same getter and setter methods as for the vector classes. See “Example: 3D Vector Classes”.; 13.12.3.3 Point-Vector Operations; The following operations are possible between points and vector classes: (p1, p2 and p3 are instantiations of the ROOT::Math::PositionVector3D objects with p1 and p3 of the same type; v1 and v2 are ROOT::Math::DisplacementVector3D objects).; p1 +",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:735808,Availability,avail,available,735808,"h::PositionVector3D objects with p1 and p3 of the same type; v1 and v2 are ROOT::Math::DisplacementVector3D objects).; p1 += v1;; p1 -= v1;; p3 = p1 + v1; // p1 and p3 are the same type; p3 = v1 + p1; // p3 is based on the same coordinate system as v1; p3 = p1 - v1;; p3 = v1 - p1;; v2 = p1 - p2; // difference between points returns a vector v2; // based on the same coordinate system as p1; Note that the addition between two points is NOT possible and the difference between points returns a vector.; 13.12.3.4 Other Operations; Exactly as for the 3D Vectors, the following operations are allowed:. comparison of points; scaling and division of points with a scalar; dot and cross product with any type of vector. 13.12.4 Example: LorentzVector Classes; As in the 3D case, typedef’s are defined for user convenience. and can be used by including the header file Math/Vector4D.h. The following typedef’s, defined in the header file Math/Vector4Dfwd.h, are available for the different instantiations of the template class ROOT::Math::LorentzVector:. ROOT::Math::XYZTVector vector based on x, y, z, t coordinates (Cartesian) in double precision; ROOT::Math::XYZTVectorF vector based on x, y, z, t coordinates (Cartesian) in float precision; ROOT::Math::PtEtaPhiEVector vector based on pt(rho), eta, phi and E(t) coordinates in double precision; ROOT::Math::PtEtaPhiMVector vector based on pt(rho), eta, phi and M(t) coordinates in double precision; ROOT::Math::PxPyPzMVector vector based on px, py, pz and M(mass) coordinates in double precision. The metric used for all the LorentzVector is (-,-,-,+) .; 13.12.4.1 Constructors and Assignment; The following declarations are available:; // create an empty vector (x=0, y=0, z=0, t=0); XYZTVector v1;; // vector with x=1, y=2, z=3, t=4; XYZTVector v2(1,2,3,4);; // vector with pt=1, eta=2, phi=PI, E=5; PtEtaPhiEVector v3(1,2,PI,5);; Note that each type of vector is constructed by passing its coordinate representation, so a XYZTVector(1,2,3,4) is dif",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:736525,Availability,avail,available,736525,"n be used by including the header file Math/Vector4D.h. The following typedef’s, defined in the header file Math/Vector4Dfwd.h, are available for the different instantiations of the template class ROOT::Math::LorentzVector:. ROOT::Math::XYZTVector vector based on x, y, z, t coordinates (Cartesian) in double precision; ROOT::Math::XYZTVectorF vector based on x, y, z, t coordinates (Cartesian) in float precision; ROOT::Math::PtEtaPhiEVector vector based on pt(rho), eta, phi and E(t) coordinates in double precision; ROOT::Math::PtEtaPhiMVector vector based on pt(rho), eta, phi and M(t) coordinates in double precision; ROOT::Math::PxPyPzMVector vector based on px, py, pz and M(mass) coordinates in double precision. The metric used for all the LorentzVector is (-,-,-,+) .; 13.12.4.1 Constructors and Assignment; The following declarations are available:; // create an empty vector (x=0, y=0, z=0, t=0); XYZTVector v1;; // vector with x=1, y=2, z=3, t=4; XYZTVector v2(1,2,3,4);; // vector with pt=1, eta=2, phi=PI, E=5; PtEtaPhiEVector v3(1,2,PI,5);; Note that each type of vector is constructed by passing its coordinate representation, so a XYZTVector(1,2,3,4) is different from a PtEtaPhiEVector(1,2,3,4). In addition, the Vector classes can be constructed by any vector, which implements the accessors x(), y(), z() and t().; This can be another ROOT::Math::LorentzVector based on a different coordinate system or any vector of a different package, like the CLHEP HepLorentzVector that implements the required signature.; XYZTVector v1(1,2,3,4);; PtEtaPhiEVector v2(v1);; CLHEP::HepLorentzVector q(1,2,3,4);; XYZTVector v3(q);; 13.12.4.2 Coordinate Accessors; All the same coordinate accessors are available through the interface of ROOT::Math::LorentzVector. For example:; //returns cartesian components for the cartesian vector v1; v1.X(); v1.X(); v1.Z(); v1.T();; //returns cartesian components for the cylindrical vector v2; v2.Px(); v2.Py(); v2.Pz(); v2.E();; //returns other components",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:737384,Availability,avail,available,737384,"le precision. The metric used for all the LorentzVector is (-,-,-,+) .; 13.12.4.1 Constructors and Assignment; The following declarations are available:; // create an empty vector (x=0, y=0, z=0, t=0); XYZTVector v1;; // vector with x=1, y=2, z=3, t=4; XYZTVector v2(1,2,3,4);; // vector with pt=1, eta=2, phi=PI, E=5; PtEtaPhiEVector v3(1,2,PI,5);; Note that each type of vector is constructed by passing its coordinate representation, so a XYZTVector(1,2,3,4) is different from a PtEtaPhiEVector(1,2,3,4). In addition, the Vector classes can be constructed by any vector, which implements the accessors x(), y(), z() and t().; This can be another ROOT::Math::LorentzVector based on a different coordinate system or any vector of a different package, like the CLHEP HepLorentzVector that implements the required signature.; XYZTVector v1(1,2,3,4);; PtEtaPhiEVector v2(v1);; CLHEP::HepLorentzVector q(1,2,3,4);; XYZTVector v3(q);; 13.12.4.2 Coordinate Accessors; All the same coordinate accessors are available through the interface of ROOT::Math::LorentzVector. For example:; //returns cartesian components for the cartesian vector v1; v1.X(); v1.X(); v1.Z(); v1.T();; //returns cartesian components for the cylindrical vector v2; v2.Px(); v2.Py(); v2.Pz(); v2.E();; //returns other components for the cartesian vector v1; v1.Pt(); v1.Eta(); v1.Phi(); v1.M(); In addition, all 4 vector coordinates can be retrieved with the GetCoordinates method:; double d[4];; //fill d array with (x,y,z,t) components of v1; v1.GetCoordinates(d);; //fill d array with (pt,eta,phi,e) components of v2; v2.GetCoordinates(d);; std::vector w(4);; //fill std::vector with (x,y,z,t); v1.GetCoordinates(w.begin(),w.end());; //components of v1; To get information on all the coordinate accessors see the ROOT::Math::LorentzVector reference documentation.; 13.12.4.3 Setter Methods; One can set only all the three coordinates via:; //sets the (x,y,z,t) for a XYZTVector; v1.SetCoordinates(c1,c2,c3,c4);; //sets pt,eta,phi,e ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:738547,Availability,avail,available,738547," components for the cylindrical vector v2; v2.Px(); v2.Py(); v2.Pz(); v2.E();; //returns other components for the cartesian vector v1; v1.Pt(); v1.Eta(); v1.Phi(); v1.M(); In addition, all 4 vector coordinates can be retrieved with the GetCoordinates method:; double d[4];; //fill d array with (x,y,z,t) components of v1; v1.GetCoordinates(d);; //fill d array with (pt,eta,phi,e) components of v2; v2.GetCoordinates(d);; std::vector w(4);; //fill std::vector with (x,y,z,t); v1.GetCoordinates(w.begin(),w.end());; //components of v1; To get information on all the coordinate accessors see the ROOT::Math::LorentzVector reference documentation.; 13.12.4.3 Setter Methods; One can set only all the three coordinates via:; //sets the (x,y,z,t) for a XYZTVector; v1.SetCoordinates(c1,c2,c3,c4);; //sets pt,eta,phi,e for a PtEtaPhiEVector; v2.SetCoordinates(c1,c2,c3,c4);; //sets cartesian components for PtEtaPhiEVector; v2.SetXYZ(x,y,z,t);; Single coordinate setter methods are available for the basic vector coordinates, like SetX() for a XYZTVector or SetPt() for a PtEtaPhiEVector. Attempting to do a SetX() on a non-Cartesian vector will not compile.; XYZTVector v1;; v1.SetX(1); //OK setting x for a cartesian vector; PtEtaPhiEVector v2;; v2.SetX(1); //ERROR: cannot set X for a non-cartesian; //vector. Method will not compile.; v2.SetR(1) // OK setting Pt for a PtEtaPhiEVector vector; In addition, there are setter methods from C arrays or iterators.; double d[4] = {1.,2.,3.,4.};; XYZTVector v;; //set (x,y,z,t) components of v using values from d; v.SetCoordinates(d);; or for example from an std::vectorusing the iterators; std::vector w(4);; //set (x,y,z,t) components of v using values from w; v.SetCoordinates(w.begin(),w.end());; 13.12.4.4 Arithmetic Operations; The following operations are possible between Lorentz vectors classes, even of different coordinate system types: (v andw are two Lorentz vector of the same type, qis a generic Lorentz vector implementing x(), y(), z() and t()",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:750502,Availability,avail,available,750502," ROOT v5.10, symmetric matrices using a storage class (ROOT::Math::MatRepSym) which contains only the N*(N+1)/2 independent element of a NxN symmetric matrix. It is not in the mandate of this package to provide complete linear algebra functionality. It provides basic matrix and vector functions such as matrix-matrix, matrix-vector, vector-vector operations, plus some extra functionality for square matrices, like inversion and determinant calculation. The inversion is based on the optimized Cramer method for squared matrices of size up to 6x6.; The SMatrix package contains only header files. Normally one does not need to build any library. In the ROOT distribution a library, libSmatrix is produced with the C++ dictionary information for squared and symmetric matrices and vectors up to dimension 7 and based on Double_t, Float_t and Double32_t. The following paragraphs describe the main characteristics of the matrix and vector classes. More detailed information about the SMatrix classes API is available in the online reference documentation.; 13.13.1 Example: Vector Class (SVector); The template class ROOT::Math::SVector represents n-dimensional vectors for objects of arbitrary type. This class has 2 template parameters, which define at compile time, its properties: 1) type of the contained elements (for example float or double); 2) size of the vector. The use of this dictionary is mandatory if one want to use Smatrix in Cling and with I/O.; 13.13.1.1 Creating a Vector; The following constructors are available to create a vector:. Default constructor for a zero vector (all elements equal to zero).; Constructor (and assignment) from a vector expression, like v=p*q+w. Due to the expression template technique, no temporary objects are created in this operation.; Constructor by passing directly the elements. This is possible only for vectors up to size 10.; Constructor from an iterator copying the data referred by the iterator. It is possible to specify the begin and end o",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:751019,Availability,avail,available,751019," squared matrices of size up to 6x6.; The SMatrix package contains only header files. Normally one does not need to build any library. In the ROOT distribution a library, libSmatrix is produced with the C++ dictionary information for squared and symmetric matrices and vectors up to dimension 7 and based on Double_t, Float_t and Double32_t. The following paragraphs describe the main characteristics of the matrix and vector classes. More detailed information about the SMatrix classes API is available in the online reference documentation.; 13.13.1 Example: Vector Class (SVector); The template class ROOT::Math::SVector represents n-dimensional vectors for objects of arbitrary type. This class has 2 template parameters, which define at compile time, its properties: 1) type of the contained elements (for example float or double); 2) size of the vector. The use of this dictionary is mandatory if one want to use Smatrix in Cling and with I/O.; 13.13.1.1 Creating a Vector; The following constructors are available to create a vector:. Default constructor for a zero vector (all elements equal to zero).; Constructor (and assignment) from a vector expression, like v=p*q+w. Due to the expression template technique, no temporary objects are created in this operation.; Constructor by passing directly the elements. This is possible only for vectors up to size 10.; Constructor from an iterator copying the data referred by the iterator. It is possible to specify the begin and end of the iterator or the begin and the size. Note that for the Vector the iterator is not generic and must be of type T*, where T is the type of the contained elements. In the following example we assume that we are using the namespace ROOT::Math; //create an empty vector of size 3 ( v[0]=v[1]=v[2]=0); SVector<double,3> v;; double d[3] = {1,2,3};; SVector<double,3> v(d,3); //create a vector from a C array; 13.13.1.2 Accessing and Setting Methods; The single vector elements can be set or retrieved using the ope",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:752772,Availability,error,error,752772,"Math; //create an empty vector of size 3 ( v[0]=v[1]=v[2]=0); SVector<double,3> v;; double d[3] = {1,2,3};; SVector<double,3> v(d,3); //create a vector from a C array; 13.13.1.2 Accessing and Setting Methods; The single vector elements can be set or retrieved using the operator[i], operator(i) or the iterator interface. Notice that the index starts from zero and not from one as in FORTRAN. Also no check is performed on the passed index. The full vector elements can be set also by using the SetElements function passing a generic iterator.; double x = m(i); // return the i-th element; x = *(m.begin()+i); // return the i-th element; v[0] = 1; // set the first element; v(1) = 2; // set the second element; *(v.begin()+3) = 3; // set the third element; std::vector<double> w(3);. // set vector elements from a std::vector<double>::iterator; v.SetElements(w.begin(),w.end());; In addition there are methods to place a sub-vector in a vector. If the size of the sub-vector is larger than the vector size a static assert (a compilation error) is produced.; SVector>double,N> v;; SVector>double,M> w;; // M <= N otherwise a compilation error is obtained later; // place a vector of size M starting from; // element ioff, v[ioff+i]=w[i]; v.Place_at(w,ioff);; // return a sub-vector of size M starting from; // v[ioff]: w[i]=v[ioff+i]; w = v.Sub < SVector>double,M> > (ioff);; For the vector functions see later in the Matrix and Vector Operators and Functions paragraph.; 13.13.2 Example: Matrix Class (SMatrix); The template class ROOT::Math::SMatrix represents a matrix of arbitrary type with nrows x ncol dimension. The class has 4 template parameters, which define at compile time, its properties:. type of the contained elements, T, for example float or double;; number of rows;; number of columns;; representation type. This is a class describing the underlined storage model of the Matrix. Presently exists only two types of this class:; ROOT::Math::MatRepStd for a general nrows x ncols matrix",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:752871,Availability,error,error,752871,"ctor from a C array; 13.13.1.2 Accessing and Setting Methods; The single vector elements can be set or retrieved using the operator[i], operator(i) or the iterator interface. Notice that the index starts from zero and not from one as in FORTRAN. Also no check is performed on the passed index. The full vector elements can be set also by using the SetElements function passing a generic iterator.; double x = m(i); // return the i-th element; x = *(m.begin()+i); // return the i-th element; v[0] = 1; // set the first element; v(1) = 2; // set the second element; *(v.begin()+3) = 3; // set the third element; std::vector<double> w(3);. // set vector elements from a std::vector<double>::iterator; v.SetElements(w.begin(),w.end());; In addition there are methods to place a sub-vector in a vector. If the size of the sub-vector is larger than the vector size a static assert (a compilation error) is produced.; SVector>double,N> v;; SVector>double,M> w;; // M <= N otherwise a compilation error is obtained later; // place a vector of size M starting from; // element ioff, v[ioff+i]=w[i]; v.Place_at(w,ioff);; // return a sub-vector of size M starting from; // v[ioff]: w[i]=v[ioff+i]; w = v.Sub < SVector>double,M> > (ioff);; For the vector functions see later in the Matrix and Vector Operators and Functions paragraph.; 13.13.2 Example: Matrix Class (SMatrix); The template class ROOT::Math::SMatrix represents a matrix of arbitrary type with nrows x ncol dimension. The class has 4 template parameters, which define at compile time, its properties:. type of the contained elements, T, for example float or double;; number of rows;; number of columns;; representation type. This is a class describing the underlined storage model of the Matrix. Presently exists only two types of this class:; ROOT::Math::MatRepStd for a general nrows x ncols matrix. This class is itself a template on the contained type T, the number of rows and the number of columns. Its data member is an array T[nrows*ncols] ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:754784,Availability,avail,available,754784,"he contained type T, the number of rows and the number of columns. Its data member is an array T[nrows*ncols] containing the matrix data. The data are stored in the row-major C convention. For example, for a matrix M, of size 3x3, the data {a0,a1,...,a8} are stored in the following order:. \[; M =; \left(\begin{array}{ccc}; a_0 & a_1 & a_2 \\; a_3 & a_4 & a_5 \\; a_6 & a_7 & a_8; \end{array}\right); \]. ROOT::Math::MatRepSym for a symmetric matrix of size NxN. This class is a template on the contained type and on the symmetric matrix size N. It has as data member an array of type T of size N*(N+1)/2, containing the lower diagonal block of the matrix. The order follows the lower diagonal block, still in a row-major convention. For example for a symmetric 3x3 matrix the order of the 6 independent elements {a0,a1,...,a5} is:. \[; M =; \left(\begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5; \end{array}\right); \]; 13.13.2.1 Creating a Matrix; The following constructors are available to create a matrix:. Default constructor for a zero matrix (all elements equal to zero).; Constructor of an identity matrix.; Copy constructor (and assignment) for a matrix with the same representation, or from a different one when possible, for example from a symmetric to a general matrix.; Constructor (and assignment) from a matrix expression, like D=A*B+C. Due to the expression template technique, no temporary objects are created in this operation. In the case of an operation like A=A*B+C, a temporary object is needed and it is created automatically to store the intermediary result in order to preserve the validity of this operation.; Constructor from a generic STL-like iterator copying the data referred by the iterator, following its order. It is both possible to specify the begin and end of the iterator or the begin and the size. In case of a symmetric matrix, it is required only the triangular block and the user can specify whether giving a block representing",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:758829,Availability,error,error,758829,"me behavior for general and symmetric matrices; in contrast to the iterator access methods which behave differently (it follows the data order).; SMatrix33 m;; m(0,0) = 1; // set the element in first row and first column; *(m.begin()+1) = 2; // set the second element (0,1); double d[9]={1,2,3,4,5,6,7,8,9};; m.SetElements(d,d+9); // set the d[] values in m; double x = m(2,1); // return the element in 3; x = m.apply(7); // return the 8-th element (row=2,col=1); x = *(m.begin()+7); // return the 8-th element (row=2,col=1); // symmetric matrices; //(note the difference in behavior between apply and the iterators); x = *(m.begin()+4) // return the element (row=2,col=1); x = m.apply(7); // returns again the (row=2,col=1) element; There are methods to place and/or retrieve ROOT::Math::SVector objects as rows or columns in (from) a matrix. In addition one can put (get) a sub-matrix as another ROOT::Math::SMatrix object in a matrix. If the size of the sub-vector or sub-matrix is larger than the matrix size a static assert (a compilation error) is produced. The non-const methods are:; SMatrix33 m;; SVector2 v2(1,2);; // place a vector in the first row from; // element (0,1) : m(0,1)=v2[0]; m.Place_in_row(v2,0,1);; // place the vector in the second column from; // (0,1) : m(0,1) = v2[0]; m.Place in_col(v2,0,1);; SMatrix22 m2;; // place m2 in m starting from the; // element (1,1) : m(1,1) = m2(0,0); m.Place_at(m2,1,1);; SVector3 v3(1,2,3);; // set v3 as the diagonal elements; // of m : m(i,i) = v3[i] for i=0,1,2; m.SetDiagonal(v3); The const methods retrieving contents (getting slices of a matrix) are:; a = {1,2,3,4,5,6,7,8,9};; SMatrix33 m(a,a+9);; SVector3 irow = m.Row(0); // return as vector the first row; SVector3 jcol = m.Col(1); // return as vector the second column. // return a slice of the first row from; // (0,1): r2[0]= m(0,1); r2[1]=m(0,2); SVector2 r2 = m.SubRow<SVector2> (0,1);; // return a slice of the second column from; // (0,1): c2[0] = m(0,1); c2[1] = m(1,1); ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:760294,Availability,avail,available,760294,"he diagonal elements; // of m : m(i,i) = v3[i] for i=0,1,2; m.SetDiagonal(v3); The const methods retrieving contents (getting slices of a matrix) are:; a = {1,2,3,4,5,6,7,8,9};; SMatrix33 m(a,a+9);; SVector3 irow = m.Row(0); // return as vector the first row; SVector3 jcol = m.Col(1); // return as vector the second column. // return a slice of the first row from; // (0,1): r2[0]= m(0,1); r2[1]=m(0,2); SVector2 r2 = m.SubRow<SVector2> (0,1);; // return a slice of the second column from; // (0,1): c2[0] = m(0,1); c2[1] = m(1,1); SVector2 c2 = m.SubCol<SVector2> (1,0);. // return a sub-matrix 2x2 with the upper left corner at(1,1); SMatrix22 subM = m.Sub<SMatrix22> (1,1);. // return the diagonal element in a SVector; SVector3 diag = m.Diagonal();. // return the upper(lower) block of the matrix m; SVector6 vub = m.UpperBlock(); // vub = [ 1, 2, 3, 5, 6, 9 ]; SVector6 vlb = m.LowerBlock(); // vlb = [ 1, 4, 5, 7, 8, 9 ]; 13.13.2.3 Linear Algebra Matrix Functions (Inversion, Determinant); Only limited linear algebra functionality is available for SMatrix. It is possible for squared matrices NxN, to find the inverse or to calculate the determinant. Different inversion algorithms are used if the matrix is smaller than 6x6 or if it is symmetric. In the case of a small matrix, a faster direct inversion is used. For a large (N>6)symmetric matrix the Bunch-Kaufman diagonal pivoting method is used while for a large (N>6) general matrix an LU factorization is performed using the same algorithm as in the CERNLIB routine dinv.; // Invert a NxN matrix.; // The inverted matrix replaces the existing one if the; // result is successful; bool ret = m.Invert(); // return the inverse matrix of m. // If the inversion fails ifail is different than zero ???; int ifail = 0;; ifail = m.Inverse(ifail);. // determinant of a square matrix - calculate the determinant; // modyfing the matrix content and returns it if the calculation; // was successful; double det;; bool ret = m.Det(det);. // calculat",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:764377,Availability,avail,available,764377,"M) returns the transpose matrix MT; ROOT::Math::Similarity(v,M) returns the scalar value resulting from the matrix-vector product vTMv; ROOT::Math::Similarity(U,M) returns the matrix resulting from the product: U M UT. If M is symmetric, the returned resulting matrix is also symmetric; ROOT::Math::SimilarityT(U,M) returns the matrix resulting from the product: UT M U. If M is symmetric, the returned resulting matrix is also symmetric. The major vector functions are:. ROOT::Math::Dot(v1,v2) returns the scalar value resulting from the vector dot product; ROOT::Math::Cross(v1,v2) returns the vector cross product for two vectors of size 3. Note that the Cross product is not defined for other vector sizes; ROOT::Math::Unit(v) returns unit vector. One can use also the v.Unit()method.; ROOT::Math::TensorProd(v1,v2) returns a general matrix Mof size N1xN2 resulting from the tensor product between the vector v1 of size N1 and v2 of size N2:. For a list of all the available matrix and vector functions see the SMatrix online reference documentation.; 13.13.4.1 Matrix and Vector I/O; One can print (or write in an output stream) Vectors and Matrices) using the Print method or the << operator:; // m is a SMatrix or a SVector object; m.Print(std::cout);; std::cout << m << std::endl;; In the ROOT distribution, the Cling dictionary is generated for SMatrix and SVector for for Double_t, Float_t and Double32_t up to dimension 7. This allows the possibility to store them in a ROOT file.; 13.14 ROOT Statistics Classes; 13.14.1 Classes for Computing Limits and Confidence Levels; TFeldmanCousins class calculates the CL upper/lower limit for a Poisson process using the Feldman-Cousins method (as described in PRD V57 #7, p3873-3889). No treatment is provided in this method for the uncertainties in the signal or the background.; TRolke computes confidence intervals for the rate of a Poisson process in the presence of background and efficiency, using the profile likelihood technique for treat",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:767814,Availability,robust,robust,767814,"arametrization for multi-dimensional data by fitting them to multi-dimensional data using polynomial or Chebyshev or Legendre polynomial; TSpectrum contains advanced spectra processing functions for 1- and 2-dimensional background estimation, smoothing, deconvolution, peak search and fitting, and orthogonal transformations.; RooFit is a complete toolkit for fitting and data analysis modeling (see the RooFit User Guide at ftp://root.cern.ch/root/doc/RooFit_Users_Manual_2.07-29.pdf); TSplot to disentangle signal from background via an extended maximum likelihood fit and with a tool to access the quality and validity of the fit producing distributions for the control variables. (see M. Pivk and F.R. Le Diberder, Nucl. Inst. Meth.A 555, 356-369, 2005).; 13.14.3 Multi-variate Analysis Classes; TMultiLayerPerceptron is a Neural Network class (see for more details the chapter “Neural Networks”).; TPrincipal provides the Principal Component Analysis.; TRobustEstimator is a robust method for minimum covariance determinant estimator (MCD).; TMVA is a package for multivariate data analysis (see https://github.com/root-project/root/blob/master/documentation/tmva/UsersGuide/TMVAUsersGuide.pdf the User’s Guide).; 14 Linear Algebra in ROOT; The linear algebra package is supposed to give a complete environment in ROOT to perform calculations like equation solving and eigenvalue decompositions. Most calculations are performed in double precision. For backward compatibility, some classes are also provided in single precision like TMatrixF, TMatrixFSym and TVectorF. Copy constructors exist to transform these into their double precision equivalent, thereby allowing easy access to decomposition and eigenvalue classes, only available in double precision.; The choice was made not to provide the less frequently used complex matrix classes. If necessary, users can always reformulate the calculation in 2 parts, a real one and an imaginary part. Although, a linear equation involving complex nu",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:768566,Availability,avail,available,768566,"ntrol variables. (see M. Pivk and F.R. Le Diberder, Nucl. Inst. Meth.A 555, 356-369, 2005).; 13.14.3 Multi-variate Analysis Classes; TMultiLayerPerceptron is a Neural Network class (see for more details the chapter “Neural Networks”).; TPrincipal provides the Principal Component Analysis.; TRobustEstimator is a robust method for minimum covariance determinant estimator (MCD).; TMVA is a package for multivariate data analysis (see https://github.com/root-project/root/blob/master/documentation/tmva/UsersGuide/TMVAUsersGuide.pdf the User’s Guide).; 14 Linear Algebra in ROOT; The linear algebra package is supposed to give a complete environment in ROOT to perform calculations like equation solving and eigenvalue decompositions. Most calculations are performed in double precision. For backward compatibility, some classes are also provided in single precision like TMatrixF, TMatrixFSym and TVectorF. Copy constructors exist to transform these into their double precision equivalent, thereby allowing easy access to decomposition and eigenvalue classes, only available in double precision.; The choice was made not to provide the less frequently used complex matrix classes. If necessary, users can always reformulate the calculation in 2 parts, a real one and an imaginary part. Although, a linear equation involving complex numbers will take about a factor of 8 more computations, the alternative of introducing a set of complex classes in this non-template library would create a major maintenance challenge.; Another choice was to fill in both the upper-right corner and the bottom-left corner of a symmetric matrix. Although most algorithms use only the upper-right corner, implementation of the different matrix views was more straightforward this way. When stored only the upper-right part is written to file.; For a detailed description of the interface, the user should look at the root reference guide at: http://root.cern.ch/root/Reference.html; 14.1 Overview of Matrix Classes; The f",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:768996,Availability,mainten,maintenance,768996," multivariate data analysis (see https://github.com/root-project/root/blob/master/documentation/tmva/UsersGuide/TMVAUsersGuide.pdf the User’s Guide).; 14 Linear Algebra in ROOT; The linear algebra package is supposed to give a complete environment in ROOT to perform calculations like equation solving and eigenvalue decompositions. Most calculations are performed in double precision. For backward compatibility, some classes are also provided in single precision like TMatrixF, TMatrixFSym and TVectorF. Copy constructors exist to transform these into their double precision equivalent, thereby allowing easy access to decomposition and eigenvalue classes, only available in double precision.; The choice was made not to provide the less frequently used complex matrix classes. If necessary, users can always reformulate the calculation in 2 parts, a real one and an imaginary part. Although, a linear equation involving complex numbers will take about a factor of 8 more computations, the alternative of introducing a set of complex classes in this non-template library would create a major maintenance challenge.; Another choice was to fill in both the upper-right corner and the bottom-left corner of a symmetric matrix. Although most algorithms use only the upper-right corner, implementation of the different matrix views was more straightforward this way. When stored only the upper-right part is written to file.; For a detailed description of the interface, the user should look at the root reference guide at: http://root.cern.ch/root/Reference.html; 14.1 Overview of Matrix Classes; The figure below shows an overview of the classes available in the linear algebra library,libMatrix.so. At the center is the base class TMatrixDBase from which three different matrix classes, TMatrixD, TMatrixDSym and TMatrixDFSparse derive. The user can define customized matrix operations through the classes TElementActionD and TElementsPosActionD. Overview of matrix classes. Reference to different vi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:769547,Availability,avail,available,769547,"tion and eigenvalue classes, only available in double precision.; The choice was made not to provide the less frequently used complex matrix classes. If necessary, users can always reformulate the calculation in 2 parts, a real one and an imaginary part. Although, a linear equation involving complex numbers will take about a factor of 8 more computations, the alternative of introducing a set of complex classes in this non-template library would create a major maintenance challenge.; Another choice was to fill in both the upper-right corner and the bottom-left corner of a symmetric matrix. Although most algorithms use only the upper-right corner, implementation of the different matrix views was more straightforward this way. When stored only the upper-right part is written to file.; For a detailed description of the interface, the user should look at the root reference guide at: http://root.cern.ch/root/Reference.html; 14.1 Overview of Matrix Classes; The figure below shows an overview of the classes available in the linear algebra library,libMatrix.so. At the center is the base class TMatrixDBase from which three different matrix classes, TMatrixD, TMatrixDSym and TMatrixDFSparse derive. The user can define customized matrix operations through the classes TElementActionD and TElementsPosActionD. Overview of matrix classes. Reference to different views of the matrix can be created through the classes on the right-hand side, see “Matrix Views”. These references provide a natural connection to vectors.; Matrix decompositions (used in equation solving and matrix inversion) are available through the classes on the left-hand side (see “Matrix Decompositions”). They inherit from the TDecompBase class. The Eigen Analysis is performed through the classes at the top, see “Matrix Eigen Analysis”. In both cases, only some matrix types can be analyzed. For instance, TDecompChol will only accept symmetric matrices as defined TMatrixDSym. The assignment operator behaves somewhat d",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:770132,Availability,avail,available,770132,"h most algorithms use only the upper-right corner, implementation of the different matrix views was more straightforward this way. When stored only the upper-right part is written to file.; For a detailed description of the interface, the user should look at the root reference guide at: http://root.cern.ch/root/Reference.html; 14.1 Overview of Matrix Classes; The figure below shows an overview of the classes available in the linear algebra library,libMatrix.so. At the center is the base class TMatrixDBase from which three different matrix classes, TMatrixD, TMatrixDSym and TMatrixDFSparse derive. The user can define customized matrix operations through the classes TElementActionD and TElementsPosActionD. Overview of matrix classes. Reference to different views of the matrix can be created through the classes on the right-hand side, see “Matrix Views”. These references provide a natural connection to vectors.; Matrix decompositions (used in equation solving and matrix inversion) are available through the classes on the left-hand side (see “Matrix Decompositions”). They inherit from the TDecompBase class. The Eigen Analysis is performed through the classes at the top, see “Matrix Eigen Analysis”. In both cases, only some matrix types can be analyzed. For instance, TDecompChol will only accept symmetric matrices as defined TMatrixDSym. The assignment operator behaves somewhat different than of most other classes. The following lines will result in an error:; TMatrixD a(3,4);; TMatrixD b(5,6);; b = a;; It required to first resize matrix b to the shape of a.; TMatrixD a(3,4);; TMatrixD b(5,6);; b.ResizeTo(a);; b = a;; 14.2 Matrix Properties; A matrix has five properties, which are all set in the constructor:. precision - float or double. In the first case you will use the TMatrixF class family, in the latter case the TMatrixD one;; type - general (TMatrixD), symmetric (TMatrixDSym) or sparse (TMatrixDSparse);; size - number of rows and columns;; index - range start of ro",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:770607,Availability,error,error,770607,"Base from which three different matrix classes, TMatrixD, TMatrixDSym and TMatrixDFSparse derive. The user can define customized matrix operations through the classes TElementActionD and TElementsPosActionD. Overview of matrix classes. Reference to different views of the matrix can be created through the classes on the right-hand side, see “Matrix Views”. These references provide a natural connection to vectors.; Matrix decompositions (used in equation solving and matrix inversion) are available through the classes on the left-hand side (see “Matrix Decompositions”). They inherit from the TDecompBase class. The Eigen Analysis is performed through the classes at the top, see “Matrix Eigen Analysis”. In both cases, only some matrix types can be analyzed. For instance, TDecompChol will only accept symmetric matrices as defined TMatrixDSym. The assignment operator behaves somewhat different than of most other classes. The following lines will result in an error:; TMatrixD a(3,4);; TMatrixD b(5,6);; b = a;; It required to first resize matrix b to the shape of a.; TMatrixD a(3,4);; TMatrixD b(5,6);; b.ResizeTo(a);; b = a;; 14.2 Matrix Properties; A matrix has five properties, which are all set in the constructor:. precision - float or double. In the first case you will use the TMatrixF class family, in the latter case the TMatrixD one;; type - general (TMatrixD), symmetric (TMatrixDSym) or sparse (TMatrixDSparse);; size - number of rows and columns;; index - range start of row and column index. By default these start at zero;; sparse map - this property is only relevant for a sparse matrix. It indicates where elements are unequal zero. 14.2.1 Accessing Properties; The following table shows the methods to access the information about the relevant matrix property:. Method; Descriptions. Int_t GetRowLwb (); row lower-bound index. Int_t GetRowUpb (); row upper-bound index. Int_t GetNrows (); number of rows. Int_t GetColLwb (); column lower-bound index. Int_t GetColUpb (); col",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:771815,Availability,toler,tolerance,771815,"h are all set in the constructor:. precision - float or double. In the first case you will use the TMatrixF class family, in the latter case the TMatrixD one;; type - general (TMatrixD), symmetric (TMatrixDSym) or sparse (TMatrixDSparse);; size - number of rows and columns;; index - range start of row and column index. By default these start at zero;; sparse map - this property is only relevant for a sparse matrix. It indicates where elements are unequal zero. 14.2.1 Accessing Properties; The following table shows the methods to access the information about the relevant matrix property:. Method; Descriptions. Int_t GetRowLwb (); row lower-bound index. Int_t GetRowUpb (); row upper-bound index. Int_t GetNrows (); number of rows. Int_t GetColLwb (); column lower-bound index. Int_t GetColUpb (); column upper-bound index. Int_t GetNcols (); number of columns. Int_t GetNoElements (); number of elements, for a dense matrix this equals: fNrows x fNcols. Double_t GetTol (); tolerance number which is used in decomposition operations. Int_t *GetRowIndexArray (); for sparse matrices, access to the row index of fNrows+1 entries. Int_t *GetColIndexArray (); for sparse matrices, access to the column index of fNelems entries. The last two methods in this table are specific to the sparse matrix, which is implemented according to the Harwell-Boeing format. Here, besides the usual shape/size descriptors of the matrix like fNrows, fRowLwb, fNcols and fColLwb, we also store a row index, fRowIndex and column index, fColIndex for the elements unequal zero:. fRowIndex[0,..,fNrows]:; Stores for each row the index range of the elements in the data and column array. fColIndex[0,..,fNelems-1]:; Stores the column number for each data element != 0. The code to print all matrix elements unequal zero would look like:; TMatrixDSparse a;; const Int_t *rIndex = a.GetRowIndexArray();; const Int_t *cIndex = a.GetColIndexArray();; const Double_t *pData = a.GetMatrixArray();; for (Int_t irow = 0; irow <",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:773650,Availability,toler,tolerance,773650,"ook like:; TMatrixDSparse a;; const Int_t *rIndex = a.GetRowIndexArray();; const Int_t *cIndex = a.GetColIndexArray();; const Double_t *pData = a.GetMatrixArray();; for (Int_t irow = 0; irow < a.getNrows(); irow++) {; const Int_t sIndex = rIndex[irow];; const Int_t eIndex = rIndex[irow+1];; for (Int_t index = sIndex; index < eIndex; index++) {; const Int_t icol = cIndex[index];; const Double_t data = pData[index];; printf(""data(%d,%d) = %.4en"",irow+a.GetfRowLwb(),; icol+a.GetColLwb(),data);; }; }; 14.2.2 Setting Properties; The following table shows the methods to set some of the matrix properties. The resizing procedures will maintain the matrix elements that overlap with the old shape. The optional last argument nr_zeros is only relevant for sparse matrices. If supplied, it sets the number of non-zero elements. If it is smaller than the number overlapping with the old matrix, only the first (row-wise)nr_zeros are copied to the new matrix. Method; Descriptions. SetTol (Double_t tol); set the tolerance number. ResizeTo (Int_t nrows,Int_t ncols,; Int_t nr_nonzeros=-1); change matrix shape to nrows x ncols. Index will start at zero. ResizeTo(Int_t row_lwb,Int_t row_upb,; Int_t col_lwb,Int_t col_upb,; Int_t nr_nonzeros=-1); change matrix shape to; row_lwb:row_upb x col_lwb:col_upb. SetRowIndexArray (Int_t *data); for sparse matrices, set the row index. The array data should contains at leastfNrows+1 entries column lower-bound index. SetColIndexArray (Int_t *data); for sparse matrices, set the column index. The array data should contains at least fNelems entries. SetSparseIndex (Int_t nelems new); allocate memory for a sparse map of nelems_new elements and copy (if exists) at most nelems_new matrix elements over to the new structure. SetSparseIndex (const TMatrixDBase &a); copy the sparse map from matrix a Note that this can be a dense matrix!. SetSparseIndexAB (const TMatrixDSparse &a, const TMatrixDSparse &b); set the sparse map to the same of the map of matrix a and b",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:776714,Availability,avail,available,776714,"Int_t row_lwb,Int_t row_upb); TMatrixDSym(Int_t nrows,const Double_t *data,Option_t *option=""""); TMatrixDSym(Int_t row_lwb,Int_t row_upb,const Double_t *data, Option_t *opt=""""). TMatrixDSparse(Int_t nrows,Int_t ncols); TMatrixDSparse(Int_t row_lwb,Int_t row_upb,Int_t col_lwb, Int_t col_upb ); TMatrixDSparse(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb,; Int_t nr_nonzeros,Int_t *row,Int_t *col,Double_t *data). If only the matrix shape is defined in the constructor, matrix data has to be supplied and possibly the sparse structure. In “Setting Properties” was discussed how to set the sparse structure.; Several methods exist to fill a matrix with data:; SetMatrixArray(const Double_t*data,Option_t*option=""""), copies the array data. If option=""F"", the array fills the matrix column-wise else row-wise. This option is only implemented for TMatrixD and TMatrixDSym. It is expected that the array data contains at least fNelems entries.; SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Double_t *data), is only available for sparse matrices. The three arrays should each contain nr entries with row index, column index and data entry. Only the entries with non-zero data value are inserted!; operator()or operator[], these operators provide the easiest way to fill a matrix but are in particular for a sparse matrix expensive. If no entry for slot (i,j) is found in the sparse index table it will be entered, which involves some memory management! Therefore, before invoking this method in a loop it is wise to set the index table first through a call to the SetSparseIndex method.; SetSub(Int_t row_lwb,Int_t col_lwb,const TMatrixDBase &source), the matrix to be inserted at position (row_lwb,col_lwb) can be both, dense or sparse.; Use(...) allows inserting another matrix or data array without actually copying the data. Next table shows the different flavors for the different matrix types. Use(TMatrixD &a); Use(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb,Double_t *d ata)",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:780981,Availability,toler,tolerance,780981,":kMult,B); constructor of \(A.B\). TMatrixD(A, TMatrixD::kTransposeMult,B); constructor of \(A^{T}.B\). TMatrixD(A, TMatrixD::kMultTranspose,B); constructor of \(A.B^{T}\). element wise multiplication; element wise division; ElementMult(A,B); ElementDiv(A,B); A(i,j)*= B(i,j); A(i,j)/= B(i,j). 14.4.2 Arithmetic Operations between Matrices and Real Numbers. Description; Format; Comment. element wise sum; C=r+A C=A+r A+=r; overwrites \(A\). element wise subtraction; C=r-A C=A-r A-=r; overwrites \(A\). matrix multiplication; C=r*A C=A*r A*=r; overwrites \(A\). 14.4.3 Comparisons and Boolean Operations; The following table shows element wise comparisons between two matrices:. Format; Output; Description. A == B; Bool_t; equal to. A != B; A > B; A >= B; A < B; A <= B; matrix; matrix; matrix; matrix; matrix; Not equal; Greater than; Greater than or equal to; Smaller than; Smaller than or equal to. AreCompatible(A,B); Compare(A,B); VerifyMatrixIdentity(A,B,verb, maxDev); Bool_t; Bool_t; Compare matrix properties; return summary of comparison; Check matrix identity within maxDev tolerance. The following table shows element wise comparisons between matrix and real:. Format; Output; Description. A == r; A != r; A > r; A >= r; A < r; A <= r; Bool_t; Bool_t; Bool_t Bool_t; Bool_t Bool_t; equal to; Not equal; Greater than; Greater than or equal to; Smaller than; Smaller than or equal to. VerifyMatrixValue(A,r,verb, maxDev); Bool_t; Compare matrix value with r within maxDev tolerance. 14.4.4 Matrix Norms. Format; Output; Description. A.RowNorm(); A.NormInf(); A.ColNorm(); A.Norm1(); A.E2Norm(); A.NonZeros(); A.Sum(); A.Min(); A.Max(); Double_t; Double_t; Double_t; Double_t; Double_t; Int_t; Double_t; Double_t; Double_t; norm induced by the infinity vector norm, maxi\(\sum_{i}|A_{ij}|\); maxi\(\sum_{i}|A_{ij}|\); norm induced by the 1 vector norm, maxj\(\sum_{i}|A_{ij}|\); maxj\(\sum_{i}|A_{ij}|\); Square of the Euclidean norm,; \(\sum_{ji}(A_{ij}^{2})\); number of elements unequal",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:781378,Availability,toler,tolerance,781378,"ment wise subtraction; C=r-A C=A-r A-=r; overwrites \(A\). matrix multiplication; C=r*A C=A*r A*=r; overwrites \(A\). 14.4.3 Comparisons and Boolean Operations; The following table shows element wise comparisons between two matrices:. Format; Output; Description. A == B; Bool_t; equal to. A != B; A > B; A >= B; A < B; A <= B; matrix; matrix; matrix; matrix; matrix; Not equal; Greater than; Greater than or equal to; Smaller than; Smaller than or equal to. AreCompatible(A,B); Compare(A,B); VerifyMatrixIdentity(A,B,verb, maxDev); Bool_t; Bool_t; Compare matrix properties; return summary of comparison; Check matrix identity within maxDev tolerance. The following table shows element wise comparisons between matrix and real:. Format; Output; Description. A == r; A != r; A > r; A >= r; A < r; A <= r; Bool_t; Bool_t; Bool_t Bool_t; Bool_t Bool_t; equal to; Not equal; Greater than; Greater than or equal to; Smaller than; Smaller than or equal to. VerifyMatrixValue(A,r,verb, maxDev); Bool_t; Compare matrix value with r within maxDev tolerance. 14.4.4 Matrix Norms. Format; Output; Description. A.RowNorm(); A.NormInf(); A.ColNorm(); A.Norm1(); A.E2Norm(); A.NonZeros(); A.Sum(); A.Min(); A.Max(); Double_t; Double_t; Double_t; Double_t; Double_t; Int_t; Double_t; Double_t; Double_t; norm induced by the infinity vector norm, maxi\(\sum_{i}|A_{ij}|\); maxi\(\sum_{i}|A_{ij}|\); norm induced by the 1 vector norm, maxj\(\sum_{i}|A_{ij}|\); maxj\(\sum_{i}|A_{ij}|\); Square of the Euclidean norm,; \(\sum_{ji}(A_{ij}^{2})\); number of elements unequal zero; \(\sum_{ji}(A_{ij})\); minij \((A_{ij})\); maxij \((A_{ij})\). A.NormByColumn (v,""D""); A.NormByRow (v,""D""); TMatrixD; TMatrixD; \(A_{ij}/= \nu_i\), divide each matrix column by vector v. If the second argument is “M”, the column is multiplied.; \(A_{ij}/= \nu_j\), divide each matrix row by vector v. If the second argument is “M”, the row is multiplied. 14.4.5 Miscellaneous Operators. Format; Output; Description. A.Zero(); TMatrixX; \(",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:785163,Availability,avail,available,785163," how the classes access different parts of the matrix:. class; view. TMatrixDRow const(X,i) TMatrixDRow(X,i); \[ \left(\begin{array}{ccccc}; x_{00} & & & & x_{0n} \\; & & & & \\; x_{i0} & ... & x_{ij} & ... & x_{in} \\; & & & & \\; x_{n0} & & & & x_{nn}; \end{array}\right)\]. TMatrixDColumn const(X,j) TMatrixDColumn(X,j); \[ \left(\begin{array}{ccccc}; x_{00} & & x_{0j} & & x_{0n} \\; & & ... & & \\; & & x_{ij} & & \\; & & ... & & \\; x_{n0} & & x_{nj} & & x_{nn}; \end{array}\right)\]. TMatrixDDiag const(X) TMatrixDDiag(X); \[ \left(\begin{array}{ccccc}; x_{00} & & & & x_{0n} \\; & ... & & & \\; & & ... & & \\; & & & ... & \\; x_{n0} & & & & x_{nn}; \end{array}\right)\]. TMatrixDSub const(X,i,l,j,k) TMatrixDSub(X,i,l,j,k); \[ \left(\begin{array}{ccccc}; x_{00} & & & & x_{0n} \\; & & & & \\; & & x_{ij} & ... & x_{ik} \\; & & x_{lj} & ... & x_{lk} \\; x_{n0} & & & & x_{nn}; \end{array}\right)\]. 14.5.1 View Operators; For the matrix views TMatrixDRow, TMatrixDColumn and TMatrixDDiag, the necessary assignment operators are available to interact with the vector class TVectorD. The sub matrix view TMatrixDSub has links to the matrix classes TMatrixD and TMatrixDSym. The next table summarizes how the access individual matrix elements in the matrix views:. Format; Comment. TMatrixDRow(A,i)(j) TMatrixDRow(A,i)[j]; element \(A_{ij}\). TMatrixDColumn(A,j)(i) TMatrixDColumn(A,j)[i]; element \(A_{ij}\). TMatrixDDiag(A(i) TMatrixDDiag(A[i]; element \(A_{ij}\). TMatrixDSub(A(i) TMatrixDSub(A,rl,rh,cl,ch)(i,j); element \(A_{ij}\); element \(A_{rl+i,cl+j}\). The next two tables show the possible operations with real numbers, and the operations between the matrix views:. Description; Format; Comment. assign real; TMatrixDRow(A,i) = r; row \(i\). TMatrixDColumn(A,j) = r; column \(j\). TMatrixDDiag(A) = r; matrix diagonal. TMatrixDSub(A,i,l,j,k) = r; sub matrix. add real; TMatrixDRow(A,i) += r; row \(i\). TMatrixDColumn(A,j) += r; column \(j\). TMatrixDDiag(A) += r; matrix diagonal. TM",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:792563,Availability,toler,tolerance,792563," does not have to worry about the decomposition step before calling a solve method, because the decomposition class checks before invoking Solve that the matrix has been decomposed.; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; lu.Solve(b,ok);; In the next example, we show again the same decomposition but now performed in a loop and all necessary steps are manually invoked. This example also demonstrates another very important point concerning memory management! Note that the vector, matrix and decomposition class are constructed outside the loop since the dimensions of vector/matrix are constant. If we would have replaced lu.SetMatrix(a) by TDecompLU lu(a), we would construct/deconstruct the array elements of lu on the stack.; TVectorD b(n);; TMatrixD a(n,n);; TDecompLU lu(n);; Bool_t ok;; for (....) {; b = ..;; a = ..;; lu.SetMatrix(a);; lu.Decompose();; lu.Solve(b,ok);; }; 14.6.1 Tolerances and Scaling; The tolerance parameter fTol (a member of the base class TDecompBase) plays a crucial role in all operations of the decomposition classes. It gives the user a tool to monitor and steer the operations its default value is \(\varepsilon\) where \(1+\varepsilon=1\).; If you do not want to be bothered by the following considerations, like in most other linear algebra packages, just set the tolerance with SetTol to an arbitrary small number. The tolerance number is used by each decomposition method to decide whether the matrix is near singular, except of course SVD that can handle singular matrices. This will be checked in a different way for any decomposition. For instance in LU, a matrix is considered singular in the solving stage when a diagonal element of the decomposed matrix is smaller than fTol. Here an important point is raised. The Decompose() method is successful as long no zero diagonal element is encountered. Therefore, the user could perform decomposition and only after this step worry about the tolerance number.; If the matrix is f",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:792948,Availability,toler,tolerance,792948,"ow again the same decomposition but now performed in a loop and all necessary steps are manually invoked. This example also demonstrates another very important point concerning memory management! Note that the vector, matrix and decomposition class are constructed outside the loop since the dimensions of vector/matrix are constant. If we would have replaced lu.SetMatrix(a) by TDecompLU lu(a), we would construct/deconstruct the array elements of lu on the stack.; TVectorD b(n);; TMatrixD a(n,n);; TDecompLU lu(n);; Bool_t ok;; for (....) {; b = ..;; a = ..;; lu.SetMatrix(a);; lu.Decompose();; lu.Solve(b,ok);; }; 14.6.1 Tolerances and Scaling; The tolerance parameter fTol (a member of the base class TDecompBase) plays a crucial role in all operations of the decomposition classes. It gives the user a tool to monitor and steer the operations its default value is \(\varepsilon\) where \(1+\varepsilon=1\).; If you do not want to be bothered by the following considerations, like in most other linear algebra packages, just set the tolerance with SetTol to an arbitrary small number. The tolerance number is used by each decomposition method to decide whether the matrix is near singular, except of course SVD that can handle singular matrices. This will be checked in a different way for any decomposition. For instance in LU, a matrix is considered singular in the solving stage when a diagonal element of the decomposed matrix is smaller than fTol. Here an important point is raised. The Decompose() method is successful as long no zero diagonal element is encountered. Therefore, the user could perform decomposition and only after this step worry about the tolerance number.; If the matrix is flagged as being singular, operations with the decomposition will fail and will return matrices or vectors that are invalid. If one would like to monitor the tolerance parameter but not have the code stop in case of a number smaller than fTol, one could proceed as follows:; TVectorD b = ..;; TMat",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:793004,Availability,toler,tolerance,793004,"cerning memory management! Note that the vector, matrix and decomposition class are constructed outside the loop since the dimensions of vector/matrix are constant. If we would have replaced lu.SetMatrix(a) by TDecompLU lu(a), we would construct/deconstruct the array elements of lu on the stack.; TVectorD b(n);; TMatrixD a(n,n);; TDecompLU lu(n);; Bool_t ok;; for (....) {; b = ..;; a = ..;; lu.SetMatrix(a);; lu.Decompose();; lu.Solve(b,ok);; }; 14.6.1 Tolerances and Scaling; The tolerance parameter fTol (a member of the base class TDecompBase) plays a crucial role in all operations of the decomposition classes. It gives the user a tool to monitor and steer the operations its default value is \(\varepsilon\) where \(1+\varepsilon=1\).; If you do not want to be bothered by the following considerations, like in most other linear algebra packages, just set the tolerance with SetTol to an arbitrary small number. The tolerance number is used by each decomposition method to decide whether the matrix is near singular, except of course SVD that can handle singular matrices. This will be checked in a different way for any decomposition. For instance in LU, a matrix is considered singular in the solving stage when a diagonal element of the decomposed matrix is smaller than fTol. Here an important point is raised. The Decompose() method is successful as long no zero diagonal element is encountered. Therefore, the user could perform decomposition and only after this step worry about the tolerance number.; If the matrix is flagged as being singular, operations with the decomposition will fail and will return matrices or vectors that are invalid. If one would like to monitor the tolerance parameter but not have the code stop in case of a number smaller than fTol, one could proceed as follows:; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; TVectorD x = lu.Solve(b,ok);; Int_t nr = 0;; while (!ok) {; lu.SetMatrix(a);; lu.SetTol(0.1*lu.GetTol());; if (nr++ > 10) ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:793578,Availability,toler,tolerance,793578,"nces and Scaling; The tolerance parameter fTol (a member of the base class TDecompBase) plays a crucial role in all operations of the decomposition classes. It gives the user a tool to monitor and steer the operations its default value is \(\varepsilon\) where \(1+\varepsilon=1\).; If you do not want to be bothered by the following considerations, like in most other linear algebra packages, just set the tolerance with SetTol to an arbitrary small number. The tolerance number is used by each decomposition method to decide whether the matrix is near singular, except of course SVD that can handle singular matrices. This will be checked in a different way for any decomposition. For instance in LU, a matrix is considered singular in the solving stage when a diagonal element of the decomposed matrix is smaller than fTol. Here an important point is raised. The Decompose() method is successful as long no zero diagonal element is encountered. Therefore, the user could perform decomposition and only after this step worry about the tolerance number.; If the matrix is flagged as being singular, operations with the decomposition will fail and will return matrices or vectors that are invalid. If one would like to monitor the tolerance parameter but not have the code stop in case of a number smaller than fTol, one could proceed as follows:; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; TVectorD x = lu.Solve(b,ok);; Int_t nr = 0;; while (!ok) {; lu.SetMatrix(a);; lu.SetTol(0.1*lu.GetTol());; if (nr++ > 10) break;; x = lu.Solve(b,ok);; }; if (x.IsValid()); cout << ""solved with tol ="" << lu.GetTol() << endl;; else; cout << ""solving failed "" << endl;; The observant reader will notice that by scaling the complete matrix by some small number the decomposition will detect a singular matrix. In this case, the user will have to reduce the tolerance number by this factor. (For CPU time saving we decided not to make this an automatic procedure).; 14.6.2 Condition number",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:793772,Availability,toler,tolerance,793772,").; If you do not want to be bothered by the following considerations, like in most other linear algebra packages, just set the tolerance with SetTol to an arbitrary small number. The tolerance number is used by each decomposition method to decide whether the matrix is near singular, except of course SVD that can handle singular matrices. This will be checked in a different way for any decomposition. For instance in LU, a matrix is considered singular in the solving stage when a diagonal element of the decomposed matrix is smaller than fTol. Here an important point is raised. The Decompose() method is successful as long no zero diagonal element is encountered. Therefore, the user could perform decomposition and only after this step worry about the tolerance number.; If the matrix is flagged as being singular, operations with the decomposition will fail and will return matrices or vectors that are invalid. If one would like to monitor the tolerance parameter but not have the code stop in case of a number smaller than fTol, one could proceed as follows:; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; TVectorD x = lu.Solve(b,ok);; Int_t nr = 0;; while (!ok) {; lu.SetMatrix(a);; lu.SetTol(0.1*lu.GetTol());; if (nr++ > 10) break;; x = lu.Solve(b,ok);; }; if (x.IsValid()); cout << ""solved with tol ="" << lu.GetTol() << endl;; else; cout << ""solving failed "" << endl;; The observant reader will notice that by scaling the complete matrix by some small number the decomposition will detect a singular matrix. In this case, the user will have to reduce the tolerance number by this factor. (For CPU time saving we decided not to make this an automatic procedure).; 14.6.2 Condition number; The numerical accuracy of the solution x in Ax = b can be accurately estimated by calculating the condition number k of matrix \(A\), which is defined as:; \(k = ||A||_{1}||A^{-1}||_{1}\) where \(||A||_{1} = \underset{j}{max}(\sum_{i}|A_{ij}|)\); A good rule of thumb is that i",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:794411,Availability,toler,tolerance,794411,"The Decompose() method is successful as long no zero diagonal element is encountered. Therefore, the user could perform decomposition and only after this step worry about the tolerance number.; If the matrix is flagged as being singular, operations with the decomposition will fail and will return matrices or vectors that are invalid. If one would like to monitor the tolerance parameter but not have the code stop in case of a number smaller than fTol, one could proceed as follows:; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; TVectorD x = lu.Solve(b,ok);; Int_t nr = 0;; while (!ok) {; lu.SetMatrix(a);; lu.SetTol(0.1*lu.GetTol());; if (nr++ > 10) break;; x = lu.Solve(b,ok);; }; if (x.IsValid()); cout << ""solved with tol ="" << lu.GetTol() << endl;; else; cout << ""solving failed "" << endl;; The observant reader will notice that by scaling the complete matrix by some small number the decomposition will detect a singular matrix. In this case, the user will have to reduce the tolerance number by this factor. (For CPU time saving we decided not to make this an automatic procedure).; 14.6.2 Condition number; The numerical accuracy of the solution x in Ax = b can be accurately estimated by calculating the condition number k of matrix \(A\), which is defined as:; \(k = ||A||_{1}||A^{-1}||_{1}\) where \(||A||_{1} = \underset{j}{max}(\sum_{i}|A_{ij}|)\); A good rule of thumb is that if the matrix condition number is 10n, the accuracy in x is 15 - n digits for double precision.; Hager devised an iterative method (W.W. Hager, Condition estimators, SIAM J. Sci. Stat. Comp., 5 (1984), pp. 311-316) to determine \(||A^{-1}||_{1}\) without actually having to calculate \(A^{-1}\). It is used when calling Condition().; A code example below shows the usage of the condition number. The matrix \(A\) is a (10x10) Hilbert matrix that is badly conditioned as its determinant shows. We construct a vector b by summing the matrix rows. Therefore, the components of the solut",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:803433,Availability,error,errors,803433,"of filling its pipe. \(A^{-1}\) Here, the time is measured for an in-place matrix inversion. Except for ROOT v3.10, the algorithms are all based on an LUfactorization followed by forward/back-substitution. ROOT v3.10 is using the slower Gaussian elimination method. The numerical accuracy of the CLHEP routine is poor:. up to 6x6 the numerical imprecise Cramer multiplication is hard-coded. For instance, calculating U=H*H-1, where H is a (5x5) Hilbert matrix, results in off-diagonal elements of \(10^{-7}\) instead of the \(10^{-13}\) using an LUaccording to Crout.; scaling protection is non-existent and limits are hard-coded, as a consequence inversion of a Hilbert matrix for sizes>(12x12) fails. In order to gain speed the CLHEP algorithm stores its permutation info of the pivots points in a static array, making multi-threading not possible. GSL uses LU decomposition without the implicit scaling of Crout. Therefore, its accuracy is not as good. For instance a (10x10) Hilbert matrix has errors 10 times larger than the LU Crout result. In ROOT v4.0, the user can choose between the Invert() and IvertFast() routines, where the latter is using the Cramer algorithm for sizes<7x7. The speed graph shows the result for InvertFast(). A*x=b the execution time is measured for solving the linear equation A*x=b. The same factorizations are used as in the matrix inversion. However, only 1 forward/back-substitution has to be used instead of msize as in the inversion of (msize x msize) matrix. As a consequence the same differences are observed but less amplified. CLHEP shows the same numerical issues as in step the matrix inversion. Since ROOT3.10 has no dedicated equation solver, the solution is calculated through x=A-1*b. This will be slower and numerically not as stable.; \((A^{T}*A)^{-1}*A^{T}\) timing results for calculation of the pseudo inverse of matrix a. The sequence of operations measures the impact of several calls to constructors and destructors in the C++ packages versus a",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:804743,Availability,error,error,804743,"ear equation A*x=b. The same factorizations are used as in the matrix inversion. However, only 1 forward/back-substitution has to be used instead of msize as in the inversion of (msize x msize) matrix. As a consequence the same differences are observed but less amplified. CLHEP shows the same numerical issues as in step the matrix inversion. Since ROOT3.10 has no dedicated equation solver, the solution is calculated through x=A-1*b. This will be slower and numerically not as stable.; \((A^{T}*A)^{-1}*A^{T}\) timing results for calculation of the pseudo inverse of matrix a. The sequence of operations measures the impact of several calls to constructors and destructors in the C++ packages versus a C library like GSL. Speed comparison between the different matrix packages. 15 Adding a Class; 15.1 The Role of TObject; The light-weight TObject class provides the default behavior and protocol for the objects in the ROOT system. Specifically, it is the primary interface to classes providing object I/O, error handling, inspection, introspection, and drawing. The interface to this service is via abstract classes.; 15.1.1 Introspection, Reflection and Run Time Type Identification; Introspection, which is also referred to as reflection, or run time type identification (RTTI) is the ability of a class to reflect upon itself or to ""look inside itself. ROOT implements reflection with the TClass class. It provides all the information about a class, a full description of data members and methods, including the comment field and the method parameter types. A class with the ClassDef macro has the ability to obtain a TClass with the IsA method.; TClass *cl = obj->IsA();; It returns a TClass. In addition, an object can directly get the class name and the base classes by:; const char* name = obj->ClassName();; If the class is a descendent of TObject, you can check if an object inherits from a specific class, you can use the InheritsFrom method. This method returns kTrue if the object inh",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:809774,Availability,mask,mask,809774,"he event status in a canvas. To show the event status window, select the Options menu and the EventStatus item. This method returns a string of information about the object at position (x, y). Every time the cursor moves, the object under the cursor executes the GetObjectInfo method. The string is then shown in the status bar. There is a default implementation in TObject, but it is typically overridden for classes that can report peculiarities for different cursor positions (for example the bin contents in a TH1).; 15.1.9 IsFolder; By default an object inheriting from TObject is not brows-able, because TObject::IsFolder() returns kFALSE. To make a class browse-able, the IsFolder method needs to be overridden to return kTRUE. In general, this method returns kTRUE if the object contains browse-able objects (like containers or lists of other objects).; 15.1.10 Bit Masks and Unique ID; A TObject descendent inherits two data members: fBits and fUniqueID. fBitsis 32-bit data member used with a bit mask to get object information. Bits 0 - 13 are reserved as global bits, bits 14 - 23 can be used in different class hierarchies.; enum EObjBits {; kCanDelete = BIT(0), // if can be deleted; kMustCleanup = BIT(3), // if destructor must call RecursiveRemove(); kObjInCanvas = BIT(3), // for backward compatibility only; kIsReferenced = BIT(4), // if referenced by TRef or TRefArray; kHasUUID = BIT(5), // if has a TUUID, fUniqueID=UUIDNumber; kCannotPick = BIT(6), // if cannot be picked in a pad; kNoContextMenu = BIT(8), // if does not want a context menu; kInvalidObject = BIT(13) // object ctor succeeded but the object should not be used; };; For example, the bits kMustCleanup and kCanDelete are used in TObject. See “The kCanDelete Bit” and “The kMustCleanup Bit”. They can be set by any object and should not be reused. Make sure not to overlap them in any given hierarchy. The bit 13 (kInvalidObject) is set when an object could not be read from a ROOT file. It will check this bit and ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:813149,Availability,error,error,813149,"lassDef(ClassName,ClassVersionID); //The class title; For example in TLine.h we have:; ClassDef(TLine,1); //A line segment; The ClassVersionID is used by the ROOT I/O system. It is written on the output stream and during reading you can check this version ID and take appropriate action depending on the value of the ID. See “Streamers”. Every time you change the data members of a class, you should increase its ClassVersionID by one. The ClassVersionID should be >=1. Set ClassVersionID=0 in case you don’t need object I/O. To be able to generate properly documentation for your classes using THtml you must add the statement:; ClassImp(ClassName); For example in TLine.cxx:; ClassImp(TLine); Note that you should provide a default constructor for your classes, i.e. a constructor with zero parameters or with one or more parameters all with default values in case you want to use object I/O. If do not provide such a default constructor, you MUST implement an I/O constructor. If not you will get a compile time error. See the “The Default Constructor” paragraph in this chapter. The ClassDef and ClassImp macros are defined in the file Rtypes.h. This file is referenced by all ROOT include files, so you will automatically get them if you use a ROOT include file.; 15.2.1 Template Support; In ROOT version 3.03 and older, ROOT provided special ClassDef and ClassImp macros for classes with two and three template arguments. In ROOT version 3.04 and above, the macros ClassDef and ClassImp can be used directly even for a class template. ClassImp is used to register an implementation file in a class. For class templates, the ClassImp can only be used for a specific class template instance.; ClassImp(MyClass1<double>);; For multiple template arguments, you will need to use an intermediary typedef:; typedef MyClass2<int,float> myc_i_f;; ClassImp(myc_i_f);; You can also register an implementation for all instances of a class template by using templateClassImp:; templateClassImp(MyClass3);; H",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:824018,Availability,avail,available,824018,"You must provide a default constructor or an I/O constructor for your class. See the “The Default Constructor” paragraph in this chapter.; #include <iostream.h>; #include ""TObject.h""; class SClass : public TObject {; private:; Float_t fX; //x position in centimeters; Float_t fY; //y position in centimeters; Int_t fTempValue; //! temporary state value; public:; SClass() { fX = fY = -1; }; void Print() const;; void SetX(float x) { fX = x; }; void SetY(float y) { fY = y; }. ClassDef(SClass, 1); };; Step 2: Add a call to the ClassDef macro to at the end of the class definition (in the SClass.h file). ClassDef(SClass,1). Add a call to the ClassImp macro in the implementation file (SClass.cxx): ClassImp(SClass).; // SClass.cxx:; #include ""SClass.h""; ClassImp(SClass);; void SClass::Print() const {; cout << ""fX = "" << fX << "", fY = "" << fY << endl;; }; You can add a class without using the ClassDef and ClassImp macros; however, you will be limited. Specifically the object I/O features of ROOT will not be available to you for these classes. See “Cling the C++ Interpreter”. The ShowMembers and Streamer method, as well as the >> operator overloads, are implemented only if you use ClassDef and ClassImp. See $ROOTSYS/include/Rtypes.h for the definition of ClassDef and ClassImp. To exclude a data member from the Streamer, add a ! as the first character in the comments of the field:; Int_t fTempValue; //! temporary state value; 15.5.1 The LinkDef.h File; Step 3: The LinkDef.h file tells rootcling which classes should be added to the dictionary.; #ifdef __CLING__; #pragma link C++ class SClass;; #endif; Three options can trail the class name:. - : tells rootcling not to generate the Streamer method for this class. This is necessary for those classes that need a customized Streamer method. #pragma link C++ class SClass-; // no streamer. ! : tells rootcling not to generate the operator>>(TBuffer &b,MyClass *&obj) method for this class. This is necessary to be able to write pointers to",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:825366,Availability,error,error,825366,"ter in the comments of the field:; Int_t fTempValue; //! temporary state value; 15.5.1 The LinkDef.h File; Step 3: The LinkDef.h file tells rootcling which classes should be added to the dictionary.; #ifdef __CLING__; #pragma link C++ class SClass;; #endif; Three options can trail the class name:. - : tells rootcling not to generate the Streamer method for this class. This is necessary for those classes that need a customized Streamer method. #pragma link C++ class SClass-; // no streamer. ! : tells rootcling not to generate the operator>>(TBuffer &b,MyClass *&obj) method for this class. This is necessary to be able to write pointers to objects of classes not inheriting from TObject. #pragma link C++ class SClass!; // no >> operator; // or; #pragma link C++ class SClass-!; // no streamer, no >> operator. + : in ROOT version 1 and 2 tells rootcling to generate a Streamer with extra byte count information. This adds an integer to each object in the output buffer, but it allows for powerful error correction in case a Streamer method is out of sync with data in the file. The + option is mutual exclusive with both the - and ! options. IMPORTANT NOTE: In ROOT Version 3 and later, a “+” after the class name tells rootcling to use the new I/O system. The byte count check is always added. The new I/O system has many advantages including support automatic schema evolution, full support for STL collections and better run-time performance. We strongly recommend using it.; #pragma link C++ class SClass+; // add byte count; For information on Streamers see “Input/Output”. To get help on rootcling type on the UNIX command line: rootcling -h; 15.5.1.1 The Order Matters; When using template classes, the order of the pragma statements matters. For example, here is a template class Tmpl and a normal class Norm, which holds a specialized instance of a Tmpl:; class Norm {; private:; Tmpl<int>* fIntTmpl;; public:; ...; };; Then in Linkdef.h, the pragma statements must be ordered by listi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:827049,Availability,error,error,827049,"s; When using template classes, the order of the pragma statements matters. For example, here is a template class Tmpl and a normal class Norm, which holds a specialized instance of a Tmpl:; class Norm {; private:; Tmpl<int>* fIntTmpl;; public:; ...; };; Then in Linkdef.h, the pragma statements must be ordered by listing all specializations before any classes that need them:; // Correct Linkdef.h ordering; ...; #pragma link C++ class Tmpl<int>;; #pragma link C++ class Norm;; ...; And not vice versa:; // Bad Linkdef.h ordering; ...; #pragma link C++ class Norm;; #pragma link C++ class Tmpl<int>;; ...; In this case, rootcling generates Norm::Streamer() that makes reference to Tmpl<int>::Streamer(). Then rootcling gets to process Tmpl<int> and generates a specialized Tmpl<int>::Streamer() function. The problem is, when the compiler finds the first Tmpl<int>::Streamer(), it will instantiate it. However, later in the file it finds the specialized version that rootcling generated. This causes the error. However, if the Linkdef.h order is reversed then rootcling can generate the specialized Tmpl<int>::Streamer() before it is needed (and thus never instantiated by the compiler).; 15.5.1.2 Other Useful Pragma Statements; The complete list of pragma statements currently supported by Cling is:; #pragma link [C|C++|off] all [class|function|global|typedef];; #pragma link [C|C++|off]; [class|struct|union|enum|namespace|protected][name];; #pragma link [C|C++|off] [global|typedef][name];; #pragma link [C|C++|off] [nestedclass|nestedtypedef];. #pragma link [C++|C|off|MACRO] function [name]<(argtypes)>;; #pragma link; [C++|C|off|MACRO] function [classname]::[name]<(argtypes)>;; #pragma link off all methods;; #pragma link [C|C++|off] defined_in [filename];; #pragma link; [C|C++|off] defined_in [class|struct|namespace] [name];; #pragma link [C|C++|off] all_function [classname];; #pragma link [C|C++|off] all_datamember [classname];; The [classname] and the [name] can also contain wildcar",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:837772,Availability,avail,available,837772,"ource and a pcm files. An exhaustive documentation of the CLI switches of genreflex can be inspected with the genreflex --help command.; The entity corresponding to the LinkDef file for genreflex is the selection XML file, also called selection XML or simply selection file. A selection XML file allows to describe a list of classes for which the dictionaries are to be created. In addition, it allows to specify properties of classes or data members, without the need to add comments in the source code. This is of primary importance when dictionaries must be created for classes residing in code which cannot be modified. For a complete description of the structure of the selection XML files and the way in which attributes can be set, refer to the genreflex --help command.; It is important to observe that selection XML files can be used in presence of rootcling invocations instead of LinkDef files.; 15.6.1 The ROOT::Meta::Selection namespace; Not only LinkDef and selection files allow to select the classes for which the dictionaries must be created: a third method is available. This is represented by the ROOT::Meta::Selection namespace. The idea behind this technique is that all the classes which are located in this special namespace are automatically selected for dictionary generation. All the properties and annotations allowed by LinkDef and selection XML files are possible. For a detailed documentation of the features of the ROOT::Meta::Selection namespace, refer to its online documentation.; 15.7 Adding a Class with ACLiC; Step 1: Define your class; #include ""TObject.h"". // define the ABC class and make it inherit from TObject so that; // we can write ABC to a ROOT file; class ABC : public TObject {. public:; Float_t a, b, c, p;; ABC() : a(0), b(0), c(0), p(0){};. // Define the class for the dictionary; ClassDef (ABC,1); };. // Call the ClassImp macro to give the ABC class RTTI and; // full I/O capabilities. #if !defined(__CLING__); ClassImp(ABC);; #endif; Step 2: Loa",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:842352,Availability,avail,available,842352," If a collection is deleted, its objects are not. The user can force a collection to delete its objects, but that is the user’s choice.; 16.1.2 Determining the Class of Contained Objects; Most containers may hold heterogeneous collections of objects and then it is left to the user to correctly cast the TObject pointer to the right class. Casting to the wrong class will give wrong results and may well crash the program! Therefore, the user has to be very careful. Often a container only contains one class of objects, but if it really contains a mixture, it is possible to ask each object about its class using the InheritsFrom method.; For example if myObject is a TObject pointer:; if (myObject->InheritsFrom(""TParticle"") {; printf(""myObject is a TParticlen"");; }; As the name suggests, this test works even if the object is a subclass of TParticle. The member function IsA() can be used instead of InheritsFrom to make the test exact. The InheritsFrom and IsA methods use the extensive Run Time Type Information (RTTI) available via the ROOT meta-classes.; 16.1.3 Types of Collections; The ROOT system implements the following basic types of collections: unordered collections, ordered collections and sorted collections. Next figure shows the inheritance hierarchy for the primary collection classes. All primary collection classes derive from the abstract base class TCollection. The inheritance hierarchy of the primary collection classes. 16.1.4 Ordered Collections (Sequences); Sequences are collections that are externally ordered because they maintain internal elements according to the order in which they were added. The following sequences are available:. TList; THashList; TOrdCollection; TObjArray; TClonesArray. The TOrdCollection, TObjArray as well as the TClonesArray can be sorted using their Sort() member function (for this, the stored objects must provide a comparison function by overriding TObject::Compare() and also must enable sorting by overriding TObject::IsSortable() ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:842987,Availability,avail,available,842987," if myObject is a TObject pointer:; if (myObject->InheritsFrom(""TParticle"") {; printf(""myObject is a TParticlen"");; }; As the name suggests, this test works even if the object is a subclass of TParticle. The member function IsA() can be used instead of InheritsFrom to make the test exact. The InheritsFrom and IsA methods use the extensive Run Time Type Information (RTTI) available via the ROOT meta-classes.; 16.1.3 Types of Collections; The ROOT system implements the following basic types of collections: unordered collections, ordered collections and sorted collections. Next figure shows the inheritance hierarchy for the primary collection classes. All primary collection classes derive from the abstract base class TCollection. The inheritance hierarchy of the primary collection classes. 16.1.4 Ordered Collections (Sequences); Sequences are collections that are externally ordered because they maintain internal elements according to the order in which they were added. The following sequences are available:. TList; THashList; TOrdCollection; TObjArray; TClonesArray. The TOrdCollection, TObjArray as well as the TClonesArray can be sorted using their Sort() member function (for this, the stored objects must provide a comparison function by overriding TObject::Compare() and also must enable sorting by overriding TObject::IsSortable() to return true). Ordered collections all derive from the abstract base class TSeqCollection. Sorted collections are ordered by an internal (automatic) sorting mechanism. The following sorted collections are available (the stored items must be sortable):. TSortedList; TBtree. Unordered collections don’t maintain the order in which the elements were added, i.e. when you iterate over an unordered collection, you are not likely to retrieve elements in the same order they were added to the collection. The following unordered collections are available:. THashTable; TMap. 16.2 Iterators: Processing a Collection; The concept of processing all the mem",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:843535,Availability,avail,available,843535,"ed collections. Next figure shows the inheritance hierarchy for the primary collection classes. All primary collection classes derive from the abstract base class TCollection. The inheritance hierarchy of the primary collection classes. 16.1.4 Ordered Collections (Sequences); Sequences are collections that are externally ordered because they maintain internal elements according to the order in which they were added. The following sequences are available:. TList; THashList; TOrdCollection; TObjArray; TClonesArray. The TOrdCollection, TObjArray as well as the TClonesArray can be sorted using their Sort() member function (for this, the stored objects must provide a comparison function by overriding TObject::Compare() and also must enable sorting by overriding TObject::IsSortable() to return true). Ordered collections all derive from the abstract base class TSeqCollection. Sorted collections are ordered by an internal (automatic) sorting mechanism. The following sorted collections are available (the stored items must be sortable):. TSortedList; TBtree. Unordered collections don’t maintain the order in which the elements were added, i.e. when you iterate over an unordered collection, you are not likely to retrieve elements in the same order they were added to the collection. The following unordered collections are available:. THashTable; TMap. 16.2 Iterators: Processing a Collection; The concept of processing all the members of a collection is generic, i.e. independent of any specific representation of a collection. To process each object in a collection one needs some type of cursor that is initialized and then steps over each member of the collection in turn. Collection objects could provide this service but there is a snag: as there is only one collection object per collection there would only be one cursor. Instead, to permit the use of as many cursors as required, they are made separate classes called iterator. For each collection class there is an associated iterato",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:843870,Availability,avail,available,843870,"rnally ordered because they maintain internal elements according to the order in which they were added. The following sequences are available:. TList; THashList; TOrdCollection; TObjArray; TClonesArray. The TOrdCollection, TObjArray as well as the TClonesArray can be sorted using their Sort() member function (for this, the stored objects must provide a comparison function by overriding TObject::Compare() and also must enable sorting by overriding TObject::IsSortable() to return true). Ordered collections all derive from the abstract base class TSeqCollection. Sorted collections are ordered by an internal (automatic) sorting mechanism. The following sorted collections are available (the stored items must be sortable):. TSortedList; TBtree. Unordered collections don’t maintain the order in which the elements were added, i.e. when you iterate over an unordered collection, you are not likely to retrieve elements in the same order they were added to the collection. The following unordered collections are available:. THashTable; TMap. 16.2 Iterators: Processing a Collection; The concept of processing all the members of a collection is generic, i.e. independent of any specific representation of a collection. To process each object in a collection one needs some type of cursor that is initialized and then steps over each member of the collection in turn. Collection objects could provide this service but there is a snag: as there is only one collection object per collection there would only be one cursor. Instead, to permit the use of as many cursors as required, they are made separate classes called iterator. For each collection class there is an associated iterator class that knows how to sequentially retrieve each member in turn. The relationship between a collection and its iterator is very close and may require that the iterator has full access to the collection (i.e. it is a friend class). In general iterator will be used via the TIter wrapper class. For example:. TLis",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:883193,Availability,avail,available,883193,"atically created. This method is therefore the key element for the creation of a hierarchical link between two volumes. As it will be described further on in this document, there are few other methods performing similar actions, but let us keep things simple for the time being. In addition, notice that there are some visualization-related calls in the example followed by a final TGeoVolume::Draw()call for the top volume. These are explained in details in the section “Visualization Settings and Attributes”. At this point, you will probably like to see how this geometry looks like. You just need to run the example and you will get the following picture that you can rotate using the mouse; or you can zoom / move it around (see what the Help menu of the GL window displays).; % root rootgeom.C. Now let us browse the hierarchy that was just created. Start a browser and double-click on the item simple1 representing the gGeoManager object. Note that right click opens the context menu of the manager class where several global methods are available.; root[] new TBrowser;. The folders Materials, Media and Local transformations are in fact the containers where the geometry manager stores the corresponding objects. The Illegal overlaps folder is empty but can be filled after performing a geometry validity check (see section: “Checking the Geometry”). If tracking is performed using TGeo, the folder Tracks might contain user-defined tracks that can be visualized/animated in the geometry context (see section: “Creating and Visualizing Tracks”). Since for the time being we are interested more in the geometrical hierarchy, we will focus on the last two displayed items TOPand TOP_1. These are the top volume and the corresponding top node in the hierarchy.; Double clicking on the TOP volume will unfold all different volumes contained by the top volume. In the right panel, we will see all the volumes contained by TOP (if the same is positioned 4 times we will get 4 identical items). Thi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:914884,Availability,down,down,914884,"nfinite and can be used only in Boolean operations that result in non-infinite composite shapes (see also “Composite Shapes” below). A half space has to be defined using the constructor:. TGeoHalfSpace (const char *name, Double_t *point[3],; Double_t *norm[3]);; 18.3.3 Composite Shapes; Composite shapes are Boolean combinations of two or more shape components. The supported Boolean operations are union (+), intersection (*) and subtraction(-). Composite shapes derive from the base TGeoShape class, therefore providing all shape features: computation of bounding box, finding if a given point is inside or outside the combination, as well as computing the distance to entering/exiting. They can be directly used for creating volumes or used in the definition of other composite shapes.; Composite shapes are provided in order to complement and extend the set of basic shape primitives. They have a binary tree internal structure, therefore all shape-related geometry queries are signals propagated from top level down to the final leaves, while the provided answers are assembled and interpreted back at top. This CSG (composite solid geometry) hierarchy is effective for small number of components, while performance drops dramatically for large structures. Building a complete geometry in this style is virtually possible but highly not recommended.; 18.3.3.1 The Structure of Composite Shapes; A composite shape can always be looked as the result of a Boolean operation between only two shape components. All information identifying these two components as well as their positions with respect to the frame of the composite is represented by an object called Boolean node. A composite shape has a pointer to such a Boolean node. Since the shape components may also be composites, they will also contain binary Boolean nodes branching out other two shapes in the hierarchy. Any such branch ends-up when the final leaves are no longer composite shapes, but basic primitives. The figure shows the ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:927516,Availability,error,error,927516,"contain the case-insensitive first 4 letters of the corresponding class name (e.g. “tubs” will match TGeoTubeSeg, “bbox” will match TGeoBBox); nmed: the medium number. This will create a special volume that will not be directly used in the geometry, but whenever positioned will require a list of actual parameters for the current shape that will be created in this process. Such volumes having shape parameters known only when used have to be positioned only with TGeoManager::Node() method (see ‘Creating and Positioning Volumes’).; Other case when shape parameterizations are quite useful is scaling geometry structures. Imagine that we would like to enlarge/shrink a detector structure on one or more axes. This happens quite often in real life and is handled by “fitting mother” parameters. This is accomplished by defining shapes with one or more invalid (negative) parameters. For instance, defining a box having dx=10., dy=10., and dz=-1 will not generate an error but will be interpreted in a different way: A special volume TGeoVolumeMulti will be created. Whenever positioned inside a mother volume, this will create a normal TGeoVolume object having as shape a box with dz fitting the corresponding dzof the mother shape. Generally, this type of parameterization is used when positioning volumes in containers having a matching shape, but it works also for most reasonable combinations.; 18.4 Geometry Creation; A given geometry can be built in various ways, but one has to follow some mandatory steps. Even if we might use some terms that will be explained later, here are few general rules:. Volumes need media and shapes in order to be created.; Both containers and contained volumes must be created before linking them together, and the relative transformation matrix must be provided.; Any volume have to be positioned somewhere otherwise it will not be considered as part of the geometry.; Visibility or tracking properties of volumes can be provided both at build time or after geo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:955635,Availability,error,error,955635," axis. The meaning of the axis index is the following: for all volumes having shapes like box, trd1, trd2, trap, gtraorpara -1, 2, 3 mean X, Y, Z; for tube, tubs, cone, cons -1 means Rxy, 2 means phi and 3 means Z; for pcon and pgon - 2 means phi and 3 means Z; for spheres 1 means Rand 2 means phi.; In fact, the division operation has the same effect as positioning volumes in a given order inside the divided container - the advantage being that the navigation in such a structure is much faster. When a volume is divided, a volume family corresponding to the slices is created. In case all slices can be represented by a single shape, only one volume is added to the family and positioned N times inside the divided volume, otherwise, each slice will be represented by a distinct volume in the family.; Divisions can be also performed in a given range of one axis. For that, one has to specify also the starting coordinate value and the step:; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N,start,step);; A check is always done on the resulting division range: if not fitting into the container limits, an error message is posted. If we will browse the divided volume we will notice that it will contain N nodes starting with index 1 up to N. The first one has the lower X limit at START position, while the last one will have the upper X limit at START+N*STEP. The resulting slices cannot be positioned inside another volume (they are by default positioned inside the divided one) but can be further divided and may contain other volumes:; TGeoVolume *slicey = slicex->Divide(""SLICEY"",2,N1);; slicey->AddNode(other_vol,index,some_matrix);; When doing that, we have to remember that SLICEY represents a family, therefore all members of the family will be divided on Y and the other volume will be added as node inside all.; In the example above all the resulting slices had the same shape as the divided volume (box). This is not always the case. For instance, dividing a volume with TUBE shape on ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:968012,Availability,error,error,968012,"The only data member is: Double_t fTranslation[3]. Translations can be added or subtracted. TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. Rotations (TGeoRotation class) represent a pure rotation. Data members are Double_t fRotationMatrix[3*3]. Rotations can be defined either by Euler angles, either, by GEANT3 angles:. TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi,theta,psi); // all angles in degrees; This represents the composition of: first a rotation about Z axis with angle phi, then a rotation with theta about the rotated X axis, and finally a rotation with psiabout the new Z axis.; r1->SetAngles(th1,phi1,th2,phi2,th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical angles of each axis of the rotated coordinate system with respect to the initial one. This construction allows definition of malformed rotations, e.g. not orthogonal. A check is performed and an error message is issued in this case.; Specific utilities: determinant, inverse. Scale transformations (TGeoScale class) - represent a scaled shrinking/enlargement, possibly different on all axes. Data members: Double_t fScale[3]. Not implemented yet.; Combined transformations - represent a rotation followed by a translation. Data members: Double_t fTranslation[3],TGeoRotation *fRotation. TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;; ...; TGeoCombiTrans *c1 = new TGeoCombiTrans(trans,rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). General transformations: (TGeoHMatrix class) represent combined transformations in any order.; Identity transformation: (TGeoIdentity class) is a generic identity transformation represented by a singleton class object gGeoIdentity. 18.4.4 Ownership of Geometry Objects; The class TGeoManager class contains the entire API needed for building and tracking geometry. It defines a global pointer gGeoManager in o",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:990039,Availability,avail,available,990039,"allows specifying if the step is limited by geometrical reasons (a boundary crossing) or is an arbitrary step. The flag cross can be used in case the step is made on a boundary and specifies if user wants to cross or not the boundary. The returned node represents the new current node after the step was made. Making a geometrically contained step with boundary crossing (is_geom=kTRUE, cross=kTRUE) - This is the default method behavior. In this case, the step size is supposed to be already set by a previous TGeoManager::FindNextBoundary() call. Due to floating-point boundary uncertainties, making a step corresponding exactly to the distance to next boundary does not insure boundary crossing. If the method is called with this purpose, an extra small step will be made in order to make the crossing the most probable event (epsil=10-6cm). Even with this extra small step cannot insure 100% boundary crossing for specific crossed shapes at big incident angles. After such a step is made, additional cross-checks become available:. gGeoManager->FindNextBoundary(pstep);; Double_t snext = gGeoManager->GetStep();; // The geometrical step is taken; TGeoNode *newNode = gGeoManager->Step();; // The step=snext+epsil is made; Bool_t hasCrossed = gGeoManager->IsEntering();; // Is the boundary crossed or not?; Bool_t isOnBoundary = gGeoManager->IsOnBoundary(); // The proposed; // geometrically limited step to be made was smaller; // than epsil value.; Bool_t isOutside = gGeoManager->IsOutside();; //Did we exit geometry ?; In case the desired end-point of the step should be in the same starting volume, the input flag cross should be set to kFALSE. In this case, the epsil value will be subtracted from the current step. Making a step of arbitrary value (is_geom=kFALSE, cross=no matter). In this case, the step to be made can be either resulting from a next computation, either set by hand:. gGeoManager->SetStep(stepvalue);; gGeoManager->Step(kFALSE);; The step value in this case will exactly ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:992540,Availability,avail,available,992540,"face. The modeller uses the following convention: we define as normal (\(\vec{n}\)) the unit vector perpendicular to a surface in the next crossing point, having the orientation such that: \(\vec{n}.\vec{d}>0\). Here \(\vec{d}\) represents the current direction. The next crossing point represents the point where a ray shot from the current point along the current direction crosses the surface.; Double_t *TGeoManager::FindNormal(Bool_t forward=kTRUE);; The method above computes the normal to the next crossed surface in forward or backward direction (i.e. the current one), assuming the state corresponding to a current arbitrary point is initialized. An example of usage of normal computation is ray tracing.; The two most important features of the geometrical modeller concerning tracking are scalability and performance as function of the total number of physical nodes. The first refers to the possibility to make use of the available memory resources and at the same time be able to resolve any geometrical query, while the second defines the capability of the modeller to respond quickly even for huge geometries. These parameters can become critical when simulating big experiments like those at LHC.; 18.5.8 Creating and Visualizing Tracks; In case the modeller is interfaced with a tracking engine, one might consider quite useful being able to store and visualize at least a part of the tracks in the context of the geometry. The base class TVirtualGeoTrack provides this functionality. It currently has one implementation inside the drawing package (TGeoTrack class). A track can be defined like:; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; Where: id is user-defined id of the track, pdg - pdg code, parent - a pointer to parent track, particle - a pointer to an arbitrary particle object (may be a TParticle).; A track has a list of daughters that have to be filled using the following method:; TVirtualGeoTrack *TVirtualGeoTrack::AddDaugh",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1000329,Availability,error,errors,1000329," than one node inside the same container. The owner of such regions cannot be determined based on hierarchical considerations; therefore they will be considered as belonging to the node from which the current track is coming from. When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker.**. Overlap checking. This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; Here precision represents the desired maximum accepted overlap value in centimeters (default value is 0.1). This tool checks all possible significant pairs of candidates inside a given volume (not declared as overlapping or division volumes). The check is performed by verifying the mesh representation of one candidate against the shape of the other. This sort of check cannot identify all possible overlapping topolog",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1001393,Availability,reliab,reliability,1001393,"inter classes and contains an automated overlap checker.**. Overlap checking. This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; Here precision represents the desired maximum accepted overlap value in centimeters (default value is 0.1). This tool checks all possible significant pairs of candidates inside a given volume (not declared as overlapping or division volumes). The check is performed by verifying the mesh representation of one candidate against the shape of the other. This sort of check cannot identify all possible overlapping topologies, but it works for more than 95% and is much faster than the usual shape-to-shape comparison. For a 100% reliability, one can perform the check at the level of a single volume by using option=“d” or option=“d<number>” to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is f",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1003542,Availability,down,down,1003542,"a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling gGeoManager->PrintOverlaps() prints the list of overlaps.; 18.6.2 Graphical Checking Methods. Safety computation checking. In order to check a given point, CheckPoint(x,y,z) method of TGeoManager draws the daughters of the volume containing the point one level down, printing the path to the deepest physical node holding this point. It also computes the closest distance to any boundary. Random points. A method to check the validity of a given geometry is shooting random points. This can be called with the method TGeoVolume::RandomPoints() and it draws a volume with the current visualization settings. Random points are generated in the bounding box of the drawn volume. The points are drawn with the color of their deepest container. Only points inside visible nodes are drawn. Random rays. A ray tracing method can be called TGeoVolume::RandomRays(). This shoots rays from a given point in the local reference frame with random directions. The intersections with displayed nodes appear as segments having the color of the touched node.; 18.7 The Drawing Package; The modeller provides a powerful drawing package, supporting several different options of visualization. A library separated from the main one provides all fu",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1004926,Availability,avail,available,1004926,"n volume. The points are drawn with the color of their deepest container. Only points inside visible nodes are drawn. Random rays. A ray tracing method can be called TGeoVolume::RandomRays(). This shoots rays from a given point in the local reference frame with random directions. The intersections with displayed nodes appear as segments having the color of the touched node.; 18.7 The Drawing Package; The modeller provides a powerful drawing package, supporting several different options of visualization. A library separated from the main one provides all functionality being linked with the underlying ROOT visualization system. This library is dynamically loaded by the plug-in manager only when drawing features are requested. The geometrical structures that can be visualized are volumes and volume hierarchies.; The main component of the visualization system is volume primitive painting in a ROOT pad. Starting from this one, several specific options or subsystems are available, like: X3D viewing using hidden line and surface removal algorithms, OpenGL viewing* or ray tracing.; The method TGeoManager::GetGeomPainter()loads the painting library in memory.; This is generally not needed since it is called automatically by TGeoVolume::Draw() as well as by few other methods setting visualization attributes.; 18.7.1 Drawing Volumes and Hierarchies of Volumes; The first thing one would like to do after building some geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; Doing this ensures that the original top-level volume of the geometry is drawn, even if another volume is currently the geometry root. OK, I suppose you already did that with your simple geometry and immediately noticed",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1006432,Availability,down,down,1006432," geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; Doing this ensures that the original top-level volume of the geometry is drawn, even if another volume is currently the geometry root. OK, I suppose you already did that with your simple geometry and immediately noticed a new ROOT canvas popping-up and having some more or less strange picture inside. Here are few questions that might come:; Q: “The picture is strangely rotated; where are the coordinate axes?”; A: If drawn in a new canvas, any view has some default viewpoint, center of view and size. One can then perform mouse/keyboard actions to change them:. Mouse left-click and drag will rotate the view;; Some keys can be pressed when the view canvas is selected: J/K zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes display as well as changing top or side viewpoints can be activated from the TView context menu: right-click on the picture when no object is selected;. Q: “Every line is black! I cannot figure out what is what…”; A: Volumes can have different colors (those known by ROOT of course). Think at using them after each volume creation: myvolume->SetLineColor(Int_t color); otherwise everything is by default black.; Q: “The top volume of my geometry is a box but I see only its content.”; A: By default the drawn volume is not displayed just because we do not want to hide its content when changing the view to HLR or solid mode. In order to see it in the default wire frame picture one has to call TGeoManager::SetTopVisible().; Q: “I do not see all volumes in my tree but just something inside.”; A: By default, TGeoVolume::Draw() paints the content of a given volume three levels down. You can chan",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1007358,Availability,down,down,1007358,"ag will rotate the view;; Some keys can be pressed when the view canvas is selected: J/K zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes display as well as changing top or side viewpoints can be activated from the TView context menu: right-click on the picture when no object is selected;. Q: “Every line is black! I cannot figure out what is what…”; A: Volumes can have different colors (those known by ROOT of course). Think at using them after each volume creation: myvolume->SetLineColor(Int_t color); otherwise everything is by default black.; Q: “The top volume of my geometry is a box but I see only its content.”; A: By default the drawn volume is not displayed just because we do not want to hide its content when changing the view to HLR or solid mode. In order to see it in the default wire frame picture one has to call TGeoManager::SetTopVisible().; Q: “I do not see all volumes in my tree but just something inside.”; A: By default, TGeoVolume::Draw() paints the content of a given volume three levels down. You can change this by using: gGeoManager::SetVisLevel(n);; Not only that, but none of the volumes at intermediate levels (0-2) are visible on the drawing unless they are final ‘leaves’ on their branch (e.g. have no other volumes positioned inside). This behavior is the default one and corresponds to ‘leaves’ global visualization mode (TGeoManager::fVisOption = 1). In order to see on the screen the intermediate containers, one can change this mode: gGeoManager->SetVisOption(0).; Q: “Volumes are highlighted when moving the mouse over their vertices. What does it mean?”; A: Indeed, moving the mouse close to some volume vertices selects it. By checking the Event Status entry in the root canvas Options menu, you will see exactly which is the selected node in the bottom right. Right-clicking when a volume is selected will open its context menu where several actions can be performed (e.g. drawing it).; Q: “OK, but now I do not want to see all th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1008673,Availability,avail,available,1008673,"the default one and corresponds to ‘leaves’ global visualization mode (TGeoManager::fVisOption = 1). In order to see on the screen the intermediate containers, one can change this mode: gGeoManager->SetVisOption(0).; Q: “Volumes are highlighted when moving the mouse over their vertices. What does it mean?”; A: Indeed, moving the mouse close to some volume vertices selects it. By checking the Event Status entry in the root canvas Options menu, you will see exactly which is the selected node in the bottom right. Right-clicking when a volume is selected will open its context menu where several actions can be performed (e.g. drawing it).; Q: “OK, but now I do not want to see all the geometry, but just a particular volume and its content. How can I do this?”; A: Once you have set a convenient global visualization option and level, what you need is just call the Draw() method of your interesting volume. You can do this either by interacting with the expanded tree of volumes in a ROOT browser (where the context menu of any volume is available), either by getting a pointer to it (e.g. by name): gGeoManager->GetVolume(""vol_name"")->Draw();; 18.7.2 Visualization Settings and Attributes; Supposing you now understand the basic things to do for drawing the geometry or parts of it, you still might be not happy and wishing to have more control on it. We will describe below how you can fine-tune some settings. Since the corresponding attributes are flags belonging to volume and node objects, you can change them at any time (even when the picture is already drawn) and see immediately the result.; 18.7.2.1 Colors and Line Styles; We have already described how to change the line colors for volumes. In fact, volume objects inherit from TAttLine class so the line style or width can also be changed:; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; When drawing in solid mode, the color of the drawn volume corresponds to the line color.; 18.7.2.2 V",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1010147,Availability,down,down,1010147,"me settings. Since the corresponding attributes are flags belonging to volume and node objects, you can change them at any time (even when the picture is already drawn) and see immediately the result.; 18.7.2.1 Colors and Line Styles; We have already described how to change the line colors for volumes. In fact, volume objects inherit from TAttLine class so the line style or width can also be changed:; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; When drawing in solid mode, the color of the drawn volume corresponds to the line color.; 18.7.2.2 Visibility Settings; The way geometry is build forces the definition of several volumes that does not represent real objects, but just virtual containers used for grouping and positioning volumes together. One would not want to see them in the picture. Since every volume is by default visible, one has to do this sort of tuning by its own:; myVolumeContainer->SetVisibility(kFALSE);; As described before, the drawing package supports two main global options: 1 (default) - only final volume leaves; 0 - all volumes down the drawn one appear on the screen. The global visible level put a limitation on the maximum applied depth. Combined with visibility settings per volume, these can tune quite well what should appear on the screen. However, there are situations when users want to see a volume branch displayed down to the maximum depth, keeping at the same time a limitation or even suppressing others. In order to accomplish that, one should use the volume attribute: Visible daughters. By default, all daughters of all volumes are displayed if there is no limitation related with their level depth with respect to the top drawn volume.; 18.7.3 Ray Tracing; Ray tracing is a quite known drawing technique based on tracking rays from the eye position through all pixels of a view port device. The pixel color is derived from the properties of the first crossed surface, according some illumination mo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1010445,Availability,down,down,1010445,"etLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; When drawing in solid mode, the color of the drawn volume corresponds to the line color.; 18.7.2.2 Visibility Settings; The way geometry is build forces the definition of several volumes that does not represent real objects, but just virtual containers used for grouping and positioning volumes together. One would not want to see them in the picture. Since every volume is by default visible, one has to do this sort of tuning by its own:; myVolumeContainer->SetVisibility(kFALSE);; As described before, the drawing package supports two main global options: 1 (default) - only final volume leaves; 0 - all volumes down the drawn one appear on the screen. The global visible level put a limitation on the maximum applied depth. Combined with visibility settings per volume, these can tune quite well what should appear on the screen. However, there are situations when users want to see a volume branch displayed down to the maximum depth, keeping at the same time a limitation or even suppressing others. In order to accomplish that, one should use the volume attribute: Visible daughters. By default, all daughters of all volumes are displayed if there is no limitation related with their level depth with respect to the top drawn volume.; 18.7.3 Ray Tracing; Ray tracing is a quite known drawing technique based on tracking rays from the eye position through all pixels of a view port device. The pixel color is derived from the properties of the first crossed surface, according some illumination model and material optical properties. While there are currently existing quite sophisticated ray tracing models, TGeo is currently using a very simple approach where the light source is matching the eye position (no shadows or back-tracing of the reflected ray). In future we are considering providing a base class in order to be able to derive more complex models.; Due to the fact that the number of rays that have ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1024243,Availability,down,down,1024243," the deepest node that geometrically contains P (in our case let us suppose it is B_3). Since a node is just a positioned volume, we can then get a pointer to the volume, medium or material objects related to it. Deepest means that B_3 still contains point P (as well as A_1 and TOP_1), but none of the daughters of volume B does. After finding out the node containing the particle, one can check if the geometry state is different compared to the last located point:; Bool_t *TGeoManager::IsSameLocation(); The algorithm for finding where a point is located in geometry is presented in the figure 17-36.; It always starts by checking if the last computed modeller state is the answer. This optimizes the search when continuously tracking a particle. The main actions performed are:. moving up and down in the logical node tree while updating the current node and its global matrix; converting the global position into the local frame of the current node/volume; checking whether the local position lies within the geometrical shape of the current volume - if this is the case continue the search downwards for the daughters of the current node, otherwise search upwards its containers until the top level is reached.; the number of candidate nodes to be checked at a given level is minimized by an additional optimization structure: voxels. This is effective even in case there is only one daughter of the current volume.; in case the current node is declared as possibly overlapping, the method FindInCluster() is invoked. This method checks all different possibilities within the cluster of overlapping candidates. One of the candidates is prioritized if one of the following conditions id fulfilled (in order):; Is declared as non-overlapping (these are anyway searched first); Has at least one daughter that contains the current point; Was already declared as containing the point at a previous step. Finding the location of a point in the geometry hierarchy. 18.10.2 Finding the Distance to Nex",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1024542,Availability,down,downwards,1024542," the deepest node that geometrically contains P (in our case let us suppose it is B_3). Since a node is just a positioned volume, we can then get a pointer to the volume, medium or material objects related to it. Deepest means that B_3 still contains point P (as well as A_1 and TOP_1), but none of the daughters of volume B does. After finding out the node containing the particle, one can check if the geometry state is different compared to the last located point:; Bool_t *TGeoManager::IsSameLocation(); The algorithm for finding where a point is located in geometry is presented in the figure 17-36.; It always starts by checking if the last computed modeller state is the answer. This optimizes the search when continuously tracking a particle. The main actions performed are:. moving up and down in the logical node tree while updating the current node and its global matrix; converting the global position into the local frame of the current node/volume; checking whether the local position lies within the geometrical shape of the current volume - if this is the case continue the search downwards for the daughters of the current node, otherwise search upwards its containers until the top level is reached.; the number of candidate nodes to be checked at a given level is minimized by an additional optimization structure: voxels. This is effective even in case there is only one daughter of the current volume.; in case the current node is declared as possibly overlapping, the method FindInCluster() is invoked. This method checks all different possibilities within the cluster of overlapping candidates. One of the candidates is prioritized if one of the following conditions id fulfilled (in order):; Is declared as non-overlapping (these are anyway searched first); Has at least one daughter that contains the current point; Was already declared as containing the point at a previous step. Finding the location of a point in the geometry hierarchy. 18.10.2 Finding the Distance to Nex",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1038562,Availability,down,down,1038562," are accessible within the geometry manager editor frame. Generally, if the new object that needs to be created does not depend on other objects, it will be built with a set of default parameters. This is the case for all shapes (except composite shapes) and matrices. For all the other objects the interface forces the selection of components before creating the object.; 18.11.5 Editing Volumes; Volumes are hierarchical components in the geometry, therefore their editor is more complex. It provides the following functionalities:. General. This category allows changing the name of the volume and selecting other shape or medium among existing ones.; Daughters. The category allows removing existing daughter nodes or adding new ones. The button “Position” allows editing the positioning matrix of a given node. . Visualization. This category allows changing the visibility of the edited volume or for its daughters, as well as other visualization settings. The radio button “All” allows viewing all volumes down to the selected depth. “Leaves” will draw only the deepest nodes that have the selected depth or lower level ones that have no daughters inside. “Only” will allow drawing only the edited volume. The check button “Raytrace” will just draw the current selection in solid mode using the ray-tracing algorithm provided by TGeo. . Division. Allows dividing the edited volume according a given pattern. The division axes that are allowed are presented in a radio-button group. The number entries labeled “From”, “Step” and “Nslices” correspond to the divisioning parameters on the selected axis. The range of the division is between start and start+ndiv*step values and its validity is checked upon changing one of the values. NOTE: When changing a value in a number entry by typing a number, press ENTER at the end to validate. This applies for taking into account and validation of any number change in the geometry editors.; 18.11.6 How to Create a Valid Geometry with Geometry Editors.",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1041866,Availability,avail,available,1041866,"e some hierarchy, one has to create several other volumes and the matrices to position them. Once this is done, use the volume editor interface to:. add/remove daughters, change shape, edit position of daughters; change visualization settings; divide the volume (only if there are no daughters yet). Close the geometry from the “General” category. 19 Python Interface. Python is a popular, open-source, dynamic programming language with an interactive interpreter. Its interoperability with other programming languages, both for extending Python as well as embedding it, is excellent and many existing third-party applications and libraries have therefore so-called “Python bindings.” PyROOT provides Python bindings for ROOT: it enables cross-calls from ROOT/Cling into Python and vice versa, the intermingling of the two interpreters, and the transport of user-level objects from one interpreter to the other. PyROOT enables access from ROOT to any application or library that itself has Python bindings, and it makes all ROOT functionality directly available from the python interpreter.; 19.1 PyROOT Overview; The Python scripting language is widely used for scientific programming, including high performance and distributed parallel code (see http://www.scipy.org). It is the second most popular scripting language (after Perl) and enjoys a wide-spread use as a “glue language”: practically every library and application these days comes with Python bindings (and if not, they can be easily written or generated).; PyROOT, a Python extension module, provides the bindings for the ROOT class library in a generic way using the Cling dictionary. This way, it allows the use of any ROOT classes from the Python interpreter, and thus the “glue-ing” of ROOT libraries with any non-ROOT library or applications that provide Python bindings. Further, PyROOT can be loaded into the Cling interpreter to allow (as of now still rudimentary) access to Python classes. The best way to understand the benefit",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1046594,Availability,avail,available,1046594,"ally on use, for older editions, the libPyROOT.so needs to be loaded first before use. It is possible to switch between interpreters by calling TPython::Prompt() on the ROOT side, while returning with ^D (EOF). State is preserved between successive switches, and string based cross calls can nest as long as shared resources are properly handled.; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; 19.1.4 Installation; There are several ways of obtaining PyROOT, and which is best depends on your specific situation. If you work at CERN, you can use the installation available on afs. Otherwise, you will want to build from source, as PyROOT is not build by default in the binaries distributed from the ROOT project site. If you download the ROOT binaries, take care to download and install the Python distribution from http://www.python.org/ against which they were built.; 19.1.4.1 Environment Settings; ROOT installations with the build of PyROOT enabled are available from the CERN afs cell /afs/cern.ch/sw/root/<version>/<platform>. To use them, simply modify your shell environment accordingly. For Unix:; export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH; export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH; export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH; For Windows:; set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%; set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%; where $ROOTSYS should be set to /afs/cern.ch/sw/root/<version>/<platform>, and PYTHONDIR to /afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform> with <version> and <platform>",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1046756,Availability,down,download,1046756,"ved between successive switches, and string based cross calls can nest as long as shared resources are properly handled.; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; 19.1.4 Installation; There are several ways of obtaining PyROOT, and which is best depends on your specific situation. If you work at CERN, you can use the installation available on afs. Otherwise, you will want to build from source, as PyROOT is not build by default in the binaries distributed from the ROOT project site. If you download the ROOT binaries, take care to download and install the Python distribution from http://www.python.org/ against which they were built.; 19.1.4.1 Environment Settings; ROOT installations with the build of PyROOT enabled are available from the CERN afs cell /afs/cern.ch/sw/root/<version>/<platform>. To use them, simply modify your shell environment accordingly. For Unix:; export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH; export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH; export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH; For Windows:; set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%; set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%; where $ROOTSYS should be set to /afs/cern.ch/sw/root/<version>/<platform>, and PYTHONDIR to /afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform> with <version> and <platform> as appropriate. Note that the latest version of Python is 2.4.1.; 19.1.4.2 Building from Source; The standard installation instructions for building ROOT from source apply, with the addition that the build of PyROOT needs to ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1046797,Availability,down,download,1046797,"ved between successive switches, and string based cross calls can nest as long as shared resources are properly handled.; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; 19.1.4 Installation; There are several ways of obtaining PyROOT, and which is best depends on your specific situation. If you work at CERN, you can use the installation available on afs. Otherwise, you will want to build from source, as PyROOT is not build by default in the binaries distributed from the ROOT project site. If you download the ROOT binaries, take care to download and install the Python distribution from http://www.python.org/ against which they were built.; 19.1.4.1 Environment Settings; ROOT installations with the build of PyROOT enabled are available from the CERN afs cell /afs/cern.ch/sw/root/<version>/<platform>. To use them, simply modify your shell environment accordingly. For Unix:; export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH; export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH; export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH; For Windows:; set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%; set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%; where $ROOTSYS should be set to /afs/cern.ch/sw/root/<version>/<platform>, and PYTHONDIR to /afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform> with <version> and <platform> as appropriate. Note that the latest version of Python is 2.4.1.; 19.1.4.2 Building from Source; The standard installation instructions for building ROOT from source apply, with the addition that the build of PyROOT needs to ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1046989,Availability,avail,available,1046989,"from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; 19.1.4 Installation; There are several ways of obtaining PyROOT, and which is best depends on your specific situation. If you work at CERN, you can use the installation available on afs. Otherwise, you will want to build from source, as PyROOT is not build by default in the binaries distributed from the ROOT project site. If you download the ROOT binaries, take care to download and install the Python distribution from http://www.python.org/ against which they were built.; 19.1.4.1 Environment Settings; ROOT installations with the build of PyROOT enabled are available from the CERN afs cell /afs/cern.ch/sw/root/<version>/<platform>. To use them, simply modify your shell environment accordingly. For Unix:; export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH; export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH; export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH; For Windows:; set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%; set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%; where $ROOTSYS should be set to /afs/cern.ch/sw/root/<version>/<platform>, and PYTHONDIR to /afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform> with <version> and <platform> as appropriate. Note that the latest version of Python is 2.4.1.; 19.1.4.2 Building from Source; The standard installation instructions for building ROOT from source apply, with the addition that the build of PyROOT needs to be enabled at the configuration step. First, follow the instructions for obtaining and unpacking the source, and setting up the build environment.; Then, use the follow",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1050643,Availability,avail,available,1050643,"OOTSYS entries are probably already there if you followed the standard instructions, and that the PYTHONDIR entries should be replaced as appropriate by your choice at configuration time, or be left out if you had the configuration script pick up them up from a default location.; 19.1.5 Using PyROOT; Since it is an extension module, the usage of PyROOT probably comes naturally if you’re used to Python. In general, PyROOT attempts to allow working in both Python and ROOT style, and although it is succeeding, it isn’t perfect: there are edges. The following sections explain in some detail what you can expect, and what you need to watch out for.; 19.1.5.1 Access to ROOT Classes; Before a ROOT class can be used from Python, its dictionary needs to be loaded into the current process. Starting with ROOT version 4.00/06, this happens automatically for all classes that are declared to the auto-loading mechanism through so-called rootmap files. Effectively, this means that all classes in the ROOT distributions are directly available for import. For example:; from ROOT import TCanvas # available at startup; c = TCanvas(). from ROOT import TLorentzVector # triggers auto-load of libPhysics; l = TLorentzVector(); Although it is not recommended, a simple way of working with PyROOT is doing a global import:; from ROOT import *. c = TCanvas(); l = TLorentzVector(); Keeping the ROOT namespace (“import ROOT”), or only importing from ROOT those classes that you will actually use (see above), however, will always be cleaner and clearer:; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); Since it is foreseen that most people will use the simple approach anyway, the request to copy all from module ROOT will not actually result in copying all ROOT classes into the current namespace. Instead, classes will still be bound (and possibly loaded) on an as-needed basis. Note carefully how this is different from other Python (extension) modules, and what to expect if you use the normal ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1050706,Availability,avail,available,1050706,"hat the PYTHONDIR entries should be replaced as appropriate by your choice at configuration time, or be left out if you had the configuration script pick up them up from a default location.; 19.1.5 Using PyROOT; Since it is an extension module, the usage of PyROOT probably comes naturally if you’re used to Python. In general, PyROOT attempts to allow working in both Python and ROOT style, and although it is succeeding, it isn’t perfect: there are edges. The following sections explain in some detail what you can expect, and what you need to watch out for.; 19.1.5.1 Access to ROOT Classes; Before a ROOT class can be used from Python, its dictionary needs to be loaded into the current process. Starting with ROOT version 4.00/06, this happens automatically for all classes that are declared to the auto-loading mechanism through so-called rootmap files. Effectively, this means that all classes in the ROOT distributions are directly available for import. For example:; from ROOT import TCanvas # available at startup; c = TCanvas(). from ROOT import TLorentzVector # triggers auto-load of libPhysics; l = TLorentzVector(); Although it is not recommended, a simple way of working with PyROOT is doing a global import:; from ROOT import *. c = TCanvas(); l = TLorentzVector(); Keeping the ROOT namespace (“import ROOT”), or only importing from ROOT those classes that you will actually use (see above), however, will always be cleaner and clearer:; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); Since it is foreseen that most people will use the simple approach anyway, the request to copy all from module ROOT will not actually result in copying all ROOT classes into the current namespace. Instead, classes will still be bound (and possibly loaded) on an as-needed basis. Note carefully how this is different from other Python (extension) modules, and what to expect if you use the normal inspection tools (such as e.g. ‘dir()’). This feature prevents the inspection tools from b",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1051856,Availability,avail,available,1051856,"s not recommended, a simple way of working with PyROOT is doing a global import:; from ROOT import *. c = TCanvas(); l = TLorentzVector(); Keeping the ROOT namespace (“import ROOT”), or only importing from ROOT those classes that you will actually use (see above), however, will always be cleaner and clearer:; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); Since it is foreseen that most people will use the simple approach anyway, the request to copy all from module ROOT will not actually result in copying all ROOT classes into the current namespace. Instead, classes will still be bound (and possibly loaded) on an as-needed basis. Note carefully how this is different from other Python (extension) modules, and what to expect if you use the normal inspection tools (such as e.g. ‘dir()’). This feature prevents the inspection tools from being swamped by an enormous amount of classes, but they can no longer be used to explore unknown parts of the system (e.g. to find out which classes are available). Furthermore, because of this approach, <tab>-completion will usually not be available until after the first use (and hence creation) of a class.; Access to class static functions, public data members, enums, etc. is as expected. Many more example uses of ROOT classes from Python can be found in the tutorials directory in the ROOT distribution. The recipes section contains a description on working with your own classes (see “Using Your Own Classes”).; 19.1.5.2 Access to STL Classes; The STL classes live in the ROOT.std namespace (or, if you prefer to get them from there, in the ROOT module directly, but doing so makes the code less clear, of course). Be careful in their use, because Python already has types called “string” and “list.”; In order to understand how to get access to a templated class, think of the general template as a meta class. By instantiating the meta class with the proper parameters, you get an actual class, which can then be used to create objec",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1051944,Availability,avail,available,1051944,"mport *. c = TCanvas(); l = TLorentzVector(); Keeping the ROOT namespace (“import ROOT”), or only importing from ROOT those classes that you will actually use (see above), however, will always be cleaner and clearer:; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); Since it is foreseen that most people will use the simple approach anyway, the request to copy all from module ROOT will not actually result in copying all ROOT classes into the current namespace. Instead, classes will still be bound (and possibly loaded) on an as-needed basis. Note carefully how this is different from other Python (extension) modules, and what to expect if you use the normal inspection tools (such as e.g. ‘dir()’). This feature prevents the inspection tools from being swamped by an enormous amount of classes, but they can no longer be used to explore unknown parts of the system (e.g. to find out which classes are available). Furthermore, because of this approach, <tab>-completion will usually not be available until after the first use (and hence creation) of a class.; Access to class static functions, public data members, enums, etc. is as expected. Many more example uses of ROOT classes from Python can be found in the tutorials directory in the ROOT distribution. The recipes section contains a description on working with your own classes (see “Using Your Own Classes”).; 19.1.5.2 Access to STL Classes; The STL classes live in the ROOT.std namespace (or, if you prefer to get them from there, in the ROOT module directly, but doing so makes the code less clear, of course). Be careful in their use, because Python already has types called “string” and “list.”; In order to understand how to get access to a templated class, think of the general template as a meta class. By instantiating the meta class with the proper parameters, you get an actual class, which can then be used to create object instances. An example usage:; >>> from ROOT import std; >>> v = std.vector(int)(); >>> for i",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1054020,Availability,avail,available,1054020,">>> for i in v:; ... print(i, end=' '); 1 2 3 4 5 6 7 8 9; >>>; >>> list(v); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; The parameters to the template instantiation can either be an actual type or value (as is used here, “int”), or a string representation of the parameters (e.g. “‘double’”), or a mixture of both (e.g. “‘TCanvas, 0’” or “‘double’, 0” ). The “std::vector<int>” class is one of the classes builtin by default into the Cling extension dlls. You will get a non-functional class (instances of which can still be passed around to C++) if the corresponding dictionary doesn’t exist.; 19.1.5.3 Access to ROOT Globals; Most globals and global functions can be imported directly from the ROOT.py module, but some common ones (most notably gMinuit, although that variable now exists at startup from release 5.08 onward) do not exist yet at program startup, as they exist in modules that are loaded later (e.g. through the auto-loading mechanism). An example session should make this clear:; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; It is also possible to create globals interactively, either by executing a Cling macro, or by a call to gROOT.ProcessLine(). These globals are made available in the same way: either use them directly after creation in ‘from ROOT import *’ more, or get them from the ROOT namespace after an ‘import ROOT’.; As of 5.08, the behaviour of ROOT globals is the same as python globals, which is sometimes counterintuitive: since they are references, they can be changed only if done so di",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1054106,Availability,avail,available,1054106,"ype or value (as is used here, “int”), or a string representation of the parameters (e.g. “‘double’”), or a mixture of both (e.g. “‘TCanvas, 0’” or “‘double’, 0” ). The “std::vector<int>” class is one of the classes builtin by default into the Cling extension dlls. You will get a non-functional class (instances of which can still be passed around to C++) if the corresponding dictionary doesn’t exist.; 19.1.5.3 Access to ROOT Globals; Most globals and global functions can be imported directly from the ROOT.py module, but some common ones (most notably gMinuit, although that variable now exists at startup from release 5.08 onward) do not exist yet at program startup, as they exist in modules that are loaded later (e.g. through the auto-loading mechanism). An example session should make this clear:; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; It is also possible to create globals interactively, either by executing a Cling macro, or by a call to gROOT.ProcessLine(). These globals are made available in the same way: either use them directly after creation in ‘from ROOT import *’ more, or get them from the ROOT namespace after an ‘import ROOT’.; As of 5.08, the behaviour of ROOT globals is the same as python globals, which is sometimes counterintuitive: since they are references, they can be changed only if done so directly through their containing module. The following session shows that in detail:; >>> from ROOT import *; >>> print(gDebug); 0; >>> gROOT.ProcessLine( 'gDebug = 7;' ); >>> print(gDe",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1054338,Availability,avail,available,1054338," ). The “std::vector<int>” class is one of the classes builtin by default into the Cling extension dlls. You will get a non-functional class (instances of which can still be passed around to C++) if the corresponding dictionary doesn’t exist.; 19.1.5.3 Access to ROOT Globals; Most globals and global functions can be imported directly from the ROOT.py module, but some common ones (most notably gMinuit, although that variable now exists at startup from release 5.08 onward) do not exist yet at program startup, as they exist in modules that are loaded later (e.g. through the auto-loading mechanism). An example session should make this clear:; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; It is also possible to create globals interactively, either by executing a Cling macro, or by a call to gROOT.ProcessLine(). These globals are made available in the same way: either use them directly after creation in ‘from ROOT import *’ more, or get them from the ROOT namespace after an ‘import ROOT’.; As of 5.08, the behaviour of ROOT globals is the same as python globals, which is sometimes counterintuitive: since they are references, they can be changed only if done so directly through their containing module. The following session shows that in detail:; >>> from ROOT import *; >>> print(gDebug); 0; >>> gROOT.ProcessLine( 'gDebug = 7;' ); >>> print(gDebug); 0 # local gDebug is unchanged; >>> gDebug = 5 # changes _local_ reference only; >>> print(gDebug); 5 # locally correct, but ...; >>> gROOT.ProcessLine( 'co",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1054651,Availability,avail,available,1054651,"otably gMinuit, although that variable now exists at startup from release 5.08 onward) do not exist yet at program startup, as they exist in modules that are loaded later (e.g. through the auto-loading mechanism). An example session should make this clear:; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; It is also possible to create globals interactively, either by executing a Cling macro, or by a call to gROOT.ProcessLine(). These globals are made available in the same way: either use them directly after creation in ‘from ROOT import *’ more, or get them from the ROOT namespace after an ‘import ROOT’.; As of 5.08, the behaviour of ROOT globals is the same as python globals, which is sometimes counterintuitive: since they are references, they can be changed only if done so directly through their containing module. The following session shows that in detail:; >>> from ROOT import *; >>> print(gDebug); 0; >>> gROOT.ProcessLine( 'gDebug = 7;' ); >>> print(gDebug); 0 # local gDebug is unchanged; >>> gDebug = 5 # changes _local_ reference only; >>> print(gDebug); 5 # locally correct, but ...; >>> gROOT.ProcessLine( 'cout << gDebug << endl;' ); 7 # ... ROOT global unchanged; >>> import ROOT; >>> print(ROOT.gDebug); 7 # still the old value (not '5'); >>> ROOT.gDebug = 3 # changes ROOT module reference; >>> gROOT.ProcessLine( 'cout << gDebug << endl;' ); 3 # ROOT global properly changed; >>>; The above is another good reason to prefer ‘import ROOT’ over ‘from ROOT import *’.; 19.1.5.4 Access to Python;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1056558,Availability,avail,available,1056558,"lue (not '5'); >>> ROOT.gDebug = 3 # changes ROOT module reference; >>> gROOT.ProcessLine( 'cout << gDebug << endl;' ); 3 # ROOT global properly changed; >>>; The above is another good reason to prefer ‘import ROOT’ over ‘from ROOT import *’.; 19.1.5.4 Access to Python; The access to Python from Cling goes through the TPython class, or directly if a Python object or class has crossed the border. The TPython class, which looks approximately like this:; class TPython {. public:; // load a Python script as if it were a macro; static void LoadMacro(const char* name);. // execute a Python statement (e.g. ""import ROOT""); static void Exec(const char* cmd);. // evaluate a Python expression (e.g. ""1+1""); static const TPyReturn& Eval(const char* expr);. // bind a ROOT object with, at the Python side, the name ""label""; static bool Bind(TObject* obj,const char* label);. // enter an interactive Python session (exit with ^D); static void Prompt();; };; LoadMacro(const char* name) - the argument is a name of a Python file that is to be executed ('execfile'), after which any new classes are automatically made available to Cling. Since it is non-selective, use with care.; ExecScript(const char* name,int argc=0,const char** argv=0) - the argument is a name of a python file that is to be executed (‘execfile’) in a private namespace to minimize side-effects. Optionally, you can add CLI-style arguments which are handed to the script through ‘sys.argv’ in the normal way.; Exec(const char* cmd)- the argument is a string of Python code that is executed as a statement. There is no return value, but an error message will be printed if there are problems such as syntax errors.; Eval(const char* expr)- the argument is a string of Python code that is evaluated as an expression. The result of the expression is returned, if it is either a builtin type (int, long, float, double, and const char* are supported), a Python type that can cross, or a ROOT type. If a ROOT type is returned, an explicit ca",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1057051,Availability,error,error,1057051,"tatic void Exec(const char* cmd);. // evaluate a Python expression (e.g. ""1+1""); static const TPyReturn& Eval(const char* expr);. // bind a ROOT object with, at the Python side, the name ""label""; static bool Bind(TObject* obj,const char* label);. // enter an interactive Python session (exit with ^D); static void Prompt();; };; LoadMacro(const char* name) - the argument is a name of a Python file that is to be executed ('execfile'), after which any new classes are automatically made available to Cling. Since it is non-selective, use with care.; ExecScript(const char* name,int argc=0,const char** argv=0) - the argument is a name of a python file that is to be executed (‘execfile’) in a private namespace to minimize side-effects. Optionally, you can add CLI-style arguments which are handed to the script through ‘sys.argv’ in the normal way.; Exec(const char* cmd)- the argument is a string of Python code that is executed as a statement. There is no return value, but an error message will be printed if there are problems such as syntax errors.; Eval(const char* expr)- the argument is a string of Python code that is evaluated as an expression. The result of the expression is returned, if it is either a builtin type (int, long, float, double, and const char* are supported), a Python type that can cross, or a ROOT type. If a ROOT type is returned, an explicit cast to void* is needed to assign the return value to a local pointer (which may have a different type), whereas builtin types will be cast implicitly, if possible, to the type of the local variable to which they are assigned.; Bind(TObject* obj,const char* label) - transfer a ROOT object from the Cling to the Python interpreter, where it will be referenced with a variable called “label”.; Prompt() - Transfer the interactive prompt to Python.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first with gSystem->Load() before",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1057118,Availability,error,errors,1057118,"tatic void Exec(const char* cmd);. // evaluate a Python expression (e.g. ""1+1""); static const TPyReturn& Eval(const char* expr);. // bind a ROOT object with, at the Python side, the name ""label""; static bool Bind(TObject* obj,const char* label);. // enter an interactive Python session (exit with ^D); static void Prompt();; };; LoadMacro(const char* name) - the argument is a name of a Python file that is to be executed ('execfile'), after which any new classes are automatically made available to Cling. Since it is non-selective, use with care.; ExecScript(const char* name,int argc=0,const char** argv=0) - the argument is a name of a python file that is to be executed (‘execfile’) in a private namespace to minimize side-effects. Optionally, you can add CLI-style arguments which are handed to the script through ‘sys.argv’ in the normal way.; Exec(const char* cmd)- the argument is a string of Python code that is executed as a statement. There is no return value, but an error message will be printed if there are problems such as syntax errors.; Eval(const char* expr)- the argument is a string of Python code that is evaluated as an expression. The result of the expression is returned, if it is either a builtin type (int, long, float, double, and const char* are supported), a Python type that can cross, or a ROOT type. If a ROOT type is returned, an explicit cast to void* is needed to assign the return value to a local pointer (which may have a different type), whereas builtin types will be cast implicitly, if possible, to the type of the local variable to which they are assigned.; Bind(TObject* obj,const char* label) - transfer a ROOT object from the Cling to the Python interpreter, where it will be referenced with a variable called “label”.; Prompt() - Transfer the interactive prompt to Python.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first with gSystem->Load() before",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1058863,Availability,avail,available,1058863,"abel”.; Prompt() - Transfer the interactive prompt to Python.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first with gSystem->Load() before use. Refer back to the other example of the use of TPython that was given in “Access to Python from ROOT”.; To show in detail how Python access can be used, an example Python module is needed, as follows:; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; This module can now be loaded into a Cling session, the class used to instantiate objects, and their member functions called for showing how different types can cross:; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; Note that the LoadMacro() call makes the class automatically available, such that it can be used directly. Otherwise, a gROOT->GetClass() call is required first.; 19.1.5.5 Callbacks; The simplest way of setting a callback to Python from Cling, e.g. for a button, is by providing the execution string. See for example tutorials/pyroot/demo.py that comes with the ROOT installation:; # [..]; bar = ROOT.TControlBar('vertical','Demos'); bar.AddButton('Help on Demos',r'TPython::Exec(""execfile('demoshelp.py')"");','Click Here For Help on Running the Demos'); bar.AddButton('browser',r'TPython::Exec(""b = Tbrowser()"");','Start the ROOT browser'); # [..]; Here, the callback is a string that will be interpreted by Cling to call TPython::Exec(), which will, in turn, interpret and execute the string given to it. Note the use of raw strings (the ‘r’ in front of the second argument string), in order to remove the need of escaping the backslashes.; 19.1.5.6 Cling Commands; In interactive mode, the Python exception hook is used to mim",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1059861,Availability,avail,available,1059861," the LoadMacro() call makes the class automatically available, such that it can be used directly. Otherwise, a gROOT->GetClass() call is required first.; 19.1.5.5 Callbacks; The simplest way of setting a callback to Python from Cling, e.g. for a button, is by providing the execution string. See for example tutorials/pyroot/demo.py that comes with the ROOT installation:; # [..]; bar = ROOT.TControlBar('vertical','Demos'); bar.AddButton('Help on Demos',r'TPython::Exec(""execfile('demoshelp.py')"");','Click Here For Help on Running the Demos'); bar.AddButton('browser',r'TPython::Exec(""b = Tbrowser()"");','Start the ROOT browser'); # [..]; Here, the callback is a string that will be interpreted by Cling to call TPython::Exec(), which will, in turn, interpret and execute the string given to it. Note the use of raw strings (the ‘r’ in front of the second argument string), in order to remove the need of escaping the backslashes.; 19.1.5.6 Cling Commands; In interactive mode, the Python exception hook is used to mimic some of the Cling commands available. These are: .q, .!, .x, .L, .cd, .ls, .pwd, .? and .help. Note that .x translates to Python ‘execfile()’ and thus accepts only Python files, not Cling macros.; 19.1.6 Memory Handling; The Python interpreter handles memory for the user by employing reference counting and a garbage collector (for new-style objects, which includes PyROOT objects). In C++, however, memory handling is done either by hand, or by an application specific, customized mechanism (as is done in ROOT). Although PyROOT is made aware of ROOT memory management, there are still a few boundary conditions that need to be dealt with by hand. Also, the heuristics that PyROOT employs to deal with memory management are not infallible. An understanding in some detail of the choices that are made is thus important.; 19.1.6.1 Automatic Memory Management; There are two global policies that can be set: heuristics and strict. By default, the heuristic policy is used, in wh",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1062078,Availability,alive,alive,1062078,"ython reference to it goes away. If, however, such an object is passed by non-const address as a parameter to a C++ function (with the exception of the use as “self” to a member function), ownership is relinquished.; A ROOT object coming from a ROOT call is not owned, but before it passes to the Python interpreter, its “must cleanup” bit is set if its type is a class derived from TObject. When the object goes out of scope on the C++ side, the Python object will change type into an object that largely behaves like None. The strict policy differs in that it will never relinquish ownership when passing an object as a parameter to a function. It is then up to the developer to prevent double deletes. Choosing one or the other policy is done by:; ROOT.SetMemoryPolicy( ROOT.kMemoryStrict ); for the strict policy, or for the heuristic policy:; ROOT.SetMemoryPolicy( ROOT.kMemoryHeuristics ); Care must be taken in the case of graphic objects: when drawn on the current pad, a reference to the graphics is kept that PyROOT isn’t currently aware of, and it is up to the developer to keep at lease one Python reference alive. See $ROOTSYS/tutorials/pyroot/zdemo.py (available in the latest release) for an example. Alternatively, one can tell python to give up ownership for individual instances:; o = ROOT.TObject(); ROOT.SetOwnership( o, False ) # True to own, False to release; 19.1.6.2 Memory Management by Hand; If needed, you can explicitly destroy a ROOT object that you own through its associated TClass:; myobject.IsA().Destructor(myobject); which will send out the deletion notification to the system (thus you do not need to care anymore at this point about Python reference counting, the object will go, even if it’s reference count it non-zero), and free the memory.; 19.1.7 Performance; The performance of PyROOT when programming with ROOT in Python is similar to that of Cling. Differences occur mainly because of differences in the respective languages: C++ is much harder to parse, b",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1062125,Availability,avail,available,1062125,"ownership is relinquished.; A ROOT object coming from a ROOT call is not owned, but before it passes to the Python interpreter, its “must cleanup” bit is set if its type is a class derived from TObject. When the object goes out of scope on the C++ side, the Python object will change type into an object that largely behaves like None. The strict policy differs in that it will never relinquish ownership when passing an object as a parameter to a function. It is then up to the developer to prevent double deletes. Choosing one or the other policy is done by:; ROOT.SetMemoryPolicy( ROOT.kMemoryStrict ); for the strict policy, or for the heuristic policy:; ROOT.SetMemoryPolicy( ROOT.kMemoryHeuristics ); Care must be taken in the case of graphic objects: when drawn on the current pad, a reference to the graphics is kept that PyROOT isn’t currently aware of, and it is up to the developer to keep at lease one Python reference alive. See $ROOTSYS/tutorials/pyroot/zdemo.py (available in the latest release) for an example. Alternatively, one can tell python to give up ownership for individual instances:; o = ROOT.TObject(); ROOT.SetOwnership( o, False ) # True to own, False to release; 19.1.6.2 Memory Management by Hand; If needed, you can explicitly destroy a ROOT object that you own through its associated TClass:; myobject.IsA().Destructor(myobject); which will send out the deletion notification to the system (thus you do not need to care anymore at this point about Python reference counting, the object will go, even if it’s reference count it non-zero), and free the memory.; 19.1.7 Performance; The performance of PyROOT when programming with ROOT in Python is similar to that of Cling. Differences occur mainly because of differences in the respective languages: C++ is much harder to parse, but once parsed, it is much easier to optimize. Consequently, individual calls to ROOT are typically faster from PyROOT, whereas loops are typically slower.; When programming in Python, the",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1071177,Availability,avail,available,1071177," i5 = mychain.myints[5]; 19.1.9.2 Writing a Tree; Writing a ROOT TTree in a Python session is a little convoluted, if only because you will need a C++ class to make sure that data members can be mapped, unless you are working with built-in types. Here is an example for working with the latter only:; from ROOT import TFile, TTree; from array import array. h = TH1F('h1','test',100,-10.,10.); f = TFile('test.root','recreate'); t = TTree('t1','tree with histos'); maxn = 10; n = array('i',[0]); d = array('f',maxn*[0.]); t.Branch('mynum',n,'mynum/I'); t.Branch('myval',d,'myval[mynum]/F'). for i in range(25):; n[0] = min(i,maxn); for j in range(n[0]):; d[j] = i*0.1+j; t.Fill(). f.Write(); f.Close(); The use of arrays is needed, because the pointer to the address of the object that is used for filling must be given to the TTree::Branch() call, even though the formal argument is declared a ’void*'. In the case of ROOT objects, similar pointer manipulation is unnecessary, because the full type information is available, and TTree::Branch() has been Pythonized to take care of the call details. However, data members of such objects that are of built-in types, still require something extra since they are normally translated to Python primitive types on access and hence their address cannot be taken. For that purpose, there is the AddressOf() function. As an example:; from ROOT import TFile, TTree; from ROOT import gROOT, AddressOf. gROOT.ProcessLine(; ""struct MyStruct { Int_t fMyInt1; Int_t fMyInt2; Int_t fMyInt3; Char_t fMyCode[4]; };"" );. from ROOT import MyStruct; mystruct = MyStruct(); f = TFile('mytree.root','RECREATE'); tree = TTree('T','Just A Tree'); tree.Branch('myints',mystruct,'MyInt1/I:MyInt2:MyInt3'); tree.Branch('mycode',AddressOf(mystruct,'fMyCode'),'MyCode/C'); for i in range(0,10):; mystruct.fMyInt1 = i; mystruct.fMyInt2 = i*i; mystruct.fMyInt3 = i*i*i; mystruct.fMyCode = ""%03d"" % i # note string assignment. tree.Fill(). f.Write(); f.Close(); The C++ class is def",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1072985,Availability,echo,echo,1072985,"ct.fMyInt1 = i; mystruct.fMyInt2 = i*i; mystruct.fMyInt3 = i*i*i; mystruct.fMyCode = ""%03d"" % i # note string assignment. tree.Fill(). f.Write(); f.Close(); The C++ class is defined through the gROOT.ProcessLine() call, and note how the AddressOf() function is used for data members of built-in type. Most of the above is for ROOT version 5.02 and later only. For older releases, and without further support, here is an example as to how you can get hold of a pointer-to-pointer to a ROOT object:; h = TH1F(); addressofobject = array('i',[h.IsA().DynamicCast(h.IsA(),h)]); 19.1.10 Using Your Own Classes; A user’s own classes can be accessed after loading, either directly or indirectly, the library that contains the dictionary. One easy way of obtaining such a library, is by using ACLiC:; $ cat MyClass.C; class MyClass {; public:. MyClass(int value = 0) {; m_value = value;; }. void SetValue(int value) {; m_value = value;; }. int GetValue() {; return m_value;; }. private:; int m_value;; };. $ echo .L MyClass.C+ | root.exe -b; [...]; Info in <TUnixSystem::ACLiC>: creating shared library [..]/./MyClass_C.so; $; Then you can use it, for example, like so:; from ROOT import gSystem. # load library with MyClass dictionary; gSystem.Load('MyClass_C'). # get MyClass from ROOT; from ROOT import MyClass; # use MyClass; m = MyClass(42); print(m.GetValue()); You can also load a macro directly, but if you do not use ACLiC, you will be restricted to use the default constructor of your class, which is otherwise fully functional. For example:; from ROOT import gROOT. # load MyClass definition macro (append '+' to use ACLiC); gROOT.LoadMacro('MyClass.C'). # get MyClass from ROOT; from ROOT import MyClass. # use MyClass; m = MyClass(); m.SetValue(42); print(m.GetValue()); 20 The Tutorials and Tests; This chapter is a guide to the examples that come with the installation of ROOT. They are located in two directories: $ROOTSYS/tutorials and $ROOTSYS/test.; 20.1 $ROOTSYS/tutorials. The tutorials di",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1102410,Availability,error,error,1102410,"hreaded process systems, a process has a set of properties. In multi-threaded systems, these properties are divided between processes and threads.; 23.1.1 Process Properties; A process in a multi-threaded system is the changeable entity. It must be considered as an execution frame. It has all traditional process attributes, such as:. Process ID, process group ID, user ID, and group ID; Environment; Working directory. A process also provides a common address space and common system resources:. File descriptors; Signal actions; Shared libraries; Inter-process communication tools (such as message queues, pipes, semaphores, or shared memory). 23.1.2 Thread Properties; A thread is the schedulable entity. It has only those properties that are required to ensure its independent flow of control. These include the following properties:. Stack; Scheduling properties (such as policy or priority); Set of pending and blocked signals; Some thread-specific data (TSD). An example of thread-specific data is the error indicator, errno. In multi-threaded systems, errno is no longer a global variable, but usually a subroutine returning a thread-specific errno value. Some other systems may provide other implementations of errno. With respect to ROOT, a thread specific data is for example the gPad pointer, which is treated in a different way, whether it is accessed from any thread or the main thread.; Threads within a process must not be considered as a group of processes (even though in Linux each thread receives an own process id, so that it can be scheduled by the kernel scheduler). All threads share the same address space. This means that two pointers having the same value in two threads refer to the same data. Also, if any thread changes one of the shared system resources, all threads within the process are affected. For example, if a thread closes a file, the file is closed for all threads.; 23.1.3 The Initial Thread; When a process is created, one thread is automatically created. ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1105720,Availability,down,downloading,1105720,"; TCondition class implements a condition variable. Use a condition variable to signal threads. The platform dependent implementation is in the TConditionImp and TPosixCondition classes .; TSemaphore class implements a counting semaphore. Use a semaphore to synchronize threads. The platform dependent implementation is in the TMutexImp and TConditionImp classes.; 23.2.3 TThread for Pedestrians; To run a thread in ROOT, follow these steps:. Initialization. Add these lines to your rootlogon.C:; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; This loads the library with the TThread class and the pthread specific implementation file for Posix threads. Coding. Define a function (e.g. void* UserFun(void* UserArgs)) that should run as a thread. The code for the examples is at the web site of the authors (Jörn Adamczewski, Marc Hemberger). After downloading the code from this site, you can follow the example below:; http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html. Loading. Start an interactive ROOT session. Load the shared library:; root[] gSystem->Load(""mhs3.so""); // or; root[] gSystem->Load(""CalcPiThread.so"");. Creating. Create a thread instance (see also example RunMhs3.CorRunPi.C) with:; root[] TThread *th = new TThread(UserFun,UserArgs);; When called from the interpreter, this gives the name “UserFun” to the thread. This name can be used to retrieve the thread later. However, when called from compiled code, this method does not give any name to the thread. So give a name to the thread in compiled use:; root[] TThread *th = new TThread(""MyThread"", UserFun, UserArgs);; You can pass arguments to the thread function using the UserArgs-pointer. When you want to start a method of a class as a thread, you have to give the pointer to the class instance as UserArgs. Running. root[] th->Run();; root[] TThread::Ps(); // like UNIX ps c.ommand;; With the mhs3",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1117193,Availability,avail,available,1117193,"(See example TMhs3).; Class Myclass may also provide a method to stop the running thread:; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; Example TMhs3: Class TThreadframe (TThreadframe.h, TThreadframe.cxx) is a simple example of a framework class managing up to four threaded methods. Class TMhs3 (TMhs3.h, TMhs3.cxx) inherits from this base class, showing the mhs3 example 8.1 (mhs3.h, mhs3.cxx)within a class. The Makefile of this example builds the shared libraries libTThreadframe.so and libTMhs3.so. These are either loaded or executed by the ROOT script TMhs3demo.C, or are linked against an executable: TMhs3run.cxx.; 23.3.1 Known Problems; Parts of the ROOT framework, like the interpreter, are not yet thread-safe. Therefore, you should use this package with caution. If you restrict your threads to distinct and `simple’ duties, you will able to benefit from their use. The TThread class is available on all platforms, which provide a POSIX compliant thread implementation. On Linux, Xavier Leroy’s Linux Threads implementation is widely used, but the TThread implementation should be usable on all platforms that provide pthread.; Linux Xlib on SMP machines is not yet thread-safe. This may cause crashes during threaded graphics operations; this problem is independent of ROOT.; Object instantiation: there is no implicit locking mechanism for memory allocation and global ROOT lists. The user has to explicitly protect their code when using them.; 23.4 The Signals of ROOT; The list of default signals handled by ROOT is:; kSigChildkSigPipe; kSigBuskSigAlarm; kSigSegmentationViolationkSigUrgent; kSigIllegalInstructionkSigFloatingException; kSigSystemkSigWindowChanged; The signals kSigFloatingException, kSigSegmentationViolation, kSigIllegalInstruction, and kSigBus cause the printing of the *** Break *** message and make a long jump back to the ROOT prompt. No other custom TSignalHandler can be added to these si",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1147733,Availability,avail,available,1147733,"asses. Any custom widget can be created by sub classing existing widgets. To achieve a better understanding of the widgets’ properties they are separated by their type and their inheritance. As all of them inherit from TGObject and most from TGWidget, these base classes are described first.; 25.5.1 TGObject; TGObject is the base class for all ROOT GUI classes. It inherits from TObject. The two data members of this class contain important information about X11/Win32 window identifier and the connection to the host’s graphics system. Every GUI element, which derives from TGObject has access to the TGClient via the data member fClient of TGObject. TGClient creates the connection with the host’s graphics system and sets up the complete graphics system for all widgets.; 25.5.2 TGWidget; The widgets base class TGWidget is typically used as a mix-in class via multiple inheritances. Its properties are available for all deriving widgets: TGButton, TGComboBox, TGTab, TGColorPalette, TGColorPick, TGDoubleSlider, TGListTree, TGNumberEntry, TGScrollBar, TGShutterItem, TGTextEntry, TGSlider, TGListBox, TGView.; This class has four data members keeping information about the widget id - important for event processing, the window which handles the widget’s events, the widget status flags and the assigned command (if there is any). The general properties of TGWidget are specified by SetFlags(Int_t flags) and ClearFlags(Int_t flags) methods. The status flags are: kWidgetWantFocus, kWidgetHasFocus, and kWidgetIsEnabled. The method Associate(const TGWindow* w) - sets the window which handles the widget events. SetCommand(const char* command) - sets the command to be executed. The command string can be gathering via GetCommand() method. For example, the third parameter in TGTextButton constructor can be omitted and set later in your program, i.e. instead of:; TGTextButton *exit = new TGTextButton(hframe,""&Exit"",; ""gApplication->Terminate()"");; You will have the following the two lines:; ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1161714,Availability,avail,available,1161714,"ints, the default ones will be used. kLHintsLeft; specifies the frame position to the left of the container frame after other frames with the same hint into the list. kLHintsCenterX; specifies the frame position centered horizontally (with vertical containers only). kLHintsRight; specifies the frame position to the right of the container frame before any other laid out frames with the same hint into the list. kLHintsTop; specifies the frame position to the top of the container frame, below any laid out frames with the same hint. kLHintsCenterY; specifies the frame position centered vertically (with horizontal containers only). kLHintsBottom; specifies the frame position to the bottom of the container frame, above any laid out frames with the same hint. kLHintsExpandX; specifies the frame to be expanded up to the width of the container frame. If the container frame is a vertical frame - it will fit the whole width. If it is a horizontal frame - after the positioning of all frames the available “free” width space is shared between the frames having this hint. kLHintsExpandY; specifies the frame to be expanded up to the height of the container frame. If the container frame is a horizontal frame - it will fit the whole height. If the container frame is a vertical frame - after the arrangement of all frames the available “free” height space is shared between the frames having this hint. kLHintsNormal; = kLHintsLeft | kLHintsTop - default hints. Layout policy:; Child frames never modify their container frame. The container frame can (or cannot) adapt its size in the layout process. It can show all or a part of its frames. Every TGFrame object has a default minimum size (1, 1) assured by TGWindow.; 25.7 Event Processing: Signals and Slots; Event handling covers the interaction between different objects and between the user and the objects in an application. There are two general ways for the user to interact with an application: the keyboard and the mouse. The Graphical Us",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1162044,Availability,avail,available,1162044,"of the container frame before any other laid out frames with the same hint into the list. kLHintsTop; specifies the frame position to the top of the container frame, below any laid out frames with the same hint. kLHintsCenterY; specifies the frame position centered vertically (with horizontal containers only). kLHintsBottom; specifies the frame position to the bottom of the container frame, above any laid out frames with the same hint. kLHintsExpandX; specifies the frame to be expanded up to the width of the container frame. If the container frame is a vertical frame - it will fit the whole width. If it is a horizontal frame - after the positioning of all frames the available “free” width space is shared between the frames having this hint. kLHintsExpandY; specifies the frame to be expanded up to the height of the container frame. If the container frame is a horizontal frame - it will fit the whole height. If the container frame is a vertical frame - after the arrangement of all frames the available “free” height space is shared between the frames having this hint. kLHintsNormal; = kLHintsLeft | kLHintsTop - default hints. Layout policy:; Child frames never modify their container frame. The container frame can (or cannot) adapt its size in the layout process. It can show all or a part of its frames. Every TGFrame object has a default minimum size (1, 1) assured by TGWindow.; 25.7 Event Processing: Signals and Slots; Event handling covers the interaction between different objects and between the user and the objects in an application. There are two general ways for the user to interact with an application: the keyboard and the mouse. The Graphical User Interface is as a bridge between the user and the program - it provides methods to detect the user actions and instruments that do something as a reaction of these actions. The user communicates with an application through the window system. The window system reports interaction events to the application. The applicati",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1177773,Availability,avail,available,1177773,"en they are selected and keep that appearance afterwards.; A text button is represented by the class TGTextButton. We already used its constructor in the example. The button label indicates the action to be taken when the button is selected or pressed. The text can be a hot string defining a hot key (known as shortcut key also) for this selection. The hot key is an underlined character in a button label that shows the assigned keyboard mnemonic for its choice. A button that prompts more information for users has the label generally followed by ellipsis (…). As we saw the hot strings “&Draw” and “&Exit” define the text labels “Draw” and “Exit” and keyboard mnemonics Alt+D, Alt+E for their selection. The letter D and E appear underlined on the screen. All text buttons should have a unique shortcut key with the exception of OK and Cancel.; These buttons are usually placed within a window to provide fast access to frequently used or critical commands. They help in situations where a command is not available through the menu bar. You already know that a command string can be passed in the text button via the constructor:; TGTextButton(const TGWindow *p, const char *s, const char *cmd,; Int_t id, GContext_t norm, FontStruct_t font,; UInt_t options);; A button label can be changed by SetText(new_label). There are important guidelines to be followed about a button label. The text has to provide a meaningful description of the performed action. The single-word label should be used whenever possible, only two-three words for clarity, if necessary. Do not number labels. Always follow all platform presentation and usage guidelines for standard button functions. Let’s remember a few standard names and definitions of well known buttons:; OK - any changed information in a window is accepted and the window is closed;; Cancel - closes window without implementing submitted changes;; Reset- resets defaults and cancels any changed information that has not be submitted;; Apply - any chan",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1180207,Availability,down,down,1180207,"cs label. These buttons may appear alone or placed in a group at the window’s top or side. They are most frequently used to quickly access commands, many of which are normally accessed through the tool bar. For example, the picture buttons below can be used to provide different styles of a histogram drawing. Here is the example how to create the first button:; TGPictureButton *fPicture = new TGPictureButton(parent,; gClient->GetPicture(""h1_s.xpm""), 11);; The picture of file h1_s.xpm is used in the button. All .xpm files are located in the directory $ROOTSYS/icons. You can assign a command directly as a parameter of the picture button constructor. The picture of TGPictureButton can be changed by:; fPicture->SetPicture(""h2_s.xpm"");; The advantage of command buttons is that they are always visible, providing a reminder of their existence. They can be inscribed with a meaningful description of what they do by TGToolTip(""Some describing text""). Their activation is much easier and faster than using a two-step menu bar/pull-down sequence. The only disadvantage of the text and picture buttons is that they consume considerable screen space if they are many. Having no more than six command buttons per window or dialog box helps to appropriately balance the application’s effectiveness, its real efficiency, and the operational simplicity.; The classes TGRadioButton and TGCheckButton present the option buttons in ROOT. Like the text buttons, they have text or hot string as a label. Radio buttons are grouped in logical sets of two or more and appear with a text label to the right. The choices are mutually exclusive and only one setting is permitted at one time. They represent visually all alternatives and it is easy to access and compare choices. They facilitate the situations where all alternatives cannot be easily remembered or where displaying the alternatives together helps to understand and select the proper choice. It is very useful to provide a default setting whenever it ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1185553,Availability,echo,echo,1185553," check box label, must be clear, meaningful, fully spelled out, and displayed in mixed-type text. Whenever the use of a given button is inappropriate, for whatever reason, that button should be disabled:; button->SetState(kButtonDisabled);; Never make a button appear and disappear.; In general, option buttons should not offer more than eight choices. If the number of choices exceeds this maximum, it is better to use a multiple selection list box.; The method IsToggleButton() gives the information whether a radio button or a check button is selected. An option button can be set or unset via its method PSetState(EButtonState state).; The method HandleKey(event) is called when the defined hotkey is hit for any button. It sets the selected option button or clicks the selected text button and invokes its defined action.; 25.8.2 Text Entries; A TGTextEntry is a one-line text input widget. It contains text that is entered or modified through the keyboard. This text may be displayed in different way according to the set echo mode. Users can control them bySetEchoMode(), GetEchoMode() methods. kNormal - display characters as they are entered (default);; kNoEcho - do not display anything;; kPassword - display asterisks instead of the characters actually entered. The way in which typed characters are inserted in the text entry is defined by TGTextEntry::EInsertMode and can be toggled by the Insert key:. kInsert - typed character are inserted (cursor has shape of short line); kReplace - entered characters substitute already typed ones (cursor has the shape of filled rectangle). ; There ate different text alignment modes defined by TGWidget::ETextJustification. They are valid until text fits the frame width of the text entry field. kTextLeft - left-side text alignment; kTextRight - right-side text alignment; kTextCenterX - center text alignment along x direction; kTextTop - top-side text alignment; kTextBottom - bottom-side text alignment; kTextCenterY - center text alignment al",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1186703,Availability,down,down,1186703," entered (default);; kNoEcho - do not display anything;; kPassword - display asterisks instead of the characters actually entered. The way in which typed characters are inserted in the text entry is defined by TGTextEntry::EInsertMode and can be toggled by the Insert key:. kInsert - typed character are inserted (cursor has shape of short line); kReplace - entered characters substitute already typed ones (cursor has the shape of filled rectangle). ; There ate different text alignment modes defined by TGWidget::ETextJustification. They are valid until text fits the frame width of the text entry field. kTextLeft - left-side text alignment; kTextRight - right-side text alignment; kTextCenterX - center text alignment along x direction; kTextTop - top-side text alignment; kTextBottom - bottom-side text alignment; kTextCenterY - center text alignment along y direction. 25.8.3 Number Entries; The TGNumberEntry class present number entry widgets. A number entry is a single-line field followed by two small, vertically arranged up-down buttons. Its purpose is to make a selection by either scrolling through a small set of meaningful predefined choices or typing numbers. The TGNumberFormat class contains enum types to specify the numeric format. The number entry widget is based on TGTextEntry. It allows only numerical input. The widget supports numerous formats including integers, hex numbers, real numbers, fixed fraction real and time/date formats. It also allows to restrict input values to non-negative or positive numbers and to specify explicit limits. The following styles are supported:. kNESInteger - integer number; kNESRealOne - real number with one digit (no exponent); kNESRealTwo - real number with two digits (no exponent); kNESRealThree - real number with three digits (no exponent); kNESRealFour - real number with four digits (no exponent); kNESReal - arbitrary real number; kNESDegree - angle in degree:minutes:seconds format; kNESMinSec - time in minutes:seconds format;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1188928,Availability,down,down,1188928,"ex- hexadecimal number. The following attributes can be specified:. kNEAAnyNumber - any number is allowed; kNEANonNegative - only non-negative numbers are allowed; kNEAPositive - only positive numbers are allowed. Explicit limits can be specified individually:. kNELNoLimits - no limits; kNELLimitMin - lower limit only; kNELLimitMax - upper limit only; kNELLimitMinMax - both lower and upper limits. fN1 = new TGNumberEntry(parent, 0.005, 9, kENTRY1,; TGNumberFormat::kNESRealThree, //style; TGNumberFormat::kNEAAnyNumber, //input value filter; TGNumberFormat::kNELLimitMinMax, //specify limits; -1.,1.); //limit values; TGNumberEntryField is a number entry input widget.; Nent = new TGNumberEntryField(hgrunf2, kNENT_ID, 0.6,; TGNumberFormat::kNESRealThree,; TGNumberFormat::kNEAAnyNumber);; TGNumberEntryField is a plain vanilla entry field, whereas TGNumberEntry adds two small buttons to increase and decrease the numerical value in the field. The number entry widgets also support using the up and down cursor keys to change the numerical values. The step size can be selected with control and shift keys:. –small step (1 unit/factor of 3); Shift medium step (10 units/factor of 10); Controllarge step (100 units/factor of 30); Shift+Controlhuge step (1000 units/factor of 100). The steps are either linear or logarithmic. The default behavior is set when the entry field is created, but it can be changed by pressing the alt key at the same time.; 25.8.4 Menus; Menus provide a list of commands or options helping the user to select and to perform a task. The menu system classes are TGMenuBar, TGMenuTitle, TGPopupMenu, and TGMenuEntry.; The TGMenuBar class implements a menu bar widget. It is used to specify and provide access to common and frequently used application actions described in menu titles, implemented by TGMenuTitle class. The menu bar is the highest-level of the menu system and it is a starting point for all interactions. Also, it is always visible and allows using the key",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1196910,Availability,down,down,1196910,"LSE; // button behavior if clicked; t[i].fId = i+1; // button id; t[i].fButton = NULL; // button pointer. if (strlen(xpms[i]) == 0) {; separator = 5;; continue;; }; tb->AddButton(fMain,&t[i],separator);; separator = 0;; }; // adding the tool bar to the main frame; fMain->AddFrame(tb, new TGLayoutHints(kLHintsTop|kLHintsExpandX));. // adding a horizontal line as a separator; TGHorizontal3DLine *lh = new TGHorizontal3DLine(fMain);; fMain->AddFrame(lh, new TGLayoutHints(kLHintsTop|kLHintsExpandX));; To have a tool bar in your application you do not need to do anything special - only to create objects: a tool bar and its picture buttons. This sample code creates the following three toolbar buttons:. First we need to complete a ToolBarData_t structure for each tool bar button before adding it to the tool bar. This structure contains:. the icon file name “filename.xpm”; the tool tip text - a short help message explaining the button purpose; the Boolean variable defining the button behavior when is clicked; kFALSE - do not stay down; kTRUE - to stay down; the button ID; the button pointer (TGButton *) - should be NULL. We create an array *xpms[] containing the icon file names that will be used for a picture button creation. If you write only the file names here ROOT will search these files in $ROOTSYS/icons directory. If the icon files are not there, you should provide the full path name also. The array *tips[]contains the tool tip texts for buttons. The integer variable separator is used to set the distance between two groups of toolbar buttons. It defines the amount of pixels to the left for each button.; We create a tool bar object and add the buttons using the AddButton method. The variable separator helps us to define no space between the buttons in a group (0), and 5 pixels extra-space before and after. All buttons added via this method will be deleted by the toolbar. On return the TGButton field of the ToolBarData_t structure is filled in (if the icon pixmap was val",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1196932,Availability,down,down,1196932,"LSE; // button behavior if clicked; t[i].fId = i+1; // button id; t[i].fButton = NULL; // button pointer. if (strlen(xpms[i]) == 0) {; separator = 5;; continue;; }; tb->AddButton(fMain,&t[i],separator);; separator = 0;; }; // adding the tool bar to the main frame; fMain->AddFrame(tb, new TGLayoutHints(kLHintsTop|kLHintsExpandX));. // adding a horizontal line as a separator; TGHorizontal3DLine *lh = new TGHorizontal3DLine(fMain);; fMain->AddFrame(lh, new TGLayoutHints(kLHintsTop|kLHintsExpandX));; To have a tool bar in your application you do not need to do anything special - only to create objects: a tool bar and its picture buttons. This sample code creates the following three toolbar buttons:. First we need to complete a ToolBarData_t structure for each tool bar button before adding it to the tool bar. This structure contains:. the icon file name “filename.xpm”; the tool tip text - a short help message explaining the button purpose; the Boolean variable defining the button behavior when is clicked; kFALSE - do not stay down; kTRUE - to stay down; the button ID; the button pointer (TGButton *) - should be NULL. We create an array *xpms[] containing the icon file names that will be used for a picture button creation. If you write only the file names here ROOT will search these files in $ROOTSYS/icons directory. If the icon files are not there, you should provide the full path name also. The array *tips[]contains the tool tip texts for buttons. The integer variable separator is used to set the distance between two groups of toolbar buttons. It defines the amount of pixels to the left for each button.; We create a tool bar object and add the buttons using the AddButton method. The variable separator helps us to define no space between the buttons in a group (0), and 5 pixels extra-space before and after. All buttons added via this method will be deleted by the toolbar. On return the TGButton field of the ToolBarData_t structure is filled in (if the icon pixmap was val",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1198860,Availability,avail,available,1198860,"). The first parameter is the window to which the button messages will be sent. Lastly, we create an object of class TGHorizontal3DLine - a horizontal 3D line. It will separate the toolbar from the menu bar because the layout hints we define as kLHintsTop | kLHintsExpandX.; It is user friendly to allow the possibility for the tool bar to be turned on or off (via a menu). If you use a single tool bar, it should fill the complete width of its parent. When using more than one, you should also think about setting the bar size to the end of the most right button. This way other bars can be displayed in the same row below the menu bar.; Tool bar buttons should have equal size, meaningful and unique icons, and short meaningful tool tip text. The related buttons should be grouped together by frequency or sequence of use, or importance. Potentially destructive buttons must be separated from them to avoid accidental activation and potentially catastrophic results. Temporarily not available items should be displayed grayed out.; 25.8.6 List Boxes; The purpose of a list box is to display a collection of items from which single or multiple selection can be made. It is always visible, having a scroll bar when the displayed area is not enough to show all items. The choices may be mutually exclusive (a list box with single selection) or not mutually exclusive (a list box with multiple selection). The proper usage of the list boxes is for selecting values, or objects, or setting attributes. You have to create them to display 4 to 8 choices at one time (3 is a required minimum in case of lack of screen space). The list should contain not more than 40 items accessible by scrolling view (vertical scroll bar). If more are required, you should provide a method for using search criteria or scoping the options. The best list boxes use is for textual data or choices. They should be wide enough to display fully all items. When it is not possible, break the long items with ellipsis and provid",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1202905,Availability,down,downward,1202905,"try; fLastEntry++;; sprintf(tmp, ""Entry %i"", fLastEntry);; fListBox->AddEntry(tmp, fLastEntry);; fListBox->MapSubwindows();; fListBox->Layout();; . . .; // removing an entry; if (fFirstEntry < fLastEntry) {; fListBox->RemoveEntry(fFirstEntry);; fListBox->Layout();; fFirstEntry++;; }; A single-selection list box is used for selecting only one item in a list.; A multiple-selection list box permits selection of more than one item. The selected choices should be visible - you have several choices to do this:. to mark selected choices with a check mark or highlight them; to provide a summary list box to the right of the list box, containing the selected choices; to provide a display-only text control indicating the number of selected choices (its position should be justified upper-right above the list box); if the actions Select All or Deselect All must be quickly or frequently performed, use command buttons. 25.8.7 Combo Boxes; A combo box is as single-selection list box that shows only the currently selected entry and a prompt button displayed as a downward arrow. The prompt button provides a visual cue that a list box is hidden. Its main advantage is consuming of quite a bit of screen space. When the user clicks on it, a list pops up, from which a new choice can be made. After a new item is chosen the combo box folds again showing the new selection. The combo box widget is represented by the user callable class TGComboBox. The class TGComboBoxPopup is a service class. The combo box constructor is very similar to the list box one. The first parameter is a parent widget pointer again, the second - an integer value that will be used as combo box ID. The method used for adding entries is very similar to the list box method we used before. The method Select(entryID) sets the current combo box entry.; char tmp[20];; // combo box layout hints; fLcombo = new TGLayoutHints(kLHintsTop | kLHintsLeft,5,5,5,5);; // combo box widget; TGComboBox *fCombo = new TGComboBox(parent,100);",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1205150,Availability,down,down,1205150,"ou can retrieve the information for currently selected item via GetSelected or GetSelectedEntry methods. The first one returns the entry ID, the second - the current entry pointer (TGLBEntry *).; 25.8.8 Sliders; A slider is a scale with an indicator (slider) that you can drag to choose a value from a predefined range. It may be oriented horizontally or vertically. In both cases it provides an excellent indication of where a value exists within a range of values. The class TGHSlider represents the horizontal slider; TGVSlider - the vertical one. Both inherit from the base class TGSlider that creates the main slider parameters: the range of values within a value can be selected; the indicator type; the tick mark scale. Using its methods SetRange, SetPosition and SetScale you can set these parameters. To retrieve the set slider value you can call GetPosition method.; Next sample code creates a horizontal slider hslider with a tick mark of type kSlider1. Its width is 150 pixels, and its scale is placed down (kScaleDownRight). The last parameter in the TGHSlider constructor is the slider ID. It will be used for event processing. The methods SetRange and SetPosition set the range and the current tick mark position of the slider.; hslider = new TGHSlider(parent,150,kSlider1|kScaleDownRight,sID);; hslider->SetRange(0,50);; hslider->SetPosition(39);; Slider values can be set by using the mouse to drag the slider across the scale until the desired value is reached. Another way is to click in the slider trough instead of dragging.; 25.8.8.1 Double Slider; Double slider widgets allow easy selection of a min and a max value out of a range. They can be either horizontal or vertical oriented. There is a choice of different types of tick marks: kDoubleScaleNo, kScaleDownRight, kDoubleScaleBoth.; To change the min value you should press the left mouse button near to the left (TGDoubleHSlider) or bottom (TGDoubleHSlider) edge of the slider. Alternatively, to change the max value you n",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1218315,Availability,avail,available,1218315,"ntsExpandY));; 25.8.14 TGCanvas, ViewPort and Container; When all display information cannot be presented in a window, the additional information must be found and made visible. A TGCanvas is a frame containing two scrollbars (horizontal and vertical) and a viewport (TGViewPort). The viewport acts as the window through which we look at the contents of the container frame. A TGContainer frame manages a content area. It can display and control a hierarchy of multi-column items, and provides the ability to add new items at any time. By default it doesn’t map sub-windows, which are items of the container. In this case sub-window must provide DrawCopy method, see for example TGLVEntry class. It is also possible to use option which allows mapping sub-windows. This option has much slower drawing speed in case of more than 1000 items placed in container. To activate this option the fMapSubwindows data member must be set to kTRUE (for example TTVLVContainer class).; A scroll bar only is available when scrolling is necessary. It consists of three elements: a slider box and two directional scroll arrows (buttons).; fCanvas = new TGCanvas(parent, w, h);; fContents = new TGListTree(fCanvas, kHorizontalFrame);; fContents->Associate(parent);; parent->AddFrame(fCanvas, new TGLayoutHints(kLHintsExpandX |; kLHintsExpandY));; // or; fCanvas = new TGCanvas(parent, w, h);; fContents = new TGListTree(fCanvas->GetViewPort(),100,100,; kHorizontalFrame);; fContents->SetCanvas(fCanvas);; fContents->Associate(parent);; fCanvas->SetContainer(fContents);; parent->AddFrame(fCanvas, new TGLayoutHints(kLHintsExpandX |; kLHintsExpandY));; The TGContainer class can handle the following keys:; F7, Ctnrl-Factivate a search dialog; F3, Ctnrl-Gcontinue to search; Endgo to the last item in container; Homego to the first item in container; PageUpnavigate up; PageDownnavigate down; arrow keysnavigate inside container; Return/Enterequivalent to double click of the mouse button; Contrl-Aselect all items; Spac",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1219190,Availability,down,down,1219190,"dows, which are items of the container. In this case sub-window must provide DrawCopy method, see for example TGLVEntry class. It is also possible to use option which allows mapping sub-windows. This option has much slower drawing speed in case of more than 1000 items placed in container. To activate this option the fMapSubwindows data member must be set to kTRUE (for example TTVLVContainer class).; A scroll bar only is available when scrolling is necessary. It consists of three elements: a slider box and two directional scroll arrows (buttons).; fCanvas = new TGCanvas(parent, w, h);; fContents = new TGListTree(fCanvas, kHorizontalFrame);; fContents->Associate(parent);; parent->AddFrame(fCanvas, new TGLayoutHints(kLHintsExpandX |; kLHintsExpandY));; // or; fCanvas = new TGCanvas(parent, w, h);; fContents = new TGListTree(fCanvas->GetViewPort(),100,100,; kHorizontalFrame);; fContents->SetCanvas(fCanvas);; fContents->Associate(parent);; fCanvas->SetContainer(fContents);; parent->AddFrame(fCanvas, new TGLayoutHints(kLHintsExpandX |; kLHintsExpandY));; The TGContainer class can handle the following keys:; F7, Ctnrl-Factivate a search dialog; F3, Ctnrl-Gcontinue to search; Endgo to the last item in container; Homego to the first item in container; PageUpnavigate up; PageDownnavigate down; arrow keysnavigate inside container; Return/Enterequivalent to double click of the mouse button; Contrl-Aselect all items; Spaceinvert selection.; 25.8.15 Embedded Canvas; This class creates a TGCanvas in which a well known ROOT TCanvas is embedded. A pointer to the TCanvas can be obtained via the GetCanvas() member function.; fEc1 = new TRootEmbeddedCanvas(""ec1"",fParent,100,100);; fParent ->AddFrame(fEc1, new TGLayoutHints(kLHintsExpandX |; kLHintsExpandY));; fEc2 = new TRootEmbeddedCanvas(""ec2"",fParent,100,100);; fParent ->AddFrame(fEc2, new TGLayoutHints(kLHintsExpandX |; kLHintsExpandY));; fEc1->GetCanvas()->SetBorderMode(0);; fEc2->GetCanvas()->SetBorderMode(0);; fEc1->GetCanvas()->",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1226210,Availability,avail,available,1226210,"ed to use several tabs to organize properly your class-editor. Each editor tab is a resource shared among all the class-editors. Tabs must be created from the constructor of your editor-class by using the method:; TGVerticalFrame* TGedFrame::CreateEditorTabSubFrame(const Text_t *name),; It returns a pointer to a new tab container frame ready for use in your class. If you need to hide/show this frame depending on the object’s status, you should store it in a data member. See for examples: TH1Editor, TH2Editor.; 25.9.2.3 Base-Class Editors Control; Full control over base-class editors can be achieved by re-implementing virtual method void TGedFrame::ActivateBaseClassEditors(TClass *cl). It is called during each compound editor rebuild and the default implementation simply offers all base-classes to the publishing mechanism.; To prevent inclusion of a base-class into the compound editor, call:; void TGedEditor::ExcludeClassEditor(TClass* class, Bool_t recurse); Pointer to the compound GED-editor is available in TGedFrame‘s data-member:; TGedEditor *fGedEditor; Ordering of base-class editor frames follows the order of the classes in the class hierarchy. This order can be changed by modifying the value of TGedFrame’s data member Int_t fPriority. The default value is 50; smaller values move the frame towards to the top. This priority should be set in the editor constructor.; 25.10 Drag and Drop; Drag and Drop support is introduced for Linux (via Xdnd - the drag and drop protocol for X window system) and for Windows (via Clipboard). Users can selects something in ROOT with a mouse press, drags it (moves the mouse while keeping the mouse button pressed) and releases the mouse button someplace else. When the button is released the selected data is “dropped” at that location. This way, a histogram from an opened ROOT file in the browser can be dragged to any TCanvas. A script file from the browser can be dropped to a TGTextView or TGTextEdit widget in TGTextEditor.; On Linux,",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1251513,Availability,avail,available,1251513,"ternatively, one can call THtml::SetViewCVS().; 27.4.4 Wiki Pages; In some contexts it might be desirable to let users comment on classes, e.g. for suggestions of use or alternatives, details of behavior, and cross references to other relevant classes. A successful example of this is the PHP.net documentation with its user annotations. THtml can include a link to a class’s Wiki page by setting the Wiki base URL via Root.Html.WikiURL or THtml::SetWikiURL().; 27.5 Tutorial; You can run the tutorial htmlex.C to see how THtml converts a script to HTML and how it creates the corresponding class reference:; root[] .x $(ROOTSYS)/tutorials/htmlex.C+; Have a look at the HTML version of the macro in htmldoc/htmlex.C.html(which should be the same as the one at http://root.cern.ch/root/html/examples/htmlex.C.html).; It demonstrates how to generate documentation for your classes and for ROOT classes and how to “beautify” a macro.; 28 Appendix A: Install and Build ROOT. 28.1 License; ROOT is made available under the LGPL v2.1 license. For full details see the file LICENSE in the ROOT distribution.; 28.2 Installing ROOT; To install ROOT you will need to go to the ROOT website at: https://root.cern/install/; You have a choice to download the binaries or the source. The source is quicker to transfer since it is only 31 MB, but you will need to compile and link it. The binaries range from 50 MB to 100 MB depending on the target platform.; 28.3 Choosing a Version; The ROOT developers follow the principle of “release early and release often”, however a very large portion of a user base requires a stable product therefore generally three versions of the system is available for download - new, old and pro:. The new version evolves quickly, with weekly or bi-weekly releases. Use this to get access to the latest and greatest, but it may not be stable. By trying out the new version you can help us converge quickly to a stable version that can then become the new pro version. If you are a ne",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1251748,Availability,down,download,1251748,"r relevant classes. A successful example of this is the PHP.net documentation with its user annotations. THtml can include a link to a class’s Wiki page by setting the Wiki base URL via Root.Html.WikiURL or THtml::SetWikiURL().; 27.5 Tutorial; You can run the tutorial htmlex.C to see how THtml converts a script to HTML and how it creates the corresponding class reference:; root[] .x $(ROOTSYS)/tutorials/htmlex.C+; Have a look at the HTML version of the macro in htmldoc/htmlex.C.html(which should be the same as the one at http://root.cern.ch/root/html/examples/htmlex.C.html).; It demonstrates how to generate documentation for your classes and for ROOT classes and how to “beautify” a macro.; 28 Appendix A: Install and Build ROOT. 28.1 License; ROOT is made available under the LGPL v2.1 license. For full details see the file LICENSE in the ROOT distribution.; 28.2 Installing ROOT; To install ROOT you will need to go to the ROOT website at: https://root.cern/install/; You have a choice to download the binaries or the source. The source is quicker to transfer since it is only 31 MB, but you will need to compile and link it. The binaries range from 50 MB to 100 MB depending on the target platform.; 28.3 Choosing a Version; The ROOT developers follow the principle of “release early and release often”, however a very large portion of a user base requires a stable product therefore generally three versions of the system is available for download - new, old and pro:. The new version evolves quickly, with weekly or bi-weekly releases. Use this to get access to the latest and greatest, but it may not be stable. By trying out the new version you can help us converge quickly to a stable version that can then become the new pro version. If you are a new user we would advice you to try the new version.; The pro (production) version is a version we feel comfortable with to exposing to a large audience for serious work. The change rate of this version is much lower than for the new v",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1252186,Availability,avail,available,1252186,"esponding class reference:; root[] .x $(ROOTSYS)/tutorials/htmlex.C+; Have a look at the HTML version of the macro in htmldoc/htmlex.C.html(which should be the same as the one at http://root.cern.ch/root/html/examples/htmlex.C.html).; It demonstrates how to generate documentation for your classes and for ROOT classes and how to “beautify” a macro.; 28 Appendix A: Install and Build ROOT. 28.1 License; ROOT is made available under the LGPL v2.1 license. For full details see the file LICENSE in the ROOT distribution.; 28.2 Installing ROOT; To install ROOT you will need to go to the ROOT website at: https://root.cern/install/; You have a choice to download the binaries or the source. The source is quicker to transfer since it is only 31 MB, but you will need to compile and link it. The binaries range from 50 MB to 100 MB depending on the target platform.; 28.3 Choosing a Version; The ROOT developers follow the principle of “release early and release often”, however a very large portion of a user base requires a stable product therefore generally three versions of the system is available for download - new, old and pro:. The new version evolves quickly, with weekly or bi-weekly releases. Use this to get access to the latest and greatest, but it may not be stable. By trying out the new version you can help us converge quickly to a stable version that can then become the new pro version. If you are a new user we would advice you to try the new version.; The pro (production) version is a version we feel comfortable with to exposing to a large audience for serious work. The change rate of this version is much lower than for the new version, it is about 3 to 6 months.; The old version is the previous pro version that people might need for some time before switching the new pro version. The old change rate is the same as for pro. 28.4 Installing Precompiled Binaries; The binaries are available for downloading from https://root.cern/install/. Once downloaded you need to unzip a",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1252200,Availability,down,download,1252200,"esponding class reference:; root[] .x $(ROOTSYS)/tutorials/htmlex.C+; Have a look at the HTML version of the macro in htmldoc/htmlex.C.html(which should be the same as the one at http://root.cern.ch/root/html/examples/htmlex.C.html).; It demonstrates how to generate documentation for your classes and for ROOT classes and how to “beautify” a macro.; 28 Appendix A: Install and Build ROOT. 28.1 License; ROOT is made available under the LGPL v2.1 license. For full details see the file LICENSE in the ROOT distribution.; 28.2 Installing ROOT; To install ROOT you will need to go to the ROOT website at: https://root.cern/install/; You have a choice to download the binaries or the source. The source is quicker to transfer since it is only 31 MB, but you will need to compile and link it. The binaries range from 50 MB to 100 MB depending on the target platform.; 28.3 Choosing a Version; The ROOT developers follow the principle of “release early and release often”, however a very large portion of a user base requires a stable product therefore generally three versions of the system is available for download - new, old and pro:. The new version evolves quickly, with weekly or bi-weekly releases. Use this to get access to the latest and greatest, but it may not be stable. By trying out the new version you can help us converge quickly to a stable version that can then become the new pro version. If you are a new user we would advice you to try the new version.; The pro (production) version is a version we feel comfortable with to exposing to a large audience for serious work. The change rate of this version is much lower than for the new version, it is about 3 to 6 months.; The old version is the previous pro version that people might need for some time before switching the new pro version. The old change rate is the same as for pro. 28.4 Installing Precompiled Binaries; The binaries are available for downloading from https://root.cern/install/. Once downloaded you need to unzip a",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1253002,Availability,avail,available,1253002,"lopers follow the principle of “release early and release often”, however a very large portion of a user base requires a stable product therefore generally three versions of the system is available for download - new, old and pro:. The new version evolves quickly, with weekly or bi-weekly releases. Use this to get access to the latest and greatest, but it may not be stable. By trying out the new version you can help us converge quickly to a stable version that can then become the new pro version. If you are a new user we would advice you to try the new version.; The pro (production) version is a version we feel comfortable with to exposing to a large audience for serious work. The change rate of this version is much lower than for the new version, it is about 3 to 6 months.; The old version is the previous pro version that people might need for some time before switching the new pro version. The old change rate is the same as for pro. 28.4 Installing Precompiled Binaries; The binaries are available for downloading from https://root.cern/install/. Once downloaded you need to unzip and de-tar the file. For example, if you have downloaded ROOT v5.30 for Linux-SLC5:; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; This will create the directory root. Before getting started read the file README/README. Also, read the Introduction chapter for an explanation of the directory structure.; 28.5 Installing from the Source; The ROOT’s source code sits in the GitHub repository https://github.com/root-project/root all the details and options to buld ROOT from sources are given in https://root.cern/building-root; In short, the steps to build ROOT from the sources are the following:. Clone the repository:. $ git clone https://github.com/root-project/root.git. Make a directory for building. $ mkdir build; $ cd build. Run cmake and make. $ cmake ../root; $ make -j8. Setup and run ROOT. $ source bin/thisroot.sh; $ root; 28.5.0.1 Staying ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1253016,Availability,down,downloading,1253016,"lopers follow the principle of “release early and release often”, however a very large portion of a user base requires a stable product therefore generally three versions of the system is available for download - new, old and pro:. The new version evolves quickly, with weekly or bi-weekly releases. Use this to get access to the latest and greatest, but it may not be stable. By trying out the new version you can help us converge quickly to a stable version that can then become the new pro version. If you are a new user we would advice you to try the new version.; The pro (production) version is a version we feel comfortable with to exposing to a large audience for serious work. The change rate of this version is much lower than for the new version, it is about 3 to 6 months.; The old version is the previous pro version that people might need for some time before switching the new pro version. The old change rate is the same as for pro. 28.4 Installing Precompiled Binaries; The binaries are available for downloading from https://root.cern/install/. Once downloaded you need to unzip and de-tar the file. For example, if you have downloaded ROOT v5.30 for Linux-SLC5:; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; This will create the directory root. Before getting started read the file README/README. Also, read the Introduction chapter for an explanation of the directory structure.; 28.5 Installing from the Source; The ROOT’s source code sits in the GitHub repository https://github.com/root-project/root all the details and options to buld ROOT from sources are given in https://root.cern/building-root; In short, the steps to build ROOT from the sources are the following:. Clone the repository:. $ git clone https://github.com/root-project/root.git. Make a directory for building. $ mkdir build; $ cd build. Run cmake and make. $ cmake ../root; $ make -j8. Setup and run ROOT. $ source bin/thisroot.sh; $ root; 28.5.0.1 Staying ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1253066,Availability,down,downloaded,1253066,"rtion of a user base requires a stable product therefore generally three versions of the system is available for download - new, old and pro:. The new version evolves quickly, with weekly or bi-weekly releases. Use this to get access to the latest and greatest, but it may not be stable. By trying out the new version you can help us converge quickly to a stable version that can then become the new pro version. If you are a new user we would advice you to try the new version.; The pro (production) version is a version we feel comfortable with to exposing to a large audience for serious work. The change rate of this version is much lower than for the new version, it is about 3 to 6 months.; The old version is the previous pro version that people might need for some time before switching the new pro version. The old change rate is the same as for pro. 28.4 Installing Precompiled Binaries; The binaries are available for downloading from https://root.cern/install/. Once downloaded you need to unzip and de-tar the file. For example, if you have downloaded ROOT v5.30 for Linux-SLC5:; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; This will create the directory root. Before getting started read the file README/README. Also, read the Introduction chapter for an explanation of the directory structure.; 28.5 Installing from the Source; The ROOT’s source code sits in the GitHub repository https://github.com/root-project/root all the details and options to buld ROOT from sources are given in https://root.cern/building-root; In short, the steps to build ROOT from the sources are the following:. Clone the repository:. $ git clone https://github.com/root-project/root.git. Make a directory for building. $ mkdir build; $ cd build. Run cmake and make. $ cmake ../root; $ make -j8. Setup and run ROOT. $ source bin/thisroot.sh; $ root; 28.5.0.1 Staying up-to-date; To keep your local ROOT source up-to-date with the GitHub repository you shoul",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1253141,Availability,down,downloaded,1253141,"refore generally three versions of the system is available for download - new, old and pro:. The new version evolves quickly, with weekly or bi-weekly releases. Use this to get access to the latest and greatest, but it may not be stable. By trying out the new version you can help us converge quickly to a stable version that can then become the new pro version. If you are a new user we would advice you to try the new version.; The pro (production) version is a version we feel comfortable with to exposing to a large audience for serious work. The change rate of this version is much lower than for the new version, it is about 3 to 6 months.; The old version is the previous pro version that people might need for some time before switching the new pro version. The old change rate is the same as for pro. 28.4 Installing Precompiled Binaries; The binaries are available for downloading from https://root.cern/install/. Once downloaded you need to unzip and de-tar the file. For example, if you have downloaded ROOT v5.30 for Linux-SLC5:; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; This will create the directory root. Before getting started read the file README/README. Also, read the Introduction chapter for an explanation of the directory structure.; 28.5 Installing from the Source; The ROOT’s source code sits in the GitHub repository https://github.com/root-project/root all the details and options to buld ROOT from sources are given in https://root.cern/building-root; In short, the steps to build ROOT from the sources are the following:. Clone the repository:. $ git clone https://github.com/root-project/root.git. Make a directory for building. $ mkdir build; $ cd build. Run cmake and make. $ cmake ../root; $ make -j8. Setup and run ROOT. $ source bin/thisroot.sh; $ root; 28.5.0.1 Staying up-to-date; To keep your local ROOT source up-to-date with the GitHub repository you should regularly run the command:; % git pull; 28.6 Fil",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:2123,Deployability,release,release,2123,", we decided to learn and investigate Object Oriented programming and C++ to better judge the suitability of these relatively new techniques for scientific programming. We knew that there is no better way to learn a new programming environment than to use it to write a program that can solve a real problem. After a few weeks, we had our first histogramming package in C++. A few weeks later we had a rewrite of the same package using the, at that time, very new template features of C++. Again, a few weeks later we had another rewrite of the package without templates since we could only compile the version with templates on one single platform using a specific compiler. Finally, after about four months we had a histogramming package that was faster and more efficient than the well-known FORTRAN based HBOOK histogramming package. This gave us enough confidence in the new technologies to decide to continue the development. Thus was born ROOT. Since its first public release at the end of 1995, ROOT has enjoyed an ever-increasing popularity. Currently it is being used in all major High Energy and Nuclear Physics laboratories around the world to monitor, to store and to analyse data. In the other sciences as well as the medical and financial industries, many people are using ROOT. We estimate the current user base to be around several thousand people. In 1997, Eric Raymond analysed in his paper “The Cathedral and the Bazaar” the development method that makes Linux such a success. The essence of that method is: “release early, release often and listen to your customers”. This is precisely how ROOT is being developed. Over the last five years, many of our “customers” became co-developers. Here we would like to thank our main co-developers and contributors:; Masaharu Goto wrote the C++ interpreter CINT that was an essential part of ROOT before ROOT 6. Despite being 8 time zones ahead of us, we have the feeling he has been sitting in the room next door since 1995.; Andrei and Mi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:2677,Deployability,release,release,2677,"he package without templates since we could only compile the version with templates on one single platform using a specific compiler. Finally, after about four months we had a histogramming package that was faster and more efficient than the well-known FORTRAN based HBOOK histogramming package. This gave us enough confidence in the new technologies to decide to continue the development. Thus was born ROOT. Since its first public release at the end of 1995, ROOT has enjoyed an ever-increasing popularity. Currently it is being used in all major High Energy and Nuclear Physics laboratories around the world to monitor, to store and to analyse data. In the other sciences as well as the medical and financial industries, many people are using ROOT. We estimate the current user base to be around several thousand people. In 1997, Eric Raymond analysed in his paper “The Cathedral and the Bazaar” the development method that makes Linux such a success. The essence of that method is: “release early, release often and listen to your customers”. This is precisely how ROOT is being developed. Over the last five years, many of our “customers” became co-developers. Here we would like to thank our main co-developers and contributors:; Masaharu Goto wrote the C++ interpreter CINT that was an essential part of ROOT before ROOT 6. Despite being 8 time zones ahead of us, we have the feeling he has been sitting in the room next door since 1995.; Andrei and Mihaela Gheata (Alice collaboration) are co-authors of the ROOT geometry classes and Virtual Monte-Carlo. They have been working with the ROOT team since 2000.; Olivier Couet, who after a successful development and maintenance of PAW, has joined the ROOT team in 2000 and has been working on the graphics sub-system.; Ilka Antcheva has been working on the Graphical User Interface classes. She is also responsible for this latest edition of the Users Guide with a better style, improved index and several new chapters (since 2002).; Bertrand B",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:2692,Deployability,release,release,2692,"he package without templates since we could only compile the version with templates on one single platform using a specific compiler. Finally, after about four months we had a histogramming package that was faster and more efficient than the well-known FORTRAN based HBOOK histogramming package. This gave us enough confidence in the new technologies to decide to continue the development. Thus was born ROOT. Since its first public release at the end of 1995, ROOT has enjoyed an ever-increasing popularity. Currently it is being used in all major High Energy and Nuclear Physics laboratories around the world to monitor, to store and to analyse data. In the other sciences as well as the medical and financial industries, many people are using ROOT. We estimate the current user base to be around several thousand people. In 1997, Eric Raymond analysed in his paper “The Cathedral and the Bazaar” the development method that makes Linux such a success. The essence of that method is: “release early, release often and listen to your customers”. This is precisely how ROOT is being developed. Over the last five years, many of our “customers” became co-developers. Here we would like to thank our main co-developers and contributors:; Masaharu Goto wrote the C++ interpreter CINT that was an essential part of ROOT before ROOT 6. Despite being 8 time zones ahead of us, we have the feeling he has been sitting in the room next door since 1995.; Andrei and Mihaela Gheata (Alice collaboration) are co-authors of the ROOT geometry classes and Virtual Monte-Carlo. They have been working with the ROOT team since 2000.; Olivier Couet, who after a successful development and maintenance of PAW, has joined the ROOT team in 2000 and has been working on the graphics sub-system.; Ilka Antcheva has been working on the Graphical User Interface classes. She is also responsible for this latest edition of the Users Guide with a better style, improved index and several new chapters (since 2002).; Bertrand B",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:4587,Deployability,integrat,integrated,4587,"edition of the Users Guide with a better style, improved index and several new chapters (since 2002).; Bertrand Bellenot has been developing and maintaining the Win32GDK version of ROOT. Bertrand has also many other contributions like the nice RootShower example (since 2001).; Valeriy Onoutchin has been working on several ROOT packages, in particular the graphics sub-system for Windows and the GUI Builder (since 2000).; Gerri Ganis has been working on the authentication procedures to be used by the root daemons and the PROOF system (since 2002).; Maarten Ballintijn (MIT) is one of the main developers of the PROOF sub-system (since 1995).; Valeri Fine (now at BNL) ported ROOT to Windows and contributed largely to the 3-D graphics. He is currently working on the Qt layer of ROOT (since 1995).; Victor Perevoztchikov (BNL) worked on key elements of the I/O system, in particular the improved support for STL collections (1997-2001).; Nenad Buncic developed the HTML documentation generation system and integrated the X3D viewer inside ROOT (1995-1997).; Suzanne Panacek was the author of the first version of this User’s Guide and very active in preparing tutorials and giving lectures about ROOT (1999-2002).; Axel Naumann has been developing further the HTML Reference Guide and helps in porting ROOT under Windows (cygwin/gcc implementation) (since 2000).; Anna Kreshuk has developed the Linear Fitter and Robust Fitter classes as well as many functions in TMath, TF1, TGraph (since 2005).; Richard Maunder has contributed to the GL viewer classes (since 2004).; Timur Pocheptsov has contributed to the GL viewer classes and GL in pad classes (since 2004).; Sergei Linev has developed the XML driver and the TSQLFile classes (since 2003).; Stefan Roiser has been contributing to the reflex and cintex packages (since 2005).; Lorenzo Moneta has been contributing the MathCore, MathMore, Smatrix & Minuit2 packages (since 2005).; Wim Lavrijsen is the author of the PyRoot package (since 2004",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:7161,Deployability,continuous,continuous,7161,"red by the Large Hadron Collider, where the data is a few orders of magnitude larger than anything seen before.; At the same time, computer science had made leaps of progress especially in the area of Object Oriented Design, and René and Fons were ready to take advantage of it.; ROOT was developed in the context of the NA49 experiment at CERN. NA49 has generated an impressive amount of data, around 10 Terabytes per run. This rate provided the ideal environment to develop and test the next generation data analysis.; ROOT was, and still is, developed in the “Bazaar style”, a term from the book “The Cathedral and the Bazaar” by Eric S. Raymond. It means a liberal, informal development style that heavily relies on the diverse and deep talent of the user community. The result is that physicists developed ROOT for themselves; this made it specific, appropriate, useful, and over time refined and very powerful. The development of ROOT is a continuous conversation between users and developers with the line between the two blurring at times and the users becoming co-developers.; When it comes to storing and mining large amount of data, physics plows the way with its Terabytes, but other fields and industry follow close behind as they acquiring more and more data over time. They are ready to use the true and tested technologies physics has invented. In this way, other fields and industries have found ROOT useful and they have started to use it also.; In the bazaar view, software is released early and frequently to expose it to thousands of eager co-developers to pound on, report bugs, and contribute possible fixes. More users find more bugs, because they stress the program in different ways. By now, after ten years, the age of ROOT is quite mature. Most likely, you will find the features you are looking for, and if you have found a hole, you are encouraged to participate in the dialog and post your suggestion or even implementation on the ROOT forum.; 1.1 The ROOT forum; If yo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:7711,Deployability,release,released,7711,"eveloped in the “Bazaar style”, a term from the book “The Cathedral and the Bazaar” by Eric S. Raymond. It means a liberal, informal development style that heavily relies on the diverse and deep talent of the user community. The result is that physicists developed ROOT for themselves; this made it specific, appropriate, useful, and over time refined and very powerful. The development of ROOT is a continuous conversation between users and developers with the line between the two blurring at times and the users becoming co-developers.; When it comes to storing and mining large amount of data, physics plows the way with its Terabytes, but other fields and industry follow close behind as they acquiring more and more data over time. They are ready to use the true and tested technologies physics has invented. In this way, other fields and industries have found ROOT useful and they have started to use it also.; In the bazaar view, software is released early and frequently to expose it to thousands of eager co-developers to pound on, report bugs, and contribute possible fixes. More users find more bugs, because they stress the program in different ways. By now, after ten years, the age of ROOT is quite mature. Most likely, you will find the features you are looking for, and if you have found a hole, you are encouraged to participate in the dialog and post your suggestion or even implementation on the ROOT forum.; 1.1 The ROOT forum; If you have a question, it is likely that it has been asked, answered, and stored in the ROOT Forum. Please use the search engine to see if your question has already been answered before posting a topic in the Forum.; You can access the ROOT forum at: https://root-forum.cern.ch.; 1.2 Contact Information; Several authors wrote this book and you may see a “change of voice” from one chapter to the next. We felt we could accept this in order to have the expert explain what they know best. If you would like to contribute a chapter or add to a section,",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:11492,Deployability,patch,patch,11492,"ework. First, we explain what we mean by a framework and then why it is an object-oriented framework.; 1.4.1 What Is a Framework?; Programming inside a framework is a little like living in a city. Plumbing, electricity, telephone, and transportation are services provided by the city. In your house, you have interfaces to the services such as light switches, electrical outlets, and telephones. The details, for example, the routing algorithm of the phone switching system, are transparent to you as the user. You do not care; you are only interested in using the phone to communicate with your collaborators to solve your domain specific problems.; Programming outside of a framework may be compared to living in the country. In order to have transportation and water, you will have to build a road and dig a well. To have services like telephone and electricity you will need to route the wires to your home. In addition, you cannot build some things yourself. For example, you cannot build a commercial airport on your patch of land. From a global perspective, it would make no sense for everyone to build their own airport. You see you will be very busy building the infrastructure (or framework) before you can use the phone to communicate with your collaborators and have a drink of water at the same time. In software engineering, it is much the same way. In a framework, the basic utilities and services, such as I/O and graphics, are provided. In addition, ROOT being a HEP analysis framework, it provides a large selection of HEP specific utilities such as histograms and fitting. The drawback of a framework is that you are constrained to it, as you are constraint to use the routing algorithm provided by your telephone service. You also have to learn the framework interfaces, which in this analogy is the same as learning how to use a telephone.; If you are interested in doing physics, a good HEP framework will save you much work. Next is a list of the more commonly used components ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:13199,Deployability,integrat,integrated,13199,"thm provided by your telephone service. You also have to learn the framework interfaces, which in this analogy is the same as learning how to use a telephone.; If you are interested in doing physics, a good HEP framework will save you much work. Next is a list of the more commonly used components of ROOT: Command Line Interpreter, Histograms and Fitting, Writing a Graphical User Interface, 2D Graphics, Input/Output , Collection Classes, Script Processor.; There are also less commonly used components, as: 3D Graphics, Parallel Processing (PROOF), Run Time Type Identification (RTTI), Socket and Network Communication, Threads.; 1.4.1.1 Advantages of Frameworks; The benefits of frameworks can be summarized as follows:. Less code to write - the programmer should be able to use and reuse the majority of the existing code. Basic functionality, such as fitting and histogramming are implemented and ready to use and customize.; More reliable and robust code - the code inherited from a framework has already been tested and integrated with the rest of the framework.; More consistent and modular code - the code reuse provides consistency and common capabilities between programs, no matter who writes them. Frameworks make it easier to break programs into smaller pieces.; More focus on areas of expertise - users can concentrate on their particular problem domain. They do not have to be experts at writing user interfaces, graphics, or networking to use the frameworks that provide those services. 1.4.2 Why Object-Oriented?; Object-Oriented Programming offers considerable benefits compared to Procedure-Oriented Programming:. Encapsulation enforces data abstraction and increases opportunity for reuse.; Sub classing and inheritance make it possible to extend and modify objects.; Class hierarchies and containment containment hierarchies provide a flexible mechanism for modeling real-world objects and the relationships among them.; Complexity is reduced because there is little growth of ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:14466,Deployability,install,install,14466,"trate on their particular problem domain. They do not have to be experts at writing user interfaces, graphics, or networking to use the frameworks that provide those services. 1.4.2 Why Object-Oriented?; Object-Oriented Programming offers considerable benefits compared to Procedure-Oriented Programming:. Encapsulation enforces data abstraction and increases opportunity for reuse.; Sub classing and inheritance make it possible to extend and modify objects.; Class hierarchies and containment containment hierarchies provide a flexible mechanism for modeling real-world objects and the relationships among them.; Complexity is reduced because there is little growth of the global state, the state is contained within each object, rather than scattered through the program in the form of global variables.; Objects may come and go, but the basic structure of the program remains relatively static, increases opportunity for reuse of design. 1.5 Installing ROOT. To install ROOT you have the choice to download the binaries or the source. The source is quicker to transfer since it is only ~22 MB, but you will need to compile and link it. The binaries compiled with no debug information range from ~35 MB to ~45 MB depending on the target platform.; The installation and building of ROOT is described in Appendix A: Install and Build ROOT. You can download the binaries, or the source. The GNU g++ compiler on most UNIX platforms can compile ROOT.; Before downloading a binary version make sure your machine contains the right run-time environment. In most cases it is not possible to run a version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is installed. In such cases you’ll have to install ROOT from source.; ROOT is currently running on the following platforms: supported platforms. GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc, Portland/PGCC,KAI/KCC); Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC); FreeBSD and OpenBSD (GCC); GNU/Hurd (GCC); HP HP-UX 10.",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:14755,Deployability,install,installation,14755,"ogramming:. Encapsulation enforces data abstraction and increases opportunity for reuse.; Sub classing and inheritance make it possible to extend and modify objects.; Class hierarchies and containment containment hierarchies provide a flexible mechanism for modeling real-world objects and the relationships among them.; Complexity is reduced because there is little growth of the global state, the state is contained within each object, rather than scattered through the program in the form of global variables.; Objects may come and go, but the basic structure of the program remains relatively static, increases opportunity for reuse of design. 1.5 Installing ROOT. To install ROOT you have the choice to download the binaries or the source. The source is quicker to transfer since it is only ~22 MB, but you will need to compile and link it. The binaries compiled with no debug information range from ~35 MB to ~45 MB depending on the target platform.; The installation and building of ROOT is described in Appendix A: Install and Build ROOT. You can download the binaries, or the source. The GNU g++ compiler on most UNIX platforms can compile ROOT.; Before downloading a binary version make sure your machine contains the right run-time environment. In most cases it is not possible to run a version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is installed. In such cases you’ll have to install ROOT from source.; ROOT is currently running on the following platforms: supported platforms. GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc, Portland/PGCC,KAI/KCC); Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC); FreeBSD and OpenBSD (GCC); GNU/Hurd (GCC); HP HP-UX 10.x (IA32) and 11 (IA64) (HP CC, aCC, GCC); IBM AIX 4.1 (xlC compiler, GCC); Sun Solaris for SPARC (SUN C++ compiler, GCC); Sun Solaris for x86 (SUN C++ compiler, KAI/KCC); Compaq Alpha (GCC, KAI/KCC, DEC/CXX); SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler); Windows >= 95 (Microsoft Vis",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:15164,Deployability,install,installed,15164,"h of the global state, the state is contained within each object, rather than scattered through the program in the form of global variables.; Objects may come and go, but the basic structure of the program remains relatively static, increases opportunity for reuse of design. 1.5 Installing ROOT. To install ROOT you have the choice to download the binaries or the source. The source is quicker to transfer since it is only ~22 MB, but you will need to compile and link it. The binaries compiled with no debug information range from ~35 MB to ~45 MB depending on the target platform.; The installation and building of ROOT is described in Appendix A: Install and Build ROOT. You can download the binaries, or the source. The GNU g++ compiler on most UNIX platforms can compile ROOT.; Before downloading a binary version make sure your machine contains the right run-time environment. In most cases it is not possible to run a version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is installed. In such cases you’ll have to install ROOT from source.; ROOT is currently running on the following platforms: supported platforms. GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc, Portland/PGCC,KAI/KCC); Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC); FreeBSD and OpenBSD (GCC); GNU/Hurd (GCC); HP HP-UX 10.x (IA32) and 11 (IA64) (HP CC, aCC, GCC); IBM AIX 4.1 (xlC compiler, GCC); Sun Solaris for SPARC (SUN C++ compiler, GCC); Sun Solaris for x86 (SUN C++ compiler, KAI/KCC); Compaq Alpha (GCC, KAI/KCC, DEC/CXX); SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler); Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC); MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl); PowerPC with GNU/Linux and GCC, Debian v2; PowerPC64 with GNU/Linux and GCC; ARM with GNU/Linux and GCC; LynxOS. 1.6 The Organization of the ROOT Framework; Now after we know in abstract terms what the ROOT framework is, let us look at the physical directories and files that come with t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:15204,Deployability,install,install,15204," contained within each object, rather than scattered through the program in the form of global variables.; Objects may come and go, but the basic structure of the program remains relatively static, increases opportunity for reuse of design. 1.5 Installing ROOT. To install ROOT you have the choice to download the binaries or the source. The source is quicker to transfer since it is only ~22 MB, but you will need to compile and link it. The binaries compiled with no debug information range from ~35 MB to ~45 MB depending on the target platform.; The installation and building of ROOT is described in Appendix A: Install and Build ROOT. You can download the binaries, or the source. The GNU g++ compiler on most UNIX platforms can compile ROOT.; Before downloading a binary version make sure your machine contains the right run-time environment. In most cases it is not possible to run a version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is installed. In such cases you’ll have to install ROOT from source.; ROOT is currently running on the following platforms: supported platforms. GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc, Portland/PGCC,KAI/KCC); Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC); FreeBSD and OpenBSD (GCC); GNU/Hurd (GCC); HP HP-UX 10.x (IA32) and 11 (IA64) (HP CC, aCC, GCC); IBM AIX 4.1 (xlC compiler, GCC); Sun Solaris for SPARC (SUN C++ compiler, GCC); Sun Solaris for x86 (SUN C++ compiler, KAI/KCC); Compaq Alpha (GCC, KAI/KCC, DEC/CXX); SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler); Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC); MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl); PowerPC with GNU/Linux and GCC, Debian v2; PowerPC64 with GNU/Linux and GCC; ARM with GNU/Linux and GCC; LynxOS. 1.6 The Organization of the ROOT Framework; Now after we know in abstract terms what the ROOT framework is, let us look at the physical directories and files that come with the ROOT installation. You may work ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:16175,Deployability,install,installation,16175," version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is installed. In such cases you’ll have to install ROOT from source.; ROOT is currently running on the following platforms: supported platforms. GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc, Portland/PGCC,KAI/KCC); Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC); FreeBSD and OpenBSD (GCC); GNU/Hurd (GCC); HP HP-UX 10.x (IA32) and 11 (IA64) (HP CC, aCC, GCC); IBM AIX 4.1 (xlC compiler, GCC); Sun Solaris for SPARC (SUN C++ compiler, GCC); Sun Solaris for x86 (SUN C++ compiler, KAI/KCC); Compaq Alpha (GCC, KAI/KCC, DEC/CXX); SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler); Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC); MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl); PowerPC with GNU/Linux and GCC, Debian v2; PowerPC64 with GNU/Linux and GCC; ARM with GNU/Linux and GCC; LynxOS. 1.6 The Organization of the ROOT Framework; Now after we know in abstract terms what the ROOT framework is, let us look at the physical directories and files that come with the ROOT installation. You may work on a platform where your system administrator has already installed ROOT. You will need to follow the specific development environment for your setup and you may not have write access to the directories. In any case, you will need an environment variable called ROOTSYS, which holds the path of the top ROOT directory.; > echo $ROOTSYS; /opt/root; In the ROOTSYS directory are examples, executables, tutorials, header tutorials files, and, if you opted to download it, the source is here. The directories of special interest to us are bin, tutorials, lib, test, andinclude. The next figure shows the contents of these directories. ROOT framework directories. 1.6.1 $ROOTSYS/bin; The bin directory contains several executables. root; shows the ROOT splash screen and calls root.exe. root.exe; the executable that root calls, if you use a debugger such as gdb, you will need to run root.exe d",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:16260,Deployability,install,installed,16260,"ROOT is currently running on the following platforms: supported platforms. GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc, Portland/PGCC,KAI/KCC); Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC); FreeBSD and OpenBSD (GCC); GNU/Hurd (GCC); HP HP-UX 10.x (IA32) and 11 (IA64) (HP CC, aCC, GCC); IBM AIX 4.1 (xlC compiler, GCC); Sun Solaris for SPARC (SUN C++ compiler, GCC); Sun Solaris for x86 (SUN C++ compiler, KAI/KCC); Compaq Alpha (GCC, KAI/KCC, DEC/CXX); SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler); Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC); MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl); PowerPC with GNU/Linux and GCC, Debian v2; PowerPC64 with GNU/Linux and GCC; ARM with GNU/Linux and GCC; LynxOS. 1.6 The Organization of the ROOT Framework; Now after we know in abstract terms what the ROOT framework is, let us look at the physical directories and files that come with the ROOT installation. You may work on a platform where your system administrator has already installed ROOT. You will need to follow the specific development environment for your setup and you may not have write access to the directories. In any case, you will need an environment variable called ROOTSYS, which holds the path of the top ROOT directory.; > echo $ROOTSYS; /opt/root; In the ROOTSYS directory are examples, executables, tutorials, header tutorials files, and, if you opted to download it, the source is here. The directories of special interest to us are bin, tutorials, lib, test, andinclude. The next figure shows the contents of these directories. ROOT framework directories. 1.6.1 $ROOTSYS/bin; The bin directory contains several executables. root; shows the ROOT splash screen and calls root.exe. root.exe; the executable that root calls, if you use a debugger such as gdb, you will need to run root.exe directly. rootcling; is the utility ROOT uses to create a class dictionary for Cling. rmkdepend; a modified version of makedepend that is use",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:17984,Deployability,install,installed,17984,"screen and calls root.exe. root.exe; the executable that root calls, if you use a debugger such as gdb, you will need to run root.exe directly. rootcling; is the utility ROOT uses to create a class dictionary for Cling. rmkdepend; a modified version of makedepend that is used by the ROOT build system. root-config; a script returning the needed compile flags and libraries for projects that compile and link with ROOT. proofd; a small daemon used to authenticate a user of ROOT parallel processing capability (PROOF). proofserv; the actual PROOF process, which is started by proofd after a user, has successfully been authenticated. rootd; is the daemon for remote ROOT file access (see the TNetFile). 1.6.2 $ROOTSYS/lib; There are several ways to use ROOT, one way is to run the executable by typing root at the system prompt another way is to link with the ROOT libraries and make the ROOT classes available in your own program.; Here is a short description of the most relevant libraries, the ones marked with a * are only installed when the options specified them. libAsImage is the image manipulation library; libCling is the C++ interpreter (Cling); libCore is the Base classes; libEG is the abstract event generator interface classes; *libEGPythia is the Pythia5 event generator interface; *libEGPythia6 is the Pythia6 event generator interface; libFitPanel contains the GUI used for fitting; libGed contains the GUI used for editing the properties of histograms, graphs, etc.; libGeom is the geometry package (with builder and painter); libGpad is the pad and canvas classes which depend on low level graphics; libGraf is the 2D graphics primitives (can be used independent of libGpad); libGraf3d is the 3D graphics primitives; libGui is the GUI classes (depend on low level graphics); libGuiBld is the GUI designer; libGuiHtml contains the embedded HTML browser; libGX11 is the low level graphics interface to the X11 system; *libGX11TTF is an add-on library to libGX11 providing TrueType f",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:26948,Deployability,release,release,26948,"hia8 quadp: Quadratic Programming smatrix: Matrices with a templated package spectrum: Peak finder, background, deconvolutions splot: Example of the TSplot class (signal/background estimator) sql: Interfaces to SQL (mysql, oracle, etc) thread: Using Threads tmva: Examples of the MultiVariate Analysis classes tree: Creating Trees, Playing with Trees unuran: Interface with the unuram random generator library xml: Writing/Reading xml files; You can execute the scripts in $ROOTSYS/tutorials (or sub-directories) by setting your current directory in the script directory or from any user directory with write access. Several tutorials create new files. If you have write access to the tutorials directory, the new files will be created in the tutorials directory, otherwise they will be created in the user directory.; 1.6.4 $ROOTSYS/test; The test directory contains a set of examples example that represent all areas of the framework. When a new release is cut, the examples in this directory are compiled and run to test the new release’s backward compatibility. The list of source files is described in chapter “The Tutorials and Tests”.; The $ROOTSYS/test directory is a gold mine of ROOT-wisdom nuggets, and we encourage you to explore and exploit it. We recommend the new users to read the chapter “Getting Started”. The chapter “The Tutorials and Tests” has instructions on how to build all the programs and it goes over the examples Event and stress.; 1.6.5 $ROOTSYS/include; The include directory contains all header files. It is especially important because the header files contain the class definitions.; 1.6.6 $ROOTSYS/<library>; The directories we explored above are available when downloading the binaries. When downloading the source you also get a directory for each library with the corresponding header and source files, located in the inc and src subdirectories. To see what classes are in a library, you can check the <library>/inc directory for the list of class definitions. Fo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:27032,Deployability,release,release,27032,"hia8 quadp: Quadratic Programming smatrix: Matrices with a templated package spectrum: Peak finder, background, deconvolutions splot: Example of the TSplot class (signal/background estimator) sql: Interfaces to SQL (mysql, oracle, etc) thread: Using Threads tmva: Examples of the MultiVariate Analysis classes tree: Creating Trees, Playing with Trees unuran: Interface with the unuram random generator library xml: Writing/Reading xml files; You can execute the scripts in $ROOTSYS/tutorials (or sub-directories) by setting your current directory in the script directory or from any user directory with write access. Several tutorials create new files. If you have write access to the tutorials directory, the new files will be created in the tutorials directory, otherwise they will be created in the user directory.; 1.6.4 $ROOTSYS/test; The test directory contains a set of examples example that represent all areas of the framework. When a new release is cut, the examples in this directory are compiled and run to test the new release’s backward compatibility. The list of source files is described in chapter “The Tutorials and Tests”.; The $ROOTSYS/test directory is a gold mine of ROOT-wisdom nuggets, and we encourage you to explore and exploit it. We recommend the new users to read the chapter “Getting Started”. The chapter “The Tutorials and Tests” has instructions on how to build all the programs and it goes over the examples Event and stress.; 1.6.5 $ROOTSYS/include; The include directory contains all header files. It is especially important because the header files contain the class definitions.; 1.6.6 $ROOTSYS/<library>; The directories we explored above are available when downloading the binaries. When downloading the source you also get a directory for each library with the corresponding header and source files, located in the inc and src subdirectories. To see what classes are in a library, you can check the <library>/inc directory for the list of class definitions. Fo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:28554,Deployability,release,release,28554,"YS/include; The include directory contains all header files. It is especially important because the header files contain the class definitions.; 1.6.6 $ROOTSYS/<library>; The directories we explored above are available when downloading the binaries. When downloading the source you also get a directory for each library with the corresponding header and source files, located in the inc and src subdirectories. To see what classes are in a library, you can check the <library>/inc directory for the list of class definitions. For example, the physics library libPhysics.so contains these class definitions:; > ls -m $ROOTSYS/math/physics/inc/; LinkDef.h, TFeldmanCousins.h, TGenPhaseSpace.h, TLorentzRotation.h,; TLorentzVector.h, TQuaternion.h, TRobustEstimator.h, TRolke.h,; TRotation.h, TVector2.h, TVector3.h; 1.7 How to Find More Information; website The ROOT web site has up to date documentation. The ROOT source code automatically generates this documentation, so each class is explicitly documented on its own web page, which is always up to date with the latest official release of ROOT.; The ROOT Reference Guide web pages can be found at class index reference guide https://root.cern/doc/master/classes.html. Each page contains a class description, and an explanation of each method. It shows the class inheritance tree and lets you jump to the parent class page by clicking on the class name. If you want more details, you can even see the source. There is a help page available in the little box on the upper right hand side of each class documentation page. You can see on the next page what a typical class documentation web page looks like. The ROOT web site also contains in addition to this Reference Guide, “How To’s”, a list of publications and example applications.; 1.7.1 Class Reference Guide; The top of any class reference page lets you jump to different parts of the documentation. The first line links to the class index and the index for the current module (a group of cl",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:30360,Deployability,install,installed,30360,"e class index and the index for the current module (a group of classes, often a library). The second line links to the ROOT homepage and the class overviews. The third line links the source information - a HTML version of the source and header file as well as the CVS (the source management system used for the ROOT development) information of the files. The last line links the different parts of the current pages. Example of function documentation, with automatically generated LaTeX-like graphics. Inheritance tree, showing what the current class derives from, and which classes inherit from it. HTML version of the source file linking all types and most functions. 2 Getting Started; We begin by showing you how to use ROOT interactively. There are two examples to click through and learn how to use the GUI. We continue by using the command line, and explaining the coding conventions, global variables and the environment setup. If you have not installed ROOT, you can do so by following the instructions in the appendix, or on the ROOT web site: http://root.cern.ch/root/Availability.html; 2.1 Setting the Environment Variables; Before you can run ROOT you need to set the environment variable ROOTSYS and change your path to include root/bin and library path variables to include root/lib. Please note: the syntax is for bash, if you are running tcsh you will have to use setenv instead of export. Define the variable $ROOTSYS to the directory where you unpacked the ROOT:. $ export ROOTSYS=$HOME/root. Add ROOTSYS/bin to your PATH:. $ export PATH=$PATH:$ROOTSYS/bin. Setting the Library Path. On HP-UX, before executing the interactive module, you must set the library path:; $ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib; On AIX, before executing the interactive module, you must set the library path:; $ [ -z ""$LIBPATH"" ] && export LIBPATH=/lib:/usr/lib; $ export LIBPATH=$LIBPATH:$ROOTSYS/lib; On Linux, Solaris, Alpha OSF and SGI, before executing the interactive module, you must set the",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:31788,Deployability,install,installed,31788,"f export. Define the variable $ROOTSYS to the directory where you unpacked the ROOT:. $ export ROOTSYS=$HOME/root. Add ROOTSYS/bin to your PATH:. $ export PATH=$PATH:$ROOTSYS/bin. Setting the Library Path. On HP-UX, before executing the interactive module, you must set the library path:; $ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib; On AIX, before executing the interactive module, you must set the library path:; $ [ -z ""$LIBPATH"" ] && export LIBPATH=/lib:/usr/lib; $ export LIBPATH=$LIBPATH:$ROOTSYS/lib; On Linux, Solaris, Alpha OSF and SGI, before executing the interactive module, you must set the library path:; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib; On Solaris, in case your LD_LIBRARY_PATH is empty, you should set it:; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib:/usr/dt/lib; If you use the afs version you should set (vers = version number, arch = architecture):; $ export ROOTSYS=/afs/cern.ch/sw/lcg/external/root/vers/arch/root; If ROOT was installed in $HOME/myroot directory on a local machine, one can do:; cd $HOME/myroot; . bin/thisroot.sh // or source bin/thisroot.sh; The new $ROOTSYS/bin/thisroot.[c]sh scripts will set correctly the ROOTSYS, LD_LIBRARY_PATH or other paths depending on the platform and the MANPATH. To run the program just type: root.; 2.2 Start and Quit a ROOT Session; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0]; To start ROOT you can type root at the system prompt. This starts up Cling, the ROOT command line C/C++ interpreter, and it gives you the ROOT prompt (root[0]).; It is possible to launch ROOT with some command line options, as shown below:; % roo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:32356,Deployability,patch,patches,32356,"nd SGI, before executing the interactive module, you must set the library path:; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib; On Solaris, in case your LD_LIBRARY_PATH is empty, you should set it:; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib:/usr/dt/lib; If you use the afs version you should set (vers = version number, arch = architecture):; $ export ROOTSYS=/afs/cern.ch/sw/lcg/external/root/vers/arch/root; If ROOT was installed in $HOME/myroot directory on a local machine, one can do:; cd $HOME/myroot; . bin/thisroot.sh // or source bin/thisroot.sh; The new $ROOTSYS/bin/thisroot.[c]sh scripts will set correctly the ROOTSYS, LD_LIBRARY_PATH or other paths depending on the platform and the MANPATH. To run the program just type: root.; 2.2 Start and Quit a ROOT Session; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0]; To start ROOT you can type root at the system prompt. This starts up Cling, the ROOT command line C/C++ interpreter, and it gives you the ROOT prompt (root[0]).; It is possible to launch ROOT with some command line options, as shown below:; % root -?; Usage: root [-l] [-b] [-n] [-q] [dir] [[file:]data.root]; [file1.C ... fileN.C]; Options:; -b : run in batch mode without graphics; -n : do not execute logon and logoff macros as specified in .rootrc; -q : exit after processing command line macro files; -l : do not show splash screen; -x : exit on exception; dir : if dir is a valid directory cd to it before executing. -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options. -b ROOT session runs in batch mode, without graphics display. This ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:38094,Deployability,toggle,toggles,38094,"e canvas. 2.3.1 Main Menus and Toolbar; At the top of the canvas window are File, Edit, View, Options, Inspect, Classes and Help menus.; 2.3.1.1 File Menu. New Canvas: creates a new canvas window in the current ROOT session.; Open…: popup a dialog to open a file.; Close Canvas: close the canvas window.; Save: save the drawing of the current canvas in a format selectable from the submenu. The current canvas name is used as a file name for various formats such as PostScript, GIF, JPEG, C macro file, root file.; Save As…: popup a dialog for saving the current canvas drawing in a new filename.; Print: popup a dialog to print the current canvas drawing; Quit ROOT: exit the ROOT session. 2.3.1.2 Edit Menu; There is only one active menu entry in the Edit menu. The others menu entries will be implemented and will become active in the near future. Clear: delete all objects in the canvas or in the selected pad according to the selected entry in the submenu. 2.3.1.3 View Menu. Editor: toggles the view of the editor. If it is selected activates and shows up the editor on the left side of the canvas window. According to the selected object, the editor loads the corresponding user interface for easy change of the object’s attributes.; Toolbar: toggles the view of the toolbar. If it is selected activates and shows up the toolbar. It contains buttons for easy and fast access to most frequently used commands and for graphics primitive drawing. Tool tips are provided for helping users.; Status Bar: toggles the view of the status bar. If it is selected, the status bar below the canvas window shows up. There the identification of the objects is displayed when moving the mouse (such as the object’s name, the object’s type, its coordinates, etc.).; Colors: creates a new canvas showing the color palette.; Markers: creates a new canvas showing the various marker styles.; Iconify: create the canvas window icon, does not close the canvas; View With…: If the last selected pad contains a 3-d s",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:38355,Deployability,toggle,toggles,38355,"le.; Close Canvas: close the canvas window.; Save: save the drawing of the current canvas in a format selectable from the submenu. The current canvas name is used as a file name for various formats such as PostScript, GIF, JPEG, C macro file, root file.; Save As…: popup a dialog for saving the current canvas drawing in a new filename.; Print: popup a dialog to print the current canvas drawing; Quit ROOT: exit the ROOT session. 2.3.1.2 Edit Menu; There is only one active menu entry in the Edit menu. The others menu entries will be implemented and will become active in the near future. Clear: delete all objects in the canvas or in the selected pad according to the selected entry in the submenu. 2.3.1.3 View Menu. Editor: toggles the view of the editor. If it is selected activates and shows up the editor on the left side of the canvas window. According to the selected object, the editor loads the corresponding user interface for easy change of the object’s attributes.; Toolbar: toggles the view of the toolbar. If it is selected activates and shows up the toolbar. It contains buttons for easy and fast access to most frequently used commands and for graphics primitive drawing. Tool tips are provided for helping users.; Status Bar: toggles the view of the status bar. If it is selected, the status bar below the canvas window shows up. There the identification of the objects is displayed when moving the mouse (such as the object’s name, the object’s type, its coordinates, etc.).; Colors: creates a new canvas showing the color palette.; Markers: creates a new canvas showing the various marker styles.; Iconify: create the canvas window icon, does not close the canvas; View With…: If the last selected pad contains a 3-d structure, a new canvas is created with a 3-D picture according to the selection made from the cascaded menu: X3D or OpenGL. The 3-D image can be interactively rotated, zoomed in wire-frame, solid, hidden line or stereo mode. 2.3.1.4 Options Menu. Auto Resize Ca",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:38611,Deployability,toggle,toggles,38611,"ave As…: popup a dialog for saving the current canvas drawing in a new filename.; Print: popup a dialog to print the current canvas drawing; Quit ROOT: exit the ROOT session. 2.3.1.2 Edit Menu; There is only one active menu entry in the Edit menu. The others menu entries will be implemented and will become active in the near future. Clear: delete all objects in the canvas or in the selected pad according to the selected entry in the submenu. 2.3.1.3 View Menu. Editor: toggles the view of the editor. If it is selected activates and shows up the editor on the left side of the canvas window. According to the selected object, the editor loads the corresponding user interface for easy change of the object’s attributes.; Toolbar: toggles the view of the toolbar. If it is selected activates and shows up the toolbar. It contains buttons for easy and fast access to most frequently used commands and for graphics primitive drawing. Tool tips are provided for helping users.; Status Bar: toggles the view of the status bar. If it is selected, the status bar below the canvas window shows up. There the identification of the objects is displayed when moving the mouse (such as the object’s name, the object’s type, its coordinates, etc.).; Colors: creates a new canvas showing the color palette.; Markers: creates a new canvas showing the various marker styles.; Iconify: create the canvas window icon, does not close the canvas; View With…: If the last selected pad contains a 3-d structure, a new canvas is created with a 3-D picture according to the selection made from the cascaded menu: X3D or OpenGL. The 3-D image can be interactively rotated, zoomed in wire-frame, solid, hidden line or stereo mode. 2.3.1.4 Options Menu. Auto Resize Canvas: turns auto-resize of the canvas on/off:. on - the canvas fits to the window when changing the window size;; off - the canvas stays fixed when changing the window size. Resize Canvas: resizes and fits the canvas to the window size.; Move Opaque: if se",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:40156,Deployability,toggle,toggles,40156,"selection made from the cascaded menu: X3D or OpenGL. The 3-D image can be interactively rotated, zoomed in wire-frame, solid, hidden line or stereo mode. 2.3.1.4 Options Menu. Auto Resize Canvas: turns auto-resize of the canvas on/off:. on - the canvas fits to the window when changing the window size;; off - the canvas stays fixed when changing the window size. Resize Canvas: resizes and fits the canvas to the window size.; Move Opaque: if selected, graphics objects are moved in opaque mode; otherwise, only the outline of objects is drawn when moving them. The option opaque produces the best effect but it requires a reasonably fast workstation or response time.; Resize Opaque: if selected, graphics objects are resized in opaque mode; otherwise, only the outline of objects is drawn when resizing them.; Interrupt: interrupts the current drawing process.; Refresh: redraws the canvas contents.; Pad Auto Exec: executes the list of TExecs in the current pad.; Statistics: toggles the display of the histogram statistics box.; Histogram Title: toggles the display of the histogram title.; Fit Parameters: toggles the display of the histogram or graph fit parameters.; Can Edit Histogram: enables/disables the possibility to edit histogram bin contents. 2.3.1.5 Inspect Menu. ROOT: inspects the top-level gROOT object (in a new canvas).; Start Browser: starts a new object browser (in a separate window).; GUI Builder: starts the GUI builder application (in a separate window). 2.3.1.6 Help Menu. Canvas: help on canvas as a whiteboard area for drawing.; Menus: help on canvas menus.; Graphics Editor: help on primitives’ drawing and objects’ editor.; Browser: help on the ROOT objects’ and files’ browser.; Objects: help on DrawClass, Inspect and Dump context menu items.; PostScript: help on how to print a canvas to a PostScript file format.; About ROOT: pops up the ROOT Logo with the version number. 2.3.1.7 Classes Menu. Classes: starts the ClassTree viewer that draws inheritance tree f",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:40227,Deployability,toggle,toggles,40227,"age can be interactively rotated, zoomed in wire-frame, solid, hidden line or stereo mode. 2.3.1.4 Options Menu. Auto Resize Canvas: turns auto-resize of the canvas on/off:. on - the canvas fits to the window when changing the window size;; off - the canvas stays fixed when changing the window size. Resize Canvas: resizes and fits the canvas to the window size.; Move Opaque: if selected, graphics objects are moved in opaque mode; otherwise, only the outline of objects is drawn when moving them. The option opaque produces the best effect but it requires a reasonably fast workstation or response time.; Resize Opaque: if selected, graphics objects are resized in opaque mode; otherwise, only the outline of objects is drawn when resizing them.; Interrupt: interrupts the current drawing process.; Refresh: redraws the canvas contents.; Pad Auto Exec: executes the list of TExecs in the current pad.; Statistics: toggles the display of the histogram statistics box.; Histogram Title: toggles the display of the histogram title.; Fit Parameters: toggles the display of the histogram or graph fit parameters.; Can Edit Histogram: enables/disables the possibility to edit histogram bin contents. 2.3.1.5 Inspect Menu. ROOT: inspects the top-level gROOT object (in a new canvas).; Start Browser: starts a new object browser (in a separate window).; GUI Builder: starts the GUI builder application (in a separate window). 2.3.1.6 Help Menu. Canvas: help on canvas as a whiteboard area for drawing.; Menus: help on canvas menus.; Graphics Editor: help on primitives’ drawing and objects’ editor.; Browser: help on the ROOT objects’ and files’ browser.; Objects: help on DrawClass, Inspect and Dump context menu items.; PostScript: help on how to print a canvas to a PostScript file format.; About ROOT: pops up the ROOT Logo with the version number. 2.3.1.7 Classes Menu. Classes: starts the ClassTree viewer that draws inheritance tree for a list of classes. 2.3.1.8 Toolbar; The following menu shortc",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:40288,Deployability,toggle,toggles,40288,"line or stereo mode. 2.3.1.4 Options Menu. Auto Resize Canvas: turns auto-resize of the canvas on/off:. on - the canvas fits to the window when changing the window size;; off - the canvas stays fixed when changing the window size. Resize Canvas: resizes and fits the canvas to the window size.; Move Opaque: if selected, graphics objects are moved in opaque mode; otherwise, only the outline of objects is drawn when moving them. The option opaque produces the best effect but it requires a reasonably fast workstation or response time.; Resize Opaque: if selected, graphics objects are resized in opaque mode; otherwise, only the outline of objects is drawn when resizing them.; Interrupt: interrupts the current drawing process.; Refresh: redraws the canvas contents.; Pad Auto Exec: executes the list of TExecs in the current pad.; Statistics: toggles the display of the histogram statistics box.; Histogram Title: toggles the display of the histogram title.; Fit Parameters: toggles the display of the histogram or graph fit parameters.; Can Edit Histogram: enables/disables the possibility to edit histogram bin contents. 2.3.1.5 Inspect Menu. ROOT: inspects the top-level gROOT object (in a new canvas).; Start Browser: starts a new object browser (in a separate window).; GUI Builder: starts the GUI builder application (in a separate window). 2.3.1.6 Help Menu. Canvas: help on canvas as a whiteboard area for drawing.; Menus: help on canvas menus.; Graphics Editor: help on primitives’ drawing and objects’ editor.; Browser: help on the ROOT objects’ and files’ browser.; Objects: help on DrawClass, Inspect and Dump context menu items.; PostScript: help on how to print a canvas to a PostScript file format.; About ROOT: pops up the ROOT Logo with the version number. 2.3.1.7 Classes Menu. Classes: starts the ClassTree viewer that draws inheritance tree for a list of classes. 2.3.1.8 Toolbar; The following menu shortcuts and utilities are available from the toolbar:; Create a new canvas ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:79094,Deployability,integrat,integrated,79094," bin contents do not exceed the maximum positive capacity (127 or 65 535). Histograms of all types may have positive or/and negative bin contents.; 3.5 Random Numbers and Histograms; TH1::FillRandom() can be used to randomly fill a histogram using the contents of an existing TF1 function or another TH1 histogram (for all dimensions). For example, the following two statements create and fill a histogram 10 000 times with a default Gaussian distribution of mean 0 and sigma 1 :; root[] TH1F h1(""h1"",""Histo from a Gaussian"",100,-3,3);; root[] h1.FillRandom(""gaus"",10000);; TH1::GetRandom() can be used to get a random number distributed according the contents of a histogram. To fill a histogram following the distribution in an existing histogram you can use the second signature of TH1::FillRandom(). Next code snipped assumes that h is an existing histogram (TH1 ).; root[] TH1F h2(""h2"",""Histo from existing histo"",100,-3,3);; root[] h2.FillRandom(&h1, 1000);; The distribution contained in the histogram h1 ( TH1 ) is integrated over the channel contents. It is normalized to one. The second parameter (1000) indicates how many random numbers are generated.; Getting 1 random number implies:. Generating a random number between 0 and 1 (say r1 ); Find the bin in the normalized integral for r1; Fill histogram channel. You can see below an example of the TH1::GetRandom() method which can be used to get a random number distributed according the contents of a histogram.; void getrandomh() {; TH1F *source = new TH1F(""source"",""source hist"",100,-3,3);; source->FillRandom(""gaus"",1000);; TH1F *final = new TH1F(""final"",""final hist"",100,-3,3);. // continued... for (Int_t i=0;i<10000;i++) {; final->Fill(source->GetRandom());; }; TCanvas *c1 = new TCanvas(""c1"",""c1"",800,1000);; c1->Divide(1,2);; c1->cd(1);; source->Draw();; c1->cd(2);; final->Draw();; c1->cd();; }; 3.6 Adding, Dividing, and Multiplying; Many types of operations are supported on histograms or between histograms:. Addition of a hi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:82287,Deployability,update,updated,82287,":ProjectionX, TH2::ProjectionY .; a 1-D, 2-D or profile out of a 3-D histogram see TH3::ProjectionZ, TH3::Project3D. These projections can be fit via: TH2::FitSlicesX, TH2::FitSlicesY, TH3::FitSlicesZ.; 3.8 Drawing Histograms; When you call the Draw method of a histogram ( TH1::Draw ) for the first time, it creates a THistPainter object and saves a pointer to painter as a data member of the histogram. The THistPainter class specializes in the drawing of histograms. It allows logarithmic axes (x, y, z) when the CONT drawing option is using. The THistPainter class is separated from the histogram so that one can have histograms without the graphics overhead, for example in a batch program. The choice to give each histogram has its own painter rather than a central singleton painter, allows two histograms to be drawn in two threads without overwriting the painter’s values. When a displayed histogram is filled again, you do not have to call the Draw method again. The image is refreshed the next time the pad is updated. A pad is updated after one of these three actions:. A carriage control on the ROOT command line; A click inside the pad; A call to TPad::Update(). By default, the TH1::Draw clears the pad before drawing the new image of the histogram. You can use the ""SAME"" option to leave the previous display intact and superimpose the new histogram. The same histogram can be drawn with different graphics options in different pads. When a displayed histogram is deleted, its image is automatically removed from the pad. To create a copy of the histogram when drawing it, you can use TH1::DrawClone(). This will clone the histogram and allow you to change and delete the original one without affecting the clone. You can use TH1::DrawNormalized() to draw a normalized copy of a histogram.; TH1 *TH1::DrawNormalized(Option_t *option,Double_t norm) const; A clone of this histogram is normalized to norm and drawn with option. A pointer to the normalized histogram is returned. The cont",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:82305,Deployability,update,updated,82305," out of a 3-D histogram see TH3::ProjectionZ, TH3::Project3D. These projections can be fit via: TH2::FitSlicesX, TH2::FitSlicesY, TH3::FitSlicesZ.; 3.8 Drawing Histograms; When you call the Draw method of a histogram ( TH1::Draw ) for the first time, it creates a THistPainter object and saves a pointer to painter as a data member of the histogram. The THistPainter class specializes in the drawing of histograms. It allows logarithmic axes (x, y, z) when the CONT drawing option is using. The THistPainter class is separated from the histogram so that one can have histograms without the graphics overhead, for example in a batch program. The choice to give each histogram has its own painter rather than a central singleton painter, allows two histograms to be drawn in two threads without overwriting the painter’s values. When a displayed histogram is filled again, you do not have to call the Draw method again. The image is refreshed the next time the pad is updated. A pad is updated after one of these three actions:. A carriage control on the ROOT command line; A click inside the pad; A call to TPad::Update(). By default, the TH1::Draw clears the pad before drawing the new image of the histogram. You can use the ""SAME"" option to leave the previous display intact and superimpose the new histogram. The same histogram can be drawn with different graphics options in different pads. When a displayed histogram is deleted, its image is automatically removed from the pad. To create a copy of the histogram when drawing it, you can use TH1::DrawClone(). This will clone the histogram and allow you to change and delete the original one without affecting the clone. You can use TH1::DrawNormalized() to draw a normalized copy of a histogram.; TH1 *TH1::DrawNormalized(Option_t *option,Double_t norm) const; A clone of this histogram is normalized to norm and drawn with option. A pointer to the normalized histogram is returned. The contents of the histogram copy are scaled such that the ne",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:84506,Deployability,update,update,84506," this histogram. The kCanDelete bit is set for the returned object. If a pad containing this copy is cleared, the histogram will be automatically deleted. See “Draw Options” for the list of options.; 3.8.1 Setting the Style; Histograms use the current style gStyle, which is the global object of class TStyle. To change the current style for histograms, the TStyle class provides a multitude of methods ranging from setting the fill color to the axis tick marks. Here are a few examples:; void SetHistFillColor(Color_t color = 1); void SetHistFillStyle(Style_t styl = 0); void SetHistLineColor(Color_t color = 1); void SetHistLineStyle(Style_t styl = 0); void SetHistLineWidth(Width_t width = 1); When you change the current style and would like to propagate the change to a previously created histogram you can call TH1::UseCurrentStyle(). You will need to call UseCurrentStyle() on each histogram. When reading many histograms from a file and you wish to update them to the current style, you can use gROOT::ForceStyle and all histograms read after this call will be updated to use the current style. See “Graphics and the Graphical User Interface”. When a histogram is automatically created as a result of a TTree::Draw , the style of the histogram is inherited from the tree attributes and the current style is ignored. The tree attributes are the ones set in the current TStyle at the time the tree was created. You can change the existing tree to use the current style, by calling TTree::UseCurrentStyle() .; 3.8.2 Draw Options; The following draw options are supported on all histogram classes:. “AXIS”: Draw only the axis.; “HIST”: When a histogram has errors, it is visualized by default with error bars. To visualize it without errors use HIST together with the required option (e.g. “HIST SAME C”).; “SAME”: Superimpose on previous picture in the same pad.; “CYL”: Use cylindrical coordinates.; “POL”: Use polar coordinates.; “SPH”: Use spherical coordinates.; “PSR”: Use pseudo-rapidity/ph",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:84618,Deployability,update,updated,84618," this histogram. The kCanDelete bit is set for the returned object. If a pad containing this copy is cleared, the histogram will be automatically deleted. See “Draw Options” for the list of options.; 3.8.1 Setting the Style; Histograms use the current style gStyle, which is the global object of class TStyle. To change the current style for histograms, the TStyle class provides a multitude of methods ranging from setting the fill color to the axis tick marks. Here are a few examples:; void SetHistFillColor(Color_t color = 1); void SetHistFillStyle(Style_t styl = 0); void SetHistLineColor(Color_t color = 1); void SetHistLineStyle(Style_t styl = 0); void SetHistLineWidth(Width_t width = 1); When you change the current style and would like to propagate the change to a previously created histogram you can call TH1::UseCurrentStyle(). You will need to call UseCurrentStyle() on each histogram. When reading many histograms from a file and you wish to update them to the current style, you can use gROOT::ForceStyle and all histograms read after this call will be updated to use the current style. See “Graphics and the Graphical User Interface”. When a histogram is automatically created as a result of a TTree::Draw , the style of the histogram is inherited from the tree attributes and the current style is ignored. The tree attributes are the ones set in the current TStyle at the time the tree was created. You can change the existing tree to use the current style, by calling TTree::UseCurrentStyle() .; 3.8.2 Draw Options; The following draw options are supported on all histogram classes:. “AXIS”: Draw only the axis.; “HIST”: When a histogram has errors, it is visualized by default with error bars. To visualize it without errors use HIST together with the required option (e.g. “HIST SAME C”).; “SAME”: Superimpose on previous picture in the same pad.; “CYL”: Use cylindrical coordinates.; “POL”: Use polar coordinates.; “SPH”: Use spherical coordinates.; “PSR”: Use pseudo-rapidity/ph",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:118240,Deployability,update,update,118240,"histogram with h2, where the asymmetry is defined as:. Asymmetry = (h1 - h2)/(h1 + h2); //where h1 = this. It works for 1D , 2D , etc. histograms. The parameter c2 is an optional argument that gives a relative weight between the two histograms, and dc 2 is the error on this weight. This is useful, for example, when forming an asymmetry between two histograms from two different data sets that need to be normalized to each other in some way. The function calculates the errors assuming Poisson statistics on h1 and h2 (that is, dh=sqrt(h)). In the next example we assume that h1 and h2 are already filled:. h3 = h1->GetAsymmetry(h2);. Then h3 is created and filled with the asymmetry between h1 and h2 ; h1 and h2 are left intact.; Note that the user’s responsibility is to manage the created histograms.; TH1::Reset() - resets the bin contents and errors of a histogram. 3.13 Important note on returned statistics (GetMean, GetStdDev, etc.); By default, histogram statistics are computed at fill time using the unbinned data used to update the bin content. This means the values returned by GetMean, GetStdDev, etc., are those of the dataset used to fill the histogram, not those of the binned content of the histogram itself, unless one of the axes has been zoomed. (See the documentation on TH1::GetStats().) This is useful if you want to keep track of the mean and standard deviation of the dataset you are visualizing with the histogram, but it can lead to some unintuitive results.; For example, suppose you have a histogram with one bin between 0 and 100, then you fill it with a Gaussian dataset with mean 20 and standard deviation 2:; TH1F * h = new TH1F(""h"", ""h"", 1, 0, 100);; for(int i=0; i<10000; i++) h->Fill(gRandom->Gaus(20, 2));; Right now, h->GetMean() will return 20 and h->GetStdDev() will return 2; ROOT calculated these values as we filled h. Next, zoom in on the Gaussian:; h->GetXaxis()->SetRangeUser(10, 30);; Now, h->GetMean() will return 50 and h->GetStdDev() will return 0",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:138174,Deployability,update,updated,138174,"s the number of bins of the original histogram. A click on the Apply button will delete the origin histogram and will replace it by the rebinned one on the screen. A click on the Ignore button will restore the origin histogram.; 3.21.1.6 Histogram drawn from an ntuple; 3.21.1.6.1 Rebin; with the slider, the number of bins can be enlarged by a factor of 2, 3, 4, 5 (moving to the right) or reduced by a factor of \(\frac{1}{2}\), \(\frac{1}{3}\), \(\frac{1}{4}\), \(\frac{1}{5}\).; 3.21.1.6.2 BinOffset with a BinOffset slider; the origin of the histogram can be changed within one binwidth. Using this slider the effect of binning the data into bins can be made visible (statistical fluctuations).; 3.21.1.6.3 Axis Range; with a double slider it is possible to zoom into the specified axis range. It is also possible to set the upper and lower limit in fields below the slider.; 3.21.1.6.4 Delayed drawing; all the Binning sliders can set to delay draw mode. Then the changes on the histogram are only updated, when the Slider is released. This should be activated if the redrawing of the histogram is time consuming.; 3.21.2 TH2Editor. 3.21.2.1 Style Tab:; 3.21.2.1.1 Title; set the title of the histogram; 3.21.2.1.2 Histogram; change the draw options of the histogram.; 3.21.2.1.3 Plot; draw a 2D or 3D plot of the histogram; according to the dimension, the drawing possibilities are different.; 3.21.2.2 2-D Plot; 3.21.2.2.1 Contour; draw a contour plot (None, Cont0…5); 3.21.2.2.2 Cont #; set the number of Contours;; 3.21.2.2.3 Arrow; set the arrow mode and shows the gradient between adjacent cells;; 3.21.2.2.4 Col; a box is drawn for each cell with a color scale varying with contents;; 3.21.2.2.5 Text; draw bin contents as text;; 3.21.2.2.6 Box; a box is drawn for each cell with surface proportional to contents;; 3.21.2.2.7 Scat; draw a scatter-plot (default);; 3.21.2.2.8 Palette; the color palette is drawn.; 3.21.2.3 3-D Plot; 3.21.2.3.1 Type; set histogram type to Lego or surface p",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:138202,Deployability,release,released,138202,"s the number of bins of the original histogram. A click on the Apply button will delete the origin histogram and will replace it by the rebinned one on the screen. A click on the Ignore button will restore the origin histogram.; 3.21.1.6 Histogram drawn from an ntuple; 3.21.1.6.1 Rebin; with the slider, the number of bins can be enlarged by a factor of 2, 3, 4, 5 (moving to the right) or reduced by a factor of \(\frac{1}{2}\), \(\frac{1}{3}\), \(\frac{1}{4}\), \(\frac{1}{5}\).; 3.21.1.6.2 BinOffset with a BinOffset slider; the origin of the histogram can be changed within one binwidth. Using this slider the effect of binning the data into bins can be made visible (statistical fluctuations).; 3.21.1.6.3 Axis Range; with a double slider it is possible to zoom into the specified axis range. It is also possible to set the upper and lower limit in fields below the slider.; 3.21.1.6.4 Delayed drawing; all the Binning sliders can set to delay draw mode. Then the changes on the histogram are only updated, when the Slider is released. This should be activated if the redrawing of the histogram is time consuming.; 3.21.2 TH2Editor. 3.21.2.1 Style Tab:; 3.21.2.1.1 Title; set the title of the histogram; 3.21.2.1.2 Histogram; change the draw options of the histogram.; 3.21.2.1.3 Plot; draw a 2D or 3D plot of the histogram; according to the dimension, the drawing possibilities are different.; 3.21.2.2 2-D Plot; 3.21.2.2.1 Contour; draw a contour plot (None, Cont0…5); 3.21.2.2.2 Cont #; set the number of Contours;; 3.21.2.2.3 Arrow; set the arrow mode and shows the gradient between adjacent cells;; 3.21.2.2.4 Col; a box is drawn for each cell with a color scale varying with contents;; 3.21.2.2.5 Text; draw bin contents as text;; 3.21.2.2.6 Box; a box is drawn for each cell with surface proportional to contents;; 3.21.2.2.7 Scat; draw a scatter-plot (default);; 3.21.2.2.8 Palette; the color palette is drawn.; 3.21.2.3 3-D Plot; 3.21.2.3.1 Type; set histogram type to Lego or surface p",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:141307,Deployability,update,updated,141307,"r, which divides the number of bins of the original histogram. Selecting the Apply button will delete the origin histogram and will replace it by the rebinned one on the screen. Selecting the Ignore the origin histogram will be restored. 3.21.2.6 Histogram drawn from an ntuple; 3.21.2.6.1 Rebin; with the sliders the number of bins can be enlarged by a factor of 2,3,4,5 (moving to the right) or reduced by a factor of \(\frac{1}{2}\), \(\frac{1}{3}\), \(\frac{1}{4}\), \(\frac{1}{5}\).; 3.21.2.6.2 BinOffset; with the BinOffset slider the origin of the histogram can be changed within one binwidth. Using this slider the effect of binning the data into bins can be made visible (=> statistical fluctuations).; 3.21.2.6.3 Axis Range; with a double slider that gives the possibility for zooming. It is also possible to set the upper and lower limit in fields below the slider.; 3.21.2.6.4 Delayed drawing; all the binning sliders can be set to delay draw mode. Then the changes on the histogram are only updated, when the Slider is released. This should be activated if the redrawing of the histogram is too time consuming.; 4 Graphs; A graph is a graphics object made of two arrays X and Y, holding the x,y coordinates of n points. There are several graph classes; they are TGraph, TGraphErrors, TGraphAsymmErrors, and TMultiGraph.; 4.1 TGraph; The TGraph class supports the general case with non-equidistant points, and the special case with equidistant points. Graphs are created with the TGraph constructor. First, we define the arrays of coordinates and then create the graph. The coordinates can be arrays of doubles or floats.; Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0; i<n; i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; TGraph *gr1 = new TGraph (n, x, y);; An alternative constructor takes only the number of points n. It is expected that the coordinates will be set later.; TGraph *gr2 = new TGraph(n);; The default constructor can also be used. Further calls to SetPoint() w",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:141335,Deployability,release,released,141335,"r, which divides the number of bins of the original histogram. Selecting the Apply button will delete the origin histogram and will replace it by the rebinned one on the screen. Selecting the Ignore the origin histogram will be restored. 3.21.2.6 Histogram drawn from an ntuple; 3.21.2.6.1 Rebin; with the sliders the number of bins can be enlarged by a factor of 2,3,4,5 (moving to the right) or reduced by a factor of \(\frac{1}{2}\), \(\frac{1}{3}\), \(\frac{1}{4}\), \(\frac{1}{5}\).; 3.21.2.6.2 BinOffset; with the BinOffset slider the origin of the histogram can be changed within one binwidth. Using this slider the effect of binning the data into bins can be made visible (=> statistical fluctuations).; 3.21.2.6.3 Axis Range; with a double slider that gives the possibility for zooming. It is also possible to set the upper and lower limit in fields below the slider.; 3.21.2.6.4 Delayed drawing; all the binning sliders can be set to delay draw mode. Then the changes on the histogram are only updated, when the Slider is released. This should be activated if the redrawing of the histogram is too time consuming.; 4 Graphs; A graph is a graphics object made of two arrays X and Y, holding the x,y coordinates of n points. There are several graph classes; they are TGraph, TGraphErrors, TGraphAsymmErrors, and TMultiGraph.; 4.1 TGraph; The TGraph class supports the general case with non-equidistant points, and the special case with equidistant points. Graphs are created with the TGraph constructor. First, we define the arrays of coordinates and then create the graph. The coordinates can be arrays of doubles or floats.; Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0; i<n; i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; TGraph *gr1 = new TGraph (n, x, y);; An alternative constructor takes only the number of points n. It is expected that the coordinates will be set later.; TGraph *gr2 = new TGraph(n);; The default constructor can also be used. Further calls to SetPoint() w",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:143239,Deployability,continuous,continuous,143239,"The default constructor can also be used. Further calls to SetPoint() will extend the internal vectors.; TGraph *gr3 = new TGraph();; 4.1.1 Graph Draw Options; The various drawing options for a graph are explained in TGraph::PaintGraph. They are:. “L” A simple poly-line between every points is drawn; “F” A fill area is drawn; “F1” Idem as “F” but fill area is no more repartee around X=0 or Y=0; “F2” draw a fill area poly line connecting the center of bins; “A” Axis are drawn around the graph; “C” A smooth curve is drawn; “*” A star is plotted at each point; “P” The current marker of the graph is plotted at each point; “B” A bar chart is drawn at each point; “[]” Only the end vertical/horizontal lines of the error bars are drawn. This option only applies to the TGraphAsymmErrors.; “1” ylow = rwymin. The options are not case sensitive and they can be concatenated in most cases. Let us look at some examples.; 4.1.1.1 Continuous Line, Axis and Stars (AC*). A graph drawn with axis, * markers and continuous line (option AC*). {; Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }. // create graph; TGraph *gr = new TGraph(n,x,y);; TCanvas *c1 = new TCanvas(""c1"",""Graph Draw Options"",; 200,10,600,400);. // draw the graph with axis, continuous line, and put; // a * at each point; gr->Draw(""AC*"");; }; 4.1.1.2 Bar Graphs (AB). A graph drawn with axis and bar (option AB). root[] TGraph *gr1 = new TGraph(n,x,y);; root[] gr1->SetFillColor(40);; root[] gr1->Draw(""AB"");; This code will only work if n, x, and y is defined. The previous example defines these. You need to set the fill color, because by default the fill color is white and will not be visible on a white canvas. You also need to give it an axis, or the bar chart will not be displayed properly.; 4.1.1.3 Filled Graphs (AF). A graph drawn with axis and fill (option AF). root[] TGraph *gr3 = new TGraph(n,x,y);; root[] gr3->SetFillColor(45);; root[] gr3->Draw(""AF""); This co",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:143531,Deployability,continuous,continuous,143531,"is drawn; “F1” Idem as “F” but fill area is no more repartee around X=0 or Y=0; “F2” draw a fill area poly line connecting the center of bins; “A” Axis are drawn around the graph; “C” A smooth curve is drawn; “*” A star is plotted at each point; “P” The current marker of the graph is plotted at each point; “B” A bar chart is drawn at each point; “[]” Only the end vertical/horizontal lines of the error bars are drawn. This option only applies to the TGraphAsymmErrors.; “1” ylow = rwymin. The options are not case sensitive and they can be concatenated in most cases. Let us look at some examples.; 4.1.1.1 Continuous Line, Axis and Stars (AC*). A graph drawn with axis, * markers and continuous line (option AC*). {; Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }. // create graph; TGraph *gr = new TGraph(n,x,y);; TCanvas *c1 = new TCanvas(""c1"",""Graph Draw Options"",; 200,10,600,400);. // draw the graph with axis, continuous line, and put; // a * at each point; gr->Draw(""AC*"");; }; 4.1.1.2 Bar Graphs (AB). A graph drawn with axis and bar (option AB). root[] TGraph *gr1 = new TGraph(n,x,y);; root[] gr1->SetFillColor(40);; root[] gr1->Draw(""AB"");; This code will only work if n, x, and y is defined. The previous example defines these. You need to set the fill color, because by default the fill color is white and will not be visible on a white canvas. You also need to give it an axis, or the bar chart will not be displayed properly.; 4.1.1.3 Filled Graphs (AF). A graph drawn with axis and fill (option AF). root[] TGraph *gr3 = new TGraph(n,x,y);; root[] gr3->SetFillColor(45);; root[] gr3->Draw(""AF""); This code will only work if n, x, yare defined. The first example defines them. You need to set the fill color, because by default the fill color is white and will not be visible on a white canvas. You also need to give it an axis, or the filled polygon will not be displayed properly.; 4.1.1.4 Marker Options. Graph markers ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:172776,Deployability,configurat,configuration,172776,"ber function:; double operator()(double *x, double *p); The advantage of the function object is that it can have a state and reference therefore what-ever other object the user needs, without using globals. This is an example to define first the function object; class MyFunctionObject {; public:; // use constructor to customize your function object; MyFunctionObject(......) { ......}. double operator() (double *x, double *p) {; // function implementation using class data members; }; };; and then use it to create the TF1:; MyFunctionObject fobj(....); // create the function object; TF1 * f = new TF1(""f"",fobj,xmin,xmax,npar); // create TF1 class with n-parameters and range [xmin,xmax]; If using C++11, one can create a TF1 also from a C++ lambda function:; // create TF1 class with 2 parameters and range [xmin,xmax] using a lambda; TF1 * f = new TF1(""f"",[](double*x,double*p){return p[0] + p[1]*x[0];},xmin,xmax,2);; 5.3 Configuring the Fit; We will show here some configuration actions that can or must be done when fitting histogram or graph using the Fit method.; 5.3.1 Fixing and Setting Parameters’ Bounds; Parameters must be initialized before invoking the Fit method. The setting of the parameter initial values is automatic for the predefined functions: poln, exp, gaus, and landau. You can fix one or more parameters by specifying the “B” option when calling the Fit method. When a function is not predefined, the fit parameters must be initialized to some value as close as possible to the expected values before calling the fit function.; To set bounds for one parameter, use TF1::SetParLimits:; func->SetParLimits(0,-1,1);; When the lower and upper limits are equal, the parameter is fixed. Next two statements fix parameter 4 at 10.; func->SetParameter(4,10);; func->SetParLimits(4,10,10);; However, to fix a parameter to 0, one must call the FixParameter function:; func->SetParameter(4,0);; func->FixParameter(4,0);; Note that you are not forced to set the limits for all param",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
