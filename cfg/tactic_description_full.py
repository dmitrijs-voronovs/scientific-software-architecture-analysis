tactic_descriptions_full = {"Ping/Echo": {"class_name": "PingEchoModel", "tactic_category": "Detect Faults",
                                          "quality_attribute": "Availability", "tactic": "Ping/Echo",
                                          "description": "An asynchronous request/response message pair exchanged between nodes to determine reachability and responsiveness."},
                            "Monitor": {"class_name": "MonitorModel", "tactic_category": "Detect Faults",
                                        "quality_attribute": "Availability", "tactic": "Monitor",
                                        "description": "A component that monitors the state of health of various parts of the system such as processors, processes, I/O, and memory."},
                            "Heartbeat": {"class_name": "HeartbeatModel", "tactic_category": "Detect Faults",
                                          "quality_attribute": "Availability", "tactic": "Heartbeat",
                                          "description": "A fault detection mechanism that employs periodic message exchange between a system monitor and a process being monitored."},
                            "Timestamp": {"class_name": "TimestampModel", "tactic_category": "Detect Faults",
                                          "quality_attribute": "Availability", "tactic": "Timestamp",
                                          "description": "Used to detect incorrect sequences of events by assigning the state of a local clock to events immediately after they occur."},
                            "Sanity Checking": {"class_name": "SanityCheckingModel", "tactic_category": "Detect Faults",
                                                "quality_attribute": "Availability", "tactic": "Sanity Checking",
                                                "description": "Checks the validity or reasonableness of specific operations or outputs of a component."},
                            "Condition Monitoring": {"class_name": "ConditionMonitoringModel",
                                                     "tactic_category": "Detect Faults",
                                                     "quality_attribute": "Availability",
                                                     "tactic": "Condition Monitoring",
                                                     "description": "Involves checking conditions in a process or device to prevent a system from producing faulty behavior."},
                            "Voting": {"class_name": "VotingModel", "tactic_category": "Detect Faults",
                                       "quality_attribute": "Availability", "tactic": "Voting",
                                       "description": "Employs multiple components that do the same thing with identical inputs and forwards their output to voting logic to detect inconsistencies."},
                            "Exception Detection": {"class_name": "ExceptionDetectionModel",
                                                    "tactic_category": "Detect Faults",
                                                    "quality_attribute": "Availability",
                                                    "tactic": "Exception Detection",
                                                    "description": "The detection of a system condition that alters the normal flow of execution."},
                            "Self-Test": {"class_name": "SelfTestModel", "tactic_category": "Detect Faults",
                                          "quality_attribute": "Availability", "tactic": "Self-Test",
                                          "description": "Components can run procedures to test themselves for correct operation."},
                            "Active Redundancy": {"class_name": "ActiveRedundancyModel",
                                                  "tactic_category": "Recover from Faults_Preparation and Repair",
                                                  "quality_attribute": "Availability", "tactic": "Active Redundancy",
                                                  "description": "A configuration where all nodes receive and process identical inputs in parallel, allowing redundant spares to maintain synchronous state with active nodes."},
                            "Passive Redundancy": {"class_name": "PassiveRedundancyModel",
                                                   "tactic_category": "Recover from Faults_Preparation and Repair",
                                                   "quality_attribute": "Availability", "tactic": "Passive Redundancy",
                                                   "description": "A configuration where only active members process input traffic and provide redundant spares with periodic state updates."},
                            "Spare": {"class_name": "SpareModel",
                                      "tactic_category": "Recover from Faults_Preparation and Repair",
                                      "quality_attribute": "Availability", "tactic": "Spare",
                                      "description": "Cold sparing where redundant spares remain out of service until a fail-over occurs."},
                            "Exception Handling": {"class_name": "ExceptionHandlingModel",
                                                   "tactic_category": "Recover from Faults_Preparation and Repair",
                                                   "quality_attribute": "Availability", "tactic": "Exception Handling",
                                                   "description": "Mechanisms employed to handle detected exceptions using information to mask the fault."},
                            "Rollback": {"class_name": "RollbackModel",
                                         "tactic_category": "Recover from Faults_Preparation and Repair",
                                         "quality_attribute": "Availability", "tactic": "Rollback",
                                         "description": "Permits the system to revert to a previous known good state upon detection of a failure."},
                            "Software Upgrade": {"class_name": "SoftwareUpgradeModel",
                                                 "tactic_category": "Recover from Faults_Preparation and Repair",
                                                 "quality_attribute": "Availability", "tactic": "Software Upgrade",
                                                 "description": "Achieves in-service upgrades to executable code images in a non-service-affecting manner."},
                            "Retry": {"class_name": "RetryModel",
                                      "tactic_category": "Recover from Faults_Preparation and Repair",
                                      "quality_attribute": "Availability", "tactic": "Retry",
                                      "description": "Assumes that the fault causing a failure is transient and retrying the operation may lead to success."},
                            "Ignore Faulty Behavior": {"class_name": "IgnoreFaultyBehaviorModel",
                                                       "tactic_category": "Recover from Faults_Preparation and Repair",
                                                       "quality_attribute": "Availability",
                                                       "tactic": "Ignore Faulty Behavior",
                                                       "description": "Calls for ignoring messages from a particular source when determined to be spurious."},
                            "Degradation": {"class_name": "DegradationModel",
                                            "tactic_category": "Recover from Faults_Preparation and Repair",
                                            "quality_attribute": "Availability", "tactic": "Degradation",
                                            "description": "Maintains critical system functions in the presence of component failures by dropping less critical functions."},
                            "Reconfiguration": {"class_name": "ReconfigurationModel",
                                                "tactic_category": "Recover from Faults_Preparation and Repair",
                                                "quality_attribute": "Availability", "tactic": "Reconfiguration",
                                                "description": "Recovers from component failures by reassigning responsibilities to remaining functional resources."},
                            "Shadow": {"class_name": "ShadowModel",
                                       "tactic_category": "Recover from Faults_Reintroduction",
                                       "quality_attribute": "Availability", "tactic": "Shadow",
                                       "description": "Operates a previously failed component in \"shadow mode\" for a predefined duration before reverting it to an active role."},
                            "State Resynchronization": {"class_name": "StateResynchronizationModel",
                                                        "tactic_category": "Recover from Faults_Reintroduction",
                                                        "quality_attribute": "Availability",
                                                        "tactic": "State Resynchronization",
                                                        "description": "Ensures that failed components are brought back to a consistent state with active components."},
                            "Escalating Restart": {"class_name": "EscalatingRestartModel",
                                                   "tactic_category": "Recover from Faults_Reintroduction",
                                                   "quality_attribute": "Availability", "tactic": "Escalating Restart",
                                                   "description": "Allows system recovery by varying the granularity of components restarted while minimizing service impact."},
                            "Non-Stop Forwarding": {"class_name": "NonStopForwardingModel",
                                                    "tactic_category": "Recover from Faults_Reintroduction",
                                                    "quality_attribute": "Availability",
                                                    "tactic": "Non-Stop Forwarding",
                                                    "description": "Splits functionality into control and data planes to continue operations while recovering the supervisory information."},
                            "Removal from Service": {"class_name": "RemovalFromServiceModel",
                                                     "tactic_category": "Prevent Faults",
                                                     "quality_attribute": "Availability",
                                                     "tactic": "Removal from Service",
                                                     "description": "Temporarily placing a system component in an out-of-service state to mitigate potential system failures."},
                            "Transactions": {"class_name": "TransactionsModel", "tactic_category": "Prevent Faults",
                                             "quality_attribute": "Availability", "tactic": "Transactions",
                                             "description": "Ensures that asynchronous messages exchanged between distributed components are atomic, consistent, isolated, and durable."},
                            "Predictive Model": {"class_name": "PredictiveModelModel",
                                                 "tactic_category": "Prevent Faults",
                                                 "quality_attribute": "Availability", "tactic": "Predictive Model",
                                                 "description": "Used with monitors to ensure a system operates within nominal parameters and take corrective action for conditions predictive of future faults."},
                            "Exception Prevention": {"class_name": "ExceptionPreventionModel",
                                                     "tactic_category": "Prevent Faults",
                                                     "quality_attribute": "Availability",
                                                     "tactic": "Exception Prevention",
                                                     "description": "Techniques employed to prevent system exceptions from occurring."},
                            "Increase Competence Set": {"class_name": "IncreaseCompetenceSetModel",
                                                        "tactic_category": "Prevent Faults",
                                                        "quality_attribute": "Availability",
                                                        "tactic": "Increase Competence Set",
                                                        "description": "Expanding the set of states in which a program is competent to operate to handle more cases as part of normal operation."},
                            "Discover Service": {"class_name": "DiscoverServiceModel", "tactic_category": "Locate",
                                                 "quality_attribute": "Interoperability", "tactic": "Discover Service",
                                                 "description": "Locates a service through searching a known directory service at runtime."},
                            "Orchestrate": {"class_name": "OrchestrateModel", "tactic_category": "Manage Interfaces",
                                            "quality_attribute": "Interoperability", "tactic": "Orchestrate",
                                            "description": "Uses a control mechanism to coordinate, manage and sequence the invocation of particular services that could be ignorant of each other."},
                            "Tailor Interface": {"class_name": "TailorInterfaceModel",
                                                 "tactic_category": "Manage Interfaces",
                                                 "quality_attribute": "Interoperability", "tactic": "Tailor Interface",
                                                 "description": "Adds or removes capabilities to an interface, such as translation, buffering, or hiding particular functions from untrusted users."},
                            "Split Module": {"class_name": "SplitModuleModel",
                                             "tactic_category": "Reduce Size of a Module",
                                             "quality_attribute": "Modifiability", "tactic": "Split Module",
                                             "description": "Refining a module into several smaller modules to reduce the average cost of future changes."},
                            "Increase Semantic Coherence": {"class_name": "IncreaseSemanticCoherenceModel",
                                                            "tactic_category": "Increase Cohesion",
                                                            "quality_attribute": "Modifiability",
                                                            "tactic": "Increase Semantic Coherence",
                                                            "description": "Moving responsibilities that don't serve the same purpose to different modules to reduce the likelihood of side effects."},
                            "Encapsulate": {"class_name": "EncapsulateModel",
                                            "tactic_category": "Separate the User Interface",
                                            "quality_attribute": "Usability", "tactic": "Encapsulate",
                                            "description": "Localizes user interface responsibilities to a single place."},
                            "Use an Intermediary": {"class_name": "UseAnIntermediaryModel",
                                                    "tactic_category": "Reduce Coupling",
                                                    "quality_attribute": "Modifiability",
                                                    "tactic": "Use an Intermediary",
                                                    "description": "Breaking a dependency between responsibilities by using an intermediary that depends on the type of dependency."},
                            "Restrict Dependencies": {"class_name": "RestrictDependenciesModel",
                                                      "tactic_category": "Reduce Coupling",
                                                      "quality_attribute": "Modifiability",
                                                      "tactic": "Restrict Dependencies",
                                                      "description": "Restricting the modules that a given module interacts with or depends on through visibility or authorization."},
                            "Refactor": {"class_name": "RefactorModel", "tactic_category": "Reduce Coupling",
                                         "quality_attribute": "Modifiability", "tactic": "Refactor",
                                         "description": "Factoring out common responsibilities from modules where they exist and assigning them an appropriate home to reduce duplication."},
                            "Abstract Common Services": {"class_name": "AbstractCommonServicesModel",
                                                         "tactic_category": "Reduce Coupling",
                                                         "quality_attribute": "Modifiability",
                                                         "tactic": "Abstract Common Services",
                                                         "description": "Implementing similar services once in a more general (abstract) form to reduce modification costs."},
                            "Component Replacement": {"class_name": "ComponentReplacementModel",
                                                      "tactic_category": "Defer Binding",
                                                      "quality_attribute": "Modifiability",
                                                      "tactic": "Component Replacement",
                                                      "description": "Binding values at compile time or build time through replacement in build scripts or makefiles."},
                            "Compile-time Parameterization": {"class_name": "CompileTimeParameterizationModel",
                                                              "tactic_category": "Defer Binding",
                                                              "quality_attribute": "Modifiability",
                                                              "tactic": "Compile-time Parameterization",
                                                              "description": "Binding values at compile time through parameterization."},
                            "Aspects": {"class_name": "AspectsModel", "tactic_category": "Defer Binding",
                                        "quality_attribute": "Modifiability", "tactic": "Aspects",
                                        "description": "Binding values at compile time or build time using aspects."},
                            "Configuration-time Binding": {"class_name": "ConfigurationTimeBindingModel",
                                                           "tactic_category": "Defer Binding",
                                                           "quality_attribute": "Modifiability",
                                                           "tactic": "Configuration-time Binding",
                                                           "description": "Binding values at deployment time through configuration."},
                            "Resource Files": {"class_name": "ResourceFilesModel", "tactic_category": "Defer Binding",
                                               "quality_attribute": "Modifiability", "tactic": "Resource Files",
                                               "description": "Binding values at startup or initialization time using resource files."},
                            "Runtime Registration": {"class_name": "RuntimeRegistrationModel",
                                                     "tactic_category": "Defer Binding",
                                                     "quality_attribute": "Modifiability",
                                                     "tactic": "Runtime Registration",
                                                     "description": "Binding values at runtime through registration."},
                            "Dynamic Lookup": {"class_name": "DynamicLookupModel", "tactic_category": "Defer Binding",
                                               "quality_attribute": "Modifiability", "tactic": "Dynamic Lookup",
                                               "description": "Binding values at runtime through dynamic lookup for services."},
                            "Interpret Parameters": {"class_name": "InterpretParametersModel",
                                                     "tactic_category": "Defer Binding",
                                                     "quality_attribute": "Modifiability",
                                                     "tactic": "Interpret Parameters",
                                                     "description": "Binding values at runtime by interpreting parameters."},
                            "Startup Time Binding": {"class_name": "StartupTimeBindingModel",
                                                     "tactic_category": "Defer Binding",
                                                     "quality_attribute": "Modifiability",
                                                     "tactic": "Startup Time Binding",
                                                     "description": "Binding values at runtime during startup."},
                            "Name Servers": {"class_name": "NameServersModel", "tactic_category": "Defer Binding",
                                             "quality_attribute": "Modifiability", "tactic": "Name Servers",
                                             "description": "Binding values at runtime using name servers."},
                            "Plug-ins": {"class_name": "PlugInsModel", "tactic_category": "Defer Binding",
                                         "quality_attribute": "Modifiability", "tactic": "Plug-ins",
                                         "description": "Binding values at runtime through plug-ins."},
                            "Publish-Subscribe": {"class_name": "PublishSubscribeModel",
                                                  "tactic_category": "Defer Binding",
                                                  "quality_attribute": "Modifiability", "tactic": "Publish-Subscribe",
                                                  "description": "Binding values at runtime using the publish-subscribe pattern."},
                            "Shared Repositories": {"class_name": "SharedRepositoriesModel",
                                                    "tactic_category": "Defer Binding",
                                                    "quality_attribute": "Modifiability",
                                                    "tactic": "Shared Repositories",
                                                    "description": "Binding values at runtime through shared repositories."},
                            "Polymorphism": {"class_name": "PolymorphismModel", "tactic_category": "Defer Binding",
                                             "quality_attribute": "Modifiability", "tactic": "Polymorphism",
                                             "description": "Binding values at runtime using polymorphism."},
                            "Manage Sampling Rate": {"class_name": "ManageSamplingRateModel",
                                                     "tactic_category": "Control Resource Demand",
                                                     "quality_attribute": "Performance",
                                                     "tactic": "Manage Sampling Rate",
                                                     "description": "Reduce the frequency at which environmental data is captured to decrease demand, typically with some loss of fidelity."},
                            "Limit Event Response": {"class_name": "LimitEventResponseModel",
                                                     "tactic_category": "Control Resource Demand",
                                                     "quality_attribute": "Performance",
                                                     "tactic": "Limit Event Response",
                                                     "description": "Process events only up to a set maximum rate to ensure more predictable processing when events are processed."},
                            "Prioritize Events": {"class_name": "PrioritizeEventsModel",
                                                  "tactic_category": "Control Resource Demand",
                                                  "quality_attribute": "Performance", "tactic": "Prioritize Events",
                                                  "description": "Impose a priority scheme that ranks events according to how important it is to service them."},
                            "Reduce Overhead": {"class_name": "ReduceOverheadModel",
                                                "tactic_category": "Resource Adaptation",
                                                "quality_attribute": "Energy Efficiency", "tactic": "Reduce Overhead",
                                                "description": "Co-locating resources and removing intermediaries and abstractions to reduce computational overhead and energy demands."},
                            "Bound Execution Times": {"class_name": "BoundExecutionTimesModel",
                                                      "tactic_category": "Control Resource Demand",
                                                      "quality_attribute": "Performance",
                                                      "tactic": "Bound Execution Times",
                                                      "description": "Place a limit on how much execution time is used to respond to an event."},
                            "Increase Resource Efficiency": {"class_name": "IncreaseResourceEfficiencyModel",
                                                             "tactic_category": "Control Resource Demand",
                                                             "quality_attribute": "Performance",
                                                             "tactic": "Increase Resource Efficiency",
                                                             "description": "Improve the algorithms used in critical areas to decrease latency."},
                            "Increase Resources": {"class_name": "IncreaseResourcesModel",
                                                   "tactic_category": "Manage Resources",
                                                   "quality_attribute": "Performance", "tactic": "Increase Resources",
                                                   "description": "Use faster processors, additional processors, additional memory, and faster networks to reduce latency."},
                            "Introduce Concurrency": {"class_name": "IntroduceConcurrencyModel",
                                                      "tactic_category": "Manage Resources",
                                                      "quality_attribute": "Performance",
                                                      "tactic": "Introduce Concurrency",
                                                      "description": "Process requests in parallel to reduce the blocked time."},
                            "Maintain Multiple Copies of Computations": {
                                "class_name": "MaintainMultipleCopiesOfComputationsModel",
                                "tactic_category": "Manage Resources", "quality_attribute": "Performance",
                                "tactic": "Maintain Multiple Copies of Computations",
                                "description": "Use multiple servers in a client-server pattern as replicas of computation to reduce the contention."},
                            "Maintain Multiple Copies of Data": {"class_name": "MaintainMultipleCopiesOfDataModel",
                                                                 "tactic_category": "Manage Resources",
                                                                 "quality_attribute": "Performance",
                                                                 "tactic": "Maintain Multiple Copies of Data",
                                                                 "description": "Keep copies of data on storage with different access speeds to reduce the contention from multiple simultaneous accesses."},
                            "Bound Queue Sizes": {"class_name": "BoundQueueSizesModel",
                                                  "tactic_category": "Manage Resources",
                                                  "quality_attribute": "Performance", "tactic": "Bound Queue Sizes",
                                                  "description": "Control the maximum number of queued arrivals and consequently the resources used to process the arrivals."},
                            "Schedule Resources": {"class_name": "ScheduleResourcesModel",
                                                   "tactic_category": "Manage Resources",
                                                   "quality_attribute": "Performance", "tactic": "Schedule Resources",
                                                   "description": "Understand the characteristics of each resource's use and choose the scheduling strategy that is compatible with it."},
                            "Detect Intrusion": {"class_name": "DetectIntrusionModel",
                                                 "tactic_category": "Detect Attacks", "quality_attribute": "Security",
                                                 "tactic": "Detect Intrusion",
                                                 "description": "Comparison of network traffic or service request patterns within a system to a set of signatures or known patterns of malicious behavior stored in a database."},
                            "Detect Service Denial": {"class_name": "DetectServiceDenialModel",
                                                      "tactic_category": "Detect Attacks",
                                                      "quality_attribute": "Security",
                                                      "tactic": "Detect Service Denial",
                                                      "description": "Comparison of the pattern or signature of network traffic coming into a system to historic profiles of known denial-of-service attacks."},
                            "Verify Message Integrity": {"class_name": "VerifyMessageIntegrityModel",
                                                         "tactic_category": "Detect Attacks",
                                                         "quality_attribute": "Security",
                                                         "tactic": "Verify Message Integrity",
                                                         "description": "Employment of techniques such as checksums or hash values to verify the integrity of messages, resource files, deployment files, and configuration files."},
                            "Detect Message Delay": {"class_name": "DetectMessageDelayModel",
                                                     "tactic_category": "Detect Attacks",
                                                     "quality_attribute": "Security", "tactic": "Detect Message Delay",
                                                     "description": "Detection of potential man-in-the-middle attacks by checking the time that it takes to deliver a message to identify suspicious timing behavior."},
                            "Identify Actors": {"class_name": "IdentifyActorsModel",
                                                "tactic_category": "Resist Attacks", "quality_attribute": "Security",
                                                "tactic": "Identify Actors",
                                                "description": "Identifying the source of any external input to the system, typically through user IDs, access codes, IP addresses, protocols, and ports."},
                            "Authenticate Actors": {"class_name": "AuthenticateActorsModel",
                                                    "tactic_category": "Resist Attacks",
                                                    "quality_attribute": "Security", "tactic": "Authenticate Actors",
                                                    "description": "Ensuring that an actor is actually who or what it purports to be through passwords, one-time passwords, digital certificates, and biometric identification."},
                            "Authorize Actors": {"class_name": "AuthorizeActorsModel",
                                                 "tactic_category": "Resist Attacks", "quality_attribute": "Security",
                                                 "tactic": "Authorize Actors",
                                                 "description": "Ensuring that an authenticated actor has the rights to access and modify either data or services through access control mechanisms."},
                            "Limit Access": {"class_name": "LimitAccessModel", "tactic_category": "Resist Attacks",
                                             "quality_attribute": "Security", "tactic": "Limit Access",
                                             "description": "Limiting access to computing resources such as memory, network connections, or access points by using memory protection, blocking a host, closing a port, or rejecting a protocol."},
                            "Limit Exposure": {"class_name": "LimitExposureModel", "tactic_category": "Resist Attacks",
                                               "quality_attribute": "Security", "tactic": "Limit Exposure",
                                               "description": "Minimizing the attack surface of a system by reducing the number of access points for resources, data, or services and connectors that may provide unanticipated exposure."},
                            "Encrypt Data": {"class_name": "EncryptDataModel", "tactic_category": "Resist Attacks",
                                             "quality_attribute": "Security", "tactic": "Encrypt Data",
                                             "description": "Protecting data from unauthorized access by applying some form of encryption to data and to communication."},
                            "Separate Entities": {"class_name": "SeparateEntitiesModel",
                                                  "tactic_category": "Resist Attacks", "quality_attribute": "Security",
                                                  "tactic": "Separate Entities",
                                                  "description": "Separating different entities within the system through physical separation, virtual machines, air gaps, or separation of sensitive from nonsensitive data."},
                            "Change Default Settings": {"class_name": "ChangeDefaultSettingsModel",
                                                        "tactic_category": "Resist Attacks",
                                                        "quality_attribute": "Security",
                                                        "tactic": "Change Default Settings",
                                                        "description": "Forcing users to change default settings to prevent attackers from gaining access to the system through publicly available settings."},
                            "Revoke Access": {"class_name": "RevokeAccessModel", "tactic_category": "React to Attacks",
                                              "quality_attribute": "Security", "tactic": "Revoke Access",
                                              "description": "Severely limiting access to sensitive resources when the system or administrator believes that an attack is underway."},
                            "Lock Computer": {"class_name": "LockComputerModel", "tactic_category": "React to Attacks",
                                              "quality_attribute": "Security", "tactic": "Lock Computer",
                                              "description": "Limiting access from a particular computer if there are repeated failed attempts to access an account from that computer."},
                            "Inform Actors": {"class_name": "InformActorsModel", "tactic_category": "React to Attacks",
                                              "quality_attribute": "Security", "tactic": "Inform Actors",
                                              "description": "Notifying relevant personnel or cooperating systems when the system has detected an attack."},
                            "Maintain Audit Trail": {"class_name": "MaintainAuditTrailModel",
                                                     "tactic_category": "Recover from Attacks",
                                                     "quality_attribute": "Security", "tactic": "Maintain Audit Trail",
                                                     "description": "Keeping a record of user and system actions and their effects to help trace the actions of, and to identify, an attacker."},
                            "Restore": {"class_name": "RestoreModel", "tactic_category": "Recover from Attacks",
                                        "quality_attribute": "Security", "tactic": "Restore",
                                        "description": "Restoration of services after an attack using tactics that deal with recovering from a failure."},
                            "Specialized Interfaces": {"class_name": "SpecializedInterfacesModel",
                                                       "tactic_category": "Control and Observe System State",
                                                       "quality_attribute": "Testability",
                                                       "tactic": "Specialized Interfaces",
                                                       "description": "Providing test-specific interfaces that allow testers to control or observe component variables and states that might otherwise be inaccessible."},
                            "Record/Playback": {"class_name": "RecordPlaybackModel",
                                                "tactic_category": "Control and Observe System State",
                                                "quality_attribute": "Testability", "tactic": "Record/Playback",
                                                "description": "Capturing the state when it crosses an interface to allow that state to be used to \"play the system back\" and re-create faults."},
                            "Localize State Storage": {"class_name": "LocalizeStateStorageModel",
                                                       "tactic_category": "Control and Observe System State",
                                                       "quality_attribute": "Testability",
                                                       "tactic": "Localize State Storage",
                                                       "description": "Storing state in a single place to make it easier to set the system to an arbitrary state for testing."},
                            "Abstract Data Sources": {"class_name": "AbstractDataSourcesModel",
                                                      "tactic_category": "Control and Observe System State",
                                                      "quality_attribute": "Testability",
                                                      "tactic": "Abstract Data Sources",
                                                      "description": "Designing interfaces to easily substitute test data without changing functional code."},
                            "Sandbox": {"class_name": "SandboxModel",
                                        "tactic_category": "Control and Observe System State",
                                        "quality_attribute": "Testability", "tactic": "Sandbox",
                                        "description": "Isolating the system from the real world to enable experimentation without permanent consequences."},
                            "Executable Assertions": {"class_name": "ExecutableAssertionsModel",
                                                      "tactic_category": "Control and Observe System State",
                                                      "quality_attribute": "Testability",
                                                      "tactic": "Executable Assertions",
                                                      "description": "Placing code at strategic locations to indicate when a program is in a faulty state."},
                            "Limit Structural Complexity": {"class_name": "LimitStructuralComplexityModel",
                                                            "tactic_category": "Limit Complexity",
                                                            "quality_attribute": "Testability",
                                                            "tactic": "Limit Structural Complexity",
                                                            "description": "Reducing dependencies between components, simplifying inheritance hierarchies, and increasing cohesion to make behavior more predictable and easier to test."},
                            "Limit Nondeterminism": {"class_name": "LimitNondeterminismModel",
                                                     "tactic_category": "Limit Complexity",
                                                     "quality_attribute": "Testability",
                                                     "tactic": "Limit Nondeterminism",
                                                     "description": "Finding and eliminating sources of unpredictable behavior to make testing more reliable."},
                            "Increase semantic coherence": {"class_name": "IncreaseSemanticCoherenceModel",
                                                            "tactic_category": "Separate the User Interface",
                                                            "quality_attribute": "Usability",
                                                            "tactic": "Increase semantic coherence",
                                                            "description": "Localizes user interface responsibilities to a single place."},
                            "Co-locate related responsibilities": {"class_name": "CoLocateRelatedResponsibilitiesModel",
                                                                   "tactic_category": "Separate the User Interface",
                                                                   "quality_attribute": "Usability",
                                                                   "tactic": "Co-locate related responsibilities",
                                                                   "description": "Localizes user interface responsibilities to a single place."},
                            "Restrict dependencies": {"class_name": "RestrictDependenciesModel",
                                                      "tactic_category": "Separate the User Interface",
                                                      "quality_attribute": "Usability",
                                                      "tactic": "Restrict dependencies",
                                                      "description": "Minimizes the ripple effect to other software when the user interface changes."},
                            "Defer binding": {"class_name": "DeferBindingModel",
                                              "tactic_category": "Separate the User Interface",
                                              "quality_attribute": "Usability", "tactic": "Defer binding",
                                              "description": "Lets you make critical user interface choices without having to recode."},
                            "Cancel": {"class_name": "CancelModel", "tactic_category": "Support User Initiative",
                                       "quality_attribute": "Usability", "tactic": "Cancel",
                                       "description": "Allows the user to terminate a command with appropriate resource management and notification."},
                            "Undo": {"class_name": "UndoModel", "tactic_category": "Support User Initiative",
                                     "quality_attribute": "Usability", "tactic": "Undo",
                                     "description": "Maintains sufficient information about system state so that an earlier state may be restored at the user's request."},
                            "Pause/resume": {"class_name": "PauseResumeModel",
                                             "tactic_category": "Support User Initiative",
                                             "quality_attribute": "Usability", "tactic": "Pause/resume",
                                             "description": "Provides the ability to temporarily free resources so they may be reallocated to other tasks."},
                            "Aggregate": {"class_name": "AggregateModel", "tactic_category": "Support User Initiative",
                                          "quality_attribute": "Usability", "tactic": "Aggregate",
                                          "description": "Allows operations to be applied to a group of objects, freeing the user from repetitive operations."},
                            "Maintain task model": {"class_name": "MaintainTaskModelModel",
                                                    "tactic_category": "Support System Initiative",
                                                    "quality_attribute": "Usability", "tactic": "Maintain task model",
                                                    "description": "Determines context so the system can have some idea of what the user is attempting and provide assistance."},
                            "Maintain user model": {"class_name": "MaintainUserModelModel",
                                                    "tactic_category": "Support System Initiative",
                                                    "quality_attribute": "Usability", "tactic": "Maintain user model",
                                                    "description": "Explicitly represents the user's knowledge of the system to control response time and assistance."},
                            "Maintain system model": {"class_name": "MaintainSystemModelModel",
                                                      "tactic_category": "Support System Initiative",
                                                      "quality_attribute": "Usability",
                                                      "tactic": "Maintain system model",
                                                      "description": "Determines expected system behavior so that appropriate feedback can be given to the user."},
                            "Metering": {"class_name": "MeteringModel", "tactic_category": "Resource Monitoring",
                                         "quality_attribute": "Energy Efficiency", "tactic": "Metering",
                                         "description": "Collecting data about the energy consumption of computational devices via a sensor infrastructure in real time."},
                            "Static Classification": {"class_name": "StaticClassificationModel",
                                                      "tactic_category": "Resource Monitoring",
                                                      "quality_attribute": "Energy Efficiency",
                                                      "tactic": "Static Classification",
                                                      "description": "Statically classifying devices and computational resources based on benchmarking or reported device characteristics when real-time data collection is infeasible."},
                            "Dynamic Classification": {"class_name": "DynamicClassificationModel",
                                                       "tactic_category": "Resource Monitoring",
                                                       "quality_attribute": "Energy Efficiency",
                                                       "tactic": "Dynamic Classification",
                                                       "description": "Using dynamic models that take into consideration transient conditions to determine energy consumption when real-time data collection is infeasible."},
                            "Vertical Scaling": {"class_name": "VerticalScalingModel",
                                                 "tactic_category": "Resource Allocation",
                                                 "quality_attribute": "Energy Efficiency", "tactic": "Vertical Scaling",
                                                 "description": "Adding or activating resources to meet processing demands, or removing/deactivating resources when demands no longer require them."},
                            "Horizontal Scaling": {"class_name": "HorizontalScalingModel",
                                                   "tactic_category": "Resource Allocation",
                                                   "quality_attribute": "Energy Efficiency",
                                                   "tactic": "Horizontal Scaling",
                                                   "description": "Adding additional servers, VMs, or resources to an existing pool for scaling up, or removing/idling such resources for energy efficiency."},
                            "Scheduling": {"class_name": "SchedulingModel", "tactic_category": "Resource Allocation",
                                           "quality_attribute": "Energy Efficiency", "tactic": "Scheduling",
                                           "description": "Allocating tasks to computational resources to optimize energy usage while respecting task constraints and priorities."},
                            "Brokering": {"class_name": "BrokeringModel", "tactic_category": "Resource Allocation",
                                          "quality_attribute": "Energy Efficiency", "tactic": "Brokering",
                                          "description": "Matching service requests with service providers based on energy information to allow choosing providers based on their energy characteristics."},
                            "Service Adaptation": {"class_name": "ServiceAdaptationModel",
                                                   "tactic_category": "Resource Adaptation",
                                                   "quality_attribute": "Energy Efficiency",
                                                   "tactic": "Service Adaptation",
                                                   "description": "Dynamically switching computational resources to ones that offer better energy efficiency or lower energy costs."},
                            "Increase Efficiency": {"class_name": "IncreaseEfficiencyModel",
                                                    "tactic_category": "Resource Adaptation",
                                                    "quality_attribute": "Energy Efficiency",
                                                    "tactic": "Increase Efficiency",
                                                    "description": "Improving the time or memory performance of critical algorithms to enhance energy efficiency, or matching service requests to hardware best suited for those requests."}}
